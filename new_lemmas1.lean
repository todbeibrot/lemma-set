import imports
lemma new_lemma_8000 (h0 : topological_space (ordered_comm_ring (add_cancel_monoid linarith.comp))) : irreducible_space (ordered_comm_ring (add_cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_8001 (h0 : nat -> group (has_append to_additive.value_type) -> group (has_append to_additive.value_type)) (h1 : nat) (h2 : group (has_append to_additive.value_type)) : is_cyclic (has_append to_additive.value_type) := sorry --non-trivial
lemma new_lemma_8002 (h0 : ring (comm_monoid (semiring (semiring unsigned)))) : rank_condition (comm_monoid (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_8003 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) (ring (finset environment.implicit_infer_kind))) : @preirreducible_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) (ring.{0} (finset.{0} environment.implicit_infer_kind)) h0)  := sorry --non-trivial
lemma new_lemma_8004 (h0 : topological_space (canonically_ordered_monoid linarith.comp)) : path_connected_space (canonically_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_8005 (h0 : list (has_nndist (finset (finset (has_add name))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_8006 (h0 : function.extfun Type (functor.comp topological_space mul_zero_class)) : @irreducible_space.{0} (mul_zero_class.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} mul_zero_class.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_8007 (h0 : group (has_Inf (boolean_algebra.core (has_add (has_pos_part linarith.comp))))) : group.fg (has_Inf (boolean_algebra.core (has_add (has_pos_part linarith.comp)))) := sorry --non-trivial
lemma new_lemma_8008 (h0 : uniform_space (cancel_monoid (boolean_algebra environment.implicit_infer_kind))) : separated_space (cancel_monoid (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_8009 (h0 : functor.add_const (complete_lattice (cancel_monoid name)) linarith.comp) : @is_compactly_generated.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_8010 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (random_gen num)) := sorry --non-trivial
lemma new_lemma_8011 (h0 : ring (semi_normed_comm_ring std_gen)) : is_domain (semi_normed_comm_ring std_gen) := sorry --non-trivial
lemma new_lemma_8012 (h0 : topological_space (partial_order unsigned)) : locally_compact_space (partial_order unsigned) := sorry --non-trivial
lemma new_lemma_8013 (h1 : not (ring (has_emptyc linarith.comp_source) -> false)) : @strong_rank_condition.{0} (has_emptyc.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (has_emptyc.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_8014 (h0 : topological_space (complete_distrib_lattice (has_nndist (has_nndist Type)))) : totally_separated_space (complete_distrib_lattice (has_nndist (has_nndist Type))) := sorry --non-trivial
lemma new_lemma_8015 (h0 : topological_space (simple_graph (has_neg (has_neg linarith.comp)))) : preconnected_space (simple_graph (has_neg (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_8016 (h0 : complete_lattice (left_cancel_semigroup (semiring num))) : complete_lattice.is_Sup_finite_compact (left_cancel_semigroup (semiring num)) := sorry --non-trivial
lemma new_lemma_8017 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_8018 (h0 : complete_lattice (cancel_monoid (has_add environment.implicit_infer_kind))) : is_compactly_generated (cancel_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_8019 (h0 : complete_lattice (has_nndist (option (option (option (option unsigned)))))) : is_atomistic (has_nndist (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_8020 (h0 : function.extfun Type (functor.add_const (topological_space (has_Sup empty)))) : @preconnected_space.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_Sup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_8021 (h0 : ring (has_nnnorm (mul_one_class string.iterator_imp))) : rank_condition (has_nnnorm (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_8022 (h0 : ring (normed_comm_ring (finset pos))) : rank_condition (normed_comm_ring (finset pos)) := sorry --non-trivial
lemma new_lemma_8023 (h0 : uniform_space (has_append (has_nnnorm reducibility_hints))) : complete_space (has_append (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_8024 (h0 : nat) (h1 h2 : fin h0) : fin.lt (id h1) h2 := sorry --non-trivial
lemma new_lemma_8025 (h0 : finset (linear_ordered_field num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_8026 (h0 : functor.add_const (ordered_add_comm_monoid (finset Type)) linarith.comp) : @archimedean.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (finset.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_8027 (h0 : topological_space (has_dist ennreal)) : locally_compact_space (has_dist ennreal) := sorry --non-trivial
lemma new_lemma_8028 (h0 : functor.add_const (group (normed_comm_ring pos)) name) : @normalizer_condition.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_8029 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (canonically_ordered_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (canonically_ordered_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_8030 (h0 : functor.add_const (complete_lattice (has_neg_part name)) (has_add ennreal)) : @is_compactly_generated.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg_part.{0} name)) (has_add.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_8031 (h0 : functor.comp complete_lattice comm_group Type) : @is_compactly_generated.{1} (comm_group.{1} Type) (@functor.comp.run.{1 1 1} complete_lattice.{1} comm_group.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_8032 (h0 : not (add_group (linear_ordered_semiring unsigned) -> false)) : @is_add_cyclic.{0} (linear_ordered_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (add_group.{0} (linear_ordered_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_8033 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_disconnected_space.{0} to_additive.value_type (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_8034 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) environment.implicit_infer_kind) : @locally_compact_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_8035 (h1 : complete_lattice (random_gen reducibility_hints)) : complete_lattice.is_Sup_finite_compact (random_gen reducibility_hints) := sorry --non-trivial
lemma new_lemma_8036 (h0 : functor.add_const (semiring (add_comm_monoid linarith.comp)) (has_to_string name)) : @is_noetherian_ring.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (add_comm_monoid.{0} linarith.comp)) (has_to_string.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_8037 (h0 : not (complete_lattice (has_compl reducibility_hints) -> false)) : @is_atomistic.{0} (has_compl.{0} reducibility_hints) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_compl.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_8038 (h0 : function.extfun Type group) : @normalizer_condition.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_8039 (h0 : group (has_pos_part (has_neg name))) : is_simple_group (has_pos_part (has_neg name)) := sorry --non-trivial
lemma new_lemma_8040 (h0 : cancel_comm_monoid_with_zero (monoid (option empty))) : unique_factorization_monoid (monoid (option empty)) := sorry --non-trivial
lemma new_lemma_8041 (h0 : uniform_space (normed_comm_ring (finset (finset (has_zero (finset linarith.comp)))))) : separated_space (normed_comm_ring (finset (finset (has_zero (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_8042 (h0 : has_star (semiring (semiring empty)) -> has_star (semiring (semiring empty)) -> Prop) : is_strict_order (has_star (semiring (semiring empty))) h0 := sorry --non-trivial
lemma new_lemma_8043 (h0 : topological_space (has_neg_part (ring (option (option (ring pos)))))) : regular_space (has_neg_part (ring (option (option (ring pos))))) := sorry --non-trivial
lemma new_lemma_8044 (h1 : list (measurable_space (random_gen string_imp))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_8045 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_8046 (h0 : group (has_emptyc to_additive.value_type)) : normalizer_condition (has_emptyc to_additive.value_type) := sorry --non-trivial
lemma new_lemma_8047 (h0 : complete_lattice (normed_group (semiring unsigned))) : complete_lattice.is_Sup_finite_compact (normed_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_8048 (h0 : functor.add_const (topological_space (has_to_string pos)) (has_Inf pos)) : @locally_compact_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_8049 (h0 : filter (has_top (has_inv to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_8050 (h1 : function.extfun Type topological_space) : @t0_space.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_8051 (h0 : list (has_neg (has_pos_part (has_add pos)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_8052 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_8053 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @regular_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_8054 (h0 : monoid (non_assoc_semiring (semiring (semiring unsigned)))) : monoid.fg (non_assoc_semiring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_8055 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_8056 (h0 : has_mem.mem add_monoid has_emptyc.emptyc) : @add_monoid.fg.{0} (metric_space.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_monoid.{0} h0) (metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_8057 (h0 : functor.add_const (topological_space (pseudo_metric_space name)) unsigned) : @regular_space.{0} (pseudo_metric_space.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_8058 (h1 : complete_lattice (random_gen (random_gen string_imp))) : is_compactly_generated (random_gen (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_8059 (h0 : has_mem.mem (has_emptyc empty) has_emptyc.emptyc) : @locally_compact_space.{0} (has_emptyc.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_8060 (h0 : finset (has_pos_part (has_add (has_Inf (has_pos_part Type))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_8061 (h0 : functor.add_const (semiring (as_linear_order empty)) num) : @is_noetherian_ring.{0} (as_linear_order.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (as_linear_order.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_8062 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (has_inv.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_inv.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_8063 (h0 : group (comm_ring (random_gen (random_gen to_additive.value_type)))) : group.fg (comm_ring (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_8064 (h0 : functor.add_const (semiring (simple_graph linarith.comp)) (has_neg name)) : @is_noetherian_ring.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (simple_graph.{0} linarith.comp)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_8065 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_domain.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_8066 (h0 : complete_lattice (fintype (has_append to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (fintype (has_append to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_8067 (h0 : topological_space (has_neg_part (has_neg_part unsigned))) : totally_disconnected_space (has_neg_part (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_8068 (h0 : topological_space (has_nndist name)) : loc_path_connected_space (has_nndist name) := sorry --non-trivial
lemma new_lemma_8069 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) linarith.comp) : @irreducible_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_8070 (h0 : topological_space (id (random_gen (has_top (has_top linarith.comp_source))))) : totally_separated_space (id (random_gen (has_top (has_top linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_8071 (h0 h1 : multiset (has_le char)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_8072 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @monoid.fg.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 monoid.{1}) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_8073 (h0 : filter (has_append char)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_8074 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_8075 (h1 : complete_lattice (distrib_lattice char)) : is_compactly_generated (distrib_lattice char) := sorry --non-trivial
lemma new_lemma_8076 (h0 : group to_additive.value_type) : normalizer_condition to_additive.value_type := sorry --non-trivial
lemma new_lemma_8077 (h0 : complete_lattice (comm_ring (has_nnnorm linarith.ineq))) : complete_lattice.is_Sup_finite_compact (comm_ring (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_8078 (h0 : complete_lattice (has_lt to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (has_lt to_additive.value_type) := sorry --non-trivial
lemma new_lemma_8079 (h1 : uniform_space (with_one (has_norm fun_info))) : complete_space (with_one (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_8080 (h0 : uniform_space (uniform_space (mul_one_class enat))) : complete_space (uniform_space (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_8081 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_8082 (h0 : function.extfun nat fin) : @group.fg.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (group.{0} (comm_semigroup.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_8083 (h0 : group (simple_graph Type)) : is_cyclic (simple_graph Type) := sorry --non-trivial
lemma new_lemma_8084 (h0 : topological_space (canonically_ordered_comm_semiring environment.implicit_infer_kind)) : normal_space (canonically_ordered_comm_semiring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_8085 (h0 : complete_lattice (linear_ordered_add_comm_group (has_top fun_info))) : is_compactly_generated (linear_ordered_add_comm_group (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_8086 (h0 : topological_space (ordered_comm_ring (has_Inf real))) : irreducible_space (ordered_comm_ring (has_Inf real)) := sorry --non-trivial
lemma new_lemma_8087 (h0 : functor.add_const Prop (option empty)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_8088 (h2 : ring (uniform_space linarith.ineq)) : strong_rank_condition (uniform_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_8089 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_8090 (h0 : topological_space (metric_space (measurable_space.dynkin_system (semiring unsigned)))) : path_connected_space (metric_space (measurable_space.dynkin_system (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_8091 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_8092 (h0 : group (canonically_ordered_comm_semiring ennreal)) : is_cyclic (canonically_ordered_comm_semiring ennreal) := sorry --non-trivial
lemma new_lemma_8093 (h0 : topological_space (has_add environment.implicit_infer_kind)) : normal_space (has_add environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_8094 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) linarith.comp) : @topological_space.separable_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_8095 (h0 : uniform_space (has_bot (sub_neg_monoid (has_add real)))) : separated_space (has_bot (sub_neg_monoid (has_add real))) := sorry --non-trivial
lemma new_lemma_8096 (h0 : cancel_comm_monoid_with_zero (with_bot unsigned)) : unique_factorization_monoid (with_bot unsigned) := sorry --non-trivial
lemma new_lemma_8097 (h0 : monoid (has_top (has_top empty))) : monoid.fg (has_top (has_top empty)) := sorry --non-trivial
lemma new_lemma_8098 (h1 : semiring (nondiscrete_normed_field linarith.ineq)) (h2 : ideal (nondiscrete_normed_field linarith.ineq)) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_8099 (h0 : ring (semigroup (has_add (has_add name)))) : strong_rank_condition (semigroup (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_8100 (h0 : uniform_space (linear_ordered_semiring (semiring fun_info))) : complete_space (linear_ordered_semiring (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_8101 (h0 : group (simple_graph (has_neg linarith.comp))) : group.fg (simple_graph (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_8102 (h0 : ring (canonically_ordered_comm_semiring (has_nndist (has_add ennreal)))) : strong_rank_condition (canonically_ordered_comm_semiring (has_nndist (has_add ennreal))) := sorry --non-trivial
lemma new_lemma_8103 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (as_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (as_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_8104 (h0 : uniform_space (random_gen (random_gen (has_inv (random_gen (random_gen (random_gen fun_info))))))) : complete_space (random_gen (random_gen (has_inv (random_gen (random_gen (random_gen fun_info)))))) := sorry --non-trivial
lemma new_lemma_8105 (h1 : uniform_space (encodable (random_gen char))) : complete_space (encodable (random_gen char)) := sorry --non-trivial
lemma new_lemma_8106 (h0 : topological_space (has_nndist (has_Inf (ring (has_pos_part Type))))) : t0_space (has_nndist (has_Inf (ring (has_pos_part Type)))) := sorry --non-trivial
lemma new_lemma_8107 (h0 : finset (semigroup (finset Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_8108 (h0 : topological_space (complete_distrib_lattice (option (option (option ennreal))))) : normal_space (complete_distrib_lattice (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_8109 (h1 : ring (normed_group (has_top (has_norm empty)))) : is_domain (normed_group (has_top (has_norm empty))) := sorry --non-trivial
lemma new_lemma_8110 (h0 : function.extfun Type group) : @is_simple_group.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_8111 (h0 : topological_space (linear_ordered_comm_group (option (option empty)))) : totally_disconnected_space (linear_ordered_comm_group (option (option empty))) := sorry --non-trivial
lemma new_lemma_8112 (h0 : ordered_comm_monoid (has_bot (has_bot name))) : has_exists_mul_of_le (has_bot (has_bot name)) := sorry --non-trivial
lemma new_lemma_8113 (h0 : add_group (canonically_ordered_comm_semiring pos)) : is_add_cyclic (canonically_ordered_comm_semiring pos) := sorry --non-trivial
lemma new_lemma_8114 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_8115 (h0 : complete_lattice (has_norm (has_top fun_info))) : is_atomistic (has_norm (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_8116 (h1 : not (ring (normed_field string_imp) -> false)) : @rank_condition.{0} (normed_field.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (normed_field.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_8117 (h0 : complete_lattice (comm_ring (random_gen (mul_one_class linarith.comp_source)))) : is_compactly_generated (comm_ring (random_gen (mul_one_class linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_8118 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) Type) : @separated_space.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) uniform_space.{1}) Type h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_8119 (h0 : functor.comp topological_space has_nndist name) : @totally_separated_space.{0} (has_nndist.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} name h0)))))))))))))))))))))))))))))))))))))))))))))))))))  := sorry --non-trivial
lemma new_lemma_8120 (h0 : topological_space (distrib (has_nnnorm (random_gen (random_gen char))))) : totally_disconnected_space (distrib (has_nnnorm (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_8121 (h0 : has_le (has_add (has_add (random_gen string_imp)))) (h1 : bounded_order (has_add (has_add (random_gen string_imp)))) : is_simple_order (has_add (has_add (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_8122 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @normalizer_condition.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_8123 (h0 : function.extfun Type ring) : @is_domain.{0} (is_R_or_C.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (is_R_or_C.{0} empty))  := sorry --non-trivial
lemma new_lemma_8124 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) name) : @t1_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_8125 (h0 : group (boolean_algebra.core (finset Type))) : group.fg (boolean_algebra.core (finset Type)) := sorry --non-trivial
lemma new_lemma_8126 (h0 : functor.add_const (topological_space (finset name)) Type) : @preirreducible_space.{0} (finset.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_8127 (h0 : filter (normed_group unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_8128 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_8129 (h0 : uniform_space (has_norm (has_top (random_gen congr_arg_kind)))) : separated_space (has_norm (has_top (random_gen congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_8130 (h0 : ring (div_inv_monoid (random_gen fun_info))) : rank_condition (div_inv_monoid (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_8131 (h0 : filter (with_bot (has_top empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_8132 (h0 : ordered_add_comm_monoid (has_pos_part (has_add (has_add pos)))) : archimedean (has_pos_part (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_8133 (h0 : functor.add_const (monoid (semigroup empty)) unsigned) : @monoid.fg.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (semigroup.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_8134 (h0 : group (id (has_norm num))) : normalizer_condition (id (has_norm num)) := sorry --non-trivial
lemma new_lemma_8135 (h0 : set (non_unital_non_assoc_semiring (random_gen (random_gen to_additive.value_type)))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_8136 (h0 : function.extfun Type group) : @group.fg.{0} (has_neg_part.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_neg_part.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_8137 (h0 : functor.comp group mul_zero_class name) : @is_simple_group.{0} (mul_zero_class.{0} name) (@functor.comp.run.{0 0 0} group.{0} mul_zero_class.{0} name h0)  := sorry --non-trivial
lemma new_lemma_8138 (h0 : option empty -> num -> Prop) : relator.bi_total h0 := sorry --non-trivial
lemma new_lemma_8139 (h0 : functor.add_const (ring (finset Type)) linarith.comp) : @strong_rank_condition.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (finset.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_8140 (h0 : functor.add_const (ring (complete_distrib_lattice unsigned)) (normed_comm_ring Type)) : @rank_condition.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 1} (ring.{0} (complete_distrib_lattice.{0} unsigned)) (normed_comm_ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_8141 (h0 : filter (ring (boolean_algebra Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_8142 (h0 : topological_space (comm_group (ring name))) : irreducible_space (comm_group (ring name)) := sorry --non-trivial
lemma new_lemma_8143 (h0 : functor.add_const (monoid (has_to_string pos)) environment.implicit_infer_kind) : @monoid.fg.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (has_to_string.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_8144 (h0 : topological_space (add_cancel_monoid (semigroup Type))) : preirreducible_space (add_cancel_monoid (semigroup Type)) := sorry --non-trivial
lemma new_lemma_8145 (h0 : prod (linear_ordered_comm_ring num) (linear_ordered_comm_ring num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_8146 (h0 : functor.add_const (complete_lattice (has_neg_part name)) environment.implicit_infer_kind) : @is_compactly_generated.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg_part.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_8147 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_8148 (h0 : function.extfun Type (functor.add_const (ordered_add_comm_monoid (ordered_cancel_add_comm_monoid ennreal)))) : @archimedean.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ordered_cancel_add_comm_monoid.{0} ennreal)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} (ordered_cancel_add_comm_monoid.{0} ennreal))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_8149 (h1 : ring (uniform_space string.iterator_imp)) : strong_rank_condition (uniform_space string.iterator_imp) := sorry --non-trivial
lemma new_lemma_8150 (h0 : function.extfun Type group) : @group.fg.{0} (random_gen.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (random_gen.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_8151 (h0 : not (has_mem.mem (function.extfun Type) has_emptyc.emptyc -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{0} (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (finset.{2} ((Type → Type) → Type 1)) (@finset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type) (@has_emptyc.emptyc.{2} (finset.{2} ((Type → Type) → Type 1)) (@finset.has_emptyc.{2} ((Type → Type) → Type 1)))) h0)) complete_lattice.{0}) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_8152 (h0 : functor.add_const (ring (has_Inf linarith.comp)) (has_neg (has_neg (ring (has_neg name))))) : @is_domain.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_Inf.{0} linarith.comp)) (has_neg.{0} (has_neg.{0} (ring.{0} (has_neg.{0} name)))) h0)  := sorry --non-trivial
lemma new_lemma_8153 (h0 : functor.add_const (complete_lattice (has_add linarith.comp)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_add.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_8154 (h0 : functor.add_const (ordered_comm_monoid (has_add linarith.comp)) Type) : @has_exists_mul_of_le.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (has_add.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_8155 (h0 : group (has_norm (has_norm linarith.ineq))) : group.fg (has_norm (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_8156 (h0 : topological_space (measurable_space.dynkin_system (option empty))) : loc_path_connected_space (measurable_space.dynkin_system (option empty)) := sorry --non-trivial
lemma new_lemma_8157 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} unsigned (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) unsigned)  := sorry --non-trivial
lemma new_lemma_8158 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_8159 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_8160 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} unsigned (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) unsigned)  := sorry --non-trivial
lemma new_lemma_8161 (h0 : functor.add_const (complete_lattice (ordered_cancel_add_comm_monoid empty)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_cancel_add_comm_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_8162 (h0 : topological_space (random_gen (mul_one_class linarith.ineq))) : path_connected_space (random_gen (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_8163 (h0 : ring (with_one linarith.ineq)) : is_domain (with_one linarith.ineq) := sorry --non-trivial
lemma new_lemma_8164 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_8165 (h2 : has_mem.mem (random_gen congr_arg_kind) has_emptyc.emptyc) : @irreducible_space.{0} (random_gen.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} congr_arg_kind) h2)  := sorry --non-trivial
lemma new_lemma_8166 (h0 : function.extfun (finset Type) (has_mem.mem (semiring congr_arg_kind))) : @separated_space.{0} (semiring.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type uniform_space.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_8167 (h1 : denumerable (denumerable (denumerable (comm_ring (comm_ring char)))) -> char -> char) : left_commutative h1 := sorry --non-trivial
lemma new_lemma_8168 (h0 : cancel_comm_monoid_with_zero (semigroup (has_neg_part Type))) : unique_factorization_monoid (semigroup (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_8169 (h0 : topological_space (measurable_space.dynkin_system (semiring empty))) : preirreducible_space (measurable_space.dynkin_system (semiring empty)) := sorry --non-trivial
lemma new_lemma_8170 (h0 : add_group (semigroup (has_neg environment.implicit_infer_kind))) : is_add_cyclic (semigroup (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_8171 (h0 : functor.add_const (topological_space (option pos)) pos) : @path_connected_space.{0} (option.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_8172 (h0 : functor.add_const (finset (finset pos)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_8173 (h0 : fin has_zero.zero) : @discrete_topology.{0} (linear_ordered_semiring.{0} (semiring.{0} (semiring.{0} congr_arg_kind))) (@matrix.vec_empty.{0} (topological_space.{0} (linear_ordered_semiring.{0} (semiring.{0} (semiring.{0} congr_arg_kind)))) h0)  := sorry --non-trivial
lemma new_lemma_8174 (h0 : functor.add_const (semiring (has_nndist num)) num) : @is_noetherian_ring.{0} (has_nndist.{0} num) (@functor.add_const.run.{0 0} (semiring.{0} (has_nndist.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_8175 (h0 : ring (has_dist (comm_monoid (comm_monoid unsigned)))) : is_domain (has_dist (comm_monoid (comm_monoid unsigned))) := sorry --non-trivial
lemma new_lemma_8176 (h0 : functor.add_const (add_monoid (add_cancel_monoid pos)) name) : @add_monoid.fg.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (add_cancel_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_8177 (h0 : ring (cancel_monoid (finset ennreal))) : strong_rank_condition (cancel_monoid (finset ennreal)) := sorry --non-trivial
lemma new_lemma_8178 (h0 : topological_space (add_cancel_comm_monoid (mul_one_class linarith.ineq))) : t0_space (add_cancel_comm_monoid (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_8179 (h0 : functor.add_const (function.extfun Type complete_lattice) linarith.comp) : @is_compactly_generated.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) linarith.comp h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_8180 (h0 : ordered_add_comm_monoid (has_Inf (ring Type))) : archimedean (has_Inf (ring Type)) := sorry --non-trivial
lemma new_lemma_8181 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @irreducible_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_8182 (h0 : group (has_pos_part (finset (has_neg pos)))) : group.fg (has_pos_part (finset (has_neg pos))) := sorry --non-trivial
lemma new_lemma_8183 (h0 : function.extfun (Type 1) semiring) : @is_noetherian_ring.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} h0 (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_8184 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_8185 (h0 : ring (has_nnnorm (mul_one_class linarith.ineq))) : strong_rank_condition (has_nnnorm (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_8186 (h0 : topological_space (normed_comm_ring (has_to_string (has_to_string environment.implicit_infer_kind)))) : regular_space (normed_comm_ring (has_to_string (has_to_string environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_8187 (h0 : set (nondiscrete_normed_field (add_comm_semigroup environment.projection_info))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_8188 (h0 : uniform_space (has_compl (has_compl enat))) : complete_space (has_compl (has_compl enat)) := sorry --non-trivial
lemma new_lemma_8189 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_8190 (h0 : add_group (denumerable (random_gen char))) : is_add_cyclic (denumerable (random_gen char)) := sorry --non-trivial
lemma new_lemma_8191 (h0 : topological_space (has_to_string (has_add environment.implicit_infer_kind))) : irreducible_space (has_to_string (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_8192 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (semigroup empty)) := sorry --non-trivial
lemma new_lemma_8193 (h0 : not (uniform_space (simple_graph enat) -> false)) : @complete_space.{0} (simple_graph.{0} enat) (@classical.by_contradiction'.{1} (uniform_space.{0} (simple_graph.{0} enat)) h0)  := sorry --non-trivial
lemma new_lemma_8194 (h0 : function.extfun nat fin) : @irreducible_space.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_8195 (h0 : ring (has_top empty)) : rank_condition (has_top empty) := sorry --non-trivial
lemma new_lemma_8196 (h0 : group (semi_normed_comm_ring (denumerable (random_gen linarith.comp_source)))) : group.fg (semi_normed_comm_ring (denumerable (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_8197 (h0 : ring (normed_lattice_add_comm_group (has_add (has_add Type)))) : is_principal_ideal_ring (normed_lattice_add_comm_group (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_8198 (h0 : uniform_space (semiring linarith.comp_source)) : complete_space (semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_8199 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (is_R_or_C.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (is_R_or_C.{0} num))  := sorry --non-trivial
lemma new_lemma_8200 (h0 : function.extfun Type topological_space) : @t0_space.{0} (add_right_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_right_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_8201 (h0 : list (add_comm_monoid (option unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_8202 (h0 : uniform_space (has_neg ennreal)) : separated_space (has_neg ennreal) := sorry --non-trivial
lemma new_lemma_8203 (h0 : has_mem.mem (measurable_space linarith.comp_source) has_emptyc.emptyc) : @totally_separated_space.{0} (measurable_space.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_8204 (h0 : group (has_pos_part (has_add (has_add linarith.comp)))) : is_cyclic (has_pos_part (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_8205 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_dist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_dist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_8206 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_8207 (h0 : uniform_space (monoid (option num))) : separated_space (monoid (option num)) := sorry --non-trivial
lemma new_lemma_8208 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_8209 (h0 : functor.add_const (topological_space (mul_zero_class empty)) (semiring (semiring (semiring num)))) : @path_connected_space.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} empty)) (semiring.{0} (semiring.{0} (semiring.{0} num))) h0)  := sorry --non-trivial
lemma new_lemma_8210 (h0 : functor.add_const (topological_space pos) (option name)) : @topological_space.separable_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) (option.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_8211 (h0 : not (add_group (has_ssubset fun_info) -> false)) : @is_add_cyclic.{0} (has_ssubset.{0} fun_info) (@classical.by_contradiction'.{1} (add_group.{0} (has_ssubset.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_8212 (h0 : complete_lattice (has_compl (has_ssubset string_imp))) : complete_lattice.is_Sup_finite_compact (has_compl (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_8213 (h0 : functor.add_const (uniform_space (semigroup linarith.comp)) pos) : @separated_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_8214 (h0 : topological_space (linear_ordered_field (cancel_monoid (option unsigned)))) : totally_separated_space (linear_ordered_field (cancel_monoid (option unsigned))) := sorry --non-trivial
lemma new_lemma_8215 (h0 : list (ordered_comm_ring (has_pos_part (has_pos_part (ring Type))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_8216 (h0 : filter (has_zero (option ennreal))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_8217 (h0 : functor.add_const (topological_space (add_comm_monoid (add_comm_monoid pos))) name) : @t1_space.{0} (add_comm_monoid.{0} (add_comm_monoid.{0} pos)) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} (add_comm_monoid.{0} pos))) name h0)  := sorry --non-trivial
lemma new_lemma_8218 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_8219 (h0 : functor.add_const (group (has_neg_part ennreal)) (option name)) : @normalizer_condition.{0} (has_neg_part.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (has_neg_part.{0} ennreal)) (option.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_8220 (h0 : semiring (has_pos_part (boolean_algebra.core pos))) : is_noetherian_ring (has_pos_part (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_8221 (h0 : topological_space (has_pos_part (finset (ring pos)))) : t0_space (has_pos_part (finset (ring pos))) := sorry --non-trivial
lemma new_lemma_8222 (h0 : topological_space (has_edist (option unsigned))) : totally_separated_space (has_edist (option unsigned)) := sorry --non-trivial
lemma new_lemma_8223 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_8224 (h0 : fin has_zero.zero) : @complete_space.{0} (finset.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (finset.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_8225 (h0 : prod (left_cancel_monoid num) (left_cancel_monoid num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_8226 (h0 : functor.add_const (topological_space name) congr_arg_kind) : @preconnected_space.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_8227 (h0 : add_group (finset (has_add (has_to_string environment.implicit_infer_kind)))) : is_add_cyclic (finset (has_add (has_to_string environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_8228 (h2 : ring (simple_graph reducibility_hints)) : rank_condition (simple_graph reducibility_hints) := sorry --non-trivial
lemma new_lemma_8229 (h0 : function.extfun nat fin) : @discrete_topology.{0} (has_bot.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_8230 (h0 : not (has_mem.mem (has_norm num) has_emptyc.emptyc -> false)) : @is_compactly_generated.{0} (has_norm.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_norm.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_8231 (h0 : topological_space (canonically_ordered_monoid pos)) : preirreducible_space (canonically_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_8232 (h0 : functor.add_const Prop (has_bot congr_arg_kind)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_8233 (h0 : left_cancel_semigroup unsigned -> left_cancel_semigroup unsigned -> Prop) : well_founded h0 := sorry --non-trivial
lemma new_lemma_8234 (h0 : function.extfun (Type 1) topological_space) : @normal_space.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_8235 (h0 : add_group (canonically_ordered_comm_semiring (option (option empty)))) : is_add_cyclic (canonically_ordered_comm_semiring (option (option empty))) := sorry --non-trivial
lemma new_lemma_8236 (h0 : finset real) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_8237 (h0 : function.extfun nat fin) : @is_compactly_generated.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (has_bot.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_8238 (h0 : ring (ordered_cancel_add_comm_monoid (option (option (option (option unsigned)))))) : rank_condition (ordered_cancel_add_comm_monoid (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_8239 (h0 : cancel_comm_monoid_with_zero (metric_space (semiring congr_arg_kind))) : unique_factorization_monoid (metric_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_8240 (h0 : functor.add_const (function.extfun Type semiring) linarith.comp) : @is_noetherian_ring.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) linarith.comp h0) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_8241 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_8242 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_8243 (h0 : functor.add_const (monoid (boolean_algebra pos)) environment.implicit_infer_kind) : @monoid.fg.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (boolean_algebra.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_8244 (h0 : topological_space (has_zero (comm_group (option unsigned)))) : totally_disconnected_space (has_zero (comm_group (option unsigned))) := sorry --non-trivial
lemma new_lemma_8245 (h0 : fin has_zero.zero) : @is_domain.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_8246 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_8247 (h1 : topological_space (div_inv_monoid string_imp)) : t0_space (div_inv_monoid string_imp) := sorry --non-trivial
lemma new_lemma_8248 (h0 : list (boolean_algebra.core linarith.comp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_8249 (h0 h5 : multiset (add_comm_semigroup fun_info)) : multiset.disjoint h0 h5 := sorry --non-trivial
lemma new_lemma_8250 (h0 : complete_lattice (complete_distrib_lattice (option pos))) : is_atomistic (complete_distrib_lattice (option pos)) := sorry --non-trivial
lemma new_lemma_8251 (h0 : add_group (has_zero (add_cancel_monoid linarith.comp))) : is_add_cyclic (has_zero (add_cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_8252 (h0 : linarith.comp_source -> linarith.comp_source -> Prop) : relator.right_unique h0 := sorry --non-trivial
lemma new_lemma_8253 (h0 : not (uniform_space (id linarith.ineq) -> false)) : @separated_space.{0} (@id.{2} Type linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (@id.{2} Type linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_8254 (h0 : functor.add_const (filter (has_zero linarith.comp)) (ring environment.implicit_infer_kind)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_8255 (h0 : topological_space (simple_graph (finset (has_add name)))) : preirreducible_space (simple_graph (finset (has_add name))) := sorry --non-trivial
lemma new_lemma_8256 (h0 : not (add_group (non_unital_non_assoc_semiring reducibility_hints) -> false)) : @is_add_cyclic.{0} (non_unital_non_assoc_semiring.{0} reducibility_hints) (@classical.by_contradiction'.{1} (add_group.{0} (non_unital_non_assoc_semiring.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_8257 (h4 : topological_space (add_comm_semigroup fun_info)) (h5 : add_group (add_comm_semigroup fun_info)) : topological_add_group (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_8258 (h0 : ring (group linarith.ineq)) : strong_rank_condition (group linarith.ineq) := sorry --non-trivial
lemma new_lemma_8259 (h0 : functor.add_const (ordered_add_comm_monoid (has_zero pos)) linarith.comp) : @archimedean.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_zero.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_8260 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (@id.{2} Type fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type fun_info))  := sorry --non-trivial
lemma new_lemma_8261 (h0 : monoid (linear_ordered_comm_group num)) : monoid.fg (linear_ordered_comm_group num) := sorry --non-trivial
lemma new_lemma_8262 (h0 : topological_space (canonically_ordered_comm_semiring empty)) : t0_space (canonically_ordered_comm_semiring empty) := sorry --non-trivial
lemma new_lemma_8263 (h0 : functor.add_const (topological_space (comm_group name)) (has_add name)) : @preconnected_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_8264 (h0 : ring (complete_distrib_lattice empty)) : is_domain (complete_distrib_lattice empty) := sorry --non-trivial
lemma new_lemma_8265 (h0 : complete_lattice (partial_order num)) : is_atomistic (partial_order num) := sorry --non-trivial
lemma new_lemma_8266 (h0 : complete_lattice (has_pos_part (has_add real))) : is_atomistic (has_pos_part (has_add real)) := sorry --non-trivial
lemma new_lemma_8267 (h0 : not (topological_space (measure_theory.measure_space unsigned) -> false)) : @locally_compact_space.{0} (measure_theory.measure_space.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (measure_theory.measure_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_8268 (h0 : function.extfun Type ring) : @is_domain.{0} (with_one.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_8269 (h0 : topological_space (has_lt (mul_one_class linarith.comp_source))) : t0_space (has_lt (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_8270 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_8271 (h0 : function.extfun Type group) : @normalizer_condition.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_8272 (h0 : ordered_comm_monoid (has_add (has_bot (has_add Type)))) : has_exists_mul_of_le (has_add (has_bot (has_add Type))) := sorry --non-trivial
lemma new_lemma_8273 (h0 : add_group (normed_comm_ring (has_add (has_add Type)))) : is_add_cyclic (normed_comm_ring (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_8274 (h0 : functor.add_const (complete_lattice (preorder empty)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (preorder.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_8275 (h0 : functor.add_const (function.extfun Type ring) Type) : @strong_rank_condition.{0} (comm_group.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (comm_group.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_8276 (h0 : topological_space (generalized_boolean_algebra pos)) : normal_space (generalized_boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_8277 (h0 : add_group (has_sub (semiring num))) : is_add_cyclic (has_sub (semiring num)) := sorry --non-trivial
lemma new_lemma_8278 (h0 : group (with_bot (random_gen linarith.comp_source))) : normalizer_condition (with_bot (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_8279 (h0 : functor.add_const (monoid (has_neg pos)) (normed_comm_ring linarith.comp)) : @monoid.fg.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (has_neg.{0} pos)) (normed_comm_ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_8280 (h0 : functor.add_const (function.extfun Type uniform_space) (option name)) : @separated_space.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) (option.{0} name) h0) (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_8281 (h0 : ring (random_gen (has_norm linarith.ineq))) : rank_condition (random_gen (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_8282 (h0 : ring (has_neg (has_neg linarith.comp))) : is_principal_ideal_ring (has_neg (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_8283 (h0 : function.extfun Type ring) : @is_domain.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_8284 (h0 : topological_space (mul_zero_class unsigned)) : regular_space (mul_zero_class unsigned) := sorry --non-trivial
lemma new_lemma_8285 (h0 : functor.add_const (filter (add_cancel_monoid name)) (has_Inf (has_add Type))) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_8286 (h0 : not (complete_lattice (div_inv_monoid fun_info) -> false)) : @is_compactly_generated.{0} (div_inv_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (div_inv_monoid.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_8287 (h0 : monoid (plift (has_Sup empty))) : monoid.fg (plift (has_Sup empty)) := sorry --non-trivial
lemma new_lemma_8288 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (finset name)) := sorry --non-trivial
lemma new_lemma_8289 (h0 : functor.add_const (topological_space (boolean_algebra.core linarith.comp)) name) : @normal_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_8290 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_8291 (h0 : monoid (has_pos_part (finset pos))) : monoid.fg (has_pos_part (finset pos)) := sorry --non-trivial
lemma new_lemma_8292 (h0 : filter (generalized_boolean_algebra name)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_8293 (h0 : topological_space (comm_ring (has_nnnorm reducibility_hints))) : t0_space (comm_ring (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_8294 (h0 : topological_space (canonically_linear_ordered_monoid (option (option ennreal)))) : preconnected_space (canonically_linear_ordered_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_8295 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @totally_disconnected_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_8296 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_8297 (h0 : prod (left_cancel_monoid congr_arg_kind) (left_cancel_monoid congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_8298 (h0 : ring (cancel_monoid (option empty))) : rank_condition (cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_8299 (h0 : function.extfun Type has_mul) (h1 : has_star empty) : @is_regular.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type has_mul.{0} h0 (has_star.{0} empty)) h1  := sorry --non-trivial
lemma new_lemma_8300 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (has_emptyc.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_emptyc.{0} empty))  := sorry --non-trivial
lemma new_lemma_8301 (h0 : topological_space (has_zero (has_to_string ennreal))) : path_connected_space (has_zero (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_8302 (h0 : topological_space (comm_group environment.implicit_infer_kind)) : normal_space (comm_group environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_8303 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (ordered_comm_monoid.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (ordered_comm_monoid.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))))  := sorry --non-trivial
lemma new_lemma_8304 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_8305 (h0 : set (has_nnnorm (mul_one_class enat))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_8306 (h0 : topological_space (normed_lattice_add_comm_group (sub_neg_monoid Type))) : locally_compact_space (normed_lattice_add_comm_group (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_8307 (h0 : functor.add_const (add_monoid (with_bot unsigned)) unsigned) : @add_monoid.fg.{0} (with_bot.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (with_bot.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_8308 (h0 : functor.add_const (complete_lattice (complete_distrib_lattice linarith.comp)) (ring pos)) : @is_atomistic.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (complete_distrib_lattice.{0} linarith.comp)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_8309 (h0 : set (uniform_space reducibility_hints)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_8310 (h0 : ring (add_left_cancel_semigroup (semiring empty))) : rank_condition (add_left_cancel_semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_8311 (h0 : complete_lattice (complete_semilattice_Sup char)) : is_compactly_generated (complete_semilattice_Sup char) := sorry --non-trivial
lemma new_lemma_8312 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_8313 (h0 : complete_lattice (linear_ordered_field (option pos))) : is_atomistic (linear_ordered_field (option pos)) := sorry --non-trivial
lemma new_lemma_8314 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) Type) : @is_compactly_generated.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) Type h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_8315 (h0 : filter (linear_ordered_add_comm_group (has_norm fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_8316 (h0 : functor.add_const (uniform_space (monoid unsigned)) num) : @complete_space.{0} (monoid.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (monoid.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_8317 (h0 : filter (as_linear_order empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_8318 (h0 : topological_space (has_to_string (finset name))) : irreducible_space (has_to_string (finset name)) := sorry --non-trivial
lemma new_lemma_8319 (h0 : not (prod (complete_linear_order unsigned) (complete_linear_order unsigned) -> false)) : id_rel (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_8320 (h0 : not (complete_lattice (linear_ordered_semiring congr_arg_kind) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_8321 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_8322 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_8323 (h0 : group (has_top (random_gen (semiring num)))) : normalizer_condition (has_top (random_gen (semiring num))) := sorry --non-trivial
lemma new_lemma_8324 (h0 : functor.add_const (function.extfun Type topological_space) name) : @topological_space.separable_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_8325 (h0 : ring (normed_field (random_gen linarith.comp_source))) : rank_condition (normed_field (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_8326 (h0 : topological_space (finset (has_neg linarith.comp))) : totally_disconnected_space (finset (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_8327 (h0 : functor.add_const (topological_space (boolean_algebra.core ennreal)) pos) : @locally_compact_space.{0} (boolean_algebra.core.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_8328 (h0 : uniform_space unsigned) : separated_space unsigned := sorry --non-trivial
lemma new_lemma_8329 (h0 : function.extfun (Type 1) ring) : @is_domain.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_8330 (h0 : functor.add_const (topological_space (sub_neg_monoid linarith.comp)) Type) : @irreducible_space.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_8331 (h0 : not (ring (random_gen char) -> false)) : @is_domain.{0} (random_gen.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_8332 (h0 : functor.add_const (ordered_comm_monoid (ordered_comm_monoid pos)) (finset linarith.comp)) : @has_exists_mul_of_le.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ordered_comm_monoid.{0} pos)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_8333 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (pseudo_metric_space.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} name))  := sorry --non-trivial
lemma new_lemma_8334 (h0 : complete_lattice (has_zero name)) : is_compactly_generated (has_zero name) := sorry --non-trivial
lemma new_lemma_8335 (h0 : topological_space (normed_comm_ring (add_comm_monoid (finset name)))) : path_connected_space (normed_comm_ring (add_comm_monoid (finset name))) := sorry --non-trivial
lemma new_lemma_8336 (h0 : complete_lattice (has_to_string pos)) : complete_lattice.is_Sup_finite_compact (has_to_string pos) := sorry --non-trivial
lemma new_lemma_8337 (h0 : ring (complete_semilattice_Sup (semiring empty))) : rank_condition (complete_semilattice_Sup (semiring empty)) := sorry --non-trivial
lemma new_lemma_8338 (h0 : topological_space (semi_normed_comm_ring std_gen)) : totally_disconnected_space (semi_normed_comm_ring std_gen) := sorry --non-trivial
lemma new_lemma_8339 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_8340 (h0 : ring (semiring (semiring unsigned))) : rank_condition (semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_8341 (h0 : functor.comp topological_space has_add Type) : @totally_disconnected_space.{1} (has_add.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_add.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_8342 (h0 : fin has_zero.zero) : @rank_condition.{0} (add_right_cancel_monoid.{0} (semiring.{0} congr_arg_kind)) (@matrix.vec_empty.{0} (ring.{0} (add_right_cancel_monoid.{0} (semiring.{0} congr_arg_kind))) h0)  := sorry --non-trivial
lemma new_lemma_8343 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (complete_semilattice_Sup fun_info)) := sorry --non-trivial
lemma new_lemma_8344 (h0 : uniform_space (ring ennreal)) : separated_space (ring ennreal) := sorry --non-trivial
lemma new_lemma_8345 (h0 : list (add_cancel_monoid pos)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_8346 (h0 : group (generalized_boolean_algebra real)) : is_cyclic (generalized_boolean_algebra real) := sorry --non-trivial
lemma new_lemma_8347 (h0 : group (non_assoc_semiring (semiring (semiring empty)))) : normalizer_condition (non_assoc_semiring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_8348 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_8349 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_8350 (h0 : functor.add_const (function.extfun nat fin) linarith.comp) : @complete_space.{1} (has_nndist.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (has_nndist.{1} Type)) (@function.extfun_app.{1 1} nat fin (@functor.add_const.run.{0 0} (function.extfun.{1 1} nat fin) linarith.comp h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_8351 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (ordered_cancel_add_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_8352 (h0 : topological_space (has_add ennreal)) : normal_space (has_add ennreal) := sorry --non-trivial
lemma new_lemma_8353 (h0 : topological_space (semigroup (comm_group linarith.comp))) : regular_space (semigroup (comm_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_8354 (h0 : ring (normed_lattice_add_comm_group (has_add real))) : is_domain (normed_lattice_add_comm_group (has_add real)) := sorry --non-trivial
lemma new_lemma_8355 (h0 : fin has_zero.zero) : @separated_space.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (canonically_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_8356 (h0 : ring (linear_ordered_field name)) : rank_condition (linear_ordered_field name) := sorry --non-trivial
lemma new_lemma_8357 (h0 : list (has_Inf (finset (ring pos)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_8358 (h0 : has_neg (linear_ordered_comm_group_with_zero to_additive.value_type)) (h1 : measurable_space (linear_ordered_comm_group_with_zero to_additive.value_type)) : has_measurable_neg (linear_ordered_comm_group_with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_8359 (h2 : set (add_comm_semigroup linarith.ineq -> char)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_8360 (h0 : functor.add_const (topological_space (monoid unsigned)) empty) : @normal_space.{0} (monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_8361 (h0 : functor.add_const (list (boolean_algebra pos)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_8362 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (topological_space.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (topological_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_8363 (h0 : functor.add_const (add_monoid (has_Inf Type)) pos) : @add_monoid.fg.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (has_Inf.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_8364 (h0 : filter (has_neg (finset linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_8365 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_8366 (h0 : topological_space (add_right_cancel_monoid (semiring congr_arg_kind))) : totally_separated_space (add_right_cancel_monoid (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_8367 (h0 : monoid (dlist (has_inv (has_inv (has_inv (has_inv to_additive.value_type)))))) : monoid.fg (dlist (has_inv (has_inv (has_inv (has_inv to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_8368 (h0 : functor.add_const (topological_space (ring unsigned)) linarith.comp) : @sequential_space.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_8369 (h0 : topological_space (monoid num)) : locally_compact_space (monoid num) := sorry --non-trivial
lemma new_lemma_8370 (h0 : semiring (linear_ordered_comm_group (has_to_string (add_comm_monoid congr_arg_kind)))) : is_noetherian_ring (linear_ordered_comm_group (has_to_string (add_comm_monoid congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_8371 (h0 : functor.add_const (function.extfun Type group) (finset (boolean_algebra linarith.comp))) : @normalizer_condition.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) (finset.{0} (boolean_algebra.{0} linarith.comp)) h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_8372 (h0 : complete_lattice (boolean_algebra (has_add Type))) : is_atomistic (boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_8373 (h0 : functor.add_const (topological_space empty) empty) : normal_space empty := sorry --non-trivial
lemma new_lemma_8374 (h0 : complete_lattice (has_zero (has_add (finset (finset pos))))) : complete_lattice.is_Sup_finite_compact (has_zero (has_add (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_8375 (h0 : function.extfun Type group) : @is_cyclic.{0} (encodable.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (encodable.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_8376 (h0 : functor.add_const (function.extfun Type group) pos) : @group.fg.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_8377 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (normed_lattice_add_comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_8378 (h0 : group (boolean_algebra (has_add Type))) : is_simple_group (boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_8379 (h0 : functor.add_const (semiring (add_cancel_monoid linarith.comp)) pos) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (add_cancel_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_8380 (h0 : functor.add_const (topological_space (has_add name)) name) : @path_connected_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_8381 (h0 : functor.add_const (topological_space (free_add_monoid empty)) empty) : @preirreducible_space.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_8382 (h0 : topological_space (has_dist (option empty))) : topological_space.separable_space (has_dist (option empty)) := sorry --non-trivial
lemma new_lemma_8383 (h0 : topological_space (bin_tree (semiring empty))) : totally_disconnected_space (bin_tree (semiring empty)) := sorry --non-trivial
lemma new_lemma_8384 (h0 : topological_space (linear_ordered_field unsigned)) : topological_space.separable_space (linear_ordered_field unsigned) := sorry --non-trivial
lemma new_lemma_8385 (h0 : topological_space (has_nndist (add_comm_monoid ennreal))) : path_connected_space (has_nndist (add_comm_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_8386 (h0 : cancel_comm_monoid_with_zero enat) (h1 : add_group (gcd_monoid enat)) : is_add_cyclic (gcd_monoid enat) := sorry --non-trivial
lemma new_lemma_8387 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_8388 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_dist unsigned)) := sorry --non-trivial
lemma new_lemma_8389 (h0 : not (topological_space (denumerable to_additive.value_type) -> false)) : @t0_space.{0} (denumerable.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_8390 (h0 : functor.add_const (semiring (left_cancel_monoid congr_arg_kind)) congr_arg_kind) : @is_noetherian_ring.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (semiring.{0} (left_cancel_monoid.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_8391 (h0 : ring (boolean_algebra.core (has_to_string name))) : strong_rank_condition (boolean_algebra.core (has_to_string name)) := sorry --non-trivial
lemma new_lemma_8392 (h3 h4 : multiset (add_comm_semigroup fun_info)) : multiset.disjoint h3 h4 := sorry --non-trivial
lemma new_lemma_8393 (h0 : not (group (add_right_cancel_monoid congr_arg_kind) -> false)) : @normalizer_condition.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (add_right_cancel_monoid.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_8394 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_8395 (h0 : complete_lattice (normed_comm_ring (finset environment.implicit_infer_kind))) : complete_lattice.is_Sup_finite_compact (normed_comm_ring (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_8396 (h0 : has_mem.mem (normed_group linarith.comp_source) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (normed_group.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_8397 (h0 : functor.add_const (complete_lattice ennreal) (option ennreal)) : is_compactly_generated ennreal := sorry --non-trivial
lemma new_lemma_8398 (h0 : ring (ordered_ring num)) : rank_condition (ordered_ring num) := sorry --non-trivial
lemma new_lemma_8399 (h0 : ring (normed_lattice_add_comm_group (has_add (has_Inf Type)))) : strong_rank_condition (normed_lattice_add_comm_group (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_8400 (h0 : finset (has_pos_part linarith.comp)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_8401 (h0 : cancel_comm_monoid_with_zero (partial_order (semiring num))) : unique_factorization_monoid (partial_order (semiring num)) := sorry --non-trivial
lemma new_lemma_8402 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc linarith.comp_source))) : @rank_condition.{0} (has_emptyc.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_8403 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (comm_ring.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (comm_ring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_8404 (h0 : ring (boolean_algebra linarith.comp)) : is_principal_ideal_ring (boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_8405 (h0 : topological_space (has_nnnorm (mul_one_class (has_le string.iterator_imp)))) : path_connected_space (has_nnnorm (mul_one_class (has_le string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_8406 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) name) : @t0_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_8407 (h0 : complete_lattice (has_norm congr_arg_kind)) : is_atomistic (has_norm congr_arg_kind) := sorry --non-trivial
lemma new_lemma_8408 (h0 : topological_space (boolean_algebra.core (has_nndist pos))) : totally_separated_space (boolean_algebra.core (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_8409 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_8410 (h0 : topological_space (semigroup (has_to_string name))) : sequential_space (semigroup (has_to_string name)) := sorry --non-trivial
lemma new_lemma_8411 (h0 : functor.add_const (topological_space (preorder empty)) empty) : @t1_space.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_8412 (h0 : ring (dlist (random_gen (fintype (distrib (topological_space (has_append linarith.ineq))))))) : is_domain (dlist (random_gen (fintype (distrib (topological_space (has_append linarith.ineq)))))) := sorry --non-trivial
lemma new_lemma_8413 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (comm_ring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_ring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_8414 (h0 : group to_additive.value_type) : group.fg to_additive.value_type := sorry --non-trivial
lemma new_lemma_8415 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_8416 (h0 : functor.add_const (functor.add_const (topological_space Type) linarith.comp) linarith.comp) : @preconnected_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) linarith.comp (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (topological_space.{1} Type) linarith.comp) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_8417 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_8418 (h0 : ring (linear_ordered_add_comm_group (has_nnnorm to_additive.value_type))) : is_domain (linear_ordered_add_comm_group (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_8419 (h0 : has_le to_additive.value_type) (h1 : to_additive.value_type) : is_max h1 := sorry --non-trivial
lemma new_lemma_8420 (h0 : uniform_space (finset (finset (has_Inf (finset linarith.comp))))) : separated_space (finset (finset (has_Inf (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_8421 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_8422 (h0 : topological_space (linear_ordered_semiring (random_gen congr_arg_kind))) : discrete_topology (linear_ordered_semiring (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_8423 (h0 : group (has_zero (finset (finset (semigroup (finset Type)))))) : normalizer_condition (has_zero (finset (finset (semigroup (finset Type))))) := sorry --non-trivial
lemma new_lemma_8424 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_8425 (h0 : topological_space (has_nndist congr_arg_kind)) : t1_space (has_nndist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_8426 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (linear_ordered_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_8427 (h0 : functor.add_const (uniform_space (ordered_comm_monoid linarith.comp)) (has_add (has_add pos))) : @complete_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_comm_monoid.{0} linarith.comp)) (has_add.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_8428 (h0 : list (has_to_string (has_Inf Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_8429 (h0 : function.extfun Type group) : @is_cyclic.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_8430 (h0 : ring (has_pos_part (finset environment.implicit_infer_kind))) : is_principal_ideal_ring (has_pos_part (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_8431 (h0 : has_mem.mem (with_one linarith.ineq) has_emptyc.emptyc) : @is_domain.{0} (with_one.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type ring.{0} (with_one.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_8432 (h0 : not (prod (option congr_arg_kind) (option congr_arg_kind) -> false)) : id_rel (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_8433 (h0 : function.extfun (Type -> Type) (function.extfun Type) -> Prop) (h1 : function.extfun (function.extfun (Type -> Type) (function.extfun Type) -> Prop) Exists) : @is_cyclic.{0} (group_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.some.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0 (@function.extfun_app.{2 0} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type) → Prop) (@Exists.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type))) h1 (λ (x : function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)), h0 x))) group.{0}) (group_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_8434 (h0 : functor.add_const (functor.add_const (group (add_semigroup empty)) empty) empty) : @is_cyclic.{0} (add_semigroup.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (add_semigroup.{0} empty)) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (group.{0} (add_semigroup.{0} empty)) empty) empty h0))  := sorry --non-trivial
lemma new_lemma_8435 (h0 : filter (has_neg_part (has_nndist name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_8436 (h0 : not (group (random_gen num) -> false)) : @normalizer_condition.{0} (random_gen.{0} num) (@classical.by_contradiction'.{1} (group.{0} (random_gen.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_8437 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) Type) : @preirreducible_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_8438 (h0 : topological_space (with_one (comm_ring (has_norm (random_gen linarith.ineq))))) : t0_space (with_one (comm_ring (has_norm (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_8439 (h0 : ordered_comm_monoid (has_add (has_nndist (has_Inf name)))) : has_exists_mul_of_le (has_add (has_nndist (has_Inf name))) := sorry --non-trivial
lemma new_lemma_8440 (h0 : add_group (add_comm_monoid (comm_monoid unsigned))) : is_add_cyclic (add_comm_monoid (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_8441 (h0 : topological_space (has_bot (has_neg (has_neg name)))) : totally_separated_space (has_bot (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_8442 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_8443 (h0 : topological_space (has_neg (finset environment.implicit_infer_kind))) : discrete_topology (has_neg (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_8444 (h0 : topological_space (comm_group (has_neg_part unsigned))) : preconnected_space (comm_group (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_8445 (h0 : functor.add_const (ring (has_zero linarith.comp)) environment.implicit_infer_kind) : @is_domain.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_8446 (h0 : topological_space (has_compl (mul_one_class (mul_one_class enat)))) : totally_disconnected_space (has_compl (mul_one_class (mul_one_class enat))) := sorry --non-trivial
lemma new_lemma_8447 (h0 : filter (ordered_comm_monoid (has_add pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_8448 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_add.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_8449 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_8450 (h2 : function.extfun Type ring) : @rank_condition.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h2 (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_8451 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_8452 (h0 : uniform_space (has_top (has_nnnorm (has_nnnorm to_additive.value_type)))) : complete_space (has_top (has_nnnorm (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_8453 (h0 : not (topological_space (linear_ordered_comm_ring congr_arg_kind) -> false)) : @discrete_topology.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_ring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_8454 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (semigroup.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_8455 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_neg.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_neg.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_8456 (h0 : semiring (has_to_string (has_neg_part pos))) : is_noetherian_ring (has_to_string (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_8457 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_sub.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_sub.{0} empty))  := sorry --non-trivial
lemma new_lemma_8458 (h0 : topological_space (monoid empty)) : discrete_topology (monoid empty) := sorry --non-trivial
lemma new_lemma_8459 (h0 : ring (has_add unsigned)) : is_domain (has_add unsigned) := sorry --non-trivial
lemma new_lemma_8460 (h0 : ordered_add_comm_monoid (boolean_algebra.core (has_to_string congr_arg_kind))) : archimedean (boolean_algebra.core (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_8461 (h0 : function.extfun Type topological_space) : @t0_space.{0} (free_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (free_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_8462 (h0 : monoid (has_star (semiring unsigned))) : monoid.fg (has_star (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_8463 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_8464 (h0 : topological_space (random_gen (comm_ring to_additive.value_type))) : path_connected_space (random_gen (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_8465 (h0 : topological_space (boolean_algebra (sub_neg_monoid real))) : normal_space (boolean_algebra (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_8466 (h0 : has_mem.mem (semiring empty) has_emptyc.emptyc) : @is_cyclic.{0} (semiring.{0} empty) (@finset.pi.empty.{1 0} Type group.{0} (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_8467 (h0 : function.extfun Type ring) : @is_domain.{0} (uniform_space.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (uniform_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_8468 (h0 : topological_space (comm_ring (comm_group (random_gen string.iterator_imp)))) : t0_space (comm_ring (comm_group (random_gen string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_8469 (h0 : functor.add_const (list (normed_linear_ordered_group empty)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_8470 (h1 : add_group (nondiscrete_normed_field (add_comm_semigroup enat))) : is_add_cyclic (nondiscrete_normed_field (add_comm_semigroup enat)) := sorry --non-trivial
lemma new_lemma_8471 (h0 : functor.add_const (complete_lattice (ring Type)) linarith.comp) : @is_compactly_generated.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_8472 (h0 : not (topological_space (id unsigned) -> false)) : @totally_disconnected_space.{0} (@id.{2} Type unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_8473 (h0 : topological_space (complete_semilattice_Sup (has_top fun_info))) : t0_space (complete_semilattice_Sup (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_8474 (h0 : group (ordered_comm_ring (has_Inf Type))) : normalizer_condition (ordered_comm_ring (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_8475 (h0 : functor.add_const (topological_space (ring linarith.comp)) name) : @t1_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_8476 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (is_R_or_C empty)) := sorry --non-trivial
lemma new_lemma_8477 (h0 : group (has_nndist Type)) : group.fg (has_nndist Type) := sorry --non-trivial
lemma new_lemma_8478 (h0 : group (mul_zero_class (semiring unsigned))) : group.fg (mul_zero_class (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_8479 (h0 : uniform_space (partial_order congr_arg_kind)) : separated_space (partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_8480 (h0 : monoid (ordered_comm_monoid (finset (has_Inf pos)))) : monoid.fg (ordered_comm_monoid (finset (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_8481 (h0 : functor.add_const (add_monoid (option pos)) name) : @add_monoid.fg.{0} (option.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (option.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_8482 (h0 : add_group (has_append (random_gen (random_gen (random_gen (random_gen (random_gen char))))))) : is_add_cyclic (has_append (random_gen (random_gen (random_gen (random_gen (random_gen char)))))) := sorry --non-trivial
lemma new_lemma_8483 (h0 : functor.add_const (add_monoid (boolean_algebra.core name)) (option pos)) : @add_monoid.fg.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (boolean_algebra.core.{0} name)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_8484 (h0 : functor.add_const (function.extfun Type uniform_space) Type) : @complete_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) Type h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_8485 (h0 : ordered_add_comm_monoid (has_bot (has_Inf Type))) : archimedean (has_bot (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_8486 (h0 : topological_space (measurable_space (semiring congr_arg_kind))) : totally_disconnected_space (measurable_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_8487 (h1 : Prop) : set.separates_points (id (fun (h0 : add_comm_semigroup (add_comm_semigroup char) -> enat), h1)) := sorry --non-trivial
lemma new_lemma_8488 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) empty) : @unique_factorization_monoid.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) empty h0) (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_8489 (h0 : group (semi_normed_comm_ring (has_top (has_top (has_top to_additive.value_type))))) : group.fg (semi_normed_comm_ring (has_top (has_top (has_top to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_8490 (h0 : ordered_comm_monoid (complete_distrib_lattice (finset unsigned))) : has_exists_mul_of_le (complete_distrib_lattice (finset unsigned)) := sorry --non-trivial
lemma new_lemma_8491 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (distrib_lattice.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (distrib_lattice.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_8492 (h0 : monoid (complete_distrib_lattice (sub_neg_monoid (has_Inf (sub_neg_monoid (has_Inf real)))))) : monoid.fg (complete_distrib_lattice (sub_neg_monoid (has_Inf (sub_neg_monoid (has_Inf real))))) := sorry --non-trivial
lemma new_lemma_8493 (h1 : complete_lattice (topological_space to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (topological_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_8494 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (add_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_8495 (h0 : functor.add_const (add_monoid (canonically_ordered_monoid real)) real) : @add_monoid.fg.{0} (canonically_ordered_monoid.{0} real) (@functor.add_const.run.{0 0} (add_monoid.{0} (canonically_ordered_monoid.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_8496 (h0 : function.extfun Type (functor.add_const (add_monoid (linear_ordered_comm_monoid_with_zero empty)))) : @add_monoid.fg.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_monoid.{0} (linear_ordered_comm_monoid_with_zero.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_8497 (h0 : topological_space (with_bot (random_gen (has_ssubset linarith.ineq)))) : t0_space (with_bot (random_gen (has_ssubset linarith.ineq))) := sorry --non-trivial
lemma new_lemma_8498 (h0 : add_group (simple_graph string.iterator_imp)) : is_add_cyclic (simple_graph string.iterator_imp) := sorry --non-trivial
lemma new_lemma_8499 (h0 : functor.add_const (ring (has_neg pos)) (finset linarith.comp)) : @rank_condition.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} pos)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_8500 (h0 : uniform_space (has_to_string (finset ennreal))) : separated_space (has_to_string (finset ennreal)) := sorry --non-trivial
lemma new_lemma_8501 (h0 : monoid (measurable_space (has_norm (has_norm linarith.comp)))) : monoid.fg (measurable_space (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_8502 (h0 : topological_space (has_zero environment.implicit_infer_kind)) : t0_space (has_zero environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_8503 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_noetherian_ring.{0} (has_sub.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) semiring.{0}) (has_sub.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_8504 (h0 : filter (has_neg pos)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_8505 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @totally_separated_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_8506 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} znum (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 znum)  := sorry --non-trivial
lemma new_lemma_8507 (h0 : monoid (pseudo_metric_space unsigned)) : monoid.fg (pseudo_metric_space unsigned) := sorry --non-trivial
lemma new_lemma_8508 (h0 : monoid (with_one linarith.comp_source)) : monoid.fg (with_one linarith.comp_source) := sorry --non-trivial
lemma new_lemma_8509 (h1 : not (ring (mul_one_class string_imp) -> false)) : @rank_condition.{0} (mul_one_class.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (mul_one_class.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_8510 (h0 : complete_lattice (partial_order (semiring (option unsigned)))) : complete_lattice.is_Sup_finite_compact (partial_order (semiring (option unsigned))) := sorry --non-trivial
lemma new_lemma_8511 (h0 : functor.comp group has_to_string environment.implicit_infer_kind) : @is_cyclic.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} group.{0} has_to_string.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_8512 (h0 : topological_space (comm_ring (random_gen fun_info))) : path_connected_space (comm_ring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_8513 (h0 : list (finset (option name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_8514 (h0 : filter (cancel_monoid name)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_8515 (h0 : not (complete_lattice (has_nnnorm linarith.ineq) -> false)) : @is_compactly_generated.{0} (has_nnnorm.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_nnnorm.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_8516 (h0 : has_mem.mem to_additive.value_type has_emptyc.emptyc) : @totally_separated_space.{0} to_additive.value_type (@finset.pi.empty.{1 0} Type topological_space.{0} to_additive.value_type h0)  := sorry --non-trivial
lemma new_lemma_8517 (h0 : has_add linarith.comp -> has_add linarith.comp -> has_add linarith.comp) : left_cancelative h0 := sorry --non-trivial
lemma new_lemma_8518 (h0 : complete_lattice (has_top (has_norm to_additive.value_type))) : is_compactly_generated (has_top (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_8519 (h0 : functor.add_const (add_group (add_comm_monoid unsigned)) (option empty)) : @is_add_cyclic.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (add_comm_monoid.{0} unsigned)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_8520 (h0 : filter (has_zero Type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_8521 (h0 : uniform_space (boolean_algebra (ring Type))) : separated_space (boolean_algebra (ring Type)) := sorry --non-trivial
lemma new_lemma_8522 (h0 : functor.add_const (topological_space (ring unsigned)) linarith.comp) : @preconnected_space.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_8523 (h0 : filter (add_monoid string_imp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_8524 (h0 : topological_space (non_assoc_semiring (option unsigned))) : loc_path_connected_space (non_assoc_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_8525 (h0 : topological_space (plift (semiring congr_arg_kind))) : t0_space (plift (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_8526 (h0 : functor.add_const (ring (add_group num)) congr_arg_kind) : @is_domain.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (add_group.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_8527 (h0 : functor.add_const Prop (has_bot (has_Inf (has_bot pos)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_8528 (h0 : add_group (has_nnnorm (has_le (mul_one_class (normed_field (normed_field std_gen)))))) : is_add_cyclic (has_nnnorm (has_le (mul_one_class (normed_field (normed_field std_gen))))) := sorry --non-trivial
lemma new_lemma_8529 (h0 : has_mem.mem has_zero.zero has_emptyc.emptyc) : matrix.vec_empty (finset.pi.empty fin has_zero.zero h0) := sorry --non-trivial
lemma new_lemma_8530 (h1 : set (set linarith.ineq)) : is_pi_system h1 := sorry --non-trivial
lemma new_lemma_8531 (h0 : group (boolean_algebra.core (has_nndist (has_nndist name)))) : group.fg (boolean_algebra.core (has_nndist (has_nndist name))) := sorry --non-trivial
lemma new_lemma_8532 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_8533 (h0 : topological_space (boolean_algebra (ordered_comm_monoid Type))) : discrete_topology (boolean_algebra (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_8534 (h1 : add_group (semi_normed_ring string_imp)) : is_add_cyclic (semi_normed_ring string_imp) := sorry --non-trivial
lemma new_lemma_8535 (h0 : functor.add_const (ordered_comm_monoid (normed_comm_ring unsigned)) unsigned) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (normed_comm_ring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_8536 (h0 : topological_space (has_zero (canonically_linear_ordered_monoid name))) : path_connected_space (has_zero (canonically_linear_ordered_monoid name)) := sorry --non-trivial
lemma new_lemma_8537 (h0 : topological_space (semiring fun_info)) : totally_separated_space (semiring fun_info) := sorry --non-trivial
lemma new_lemma_8538 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_8539 (h0 : add_group (linear_ordered_add_comm_group to_additive.value_type)) : is_add_cyclic (linear_ordered_add_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_8540 (h0 : monoid (linear_ordered_comm_group (option empty))) : monoid.fg (linear_ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_8541 (h0 : topological_space (comm_semigroup real)) : discrete_topology (comm_semigroup real) := sorry --non-trivial
lemma new_lemma_8542 (h0 : functor.add_const (function.extfun Type ring) (has_neg pos)) : @is_domain.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (has_neg.{0} pos) h0) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_8543 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space congr_arg_kind))) : @irreducible_space.{0} (measurable_space.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_8544 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_8545 (h0 : topological_space (simple_graph congr_arg_kind)) : path_connected_space (simple_graph congr_arg_kind) := sorry --non-trivial
lemma new_lemma_8546 (h0 : complete_lattice (has_union (semiring (semiring (semiring (semiring num)))))) : is_compactly_generated (has_union (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_8547 (h0 : functor.add_const (add_group (finset name)) (has_neg_part Type)) : @is_add_cyclic.{0} (finset.{0} name) (@functor.add_const.run.{0 1} (add_group.{0} (finset.{0} name)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_8548 (h0 : ordered_add_comm_monoid (has_add name)) : archimedean (has_add name) := sorry --non-trivial
lemma new_lemma_8549 (h0 : functor.add_const (list (has_to_string Type)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_8550 (h0 : functor.add_const (finset (add_cancel_monoid name)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_8551 (h0 : add_group (has_to_string (boolean_algebra.core (has_add (has_add name))))) : is_add_cyclic (has_to_string (boolean_algebra.core (has_add (has_add name)))) := sorry --non-trivial
lemma new_lemma_8552 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) pos) : @normal_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_8553 (h2 : list (with_one (has_top linarith.ineq))) : list.nodup h2 := sorry --non-trivial
lemma new_lemma_8554 (h0 : complete_lattice (topological_space (random_gen linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (topological_space (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_8555 (h0 : list (cancel_monoid (option (comm_monoid unsigned)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_8556 (h0 : topological_space (has_Inf (has_to_string (has_add (has_add (has_add pos)))))) : totally_disconnected_space (has_Inf (has_to_string (has_add (has_add (has_add pos))))) := sorry --non-trivial
lemma new_lemma_8557 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_8558 (h0 : topological_space (free_add_monoid congr_arg_kind)) : normal_space (free_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_8559 (h0 : functor.add_const (functor.add_const (ring environment.implicit_infer_kind) Type) linarith.comp) : @strong_rank_condition.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 1} (ring.{0} environment.implicit_infer_kind) Type (@functor.add_const.run.{0 0} (functor.add_const.{0 1} (ring.{0} environment.implicit_infer_kind) Type) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_8560 (h0 : add_group (has_zero (normed_comm_ring linarith.comp))) : is_add_cyclic (has_zero (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_8561 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_nndist.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_nndist.{0} num))  := sorry --non-trivial
lemma new_lemma_8562 (h0 : function.extfun Type group) : @normalizer_condition.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_8563 (h0 : filter (has_to_string (has_to_string (comm_group unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_8564 (h0 : semiring (cancel_monoid pos)) : is_noetherian_ring (cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_8565 (h0 : not (group (mul_zero_class empty) -> false)) : @normalizer_condition.{0} (mul_zero_class.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (mul_zero_class.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_8566 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_8567 (h0 : functor.add_const (group pos) pos) : @normalizer_condition.{0} pos (@functor.add_const.run.{0 0} (group.{0} pos) pos h0)  := sorry --non-trivial
lemma new_lemma_8568 (h0 : topological_space (add_left_cancel_semigroup empty)) : topological_space.separable_space (add_left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_8569 (h0 : function.extfun (Type 1) uniform_space) : @complete_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_8570 (h0 : topological_space (boolean_algebra unsigned)) : sequential_space (boolean_algebra unsigned) := sorry --non-trivial
lemma new_lemma_8571 (h0 : group (sub_neg_monoid linarith.comp)) : group.fg (sub_neg_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_8572 (h0 : topological_space (has_pos_part (has_nndist linarith.comp))) : irreducible_space (has_pos_part (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_8573 (h0 : function.extfun nat fin) : @t0_space.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_8574 (h0 : functor.add_const (topological_space (has_nndist Type)) Type) : @t0_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_nndist.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_8575 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (@id.{2} Type (has_norm.{0} empty)) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (@id.{2} Type (has_norm.{0} empty)))  := sorry --non-trivial
lemma new_lemma_8576 (h0 : nat -> string_imp -> comm_ring (has_ssubset (has_ssubset linarith.comp_source))) (h1 : list string_imp) : list.nodup (list.map_with_index h0 (id h1)) := sorry --non-trivial
lemma new_lemma_8577 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_one.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_one.{0} num))  := sorry --non-trivial
lemma new_lemma_8578 (h0 : functor.add_const (topological_space (has_to_string Type)) name) : @sequential_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_8579 (h0 : uniform_space (semi_normed_ring char)) : complete_space (semi_normed_ring char) := sorry --non-trivial
lemma new_lemma_8580 (h0 : monoid (ring (normed_comm_ring (has_neg Type)))) : monoid.fg (ring (normed_comm_ring (has_neg Type))) := sorry --non-trivial
lemma new_lemma_8581 (h0 : topological_space (option congr_arg_kind)) : totally_disconnected_space (option congr_arg_kind) := sorry --non-trivial
lemma new_lemma_8582 (h0 : not (monoid (has_emptyc fun_info) -> false)) : @monoid.fg.{0} (has_emptyc.{0} fun_info) (@classical.by_contradiction'.{1} (monoid.{0} (has_emptyc.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_8583 (h0 : topological_space (linear_ordered_semiring (has_top (has_top (has_top to_additive.value_type))))) : path_connected_space (linear_ordered_semiring (has_top (has_top (has_top to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_8584 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_8585 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_8586 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_8587 (h0 : group (group_with_zero (option unsigned))) : normalizer_condition (group_with_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_8588 (h2 : ring (distrib (has_nnnorm char))) : strong_rank_condition (distrib (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_8589 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_8590 (h0 : has_mem.mem (complete_semilattice_Sup (semiring congr_arg_kind)) has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (complete_semilattice_Sup.{0} (semiring.{0} congr_arg_kind)) (@multiset.pi.empty.{1 0} Type complete_lattice.{0} (complete_semilattice_Sup.{0} (semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_8591 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_8592 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_8593 (h0 : group (with_bot (has_inv (has_top linarith.comp_source)))) : normalizer_condition (with_bot (has_inv (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_8594 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} real (@matrix.vec_empty.{0} (complete_lattice.{0} real) h0)  := sorry --non-trivial
lemma new_lemma_8595 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_8596 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_nndist.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_nndist.{0} num))  := sorry --non-trivial
lemma new_lemma_8597 (h0 : functor.add_const (prod (linear_order unsigned) (linear_order unsigned)) empty) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_8598 (h0 : not (monoid (with_one empty) -> false)) : @monoid.fg.{0} (with_one.{0} empty) (@classical.by_contradiction'.{1} (monoid.{0} (with_one.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_8599 (h0 : ring (semigroup (has_nndist name))) : rank_condition (semigroup (has_nndist name)) := sorry --non-trivial
lemma new_lemma_8600 (h0 : group (semi_normed_comm_ring (linear_ordered_add_comm_group fun_info))) : group.fg (semi_normed_comm_ring (linear_ordered_add_comm_group fun_info)) := sorry --non-trivial
lemma new_lemma_8601 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (preorder empty)) := sorry --non-trivial
lemma new_lemma_8602 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) (ring (ring (ring Type)))) : @complete_lattice.is_Sup_finite_compact.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) (ring.{1} (ring.{1} (ring.{1} Type))) h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_8603 (h0 : functor.add_const (ordered_add_comm_monoid (group_with_zero unsigned)) num) : @archimedean.{0} (group_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (group_with_zero.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_8604 (h0 : function.extfun Type topological_space) : loc_path_connected_space nnreal := sorry --non-trivial
lemma new_lemma_8605 (h0 : filter (ordered_comm_monoid (has_Inf (has_pos_part pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_8606 (h0 : functor.add_const (topological_space (linear_ordered_comm_group ennreal)) (option ennreal)) : @irreducible_space.{0} (linear_ordered_comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_group.{0} ennreal)) (option.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_8607 (h0 : functor.add_const (ring (normed_comm_ring name)) linarith.comp) : @is_principal_ideal_ring.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_8608 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_8609 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @t0_space.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) num)  := sorry --non-trivial
lemma new_lemma_8610 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_8611 (h0 : topological_space (is_R_or_C congr_arg_kind)) : irreducible_space (is_R_or_C congr_arg_kind) := sorry --non-trivial
lemma new_lemma_8612 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_8613 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system num)) unsigned) : @discrete_topology.{0} (measurable_space.dynkin_system.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_8614 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_8615 (h0 : empty -> has_top unsigned -> has_top unsigned) : left_commutative h0 := sorry --non-trivial
lemma new_lemma_8616 (h0 : functor.add_const (complete_lattice (has_nndist linarith.comp)) (has_pos_part linarith.comp)) : @is_compactly_generated.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} linarith.comp)) (has_pos_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_8617 (h1 : function.extfun Type topological_space) : @irreducible_space.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_8618 (h0 : topological_space (has_add (normed_comm_ring name))) : regular_space (has_add (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_8619 (h0 : uniform_space (boolean_algebra (has_Inf (has_Inf (has_Inf Type))))) : complete_space (boolean_algebra (has_Inf (has_Inf (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_8620 (h0 : function.extfun Type (functor.comp ring mul_zero_class)) : @is_domain.{0} (mul_zero_class.{0} name) (@functor.comp.run.{0 0 0} ring.{0} mul_zero_class.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} mul_zero_class.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_8621 (h0 : topological_space (comm_group (semigroup Type))) : normal_space (comm_group (semigroup Type)) := sorry --non-trivial
lemma new_lemma_8622 (h0 : topological_space (with_bot (has_norm fun_info))) : normal_space (with_bot (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_8623 (h0 : add_monoid (add_group (with_bot unsigned))) (h1 : not (function.extfun Type add_group -> false)) : is_add_unit (function.extfun_app (classical.by_contradiction' h1) (with_bot unsigned)) := sorry --non-trivial
lemma new_lemma_8624 (h0 : ring (has_to_string (has_add linarith.comp))) : is_domain (has_to_string (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_8625 (h0 : functor.add_const (filter (has_to_string pos)) (normed_comm_ring pos)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_8626 (h1 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} num (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 num)  := sorry --non-trivial
lemma new_lemma_8627 (h0 : add_group (complete_semilattice_Sup (semiring (semiring (has_norm unsigned))))) : is_add_cyclic (complete_semilattice_Sup (semiring (semiring (has_norm unsigned)))) := sorry --non-trivial
lemma new_lemma_8628 (h0 : cancel_comm_monoid_with_zero (has_bot linarith.comp)) : unique_factorization_monoid (has_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_8629 (h0 : topological_space (ordered_comm_group unsigned)) : preirreducible_space (ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_8630 (h0 : ring (option (semiring (semiring (semiring num))))) : strong_rank_condition (option (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_8631 (h0 : topological_space (finset (has_Inf pos))) : preconnected_space (finset (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_8632 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) pos) : @sequential_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_8633 (h0 : has_lt (mul_one_class linarith.ineq)) : no_max_order (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_8634 (h0 : functor.add_const (list (normed_comm_ring ennreal)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_8635 (h0 : functor.add_const (ring (preorder num)) empty) : @is_principal_ideal_ring.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (preorder.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_8636 (h0 : topological_space (has_nndist environment.implicit_infer_kind)) : irreducible_space (has_nndist environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_8637 (h0 : group (has_to_string (has_to_string num))) : is_cyclic (has_to_string (has_to_string num)) := sorry --non-trivial
lemma new_lemma_8638 (h1 : function.extfun (Type 1) group) : @group.fg.{1} Type (@function.extfun_app.{3 2} (Type 1) group.{1} h1 Type)  := sorry --non-trivial
lemma new_lemma_8639 (h0 : functor.add_const (group (add_comm_monoid pos)) name) : @is_simple_group.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_8640 (h0 : topological_space (mul_zero_class Type)) : loc_path_connected_space (mul_zero_class Type) := sorry --non-trivial
lemma new_lemma_8641 (h0 : functor.add_const (uniform_space (free_add_monoid congr_arg_kind)) empty) : @separated_space.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (free_add_monoid.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_8642 (h0 : topological_space (has_neg_part Type)) : normal_space (has_neg_part Type) := sorry --non-trivial
lemma new_lemma_8643 (h1 : uniform_space (topological_space (has_add bool))) : complete_space (topological_space (has_add bool)) := sorry --non-trivial
lemma new_lemma_8644 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_8645 (h0 : not (ring (id congr_arg_kind) -> false)) : @is_principal_ideal_ring.{0} (@id.{2} Type congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (@id.{2} Type congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_8646 (h0 : functor.add_const (complete_lattice (add_cancel_monoid ennreal)) name) : @is_atomistic.{0} (add_cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_8647 (h0 : ordered_add_comm_monoid (has_add (add_cancel_monoid name))) : archimedean (has_add (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_8648 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_8649 (h0 : not (ring (bin_tree congr_arg_kind) -> false)) : @rank_condition.{0} (bin_tree.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (bin_tree.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_8650 (h0 : topological_space (normed_lattice_add_comm_group (has_add Type))) : t1_space (normed_lattice_add_comm_group (has_add Type)) := sorry --non-trivial
lemma new_lemma_8651 (h3 : set (fun_info -> enat)) : set.separates_points h3 := sorry --non-trivial
lemma new_lemma_8652 (h0 : semiring (boolean_algebra (ring (finset (ring pos))))) : is_noetherian_ring (boolean_algebra (ring (finset (ring pos)))) := sorry --non-trivial
lemma new_lemma_8653 (h0 : topological_space (canonically_ordered_comm_semiring (add_comm_monoid ennreal))) : preconnected_space (canonically_ordered_comm_semiring (add_comm_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_8654 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (id fun_info)) := sorry --non-trivial
lemma new_lemma_8655 (h0 : functor.add_const (topological_space (preorder unsigned)) empty) : @loc_path_connected_space.{0} (preorder.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_8656 (h0 : comm_semigroup empty -> comm_semigroup empty -> Prop) (h1 : set (comm_semigroup empty)) (h2 : coe_sort h1) (h3 : not (coe_sort h1 -> false)) : subrel h0 h1 h2 (classical.by_contradiction' h3) := sorry --non-trivial
lemma new_lemma_8657 (h0 : topological_space (ordered_comm_ring (has_neg (has_Inf name)))) : regular_space (ordered_comm_ring (has_neg (has_Inf name))) := sorry --non-trivial
lemma new_lemma_8658 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @separated_space.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) uniform_space.{0}) (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_8659 (h0 : group (add_cancel_monoid (has_add (option ennreal)))) : is_simple_group (add_cancel_monoid (has_add (option ennreal))) := sorry --non-trivial
lemma new_lemma_8660 (h0 : fin has_zero.zero) : @path_connected_space.{0} (has_pos_part.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_pos_part.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_8661 (h0 : ordered_add_comm_monoid (simple_graph (ring pos))) : archimedean (simple_graph (ring pos)) := sorry --non-trivial
lemma new_lemma_8662 (h0 : uniform_space (has_bot (has_neg pos))) : complete_space (has_bot (has_neg pos)) := sorry --non-trivial
lemma new_lemma_8663 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (partial_order.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_8664 (h0 : function.extfun Type (functor.add_const (functor.add_const (ordered_add_comm_monoid nnreal) empty))) : archimedean nnreal := sorry --non-trivial
lemma new_lemma_8665 (h0 : topological_space (ring (has_add pos))) : path_connected_space (ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_8666 (h0 : list (has_nndist num)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_8667 (h0 : uniform_space (ordered_comm_ring (ring pos))) : separated_space (ordered_comm_ring (ring pos)) := sorry --non-trivial
lemma new_lemma_8668 (h0 : nat -> Prop -> Prop) (h1 : nat) (h2 : order_hom nat (order_hom nat Prop)) : nat.repeat h0 h1 (monotonic_sequence_limit (monotonic_sequence_limit h2)) := sorry --non-trivial
lemma new_lemma_8669 (h0 : topological_space (cancel_monoid (has_add (has_add (ring name))))) : preconnected_space (cancel_monoid (has_add (has_add (ring name)))) := sorry --non-trivial
lemma new_lemma_8670 (h0 : function.extfun Type group) : @is_simple_group.{0} (add_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (add_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_8671 (h0 : group (has_add (has_Inf name))) : group.fg (has_add (has_Inf name)) := sorry --non-trivial
lemma new_lemma_8672 (h0 : functor.add_const (function.extfun Type topological_space) (finset pos)) : @preconnected_space.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (finset.{0} pos) h0) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_8673 (h0 : group (ordered_comm_monoid (has_neg (has_neg linarith.comp)))) : group.fg (ordered_comm_monoid (has_neg (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_8674 (h0 : functor.add_const (add_monoid (bin_tree num)) congr_arg_kind) : @add_monoid.fg.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (bin_tree.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_8675 (h0 : functor.comp ring add_comm_monoid environment.implicit_infer_kind) : @strong_rank_condition.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} ring.{0} add_comm_monoid.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_8676 (h0 : topological_space (has_nnnorm enat)) : path_connected_space (has_nnnorm enat) := sorry --non-trivial
lemma new_lemma_8677 (h0 : uniform_space (left_cancel_monoid (semiring empty))) : separated_space (left_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_8678 (h1 : group (denumerable (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm string_imp)))))) : group.fg (denumerable (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm string_imp))))) := sorry --non-trivial
lemma new_lemma_8679 (h0 : finset (has_Inf (has_Inf name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_8680 (h0 : not (ring (dlist fun_info) -> false)) : @rank_condition.{0} (dlist.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (dlist.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_8681 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_8682 (h1 : complete_lattice (measurable_space (normed_group to_additive.value_type))) : is_atomistic (measurable_space (normed_group to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_8683 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @totally_separated_space.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (sub_neg_monoid.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero))))  := sorry --non-trivial
lemma new_lemma_8684 (h0 : group (comm_ring (random_gen (random_gen fun_info)))) : is_cyclic (comm_ring (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_8685 (h0 : functor.add_const (topological_space (generalized_boolean_algebra Type)) (has_neg Type)) : @path_connected_space.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_8686 (h1 : not (topological_space (random_gen linarith.comp) -> false)) : @normal_space.{0} (random_gen.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} linarith.comp)) h1)  := sorry --non-trivial
lemma new_lemma_8687 (h0 : monoid (has_top (has_top linarith.comp_source))) : monoid.fg (has_top (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_8688 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @locally_compact_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_8689 (h0 : functor.add_const (topological_space (has_neg pos)) pos) : @preirreducible_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_8690 (h0 : has_lt (has_nnnorm (mul_one_class (mul_one_class environment.projection_info)))) : no_max_order (has_nnnorm (mul_one_class (mul_one_class environment.projection_info))) := sorry --non-trivial
lemma new_lemma_8691 (h0 : not (group (has_append (comm_ring (has_nnnorm (comm_ring (comm_ring (has_nnnorm char)))))) -> false)) : @is_cyclic.{0} (has_append.{0} (comm_ring.{0} (has_nnnorm.{0} (comm_ring.{0} (comm_ring.{0} (has_nnnorm.{0} char)))))) (@classical.by_contradiction'.{1} (group.{0} (has_append.{0} (comm_ring.{0} (has_nnnorm.{0} (comm_ring.{0} (comm_ring.{0} (has_nnnorm.{0} char))))))) h0)  := sorry --non-trivial
lemma new_lemma_8692 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_8693 (h0 : topological_space (left_cancel_monoid (semiring num))) : irreducible_space (left_cancel_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_8694 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_8695 (h0 : topological_space (has_sub num)) : locally_compact_space (has_sub num) := sorry --non-trivial
lemma new_lemma_8696 (h0 : functor.add_const (filter (has_neg linarith.comp)) (finset environment.implicit_infer_kind)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_8697 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @unique_factorization_monoid.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 cancel_comm_monoid_with_zero.{1}) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_8698 (h0 : functor.add_const (topological_space Type) Type) : @t1_space.{1} Type (@functor.add_const.run.{1 1} (topological_space.{1} Type) Type h0)  := sorry --non-trivial
lemma new_lemma_8699 (h0 : finset (boolean_algebra.core (boolean_algebra Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_8700 (h0 : fin has_zero.zero) : @normal_space.{0} (ordered_comm_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_8701 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_8702 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_8703 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (add_left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_8704 (h0 : topological_space (ordered_comm_ring (has_add (has_Inf pos)))) : totally_separated_space (ordered_comm_ring (has_add (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_8705 (h0 : ring (has_top (lattice char))) : strong_rank_condition (has_top (lattice char)) := sorry --non-trivial
lemma new_lemma_8706 (h0 : group (complete_linear_order unsigned)) : is_cyclic (complete_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_8707 (h0 : topological_space (add_comm_monoid (has_neg_part environment.implicit_infer_kind))) : totally_separated_space (add_comm_monoid (has_neg_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_8708 (h0 : topological_space (complete_distrib_lattice (comm_semigroup pos))) : sequential_space (complete_distrib_lattice (comm_semigroup pos)) := sorry --non-trivial
lemma new_lemma_8709 (h0 : std_gen -> std_gen -> Prop) (h1 h2 : std_gen) : relation.refl_trans_gen h0 h1 h2 := sorry --non-trivial
lemma new_lemma_8710 (h2 : ring (distrib (random_gen (random_gen char)))) : rank_condition (distrib (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_8711 (h0 : topological_space (complete_distrib_lattice ennreal)) : discrete_topology (complete_distrib_lattice ennreal) := sorry --non-trivial
lemma new_lemma_8712 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (finset.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (finset.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_8713 (h0 : add_group (fintype (random_gen (random_gen (random_gen (random_gen char)))))) : is_add_cyclic (fintype (random_gen (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_8714 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) pos) : @t1_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_8715 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_8716 (h0 : topological_space (has_neg environment.implicit_infer_kind)) : locally_compact_space (has_neg environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_8717 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen unsigned))) : @locally_compact_space.{0} (random_gen.{0} unsigned) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} unsigned) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} unsigned)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_8718 (h0 : preorder (has_union empty)) (h1 : function.extfun (has_union empty) (fun (x : has_union empty), Prop)) : set.ord_connected (function.extfun_app h1) := sorry --non-trivial
lemma new_lemma_8719 (h0 : functor.add_const (group (has_add pos)) linarith.comp) : @group.fg.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_8720 (h0 : group (complete_distrib_lattice (has_add Type))) : normalizer_condition (complete_distrib_lattice (has_add Type)) := sorry --non-trivial
lemma new_lemma_8721 (h0 : group (has_top (has_norm (random_gen linarith.ineq)))) : group.fg (has_top (has_norm (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_8722 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @totally_separated_space.{0} (ring.{0} ordering) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (ring.{0} ordering))  := sorry --non-trivial
lemma new_lemma_8723 (h0 : functor.add_const (function.extfun Type uniform_space) pos) : @complete_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) pos h0) (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_8724 (h0 : topological_space (has_norm (random_gen string_imp))) : totally_separated_space (has_norm (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_8725 (h0 : functor.add_const (topological_space (has_add pos)) (ring (ring environment.implicit_infer_kind))) : @normal_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) (ring.{0} (ring.{0} environment.implicit_infer_kind)) h0)  := sorry --non-trivial
lemma new_lemma_8726 (h0 : functor.add_const (ring (omega_complete_partial_order empty)) (option (option empty))) : @is_principal_ideal_ring.{0} (omega_complete_partial_order.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (omega_complete_partial_order.{0} empty)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_8727 (h0 : topological_space (semigroup (finset (has_add (finset environment.implicit_infer_kind))))) : irreducible_space (semigroup (finset (has_add (finset environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_8728 (h0 : filter (has_add (finset linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_8729 (h0 : topological_space (mul_one_class reducibility_hints)) : path_connected_space (mul_one_class reducibility_hints) := sorry --non-trivial
lemma new_lemma_8730 (h0 : group (has_neg (has_to_string (has_to_string name)))) : normalizer_condition (has_neg (has_to_string (has_to_string name))) := sorry --non-trivial
lemma new_lemma_8731 (h1 : topological_space (random_gen linarith.comp_source)) : t0_space (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_8732 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_add_cyclic.{0} (add_group.{0} (has_top.{0} fun_info)) (@matrix.vec_empty.{0} (add_group.{0} (add_group.{0} (has_top.{0} fun_info))) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_8733 (h0 : complete_lattice (monoid_with_zero (option pos))) : complete_lattice.is_Sup_finite_compact (monoid_with_zero (option pos)) := sorry --non-trivial
lemma new_lemma_8734 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_8735 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_8736 (h0 : not (ring (has_compl enat) -> false)) : @rank_condition.{0} (has_compl.{0} enat) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} enat)) h0)  := sorry --non-trivial
lemma new_lemma_8737 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_star.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_star.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_8738 (h0 : topological_space (has_emptyc (semiring (semiring num)))) : irreducible_space (has_emptyc (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_8739 (h0 : topological_space (ordered_comm_ring (has_Inf linarith.comp))) : irreducible_space (ordered_comm_ring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_8740 (h0 : topological_space (has_star (semiring empty))) : totally_disconnected_space (has_star (semiring empty)) := sorry --non-trivial
lemma new_lemma_8741 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (sub_neg_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_8742 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) unsigned) : @archimedean.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) unsigned h0) (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_8743 (h0 : finset (complete_linear_order (semiring (semiring congr_arg_kind)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_8744 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (@id.{2} Type fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (@id.{2} Type fun_info))  := sorry --non-trivial
lemma new_lemma_8745 (h0 : topological_space (normed_group (random_gen linarith.ineq))) : path_connected_space (normed_group (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_8746 (h0 : functor.add_const (topological_space (mul_zero_class congr_arg_kind)) unsigned) : @t0_space.{0} (mul_zero_class.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_8747 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra linarith.comp)) (ring (has_add linarith.comp))) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.{0} linarith.comp)) (ring.{0} (has_add.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_8748 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_add pos)) := sorry --non-trivial
lemma new_lemma_8749 (h0 : complete_lattice (left_cancel_monoid (semiring empty))) : complete_lattice.is_Sup_finite_compact (left_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_8750 (h0 : not (filter (nondiscrete_normed_field linarith.ineq) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_8751 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (finset.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_8752 (h0 : group (linear_ordered_comm_group congr_arg_kind)) : group.fg (linear_ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_8753 (h0 : functor.add_const (topological_space (bin_tree num)) congr_arg_kind) : @irreducible_space.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_8754 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} h0 (linear_ordered_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_8755 (h0 : not (complete_lattice (simple_graph to_additive.value_type) -> false)) : @is_compactly_generated.{0} (simple_graph.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (simple_graph.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_8756 (h0 : group (normed_lattice_add_comm_group (has_Inf (has_add linarith.comp)))) : group.fg (normed_lattice_add_comm_group (has_Inf (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_8757 (h0 : add_group (has_to_string (option (option (option pos))))) : is_add_cyclic (has_to_string (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_8758 (h0 : add_group (topological_space (has_lt (comm_ring (comm_ring (normed_field linarith.ineq)))))) : is_add_cyclic (topological_space (has_lt (comm_ring (comm_ring (normed_field linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_8759 (h0 : topological_space (comm_semigroup (has_pos_part Type))) : preconnected_space (comm_semigroup (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_8760 (h0 : empty -> empty -> Prop) : is_refl empty h0 := sorry --non-trivial
lemma new_lemma_8761 (h0 : not (group (measure_theory.measure_space congr_arg_kind) -> false)) : @group.fg.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (measure_theory.measure_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_8762 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @normalizer_condition.{0} (measurable_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (measurable_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_8763 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring num))) : @is_add_cyclic.{0} (linear_ordered_semiring.{0} num) (@finset.pi.empty.{1 0} Type add_group.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_8764 (h0 : fin has_zero.zero) : @is_atomistic.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (ordered_comm_ring.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))))  := sorry --non-trivial
lemma new_lemma_8765 (h0 : group (cancel_monoid (option empty))) : is_cyclic (cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_8766 (h0 : topological_space (normed_group linarith.comp)) : totally_disconnected_space (normed_group linarith.comp) := sorry --non-trivial
lemma new_lemma_8767 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_8768 (h0 : ring (has_top (random_gen to_additive.value_type))) : strong_rank_condition (has_top (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_8769 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_8770 (h0 : topological_space (complete_distrib_lattice (ring (ring (ring linarith.comp))))) : t1_space (complete_distrib_lattice (ring (ring (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_8771 (h0 : topological_space (left_cancel_monoid (semiring (semiring congr_arg_kind)))) : normal_space (left_cancel_monoid (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_8772 (h0 : ring (measurable_space.dynkin_system (option unsigned))) : is_domain (measurable_space.dynkin_system (option unsigned)) := sorry --non-trivial
lemma new_lemma_8773 (h0 : uniform_space (finset ennreal)) : separated_space (finset ennreal) := sorry --non-trivial
lemma new_lemma_8774 (h0 : group (has_top (random_gen (random_gen linarith.ineq)))) : group.fg (has_top (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_8775 (h1 : ring (measurable_space.dynkin_system (has_nnnorm char))) : strong_rank_condition (measurable_space.dynkin_system (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_8776 (h0 : semiring (has_union (semiring congr_arg_kind))) : is_noetherian_ring (has_union (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_8777 (h1 : topological_space (has_compl environment.projection_info)) : path_connected_space (has_compl environment.projection_info) := sorry --non-trivial
lemma new_lemma_8778 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_8779 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (normed_group num)) := sorry --non-trivial
lemma new_lemma_8780 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @loc_path_connected_space.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_8781 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_8782 (h0 : functor.add_const (topological_space (bin_tree unsigned)) unsigned) : @discrete_topology.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_8783 (h0 : fin has_zero.zero) : @preirreducible_space.{0} pos (@matrix.vec_empty.{0} (topological_space.{0} pos) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_8784 (h0 : list (monoid (complete_distrib_lattice pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_8785 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (distrib_lattice.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (distrib_lattice.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_8786 (h0 : topological_space (linear_ordered_add_comm_group (random_gen (random_gen to_additive.value_type)))) : t0_space (linear_ordered_add_comm_group (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_8787 (h1 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_separated_space.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h1) (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_8788 (h0 : functor.add_const (function.extfun Type group) pos) : @is_cyclic.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_8789 (h0 : topological_space (has_norm (has_norm fun_info))) : discrete_topology (has_norm (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_8790 (h0 : uniform_space (has_emptyc (random_gen (random_gen (has_top fun_info))))) : separated_space (has_emptyc (random_gen (random_gen (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_8791 (h0 : group (preorder (semiring (has_Sup congr_arg_kind)))) : normalizer_condition (preorder (semiring (has_Sup congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_8792 (h0 : functor.add_const (topological_space name) empty) : @t0_space.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) empty h0)  := sorry --non-trivial
lemma new_lemma_8793 (h0 : functor.add_const (ordered_add_comm_monoid (linear_order empty)) (option empty)) : @archimedean.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (linear_order.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_8794 (h0 : topological_space (has_dist unsigned)) : totally_disconnected_space (has_dist unsigned) := sorry --non-trivial
lemma new_lemma_8795 (h0 : topological_space (has_pos_part (has_Inf (has_bot real)))) : regular_space (has_pos_part (has_Inf (has_bot real))) := sorry --non-trivial
lemma new_lemma_8796 (h0 : topological_space (ring (has_add (has_add Type)))) : t0_space (ring (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_8797 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_principal_ideal_ring.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_8798 (h0 : complete_lattice (has_top (has_norm fun_info))) : complete_lattice.is_Sup_finite_compact (has_top (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_8799 (h0 : functor.add_const (ordered_comm_monoid (ordered_comm_ring name)) name) : @has_exists_mul_of_le.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ordered_comm_ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_8800 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_edist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_edist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_8801 (h0 : functor.add_const (ordered_comm_monoid (has_nndist Type)) name) : @has_exists_mul_of_le.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (has_nndist.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_8802 (h0 : group (random_gen (random_gen num))) : normalizer_condition (random_gen (random_gen num)) := sorry --non-trivial
lemma new_lemma_8803 (h0 : group (with_one (has_nnnorm (has_nnnorm to_additive.value_type)))) : group.fg (with_one (has_nnnorm (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_8804 (h0 : group (simple_graph (boolean_algebra.core Type))) : group.fg (simple_graph (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_8805 (h1 : not (ring (has_emptyc linarith.ineq) -> false)) : @is_domain.{0} (has_emptyc.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (has_emptyc.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_8806 (h0 : topological_space (has_nnnorm (mul_one_class string.iterator_imp))) : t0_space (has_nnnorm (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_8807 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @totally_disconnected_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_8808 (h0 : functor.add_const (monoid (has_dist num)) num) : @monoid.fg.{0} (has_dist.{0} num) (@functor.add_const.run.{0 0} (monoid.{0} (has_dist.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_8809 (h0 : not (cancel_comm_monoid_with_zero (linear_ordered_semiring empty) -> false)) : @unique_factorization_monoid.{0} (linear_ordered_semiring.{0} empty) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (linear_ordered_semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_8810 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) linarith.comp) : @normal_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_8811 (h1 : std_gen -> std_gen -> Prop) (h2 : std_gen) (h3 : rbmap std_gen char h1) : rbmap.mem h2 h3 := sorry --non-trivial
lemma new_lemma_8812 (h0 : topological_space (left_cancel_monoid num)) : topological_space.separable_space (left_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_8813 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_8814 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (has_compl.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_compl.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_8815 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (has_pos_part.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (has_pos_part.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_8816 (h0 : group (non_assoc_semiring (semiring congr_arg_kind))) : is_cyclic (non_assoc_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_8817 (h0 : monoid (ordered_comm_ring (ring (ring linarith.comp)))) : monoid.fg (ordered_comm_ring (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_8818 (h0 : topological_space (has_neg (has_pos_part pos))) : totally_disconnected_space (has_neg (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_8819 (h0 : topological_space (ring (finset (finset pos)))) : totally_disconnected_space (ring (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_8820 (h0 : has_coe (nondiscrete_normed_field environment.projection_info) Prop) (h3 : nondiscrete_normed_field environment.projection_info) : @coe_b.{1 1} (nondiscrete_normed_field.{0} environment.projection_info) Prop h0 h3  := sorry --non-trivial
lemma new_lemma_8821 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_8822 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_8823 (h0 : topological_space (finset (has_pos_part linarith.comp))) : irreducible_space (finset (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_8824 (h0 : ring (has_pos_part (finset (finset linarith.comp)))) : rank_condition (has_pos_part (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_8825 (h0 : ring (has_le (mul_one_class string.iterator_imp))) : rank_condition (has_le (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_8826 (h0 : topological_space (semiring (option (option empty)))) : totally_separated_space (semiring (option (option empty))) := sorry --non-trivial
lemma new_lemma_8827 (h0 : complete_lattice (has_top (has_norm (has_norm congr_arg_kind)))) : is_atomistic (has_top (has_norm (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_8828 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @locally_compact_space.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_8829 (h0 : group (ordered_comm_ring Type)) : is_cyclic (ordered_comm_ring Type) := sorry --non-trivial
lemma new_lemma_8830 (h0 : ring (with_zero (random_gen linarith.ineq))) : is_domain (with_zero (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_8831 (h2 : list (with_one congr_arg_kind)) : list.nodup h2 := sorry --non-trivial
lemma new_lemma_8832 (h0 : group (partial_order num)) : group.fg (partial_order num) := sorry --non-trivial
lemma new_lemma_8833 (h0 : group (random_gen string_imp)) : normalizer_condition (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_8834 (h0 : complete_lattice (has_inv to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (has_inv to_additive.value_type) := sorry --non-trivial
lemma new_lemma_8835 (h0 : ring (semi_normed_ring (has_nnnorm reducibility_hints))) : is_domain (semi_normed_ring (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_8836 (h0 : complete_lattice (mul_one_class char)) : complete_lattice.is_Sup_finite_compact (mul_one_class char) := sorry --non-trivial
lemma new_lemma_8837 (h1 : set (char -> char)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_8838 (h1 : uniform_space (distrib (comm_ring char))) : complete_space (distrib (comm_ring char)) := sorry --non-trivial
lemma new_lemma_8839 (h0 : not (group (has_ssubset linarith.comp_source) -> false)) : @is_cyclic.{0} (has_ssubset.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (has_ssubset.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_8840 (h0 : cancel_comm_monoid_with_zero (has_union congr_arg_kind)) : unique_factorization_monoid (has_union congr_arg_kind) := sorry --non-trivial
lemma new_lemma_8841 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} fun_info (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) fun_info)  := sorry --non-trivial
lemma new_lemma_8842 (h0 : semiring (ring (has_to_string (has_add (has_add environment.implicit_infer_kind))))) : is_noetherian_ring (ring (has_to_string (has_add (has_add environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_8843 (h1 : ring (random_gen (has_ssubset char))) : rank_condition (random_gen (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_8844 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_monoid_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_8845 (h0 : fin has_zero.zero) : @is_noetherian_ring.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (semiring.{1} (ordered_comm_ring.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_8846 (h0 : functor.add_const (ring (add_comm_monoid pos)) (has_neg pos)) : @is_principal_ideal_ring.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} pos)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_8847 (h0 : function.extfun Type (functor.comp ring cancel_monoid)) : @is_domain.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} ring.{0} cancel_monoid.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} cancel_monoid.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_8848 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_neg num)) := sorry --non-trivial
lemma new_lemma_8849 (h0 : topological_space (dlist num)) : totally_disconnected_space (dlist num) := sorry --non-trivial
lemma new_lemma_8850 (h0 : ring (finset (has_add (has_add name)))) : is_domain (finset (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_8851 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) empty) : @normal_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_8852 (h0 : filter (id (random_gen (has_top (has_top linarith.comp))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_8853 (h0 : ring (finset (finset (finset pos)))) : is_domain (finset (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_8854 (h0 : filter (has_top (has_nnnorm fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_8855 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @preconnected_space.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_8856 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) pos) : @topological_space.separable_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_8857 (h0 : not (group (has_sub unsigned) -> false)) : @normalizer_condition.{0} (has_sub.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (has_sub.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_8858 (h0 : function.extfun Type (functor.add_const (list (canonically_linear_ordered_monoid num)))) : palindrome (functor.add_const.run (function.extfun_app h0 unsigned)) := sorry --non-trivial
lemma new_lemma_8859 (h0 : ring (has_pos_part (has_neg name))) : is_principal_ideal_ring (has_pos_part (has_neg name)) := sorry --non-trivial
lemma new_lemma_8860 (h0 : functor.add_const (uniform_space (boolean_algebra.core linarith.comp)) linarith.comp) : @complete_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.core.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_8861 (h0 : semiring (sub_neg_monoid empty)) : is_noetherian_ring (sub_neg_monoid empty) := sorry --non-trivial
lemma new_lemma_8862 (h0 : topological_space (has_bot real)) : t0_space (has_bot real) := sorry --non-trivial
lemma new_lemma_8863 (h0 : topological_space (monoid (option (option ennreal)))) : irreducible_space (monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_8864 (h0 : ring (has_append (has_nnnorm (has_nnnorm reducibility_hints)))) : rank_condition (has_append (has_nnnorm (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_8865 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_inv.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_inv.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_8866 (h0 : functor.comp list has_to_string Type) : palindrome (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_8867 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_8868 (h1 : topological_space (has_ssubset (random_gen (has_ssubset linarith.comp_source)))) : t0_space (has_ssubset (random_gen (has_ssubset linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_8869 (h0 : topological_space (add_comm_monoid (option congr_arg_kind))) : discrete_topology (add_comm_monoid (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_8870 (h0 : functor.add_const (topological_space (free_add_monoid unsigned)) unsigned) : @locally_compact_space.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_8871 (h0 : ordered_comm_monoid (has_neg (finset environment.implicit_infer_kind))) : has_exists_mul_of_le (has_neg (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_8872 (h0 : functor.add_const (function.extfun Type list) (ring name)) : palindrome (function.extfun_app (functor.add_const.run h0) (ordered_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_8873 (h0 : functor.add_const (topological_space (sub_neg_monoid linarith.comp)) (has_Inf linarith.comp)) : @regular_space.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_8874 (h0 : topological_space (has_to_string (has_neg_part ennreal))) : path_connected_space (has_to_string (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_8875 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_8876 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) linarith.comp) : @normal_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_8877 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_8878 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} real (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 real)  := sorry --non-trivial
lemma new_lemma_8879 (h0 : has_mem.mem (random_gen num) has_emptyc.emptyc) : @path_connected_space.{0} (random_gen.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_8880 (h0 : filter (has_zero (has_add (has_add pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_8881 (h1 : has_lt char) : no_max_order char := sorry --non-trivial
lemma new_lemma_8882 (h0 : ordered_add_comm_monoid (complete_distrib_lattice (has_nndist (has_add pos)))) : archimedean (complete_distrib_lattice (has_nndist (has_add pos))) := sorry --non-trivial
lemma new_lemma_8883 (h0 : functor.add_const (ordered_add_comm_monoid (comm_group environment.implicit_infer_kind)) linarith.comp) : @archimedean.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (comm_group.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_8884 (h0 : topological_space (has_nnnorm reducibility_hints)) : path_connected_space (has_nnnorm reducibility_hints) := sorry --non-trivial
lemma new_lemma_8885 (h0 : functor.add_const (uniform_space (semigroup Type)) (ring pos)) : @separated_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (semigroup.{1} Type)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_8886 (h1 : group (has_add (comm_ring (normed_group (normed_group string_imp))))) : is_cyclic (has_add (comm_ring (normed_group (normed_group string_imp)))) := sorry --non-trivial
lemma new_lemma_8887 (h2 : complete_lattice (has_append linarith.comp_source)) : is_compactly_generated (has_append linarith.comp_source) := sorry --non-trivial
lemma new_lemma_8888 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_8889 (h1 : topological_space (has_compl (comm_ring char))) : path_connected_space (has_compl (comm_ring char)) := sorry --non-trivial
lemma new_lemma_8890 (h0 : functor.add_const (uniform_space (ordered_comm_group empty)) empty) : @separated_space.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_comm_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_8891 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) Type) : @t1_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_8892 (h0 : not (group (has_ssubset linarith.ineq) -> false)) : @group.fg.{0} (has_ssubset.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (has_ssubset.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_8893 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring pos)) environment.implicit_infer_kind) : @strong_rank_condition.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_comm_semiring.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_8894 (h0 : complete_lattice (mul_zero_class (add_cancel_monoid (has_nndist pos)))) : is_atomistic (mul_zero_class (add_cancel_monoid (has_nndist pos))) := sorry --non-trivial
lemma new_lemma_8895 (h0 : not (list (has_top linarith.comp_source) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_8896 (h0 : ring (has_nndist unsigned) -> ring (has_nndist unsigned) -> Prop) : is_symm (ring (has_nndist unsigned)) h0 := sorry --non-trivial
lemma new_lemma_8897 (h0 : monoid (has_to_string (finset (has_neg linarith.comp)))) : monoid.fg (has_to_string (finset (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_8898 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (normed_group.{0} (has_top.{0} fun_info)) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (normed_group.{0} (has_top.{0} fun_info)))  := sorry --non-trivial
lemma new_lemma_8899 (h0 : topological_space (has_inv linarith.comp_source)) : totally_disconnected_space (has_inv linarith.comp_source) := sorry --non-trivial
lemma new_lemma_8900 (h0 : has_mem.mem string_imp has_emptyc.emptyc) : @is_cyclic.{0} string_imp (@finset.pi.empty.{1 0} Type group.{0} string_imp h0)  := sorry --non-trivial
lemma new_lemma_8901 (h0 : function.extfun Type (functor.add_const (topological_space (semigroup num)))) : @discrete_topology.{0} (semigroup.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} num)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (semigroup.{0} num))) h0 empty))  := sorry --non-trivial
lemma new_lemma_8902 (h0 : functor.add_const (ring (has_pos_part linarith.comp)) linarith.comp) : @is_principal_ideal_ring.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_pos_part.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_8903 (h0 : topological_space (boolean_algebra.core (has_add unsigned))) : path_connected_space (boolean_algebra.core (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_8904 (h0 : function.extfun Type group) : @is_simple_group.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_8905 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_8906 (h0 : ring (finset (finset (has_add environment.implicit_infer_kind)))) : rank_condition (finset (finset (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_8907 (h0 : ring (has_append (has_nnnorm char))) : rank_condition (has_append (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_8908 (h0 : list (preorder congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_8909 (h0 : topological_space (comm_semigroup char)) : totally_disconnected_space (comm_semigroup char) := sorry --non-trivial
lemma new_lemma_8910 (h0 : functor.add_const (monoid (boolean_algebra pos)) name) : @monoid.fg.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_8911 (h0 : topological_space (with_one (has_norm (has_norm (has_norm linarith.comp_source))))) : totally_disconnected_space (with_one (has_norm (has_norm (has_norm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_8912 (h0 : group (has_nnnorm to_additive.value_type)) : group.fg (has_nnnorm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_8913 (h0 : ordered_comm_monoid (finset (boolean_algebra (normed_comm_ring Type)))) : has_exists_mul_of_le (finset (boolean_algebra (normed_comm_ring Type))) := sorry --non-trivial
lemma new_lemma_8914 (h0 : topological_space (complete_semilattice_Sup (random_gen to_additive.value_type))) : path_connected_space (complete_semilattice_Sup (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_8915 (h0 : filter (has_zero (option name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_8916 (h0 : monoid (add_cancel_monoid (ordered_ring Type))) : monoid.fg (add_cancel_monoid (ordered_ring Type)) := sorry --non-trivial
lemma new_lemma_8917 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_8918 (h0 : functor.add_const (function.extfun (Type 1) group) name) : @is_cyclic.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) name h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_8919 (h0 : ordered_add_comm_monoid (has_to_string (has_add (has_add (mul_zero_class Type))))) : archimedean (has_to_string (has_add (has_add (mul_zero_class Type)))) := sorry --non-trivial
lemma new_lemma_8920 (h0 : filter (has_to_string num)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_8921 (h0 : add_group (has_top (semiring (semiring (semiring num))))) : is_add_cyclic (has_top (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_8922 (h0 : ring (has_bot (has_add (has_add linarith.comp)))) : is_domain (has_bot (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_8923 (h0 : topological_space (semi_normed_ring reducibility_hints)) : totally_disconnected_space (semi_normed_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_8924 (h0 : ring (sub_neg_monoid (has_add name))) : rank_condition (sub_neg_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_8925 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (bin_tree.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_8926 (h0 : ring (has_inv (comm_ring fun_info))) : is_domain (has_inv (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_8927 (h0 : topological_space (add_cancel_monoid (has_neg (ring linarith.comp)))) : topological_space.separable_space (add_cancel_monoid (has_neg (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_8928 (h0 : topological_space (has_one linarith.comp)) : t0_space (has_one linarith.comp) := sorry --non-trivial
lemma new_lemma_8929 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} unsigned (@function.extfun_app.{2 1} Type topological_space.{0} h0 unsigned)  := sorry --non-trivial
lemma new_lemma_8930 (h0 : preorder (nondiscrete_normed_field (mul_one_class std_gen))) (h1 : set (nondiscrete_normed_field (mul_one_class std_gen))) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_8931 (h0 : topological_space (generalized_boolean_algebra (has_neg Type))) : locally_compact_space (generalized_boolean_algebra (has_neg Type)) := sorry --non-trivial
lemma new_lemma_8932 (h0 : ring (has_neg (has_Inf (has_pos_part (finset environment.implicit_infer_kind))))) : is_domain (has_neg (has_Inf (has_pos_part (finset environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_8933 (h0 : semiring (lex congr_arg_kind)) : is_noetherian_ring (lex congr_arg_kind) := sorry --non-trivial
lemma new_lemma_8934 (h1 : complete_lattice (denumerable fun_info)) : is_compactly_generated (denumerable fun_info) := sorry --non-trivial
lemma new_lemma_8935 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_8936 (h0 : uniform_space (has_top (has_norm empty))) : complete_space (has_top (has_norm empty)) := sorry --non-trivial
lemma new_lemma_8937 (h0 : ring (topological_space (denumerable (has_nnnorm linarith.ineq)))) : strong_rank_condition (topological_space (denumerable (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_8938 (h0 : ring (normed_field (metric_space (metric_space char)))) : strong_rank_condition (normed_field (metric_space (metric_space char))) := sorry --non-trivial
lemma new_lemma_8939 (h0 : topological_space (boolean_algebra (has_to_string pos))) : regular_space (boolean_algebra (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_8940 (h0 : functor.add_const (uniform_space (semigroup name)) name) : @separated_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_8941 (h0 : ring (has_Inf (has_neg name))) : is_principal_ideal_ring (has_Inf (has_neg name)) := sorry --non-trivial
lemma new_lemma_8942 (h0 : topological_space (has_zero (finset (has_neg (ring Type))))) : path_connected_space (has_zero (finset (has_neg (ring Type)))) := sorry --non-trivial
lemma new_lemma_8943 (h0 : topological_space (random_gen linarith.ineq)) : locally_compact_space (random_gen linarith.ineq) := sorry --non-trivial
lemma new_lemma_8944 (h0 : topological_space (linear_ordered_field num)) : totally_separated_space (linear_ordered_field num) := sorry --non-trivial
lemma new_lemma_8945 (h0 : topological_space (has_neg (has_pos_part linarith.comp))) : topological_space.separable_space (has_neg (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_8946 (h0 : add_group (semigroup congr_arg_kind)) : is_add_cyclic (semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_8947 (h0 : topological_space (has_top (semiring (semiring empty)))) : path_connected_space (has_top (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_8948 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_8949 (h0 : functor.add_const (add_group (has_pos_part linarith.comp)) (ring linarith.comp)) : @is_add_cyclic.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (has_pos_part.{0} linarith.comp)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_8950 (h0 : functor.add_const (complete_lattice (preorder empty)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (preorder.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_8951 (h0 : group (ordered_comm_monoid (has_Inf (has_Inf real)))) : normalizer_condition (ordered_comm_monoid (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_8952 (h0 : filter (has_to_string (has_to_string pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_8953 (h0 : add_comm_semigroup enat -> add_comm_semigroup enat -> Prop) : is_trans (add_comm_semigroup enat) h0 := sorry --non-trivial
lemma new_lemma_8954 (h0 : measurable_space (with_zero unsigned)) (h1 : has_mul (with_zero unsigned)) (h2 : uniform_space (plift (has_measurable_mul₂ (with_zero unsigned)))) : complete_space (plift (has_measurable_mul₂ (with_zero unsigned))) := sorry --non-trivial
lemma new_lemma_8955 (h0 : uniform_space (topological_space (random_gen string_imp))) : complete_space (topological_space (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_8956 (h2 : group (random_gen (random_gen string_imp))) : is_cyclic (random_gen (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_8957 (h0 : list (has_nndist (comm_monoid unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_8958 (h0 : topological_space (has_neg (semigroup (has_Inf linarith.comp)))) : totally_disconnected_space (has_neg (semigroup (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_8959 (h0 : topological_space (ring (mul_one_class (has_Inf Type)))) : normal_space (ring (mul_one_class (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_8960 (h0 : function.extfun Type group) : @normalizer_condition.{0} nnreal (@function.extfun_app.{2 1} Type group.{0} h0 nnreal)  := sorry --non-trivial
lemma new_lemma_8961 (h0 : functor.add_const (functor.comp topological_space add_comm_monoid unsigned) unsigned) : @discrete_topology.{0} (add_comm_monoid.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} unsigned (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} topological_space.{0} add_comm_monoid.{0} unsigned) unsigned h0))  := sorry --non-trivial
lemma new_lemma_8962 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) pos) : @totally_disconnected_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_8963 (h0 : has_ssubset string_imp -> has_ssubset string_imp -> bool) : is_dec_refl h0 := sorry --non-trivial
lemma new_lemma_8964 (h0 : topological_space (add_comm_monoid (semiring empty))) : preirreducible_space (add_comm_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_8965 (h1 : complete_lattice (with_zero linarith.ineq)) : complete_lattice.is_Sup_finite_compact (with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_8966 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_8967 (h0 : topological_space (ring (ring linarith.comp))) : totally_disconnected_space (ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_8968 (h0 : complete_lattice (has_neg_part (option pos))) : is_atomistic (has_neg_part (option pos)) := sorry --non-trivial
lemma new_lemma_8969 (h0 : functor.add_const (filter (cancel_monoid Type)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_8970 (h0 : functor.add_const (monoid (add_cancel_monoid pos)) pos) : @monoid.fg.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (add_cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_8971 (h0 : group (id char)) : group.fg (id char) := sorry --non-trivial
lemma new_lemma_8972 (h0 : ordered_comm_monoid (add_comm_monoid (finset linarith.comp))) : has_exists_mul_of_le (add_comm_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_8973 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @topological_space.separable_space.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_8974 (h0 : group (distrib_lattice (random_gen (random_gen fun_info)))) : is_cyclic (distrib_lattice (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_8975 (h0 : complete_lattice (has_one num)) : is_compactly_generated (has_one num) := sorry --non-trivial
lemma new_lemma_8976 (h0 : group (has_top char)) : group.fg (has_top char) := sorry --non-trivial
lemma new_lemma_8977 (h0 : add_monoid (ring (ordered_comm_monoid (has_Inf pos)))) : add_monoid.fg (ring (ordered_comm_monoid (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_8978 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (ordered_cancel_add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (ordered_cancel_add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_8979 (h0 : add_group (has_append (has_ssubset char))) : is_add_cyclic (has_append (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_8980 (h0 : functor.add_const (function.extfun Type add_group) linarith.comp) : @is_add_cyclic.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) linarith.comp h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_8981 (h0 : fin has_zero.zero) : @strong_rank_condition.{0} (has_norm.{0} (semiring.{0} unsigned)) (@matrix.vec_empty.{0} (ring.{0} (has_norm.{0} (semiring.{0} unsigned))) h0)  := sorry --non-trivial
lemma new_lemma_8982 (h0 : not (complete_lattice (uniform_space string_imp) -> false)) : is_compactly_generated (uniform_space string_imp) := sorry --non-trivial
lemma new_lemma_8983 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @totally_disconnected_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_8984 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_8985 (h0 : function.extfun (finset Type) (has_mem.mem (complete_semilattice_Sup linarith.comp_source))) : @is_domain.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_8986 (h0 : uniform_space (boolean_algebra (finset (has_Inf linarith.comp)))) : separated_space (boolean_algebra (finset (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_8987 (h1 : not (topological_space (linear_ordered_add_comm_group num) -> false)) : @t0_space.{0} (linear_ordered_add_comm_group.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_add_comm_group.{0} num)) h1)  := sorry --non-trivial
lemma new_lemma_8988 (h0 : fin has_zero.zero) : @path_connected_space.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (normed_lattice_add_comm_group.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_8989 (h0 : functor.add_const (topological_space (has_Sup empty)) congr_arg_kind) : @discrete_topology.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_8990 (h1 : function.extfun Type ring) : @is_domain.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h1 (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_8991 (h0 : list (boolean_algebra (has_neg pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_8992 (h0 : complete_lattice (has_ssubset fun_info)) : is_compactly_generated (has_ssubset fun_info) := sorry --non-trivial
lemma new_lemma_8993 (h0 : ring (simple_graph (has_add Type))) : is_principal_ideal_ring (simple_graph (has_add Type)) := sorry --non-trivial
lemma new_lemma_8994 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (simple_graph.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (simple_graph.{0} empty))  := sorry --non-trivial
lemma new_lemma_8995 (h0 : semiring (has_union (has_norm (has_norm num)))) : is_noetherian_ring (has_union (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_8996 (h0 : functor.comp add_monoid add_comm_monoid environment.implicit_infer_kind) : @add_monoid.fg.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} add_monoid.{0} add_comm_monoid.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_8997 (h1 : nat) (h2 : function.extfun Type monoid) : monoid.fg (zmod h1) := sorry --non-trivial
lemma new_lemma_8998 (h0 : functor.add_const (function.extfun Type ring) congr_arg_kind -> Prop) (h1 : Exists (fun (x : functor.add_const (function.extfun Type ring) congr_arg_kind), h0 x)) : @rank_condition.{0} (has_star.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) congr_arg_kind (@classical.some.{2} (functor.add_const.{1 0} (function.extfun.{2 1} Type ring.{0}) congr_arg_kind) h0 h1)) (has_star.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_8999 (h0 : functor.add_const (group (semigroup linarith.comp)) (has_to_string environment.implicit_infer_kind)) : @is_simple_group.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} linarith.comp)) (has_to_string.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_9000 (h0 : has_le ereal) : no_top_order ereal := sorry --non-trivial
lemma new_lemma_9001 (h1 : function.extfun Type topological_space) : @irreducible_space.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_9002 (h0 : functor.add_const (function.extfun (Type 1) list) (ring (ring pos))) : list.nodup (function.extfun_app (functor.add_const.run h0) Type) := sorry --non-trivial
lemma new_lemma_9003 (h0 : topological_space (distrib_lattice (comm_ring linarith.ineq))) : t0_space (distrib_lattice (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_9004 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_9005 (h0 : functor.add_const (ring (plift num)) empty) : @is_principal_ideal_ring.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (ring.{1} (plift.{1} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_9006 (h0 : topological_space (random_gen (random_gen string_imp))) : path_connected_space (random_gen (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_9007 (h0 : function.extfun Type topological_space) : @regular_space.{0} (complete_distrib_lattice.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} num))  := sorry --non-trivial
lemma new_lemma_9008 (h0 : uniform_space std_gen) (h1 : ring (uniform_space.separation_quotient std_gen)) : strong_rank_condition (uniform_space.separation_quotient std_gen) := sorry --non-trivial
lemma new_lemma_9009 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring ennreal)) pos) : @loc_path_connected_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_9010 (h0 : add_group (has_top (has_top fun_info))) : is_add_cyclic (has_top (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_9011 (h0 : complete_lattice (linear_ordered_semiring (linear_ordered_semiring (semiring (semiring empty))))) : is_atomistic (linear_ordered_semiring (linear_ordered_semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_9012 (h0 : uniform_space (normed_group (has_norm congr_arg_kind))) : separated_space (normed_group (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_9013 (h0 : functor.add_const (topological_space (semigroup Type)) name) : @t1_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_9014 (h0 : function.extfun Type group) : @group.fg.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_9015 (h0 : topological_space (semigroup (add_comm_monoid (finset name)))) : regular_space (semigroup (add_comm_monoid (finset name))) := sorry --non-trivial
lemma new_lemma_9016 (h1 : ring (dlist linarith.comp_source)) : is_domain (dlist linarith.comp_source) := sorry --non-trivial
lemma new_lemma_9017 (h0 : ring (ring (has_add Type))) : rank_condition (ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_9018 (h0 : function.extfun Type topological_space) : @t1_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_9019 (h0 : topological_space (div_inv_monoid (has_Inf (has_Inf Type)))) : sequential_space (div_inv_monoid (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_9020 (h0 : functor.add_const (add_monoid (comm_group unsigned)) pos) : @add_monoid.fg.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (comm_group.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_9021 (h0 : ring (canonically_ordered_monoid (has_Inf name))) : is_domain (canonically_ordered_monoid (has_Inf name)) := sorry --non-trivial
lemma new_lemma_9022 (h0 : functor.add_const (ordered_add_comm_monoid auto.case_option) unsigned) : @archimedean.{0} auto.case_option (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} auto.case_option) unsigned h0)  := sorry --non-trivial
lemma new_lemma_9023 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_9024 (h0 : ring (has_top linarith.comp)) : rank_condition (has_top linarith.comp) := sorry --non-trivial
lemma new_lemma_9025 (h0 : topological_space (nondiscrete_normed_field ereal)) : t0_space (nondiscrete_normed_field ereal) := sorry --non-trivial
lemma new_lemma_9026 (h0 : topological_space (semi_normed_ring string.iterator_imp)) (h1 : preorder (semi_normed_ring string.iterator_imp)) : order_topology (semi_normed_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_9027 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @separated_space.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 uniform_space.{1}) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_9028 (h0 : function.extfun Type ring) : @rank_condition.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_9029 (h0 : group (free_add_monoid num)) : normalizer_condition (free_add_monoid num) := sorry --non-trivial
lemma new_lemma_9030 (h0 : functor.add_const (function.extfun (Type 1) finset) pos) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (ring Type)) := sorry --non-trivial
lemma new_lemma_9031 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (left_cancel_monoid (semiring empty))) := sorry --non-trivial
lemma new_lemma_9032 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_9033 (h0 : functor.add_const (ring (has_neg Type)) (has_Inf linarith.comp)) : @strong_rank_condition.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_neg.{1} Type)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_9034 (h0 : finset (bin_tree empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_9035 (h0 : topological_space (finset (sub_neg_monoid linarith.comp))) : regular_space (finset (sub_neg_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_9036 (h0 : topological_space (comm_semigroup (has_scalar Type real))) : regular_space (comm_semigroup (has_scalar Type real)) := sorry --non-trivial
lemma new_lemma_9037 (h0 : functor.add_const (list (has_Sup empty)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_9038 (h0 : heq (div_inv_monoid (has_nnnorm (has_nnnorm linarith.ineq))) (has_add (random_gen to_additive.value_type))) (h1 : ring (div_inv_monoid (has_nnnorm (has_nnnorm linarith.ineq)))) : @rank_condition.{0} (has_add.{0} (random_gen.{0} to_additive.value_type)) (@heq.elim.{2 1} Type (div_inv_monoid.{0} (has_nnnorm.{0} (has_nnnorm.{0} linarith.ineq))) ring.{0} (has_add.{0} (random_gen.{0} to_additive.value_type)) h0 h1)  := sorry --non-trivial
lemma new_lemma_9039 (h1 : has_mem.mem (with_bot num) has_emptyc.emptyc) : @is_atomistic.{0} (with_bot.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_bot.{0} num) h1)  := sorry --non-trivial
lemma new_lemma_9040 (h0 : function.extfun (finset Type) (has_mem.mem (id linarith.comp))) : @discrete_topology.{0} (@id.{2} Type linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (@id.{2} Type linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_9041 (h0 : uniform_space (has_ssubset (denumerable to_additive.value_type))) : separated_space (has_ssubset (denumerable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_9042 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @regular_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_9043 (h0 : topological_space (has_emptyc (semiring (semiring (semiring empty))))) : irreducible_space (has_emptyc (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_9044 (h0 : topological_space (simple_graph pos)) : loc_path_connected_space (simple_graph pos) := sorry --non-trivial
lemma new_lemma_9045 (h0 : monoid (complete_distrib_lattice (boolean_algebra.core Type))) : monoid.fg (complete_distrib_lattice (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_9046 (h0 : functor.add_const (uniform_space (has_add pos)) environment.implicit_infer_kind) : @separated_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_add.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_9047 (h2 : add_group (measurable_space linarith.comp)) : is_add_cyclic (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_9048 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_9049 (h0 : function.extfun (Type 1) topological_space) : @t1_space.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_9050 (h0 : group (ring (has_neg_part (has_neg_part linarith.comp)))) : is_simple_group (ring (has_neg_part (has_neg_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_9051 (h0 : has_mem.mem (random_gen linarith.ineq) has_emptyc.emptyc) : @monoid.fg.{0} (random_gen.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type monoid.{0} (random_gen.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_9052 (h0 : list (has_zero (has_add Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_9053 (h0 : complete_lattice (with_one num)) : complete_lattice.is_Sup_finite_compact (with_one num) := sorry --non-trivial
lemma new_lemma_9054 (h0 : complete_lattice (partial_order (option (option unsigned)))) : complete_lattice.is_Sup_finite_compact (partial_order (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_9055 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_9056 (h0 : functor.add_const Prop (complete_distrib_lattice (option (option pos)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_9057 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_9058 (h0 : functor.add_const (topological_space (metric_space num)) empty) : @discrete_topology.{0} (metric_space.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (metric_space.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_9059 (h0 : topological_space (finset (has_pos_part pos))) : t1_space (finset (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_9060 (h0 : functor.add_const (finset (has_to_string pos)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_9061 (h0 : functor.add_const (topological_space (has_zero Type)) linarith.comp) : @regular_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_9062 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) (has_Inf pos)) : @normal_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_9063 (h0 : fin has_zero.zero) : @is_compactly_generated.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (generalized_boolean_algebra.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_9064 (h0 : list (semigroup (boolean_algebra.core Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_9065 (h0 : ring (random_gen num)) : strong_rank_condition (random_gen num) := sorry --non-trivial
lemma new_lemma_9066 (h0 : functor.add_const (group (has_to_string pos)) Type) : @group.fg.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (has_to_string.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_9067 (h0 : topological_space (has_to_string (add_comm_monoid Type))) : locally_compact_space (has_to_string (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_9068 (h0 : functor.add_const (topological_space (finset linarith.comp)) Type) : @loc_path_connected_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_9069 (h4 : topological_space (add_comm_semigroup std_gen)) (h5 : preorder (add_comm_semigroup std_gen)) : order_closed_topology (add_comm_semigroup std_gen) := sorry --non-trivial
lemma new_lemma_9070 (h0 : group (ring (semigroup (has_add environment.implicit_infer_kind)))) : is_simple_group (ring (semigroup (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_9071 (h0 : topological_space (finset (has_neg pos))) : preconnected_space (finset (has_neg pos)) := sorry --non-trivial
lemma new_lemma_9072 (h2 : set (nondiscrete_normed_field char)) : set.finite h2 := sorry --non-trivial
lemma new_lemma_9073 (h0 : topological_space (linear_ordered_field (has_to_string (has_to_string congr_arg_kind)))) : loc_path_connected_space (linear_ordered_field (has_to_string (has_to_string congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_9074 (h0 : ring (linear_ordered_add_comm_group (has_nnnorm (random_gen linarith.ineq)))) : rank_condition (linear_ordered_add_comm_group (has_nnnorm (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_9075 (h0 : set (mul_one_class fun_info -> add_comm_semigroup ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_9076 (h0 : add_monoid (measure_theory.measure_space (semiring (semiring empty)))) : add_monoid.fg (measure_theory.measure_space (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_9077 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) Type) : @archimedean.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) Type h0) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_9078 (h0 : group (comm_ring fun_info)) : is_cyclic (comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_9079 (h0 : group (random_gen linarith.ineq)) : group.fg (random_gen linarith.ineq) := sorry --non-trivial
lemma new_lemma_9080 (h0 : uniform_space (non_unital_non_assoc_semiring string.iterator_imp)) : complete_space (non_unital_non_assoc_semiring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_9081 (h0 : topological_space (add_comm_monoid (ring Type))) : irreducible_space (add_comm_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_9082 (h0 : topological_space (has_norm congr_arg_kind)) : totally_disconnected_space (has_norm congr_arg_kind) := sorry --non-trivial
lemma new_lemma_9083 (h0 : topological_space (add_comm_semigroup enat)) : path_connected_space (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_9084 (h0 : ring (has_nndist (normed_comm_ring linarith.comp))) : strong_rank_condition (has_nndist (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_9085 (h0 : functor.add_const (uniform_space (finset pos)) (finset Type)) : @complete_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (finset.{0} pos)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_9086 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} empty (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) empty)  := sorry --non-trivial
lemma new_lemma_9087 (h0 : function.extfun Type group) : @normalizer_condition.{0} (add_right_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (add_right_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_9088 (h0 : functor.add_const (group (add_cancel_monoid linarith.comp)) linarith.comp) : @normalizer_condition.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_9089 (h0 : topological_space (measurable_space (has_top to_additive.value_type))) : totally_separated_space (measurable_space (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_9090 (h0 : complete_lattice (semi_normed_comm_ring (mul_one_class enat))) : is_compactly_generated (semi_normed_comm_ring (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_9091 (h0 : has_neg (linear_ordered_comm_group_with_zero enat)) (h1 : measurable_space (linear_ordered_comm_group_with_zero enat)) : has_measurable_neg (linear_ordered_comm_group_with_zero enat) := sorry --non-trivial
lemma new_lemma_9092 (h0 : functor.add_const (function.extfun Type ring) name) : @rank_condition.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name h0) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_9093 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_9094 (h0 : complete_lattice (add_cancel_monoid pos)) : is_atomistic (add_cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_9095 (h0 : functor.add_const (ring (has_zero pos)) (finset (finset (has_zero linarith.comp)))) : @strong_rank_condition.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} pos)) (finset.{0} (finset.{0} (has_zero.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_9096 (h0 : add_monoid (has_add (has_neg pos))) : add_monoid.fg (has_add (has_neg pos)) := sorry --non-trivial
lemma new_lemma_9097 (h0 : ring (has_nndist (has_add (has_add unsigned)))) : rank_condition (has_nndist (has_add (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_9098 (h1 : ring (has_nnnorm (metric_space (metric_space linarith.comp_source)))) : rank_condition (has_nnnorm (metric_space (metric_space linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_9099 (h0 h1 : multiset (simple_graph (mul_one_class reducibility_hints))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_9100 (h0 : uniform_space (add_cancel_monoid (option (option (option empty))))) : separated_space (add_cancel_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_9101 (h0 : semiring (has_add (has_neg (ring Type)))) : is_noetherian_ring (has_add (has_neg (ring Type))) := sorry --non-trivial
lemma new_lemma_9102 (h0 : not (ring (linear_ordered_semiring linarith.comp) -> false)) : @strong_rank_condition.{0} (linear_ordered_semiring.{0} linarith.comp) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_semiring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_9103 (h0 : complete_lattice (has_bot pos)) : is_atomistic (has_bot pos) := sorry --non-trivial
lemma new_lemma_9104 (h0 : functor.add_const (topological_space (ordered_comm_monoid Type)) name) : @normal_space.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_9105 (h0 : topological_space (ordered_comm_ring (has_add linarith.comp))) : discrete_topology (ordered_comm_ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_9106 (h0 : functor.add_const (function.extfun Type group) unsigned) : @normalizer_condition.{0} (cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) unsigned h0) (cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_9107 (h0 : topological_space (simple_graph (option empty))) : irreducible_space (simple_graph (option empty)) := sorry --non-trivial
lemma new_lemma_9108 (h0 : not (has_mem.mem (measurable_space num) has_emptyc.emptyc -> false)) : @totally_disconnected_space.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_9109 (h1 : uniform_space (fintype string_imp)) : complete_space (fintype string_imp) := sorry --non-trivial
lemma new_lemma_9110 (h0 : functor.add_const (semiring (finset unsigned)) Type) : @is_noetherian_ring.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 1} (semiring.{0} (finset.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_9111 (h0 : topological_space (non_assoc_semiring (semiring (semiring (semiring empty))))) : path_connected_space (non_assoc_semiring (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_9112 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_9113 (h0 : ring (has_compl (random_gen (random_gen char)))) : is_domain (has_compl (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_9114 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_9115 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (linear_ordered_comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_9116 (h0 : functor.add_const (ordered_add_comm_monoid (preorder empty)) empty) : @archimedean.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (preorder.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_9117 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) ennreal) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_9118 (h0 : complete_lattice (semiring (has_top (has_top (has_top fun_info))))) : complete_lattice.is_Sup_finite_compact (semiring (has_top (has_top (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_9119 (h0 : prod (id empty) (id empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_9120 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_emptyc.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_9121 (h0 : functor.add_const (topological_space (has_Inf name)) pos) : @path_connected_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_9122 (h0 : functor.add_const (uniform_space (has_dist congr_arg_kind)) num) : @complete_space.{0} (has_dist.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_dist.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_9123 (h0 : function.extfun Type (functor.comp add_monoid cancel_monoid)) : @add_monoid.fg.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} add_monoid.{0} cancel_monoid.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} add_monoid.{0} cancel_monoid.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_9124 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (normed_lattice_add_comm_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_9125 (h0 : complete_lattice (semiring num)) : complete_lattice.is_Sup_finite_compact (semiring num) := sorry --non-trivial
lemma new_lemma_9126 (h0 : uniform_space (normed_lattice_add_comm_group (has_add Type))) : separated_space (normed_lattice_add_comm_group (has_add Type)) := sorry --non-trivial
lemma new_lemma_9127 (h0 : uniform_space (has_to_string (has_to_string linarith.comp))) : complete_space (has_to_string (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_9128 (h0 : topological_space (random_gen linarith.comp)) : discrete_topology (random_gen linarith.comp) := sorry --non-trivial
lemma new_lemma_9129 (h0 : add_group (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) : is_add_cyclic (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_9130 (h0 : functor.comp topological_space complete_distrib_lattice Type) : @preconnected_space.{1} (complete_distrib_lattice.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} complete_distrib_lattice.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_9131 (h0 : topological_space (ordered_ring congr_arg_kind)) : normal_space (ordered_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_9132 (h1 : has_mem.mem (complete_semilattice_Sup linarith.comp_source) has_emptyc.emptyc) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (complete_semilattice_Sup.{0} linarith.comp_source) h1)  := sorry --non-trivial
lemma new_lemma_9133 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_9134 (h0 : ordered_add_comm_monoid (has_dist (option (option unsigned)))) : archimedean (has_dist (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_9135 (h0 : has_mem.mem num has_emptyc.emptyc) : @is_compactly_generated.{0} num (@finset.pi.empty.{1 0} Type complete_lattice.{0} num h0)  := sorry --non-trivial
lemma new_lemma_9136 (h0 : functor.comp complete_lattice boolean_algebra.core Type) : @is_atomistic.{1} (boolean_algebra.core.{1} Type) (@functor.comp.run.{1 1 1} complete_lattice.{1} boolean_algebra.core.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_9137 (h0 : topological_space (ring (has_nndist (ring pos)))) : totally_separated_space (ring (has_nndist (ring pos))) := sorry --non-trivial
lemma new_lemma_9138 (h0 : functor.add_const (topological_space (complete_distrib_lattice empty)) num) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_9139 (h0 : not (group (semiring congr_arg_kind) -> false)) : @is_cyclic.{0} (semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_9140 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_inv.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inv.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_9141 (h0 : complete_lattice (complete_distrib_lattice (has_add (has_add Type)))) : is_compactly_generated (complete_distrib_lattice (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_9142 (h0 : functor.add_const (functor.add_const Prop (ordered_comm_ring pos)) pos) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_9143 (h0 : functor.add_const (topological_space (bin_tree congr_arg_kind)) unsigned) : @loc_path_connected_space.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_9144 (h0 : functor.add_const (function.extfun Type uniform_space) name) : @separated_space.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) name h0) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_9145 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} nnreal (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 nnreal)  := sorry --non-trivial
lemma new_lemma_9146 (h0 : function.extfun Type ring) : @rank_condition.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_9147 (h0 : topological_space (add_comm_monoid (has_add pos))) : sequential_space (add_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_9148 (h0 : topological_space (boolean_algebra (has_add (sub_neg_monoid Type)))) : totally_separated_space (boolean_algebra (has_add (sub_neg_monoid Type))) := sorry --non-trivial
lemma new_lemma_9149 (h1 : topological_space (has_nnnorm char)) : path_connected_space (has_nnnorm char) := sorry --non-trivial
lemma new_lemma_9150 (h0 : topological_space (add_cancel_monoid (finset (has_to_string linarith.comp)))) : preirreducible_space (add_cancel_monoid (finset (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_9151 (h0 : topological_space (dlist (random_gen (random_gen to_additive.value_type)))) : path_connected_space (dlist (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_9152 (h0 : complete_lattice (has_zero (option name))) : is_atomistic (has_zero (option name)) := sorry --non-trivial
lemma new_lemma_9153 (h0 : ordered_comm_monoid (has_pos_part (has_Inf (has_Inf (has_Inf real))))) : has_exists_mul_of_le (has_pos_part (has_Inf (has_Inf (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_9154 (h0 : group (has_bot (has_add (has_pos_part (has_Inf pos))))) : is_simple_group (has_bot (has_add (has_pos_part (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_9155 (h0 : monoid (add_cancel_monoid (has_add environment.implicit_infer_kind))) : monoid.fg (add_cancel_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_9156 (h0 : functor.add_const (topological_space (has_add Type)) linarith.comp) : @preconnected_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_9157 (h0 : uniform_space (normed_comm_ring (finset unsigned))) : separated_space (normed_comm_ring (finset unsigned)) := sorry --non-trivial
lemma new_lemma_9158 (h0 : set (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup linarith.ineq))))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_9159 (h0 : topological_space (has_add (has_zero name))) : sequential_space (has_add (has_zero name)) := sorry --non-trivial
lemma new_lemma_9160 (h0 : complete_lattice (has_top (semiring (has_top (has_norm linarith.comp))))) : is_atomistic (has_top (semiring (has_top (has_norm linarith.comp)))) := sorry --non-trivial
lemma new_lemma_9161 (h0 : functor.add_const (functor.add_const (topological_space environment.implicit_infer_kind) Type) Type) : @path_connected_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 1} (topological_space.{0} environment.implicit_infer_kind) Type (@functor.add_const.run.{0 1} (functor.add_const.{0 1} (topological_space.{0} environment.implicit_infer_kind) Type) Type h0))  := sorry --non-trivial
lemma new_lemma_9162 (h0 : topological_space (ring (has_neg Type))) : regular_space (ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_9163 (h0 : not (uniform_space (has_nnnorm fun_info) -> false)) : @complete_space.{0} (has_nnnorm.{0} fun_info) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_nnnorm.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_9164 (h0 : topological_space (has_zero (option (mul_zero_class name)))) : sequential_space (has_zero (option (mul_zero_class name))) := sorry --non-trivial
lemma new_lemma_9165 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_9166 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_9167 (h0 : topological_space (has_neg_part (has_add pos))) : preconnected_space (has_neg_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_9168 (h0 : topological_space (ordered_comm_monoid (has_Inf linarith.comp))) : normal_space (ordered_comm_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_9169 (h0 : functor.comp topological_space semigroup name) : @path_connected_space.{0} (semigroup.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} name h0)  := sorry --non-trivial
lemma new_lemma_9170 (h0 : not (complete_lattice (bin_tree empty) -> false)) : @is_compactly_generated.{0} (bin_tree.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (bin_tree.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_9171 (h0 : not (Prop -> false)) (h1 : setoid (classical.by_contradiction' h0)) : quotient h1 := sorry --non-trivial
lemma new_lemma_9172 (h0 : filter (canonically_ordered_comm_semiring (has_to_string (has_to_string pos)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_9173 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_9174 (h0 : topological_space (has_Inf (ordered_ring (has_Inf (has_Inf (has_neg Type)))))) : t0_space (has_Inf (ordered_ring (has_Inf (has_Inf (has_neg Type))))) := sorry --non-trivial
lemma new_lemma_9175 (h0 : set (nondiscrete_normed_field (mul_one_class char))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_9176 (h0 : char -> char -> Prop) : is_strict_total_order' char h0 := sorry --non-trivial
lemma new_lemma_9177 (h0 : not (semiring (has_sub num) -> false)) : @is_noetherian_ring.{0} (has_sub.{0} num) (@classical.by_contradiction'.{1} (semiring.{0} (has_sub.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_9178 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (omega_complete_partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (omega_complete_partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_9179 (h0 : functor.add_const (ordered_comm_monoid (has_neg_part Type)) (boolean_algebra (has_add name))) : @has_exists_mul_of_le.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (has_neg_part.{1} Type)) (boolean_algebra.{0} (has_add.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_9180 (h0 : topological_space (linear_ordered_comm_ring num)) : totally_separated_space (linear_ordered_comm_ring num) := sorry --non-trivial
lemma new_lemma_9181 (h1 : topological_space (normed_group (random_gen (random_gen linarith.ineq)))) : path_connected_space (normed_group (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_9182 (h0 : list (linear_order (option (option empty)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_9183 (h0 : group (canonically_ordered_add_monoid empty)) : is_cyclic (canonically_ordered_add_monoid empty) := sorry --non-trivial
lemma new_lemma_9184 (h0 : has_mem.mem (with_one linarith.comp_source) has_emptyc.emptyc) : @complete_space.{0} (with_one.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type uniform_space.{0} (with_one.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_9185 (h0 : function.extfun (option pos) (fun (x : option pos), Prop)) : zzz_forall (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_9186 (h0 : topological_space (has_zero (boolean_algebra environment.implicit_infer_kind))) : totally_disconnected_space (has_zero (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_9187 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_neg_part.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg_part.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_9188 (h1 : add_group (random_gen (random_gen (random_gen string_imp)))) : is_add_cyclic (random_gen (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_9189 (h0 : function.extfun (Type 1) topological_space) : @discrete_topology.{1} (canonically_linear_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (canonically_linear_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_9190 (h0 : measurable_space (normed_field (normed_field linarith.ineq))) (h1 : filter (normed_field (normed_field linarith.ineq))) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_9191 (h0 : function.extfun Type group) : @normalizer_condition.{0} (normed_group.{0} (has_top.{0} num)) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_group.{0} (has_top.{0} num)))  := sorry --non-trivial
lemma new_lemma_9192 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (bin_tree.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} empty))  := sorry --non-trivial
lemma new_lemma_9193 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (bin_tree.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (bin_tree.{0} empty))  := sorry --non-trivial
lemma new_lemma_9194 (h1 : set (metric_space char -> enat)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_9195 (h0 : monoid (add_comm_monoid (finset environment.implicit_infer_kind))) : monoid.fg (add_comm_monoid (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_9196 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (linear_ordered_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_9197 (h0 : to_additive.value_type -> to_additive.value_type -> Prop) (h1 : list to_additive.value_type) : list.pairwise h0 h1 := sorry --non-trivial
lemma new_lemma_9198 (h0 : topological_space (finset (ring linarith.comp))) : preirreducible_space (finset (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_9199 (h0 : list (add_comm_monoid name)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_9200 (h0 : ring (comm_ring (random_gen linarith.ineq))) : is_domain (comm_ring (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_9201 (h0 : topological_space (ordered_comm_ring (sub_neg_monoid real))) : irreducible_space (ordered_comm_ring (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_9202 (h0 : topological_space (ordered_comm_monoid (has_neg (has_neg (has_neg (has_neg (has_neg name))))))) : totally_separated_space (ordered_comm_monoid (has_neg (has_neg (has_neg (has_neg (has_neg name)))))) := sorry --non-trivial
lemma new_lemma_9203 (h0 : topological_space (mul_zero_class (has_add pos))) : t1_space (mul_zero_class (has_add pos)) := sorry --non-trivial
lemma new_lemma_9204 (h0 : list (partial_order (semiring (semiring num)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_9205 (h0 : topological_space (has_nnnorm (random_gen (random_gen linarith.comp_source)))) : t0_space (has_nnnorm (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_9206 (h0 : uniform_space (has_union (semiring (semiring (semiring linarith.comp))))) : complete_space (has_union (semiring (semiring (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_9207 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_9208 (h1 : topological_space (has_norm string_imp)) : irreducible_space (has_norm string_imp) := sorry --non-trivial
lemma new_lemma_9209 (h0 : function.extfun Type topological_space) : @t0_space.{0} (@id.{2} Type linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type linarith.ineq))  := sorry --non-trivial
lemma new_lemma_9210 (h0 h1 : multiset (semi_normed_comm_ring enat)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_9211 (h0 : group (has_add enat)) : is_cyclic (has_add enat) := sorry --non-trivial
lemma new_lemma_9212 (h0 : ring (metric_space (has_norm (semiring congr_arg_kind)))) : rank_condition (metric_space (has_norm (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_9213 (h0 : topological_space (has_Inf (has_Inf pos))) : totally_separated_space (has_Inf (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_9214 (h0 : functor.comp topological_space add_cancel_monoid Type) : @totally_disconnected_space.{1} (add_cancel_monoid.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} add_cancel_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_9215 (h0 : group (has_nndist (option (option (option ennreal))))) : normalizer_condition (has_nndist (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_9216 (h0 : topological_space (simple_graph congr_arg_kind)) : discrete_topology (simple_graph congr_arg_kind) := sorry --non-trivial
lemma new_lemma_9217 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_9218 (h0 : complete_lattice (with_bot (has_top (random_gen (has_top (has_norm num)))))) : is_compactly_generated (with_bot (has_top (random_gen (has_top (has_norm num))))) := sorry --non-trivial
lemma new_lemma_9219 (h0 : complete_lattice (has_top (has_top linarith.comp_source))) : is_atomistic (has_top (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_9220 (h0 : ring (has_nndist (add_comm_monoid name))) : strong_rank_condition (has_nndist (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_9221 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} fun_info (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) fun_info)  := sorry --non-trivial
lemma new_lemma_9222 (h0 : functor.add_const (ring (has_to_string linarith.comp)) linarith.comp) : @strong_rank_condition.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_9223 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (complete_distrib_lattice.{0} pos) (@matrix.vec_empty.{0} (semiring.{0} (complete_distrib_lattice.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_9224 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (filter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (filter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_9225 (h1 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (mul_one_class.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (mul_one_class.{0} char))  := sorry --non-trivial
lemma new_lemma_9226 (h0 : functor.add_const (uniform_space (semigroup (option empty))) empty) : @separated_space.{0} (semigroup.{0} (option.{0} empty)) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} (option.{0} empty))) empty h0)  := sorry --non-trivial
lemma new_lemma_9227 (h0 : set (mul_one_class ereal -> ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_9228 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_9229 (h0 : functor.comp topological_space boolean_algebra.core name) : @t0_space.{0} (boolean_algebra.core.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} name h0)  := sorry --non-trivial
lemma new_lemma_9230 (h0 : topological_space (has_emptyc (random_gen linarith.comp_source))) : totally_disconnected_space (has_emptyc (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_9231 (h0 : uniform_space (generalized_boolean_algebra (ring (has_Inf linarith.comp)))) : separated_space (generalized_boolean_algebra (ring (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_9232 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (linear_ordered_comm_group ennreal)) := sorry --non-trivial
lemma new_lemma_9233 (h0 h1 : multiset (nondiscrete_normed_field environment.projection_info)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_9234 (h0 : function.extfun (Type 1) group) : @is_cyclic.{1} (plift.{1} (add_cancel_comm_monoid.{0} empty)) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (plift.{1} (add_cancel_comm_monoid.{0} empty)))  := sorry --non-trivial
lemma new_lemma_9235 (h1 : filter (with_one string_imp)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_9236 (h0 : functor.add_const (complete_lattice (has_to_string pos)) Type) : @is_compactly_generated.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_to_string.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_9237 (h1 : topological_space (denumerable (random_gen char))) : t0_space (denumerable (random_gen char)) := sorry --non-trivial
lemma new_lemma_9238 (h0 : group (has_add (mul_zero_class name))) : is_simple_group (has_add (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_9239 (h0 : list (ordered_ring empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_9240 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @monoid.fg.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) monoid.{0}) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_9241 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) Type) : @preirreducible_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_9242 (h0 : ordered_add_comm_monoid (has_neg pos)) : archimedean (has_neg pos) := sorry --non-trivial
lemma new_lemma_9243 (h0 : finset (semigroup congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_9244 (h0 : topological_space (has_append (has_compl linarith.ineq))) : t0_space (has_append (has_compl linarith.ineq)) := sorry --non-trivial
lemma new_lemma_9245 (h0 : topological_space (random_gen (with_bot to_additive.value_type))) : t0_space (random_gen (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_9246 (h0 : ring (metric_space (linear_ordered_semiring congr_arg_kind))) : strong_rank_condition (metric_space (linear_ordered_semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_9247 (h0 : topological_space (has_to_string (finset (has_add pos)))) : t0_space (has_to_string (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_9248 (h0 : functor.add_const (topological_space (has_neg_part ennreal)) (canonically_linear_ordered_monoid ennreal)) : @totally_separated_space.{0} (has_neg_part.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} ennreal)) (canonically_linear_ordered_monoid.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_9249 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_9250 (h0 : topological_space (has_Sup empty)) : t0_space (has_Sup empty) := sorry --non-trivial
lemma new_lemma_9251 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_9252 (h0 : ring (mul_zero_class (semiring unsigned))) : strong_rank_condition (mul_zero_class (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_9253 (h0 : not (topological_space (add_group linarith.comp) -> false)) : @normal_space.{0} (add_group.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_9254 (h0 : functor.add_const (topological_space (add_comm_monoid name)) linarith.comp) : @totally_disconnected_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_9255 (h0 : function.extfun (Type 1) (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (canonically_ordered_comm_semiring Type)) := sorry --non-trivial
lemma new_lemma_9256 (h0 : functor.add_const (topological_space (has_zero unsigned)) environment.implicit_infer_kind) : @regular_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_9257 (h0 : topological_space (div_inv_monoid linarith.ineq)) : path_connected_space (div_inv_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_9258 (h0 : complete_lattice (mul_one_class string_imp)) : complete_lattice.is_Sup_finite_compact (mul_one_class string_imp) := sorry --non-trivial
lemma new_lemma_9259 (h0 : topological_space (has_top (has_ssubset linarith.ineq))) : t0_space (has_top (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_9260 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_9261 (h0 : functor.add_const (topological_space (partial_order empty)) num) : @path_connected_space.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_9262 (h0 : cancel_comm_monoid_with_zero (complete_distrib_lattice num)) : unique_factorization_monoid (complete_distrib_lattice num) := sorry --non-trivial
lemma new_lemma_9263 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) Type) : @preconnected_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (boolean_algebra.core.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_9264 (h0 : function.extfun Type (functor.add_const (topological_space (has_pos_part linarith.comp)))) : @regular_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) name (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp))) h0 name))  := sorry --non-trivial
lemma new_lemma_9265 (h0 : not (complete_lattice (with_zero linarith.ineq) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_zero.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_zero.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_9266 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @is_principal_ideal_ring.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_9267 (h0 : topological_space (add_cancel_comm_monoid unsigned)) : path_connected_space (add_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_9268 (h2 : topological_space (semi_normed_ring to_additive.value_type)) : t0_space (semi_normed_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_9269 (h0 : monoid (has_top (has_top (has_top (semiring congr_arg_kind))))) : monoid.fg (has_top (has_top (has_top (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_9270 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) Type) : @sequential_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_9271 (h0 : set (mul_one_class std_gen -> mul_one_class string.iterator_imp)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_9272 (h0 : functor.const Prop linarith.ineq) : functor.const.run h0 := sorry --non-trivial
lemma new_lemma_9273 (h0 : functor.add_const (list (boolean_algebra.core Type)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_9274 (h0 : topological_space (normed_group (has_norm (has_norm (has_norm (has_norm fun_info)))))) : locally_compact_space (normed_group (has_norm (has_norm (has_norm (has_norm fun_info))))) := sorry --non-trivial
lemma new_lemma_9275 (h0 : ordered_add_comm_monoid (boolean_algebra (comm_group unsigned))) : archimedean (boolean_algebra (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_9276 (h0 : complete_lattice (semi_normed_ring (random_gen reducibility_hints))) : complete_lattice.is_Sup_finite_compact (semi_normed_ring (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_9277 (h0 : group (has_add (has_add (has_add linarith.comp)))) : group.fg (has_add (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_9278 (h0 : ring (add_right_cancel_monoid (semiring (semiring num)))) : strong_rank_condition (add_right_cancel_monoid (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_9279 (h0 : functor.add_const (add_group (has_add name)) Type) : @is_add_cyclic.{0} (has_add.{0} name) (@functor.add_const.run.{0 1} (add_group.{0} (has_add.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_9280 (h1 : ring (with_bot linarith.comp)) : is_domain (with_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_9281 (h0 : functor.add_const (filter (cancel_monoid environment.implicit_infer_kind)) (cancel_monoid Type)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_9282 (h0 : complete_lattice (canonically_ordered_monoid Type)) : is_atomistic (canonically_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_9283 (h0 : set (has_compl char)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_9284 (h0 : linarith.comp -> linarith.comp -> Prop) : well_founded h0 := sorry --non-trivial
lemma new_lemma_9285 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (non_assoc_semiring.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (non_assoc_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_9286 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup Type)) (ring Type)) : @archimedean.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (ordered_add_comm_monoid.{1} (semigroup.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_9287 (h0 : functor.add_const (topological_space (finset Type)) (finset (has_neg linarith.comp))) : @t0_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) (finset.{0} (has_neg.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_9288 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_9289 (h0 : ring (complete_semilattice_Sup (semiring (semiring (has_top unsigned))))) : strong_rank_condition (complete_semilattice_Sup (semiring (semiring (has_top unsigned)))) := sorry --non-trivial
lemma new_lemma_9290 (h0 : function.extfun (finset ((Type -> Type) -> Type 1)) (has_mem.mem (function.extfun Type))) : @monoid.fg.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@function.extfun_app.{3 0} (finset.{2} ((Type → Type) → Type 1)) (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (finset.{2} ((Type → Type) → Type 1)) (@finset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type)) h0 (@has_emptyc.emptyc.{2} (finset.{2} ((Type → Type) → Type 1)) (@finset.has_emptyc.{2} ((Type → Type) → Type 1))))) monoid.{0}) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_9291 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_9292 (h0 : monoid (mul_zero_class (semiring empty))) : monoid.fg (mul_zero_class (semiring empty)) := sorry --non-trivial
lemma new_lemma_9293 (h0 : not (topological_space (linear_ordered_semiring unsigned) -> false)) : @preirreducible_space.{0} (linear_ordered_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_9294 (h0 : function.extfun (Type 1) ring) : @strong_rank_condition.{1} Type (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 Type)  := sorry --non-trivial
lemma new_lemma_9295 (h0 : nnreal -> nnreal -> Prop) : is_strict_order nnreal h0 := sorry --non-trivial
lemma new_lemma_9296 (h0 : complete_lattice (is_R_or_C unsigned)) : is_atomistic (is_R_or_C unsigned) := sorry --non-trivial
lemma new_lemma_9297 (h0 : add_group (add_comm_monoid (has_neg linarith.comp))) : is_add_cyclic (add_comm_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_9298 (h0 : cancel_comm_monoid_with_zero (ordered_comm_ring (has_add (has_pos_part linarith.comp)))) : unique_factorization_monoid (ordered_comm_ring (has_add (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_9299 (h0 : complete_lattice (finset (has_Inf pos))) : is_atomistic (finset (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_9300 (h0 : function.extfun (multiset Type) (has_mem.mem (id linarith.comp_source))) : @monoid.fg.{0} (@id.{2} Type linarith.comp_source) (@multiset.pi.empty.{1 0} Type monoid.{0} (@id.{2} Type linarith.comp_source) (@function.extfun_app.{2 0} (multiset.{1} Type) (@has_mem.mem.{1 1} Type (multiset.{1} Type) (@multiset.has_mem.{1} Type) (@id.{2} Type linarith.comp_source)) h0 (@has_zero.zero.{1} (multiset.{1} Type) (@multiset.has_zero.{1} Type))))  := sorry --non-trivial
lemma new_lemma_9301 (h0 : functor.add_const (finset (semigroup linarith.comp)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_9302 (h0 : functor.add_const (topological_space (has_add linarith.comp)) environment.implicit_infer_kind) : @t0_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_9303 (h0 : ring (has_lt (mul_one_class linarith.ineq))) : strong_rank_condition (has_lt (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_9304 (h0 : function.extfun nat fin) : @loc_path_connected_space.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (normed_lattice_add_comm_group.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_9305 (h0 : topological_space (add_cancel_monoid name)) : totally_separated_space (add_cancel_monoid name) := sorry --non-trivial
lemma new_lemma_9306 (h0 : ring (semigroup (finset (ring linarith.comp)))) : rank_condition (semigroup (finset (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_9307 (h0 : topological_space (has_Sup (comm_monoid (option unsigned)))) : irreducible_space (has_Sup (comm_monoid (option unsigned))) := sorry --non-trivial
lemma new_lemma_9308 (h1 : function.extfun (finset Type) (has_mem.mem congr_arg_kind)) : @irreducible_space.{0} congr_arg_kind (@finset.pi.empty.{1 0} Type topological_space.{0} congr_arg_kind (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) congr_arg_kind) h1 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_9309 (h0 : char -> Prop) (h1 : filter char) : filter.eventually h0 h1 := sorry --non-trivial
lemma new_lemma_9310 (h0 : ring (linear_ordered_comm_group_with_zero reducibility_hints)) : rank_condition (linear_ordered_comm_group_with_zero reducibility_hints) := sorry --non-trivial
lemma new_lemma_9311 (h0 : functor.add_const (ordered_comm_monoid (has_add pos)) (option (option pos))) : @has_exists_mul_of_le.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_add.{0} pos)) (option.{0} (option.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_9312 (h0 : topological_space (with_one (has_inv linarith.ineq))) : locally_compact_space (with_one (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_9313 (h0 : filter (complete_distrib_lattice num)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_9314 (h0 : functor.add_const (uniform_space (cancel_monoid unsigned)) num) : @separated_space.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (cancel_monoid.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_9315 (h0 : not (ring (non_unital_non_assoc_semiring linarith.comp_source) -> false)) : @is_domain.{0} (non_unital_non_assoc_semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (non_unital_non_assoc_semiring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_9316 (h0 : ring (boolean_algebra.core (has_neg_part environment.implicit_infer_kind))) : is_principal_ideal_ring (boolean_algebra.core (has_neg_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_9317 (h0 : add_monoid (measurable_space.dynkin_system (semiring (semiring congr_arg_kind)))) : add_monoid.fg (measurable_space.dynkin_system (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_9318 (h0 : functor.add_const (ring znum) (option empty)) : @strong_rank_condition.{0} znum (@functor.add_const.run.{0 0} (ring.{0} znum) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_9319 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring Type)) name) : @is_domain.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (canonically_ordered_comm_semiring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_9320 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_9321 (h0 : topological_space (has_pos_part (ring (has_add (has_pos_part pos))))) : loc_path_connected_space (has_pos_part (ring (has_add (has_pos_part pos)))) := sorry --non-trivial
lemma new_lemma_9322 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_9323 (h0 : add_group (simple_graph (ring (has_add (boolean_algebra.core linarith.comp))))) : is_add_cyclic (simple_graph (ring (has_add (boolean_algebra.core linarith.comp)))) := sorry --non-trivial
lemma new_lemma_9324 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_9325 (h0 : topological_space (finset (normed_comm_ring pos))) : loc_path_connected_space (finset (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_9326 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (non_assoc_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_9327 (h0 : ordered_add_comm_monoid (canonically_ordered_monoid (has_neg (has_neg (has_neg name))))) : archimedean (canonically_ordered_monoid (has_neg (has_neg (has_neg name)))) := sorry --non-trivial
lemma new_lemma_9328 (h1 : topological_space (has_top fun_info)) : t0_space (has_top fun_info) := sorry --non-trivial
lemma new_lemma_9329 (h0 : not (has_mem.mem (has_emptyc (random_gen linarith.comp_source)) has_emptyc.emptyc -> false)) : @monoid.fg.{0} (has_emptyc.{0} (random_gen.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type monoid.{0} (has_emptyc.{0} (random_gen.{0} linarith.comp_source)) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} (random_gen.{0} linarith.comp_source)) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_9330 (h0 : group (ordered_comm_ring (finset linarith.comp))) : group.fg (ordered_comm_ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_9331 (h0 : monoid (add_cancel_monoid (boolean_algebra linarith.comp))) : monoid.fg (add_cancel_monoid (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_9332 (h0 : topological_space (add_cancel_monoid (has_add linarith.comp))) : totally_disconnected_space (add_cancel_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_9333 (h0 : topological_space (boolean_algebra.core (option (has_add (option (cancel_monoid pos)))))) : normal_space (boolean_algebra.core (option (has_add (option (cancel_monoid pos))))) := sorry --non-trivial
lemma new_lemma_9334 (h0 : topological_space (ring (has_to_string (finset (has_to_string Type))))) : t1_space (ring (has_to_string (finset (has_to_string Type)))) := sorry --non-trivial
lemma new_lemma_9335 (h0 : function.extfun Type monoid) (h1 : function.extfun Type topological_space) : @irreducible_space.{0} (@star_monoid.{0} num (@function.extfun_app.{2 1} Type monoid.{0} h0 num)) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (@star_monoid.{0} num (@function.extfun_app.{2 1} Type monoid.{0} h0 num)))  := sorry --non-trivial
lemma new_lemma_9336 (h0 : has_mem.mem group has_emptyc.emptyc) : @group.fg.{0} (has_emptyc.{0} (random_gen.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (has_emptyc.{0} (random_gen.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_9337 (h0 : random_gen fun_info -> Prop) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) (random_gen.{0} fun_info) h0  := sorry --non-trivial
lemma new_lemma_9338 (h0 : functor.add_const (group (preorder num)) empty) : @normalizer_condition.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (group.{0} (preorder.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_9339 (h0 : ring (random_gen (has_nnnorm (mul_one_class linarith.comp_source)))) : rank_condition (random_gen (has_nnnorm (mul_one_class linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_9340 (h0 : functor.add_const (add_monoid linarith.comp) Type) : @add_monoid.fg.{0} linarith.comp (@functor.add_const.run.{0 1} (add_monoid.{0} linarith.comp) Type h0)  := sorry --non-trivial
lemma new_lemma_9341 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_9342 (h5 : uniform_space (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup linarith.ineq)))) : complete_space (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup linarith.ineq))) := sorry --non-trivial
lemma new_lemma_9343 (h0 : topological_space (normed_comm_ring (option (option ennreal)))) : discrete_topology (normed_comm_ring (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_9344 (h0 : topological_space (has_ssubset (random_gen (random_gen char)))) : t0_space (has_ssubset (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_9345 (h0 : not (topological_space (random_gen linarith.ineq) -> false)) : @irreducible_space.{0} (random_gen.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_9346 (h0 : functor.add_const (functor.add_const (group linarith.comp) name) name) : @is_cyclic.{0} linarith.comp (@functor.add_const.run.{0 0} (group.{0} linarith.comp) name (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (group.{0} linarith.comp) name) name h0))  := sorry --non-trivial
lemma new_lemma_9347 (h0 : filter (add_group (has_norm (has_norm (semiring linarith.comp))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_9348 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (complete_linear_order empty)) := sorry --non-trivial
lemma new_lemma_9349 (h0 : list (complete_distrib_lattice ennreal)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_9350 (h0 : functor.add_const (topological_space (measure_theory.measure_space congr_arg_kind)) unsigned) : @totally_separated_space.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (measure_theory.measure_space.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_9351 (h0 : functor.add_const (topological_space (has_star empty)) (semiring congr_arg_kind)) : @totally_separated_space.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} empty)) (semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_9352 (h0 : topological_space (fintype (has_nnnorm to_additive.value_type))) : locally_compact_space (fintype (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_9353 (h0 : topological_space (has_compl (semi_normed_ring (has_compl (has_le (semi_normed_ring enat)))))) : t0_space (has_compl (semi_normed_ring (has_compl (has_le (semi_normed_ring enat))))) := sorry --non-trivial
lemma new_lemma_9354 (h0 : topological_space (boolean_algebra name)) : regular_space (boolean_algebra name) := sorry --non-trivial
lemma new_lemma_9355 (h0 : semiring (normed_comm_ring (option (mul_zero_class name)))) : is_noetherian_ring (normed_comm_ring (option (mul_zero_class name))) := sorry --non-trivial
lemma new_lemma_9356 (h1 : uniform_space (has_nnnorm (random_gen (random_gen string_imp)))) : complete_space (has_nnnorm (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_9357 (h0 : functor.add_const (functor.add_const (function.extfun Type complete_lattice) Type) (finset pos)) : @complete_lattice.is_Sup_finite_compact.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type complete_lattice.{0}) Type (@functor.add_const.run.{1 0} (functor.add_const.{1 1} (function.extfun.{2 1} Type complete_lattice.{0}) Type) (finset.{0} pos) h0)) (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_9358 (h0 : topological_space (pseudo_metric_space ennreal)) : preconnected_space (pseudo_metric_space ennreal) := sorry --non-trivial
lemma new_lemma_9359 (h0 : filter (semiring unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_9360 (h0 : uniform_space (complete_linear_order (semiring empty))) : complete_space (complete_linear_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_9361 (h0 : functor.add_const Prop (has_norm congr_arg_kind)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_9362 (h0 : monoid (distrib_lattice (has_inv (has_inv (has_inv linarith.comp_source))))) : monoid.fg (distrib_lattice (has_inv (has_inv (has_inv linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_9363 (h0 : group (ring (finset (ring pos)))) : group.fg (ring (finset (ring pos))) := sorry --non-trivial
lemma new_lemma_9364 (h0 : group (distrib (has_nnnorm (has_nnnorm char)))) : is_cyclic (distrib (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_9365 (h0 : add_group (comm_ring (mul_one_class reducibility_hints))) : is_add_cyclic (comm_ring (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_9366 (h1 : topological_space (has_lt linarith.comp_source)) : totally_disconnected_space (has_lt linarith.comp_source) := sorry --non-trivial
lemma new_lemma_9367 (h0 : functor.add_const (topological_space (has_neg unsigned)) name) : @t0_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_9368 (h0 : add_group (free_add_monoid congr_arg_kind)) : is_add_cyclic (free_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_9369 (h0 : topological_space (has_zero (has_neg (finset environment.implicit_infer_kind)))) : locally_compact_space (has_zero (has_neg (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_9370 (h0 : topological_space (ordered_comm_monoid (ring (ring Type)))) : locally_compact_space (ordered_comm_monoid (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_9371 (h0 : uniform_space (has_top fun_info)) : separated_space (has_top fun_info) := sorry --non-trivial
lemma new_lemma_9372 (h0 : add_monoid (simple_graph (boolean_algebra.core (has_Inf linarith.comp)))) : add_monoid.fg (simple_graph (boolean_algebra.core (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_9373 (h0 : not (uniform_space (complete_linear_order num) -> false)) : @complete_space.{0} (complete_linear_order.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (complete_linear_order.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_9374 (h0 : topological_space (has_neg (has_neg (has_Inf Type)))) : topological_space.separable_space (has_neg (has_neg (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_9375 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @topological_space.separable_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_9376 (h0 : topological_space (simple_graph name)) : sequential_space (simple_graph name) := sorry --non-trivial
lemma new_lemma_9377 (h0 : function.extfun (finset Type) (has_mem.mem (complete_distrib_lattice num))) : @totally_separated_space.{0} (complete_distrib_lattice.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_distrib_lattice.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_distrib_lattice.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_9378 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_9379 (h0 : ring (left_cancel_semigroup (semiring (semiring unsigned)))) : strong_rank_condition (left_cancel_semigroup (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_9380 (h0 : ring (omega_complete_partial_order ereal)) : invariant_basis_number (omega_complete_partial_order ereal) := sorry --non-trivial
lemma new_lemma_9381 (h0 : topological_space (has_add (ring Type))) : preirreducible_space (has_add (ring Type)) := sorry --non-trivial
lemma new_lemma_9382 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (metric_space.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} h0 (metric_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_9383 (h0 : semiring (add_comm_semigroup enat)) (h1 : add_comm_semigroup enat) : even h1 := sorry --non-trivial
lemma new_lemma_9384 (h0 : complete_lattice (simple_graph (has_pos_part (finset linarith.comp)))) : is_compactly_generated (simple_graph (has_pos_part (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_9385 (h0 : function.extfun Type topological_space) : @t0_space.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_9386 (h0 : add_group (dlist (random_gen (random_gen string_imp)))) : is_add_cyclic (dlist (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_9387 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_9388 (h0 : list (monoid_with_zero ennreal)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_9389 (h0 : group (complete_distrib_lattice (has_to_string congr_arg_kind))) : is_simple_group (complete_distrib_lattice (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_9390 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_9391 (h0 : add_group (has_emptyc empty)) : is_add_cyclic (has_emptyc empty) := sorry --non-trivial
lemma new_lemma_9392 (h0 : topological_space (semi_normed_comm_ring (random_gen string_imp))) : locally_compact_space (semi_normed_comm_ring (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_9393 (h0 : function.extfun Type (functor.comp topological_space has_neg)) : @t0_space.{0} (has_neg.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_neg.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_9394 (h0 : topological_space (add_comm_monoid (has_pos_part real))) : irreducible_space (add_comm_monoid (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_9395 (h0 : ring (ordered_cancel_add_comm_monoid congr_arg_kind)) : is_domain (ordered_cancel_add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_9396 (h1 : group (add_cancel_comm_monoid (metric_space (metric_space char)))) : is_cyclic (add_cancel_comm_monoid (metric_space (metric_space char))) := sorry --non-trivial
lemma new_lemma_9397 (h0 : functor.add_const (topological_space (semiring empty)) empty) : @topological_space.separable_space.{0} (semiring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_9398 (h0 : complete_lattice (topological_space (has_nnnorm char))) : is_compactly_generated (topological_space (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_9399 (h0 : fin has_zero.zero) : @complete_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) uniform_space.{1}) h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_9400 (h0 : functor.add_const (topological_space (sub_neg_monoid linarith.comp)) Type) : @t0_space.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_9401 (h0 : functor.add_const (semiring (ring environment.implicit_infer_kind)) linarith.comp) : @is_noetherian_ring.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (semiring.{0} (ring.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_9402 (h1 : ring (random_gen (has_nnnorm (normed_field char)))) : strong_rank_condition (random_gen (has_nnnorm (normed_field char))) := sorry --non-trivial
lemma new_lemma_9403 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_add_monoid (option (option empty)))) : unique_factorization_monoid (canonically_ordered_add_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_9404 (h0 : functor.add_const (filter (normed_comm_ring linarith.comp)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_9405 (h0 : function.extfun Type topological_space) : @t1_space.{0} (linear_ordered_field.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_9406 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) (has_neg (has_Inf Type))) : @irreducible_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) (has_neg.{1} (has_Inf.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_9407 (h0 : add_monoid (has_one (has_top empty))) : add_monoid.fg (has_one (has_top empty)) := sorry --non-trivial
lemma new_lemma_9408 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (linear_ordered_field.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_9409 (h0 : ring (ordered_comm_ring (sub_neg_monoid pos))) : rank_condition (ordered_comm_ring (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_9410 (h0 : semiring (ordered_comm_monoid real)) : is_noetherian_ring (ordered_comm_monoid real) := sorry --non-trivial
lemma new_lemma_9411 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_inner.{0 0} (option.{0} empty) congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inner.{0 0} (option.{0} empty) congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_9412 (h4 : not (uniform_space (uniform_space to_additive.value_type) -> false)) : @complete_space.{0} (uniform_space.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (uniform_space.{0} (uniform_space.{0} to_additive.value_type)) h4)  := sorry --non-trivial
lemma new_lemma_9413 (h0 : functor.add_const (complete_lattice (as_linear_order unsigned)) congr_arg_kind) : @is_atomistic.{0} (as_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (as_linear_order.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_9414 (h0 : list (has_to_string (has_add Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_9415 (h0 : topological_space ennreal) : discrete_topology ennreal := sorry --non-trivial
lemma new_lemma_9416 (h1 : topological_space (nondiscrete_normed_field (add_comm_semigroup linarith.ineq))) (h2 : add_group (nondiscrete_normed_field (add_comm_semigroup linarith.ineq))) : topological_add_group (nondiscrete_normed_field (add_comm_semigroup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_9417 (h0 : functor.add_const (filter (ring Type)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_9418 (h0 : group (normed_lattice_add_comm_group (has_pos_part Type))) : is_simple_group (normed_lattice_add_comm_group (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_9419 (h0 : topological_space (has_ssubset int)) : locally_compact_space (has_ssubset int) := sorry --non-trivial
lemma new_lemma_9420 (h0 : topological_space (distrib (comm_ring reducibility_hints))) : totally_disconnected_space (distrib (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_9421 (h0 : cancel_comm_monoid_with_zero (nondiscrete_normed_field (nondiscrete_normed_field fun_info))) (h1 : has_lt (gcd_monoid (nondiscrete_normed_field (nondiscrete_normed_field fun_info)))) : no_max_order (gcd_monoid (nondiscrete_normed_field (nondiscrete_normed_field fun_info))) := sorry --non-trivial
lemma new_lemma_9422 (h0 : functor.add_const (finset (boolean_algebra.core unsigned)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_9423 (h0 : list (linear_ordered_add_comm_group (comm_ring to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_9424 (h0 : functor.add_const (function.extfun (Type 1) semiring) pos) : @is_noetherian_ring.{1} Type (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) semiring.{1}) pos h0) Type)  := sorry --non-trivial
lemma new_lemma_9425 (h0 : topological_space (has_Inf (ring (has_Inf Type)))) : locally_compact_space (has_Inf (ring (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_9426 (h0 : add_monoid (has_norm (has_norm fun_info))) : add_monoid.fg (has_norm (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_9427 (h0 : topological_space (with_bot (semiring (semiring empty)))) : locally_compact_space (with_bot (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_9428 (h0 : function.extfun Type topological_space) : @normal_space.{0} (linear_ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_9429 (h0 : complete_lattice nnreal -> Prop) (h1 : Exists (fun (x : complete_lattice nnreal), h0 x)) : @complete_lattice.is_Sup_finite_compact.{0} nnreal (@classical.some.{1} (complete_lattice.{0} nnreal) h0 h1)  := sorry --non-trivial
lemma new_lemma_9430 (h0 : functor.add_const (topological_space (has_to_string unsigned)) pos) : @preconnected_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_9431 (h0 : topological_space (has_neg_part (has_to_string ennreal))) : path_connected_space (has_neg_part (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_9432 (h0 : topological_space (comm_group (ring pos))) : t0_space (comm_group (ring pos)) := sorry --non-trivial
lemma new_lemma_9433 (h0 : list (has_inv (has_top (dlist (random_gen fun_info))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_9434 (h0 : topological_space (finset (finset (finset Type)))) : discrete_topology (finset (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_9435 (h3 : ring (has_compl (has_nnnorm (has_nnnorm (random_gen (has_nnnorm to_additive.value_type)))))) : is_domain (has_compl (has_nnnorm (has_nnnorm (random_gen (has_nnnorm to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_9436 (h0 : monoid (add_cancel_monoid (option unsigned))) : monoid.fg (add_cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_9437 (h0 : complete_lattice (has_zero ennreal)) : is_atomistic (has_zero ennreal) := sorry --non-trivial
lemma new_lemma_9438 (h0 : uniform_space (comm_monoid (option empty))) : separated_space (comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_9439 (h0 : function.extfun Type (functor.add_const (topological_space (add_left_cancel_semigroup empty)))) : @t0_space.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_9440 (h0 : complete_lattice (boolean_algebra.core (comm_monoid (comm_monoid unsigned)))) : is_atomistic (boolean_algebra.core (comm_monoid (comm_monoid unsigned))) := sorry --non-trivial
lemma new_lemma_9441 (h0 : uniform_space (has_zero ennreal)) : separated_space (has_zero ennreal) := sorry --non-trivial
lemma new_lemma_9442 (h0 : topological_space (has_inv linarith.comp_source)) : totally_separated_space (has_inv linarith.comp_source) := sorry --non-trivial
lemma new_lemma_9443 (h0 : uniform_space (mul_zero_class unsigned)) : separated_space (mul_zero_class unsigned) := sorry --non-trivial
lemma new_lemma_9444 (h0 : ordered_add_comm_monoid (finset (has_neg linarith.comp))) : archimedean (finset (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_9445 (h0 : has_le (has_compl string_imp)) (h1 : ring (has_nnnorm (bounded_order (has_compl string_imp)))) : is_domain (has_nnnorm (bounded_order (has_compl string_imp))) := sorry --non-trivial
lemma new_lemma_9446 (h0 : functor.add_const (function.extfun Type semiring) (has_add (has_add linarith.comp))) : @is_noetherian_ring.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) (has_add.{0} (has_add.{0} linarith.comp)) h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_9447 (h0 : functor.add_const (list (complete_distrib_lattice empty)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_9448 (h0 : not (uniform_space (normed_field char) -> false)) : @separated_space.{0} (normed_field.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (normed_field.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_9449 (h0 : topological_space (add_comm_monoid (has_pos_part real))) : totally_disconnected_space (add_comm_monoid (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_9450 (h0 : group (linear_ordered_field num)) : group.fg (linear_ordered_field num) := sorry --non-trivial
lemma new_lemma_9451 (h0 : ring (monoid_with_zero (option unsigned))) : is_principal_ideal_ring (monoid_with_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_9452 (h0 : list (linear_order empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_9453 (h0 : complete_lattice (linear_ordered_semiring (has_top to_additive.value_type))) : is_compactly_generated (linear_ordered_semiring (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_9454 (h0 : topological_space (denumerable (has_ssubset string_imp))) : path_connected_space (denumerable (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_9455 (h0 : topological_space (add_group (semiring (semiring (semiring unsigned))))) : normal_space (add_group (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_9456 (h0 : filter (add_comm_monoid (option pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_9457 (h0 : functor.add_const (ring (has_add Type)) (has_to_string Type)) : @is_domain.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (has_add.{1} Type)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_9458 (h0 : functor.add_const (function.extfun Type ring) Type) : @strong_rank_condition.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_9459 (h0 : complete_lattice (normed_group (with_bot congr_arg_kind))) : is_atomistic (normed_group (with_bot congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_9460 (h0 : topological_space (with_bot (has_norm (has_norm empty)))) : t0_space (with_bot (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_9461 (h0 : functor.add_const (topological_space (has_to_string unsigned)) Type) : @locally_compact_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_9462 (h0 : not (complete_lattice (with_one linarith.ineq) -> false)) : @is_atomistic.{0} (with_one.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_one.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_9463 (h0 : function.extfun (Type 1) topological_space) : @topological_space.separable_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_9464 (h0 : topological_space (has_compl (random_gen (comm_ring (has_nnnorm (has_nnnorm linarith.ineq)))))) : path_connected_space (has_compl (random_gen (comm_ring (has_nnnorm (has_nnnorm linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_9465 (h0 : functor.add_const (complete_lattice (has_neg ennreal)) (option num)) : @is_atomistic.{0} (has_neg.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} ennreal)) (option.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_9466 (h0 : uniform_space (ordered_comm_monoid (finset pos))) : complete_space (ordered_comm_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_9467 (h0 : topological_space (canonically_ordered_monoid (has_add linarith.comp))) : locally_compact_space (canonically_ordered_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_9468 (h0 : topological_space (with_bot (semiring linarith.ineq))) : irreducible_space (with_bot (semiring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_9469 (h0 : monoid (has_to_string (finset (finset environment.implicit_infer_kind)))) : monoid.fg (has_to_string (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_9470 (h0 : topological_space (add_cancel_monoid (has_add (has_add pos)))) : preconnected_space (add_cancel_monoid (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_9471 (h0 : ring (has_neg_part (comm_group environment.implicit_infer_kind))) : is_principal_ideal_ring (has_neg_part (comm_group environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_9472 (h0 : complete_lattice (normed_comm_ring num)) : complete_lattice.is_Sup_finite_compact (normed_comm_ring num) := sorry --non-trivial
lemma new_lemma_9473 (h0 : ring (with_bot (has_top (has_top fun_info)))) : is_domain (with_bot (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_9474 (h0 : group (semigroup (finset (finset pos)))) : is_simple_group (semigroup (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_9475 (h0 : functor.add_const (filter (linear_ordered_field empty)) (option unsigned)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_9476 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_9477 (h0 : add_group (simple_graph environment.projection_info)) : is_add_cyclic (simple_graph environment.projection_info) := sorry --non-trivial
lemma new_lemma_9478 (h0 : function.extfun (Type 1) (functor.add_const (complete_lattice (semigroup name)))) : @is_compactly_generated.{0} (semigroup.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (semigroup.{0} name)) (has_nndist.{1} Type) (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (complete_lattice.{0} (semigroup.{0} name))) h0 (has_nndist.{1} Type)))  := sorry --non-trivial
lemma new_lemma_9479 (h0 : ordered_add_comm_monoid (has_zero (finset pos))) : archimedean (has_zero (finset pos)) := sorry --non-trivial
lemma new_lemma_9480 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (add_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_9481 (h0 : functor.add_const (topological_space (has_nndist pos)) (boolean_algebra linarith.comp)) : @preconnected_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) (boolean_algebra.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_9482 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (semigroup pos)) := sorry --non-trivial
lemma new_lemma_9483 (h0 : topological_space (left_cancel_monoid unsigned)) : discrete_topology (left_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_9484 (h0 : complete_lattice (has_bot (has_Inf Type))) : is_atomistic (has_bot (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_9485 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (ordered_comm_group empty)) := sorry --non-trivial
lemma new_lemma_9486 (h0 : function.extfun Type group) : @normalizer_condition.{0} (monoid_with_zero.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (monoid_with_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_9487 (h0 : add_monoid linarith.comp_source) (h1 : linarith.comp_source) : is_add_unit h1 := sorry --non-trivial
lemma new_lemma_9488 (h0 : functor.add_const (topological_space (left_cancel_monoid unsigned)) unsigned) : @totally_disconnected_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_9489 (h0 : functor.add_const (ring (left_cancel_semigroup unsigned)) congr_arg_kind) : @is_domain.{0} (left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_semigroup.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_9490 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_star num)) := sorry --non-trivial
lemma new_lemma_9491 (h0 : finset (linear_ordered_field unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_9492 (h0 : has_mem.mem (has_one empty) has_emptyc.emptyc) : @normal_space.{0} (has_one.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_9493 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_9494 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @is_domain.{0} (has_mul.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_mul.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_9495 (h0 : fin has_zero.zero) : @regular_space.{0} (has_add.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_9496 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (linear_ordered_field.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type semiring.{0} h0 (linear_ordered_field.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_9497 (h0 : topological_space (has_pos_part (finset pos))) : normal_space (has_pos_part (finset pos)) := sorry --non-trivial
lemma new_lemma_9498 (h0 : function.extfun (Type 1) group) : @is_cyclic.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_9499 (h0 : topological_space (semigroup (comm_group Type))) : irreducible_space (semigroup (comm_group Type)) := sorry --non-trivial
lemma new_lemma_9500 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (add_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_9501 (h0 : fin has_zero.zero) : @complete_space.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_9502 (h0 : topological_space (linear_ordered_comm_ring empty)) : totally_disconnected_space (linear_ordered_comm_ring empty) := sorry --non-trivial
lemma new_lemma_9503 (h0 : complete_lattice (distrib (metric_space char))) : is_compactly_generated (distrib (metric_space char)) := sorry --non-trivial
lemma new_lemma_9504 (h0 : function.extfun (Type 1) topological_space) : @preirreducible_space.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_9505 (h0 : list (add_cancel_comm_monoid empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_9506 (h0 : ring (has_lt (mul_one_class (has_ssubset reducibility_hints)))) : rank_condition (has_lt (mul_one_class (has_ssubset reducibility_hints))) := sorry --non-trivial
lemma new_lemma_9507 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @monoid.fg.{1} (canonically_linear_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 monoid.{1}) (canonically_linear_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_9508 (h0 : functor.add_const (topological_space (free_add_monoid empty)) num) : @t0_space.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_9509 (h0 : functor.add_const (semiring (complete_distrib_lattice real)) real) : @is_noetherian_ring.{0} (complete_distrib_lattice.{0} real) (@functor.add_const.run.{0 0} (semiring.{0} (complete_distrib_lattice.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_9510 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) pos) : @irreducible_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_9511 (h0 : ring (measure_theory.measure_space (semiring (semiring unsigned)))) : rank_condition (measure_theory.measure_space (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_9512 (h0 : finset (normed_comm_ring (ring (normed_comm_ring linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_9513 (h0 : filter (plift (option unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_9514 (h2 : Prop) : set.separates_points (id (fun (h1 : std_gen -> fun_info), h2)) := sorry --non-trivial
lemma new_lemma_9515 (h0 : functor.add_const (functor.add_const (topological_space Type) pos) (has_add (has_zero linarith.comp))) : @sequential_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) pos (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (topological_space.{1} Type) pos) (has_add.{0} (has_zero.{0} linarith.comp)) h0))  := sorry --non-trivial
lemma new_lemma_9516 (h0 : uniform_space (semi_normed_comm_ring (mul_one_class char))) : complete_space (semi_normed_comm_ring (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_9517 (h0 : functor.add_const (add_group (simple_graph linarith.comp)) Type) : @is_add_cyclic.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_group.{0} (simple_graph.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_9518 (h0 : add_group (pseudo_metric_space empty)) : is_add_cyclic (pseudo_metric_space empty) := sorry --non-trivial
lemma new_lemma_9519 (h0 : functor.add_const (ring (semigroup congr_arg_kind)) num) : @rank_condition.{0} (semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_9520 (h0 : has_coe (add_comm_semigroup (add_comm_semigroup fun_info)) Prop) (h1 : add_comm_semigroup (add_comm_semigroup fun_info)) : @coe_b.{1 1} (add_comm_semigroup.{0} (add_comm_semigroup.{0} fun_info)) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_9521 (h0 : topological_space (linear_ordered_field empty)) : normal_space (linear_ordered_field empty) := sorry --non-trivial
lemma new_lemma_9522 (h0 : functor.add_const (group (simple_graph linarith.comp)) linarith.comp) : @normalizer_condition.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (simple_graph.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_9523 (h0 : uniform_space (add_comm_monoid reducibility_hints)) : complete_space (add_comm_monoid reducibility_hints) := sorry --non-trivial
lemma new_lemma_9524 (h1 : group (measurable_space (random_gen string_imp))) : is_cyclic (measurable_space (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_9525 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @locally_compact_space.{0} (canonically_linear_ordered_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (canonically_linear_ordered_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_9526 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (dlist.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (dlist.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_9527 (h1 : complete_lattice (has_compl to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (has_compl to_additive.value_type) := sorry --non-trivial
lemma new_lemma_9528 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_9529 (h0 : functor.add_const (topological_space (finset name)) linarith.comp) : @irreducible_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_9530 (h0 : list (cancel_monoid (option num))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_9531 (h1 : Prop) : set.finite (id (fun (h0 : ereal), h1)) := sorry --non-trivial
lemma new_lemma_9532 (h0 : group (complete_semilattice_Sup (has_ssubset fun_info))) : group.fg (complete_semilattice_Sup (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_9533 (h0 : functor.comp list comm_group name) : list.nodup (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_9534 (h0 : fin has_zero.zero) : @add_monoid.fg.{0} (has_add.{0} linarith.comp) (@matrix.vec_empty.{0} (add_monoid.{0} (has_add.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_9535 (h0 : functor.add_const (group (has_add Type)) (ring pos)) : @normalizer_condition.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_add.{1} Type)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_9536 (h0 : topological_space (has_neg (has_neg pos))) : irreducible_space (has_neg (has_neg pos)) := sorry --non-trivial
lemma new_lemma_9537 (h0 : topological_space (has_top unsigned)) : normal_space (has_top unsigned) := sorry --non-trivial
lemma new_lemma_9538 (h0 : add_group (mul_zero_class (semiring unsigned))) : is_add_cyclic (mul_zero_class (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_9539 (h0 : function.extfun (Type 1) topological_space) : @discrete_topology.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_9540 (h0 : not (topological_space (has_one empty) -> false)) : @topological_space.separable_space.{0} (has_one.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_one.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_9541 (h1 : group (fintype to_additive.value_type)) : is_cyclic (fintype to_additive.value_type) := sorry --non-trivial
lemma new_lemma_9542 (h0 : ordered_add_comm_monoid (canonically_linear_ordered_monoid (has_bot pos))) : archimedean (canonically_linear_ordered_monoid (has_bot pos)) := sorry --non-trivial
lemma new_lemma_9543 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_9544 (h0 : complete_lattice (has_inv (has_inv to_additive.value_type))) : is_atomistic (has_inv (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_9545 (h0 : topological_space (has_add (ring (has_neg linarith.comp)))) : irreducible_space (has_add (ring (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_9546 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (dlist.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (dlist.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_9547 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} fun_info (@function.extfun_app.{2 1} Type topological_space.{0} h0 fun_info)  := sorry --non-trivial
lemma new_lemma_9548 (h0 : group (has_ssubset (denumerable to_additive.value_type))) : is_cyclic (has_ssubset (denumerable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_9549 (h1 : ring (div_inv_monoid string_imp)) : strong_rank_condition (div_inv_monoid string_imp) := sorry --non-trivial
lemma new_lemma_9550 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (random_gen.{0} string_imp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (random_gen.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_9551 (h0 : topological_space (ordered_comm_monoid (has_neg (has_neg (has_neg name))))) : normal_space (ordered_comm_monoid (has_neg (has_neg (has_neg name)))) := sorry --non-trivial
lemma new_lemma_9552 (h0 : not (prod (has_top unsigned) (has_top unsigned) -> false)) : id_rel (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_9553 (h0 : ring (add_semigroup num)) : is_principal_ideal_ring (add_semigroup num) := sorry --non-trivial
lemma new_lemma_9554 (h0 : functor.add_const (uniform_space (canonically_ordered_comm_semiring empty)) unsigned) : @complete_space.{0} (canonically_ordered_comm_semiring.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (canonically_ordered_comm_semiring.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_9555 (h1 : set (multiplicative to_additive.value_type)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_9556 (h0 : topological_space (has_star (semiring (semiring num)))) : locally_compact_space (has_star (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_9557 (h0 : ring (normed_group (has_top (has_top (has_top congr_arg_kind))))) : is_domain (normed_group (has_top (has_top (has_top congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_9558 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_9559 (h0 : functor.add_const (topological_space (semigroup congr_arg_kind)) unsigned) : @irreducible_space.{0} (semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_9560 (h0 : add_monoid (id (semiring (semiring linarith.comp)))) : add_monoid.fg (id (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_9561 (h0 : complete_lattice (topological_space (has_ssubset string_imp))) : is_compactly_generated (topological_space (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_9562 (h0 : topological_space (mul_zero_class (semiring (semiring num)))) : preirreducible_space (mul_zero_class (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_9563 (h0 : functor.add_const (list (has_Sup unsigned)) num) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_9564 (h0 : monoid (measurable_space (has_inv (random_gen (random_gen fun_info))))) : monoid.fg (measurable_space (has_inv (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_9565 (h0 : topological_space (has_pos_part (canonically_linear_ordered_monoid (has_Inf real)))) : t0_space (has_pos_part (canonically_linear_ordered_monoid (has_Inf real))) := sorry --non-trivial
lemma new_lemma_9566 (h0 : functor.add_const (ordered_add_comm_monoid (has_neg pos)) linarith.comp) : @archimedean.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_neg.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_9567 (h0 : topological_space (has_add (has_to_string Type))) : topological_space.separable_space (has_add (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_9568 (h0 : not (group (complete_linear_order unsigned) -> false)) : @is_cyclic.{0} (complete_linear_order.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (complete_linear_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_9569 (h0 : ring (has_Inf (has_Inf pos))) : strong_rank_condition (has_Inf (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_9570 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_disconnected_space.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_9571 (h0 : filter (normed_comm_ring (option (option pos)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_9572 (h0 : not (complete_lattice (div_inv_monoid char) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (div_inv_monoid.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (div_inv_monoid.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_9573 (h0 : topological_space (has_norm fun_info)) : path_connected_space (has_norm fun_info) := sorry --non-trivial
lemma new_lemma_9574 (h1 : set (nondiscrete_normed_field reducibility_hints)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_9575 (h0 : set (semi_normed_comm_ring (mul_one_class string.iterator_imp))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_9576 (h0 : topological_space (cancel_monoid (add_comm_monoid (has_neg_part pos)))) : regular_space (cancel_monoid (add_comm_monoid (has_neg_part pos))) := sorry --non-trivial
lemma new_lemma_9577 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (canonically_ordered_monoid.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_9578 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_9579 (h0 : topological_space (add_comm_monoid (option unsigned))) : irreducible_space (add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_9580 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_9581 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_9582 (h0 : functor.add_const (group (add_comm_monoid linarith.comp)) linarith.comp) : @normalizer_condition.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_9583 (h0 : semiring (plift (semiring unsigned))) : is_noetherian_ring (plift (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_9584 (h0 : topological_space (dlist linarith.comp_source)) : locally_compact_space (dlist linarith.comp_source) := sorry --non-trivial
lemma new_lemma_9585 (h0 : function.extfun Type group) : @group.fg.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_9586 (h0 : functor.add_const (list (has_to_string linarith.comp)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_9587 (h0 : topological_space (group_with_zero ennreal)) : preconnected_space (group_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_9588 (h0 : topological_space (has_ssubset (has_nnnorm (random_gen to_additive.value_type)))) : t0_space (has_ssubset (has_nnnorm (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_9589 (h0 : functor.add_const (ring (has_zero environment.implicit_infer_kind)) linarith.comp) : @rank_condition.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_9590 (h0 : filter (has_to_string (option ennreal))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_9591 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_9592 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @discrete_topology.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_9593 (h0 : has_mem.mem (linear_ordered_semiring to_additive.value_type) has_emptyc.emptyc) : @path_connected_space.{0} (linear_ordered_semiring.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_9594 (h1 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @normalizer_condition.{0} fun_info (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h1 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) fun_info)  := sorry --non-trivial
lemma new_lemma_9595 (h0 : topological_space (is_R_or_C congr_arg_kind)) : t1_space (is_R_or_C congr_arg_kind) := sorry --non-trivial
lemma new_lemma_9596 (h0 : complete_lattice (distrib ennreal)) : complete_lattice.is_Sup_finite_compact (distrib ennreal) := sorry --non-trivial
lemma new_lemma_9597 (h0 : list (add_right_cancel_monoid (semiring empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_9598 (h0 : ring (semigroup (option name))) : is_principal_ideal_ring (semigroup (option name)) := sorry --non-trivial
lemma new_lemma_9599 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_9600 (h0 : finset (complete_distrib_lattice (has_Inf (ring name)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_9601 (h0 : topological_space (ring (has_Inf linarith.comp))) : preconnected_space (ring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_9602 (h0 : add_group (has_Sup num)) : is_add_cyclic (has_Sup num) := sorry --non-trivial
lemma new_lemma_9603 (h0 : topological_space (non_unital_non_assoc_semiring (mul_one_class reducibility_hints))) (h1 : preorder (non_unital_non_assoc_semiring (mul_one_class reducibility_hints))) : order_topology (non_unital_non_assoc_semiring (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_9604 (h0 : functor.add_const (ring (finset pos)) linarith.comp) : @is_domain.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_9605 (h0 : complete_lattice (semi_normed_ring (mul_one_class linarith.ineq))) : complete_lattice.is_Sup_finite_compact (semi_normed_ring (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_9606 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @group.fg.{0} (has_ssubset.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (has_ssubset.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_9607 (h0 : functor.add_const (topological_space (has_Inf pos)) Type) : @discrete_topology.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_9608 (h0 : fin has_zero.zero) : matrix.vec_empty (matrix.vec_empty (matrix.vec_empty (id (id (id h0))))) := sorry --non-trivial
lemma new_lemma_9609 (h0 : set (mul_one_class linarith.ineq -> linarith.ineq)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_9610 (h0 : function.extfun Type (functor.add_const (topological_space (linear_ordered_comm_monoid_with_zero unsigned)))) : @topological_space.separable_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned))) h0 num))  := sorry --non-trivial
lemma new_lemma_9611 (h0 : function.extfun Type group) : @is_simple_group.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_9612 (h0 : topological_space (has_Sup (semiring (semiring empty)))) : totally_separated_space (has_Sup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_9613 (h0 : functor.add_const (finset (has_neg Type)) (finset pos)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_9614 (h0 : uniform_space environment.implicit_infer_kind) : separated_space environment.implicit_infer_kind := sorry --non-trivial
lemma new_lemma_9615 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @has_exists_mul_of_le.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (ordered_comm_monoid.{1} (has_bot.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_9616 (h0 : group (normed_lattice_add_comm_group (ring (finset linarith.comp)))) : group.fg (normed_lattice_add_comm_group (ring (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_9617 (h0 : group (simple_graph (has_add pos))) : group.fg (simple_graph (has_add pos)) := sorry --non-trivial
lemma new_lemma_9618 (h0 : set (normed_field linarith.comp_source)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_9619 (h0 : function.extfun Type ring) : @is_domain.{0} (measurable_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h0 (measurable_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_9620 (h0 : topological_space (has_neg (add_comm_monoid (ring Type)))) : sequential_space (has_neg (add_comm_monoid (ring Type))) := sorry --non-trivial
lemma new_lemma_9621 (h0 : add_monoid (has_add (has_Inf pos))) : add_monoid.fg (has_add (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_9622 (h0 : uniform_space (has_to_string (normed_comm_ring (normed_comm_ring Type)))) : complete_space (has_to_string (normed_comm_ring (normed_comm_ring Type))) := sorry --non-trivial
lemma new_lemma_9623 (h0 : filter (comm_monoid num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_9624 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_9625 (h0 : topological_space (complete_semilattice_Sup (semiring (semiring congr_arg_kind)))) : discrete_topology (complete_semilattice_Sup (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_9626 (h0 : has_mem.mem (has_one linarith.comp) has_emptyc.emptyc) : @irreducible_space.{0} (has_one.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_9627 (h0 : functor.add_const (list (semigroup environment.implicit_infer_kind)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_9628 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) pos) : @preconnected_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_9629 (h0 : monoid (pseudo_metric_space (option (option ennreal)))) : monoid.fg (pseudo_metric_space (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_9630 (h0 : monoid (has_union (random_gen empty))) : monoid.fg (has_union (random_gen empty)) := sorry --non-trivial
lemma new_lemma_9631 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_9632 (h0 : complete_lattice (has_compl (mul_one_class (mul_one_class linarith.comp_source)))) : is_compactly_generated (has_compl (mul_one_class (mul_one_class linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_9633 (h0 : complete_lattice (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source)))) : is_compactly_generated (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_9634 (h0 : functor.add_const (ring (has_nndist name)) linarith.comp) : @is_domain.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_9635 (h0 : list (pseudo_metric_space unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_9636 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_9637 (h0 : group (has_top (random_gen char))) : group.fg (has_top (random_gen char)) := sorry --non-trivial
lemma new_lemma_9638 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (option.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (option.{0} num))  := sorry --non-trivial
lemma new_lemma_9639 (h0 : topological_space (has_add (has_nndist Type))) : t0_space (has_add (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_9640 (h0 : topological_space (ordered_comm_ring (has_add name))) : preirreducible_space (ordered_comm_ring (has_add name)) := sorry --non-trivial
lemma new_lemma_9641 (h0 : function.extfun Type group) : @normalizer_condition.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_9642 (h0 : cancel_comm_monoid_with_zero (pseudo_metric_space (option name))) : unique_factorization_monoid (pseudo_metric_space (option name)) := sorry --non-trivial
lemma new_lemma_9643 (h0 : functor.add_const (function.extfun Type uniform_space) (finset environment.implicit_infer_kind)) : @separated_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) (finset.{0} environment.implicit_infer_kind) h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_9644 (h0 : topological_space (complete_distrib_lattice (has_add Type))) : locally_compact_space (complete_distrib_lattice (has_add Type)) := sorry --non-trivial
lemma new_lemma_9645 (h0 : group (canonically_ordered_comm_semiring (option (option (option num))))) : group.fg (canonically_ordered_comm_semiring (option (option (option num)))) := sorry --non-trivial
lemma new_lemma_9646 (h0 : not (list (filter Prop) -> false) -> list (filter Prop)) (h1 : nonempty (list (filter Prop))) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@id.{1} (filter.{0} Prop) (@list.head.{0} (filter.{0} Prop) (@filter.inhabited.{0} Prop) (@classical.choice_of_by_contradiction'.{1} (list.{0} (filter.{0} Prop)) h0 h1)))  := sorry --non-trivial
lemma new_lemma_9647 (h0 : ring (has_add (has_nnnorm linarith.ineq))) : rank_condition (has_add (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_9648 (h0 : uniform_space (monoid (option (option (option empty))))) : complete_space (monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_9649 (h0 : functor.add_const (list (cancel_monoid name)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_9650 (h0 : topological_space (normed_comm_ring (semiring (semiring (semiring empty))))) : discrete_topology (normed_comm_ring (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_9651 (h0 : functor.add_const (uniform_space (has_to_string name)) pos) : @separated_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_to_string.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_9652 (h0 : topological_space (boolean_algebra (has_Inf pos))) : normal_space (boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_9653 (h0 : group unsigned) : group.fg unsigned := sorry --non-trivial
lemma new_lemma_9654 (h4 : ring (distrib (has_ssubset (random_gen char)))) : is_domain (distrib (has_ssubset (random_gen char))) := sorry --non-trivial
lemma new_lemma_9655 (h0 : topological_space (has_zero (has_add environment.implicit_infer_kind))) : sequential_space (has_zero (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_9656 (h0 : topological_space (cancel_monoid (option unsigned))) : sequential_space (cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_9657 (h0 : topological_space (monoid_with_zero pos)) : preconnected_space (monoid_with_zero pos) := sorry --non-trivial
lemma new_lemma_9658 (h0 : uniform_space (random_gen (denumerable char))) : complete_space (random_gen (denumerable char)) := sorry --non-trivial
lemma new_lemma_9659 (h0 : topological_space (ordered_comm_monoid (has_Inf name))) : discrete_topology (ordered_comm_monoid (has_Inf name)) := sorry --non-trivial
lemma new_lemma_9660 (h0 : functor.add_const (complete_lattice (has_to_string unsigned)) (option ennreal)) : @complete_lattice.is_Sup_finite_compact.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} unsigned)) (option.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_9661 (h0 : has_mem.mem (semiring linarith.comp_source) has_emptyc.emptyc) : @monoid.fg.{0} (semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type monoid.{0} (semiring.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_9662 (h0 : ordered_comm_monoid (mul_zero_class environment.implicit_infer_kind)) : has_exists_mul_of_le (mul_zero_class environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_9663 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_9664 (h0 : has_mem.mem (with_bot num) has_emptyc.emptyc) : @is_add_cyclic.{0} (with_bot.{0} num) (@finset.pi.empty.{1 0} Type add_group.{0} (with_bot.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_9665 (h0 : function.extfun (finset Type) (has_mem.mem (has_top num))) : @totally_disconnected_space.{0} (has_top.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_9666 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) (boolean_algebra environment.implicit_infer_kind)) : @totally_separated_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) (boolean_algebra.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_9667 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_9668 (h0 : semiring (add_left_cancel_semigroup congr_arg_kind)) : is_noetherian_ring (add_left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_9669 (h0 : function.extfun Type group) : @is_cyclic.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_add_comm_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_9670 (h0 : topological_space (metric_space (add_group (random_gen (semiring num))))) : preirreducible_space (metric_space (add_group (random_gen (semiring num)))) := sorry --non-trivial
lemma new_lemma_9671 (h0 : topological_space (has_zero environment.implicit_infer_kind)) : loc_path_connected_space (has_zero environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_9672 (h0 : group (ordered_comm_ring (ring name))) : normalizer_condition (ordered_comm_ring (ring name)) := sorry --non-trivial
lemma new_lemma_9673 (h0 : semiring (with_bot (semiring (semiring (semiring num))))) : is_noetherian_ring (with_bot (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_9674 (h0 : ring (has_neg ennreal)) : is_principal_ideal_ring (has_neg ennreal) := sorry --non-trivial
lemma new_lemma_9675 (h1 : ring (generalized_boolean_algebra (has_nnnorm string_imp))) : strong_rank_condition (generalized_boolean_algebra (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_9676 (h0 : add_group (linear_ordered_semiring (random_gen linarith.comp))) : is_add_cyclic (linear_ordered_semiring (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_9677 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_9678 (h0 : functor.add_const (add_monoid (has_add Type)) Type) : @add_monoid.fg.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (add_monoid.{1} (has_add.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_9679 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) Type) : @totally_separated_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (normed_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_9680 (h0 : add_group (semiring fun_info)) : is_add_cyclic (semiring fun_info) := sorry --non-trivial
lemma new_lemma_9681 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_9682 (h0 : topological_space (linear_ordered_comm_ring (semiring congr_arg_kind))) : totally_separated_space (linear_ordered_comm_ring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_9683 (h0 : function.extfun nat fin) : @preirreducible_space.{0} (sub_neg_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_9684 (h0 : not (group (has_top linarith.comp_source) -> false)) : @is_cyclic.{0} (has_top.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (has_top.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_9685 (h0 : not (uniform_space (semiring num) -> false)) : @separated_space.{0} (semiring.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_9686 (h0 : topological_space (denumerable linarith.ineq)) : t0_space (denumerable linarith.ineq) := sorry --non-trivial
lemma new_lemma_9687 (h0 : topological_space (nondiscrete_normed_field string.iterator_imp)) : t0_space (nondiscrete_normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_9688 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} znum (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) znum)  := sorry --non-trivial
lemma new_lemma_9689 (h0 : function.extfun Type (prod (left_cancel_semigroup empty))) : id_rel (function.extfun_app h0 (left_cancel_semigroup empty)) := sorry --non-trivial
lemma new_lemma_9690 (h0 : functor.add_const (complete_lattice (boolean_algebra real)) real) : @is_compactly_generated.{0} (boolean_algebra.{0} real) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_9691 (h0 : functor.add_const (fin has_zero.zero) Type) : @is_atomistic.{1} (has_nndist.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (has_nndist.{1} Type)) (@functor.add_const.run.{0 1} (fin (@has_zero.zero.{0} nat nat.has_zero)) Type h0))  := sorry --non-trivial
lemma new_lemma_9692 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_Sup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_9693 (h0 : uniform_space (as_linear_order empty)) : complete_space (as_linear_order empty) := sorry --non-trivial
lemma new_lemma_9694 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_9695 (h1 : ring (has_append (random_gen reducibility_hints))) : strong_rank_condition (has_append (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_9696 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (normed_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (normed_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_9697 (h2 : ring (add_comm_semigroup char)) : rank_condition (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_9698 (h0 : group (has_nndist (has_to_string environment.implicit_infer_kind))) : normalizer_condition (has_nndist (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_9699 (h0 : topological_space (has_neg (option ennreal))) : normal_space (has_neg (option ennreal)) := sorry --non-trivial
lemma new_lemma_9700 (h0 : ordered_add_comm_monoid (cancel_monoid (option (option (option unsigned))))) : archimedean (cancel_monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_9701 (h0 : topological_space (has_to_string (comm_group (has_neg_part (comm_group Type))))) : sequential_space (has_to_string (comm_group (has_neg_part (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_9702 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_dist.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_9703 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_to_string name)) := sorry --non-trivial
lemma new_lemma_9704 (h0 : semiring (finset (has_neg (finset (mul_one_class pos))))) : is_noetherian_ring (finset (has_neg (finset (mul_one_class pos)))) := sorry --non-trivial
lemma new_lemma_9705 (h0 : complete_lattice (has_lt (has_compl linarith.ineq))) : is_compactly_generated (has_lt (has_compl linarith.ineq)) := sorry --non-trivial
lemma new_lemma_9706 (h0 : semiring (sub_neg_monoid (has_Inf (has_pos_part real)))) : is_noetherian_ring (sub_neg_monoid (has_Inf (has_pos_part real))) := sorry --non-trivial
lemma new_lemma_9707 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_9708 (h0 : functor.add_const (topological_space (has_neg pos)) environment.implicit_infer_kind) : @irreducible_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_9709 (h0 : functor.add_const (ring (semigroup pos)) Type) : @strong_rank_condition.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (semigroup.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_9710 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (add_cancel_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_9711 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (dlist.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (dlist.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_9712 (h0 : add_comm_group (linear_order empty)) (h1 : function.extfun Type has_norm) : @normed_group.core.{0} (linear_order.{0} empty) h0 (@function.extfun_app.{2 1} Type has_norm.{0} h1 (linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_9713 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_9714 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_9715 (h0 : ordered_add_comm_monoid (has_bot (has_Inf (has_add name)))) : archimedean (has_bot (has_Inf (has_add name))) := sorry --non-trivial
lemma new_lemma_9716 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (linear_ordered_comm_group.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_comm_group.{0} num))  := sorry --non-trivial
lemma new_lemma_9717 (h0 : functor.add_const (topological_space (metric_space empty)) num) : @t1_space.{0} (metric_space.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (metric_space.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_9718 (h0 : group (with_bot (has_inv linarith.comp_source))) : normalizer_condition (with_bot (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_9719 (h0 : ring (canonically_ordered_add_monoid (option unsigned))) : rank_condition (canonically_ordered_add_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_9720 (h0 : not (has_mem.mem (linear_ordered_semiring fun_info) has_emptyc.emptyc -> false)) : @totally_separated_space.{0} (linear_ordered_semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_9721 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_9722 (h1 : add_group (add_left_cancel_monoid (distrib to_additive.value_type))) : is_add_cyclic (add_left_cancel_monoid (distrib to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_9723 (h0 : functor.add_const (function.extfun Type ring) (finset linarith.comp)) : @rank_condition.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (finset.{0} linarith.comp) h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_9724 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (add_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (add_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_9725 (h0 : uniform_space (ring num)) : complete_space (ring num) := sorry --non-trivial
lemma new_lemma_9726 (h0 : topological_space (ordered_comm_ring (has_Inf Type))) : t0_space (ordered_comm_ring (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_9727 (h1 : topological_space (random_gen (has_ssubset reducibility_hints))) : t0_space (random_gen (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_9728 (h0 : uniform_space (add_cancel_comm_monoid (mul_one_class string.iterator_imp))) : complete_space (add_cancel_comm_monoid (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_9729 (h0 : monoid (has_add (semigroup Type))) : monoid.fg (has_add (semigroup Type)) := sorry --non-trivial
lemma new_lemma_9730 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_cancel_monoid unsigned)) num) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_cancel_monoid.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_9731 (h0 : list empty) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_9732 (h1 : ring (simple_graph (mul_one_class (mul_one_class ereal)))) : is_domain (simple_graph (mul_one_class (mul_one_class ereal))) := sorry --non-trivial
lemma new_lemma_9733 (h0 : topological_space (normed_group (has_one (has_one num)))) : discrete_topology (normed_group (has_one (has_one num))) := sorry --non-trivial
lemma new_lemma_9734 (h0 : group (has_pos_part (ordered_comm_monoid (has_Inf (has_Inf real))))) : group.fg (has_pos_part (ordered_comm_monoid (has_Inf (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_9735 (h0 : has_neg linarith.comp -> has_neg linarith.comp -> Prop) : total h0 := sorry --non-trivial
lemma new_lemma_9736 (h0 : ring (add_group (semiring (semiring (semiring unsigned))))) : strong_rank_condition (add_group (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_9737 (h0 : fin has_zero.zero) : @strong_rank_condition.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (ordered_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_9738 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_Sup.{0} (option.{0} (option.{0} empty))) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_Sup.{0} (option.{0} (option.{0} empty))))  := sorry --non-trivial
lemma new_lemma_9739 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_9740 (h0 : topological_space (pseudo_metric_space (has_to_string pos))) : regular_space (pseudo_metric_space (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_9741 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) name) : @topological_space.separable_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_9742 (h0 : functor.comp ring finset unsigned) : @is_principal_ideal_ring.{0} (finset.{0} unsigned) (@functor.comp.run.{0 0 0} ring.{0} finset.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_9743 (h0 : not (topological_space (option num) -> false)) : @totally_separated_space.{0} (option.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (option.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_9744 (h0 : topological_space (finset (option (option empty)))) : normal_space (finset (option (option empty))) := sorry --non-trivial
lemma new_lemma_9745 (h0 : complete_lattice (has_zero pos)) : is_atomistic (has_zero pos) := sorry --non-trivial
lemma new_lemma_9746 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_9747 (h0 : add_group (has_div (normed_field (semi_normed_ring linarith.comp_source)))) : is_add_cyclic (has_div (normed_field (semi_normed_ring linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_9748 (h0 : functor.add_const (topological_space (has_neg Type)) name) : @totally_separated_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_9749 (h0 : functor.add_const (list (has_neg name)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_9750 (h0 : uniform_space (semi_normed_comm_ring string.iterator_imp)) : complete_space (semi_normed_comm_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_9751 (h0 : not (complete_lattice (with_bot empty) -> false)) : @is_atomistic.{0} (with_bot.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_bot.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_9752 (h0 : filter (bin_tree (semiring (non_assoc_semiring unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_9753 (h0 : topological_space (has_neg_part (finset Type))) : regular_space (has_neg_part (finset Type)) := sorry --non-trivial
lemma new_lemma_9754 (h0 : group (has_add (has_add linarith.comp))) : group.fg (has_add (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_9755 (h0 : functor.add_const (complete_lattice (linear_ordered_cancel_comm_monoid unsigned)) empty) : @is_atomistic.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_9756 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (linear_ordered_field.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_9757 (h0 : functor.add_const (list (ordered_comm_ring name)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_9758 (h0 : not (add_group (distrib (has_ssubset to_additive.value_type)) -> false)) : @is_add_cyclic.{0} (distrib.{0} (has_ssubset.{0} to_additive.value_type)) (@classical.by_contradiction'.{1} (add_group.{0} (distrib.{0} (has_ssubset.{0} to_additive.value_type))) h0)  := sorry --non-trivial
lemma new_lemma_9759 (h0 : topological_space (ordered_comm_monoid (has_Inf (has_Inf real)))) : locally_compact_space (ordered_comm_monoid (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_9760 (h0 : ring (complete_semilattice_Sup (semiring congr_arg_kind))) : is_domain (complete_semilattice_Sup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_9761 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup name)) name) : @archimedean.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semigroup.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_9762 (h0 : add_monoid (canonically_ordered_comm_semiring (boolean_algebra.core linarith.comp))) : add_monoid.fg (canonically_ordered_comm_semiring (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_9763 (h0 : fin has_zero.zero) : @complete_space.{1} (canonically_linear_ordered_add_monoid.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (canonically_linear_ordered_add_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_9764 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_9765 (h0 : ring (linear_ordered_comm_ring empty)) : is_principal_ideal_ring (linear_ordered_comm_ring empty) := sorry --non-trivial
lemma new_lemma_9766 (h1 : topological_space (denumerable char)) : totally_disconnected_space (denumerable char) := sorry --non-trivial
lemma new_lemma_9767 (h0 : not (topological_space (non_unital_non_assoc_semiring (mul_one_class (mul_one_class linarith.ineq))) -> false)) : @t0_space.{0} (non_unital_non_assoc_semiring.{0} (mul_one_class.{0} (mul_one_class.{0} linarith.ineq))) (@classical.by_contradiction'.{1} (topological_space.{0} (non_unital_non_assoc_semiring.{0} (mul_one_class.{0} (mul_one_class.{0} linarith.ineq)))) h0)  := sorry --non-trivial
lemma new_lemma_9768 (h0 : group (has_to_string real)) : is_cyclic (has_to_string real) := sorry --non-trivial
lemma new_lemma_9769 (h0 : topological_space (finset (finset ennreal))) : path_connected_space (finset (finset ennreal)) := sorry --non-trivial
lemma new_lemma_9770 (h0 : function.extfun nat fin) : @totally_disconnected_space.{0} (has_add.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_9771 (h0 : functor.comp ring has_neg_part name) : @is_domain.{0} (has_neg_part.{0} name) (@functor.comp.run.{0 0 0} ring.{0} has_neg_part.{0} name (@functor.comp.run.{0 0 0} ring.{0} has_neg_part.{0} name (@functor.comp.run.{0 0 0} ring.{0} has_neg_part.{0} name h0)))  := sorry --non-trivial
lemma new_lemma_9772 (h0 : monoid (has_norm (semiring (has_norm to_additive.value_type)))) : monoid.fg (has_norm (semiring (has_norm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_9773 (h0 : topological_space (add_group (semiring (semiring (has_top empty))))) : totally_disconnected_space (add_group (semiring (semiring (has_top empty)))) := sorry --non-trivial
lemma new_lemma_9774 (h0 : topological_space Type) : totally_disconnected_space Type := sorry --non-trivial
lemma new_lemma_9775 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot fun_info))) : @t0_space.{0} (with_bot.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_9776 (h2 : set (has_compl std_gen)) : set.finite h2 := sorry --non-trivial
lemma new_lemma_9777 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_9778 (h0 : ring (mul_zero_class (finset (finset name)))) : is_principal_ideal_ring (mul_zero_class (finset (finset name))) := sorry --non-trivial
lemma new_lemma_9779 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_domain.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_9780 (h0 : functor.add_const (topological_space (add_comm_monoid name)) (boolean_algebra pos)) : @locally_compact_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) (boolean_algebra.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_9781 (h0 : functor.add_const (function.extfun (Type 1) list) name) : list.nodup (function.extfun_app (functor.add_const.run h0) (ring Type)) := sorry --non-trivial
lemma new_lemma_9782 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (measurable_space.dynkin_system.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (measurable_space.dynkin_system.{0} empty))  := sorry --non-trivial
lemma new_lemma_9783 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (add_group.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_9784 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_9785 (h0 : function.extfun Type group) : @group.fg.{0} (complete_semilattice_Sup.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_semilattice_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_9786 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @irreducible_space.{0} (semiring.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.ineq))))) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.ineq))))))  := sorry --non-trivial
lemma new_lemma_9787 (h0 : ring (add_cancel_monoid (normed_comm_ring pos))) : rank_condition (add_cancel_monoid (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_9788 (h0 : denumerable empty -> linarith.comp -> Prop) (h1 : not (prod (denumerable empty) linarith.comp -> false)) : function.uncurry h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_9789 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_9790 (h0 : functor.add_const (group (has_neg linarith.comp)) name) : @group.fg.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_9791 (h0 : list (has_nndist (option (option (option (option (ring (ring (option (ring pos)))))))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_9792 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_9793 (h0 : topological_space (has_Inf (has_Inf (has_pos_part name)))) : t0_space (has_Inf (has_Inf (has_pos_part name))) := sorry --non-trivial
lemma new_lemma_9794 (h0 : topological_space (normed_comm_ring (option (option (option (option ennreal)))))) : normal_space (normed_comm_ring (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_9795 (h0 : topological_space (boolean_algebra (finset (finset Type)))) : loc_path_connected_space (boolean_algebra (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_9796 (h0 : complete_lattice (linear_ordered_comm_ring (semiring (semiring num)))) : is_compactly_generated (linear_ordered_comm_ring (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_9797 (h0 : group (canonically_ordered_comm_semiring (option (option unsigned)))) : normalizer_condition (canonically_ordered_comm_semiring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_9798 (h0 : function.extfun nat fin) : @archimedean.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (ordered_add_comm_monoid.{1} (has_bot.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_9799 (h0 : topological_space (ordered_comm_ring (has_Inf Type))) : totally_separated_space (ordered_comm_ring (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_9800 (h0 : topological_space (canonically_ordered_monoid pos)) : totally_separated_space (canonically_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_9801 (h0 : topological_space (semigroup (finset (ring pos)))) : totally_separated_space (semigroup (finset (ring pos))) := sorry --non-trivial
lemma new_lemma_9802 (h0 : cancel_comm_monoid_with_zero (has_nndist empty)) : unique_factorization_monoid (has_nndist empty) := sorry --non-trivial
lemma new_lemma_9803 (h0 : filter (option (semiring empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_9804 (h0 : function.extfun Type (functor.add_const (group (cancel_monoid ennreal)))) : @is_cyclic.{0} (cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (cancel_monoid.{0} ennreal)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (cancel_monoid.{0} ennreal))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_9805 (h0 : functor.add_const (ring (boolean_algebra name)) environment.implicit_infer_kind) : @strong_rank_condition.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_9806 (h1 : uniform_space (has_ssubset char)) : complete_space (has_ssubset char) := sorry --non-trivial
lemma new_lemma_9807 (h0 : functor.add_const (list (ordered_comm_ring linarith.comp)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_9808 (h0 : complete_lattice (has_top (semiring (semiring unsigned)))) : is_compactly_generated (has_top (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_9809 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (ordered_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_9810 (h0 : set (add_comm_semigroup fun_info -> mul_one_class std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_9811 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_9812 (h0 : add_monoid (option pos)) : add_monoid.fg (option pos) := sorry --non-trivial
lemma new_lemma_9813 (h0 : topological_space (boolean_algebra (finset (has_to_string pos)))) : topological_space.separable_space (boolean_algebra (finset (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_9814 (h0 : functor.add_const Prop (simple_graph Type)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_9815 (h3 : not (complete_lattice (measurable_space linarith.comp) -> false)) : is_atomistic (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_9816 (h0 : topological_space (canonically_ordered_monoid linarith.comp)) : regular_space (canonically_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_9817 (h0 : add_group (has_nnnorm (mul_one_class (mul_one_class reducibility_hints)))) : is_add_cyclic (has_nnnorm (mul_one_class (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_9818 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_9819 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system congr_arg_kind)) (semiring num)) : @locally_compact_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_9820 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_add_comm_group.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) complete_lattice.{0}) (linear_ordered_add_comm_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_9821 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_emptyc.{0} (with_bot.{0} (with_bot.{0} string_imp))) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_emptyc.{0} (with_bot.{0} (with_bot.{0} string_imp))))  := sorry --non-trivial
lemma new_lemma_9822 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type add_group.{0} h0 (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_9823 (h0 : complete_lattice (dlist (has_inv linarith.comp_source))) : is_compactly_generated (dlist (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_9824 (h0 : monoid (has_add (has_to_string (has_to_string num)))) : monoid.fg (has_add (has_to_string (has_to_string num))) := sorry --non-trivial
lemma new_lemma_9825 (h0 : semiring (ordered_comm_monoid (has_add (has_add (has_add Type))))) : is_noetherian_ring (ordered_comm_monoid (has_add (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_9826 (h0 : functor.add_const (function.extfun Type complete_lattice) unsigned) : @is_compactly_generated.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) unsigned h0) (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_9827 (h0 : list (canonically_linear_ordered_monoid (has_neg (has_neg real)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_9828 (h0 : topological_space (has_nndist (has_nndist Type))) : locally_compact_space (has_nndist (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_9829 (h0 : monoid (has_pos_part linarith.comp)) : monoid.fg (has_pos_part linarith.comp) := sorry --non-trivial
lemma new_lemma_9830 (h0 : uniform_space (comm_semigroup (has_Inf pos))) : complete_space (comm_semigroup (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_9831 (h0 : add_monoid (comm_monoid (option (option (option (option (option empty))))))) : add_monoid.fg (comm_monoid (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_9832 (h0 : functor.add_const (topological_space (comm_monoid empty)) empty) : @totally_disconnected_space.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_9833 (h0 : topological_space (has_nnnorm linarith.comp_source)) : t0_space (has_nnnorm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_9834 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (ordered_ring (option unsigned))) := sorry --non-trivial
lemma new_lemma_9835 (h0 : function.extfun (Type 1) topological_space) : @totally_disconnected_space.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_9836 (h0 : functor.add_const (uniform_space (has_zero linarith.comp)) environment.implicit_infer_kind) : @separated_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_zero.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_9837 (h0 : function.extfun Type (functor.comp group comm_group)) : @is_cyclic.{0} (comm_group.{0} pos) (@functor.comp.run.{0 0 0} group.{0} comm_group.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} comm_group.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_9838 (h0 : filter (with_bot (has_inv linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_9839 (h0 : ring (distrib string_imp)) : rank_condition (distrib string_imp) := sorry --non-trivial
lemma new_lemma_9840 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (complete_distrib_lattice.{0} stieltjes_function) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (complete_distrib_lattice.{0} stieltjes_function))  := sorry --non-trivial
lemma new_lemma_9841 (h0 : functor.add_const (topological_space (monoid unsigned)) empty) : @path_connected_space.{0} (monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_9842 (h0 : functor.add_const (ring (has_Inf linarith.comp)) Type) : @strong_rank_condition.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (has_Inf.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_9843 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_9844 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @complete_space.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 uniform_space.{1}) (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_9845 (h0 : list (add_cancel_monoid num)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_9846 (h0 : add_monoid (id (normed_group (id empty)))) : add_monoid.fg (id (normed_group (id empty))) := sorry --non-trivial
lemma new_lemma_9847 (h0 : not (topological_space (linear_ordered_semiring linarith.comp_source) -> false)) : @path_connected_space.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_9848 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} h0 (linear_ordered_add_comm_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_9849 (h0 : group (linear_ordered_semiring (has_norm (has_norm (has_norm num))))) : normalizer_condition (linear_ordered_semiring (has_norm (has_norm (has_norm num)))) := sorry --non-trivial
lemma new_lemma_9850 (h0 : ordered_add_comm_monoid (has_neg_part (boolean_algebra.core name))) : archimedean (has_neg_part (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_9851 (h0 : add_group (add_cancel_monoid (has_neg (has_zero pos)))) : is_add_cyclic (add_cancel_monoid (has_neg (has_zero pos))) := sorry --non-trivial
lemma new_lemma_9852 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_9853 (h0 : add_monoid (normed_comm_ring (comm_group unsigned))) : add_monoid.fg (normed_comm_ring (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_9854 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_9855 (h0 : functor.add_const (group (comm_group unsigned)) unsigned) : @group.fg.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_9856 (h0 : cancel_comm_monoid_with_zero (left_cancel_semigroup unsigned)) : unique_factorization_monoid (left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_9857 (h1 : ring (normed_comm_ring (random_gen char))) : rank_condition (normed_comm_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_9858 (h0 : ring (has_add (comm_group (boolean_algebra Type)))) : rank_condition (has_add (comm_group (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_9859 (h0 : uniform_space (ordered_comm_ring (has_bot Type))) : separated_space (ordered_comm_ring (has_bot Type)) := sorry --non-trivial
lemma new_lemma_9860 (h0 : topological_space (has_nndist (finset linarith.comp))) : normal_space (has_nndist (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_9861 (h0 : function.extfun (((Type -> Type) -> Type 1) -> Type 1) (function.extfun ((Type -> Type) -> Type 1))) : @is_compactly_generated.{0} (dlist.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (@function.extfun_app.{3 3} (((Type → Type) → Type 1) → Type 1) (function.extfun.{3 2} ((Type → Type) → Type 1)) h0 (function.extfun.{2 2} (Type → Type))) (function.extfun.{2 1} Type)) complete_lattice.{0}) (dlist.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_9862 (h0 : functor.add_const (function.extfun Type group) (ring Type)) : @normalizer_condition.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) (ring.{1} Type) h0) (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_9863 (h0 : ring (normed_comm_ring (comm_group name))) : is_principal_ideal_ring (normed_comm_ring (comm_group name)) := sorry --non-trivial
lemma new_lemma_9864 (h0 : group (normed_comm_ring (comm_group pos))) : is_simple_group (normed_comm_ring (comm_group pos)) := sorry --non-trivial
lemma new_lemma_9865 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_comm_semiring unsigned)) : unique_factorization_monoid (canonically_ordered_comm_semiring unsigned) := sorry --non-trivial
lemma new_lemma_9866 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @sequential_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) Type)  := sorry --non-trivial
lemma new_lemma_9867 (h0 : group (complete_distrib_lattice (cancel_monoid name))) : group.fg (complete_distrib_lattice (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_9868 (h0 : group (complete_distrib_lattice (has_nndist (add_comm_monoid pos)))) : is_cyclic (complete_distrib_lattice (has_nndist (add_comm_monoid pos))) := sorry --non-trivial
lemma new_lemma_9869 (h0 : functor.add_const (topological_space (linear_ordered_comm_monoid_with_zero (option empty))) empty) : @irreducible_space.{0} (linear_ordered_comm_monoid_with_zero.{0} (option.{0} empty)) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_monoid_with_zero.{0} (option.{0} empty))) empty h0)  := sorry --non-trivial
lemma new_lemma_9870 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (add_cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_9871 (h0 : topological_space (linear_ordered_field num)) : preirreducible_space (linear_ordered_field num) := sorry --non-trivial
lemma new_lemma_9872 (h0 : topological_space (normed_lattice_add_comm_group (has_add pos))) : irreducible_space (normed_lattice_add_comm_group (has_add pos)) := sorry --non-trivial
lemma new_lemma_9873 (h0 : function.extfun (Type 1) ordered_comm_monoid) : @has_exists_mul_of_le.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} h0 (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_9874 (h0 : topological_space (boolean_algebra.core ennreal)) : sequential_space (boolean_algebra.core ennreal) := sorry --non-trivial
lemma new_lemma_9875 (h0 : topological_space (add_comm_monoid (comm_group Type))) : loc_path_connected_space (add_comm_monoid (comm_group Type)) := sorry --non-trivial
lemma new_lemma_9876 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_9877 (h0 : topological_space (has_to_string (has_add linarith.comp))) : topological_space.separable_space (has_to_string (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_9878 (h1 : add_group reducibility_hints) : is_add_cyclic reducibility_hints := sorry --non-trivial
lemma new_lemma_9879 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_9880 (h0 : functor.add_const Prop (boolean_algebra name)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_9881 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} fun_info (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) fun_info)  := sorry --non-trivial
lemma new_lemma_9882 (h0 : topological_space (simple_graph pos)) : normal_space (simple_graph pos) := sorry --non-trivial
lemma new_lemma_9883 (h0 : list (free_add_monoid (option (option unsigned)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_9884 (h0 : uniform_space (add_comm_monoid (has_add (has_bot (has_add (has_Inf real)))))) : separated_space (add_comm_monoid (has_add (has_bot (has_add (has_Inf real))))) := sorry --non-trivial
lemma new_lemma_9885 (h0 : functor.add_const (topological_space (add_comm_monoid unsigned)) Type) : @totally_separated_space.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_9886 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @rank_condition.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_9887 (h0 : functor.add_const (add_group (has_to_string Type)) linarith.comp) : @is_add_cyclic.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (has_to_string.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_9888 (h0 : function.extfun Type topological_space) : @regular_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_9889 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_9890 (h0 : cancel_comm_monoid_with_zero (has_to_string (has_to_string pos))) : unique_factorization_monoid (has_to_string (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_9891 (h0 : ordered_comm_monoid (canonically_linear_ordered_monoid (finset linarith.comp))) : has_exists_mul_of_le (canonically_linear_ordered_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_9892 (h0 : topological_space (semiring (has_top empty))) : totally_disconnected_space (semiring (has_top empty)) := sorry --non-trivial
lemma new_lemma_9893 (h0 : complete_lattice (has_nndist (metric_space linarith.comp))) : is_compactly_generated (has_nndist (metric_space linarith.comp)) := sorry --non-trivial
lemma new_lemma_9894 (h0 : topological_space (distrib_lattice string_imp)) : locally_compact_space (distrib_lattice string_imp) := sorry --non-trivial
lemma new_lemma_9895 (h0 : topological_space (has_zero (has_add (has_to_string (has_to_string (finset pos)))))) : t1_space (has_zero (has_add (has_to_string (has_to_string (finset pos))))) := sorry --non-trivial
lemma new_lemma_9896 (h0 : topological_space (with_one (has_inv (has_inv linarith.comp_source)))) : totally_separated_space (with_one (has_inv (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_9897 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_neg_part.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg_part.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_9898 (h0 : group (ring (has_zero (has_zero Type)))) : group.fg (ring (has_zero (has_zero Type))) := sorry --non-trivial
lemma new_lemma_9899 (h0 : complete_lattice (add_monoid environment.implicit_infer_kind)) : complete_lattice.is_Sup_finite_compact (add_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_9900 (h0 : uniform_space (metric_space (random_gen char))) : complete_space (metric_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_9901 (h0 : not (ring (semi_normed_ring to_additive.value_type) -> false)) : @strong_rank_condition.{0} (semi_normed_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_ring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_9902 (h0 : semiring (simple_graph (boolean_algebra.core pos))) : is_noetherian_ring (simple_graph (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_9903 (h0 : ring (cancel_monoid (option pos))) : strong_rank_condition (cancel_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_9904 (h0 : topological_space (left_cancel_semigroup (semiring (semiring congr_arg_kind)))) : totally_disconnected_space (left_cancel_semigroup (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_9905 (h0 : uniform_space (normed_group char)) : complete_space (normed_group char) := sorry --non-trivial
lemma new_lemma_9906 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_9907 (h0 : group (with_one (semiring empty))) : group.fg (with_one (semiring empty)) := sorry --non-trivial
lemma new_lemma_9908 (h0 : functor.add_const (list (boolean_algebra.core unsigned)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_9909 (h0 : filter (add_comm_monoid (option (option (cancel_monoid ennreal))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_9910 (h2 : function.extfun Type topological_space) : @t0_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h2 (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_9911 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_9912 (h0 : group (add_cancel_monoid (has_neg_part Type))) : normalizer_condition (add_cancel_monoid (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_9913 (h0 : functor.add_const (ring ennreal) ennreal) : @rank_condition.{0} ennreal (@functor.add_const.run.{0 0} (ring.{0} ennreal) ennreal h0)  := sorry --non-trivial
lemma new_lemma_9914 (h0 : uniform_space (generalized_boolean_algebra (finset (has_add linarith.comp)))) : separated_space (generalized_boolean_algebra (finset (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_9915 (h0 : group (semigroup (comm_group pos))) : is_simple_group (semigroup (comm_group pos)) := sorry --non-trivial
lemma new_lemma_9916 (h0 : topological_space (has_sub num)) : normal_space (has_sub num) := sorry --non-trivial
lemma new_lemma_9917 (h0 : ring (free_add_monoid (semiring (semiring num)))) : is_domain (free_add_monoid (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_9918 (h0 : topological_space (cancel_monoid (boolean_algebra (has_nndist name)))) : regular_space (cancel_monoid (boolean_algebra (has_nndist name))) := sorry --non-trivial
lemma new_lemma_9919 (h0 : group (dlist linarith.ineq)) : group.fg (dlist linarith.ineq) := sorry --non-trivial
lemma new_lemma_9920 (h0 : not (ring (has_compl char) -> false)) : @rank_condition.{0} (has_compl.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_9921 (h0 : not (ring (uniform_space to_additive.value_type) -> false)) : @is_domain.{0} (uniform_space.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (uniform_space.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_9922 (h0 : add_monoid (boolean_algebra (cancel_monoid (comm_group Type)))) : add_monoid.fg (boolean_algebra (cancel_monoid (comm_group Type))) := sorry --non-trivial
lemma new_lemma_9923 (h0 : not (add_monoid (has_union congr_arg_kind) -> false)) : @add_monoid.fg.{0} (has_union.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_monoid.{0} (has_union.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_9924 (h0 : group (add_cancel_comm_monoid (mul_one_class char))) (h1 : subgroup (add_cancel_comm_monoid (mul_one_class char))) : subgroup.characteristic h1 := sorry --non-trivial
lemma new_lemma_9925 (h0 : function.extfun (Type 1) topological_space) : @regular_space.{1} (sub_neg_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (sub_neg_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_9926 (h0 : has_mem.mem (random_gen (semiring congr_arg_kind)) has_emptyc.emptyc) : filter.ne_bot (finset.pi.empty filter (random_gen (semiring congr_arg_kind)) h0) := sorry --non-trivial
lemma new_lemma_9927 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (@id.{2} Type linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (@id.{2} Type linarith.ineq))  := sorry --non-trivial
lemma new_lemma_9928 (h0 : topological_space (has_add (has_pos_part pos))) : totally_disconnected_space (has_add (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_9929 (h0 : topological_space (has_add (boolean_algebra name))) : preirreducible_space (has_add (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_9930 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} h0 (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_9931 (h0 : uniform_space (linear_ordered_field (option unsigned))) : complete_space (linear_ordered_field (option unsigned)) := sorry --non-trivial
lemma new_lemma_9932 (h0 : functor.add_const (ring (ring Type)) Type) : @is_principal_ideal_ring.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_9933 (h0 : group (ring (has_to_string (has_to_string linarith.comp)))) : is_cyclic (ring (has_to_string (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_9934 (h3 : has_coe linarith.ineq Prop) (h4 : linarith.ineq) : @coe_b.{1 1} linarith.ineq Prop h3 h4  := sorry --non-trivial
lemma new_lemma_9935 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (measurable_space.dynkin_system unsigned)) := sorry --non-trivial
lemma new_lemma_9936 (h0 : cancel_comm_monoid_with_zero (add_right_cancel_monoid empty)) : unique_factorization_monoid (add_right_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_9937 (h0 : functor.add_const (uniform_space Type) Type) : @complete_space.{1} Type (@functor.add_const.run.{1 1} (uniform_space.{1} Type) Type h0)  := sorry --non-trivial
lemma new_lemma_9938 (h0 : group (comm_group pos)) : normalizer_condition (comm_group pos) := sorry --non-trivial
lemma new_lemma_9939 (h0 : not (group (with_one (random_gen (has_nnnorm (random_gen (random_gen to_additive.value_type))))) -> false)) : @is_cyclic.{0} (with_one.{0} (random_gen.{0} (has_nnnorm.{0} (random_gen.{0} (random_gen.{0} to_additive.value_type))))) (@classical.by_contradiction'.{1} (group.{0} (with_one.{0} (random_gen.{0} (has_nnnorm.{0} (random_gen.{0} (random_gen.{0} to_additive.value_type)))))) h0)  := sorry --non-trivial
lemma new_lemma_9940 (h0 : ring (add_comm_semigroup (add_comm_semigroup (mul_one_class environment.projection_info)))) : is_domain (add_comm_semigroup (add_comm_semigroup (mul_one_class environment.projection_info))) := sorry --non-trivial
lemma new_lemma_9941 (h1 : complete_lattice reducibility_hints) : is_compactly_generated reducibility_hints := sorry --non-trivial
lemma new_lemma_9942 (h0 : functor.add_const (list (ring linarith.comp)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_9943 (h0 : finset (has_inter (option (option empty)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_9944 (h0 : ordered_add_comm_monoid (sub_neg_monoid (has_neg name))) : archimedean (sub_neg_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_9945 (h0 h1 : to_additive.value_type -> to_additive.value_type) : function.right_inverse h0 h1 := sorry --non-trivial
lemma new_lemma_9946 (h0 : semiring (semigroup (semigroup (semigroup (ring Type))))) : is_noetherian_ring (semigroup (semigroup (semigroup (ring Type)))) := sorry --non-trivial
lemma new_lemma_9947 (h0 : not (topological_space (measurable_space.dynkin_system linarith.comp) -> false)) : @path_connected_space.{0} (measurable_space.dynkin_system.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.dynkin_system.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_9948 (h0 : add_group (simple_graph (finset (has_pos_part pos)))) : is_add_cyclic (simple_graph (finset (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_9949 (h0 : topological_space (canonically_ordered_add_monoid (option (option unsigned)))) : t0_space (canonically_ordered_add_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_9950 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @preirreducible_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_9951 (h0 : add_monoid (has_inter (option (option num)))) : add_monoid.fg (has_inter (option (option num))) := sorry --non-trivial
lemma new_lemma_9952 (h0 : add_monoid (complete_semilattice_Sup (semiring congr_arg_kind))) : add_monoid.fg (complete_semilattice_Sup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_9953 (h0 : not (complete_lattice (left_cancel_semigroup num) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (left_cancel_semigroup.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (left_cancel_semigroup.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_9954 (h0 : filter (normed_comm_ring (ring linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_9955 (h0 : fin has_zero.zero) : @separated_space.{0} (has_bot.{0} name) (@matrix.vec_empty.{0} (uniform_space.{0} (has_bot.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_9956 (h0 : topological_space (group_with_zero (has_neg_part pos))) : t0_space (group_with_zero (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_9957 : subsingleton doc_category := sorry --non-trivial
lemma new_lemma_9958 (h0 : functor.add_const (group (measurable_space.dynkin_system num)) empty) : @normalizer_condition.{0} (measurable_space.dynkin_system.{0} num) (@functor.add_const.run.{0 0} (group.{0} (measurable_space.dynkin_system.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_9959 (h0 : topological_space (semigroup (finset Type))) : totally_disconnected_space (semigroup (finset Type)) := sorry --non-trivial
lemma new_lemma_9960 (h0 : topological_space (semiring num)) : totally_disconnected_space (semiring num) := sorry --non-trivial
lemma new_lemma_9961 (h0 : functor.add_const (complete_lattice (normed_comm_ring pos)) pos) : @is_atomistic.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_9962 (h0 : function.extfun Type ring) : @is_domain.{0} (has_bot.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_9963 (h0 : list (filter (semiring empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_9964 (h0 : functor.add_const (monoid (comm_group Type)) linarith.comp) : @monoid.fg.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (comm_group.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_9965 (h0 : functor.add_const (topological_space (has_add linarith.comp)) (has_neg name)) : @t0_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_9966 (h0 : semiring (complete_semilattice_Sup (has_top fun_info))) (h1 : complete_semilattice_Sup (has_top fun_info)) : odd h1 := sorry --non-trivial
lemma new_lemma_9967 (h0 : has_mem.mem (random_gen linarith.comp_source) has_emptyc.emptyc) : @is_domain.{0} (random_gen.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (random_gen.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_9968 (h0 : measurable_space num) (h1 : has_mul num) (h2 : has_mem.mem h0 has_emptyc.emptyc) : @measure_theory.measure.is_mul_right_invariant.{0} num h0 h1 (@finset.pi.empty.{0 0} (measurable_space.{0} num) (@measure_theory.measure.{0} num) h0 h2)  := sorry --non-trivial
lemma new_lemma_9969 (h0 : ring (cancel_monoid (has_add ennreal))) : is_principal_ideal_ring (cancel_monoid (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_9970 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (canonically_ordered_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_9971 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) linarith.comp) : @t1_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_9972 (h0 : functor.add_const (topological_space (has_to_string pos)) (has_nndist linarith.comp)) : @topological_space.separable_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) (has_nndist.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_9973 (h2 : list (has_norm to_additive.value_type)) : list.nodup h2 := sorry --non-trivial
lemma new_lemma_9974 (h0 : topological_space ennreal) : t0_space ennreal := sorry --non-trivial
lemma new_lemma_9975 (h0 : group (semi_normed_comm_ring linarith.comp_source)) : is_cyclic (semi_normed_comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_9976 (h0 : list (free_add_monoid congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_9977 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @regular_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_9978 (h0 : topological_space (encodable (random_gen linarith.ineq))) : t0_space (encodable (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_9979 (h0 : topological_space (cancel_monoid Type)) : loc_path_connected_space (cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_9980 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (simple_graph unsigned)) := sorry --non-trivial
lemma new_lemma_9981 (h0 : functor.add_const (semiring (add_comm_monoid pos)) name) : @is_noetherian_ring.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (add_comm_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_9982 (h0 : topological_space (with_bot (random_gen num))) : totally_disconnected_space (with_bot (random_gen num)) := sorry --non-trivial
lemma new_lemma_9983 (h0 : not (topological_space (linear_ordered_comm_group_with_zero string_imp) -> false)) : @path_connected_space.{0} (linear_ordered_comm_group_with_zero.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_group_with_zero.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_9984 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_9985 (h0 : topological_space (boolean_algebra.core (fintype environment.implicit_infer_kind))) : preconnected_space (boolean_algebra.core (fintype environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_9986 (h0 : topological_space (has_pos_part (has_add (has_add (has_Inf linarith.comp))))) : preconnected_space (has_pos_part (has_add (has_add (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_9987 (h0 : topological_space (sub_neg_monoid (finset (has_Inf linarith.comp)))) : discrete_topology (sub_neg_monoid (finset (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_9988 (h0 : functor.add_const (topological_space (has_add linarith.comp)) Type) : @preconnected_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_9989 (h0 : function.extfun Type group) : @group.fg.{0} (left_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (left_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_9990 (h0 : not (ring (non_unital_non_assoc_semiring string_imp) -> false)) : @strong_rank_condition.{0} (non_unital_non_assoc_semiring.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (non_unital_non_assoc_semiring.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_9991 (h1 : not (topological_space (distrib linarith.comp_source) -> false)) : @path_connected_space.{0} (distrib.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_9992 (h0 : ring (has_top to_additive.value_type)) : is_domain (has_top to_additive.value_type) := sorry --non-trivial
lemma new_lemma_9993 (h0 : topological_space (with_zero linarith.comp_source)) : path_connected_space (with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_9994 (h0 : ring (distrib (has_nnnorm (has_lt linarith.comp_source)))) : strong_rank_condition (distrib (has_nnnorm (has_lt linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_9995 (h0 : ring (denumerable (metric_space to_additive.value_type))) : is_domain (denumerable (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_9996 (h1 : complete_lattice (add_cancel_comm_monoid string_imp)) : is_compactly_generated (add_cancel_comm_monoid string_imp) := sorry --non-trivial
lemma new_lemma_9997 (h0 : group (has_to_string pos)) : is_cyclic (has_to_string pos) := sorry --non-trivial
lemma new_lemma_9998 (h0 : topological_space (boolean_algebra (has_neg linarith.comp))) : topological_space.separable_space (boolean_algebra (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_9999 (h0 : preorder (add_comm_semigroup (add_comm_semigroup ereal))) (h1 : set (add_comm_semigroup (add_comm_semigroup ereal))) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_10000 (h0 : functor.add_const (topological_space name) unsigned) : @irreducible_space.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) unsigned h0)  := sorry --non-trivial
lemma new_lemma_10001 (h1 : complete_lattice (normed_field string_imp)) : is_compactly_generated (normed_field string_imp) := sorry --non-trivial
lemma new_lemma_10002 (h0 : topological_space (complete_distrib_lattice (has_add (has_add name)))) : preirreducible_space (complete_distrib_lattice (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_10003 (h0 : monoid (boolean_algebra (has_to_string (has_pos_part environment.implicit_infer_kind)))) : monoid.fg (boolean_algebra (has_to_string (has_pos_part environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_10004 (h0 : group (random_gen congr_arg_kind)) : is_cyclic (random_gen congr_arg_kind) := sorry --non-trivial
lemma new_lemma_10005 (h0 : complete_lattice (random_gen to_additive.value_type)) : is_compactly_generated (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_10006 (h0 : add_monoid (has_neg (has_add linarith.comp))) : add_monoid.fg (has_neg (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_10007 (h0 : functor.add_const (functor.add_const (topological_space ordering) linarith.comp) name) : @irreducible_space.{0} ordering (@functor.add_const.run.{0 0} (topological_space.{0} ordering) linarith.comp (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} ordering) linarith.comp) name h0))  := sorry --non-trivial
lemma new_lemma_10008 (h0 : functor.add_const (topological_space (boolean_algebra Type)) linarith.comp) : @regular_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_10009 (h0 : prod (finset ennreal) (finset ennreal)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_10010 (h0 : add_monoid (has_norm (has_top (semiring empty)))) : add_monoid.fg (has_norm (has_top (semiring empty))) := sorry --non-trivial
lemma new_lemma_10011 (h0 : semiring (normed_comm_ring (has_neg pos))) : is_noetherian_ring (normed_comm_ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_10012 (h0 : add_group (has_zero (has_Inf linarith.comp))) : is_add_cyclic (has_zero (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_10013 (h0 : topological_space (linear_ordered_comm_group (option unsigned))) : t1_space (linear_ordered_comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_10014 (h1 : set (add_comm_semigroup linarith.ineq -> char)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_10015 (h0 : topological_space (encodable (has_top to_additive.value_type))) : t0_space (encodable (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_10016 (h1 : complete_lattice (linear_ordered_add_comm_group to_additive.value_type)) : is_compactly_generated (linear_ordered_add_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_10017 (h0 : topological_space (has_zero Type)) : t1_space (has_zero Type) := sorry --non-trivial
lemma new_lemma_10018 (h0 : topological_space (id (measurable_space congr_arg_kind))) : totally_disconnected_space (id (measurable_space congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_10019 (h0 : topological_space (boolean_algebra (has_pos_part Type))) : totally_disconnected_space (boolean_algebra (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_10020 (h0 : group (has_to_string (ring (has_add (has_add linarith.comp))))) : is_simple_group (has_to_string (ring (has_add (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_10021 (h0 : cancel_comm_monoid_with_zero (add_semigroup (option unsigned))) : unique_factorization_monoid (add_semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_10022 (h0 : topological_space (partial_order congr_arg_kind)) : path_connected_space (partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_10023 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_10024 (h0 : ordered_comm_monoid (boolean_algebra (has_add (has_add linarith.comp)))) : has_exists_mul_of_le (boolean_algebra (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_10025 (h0 : functor.add_const (list (has_neg pos)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_10026 (h0 : add_group (id (has_norm num))) : is_add_cyclic (id (has_norm num)) := sorry --non-trivial
lemma new_lemma_10027 (h0 : complete_lattice (has_nndist (comm_group (comm_group (has_to_string pos))))) : is_compactly_generated (has_nndist (comm_group (comm_group (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_10028 (h0 h1 : multiset (random_gen to_additive.value_type)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_10029 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_10030 (h1 : topological_space (distrib string.iterator_imp)) : totally_disconnected_space (distrib string.iterator_imp) := sorry --non-trivial
lemma new_lemma_10031 (h0 : fin has_zero.zero) : @preirreducible_space.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (comm_semigroup.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_10032 (h0 : monoid (simple_graph (finset (has_Inf Type)))) : monoid.fg (simple_graph (finset (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_10033 (h0 : finset (has_neg empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_10034 (h0 : ring (finset (has_nndist pos))) : is_principal_ideal_ring (finset (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_10035 (h0 : topological_space (add_comm_semigroup std_gen)) : topological_space.first_countable_topology (add_comm_semigroup std_gen) := sorry --non-trivial
lemma new_lemma_10036 (h0 : semiring fun_info -> Prop) : zzz_forall h0 := sorry --non-trivial
lemma new_lemma_10037 (h0 : monoid (id to_additive.value_type)) : monoid.fg (id to_additive.value_type) := sorry --non-trivial
lemma new_lemma_10038 (h0 : topological_space (denumerable (has_top fun_info))) : totally_disconnected_space (denumerable (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_10039 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (preorder.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} num))  := sorry --non-trivial
lemma new_lemma_10040 (h1 : has_mem.mem (has_emptyc congr_arg_kind) has_emptyc.emptyc) : @totally_disconnected_space.{0} (has_emptyc.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_10041 (h0 : functor.add_const (filter (bin_tree empty)) empty) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_10042 (h0 : ordered_comm_monoid (boolean_algebra (has_add (has_neg_part environment.implicit_infer_kind)))) : has_exists_mul_of_le (boolean_algebra (has_add (has_neg_part environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_10043 (h0 : topological_space (sub_neg_monoid (sub_neg_monoid name))) : normal_space (sub_neg_monoid (sub_neg_monoid name)) := sorry --non-trivial
lemma new_lemma_10044 (h0 : topological_space (normed_comm_ring (boolean_algebra.core pos))) : preirreducible_space (normed_comm_ring (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_10045 (h0 : ring (random_gen (denumerable to_additive.value_type))) : rank_condition (random_gen (denumerable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_10046 (h0 : prod (finset (finset environment.implicit_infer_kind)) (finset (finset environment.implicit_infer_kind))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_10047 (h1 : uniform_space (add_comm_semigroup std_gen)) : complete_space (add_comm_semigroup std_gen) := sorry --non-trivial
lemma new_lemma_10048 (h0 : not (complete_lattice (topological_space fun_info) -> false)) : is_compactly_generated (topological_space fun_info) := sorry --non-trivial
lemma new_lemma_10049 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (linear_ordered_comm_monoid_with_zero.{0} num) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_10050 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_10051 (h0 : not (complete_lattice (uniform_space (mul_one_class string.iterator_imp)) -> false)) : complete_lattice.is_Sup_finite_compact (uniform_space (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_10052 (h0 : complete_lattice (ordered_comm_ring (has_add pos))) : is_atomistic (ordered_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_10053 (h0 : uniform_space (linear_ordered_cancel_add_comm_monoid fun_info)) : complete_space (linear_ordered_cancel_add_comm_monoid fun_info) := sorry --non-trivial
lemma new_lemma_10054 (h0 : functor.add_const (semiring (has_to_string name)) pos) : @is_noetherian_ring.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (has_to_string.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_10055 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_10056 (h0 : topological_space (comm_semigroup (has_Inf (has_add Type)))) : t1_space (comm_semigroup (has_Inf (has_add Type))) := sorry --non-trivial
lemma new_lemma_10057 (h0 : functor.add_const (ordered_add_comm_monoid (cancel_monoid pos)) name) : @archimedean.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (cancel_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_10058 (h0 h1 : multiset (uniform_space linarith.comp_source)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_10059 (h0 : functor.add_const (ring (left_cancel_semigroup congr_arg_kind)) num) : @strong_rank_condition.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_semigroup.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_10060 (h0 : has_zero (pseudo_metric_space ennreal) -> has_zero (pseudo_metric_space ennreal) -> Prop) : is_symm (has_zero (pseudo_metric_space ennreal)) h0 := sorry --non-trivial
lemma new_lemma_10061 (h4 : topological_space num) : totally_separated_space num := sorry --non-trivial
lemma new_lemma_10062 (h0 : add_group (monoid (option (option ennreal)))) : is_add_cyclic (monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_10063 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (preorder empty)) := sorry --non-trivial
lemma new_lemma_10064 (h0 : function.extfun (Type 1) (functor.comp ordered_add_comm_monoid has_nndist)) : @archimedean.{1} (has_nndist.{1} Type) (@functor.comp.run.{1 1 1} ordered_add_comm_monoid.{1} has_nndist.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} ordered_add_comm_monoid.{1} has_nndist.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_10065 (h0 : topological_space (canonically_ordered_add_monoid (option empty))) : discrete_topology (canonically_ordered_add_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_10066 (h0 : function.extfun Type ring) : @is_domain.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_10067 (h0 : topological_space (has_pos_part (has_Inf Type))) : normal_space (has_pos_part (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_10068 (h0 : monoid (boolean_algebra (has_Inf (has_Inf linarith.comp)))) : monoid.fg (boolean_algebra (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_10069 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @has_exists_mul_of_le.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ordered_comm_monoid.{1}) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_10070 (h0 : topological_space (normed_comm_ring empty)) : totally_separated_space (normed_comm_ring empty) := sorry --non-trivial
lemma new_lemma_10071 (h0 : topological_space (sub_neg_monoid (sub_neg_monoid real))) : preirreducible_space (sub_neg_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_10072 (h0 : finset (simple_graph (ring (has_add (ring Type))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_10073 (h0 : functor.add_const (group (cancel_monoid name)) linarith.comp) : @is_simple_group.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_10074 (h0 : topological_space (ring (option empty))) : preconnected_space (ring (option empty)) := sorry --non-trivial
lemma new_lemma_10075 (h0 : list (add_cancel_monoid (finset pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_10076 (h0 : topological_space (ordered_comm_monoid (has_Inf linarith.comp))) : path_connected_space (ordered_comm_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_10077 (h0 : functor.add_const (ring (add_comm_monoid Type)) name) : @is_principal_ideal_ring.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (add_comm_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_10078 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_10079 (h0 : topological_space (plift (semiring (semiring (semiring (semiring (semiring (semiring unsigned)))))))) : discrete_topology (plift (semiring (semiring (semiring (semiring (semiring (semiring unsigned))))))) := sorry --non-trivial
lemma new_lemma_10080 (h0 : list (semigroup (has_zero environment.implicit_infer_kind))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_10081 (h0 : functor.add_const (functor.add_const (topological_space Type) Type) pos) : @topological_space.separable_space.{1} Type (@functor.add_const.run.{1 1} (topological_space.{1} Type) Type (@functor.add_const.run.{1 0} (functor.add_const.{1 1} (topological_space.{1} Type) Type) pos h0))  := sorry --non-trivial
lemma new_lemma_10082 (h0 : has_mem.mem string_imp has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} string_imp (@finset.pi.empty.{1 0} Type complete_lattice.{0} string_imp h0)  := sorry --non-trivial
lemma new_lemma_10083 (h0 : functor.comp topological_space boolean_algebra Type) : @discrete_topology.{1} (boolean_algebra.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} boolean_algebra.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_10084 (h0 : topological_space (random_gen (has_norm linarith.comp))) : path_connected_space (random_gen (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_10085 (h0 : topological_space (add_left_cancel_monoid (random_gen linarith.ineq))) : totally_disconnected_space (add_left_cancel_monoid (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_10086 (h0 : ring (normed_group (encodable (has_nnnorm string_imp)))) : strong_rank_condition (normed_group (encodable (has_nnnorm string_imp))) := sorry --non-trivial
lemma new_lemma_10087 (h6 : Prop) : set.separates_points (id (fun (h0 : ereal -> ereal), h6)) := sorry --non-trivial
lemma new_lemma_10088 (h0 : not (has_mem.mem topological_space has_emptyc.emptyc -> false)) : @discrete_topology.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (linear_ordered_semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_10089 (h0 : topological_space (has_top (has_norm congr_arg_kind))) : totally_separated_space (has_top (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_10090 (h0 : topological_space (finset (normed_comm_ring (has_add environment.implicit_infer_kind)))) : t0_space (finset (normed_comm_ring (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_10091 (h0 : topological_space (has_add linarith.comp)) : preirreducible_space (has_add linarith.comp) := sorry --non-trivial
lemma new_lemma_10092 (h0 : function.extfun (Type 1) filter) : countable_Inter_filter (function.extfun_app h0 (simple_graph Type)) := sorry --non-trivial
lemma new_lemma_10093 (h0 : uniform_space (has_bot (has_Inf real))) : separated_space (has_bot (has_Inf real)) := sorry --non-trivial
lemma new_lemma_10094 (h0 : topological_space (cancel_monoid ennreal)) : preconnected_space (cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_10095 (h1 : not (group (normed_field (random_gen reducibility_hints)) -> false)) : @is_cyclic.{0} (normed_field.{0} (random_gen.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (group.{0} (normed_field.{0} (random_gen.{0} reducibility_hints))) h1)  := sorry --non-trivial
lemma new_lemma_10096 (h0 : topological_space (has_nndist (boolean_algebra.core pos))) : irreducible_space (has_nndist (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_10097 (h1 : function.extfun Type topological_space) : @path_connected_space.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_10098 (h0 : group (random_gen (has_nnnorm (random_gen fun_info)))) : group.fg (random_gen (has_nnnorm (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_10099 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) Type) : @discrete_topology.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_10100 (h0 : topological_space (has_nndist (comm_group unsigned))) : regular_space (has_nndist (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_10101 (h0 : topological_space (encodable (has_nnnorm (random_gen linarith.comp_source)))) : totally_disconnected_space (encodable (has_nnnorm (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_10102 (h0 : functor.add_const (complete_lattice (bin_tree num)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (bin_tree.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_10103 (h1 : uniform_space (add_comm_semigroup string.iterator_imp)) : complete_space (add_comm_semigroup string.iterator_imp) := sorry --non-trivial
lemma new_lemma_10104 (h0 : complete_lattice (linear_ordered_add_comm_group (has_inv (random_gen linarith.comp_source)))) : is_compactly_generated (linear_ordered_add_comm_group (has_inv (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_10105 (h0 : topological_space (normed_lattice_add_comm_group (finset linarith.comp))) : discrete_topology (normed_lattice_add_comm_group (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_10106 (h0 : functor.add_const (ring (has_add Type)) (ring pos)) : @strong_rank_condition.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_add.{1} Type)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_10107 (h0 : not (ring (has_compl reducibility_hints) -> false)) : @strong_rank_condition.{0} (has_compl.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_10108 (h0 : ordered_add_comm_monoid (add_cancel_monoid (option (option (option (option (option empty))))))) : archimedean (add_cancel_monoid (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_10109 (h0 : function.extfun Type complete_lattice) : is_atomistic (measurable_space (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_10110 (h0 : topological_space (has_top (random_gen (random_gen string_imp)))) : t0_space (has_top (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_10111 (h0 : uniform_space (canonically_ordered_monoid (has_add (has_add (has_add linarith.comp))))) : separated_space (canonically_ordered_monoid (has_add (has_add (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_10112 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (semilattice_inf empty)) := sorry --non-trivial
lemma new_lemma_10113 (h0 : not (function.extfun Type ring -> false)) : @is_principal_ideal_ring.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_10114 (h0 : ring (normed_group char)) : is_domain (normed_group char) := sorry --non-trivial
lemma new_lemma_10115 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) name) : @preconnected_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_10116 (h0 : finset (semigroup (ring (ring linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_10117 (h0 : uniform_space (comm_group pos)) : separated_space (comm_group pos) := sorry --non-trivial
lemma new_lemma_10118 (h0 : functor.add_const (add_monoid (add_comm_monoid name)) unsigned) : @add_monoid.fg.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (add_comm_monoid.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_10119 (h0 : topological_space (has_union (has_norm num))) : t0_space (has_union (has_norm num)) := sorry --non-trivial
lemma new_lemma_10120 (h0 : functor.add_const (group (has_add pos)) linarith.comp) : @normalizer_condition.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_10121 (h0 : group (with_bot (has_top (has_top num)))) : normalizer_condition (with_bot (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_10122 (h0 : functor.add_const (function.extfun Type add_monoid) pos) : @add_monoid.fg.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) pos h0) (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_10123 (h0 : semiring (has_sub (has_norm empty))) : is_noetherian_ring (has_sub (has_norm empty)) := sorry --non-trivial
lemma new_lemma_10124 (h0 : topological_space (normed_field string_imp)) (h1 : preorder (normed_field string_imp)) : order_closed_topology (normed_field string_imp) := sorry --non-trivial
lemma new_lemma_10125 (h0 : list (has_star (option (option unsigned)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_10126 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_10127 (h0 : topological_space (distrib (mul_one_class linarith.ineq))) : t0_space (distrib (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_10128 (h0 : functor.add_const (monoid (comm_group pos)) linarith.comp) : @monoid.fg.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (comm_group.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_10129 (h0 : functor.add_const (topological_space (has_add Type)) (finset linarith.comp)) : @normal_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_10130 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (pseudo_metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_10131 (h0 : topological_space (mul_zero_class environment.implicit_infer_kind)) : locally_compact_space (mul_zero_class environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_10132 (h0 : fin has_zero.zero) : @rank_condition.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_10133 (h0 : functor.add_const (topological_space (finset pos)) (has_neg pos)) : @t0_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_10134 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @rank_condition.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_10135 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_10136 (h0 : not (cancel_comm_monoid_with_zero (linear_ordered_comm_ring empty) -> false)) : @unique_factorization_monoid.{0} (linear_ordered_comm_ring.{0} empty) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (linear_ordered_comm_ring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_10137 (h0 : not (uniform_space (encodable fun_info) -> false)) : @complete_space.{0} (encodable.{0} fun_info) (@classical.by_contradiction'.{1} (uniform_space.{0} (encodable.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_10138 (h0 : functor.comp topological_space add_comm_monoid unsigned) : @t0_space.{0} (add_comm_monoid.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_10139 (h1 : topological_space (has_div linarith.ineq)) : path_connected_space (has_div linarith.ineq) := sorry --non-trivial
lemma new_lemma_10140 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (boolean_algebra.core.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} num))  := sorry --non-trivial
lemma new_lemma_10141 (h0 : functor.add_const (topological_space (add_cancel_monoid empty)) num) : @t0_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_10142 (h0 : functor.add_const (finset (normed_comm_ring linarith.comp)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_10143 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @t0_space.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_10144 (h0 : not (ring (add_monoid to_additive.value_type) -> false)) : @is_domain.{0} (add_monoid.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (add_monoid.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_10145 (h0 : function.extfun Type topological_space) : @t1_space.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_10146 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @normal_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_10147 (h1 : group (has_top linarith.comp_source)) : normalizer_condition (has_top linarith.comp_source) := sorry --non-trivial
lemma new_lemma_10148 (h0 : finset (normed_linear_ordered_group (semiring (semiring (semiring empty))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_10149 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (complete_distrib_lattice.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (complete_distrib_lattice.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_10150 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_10151 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) name) : @totally_disconnected_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_10152 (h0 : function.extfun Type (functor.add_const (function.extfun Type group))) : @is_simple_group.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type group.{0})) h0 pos)) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_10153 (h0 : topological_space (omega_complete_partial_order num)) : irreducible_space (omega_complete_partial_order num) := sorry --non-trivial
lemma new_lemma_10154 (h5 : ring (add_comm_semigroup enat)) : rank_condition (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_10155 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} unsigned (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) unsigned)  := sorry --non-trivial
lemma new_lemma_10156 (h0 : functor.add_const (topological_space (ring Type)) (ring pos)) : @totally_disconnected_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_10157 (h0 : function.extfun Type complete_lattice) : is_atomistic (measurable_space empty) := sorry --non-trivial
lemma new_lemma_10158 (h0 : ring (has_Inf (has_add (has_add linarith.comp)))) : strong_rank_condition (has_Inf (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_10159 (h0 : topological_space (simple_graph enat)) (h1 : add_group (simple_graph enat)) : topological_add_group (simple_graph enat) := sorry --non-trivial
lemma new_lemma_10160 (h0 : function.extfun Type ring) : @rank_condition.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_10161 (h0 : monoid (with_bot (with_one linarith.ineq))) : monoid.fg (with_bot (with_one linarith.ineq)) := sorry --non-trivial
lemma new_lemma_10162 (h0 : functor.add_const (group (has_to_string Type)) pos) : @is_simple_group.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_to_string.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_10163 (h0 : functor.add_const (finset (bin_tree congr_arg_kind)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_10164 (h0 : topological_space (finset (has_to_string name))) : topological_space.separable_space (finset (has_to_string name)) := sorry --non-trivial
lemma new_lemma_10165 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_10166 (h0 : functor.add_const (topological_space (has_Inf pos)) (ring Type)) : @sequential_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} pos)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_10167 (h0 : fin has_zero.zero) : @complete_space.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (ordered_comm_ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_10168 (h0 : group (random_gen (has_top linarith.ineq))) : normalizer_condition (random_gen (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_10169 (h0 : filter (semigroup Type)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_10170 (h0 : topological_space (nondiscrete_normed_field (normed_group char))) : t0_space (nondiscrete_normed_field (normed_group char)) := sorry --non-trivial
lemma new_lemma_10171 (h0 : topological_space (add_cancel_monoid (option num))) : preirreducible_space (add_cancel_monoid (option num)) := sorry --non-trivial
lemma new_lemma_10172 (h0 : function.extfun Type ring) : @is_domain.{0} (has_neg.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg.{0} empty))  := sorry --non-trivial
lemma new_lemma_10173 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (linear_ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (linear_ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_10174 (h0 : has_mem.mem (has_one num) has_emptyc.emptyc) : @group.fg.{0} (has_one.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (has_one.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_10175 (h1 : ring (has_div string_imp)) : rank_condition (has_div string_imp) := sorry --non-trivial
lemma new_lemma_10176 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_10177 (h0 : functor.add_const (functor.add_const Prop (option empty)) empty) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_10178 (h0 : functor.add_const (function.extfun Type uniform_space) linarith.comp) : @separated_space.{0} pos (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) linarith.comp h0) pos)  := sorry --non-trivial
lemma new_lemma_10179 (h0 : complete_lattice (canonically_ordered_comm_semiring (has_pos_part linarith.comp))) : is_compactly_generated (canonically_ordered_comm_semiring (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_10180 (h0 : ring (has_append (has_ssubset fun_info))) : rank_condition (has_append (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_10181 (h0 : complete_lattice (has_sub congr_arg_kind)) : is_compactly_generated (has_sub congr_arg_kind) := sorry --non-trivial
lemma new_lemma_10182 (h0 : ring (mul_one_class linarith.ineq)) : is_domain (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_10183 (h0 : functor.add_const (finset (add_cancel_monoid unsigned)) (canonically_ordered_monoid Type)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_10184 (h0 : functor.add_const (topological_space (add_right_cancel_monoid unsigned)) (option empty)) : @t0_space.{0} (add_right_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_right_cancel_monoid.{0} unsigned)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_10185 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_10186 (h0 : topological_space (mul_zero_class name)) : t0_space (mul_zero_class name) := sorry --non-trivial
lemma new_lemma_10187 (h0 : ring (has_pos_part (has_add linarith.comp))) : is_principal_ideal_ring (has_pos_part (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_10188 (h0 : topological_space (semi_normed_comm_ring (has_ssubset (has_norm fun_info)))) : path_connected_space (semi_normed_comm_ring (has_ssubset (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_10189 (h0 : functor.add_const (functor.add_const (filter (has_to_string unsigned)) (has_neg_part linarith.comp)) linarith.comp) : filter.ne_bot (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_10190 (h0 : topological_space (has_Inf (has_neg (has_neg pos)))) : sequential_space (has_Inf (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_10191 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (normed_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_10192 (h0 : add_monoid (generalized_boolean_algebra (has_neg pos))) : add_monoid.fg (generalized_boolean_algebra (has_neg pos)) := sorry --non-trivial
lemma new_lemma_10193 (h0 : topological_space (has_one (has_norm empty))) : totally_disconnected_space (has_one (has_norm empty)) := sorry --non-trivial
lemma new_lemma_10194 (h0 : topological_space (semi_normed_ring (mul_one_class string.iterator_imp))) : totally_disconnected_space (semi_normed_ring (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_10195 (h0 : functor.add_const (topological_space (mul_zero_class num)) congr_arg_kind) : @topological_space.separable_space.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_10196 (h0 : group (encodable (random_gen linarith.ineq))) : is_cyclic (encodable (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_10197 (h1 : ring (has_compl (has_nnnorm linarith.comp_source))) : rank_condition (has_compl (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_10198 (h0 : functor.add_const (semiring (semigroup linarith.comp)) name) : @is_noetherian_ring.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (semigroup.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_10199 (h0 : function.extfun Type group) : @normalizer_condition.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_10200 (h2 : ring (add_left_cancel_monoid fun_info)) : rank_condition (add_left_cancel_monoid fun_info) := sorry --non-trivial
lemma new_lemma_10201 (h0 : functor.add_const (add_group (cancel_monoid unsigned)) name) : @is_add_cyclic.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (cancel_monoid.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_10202 (h0 : topological_space (semigroup (has_neg (add_cancel_monoid name)))) : t1_space (semigroup (has_neg (add_cancel_monoid name))) := sorry --non-trivial
lemma new_lemma_10203 (h0 : topological_space (pseudo_metric_space (option ennreal))) (h1 : group (pseudo_metric_space (option ennreal))) : topological_group (pseudo_metric_space (option ennreal)) := sorry --non-trivial
lemma new_lemma_10204 (h0 : functor.add_const (group (has_neg_part name)) Type) : @normalizer_condition.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 1} (group.{0} (has_neg_part.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_10205 (h0 : group (with_bot (has_top (has_top (has_top (has_top unsigned)))))) : is_cyclic (with_bot (has_top (has_top (has_top (has_top unsigned))))) := sorry --non-trivial
lemma new_lemma_10206 (h0 : add_monoid (random_gen (has_nnnorm char))) (h1 : not (random_gen (has_nnnorm char) -> false)) : is_add_unit (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_10207 (h0 : topological_space (add_cancel_monoid (finset pos))) : irreducible_space (add_cancel_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_10208 (h0 : functor.add_const (comm_ring (canonically_ordered_comm_semiring name)) Type) : @local_ring.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 1} (comm_ring.{0} (canonically_ordered_comm_semiring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_10209 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_10210 (h0 : topological_space (semigroup (has_to_string unsigned))) : t0_space (semigroup (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_10211 (h0 : functor.add_const (group (add_semigroup unsigned)) empty) : @normalizer_condition.{0} (add_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (add_semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_10212 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) name) : @loc_path_connected_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_10213 (h0 : topological_space (sub_neg_monoid (has_add pos))) : totally_disconnected_space (sub_neg_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_10214 (h0 : monoid (linear_ordered_comm_group ennreal)) : monoid.fg (linear_ordered_comm_group ennreal) := sorry --non-trivial
lemma new_lemma_10215 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (add_group.{0} fun_info) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (add_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_10216 (h0 : functor.add_const (complete_lattice (linear_ordered_comm_ring num)) num) : @is_compactly_generated.{0} (linear_ordered_comm_ring.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_ordered_comm_ring.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_10217 (h0 : functor.add_const (function.extfun Type uniform_space) (has_to_string Type)) : @separated_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) (has_to_string.{1} Type) h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_10218 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_10219 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (linear_ordered_cancel_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_cancel_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_10220 (h0 : complete_lattice (random_gen (has_nnnorm fun_info))) : complete_lattice.is_Sup_finite_compact (random_gen (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_10221 (h0 : monoid (normed_comm_ring (ring linarith.comp))) : monoid.fg (normed_comm_ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_10222 (h1 : complete_lattice (mul_one_class (mul_one_class (mul_one_class linarith.comp_source)))) : is_compactly_generated (mul_one_class (mul_one_class (mul_one_class linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_10223 (h0 : function.extfun Type topological_space) : @t1_space.{0} znum (@function.extfun_app.{2 1} Type topological_space.{0} h0 znum)  := sorry --non-trivial
lemma new_lemma_10224 (h0 : list (linear_ordered_comm_group unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_10225 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_10226 (h0 : complete_lattice (add_comm_monoid (option ennreal))) : is_atomistic (add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_10227 (h0 : complete_lattice (has_bot (has_neg (has_neg name)))) : is_compactly_generated (has_bot (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_10228 (h0 : topological_space (has_nnnorm char)) (h1 : not (preorder (has_nnnorm char) -> false)) : @order_topology.{0} (has_nnnorm.{0} char) h0 (@classical.by_contradiction'.{1} (preorder.{0} (has_nnnorm.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_10229 (h0 : topological_space (complete_semilattice_Sup (has_top (has_top num)))) : totally_separated_space (complete_semilattice_Sup (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_10230 (h0 : list (mul_zero_class num)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_10231 (h0 : ring (is_R_or_C (option (option unsigned)))) : strong_rank_condition (is_R_or_C (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_10232 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_inter.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_inter.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_10233 (h0 : not (topological_space (random_gen congr_arg_kind) -> false)) : @irreducible_space.{0} (random_gen.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_10234 (h0 : ring (has_neg_part (option pos))) : strong_rank_condition (has_neg_part (option pos)) := sorry --non-trivial
lemma new_lemma_10235 (h0 : topological_space (linear_ordered_semiring (random_gen num))) : totally_separated_space (linear_ordered_semiring (random_gen num)) := sorry --non-trivial
lemma new_lemma_10236 (h0 : functor.add_const (complete_lattice (boolean_algebra Type)) (ring Type)) : @is_compactly_generated.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (boolean_algebra.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_10237 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normal_space.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_10238 (h0 : finset (preorder congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_10239 (h0 : semiring (simple_graph (has_add (has_add (has_to_string linarith.comp))))) : is_noetherian_ring (simple_graph (has_add (has_add (has_to_string linarith.comp)))) := sorry --non-trivial
lemma new_lemma_10240 (h0 : ordered_comm_monoid (ordered_comm_monoid Type)) : has_exists_mul_of_le (ordered_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_10241 (h0 : function.extfun (finset Type) (has_mem.mem (semiring linarith.comp_source))) : @strong_rank_condition.{0} (semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_10242 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_10243 (h0 : functor.add_const (function.extfun (Type 1) ring) Type) : @strong_rank_condition.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) Type h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_10244 (h0 : topological_space (has_to_string (finset (finset (finset pos))))) : path_connected_space (has_to_string (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_10245 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) linarith.comp) : @t1_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_10246 (h0 : add_monoid (finset Type)) : add_monoid.fg (finset Type) := sorry --non-trivial
lemma new_lemma_10247 (h0 : functor.add_const (function.extfun Type list) pos) : palindrome (function.extfun_app (functor.add_const.run h0) (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_10248 (h0 : monoid (with_bot (semiring (semiring unsigned)))) : monoid.fg (with_bot (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_10249 (h0 : topological_space (monoid (option (option ennreal)))) : topological_space.separable_space (monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_10250 (h1 : ring (mul_one_class (mul_one_class (mul_one_class std_gen)))) : strong_rank_condition (mul_one_class (mul_one_class (mul_one_class std_gen))) := sorry --non-trivial
lemma new_lemma_10251 (h0 : functor.add_const (topological_space (has_neg_part pos)) environment.implicit_infer_kind) : @t1_space.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_10252 (h0 : ordered_add_comm_monoid (comm_group (finset (finset linarith.comp)))) : archimedean (comm_group (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_10253 (h0 : topological_space (canonically_ordered_monoid (has_neg name))) : locally_compact_space (canonically_ordered_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_10254 (h1 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_ssubset.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (has_ssubset.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_10255 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (canonically_ordered_monoid.{0} (finset.{0} pos)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} (finset.{0} pos)))  := sorry --non-trivial
lemma new_lemma_10256 (h0 : topological_space (has_nndist (has_zero Type))) : loc_path_connected_space (has_nndist (has_zero Type)) := sorry --non-trivial
lemma new_lemma_10257 (h0 : topological_space (has_Inf (has_add linarith.comp))) : path_connected_space (has_Inf (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_10258 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_10259 (h0 : fin has_zero.zero) : @group.fg.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) h0) (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_10260 (h0 : functor.add_const (list linarith.comp) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_10261 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_10262 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_10263 (h0 : functor.add_const (semiring (has_Inf linarith.comp)) (ring (finset pos))) : @is_noetherian_ring.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (has_Inf.{0} linarith.comp)) (ring.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_10264 (h0 : function.extfun Type topological_space) : @t1_space.{0} (mul_zero_class.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_10265 (h0 : semiring (with_bot (semiring (semiring unsigned)))) : is_noetherian_ring (with_bot (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_10266 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_zero pos)) := sorry --non-trivial
lemma new_lemma_10267 (h0 : topological_space (has_inv string_imp)) : totally_separated_space (has_inv string_imp) := sorry --non-trivial
lemma new_lemma_10268 (h0 h1 : function.extfun (has_norm num) (fun (x : has_norm num), Prop)) : set.subset (function.extfun_app h0) (function.extfun_app h1) := sorry --non-trivial
lemma new_lemma_10269 (h0 : functor.add_const (topological_space (has_add Type)) pos) : @irreducible_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_10270 (h0 : has_mem.mem (has_emptyc num) has_emptyc.emptyc) : @is_atomistic.{0} (has_emptyc.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_emptyc.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_10271 (h0 : ring (has_edist empty)) : rank_condition (has_edist empty) := sorry --non-trivial
lemma new_lemma_10272 (h0 : ring (measurable_space.dynkin_system unsigned)) : rank_condition (measurable_space.dynkin_system unsigned) := sorry --non-trivial
lemma new_lemma_10273 (h0 : add_group (random_gen (has_norm congr_arg_kind))) : is_add_cyclic (random_gen (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_10274 (h0 : topological_space (has_ssubset (has_ssubset (has_inv fun_info)))) : t0_space (has_ssubset (has_ssubset (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_10275 (h0 : complete_lattice (has_ssubset (has_nnnorm fun_info))) : complete_lattice.is_Sup_finite_compact (has_ssubset (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_10276 (h0 : not (ring (has_compl linarith.comp_source) -> false)) : @rank_condition.{0} (has_compl.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_10277 (h0 : functor.add_const (filter (finset name)) (boolean_algebra Type)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_10278 (h0 : complete_lattice (monoid_with_zero num)) : complete_lattice.is_Sup_finite_compact (monoid_with_zero num) := sorry --non-trivial
lemma new_lemma_10279 (h0 : filter (semigroup (comm_group (comm_group (comm_group (comm_group unsigned)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_10280 (h0 : not (ring (simple_graph linarith.ineq) -> false)) : @rank_condition.{0} (simple_graph.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (simple_graph.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_10281 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) pos) : @loc_path_connected_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_10282 (h0 h1 : multiset (add_comm_semigroup enat)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_10283 (h0 : ring (has_add (boolean_algebra Type))) : is_domain (has_add (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_10284 (h0 : ring (normed_group unsigned)) : is_domain (normed_group unsigned) := sorry --non-trivial
lemma new_lemma_10285 (h0 : std_gen -> std_gen) (h1 h2 : std_gen -> Prop) (h3 : std_gen) : function.extend h0 h1 h2 h3 := sorry --non-trivial
lemma new_lemma_10286 (h0 : topological_space (canonically_ordered_monoid Type)) : preirreducible_space (canonically_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_10287 (h0 : complete_lattice (linear_ordered_field (option (option unsigned)))) : is_atomistic (linear_ordered_field (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_10288 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (denumerable.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (denumerable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_10289 (h0 : topological_space (has_nndist (has_nndist name))) : preirreducible_space (has_nndist (has_nndist name)) := sorry --non-trivial
lemma new_lemma_10290 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_sub.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_sub.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_10291 (h0 : function.extfun Type topological_space) : sequential_space real := sorry --non-trivial
lemma new_lemma_10292 (h0 : topological_space (has_neg (has_pos_part (has_Inf pos)))) : normal_space (has_neg (has_pos_part (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_10293 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_10294 (h0 : group (dlist (random_gen (has_nnnorm fun_info)))) : group.fg (dlist (random_gen (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_10295 (h0 : function.extfun Type ring) : @is_domain.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_10296 (h0 : topological_space (mul_zero_class (finset ennreal))) : preirreducible_space (mul_zero_class (finset ennreal)) := sorry --non-trivial
lemma new_lemma_10297 (h0 : preorder ordering) (h1 : pred_order ordering) : is_pred_archimedean ordering := sorry --non-trivial
lemma new_lemma_10298 (h0 : finset (left_cancel_monoid num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_10299 (h0 : function.extfun Type topological_space) : @t0_space.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_10300 (h0 : measurable_space char) (h1 : has_add char) (h2 : measure_theory.measure char) : measure_theory.measure.is_add_left_invariant h2 := sorry --non-trivial
lemma new_lemma_10301 (h0 : topological_space (normed_group (random_gen (random_gen (random_gen linarith.comp_source))))) : totally_separated_space (normed_group (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_10302 (h1 : ring (with_one (random_gen string_imp))) : rank_condition (with_one (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_10303 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) environment.implicit_infer_kind) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_10304 (h0 : functor.add_const (semiring (has_nndist unsigned)) name) : @is_noetherian_ring.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (has_nndist.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_10305 (h0 : complete_lattice nnreal) : complete_lattice.is_Sup_finite_compact nnreal := sorry --non-trivial
lemma new_lemma_10306 (h0 : function.extfun (Type 1) uniform_space) : @complete_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_10307 (h0 : has_coe (cancel_monoid (mul_one_class linarith.ineq)) Prop) (h1 : cancel_monoid (mul_one_class linarith.ineq)) : @coe_b.{1 1} (cancel_monoid.{0} (mul_one_class.{0} linarith.ineq)) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_10308 (h1 : function.extfun Type group) : @normalizer_condition.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h1 (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_10309 (h0 : ordered_add_comm_monoid (cancel_monoid (option pos))) : archimedean (cancel_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_10310 (h0 : ring (has_div fun_info)) : strong_rank_condition (has_div fun_info) := sorry --non-trivial
lemma new_lemma_10311 (h0 : not (ring (has_ssubset (random_gen reducibility_hints)) -> false)) : @is_domain.{0} (has_ssubset.{0} (random_gen.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} (random_gen.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_10312 (h0 : functor.add_const (complete_lattice (boolean_algebra.core Type)) name) : @is_atomistic.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (boolean_algebra.core.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_10313 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_10314 (h0 : add_group (linear_ordered_comm_group_with_zero (mul_one_class string.iterator_imp))) : is_add_cyclic (linear_ordered_comm_group_with_zero (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_10315 (h0 : add_group (sub_neg_monoid (finset linarith.comp))) : is_add_cyclic (sub_neg_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_10316 (h0 : list (boolean_algebra.core (option (option pos)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_10317 (h0 : finset (ring (finset pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_10318 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_10319 (h0 : not (functor.comp topological_space has_ssubset string_imp -> false)) : @path_connected_space.{0} (has_ssubset.{0} string_imp) (@functor.comp.run.{0 0 0} topological_space.{0} has_ssubset.{0} string_imp (@classical.by_contradiction'.{1} (functor.comp.{0 0 0} topological_space.{0} has_ssubset.{0} string_imp) h0))  := sorry --non-trivial
lemma new_lemma_10320 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_10321 (h0 : topological_space (canonically_linear_ordered_monoid empty)) : discrete_topology (canonically_linear_ordered_monoid empty) := sorry --non-trivial
lemma new_lemma_10322 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (sub_neg_monoid.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (sub_neg_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_10323 (h0 : functor.add_const (topological_space (cancel_monoid name)) linarith.comp) : @sequential_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_10324 (h0 : topological_space (has_pos_part (has_Inf (has_Inf (has_Inf (has_Inf pos)))))) : irreducible_space (has_pos_part (has_Inf (has_Inf (has_Inf (has_Inf pos))))) := sorry --non-trivial
lemma new_lemma_10325 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_10326 (h0 : group (linear_ordered_comm_ring (semiring empty))) : group.fg (linear_ordered_comm_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_10327 (h0 h1 : multiset (nondiscrete_normed_field (mul_one_class environment.projection_info))) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_10328 (h0 : add_monoid (measurable_space (complete_semilattice_Sup linarith.comp))) : add_monoid.fg (measurable_space (complete_semilattice_Sup linarith.comp)) := sorry --non-trivial
lemma new_lemma_10329 (h0 : topological_space (has_neg_part (has_neg name))) : totally_separated_space (has_neg_part (has_neg name)) := sorry --non-trivial
lemma new_lemma_10330 (h0 : functor.add_const (uniform_space (semigroup environment.implicit_infer_kind)) environment.implicit_infer_kind) : @separated_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_10331 (h0 : ring (normed_linear_ordered_group (semiring (semiring num)))) : strong_rank_condition (normed_linear_ordered_group (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_10332 (h0 : topological_space (normed_comm_ring (has_neg (finset linarith.comp)))) : regular_space (normed_comm_ring (has_neg (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_10333 (h0 : not (ring (has_one congr_arg_kind) -> false)) : @strong_rank_condition.{0} (has_one.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (has_one.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_10334 (h1 : not (group (random_gen char) -> false)) : @is_cyclic.{0} (random_gen.{0} char) (@classical.by_contradiction'.{1} (group.{0} (random_gen.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_10335 (h0 : complete_lattice (has_nndist (add_group_with_zero_nhd ennreal))) : complete_lattice.is_Sup_finite_compact (has_nndist (add_group_with_zero_nhd ennreal)) := sorry --non-trivial
lemma new_lemma_10336 (h0 : uniform_space (canonically_ordered_comm_semiring (has_to_string name))) : separated_space (canonically_ordered_comm_semiring (has_to_string name)) := sorry --non-trivial
lemma new_lemma_10337 (h0 : topological_space (cancel_monoid (option num))) : normal_space (cancel_monoid (option num)) := sorry --non-trivial
lemma new_lemma_10338 (h0 : has_to_string unsigned -> has_to_string unsigned -> Prop) : is_symm (has_to_string unsigned) h0 := sorry --non-trivial
lemma new_lemma_10339 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) name) : @totally_disconnected_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_10340 (h1 : topological_space (measurable_space linarith.comp_source)) : irreducible_space (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_10341 (h0 : add_group (has_add unsigned)) : is_add_cyclic (has_add unsigned) := sorry --non-trivial
lemma new_lemma_10342 (h0 : group (has_to_string (has_neg (has_neg Type)))) : is_simple_group (has_to_string (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_10343 (h0 : function.extfun Type (functor.add_const (ring linarith.comp))) : @is_domain.{0} linarith.comp (@functor.add_const.run.{0 0} (ring.{0} linarith.comp) name (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} linarith.comp)) h0 name))  := sorry --non-trivial
lemma new_lemma_10344 (h0 : function.extfun Type group) : @normalizer_condition.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_10345 (h0 : prod (has_top (semiring empty)) (has_top (semiring empty))) : set.diagonal (has_top (semiring empty)) h0 := sorry --non-trivial
lemma new_lemma_10346 (h0 : topological_space (normed_group (with_one congr_arg_kind))) : irreducible_space (normed_group (with_one congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_10347 (h0 : topological_space (ring (has_add Type))) : locally_compact_space (ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_10348 (h0 : uniform_space ereal -> Prop) (h1 : Exists (fun (x : uniform_space ereal), h0 x)) : @complete_space.{0} ereal (@classical.some.{1} (uniform_space.{0} ereal) h0 h1)  := sorry --non-trivial
lemma new_lemma_10349 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} pos (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) pos)  := sorry --non-trivial
lemma new_lemma_10350 (h0 : functor.add_const (topological_space (measure_theory.measure_space congr_arg_kind)) num) : @locally_compact_space.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (measure_theory.measure_space.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_10351 (h0 : topological_space (boolean_algebra (normed_comm_ring environment.implicit_infer_kind))) : totally_separated_space (boolean_algebra (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_10352 (h0 : functor.add_const (topological_space (cancel_monoid pos)) environment.implicit_infer_kind) : @totally_disconnected_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_10353 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_10354 (h0 : topological_space (has_to_string (has_to_string unsigned))) : topological_space.separable_space (has_to_string (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_10355 (h0 : ring (id (linear_ordered_semiring (random_gen (random_gen linarith.ineq))))) : is_domain (id (linear_ordered_semiring (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_10356 (h0 : topological_space (has_le (mul_one_class (has_compl enat)))) : totally_disconnected_space (has_le (mul_one_class (has_compl enat))) := sorry --non-trivial
lemma new_lemma_10357 (h0 : functor.add_const (functor.add_const (uniform_space (bin_tree num)) num) congr_arg_kind) : @complete_space.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (bin_tree.{0} num)) num (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (uniform_space.{0} (bin_tree.{0} num)) num) congr_arg_kind h0))  := sorry --non-trivial
lemma new_lemma_10358 (h0 : group (topological_space to_additive.value_type)) : is_cyclic (topological_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_10359 (h0 : not (uniform_space (with_zero (has_nnnorm (has_nnnorm linarith.comp_source))) -> false)) : @complete_space.{0} (with_zero.{0} (has_nnnorm.{0} (has_nnnorm.{0} linarith.comp_source))) (@classical.by_contradiction'.{1} (uniform_space.{0} (with_zero.{0} (has_nnnorm.{0} (has_nnnorm.{0} linarith.comp_source)))) h0)  := sorry --non-trivial
lemma new_lemma_10360 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_10361 (h0 : group (has_to_string (has_add (has_add linarith.comp)))) : is_simple_group (has_to_string (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_10362 (h0 : list (has_add (has_add Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_10363 (h2 : set (char -> enat)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_10364 (h0 : comm_monoid_with_zero (add_cancel_monoid (option (option unsigned)))) : wf_dvd_monoid (add_cancel_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_10365 (h0 : functor.add_const (function.extfun Type add_monoid) environment.implicit_infer_kind) : @add_monoid.fg.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) environment.implicit_infer_kind h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_10366 (h0 : topological_space (has_dist ennreal)) : t0_space (has_dist ennreal) := sorry --non-trivial
lemma new_lemma_10367 (h0 : cancel_comm_monoid_with_zero (boolean_algebra.core num)) : unique_factorization_monoid (boolean_algebra.core num) := sorry --non-trivial
lemma new_lemma_10368 (h0 : functor.add_const (ring (semigroup linarith.comp)) (mul_one_class linarith.comp)) : @strong_rank_condition.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} linarith.comp)) (mul_one_class.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_10369 (h0 : functor.comp ring finset name) : @is_principal_ideal_ring.{0} (finset.{0} name) (@functor.comp.run.{0 0 0} ring.{0} finset.{0} name h0)  := sorry --non-trivial
lemma new_lemma_10370 (h0 : topological_space (has_nndist (option empty))) : irreducible_space (has_nndist (option empty)) := sorry --non-trivial
lemma new_lemma_10371 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_10372 (h1 : has_mem.mem topological_space has_emptyc.emptyc) : @irreducible_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h1) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_10373 (h0 : cancel_comm_monoid_with_zero (has_to_string (has_add (has_neg (has_neg Type))))) : unique_factorization_monoid (has_to_string (has_add (has_neg (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_10374 (h0 : functor.add_const (uniform_space (finset Type)) (ring (has_neg Type))) : @separated_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (finset.{1} Type)) (ring.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_10375 (h0 : function.extfun (Type 1) (functor.comp topological_space has_add)) : @t1_space.{1} (has_add.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_add.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} has_add.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_10376 (h0 : functor.add_const (add_monoid (ring Type)) linarith.comp) : @add_monoid.fg.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_10377 (h0 : functor.add_const (topological_space (has_add name)) (has_neg (has_neg name))) : @t0_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) (has_neg.{0} (has_neg.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_10378 (h0 : functor.add_const (topological_space (has_nndist name)) Type) : @loc_path_connected_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_10379 (h0 : topological_space (has_zero (complete_distrib_lattice (boolean_algebra name)))) : irreducible_space (has_zero (complete_distrib_lattice (boolean_algebra name))) := sorry --non-trivial
lemma new_lemma_10380 (h1 : not (ring (distrib_lattice linarith.ineq) -> false)) : @is_domain.{0} (distrib_lattice.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (distrib_lattice.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_10381 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (complete_linear_order.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_10382 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @irreducible_space.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_10383 (h0 : functor.add_const (function.extfun (Type 1) add_group) Type) : @is_add_cyclic.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) add_group.{1}) Type h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_10384 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (complete_distrib_lattice.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_10385 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) name) : @regular_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_10386 (h0 : functor.add_const (ordered_add_comm_monoid (has_add unsigned)) (has_add Type)) : @archimedean.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_add.{0} unsigned)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_10387 (h0 : not (topological_space (has_compl enat) -> false)) : @t0_space.{0} (has_compl.{0} enat) (@classical.by_contradiction'.{1} (topological_space.{0} (has_compl.{0} enat)) h0)  := sorry --non-trivial
lemma new_lemma_10388 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_10389 (h1 : ring (random_gen (comm_ring (comm_ring char)))) : is_domain (random_gen (comm_ring (comm_ring char))) := sorry --non-trivial
lemma new_lemma_10390 (h0 : topological_space (mul_zero_class pos)) : regular_space (mul_zero_class pos) := sorry --non-trivial
lemma new_lemma_10391 (h0 : cancel_comm_monoid_with_zero (ordered_comm_ring (has_Inf (has_Inf pos)))) : unique_factorization_monoid (ordered_comm_ring (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_10392 (h0 : not (complete_lattice (has_emptyc linarith.ineq) -> false)) : @is_compactly_generated.{0} (has_emptyc.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_emptyc.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_10393 (h0 : monoid (denumerable to_additive.value_type)) : monoid.fg (denumerable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_10394 (h1 : group (with_bot (with_bot string_imp))) : normalizer_condition (with_bot (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_10395 (h0 : ring (canonically_ordered_monoid (has_Inf real))) : strong_rank_condition (canonically_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_10396 (h0 : complete_lattice (ordered_comm_ring empty)) : is_compactly_generated (ordered_comm_ring empty) := sorry --non-trivial
lemma new_lemma_10397 (h0 : functor.comp group has_zero pos) : @group.fg.{0} (has_zero.{0} pos) (@functor.comp.run.{0 0 0} group.{0} has_zero.{0} pos (@functor.comp.run.{0 0 0} group.{0} has_zero.{0} pos h0))  := sorry --non-trivial
lemma new_lemma_10398 (h0 : functor.add_const (ring (finset Type)) linarith.comp) : @is_domain.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (finset.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_10399 (h0 : topological_space (boolean_algebra (comm_group (has_add unsigned)))) : loc_path_connected_space (boolean_algebra (comm_group (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_10400 (h0 : monoid (linear_ordered_add_comm_group (random_gen fun_info))) : monoid.fg (linear_ordered_add_comm_group (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_10401 (h0 : functor.add_const (functor.add_const (finset linarith.comp) pos) pos) : finset.nonempty (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_10402 (h0 : ordered_add_comm_monoid (has_add (option unsigned))) : archimedean (has_add (option unsigned)) := sorry --non-trivial
lemma new_lemma_10403 (h0 : functor.add_const (topological_space (non_assoc_semiring unsigned)) unsigned) : @t0_space.{0} (non_assoc_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_10404 (h2 : complete_lattice (has_top (random_gen fun_info))) : is_atomistic (has_top (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_10405 (h0 : semiring (normed_comm_ring (ring (has_neg environment.implicit_infer_kind)))) : is_noetherian_ring (normed_comm_ring (ring (has_neg environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_10406 (h0 : list (normed_group (random_gen (random_gen to_additive.value_type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_10407 (h0 : function.extfun Type (functor.comp list cancel_monoid)) : list.nodup (functor.comp.run (function.extfun_app h0 unsigned)) := sorry --non-trivial
lemma new_lemma_10408 (h0 : functor.add_const (list (ring environment.implicit_infer_kind)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_10409 (h0 : group (finset Type)) : is_simple_group (finset Type) := sorry --non-trivial
lemma new_lemma_10410 (h0 : ring (has_inv (has_norm (semiring fun_info)))) : strong_rank_condition (has_inv (has_norm (semiring fun_info))) := sorry --non-trivial
lemma new_lemma_10411 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_10412 (h0 : topological_space (with_bot (has_inv (random_gen (comm_ring to_additive.value_type))))) : path_connected_space (with_bot (has_inv (random_gen (comm_ring to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_10413 (h0 : functor.add_const (uniform_space (complete_distrib_lattice pos)) linarith.comp) : @separated_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (complete_distrib_lattice.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_10414 (h0 : topological_space (ordered_comm_ring (has_neg pos))) : locally_compact_space (ordered_comm_ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_10415 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (dlist string_imp)) := sorry --non-trivial
lemma new_lemma_10416 (h0 : group (comm_group (option (option (option (option unsigned)))))) : is_cyclic (comm_group (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_10417 (h0 : complete_lattice (ordered_cancel_add_comm_monoid unsigned)) : is_compactly_generated (ordered_cancel_add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_10418 (h0 : functor.add_const (monoid (boolean_algebra Type)) pos) : @monoid.fg.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_10419 (h1 : topological_space (semiring (random_gen to_additive.value_type))) : locally_compact_space (semiring (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_10420 (h0 : functor.add_const (topological_space (has_neg pos)) (has_neg pos)) : @totally_disconnected_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_10421 (h0 : finset (simple_graph (ring (ring (finset linarith.comp))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_10422 (h0 : topological_space (boolean_algebra (has_pos_part pos))) : totally_separated_space (boolean_algebra (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_10423 (h0 : functor.add_const (topological_space (finset name)) name) : @preirreducible_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_10424 (h0 : group (has_zero (has_nndist environment.implicit_infer_kind))) : normalizer_condition (has_zero (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_10425 (h0 : monoid (boolean_algebra unsigned)) : monoid.fg (boolean_algebra unsigned) := sorry --non-trivial
lemma new_lemma_10426 (h2 : topological_space (distrib_lattice fun_info)) : path_connected_space (distrib_lattice fun_info) := sorry --non-trivial
lemma new_lemma_10427 (h0 : list (left_cancel_monoid unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_10428 (h0 : complete_lattice (measurable_space.dynkin_system num)) : is_compactly_generated (measurable_space.dynkin_system num) := sorry --non-trivial
lemma new_lemma_10429 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_10430 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (semi_normed_comm_ring.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semi_normed_comm_ring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_10431 (h0 : topological_space (complete_linear_order (semiring unsigned))) : normal_space (complete_linear_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_10432 (h3 : complete_lattice (add_cancel_comm_monoid char)) : complete_lattice.is_Sup_finite_compact (add_cancel_comm_monoid char) := sorry --non-trivial
lemma new_lemma_10433 (h1 : complete_lattice (comm_ring (metric_space to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (comm_ring (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_10434 (h0 : filter (has_well_founded (dlist linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_10435 (h0 : topological_space (has_add (has_Inf (has_add linarith.comp)))) : totally_separated_space (has_add (has_Inf (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_10436 (h0 : measurable_space (has_neg_part (add_cancel_monoid name))) (h1 : has_add (has_neg_part (add_cancel_monoid name))) : has_measurable_add (has_neg_part (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_10437 (h0 : add_monoid (has_to_string (finset (has_Inf linarith.comp)))) : add_monoid.fg (has_to_string (finset (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_10438 (h0 : functor.add_const (ordered_add_comm_monoid (has_add name)) name) : @archimedean.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_add.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_10439 (h0 : topological_space (has_nndist name)) : t0_space (has_nndist name) := sorry --non-trivial
lemma new_lemma_10440 (h0 : complete_lattice (fintype (semigroup (random_gen to_additive.value_type)))) : is_compactly_generated (fintype (semigroup (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_10441 (h0 : function.extfun Type (prod (canonically_linear_ordered_monoid name))) : id_rel (function.extfun_app h0 (canonically_linear_ordered_monoid name)) := sorry --non-trivial
lemma new_lemma_10442 (h0 : topological_space (boolean_algebra linarith.comp)) : totally_disconnected_space (boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_10443 (h0 : ring (random_gen (normed_field (random_gen (comm_ring reducibility_hints))))) : is_domain (random_gen (normed_field (random_gen (comm_ring reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_10444 (h0 : cancel_comm_monoid_with_zero (has_zero (has_nndist pos))) : unique_factorization_monoid (has_zero (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_10445 (h0 : group (with_one linarith.comp)) : normalizer_condition (with_one linarith.comp) := sorry --non-trivial
lemma new_lemma_10446 (h0 : uniform_space (has_pos_part (ring pos))) : complete_space (has_pos_part (ring pos)) := sorry --non-trivial
lemma new_lemma_10447 (h0 : functor.add_const (ordered_add_comm_monoid (has_Inf pos)) pos) : @archimedean.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_Inf.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_10448 (h0 : group (normed_group (random_gen (random_gen (has_inv linarith.comp_source))))) : is_cyclic (normed_group (random_gen (random_gen (has_inv linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_10449 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_10450 (h0 : add_group (has_ssubset (has_ssubset string_imp))) : is_add_cyclic (has_ssubset (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_10451 (h0 : uniform_space (semiring (has_top (semiring (semiring (semiring empty)))))) : complete_space (semiring (has_top (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_10452 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_10453 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_10454 (h0 : add_monoid (has_zero (has_add environment.implicit_infer_kind))) : add_monoid.fg (has_zero (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_10455 (h0 : ring (with_one (has_ssubset (has_top (random_gen to_additive.value_type))))) : is_domain (with_one (has_ssubset (has_top (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_10456 (h0 : not (ring (distrib_lattice fun_info) -> false)) : @rank_condition.{0} (distrib_lattice.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (distrib_lattice.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_10457 (h0 : functor.comp topological_space semigroup name) : @t1_space.{0} (semigroup.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} name h0)  := sorry --non-trivial
lemma new_lemma_10458 (h0 : Type -> Type -> Prop) : well_founded h0 := sorry --non-trivial
lemma new_lemma_10459 (h1 : preorder (mul_one_class std_gen)) (h2 : set (mul_one_class std_gen)) : set.is_pwo h2 := sorry --non-trivial
lemma new_lemma_10460 (h0 : functor.add_const (list (has_to_string linarith.comp)) (has_to_string (ring linarith.comp))) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_10461 (h0 : topological_space (mul_zero_class (has_to_string ennreal))) : path_connected_space (mul_zero_class (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_10462 (h0 : add_group (non_assoc_semiring (semiring congr_arg_kind))) : is_add_cyclic (non_assoc_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_10463 (h0 : topological_space (with_zero (has_ssubset string_imp))) : path_connected_space (with_zero (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_10464 (h0 : list (has_zero (add_comm_monoid (has_to_string Type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_10465 (h0 : prod (finset (has_add name)) (finset (has_add name))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_10466 (h0 : function.extfun Type (functor.add_const (group (has_nndist ennreal)))) : @is_simple_group.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} ennreal)) ennreal (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (has_nndist.{0} ennreal))) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_10467 (h0 : ring (linear_ordered_field (option num))) : is_principal_ideal_ring (linear_ordered_field (option num)) := sorry --non-trivial
lemma new_lemma_10468 (h3 : topological_space std_gen) : t0_space std_gen := sorry --non-trivial
lemma new_lemma_10469 (h0 : uniform_space (linear_ordered_semiring (random_gen linarith.ineq))) : separated_space (linear_ordered_semiring (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_10470 (h0 : topological_space (simple_graph (ring (has_pos_part (has_pos_part (ring linarith.comp)))))) : regular_space (simple_graph (ring (has_pos_part (has_pos_part (ring linarith.comp))))) := sorry --non-trivial
lemma new_lemma_10471 (h0 : topological_space (linear_order (option unsigned))) : locally_compact_space (linear_order (option unsigned)) := sorry --non-trivial
lemma new_lemma_10472 (h0 : filter (has_to_string environment.implicit_infer_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_10473 (h1 : ring (random_gen char)) : rank_condition (random_gen char) := sorry --non-trivial
lemma new_lemma_10474 (h0 : functor.add_const (ring (finset linarith.comp)) (normed_comm_ring (ring (ring Type)))) : @strong_rank_condition.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (finset.{0} linarith.comp)) (normed_comm_ring.{1} (ring.{1} (ring.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_10475 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_10476 (h0 : semiring (add_comm_monoid (normed_comm_ring Type))) : is_noetherian_ring (add_comm_monoid (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_10477 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_10478 (h0 : topological_space (has_top (has_norm empty))) : totally_disconnected_space (has_top (has_norm empty)) := sorry --non-trivial
lemma new_lemma_10479 (h0 : group (with_one (has_norm num))) : group.fg (with_one (has_norm num)) := sorry --non-trivial
lemma new_lemma_10480 (h0 : filter (boolean_algebra (has_Inf linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_10481 (h0 : functor.add_const (filter (has_neg Type)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_10482 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_neg.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_neg.{0} num))  := sorry --non-trivial
lemma new_lemma_10483 (h0 : ring (as_linear_order (option empty))) : rank_condition (as_linear_order (option empty)) := sorry --non-trivial
lemma new_lemma_10484 (h0 : function.extfun Type (functor.add_const (topological_space (simple_graph linarith.comp)))) : @regular_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} linarith.comp)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (simple_graph.{0} linarith.comp))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_10485 (h1 : monoid congr_arg_kind) : monoid.fg congr_arg_kind := sorry --non-trivial
lemma new_lemma_10486 (h0 : topological_space (has_top (random_gen (random_gen (random_gen linarith.comp_source))))) : path_connected_space (has_top (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_10487 (h0 : topological_space (has_bot (option empty))) : preirreducible_space (has_bot (option empty)) := sorry --non-trivial
lemma new_lemma_10488 (h0 : functor.add_const (topological_space (has_pos_part Type)) pos) : @totally_disconnected_space.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_pos_part.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_10489 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 complete_lattice.{0}) (semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_10490 (h1 : topological_space (measurable_space fun_info)) : irreducible_space (measurable_space fun_info) := sorry --non-trivial
lemma new_lemma_10491 (h0 : uniform_space (has_one (id congr_arg_kind))) : complete_space (has_one (id congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_10492 (h0 : functor.add_const (group (has_neg ennreal)) ennreal) : @is_simple_group.{0} (has_neg.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_10493 (h0 : functor.add_const (list (finset environment.implicit_infer_kind)) (ring Type)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_10494 (h0 : add_group (normed_comm_ring empty)) : is_add_cyclic (normed_comm_ring empty) := sorry --non-trivial
lemma new_lemma_10495 (h0 : ring (complete_linear_order congr_arg_kind)) : strong_rank_condition (complete_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_10496 (h0 : ordered_add_comm_monoid (comm_group (semigroup linarith.comp))) : archimedean (comm_group (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_10497 (h2 : set (distrib linarith.ineq)) : set.finite h2 := sorry --non-trivial
lemma new_lemma_10498 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_10499 (h0 : group (add_left_cancel_monoid to_additive.value_type)) : is_cyclic (add_left_cancel_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_10500 (h0 : ring (canonically_ordered_monoid (ordered_comm_monoid linarith.comp))) : is_domain (canonically_ordered_monoid (ordered_comm_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_10501 (h0 : not (group (has_top char) -> false)) : @group.fg.{0} (has_top.{0} char) (@classical.by_contradiction'.{1} (group.{0} (has_top.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_10502 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) empty) : @t0_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_10503 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (boolean_algebra.core empty)) := sorry --non-trivial
lemma new_lemma_10504 (h0 : complete_lattice (has_to_string Type)) : complete_lattice.is_Sup_finite_compact (has_to_string Type) := sorry --non-trivial
lemma new_lemma_10505 (h0 : topological_space (add_group unsigned)) : discrete_topology (add_group unsigned) := sorry --non-trivial
lemma new_lemma_10506 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) Type) : @t1_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_10507 (h0 : function.extfun Type (prod (omega_complete_partial_order num))) : id_rel (function.extfun_app h0 (omega_complete_partial_order num)) := sorry --non-trivial
lemma new_lemma_10508 (h0 : semiring (ordered_comm_ring pos)) : is_noetherian_ring (ordered_comm_ring pos) := sorry --non-trivial
lemma new_lemma_10509 (h0 : functor.comp complete_lattice has_add Type) : @is_compactly_generated.{1} (has_add.{1} Type) (@functor.comp.run.{1 1 1} complete_lattice.{1} has_add.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_10510 (h0 : not (complete_lattice (measurable_space.dynkin_system empty) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (measurable_space.dynkin_system.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (measurable_space.dynkin_system.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_10511 (h0 : functor.comp topological_space finset ennreal) : @sequential_space.{0} (finset.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_10512 (h1 : function.extfun Type group) : @normalizer_condition.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h1 (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_10513 (h0 : list (bin_tree empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_10514 (h0 : topological_space (finset (has_neg name))) : regular_space (finset (has_neg name)) := sorry --non-trivial
lemma new_lemma_10515 (h0 : functor.add_const (functor.add_const (ring linarith.comp) pos) pos) : @rank_condition.{0} linarith.comp (@functor.add_const.run.{0 0} (ring.{0} linarith.comp) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ring.{0} linarith.comp) pos) pos h0))  := sorry --non-trivial
lemma new_lemma_10516 (h0 : functor.add_const (ordered_comm_monoid (has_pos_part pos)) (ring Type)) : @has_exists_mul_of_le.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (has_pos_part.{0} pos)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_10517 (h0 : has_mem.mem num has_emptyc.emptyc) : @is_domain.{0} num (@finset.pi.empty.{1 0} Type ring.{0} num h0)  := sorry --non-trivial
lemma new_lemma_10518 (h0 : list (normed_comm_ring (semigroup name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_10519 (h0 : list (ring (has_to_string unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_10520 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_nndist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_nndist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_10521 (h0 : not (complete_lattice (distrib linarith.comp_source) -> false)) : @is_compactly_generated.{0} (distrib.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (distrib.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_10522 (h0 : topological_space (has_dist unsigned)) : locally_compact_space (has_dist unsigned) := sorry --non-trivial
lemma new_lemma_10523 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_10524 (h0 : functor.comp (functor.comp complete_lattice has_nndist) with_top nnreal) : @is_atomistic.{0} (has_nndist.{0} ennreal) (@functor.comp.run.{0 0 0} complete_lattice.{0} has_nndist.{0} ennreal (@functor.comp.run.{0 0 0} (functor.comp.{0 0 0} complete_lattice.{0} has_nndist.{0}) with_top.{0} nnreal h0))  := sorry --non-trivial
lemma new_lemma_10525 (h0 : not (topological_space (has_top unsigned) -> false)) : @topological_space.separable_space.{0} (has_top.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_10526 (h1 : topological_space (random_gen (random_gen reducibility_hints))) : t0_space (random_gen (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_10527 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_10528 (h0 : topological_space (has_norm (has_top (semiring (semiring congr_arg_kind))))) : preirreducible_space (has_norm (has_top (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_10529 (h1 : function.extfun Type ring) : @is_domain.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h1 (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_10530 (h0 : not (add_group reducibility_hints -> false)) : @is_add_cyclic.{0} reducibility_hints (@classical.by_contradiction'.{1} (add_group.{0} reducibility_hints) h0)  := sorry --non-trivial
lemma new_lemma_10531 (h0 : set (string.iterator_imp -> mul_one_class (mul_one_class std_gen))) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_10532 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_10533 (h0 : semiring (simple_graph (has_neg name))) : is_noetherian_ring (simple_graph (has_neg name)) := sorry --non-trivial
lemma new_lemma_10534 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_10535 (h0 : complete_lattice (with_bot (has_norm linarith.comp))) : is_atomistic (with_bot (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_10536 (h3 : topological_space (distrib (comm_ring char))) : totally_disconnected_space (distrib (comm_ring char)) := sorry --non-trivial
lemma new_lemma_10537 (h0 : functor.add_const (uniform_space (ring unsigned)) pos) : @complete_space.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (ring.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_10538 (h0 : topological_space (generalized_boolean_algebra (ring linarith.comp))) : preirreducible_space (generalized_boolean_algebra (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_10539 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_10540 (h0 : ring (canonically_linear_ordered_monoid (option pos))) : strong_rank_condition (canonically_linear_ordered_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_10541 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_10542 (h0 : topological_space (encodable (has_nnnorm (has_nnnorm (has_nnnorm to_additive.value_type))))) : path_connected_space (encodable (has_nnnorm (has_nnnorm (has_nnnorm to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_10543 (h0 : topological_space (canonically_ordered_monoid (has_Inf pos))) : t1_space (canonically_ordered_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_10544 (h0 : complete_lattice (has_neg_part (boolean_algebra pos))) : complete_lattice.is_Sup_finite_compact (has_neg_part (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_10545 (h0 : ring (normed_comm_ring (has_add pos))) : is_principal_ideal_ring (normed_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_10546 (h0 : ring (plift (option congr_arg_kind))) : strong_rank_condition (plift (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_10547 (h0 : function.extfun Type (functor.add_const (topological_space auto.case_option))) : @totally_disconnected_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} auto.case_option)) h0 num))  := sorry --non-trivial
lemma new_lemma_10548 (h0 : functor.add_const (topological_space (ordered_comm_monoid pos)) Type) : @t1_space.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_10549 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_10550 (h0 : has_add (non_unital_non_assoc_semiring reducibility_hints)) (h1 : uniform_space (add_con (non_unital_non_assoc_semiring reducibility_hints))) : complete_space (add_con (non_unital_non_assoc_semiring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_10551 (h0 : functor.add_const (group (semigroup Type)) (has_to_string Type)) : @is_cyclic.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (semigroup.{1} Type)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_10552 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_dist.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_dist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_10553 (h0 : complete_lattice (add_cancel_monoid (has_zero (semigroup (has_neg (has_zero pos)))))) : is_compactly_generated (add_cancel_monoid (has_zero (semigroup (has_neg (has_zero pos))))) := sorry --non-trivial
lemma new_lemma_10554 (h0 : functor.add_const (topological_space (cancel_monoid unsigned)) environment.implicit_infer_kind) : @preirreducible_space.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_10555 (h0 : functor.add_const (filter (ring pos)) (has_to_string (has_neg_part unsigned))) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_10556 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @locally_compact_space.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (normed_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_10557 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_10558 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_cancel_monoid unsigned)) congr_arg_kind) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_cancel_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_10559 (h0 : complete_lattice (has_norm num)) : is_compactly_generated (has_norm num) := sorry --non-trivial
lemma new_lemma_10560 (h0 : functor.add_const (topological_space (has_add pos)) Type) : @normal_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_10561 (h0 : ring (id (semiring num))) : strong_rank_condition (id (semiring num)) := sorry --non-trivial
lemma new_lemma_10562 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_10563 (h0 : functor.add_const (finset (finset linarith.comp)) (normed_comm_ring (has_pos_part (has_Inf pos)))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_10564 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @rank_condition.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_10565 (h0 : ring (fintype (random_gen (random_gen (random_gen char))))) : rank_condition (fintype (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_10566 (h0 : functor.add_const (function.extfun (Type 1) group) (has_to_string pos)) : @group.fg.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) (has_to_string.{0} pos) h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_10567 (h0 : topological_space (ordered_comm_monoid (has_nndist (has_add Type)))) : discrete_topology (ordered_comm_monoid (has_nndist (has_add Type))) := sorry --non-trivial
lemma new_lemma_10568 (h0 : functor.add_const (ordered_comm_monoid (normed_comm_ring pos)) (has_neg linarith.comp)) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (normed_comm_ring.{0} pos)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_10569 (h0 : topological_space (has_add (has_pos_part (finset linarith.comp)))) : preconnected_space (has_add (has_pos_part (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_10570 (h0 : ring (random_gen (has_one (has_norm (has_top (has_top num)))))) : rank_condition (random_gen (has_one (has_norm (has_top (has_top num))))) := sorry --non-trivial
lemma new_lemma_10571 (h0 : functor.add_const (uniform_space (has_to_string pos)) (ring pos)) : @separated_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_to_string.{0} pos)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_10572 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_10573 (h0 : group (encodable (random_gen (random_gen (random_gen (random_gen char)))))) : group.fg (encodable (random_gen (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_10574 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_10575 (h0 : group (plift unsigned)) : is_cyclic (plift unsigned) := sorry --non-trivial
lemma new_lemma_10576 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_zero unsigned)) := sorry --non-trivial
lemma new_lemma_10577 (h0 : group (boolean_algebra (has_to_string linarith.comp))) : is_cyclic (boolean_algebra (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_10578 (h0 : list (has_to_string (has_pos_part (has_pos_part (has_pos_part pos))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_10579 (h0 : topological_space auto.case_option) : totally_disconnected_space auto.case_option := sorry --non-trivial
lemma new_lemma_10580 (h0 : functor.add_const (topological_space (has_edist unsigned)) (option empty)) : @locally_compact_space.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} unsigned)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_10581 (h0 : functor.add_const (functor.add_const Prop ennreal) unsigned) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_10582 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) (ring pos)) : @has_exists_mul_of_le.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) (ring.{0} pos) h0) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_10583 (h0 : topological_space (has_Inf (boolean_algebra (has_neg linarith.comp)))) : locally_compact_space (has_Inf (boolean_algebra (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_10584 (h0 : ring (complete_distrib_lattice (has_neg environment.implicit_infer_kind))) : strong_rank_condition (complete_distrib_lattice (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_10585 (h0 : topological_space (has_lt (mul_one_class fun_info))) : totally_disconnected_space (has_lt (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_10586 (h0 : not (complete_lattice (linear_ordered_comm_group_with_zero to_additive.value_type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_comm_group_with_zero.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_comm_group_with_zero.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_10587 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (left_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (left_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_10588 (h0 : filter (has_inv (random_gen (random_gen (random_gen (random_gen to_additive.value_type)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_10589 (h1 : monoid string_imp) : monoid.fg string_imp := sorry --non-trivial
lemma new_lemma_10590 (h0 : topological_space (comm_group (add_comm_monoid name))) : locally_compact_space (comm_group (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_10591 (h0 : functor.add_const (complete_lattice (canonically_ordered_comm_semiring ennreal)) ennreal) : @is_compactly_generated.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_ordered_comm_semiring.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_10592 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (monoid empty)) := sorry --non-trivial
lemma new_lemma_10593 (h0 : group (finset (comm_group name))) : is_cyclic (finset (comm_group name)) := sorry --non-trivial
lemma new_lemma_10594 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_10595 (h0 : monoid (monoid empty)) : monoid.fg (monoid empty) := sorry --non-trivial
lemma new_lemma_10596 (h0 : ring (has_le to_additive.value_type)) : strong_rank_condition (has_le to_additive.value_type) := sorry --non-trivial
lemma new_lemma_10597 (h0 : topological_space (boolean_algebra (has_add (has_neg (has_add (has_neg (boolean_algebra Type))))))) : discrete_topology (boolean_algebra (has_add (has_neg (has_add (has_neg (boolean_algebra Type)))))) := sorry --non-trivial
lemma new_lemma_10598 (h0 : topological_space (with_zero string_imp)) : path_connected_space (with_zero string_imp) := sorry --non-trivial
lemma new_lemma_10599 (h0 : not (topological_space (measurable_space.dynkin_system empty) -> false)) : @totally_separated_space.{0} (measurable_space.dynkin_system.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.dynkin_system.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_10600 (h0 : set (normed_field std_gen)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_10601 (h0 : monoid (mul_zero_class name)) : monoid.fg (mul_zero_class name) := sorry --non-trivial
lemma new_lemma_10602 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_add name)) linarith.comp) : @unique_factorization_monoid.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_add.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_10603 (h0 : has_mem.mem group has_emptyc.emptyc) : @is_cyclic.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_10604 (h0 : not (topological_space (with_bot (random_gen linarith.comp_source)) -> false)) : @irreducible_space.{0} (with_bot.{0} (random_gen.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} (random_gen.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_10605 (h0 : fin has_zero.zero) : @preconnected_space.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_10606 (h0 : add_group (has_union (has_top empty))) : is_add_cyclic (has_union (has_top empty)) := sorry --non-trivial
lemma new_lemma_10607 (h0 : functor.add_const (monoid (omega_complete_partial_order empty)) empty) : @monoid.fg.{0} (omega_complete_partial_order.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (omega_complete_partial_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_10608 (h0 : topological_space char) (h1 : topological_space (add_group (topological_space.nonempty_compacts char))) : t2_5_space (add_group (topological_space.nonempty_compacts char)) := sorry --non-trivial
lemma new_lemma_10609 (h0 : functor.add_const (topological_space (ring Type)) linarith.comp) : @sequential_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_10610 (h0 : ring (complete_distrib_lattice to_additive.value_type)) : rank_condition (complete_distrib_lattice to_additive.value_type) := sorry --non-trivial
lemma new_lemma_10611 (h0 : function.extfun Type group) : @normalizer_condition.{0} to_additive.value_type (@function.extfun_app.{2 1} Type group.{0} h0 to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_10612 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @sequential_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_10613 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (canonically_ordered_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_ordered_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_10614 (h0 : complete_lattice to_additive.value_type) : is_atomistic to_additive.value_type := sorry --non-trivial
lemma new_lemma_10615 (h0 : topological_space (complete_linear_order (has_norm empty))) : discrete_topology (complete_linear_order (has_norm empty)) := sorry --non-trivial
lemma new_lemma_10616 (h0 : group (add_cancel_monoid (complete_distrib_lattice environment.implicit_infer_kind))) : is_simple_group (add_cancel_monoid (complete_distrib_lattice environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_10617 (h0 : topological_space (cancel_monoid (option empty))) : discrete_topology (cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_10618 (h0 : functor.add_const (group (boolean_algebra pos)) environment.implicit_infer_kind) : @is_simple_group.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_10619 (h0 : functor.add_const (add_group (add_cancel_monoid empty)) empty) : @is_add_cyclic.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (add_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_10620 (h0 : functor.add_const (topological_space (has_Sup num)) empty) : @discrete_topology.{0} (has_Sup.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_10621 (h0 : finset (linear_order (semiring empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_10622 (h0 : not (group (has_top congr_arg_kind) -> false)) : @normalizer_condition.{0} (has_top.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (has_top.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_10623 (h0 : function.extfun Type topological_space) : @normal_space.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_10624 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_10625 (h2 : measurable_space linarith.ineq) (h3 : set linarith.ineq) : measurable_set h3 := sorry --non-trivial
lemma new_lemma_10626 (h0 : monoid (semigroup (mul_zero_class unsigned))) : monoid.fg (semigroup (mul_zero_class unsigned)) := sorry --non-trivial
lemma new_lemma_10627 (h0 : topological_space (add_comm_monoid (has_Inf (has_Inf Type)))) : path_connected_space (add_comm_monoid (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_10628 (h0 : ring (comm_monoid unsigned)) : strong_rank_condition (comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_10629 (h0 : functor.add_const (monoid (has_to_string pos)) (ring (ring Type))) : @monoid.fg.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (monoid.{0} (has_to_string.{0} pos)) (ring.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_10630 (h0 : complete_lattice (linear_ordered_field (option (option (option pos))))) : complete_lattice.is_Sup_finite_compact (linear_ordered_field (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_10631 (h0 : list (normed_comm_ring pos)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_10632 (h0 : functor.add_const (topological_space (has_neg unsigned)) (boolean_algebra name)) : @totally_separated_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) (boolean_algebra.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_10633 (h0 : add_monoid (linear_ordered_semiring (has_top (has_top unsigned)))) : add_monoid.fg (linear_ordered_semiring (has_top (has_top unsigned))) := sorry --non-trivial
lemma new_lemma_10634 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_10635 (h0 : group (has_Inf (has_pos_part (has_add pos)))) : group.fg (has_Inf (has_pos_part (has_add pos))) := sorry --non-trivial
lemma new_lemma_10636 (h2 : topological_space enat) : path_connected_space enat := sorry --non-trivial
lemma new_lemma_10637 (h0 : group (has_top string_imp)) : is_cyclic (has_top string_imp) := sorry --non-trivial
lemma new_lemma_10638 (h0 : topological_space (with_zero (random_gen (random_gen to_additive.value_type)))) : locally_compact_space (with_zero (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_10639 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (comm_group.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (comm_group.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_10640 (h0 : functor.add_const (topological_space (finset linarith.comp)) pos) : @totally_disconnected_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_10641 (h0 : ring (bin_tree (semiring empty))) : strong_rank_condition (bin_tree (semiring empty)) := sorry --non-trivial
lemma new_lemma_10642 (h0 : semiring (id empty)) : is_noetherian_ring (id empty) := sorry --non-trivial
lemma new_lemma_10643 (h0 : set (has_compl (mul_one_class (mul_one_class string.iterator_imp)))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_10644 (h0 : functor.add_const (complete_lattice (has_repr unsigned)) empty) : @is_compactly_generated.{0} (has_repr.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_repr.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_10645 (h0 : uniform_space (ordered_comm_ring (ordered_ring Type))) : separated_space (ordered_comm_ring (ordered_ring Type)) := sorry --non-trivial
lemma new_lemma_10646 (h0 : functor.add_const (ring (has_neg environment.implicit_infer_kind)) Type) : @rank_condition.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ring.{0} (has_neg.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_10647 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (ordered_comm_ring real)) := sorry --non-trivial
lemma new_lemma_10648 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_emptyc.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_emptyc.{0} empty))  := sorry --non-trivial
lemma new_lemma_10649 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (dlist.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (dlist.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_10650 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_10651 (h0 : finset (boolean_algebra (has_pos_part (normed_comm_ring (has_Inf pos))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_10652 (h0 : add_monoid (random_gen (semiring empty))) : add_monoid.fg (random_gen (semiring empty)) := sorry --non-trivial
lemma new_lemma_10653 (h0 : topological_space (simple_graph (has_compl enat))) (h1 : add_group (simple_graph (has_compl enat))) : topological_add_group (simple_graph (has_compl enat)) := sorry --non-trivial
lemma new_lemma_10654 (h0 : topological_space (add_cancel_monoid (div_inv_monoid empty))) : t1_space (add_cancel_monoid (div_inv_monoid empty)) := sorry --non-trivial
lemma new_lemma_10655 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_10656 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (measurable_space.{0} string_imp) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (measurable_space.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_10657 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_10658 (h0 : topological_space (has_bot (semiring unsigned))) : t1_space (has_bot (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_10659 (h0 : topological_space (normed_field (random_gen (random_gen (random_gen string.iterator_imp))))) : t0_space (normed_field (random_gen (random_gen (random_gen string.iterator_imp)))) := sorry --non-trivial
lemma new_lemma_10660 (h0 : add_group (non_unital_non_assoc_ring char)) : is_add_cyclic (non_unital_non_assoc_ring char) := sorry --non-trivial
lemma new_lemma_10661 (h0 : set (linear_ordered_comm_group_with_zero to_additive.value_type)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_10662 (h0 : functor.comp cancel_comm_monoid_with_zero has_neg_part name) : @unique_factorization_monoid.{0} (has_neg_part.{0} name) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_neg_part.{0} name h0)  := sorry --non-trivial
lemma new_lemma_10663 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_10664 (h0 : topological_space (group_with_zero (option (option (option (option empty)))))) : topological_space.separable_space (group_with_zero (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_10665 (h1 : not (topological_space (with_one num) -> false)) : @irreducible_space.{0} (with_one.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} num)) h1)  := sorry --non-trivial
lemma new_lemma_10666 (h0 : ring (monoid_with_zero (option (option ennreal)))) : is_domain (monoid_with_zero (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_10667 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_10668 (h0 : complete_lattice (has_Inf (finset linarith.comp))) : is_compactly_generated (has_Inf (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_10669 (h1 : topological_space (mul_one_class string.iterator_imp)) (h2 : preorder (mul_one_class string.iterator_imp)) : order_closed_topology (mul_one_class string.iterator_imp) := sorry --non-trivial
lemma new_lemma_10670 (h0 : filter (non_assoc_semiring (option unsigned))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_10671 (h0 : functor.add_const (function.extfun Type topological_space) (finset (finset linarith.comp))) : @path_connected_space.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (finset.{0} (finset.{0} linarith.comp)) h0) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_10672 (h1 : uniform_space environment.projection_info) : complete_space environment.projection_info := sorry --non-trivial
lemma new_lemma_10673 (h0 : topological_space (random_gen (has_norm congr_arg_kind))) : preirreducible_space (random_gen (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_10674 (h0 : list (complete_semilattice_Sup (has_nnnorm linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_10675 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @loc_path_connected_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_10676 (h0 : monoid (normed_group (has_inv fun_info))) : monoid.fg (normed_group (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_10677 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_10678 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) environment.implicit_infer_kind) : @discrete_topology.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_10679 (h0 : functor.add_const (ordered_add_comm_monoid (has_Inf Type)) pos) : @archimedean.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (has_Inf.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_10680 (h0 : has_mul (has_emptyc (has_top linarith.comp))) (h1 : function.extfun Type has_emptyc) : is_right_regular (function.extfun_app h1 (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_10681 (h0 : not (group (comm_ring string.iterator_imp) -> false)) : @is_cyclic.{0} (comm_ring.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (group.{0} (comm_ring.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_10682 (h0 : with_bot (has_lt (nondiscrete_normed_field fun_info))) (h1 : ne h0 has_bot.bot) : @no_max_order.{0} (nondiscrete_normed_field.{0} fun_info) (@with_bot.unbot.{0} (has_lt.{0} (nondiscrete_normed_field.{0} fun_info)) h0 h1)  := sorry --non-trivial
lemma new_lemma_10683 (h0 : topological_space (linear_ordered_comm_ring (semiring empty))) : path_connected_space (linear_ordered_comm_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_10684 (h0 : topological_space (distrib (has_nnnorm (has_nnnorm char)))) : totally_disconnected_space (distrib (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_10685 (h0 : ring (has_dist congr_arg_kind)) : strong_rank_condition (has_dist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_10686 (h0 : ring (random_gen empty)) : is_domain (random_gen empty) := sorry --non-trivial
lemma new_lemma_10687 (h0 : functor.add_const (topological_space (plift unsigned)) congr_arg_kind) : @t1_space.{1} (plift.{1} unsigned) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_10688 (h0 : topological_space (metric_space (semiring (semiring congr_arg_kind)))) : discrete_topology (metric_space (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_10689 (h0 : topological_space (with_bot (has_inv linarith.comp_source))) : path_connected_space (with_bot (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_10690 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (left_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (left_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_10691 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (canonically_ordered_add_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_add_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_10692 (h0 : topological_space (with_one (has_norm num))) : t0_space (with_one (has_norm num)) := sorry --non-trivial
lemma new_lemma_10693 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_10694 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra linarith.comp)) pos) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_10695 (h0 : group (with_bot (has_top linarith.ineq))) : is_cyclic (with_bot (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_10696 (h1 : uniform_space (has_emptyc num)) : complete_space (has_emptyc num) := sorry --non-trivial
lemma new_lemma_10697 (h0 : function.extfun Type (functor.add_const (topological_space name))) : @preirreducible_space.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} name)) h0 empty))  := sorry --non-trivial
lemma new_lemma_10698 (h0 : prod (mul_zero_class (mul_zero_class pos)) (mul_zero_class (mul_zero_class pos))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_10699 (h0 : ring (finset (boolean_algebra.core Type))) : rank_condition (finset (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_10700 (h0 : functor.add_const (functor.add_const (ordered_comm_monoid pos) linarith.comp) linarith.comp) : @has_exists_mul_of_le.{0} pos (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} pos) linarith.comp (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ordered_comm_monoid.{0} pos) linarith.comp) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_10701 (h0 : functor.add_const (filter (bin_tree unsigned)) empty) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_10702 (h0 : uniform_space (option unsigned)) : separated_space (option unsigned) := sorry --non-trivial
lemma new_lemma_10703 (h0 : uniform_space (has_neg (has_to_string Type))) : complete_space (has_neg (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_10704 (h0 : group (option empty)) : is_cyclic (option empty) := sorry --non-trivial
lemma new_lemma_10705 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_10706 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_10707 (h0 : topological_space (measure_theory.measure_space unsigned)) : topological_space.separable_space (measure_theory.measure_space unsigned) := sorry --non-trivial
lemma new_lemma_10708 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_10709 (h0 : complete_lattice (normed_comm_ring (option unsigned))) : is_compactly_generated (normed_comm_ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_10710 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} unsigned (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) unsigned)  := sorry --non-trivial
lemma new_lemma_10711 (h0 : topological_space (add_comm_monoid (has_add environment.implicit_infer_kind))) : discrete_topology (add_comm_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_10712 (h0 : semiring (canonically_ordered_comm_semiring congr_arg_kind)) : is_noetherian_ring (canonically_ordered_comm_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_10713 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring linarith.comp)) (has_neg linarith.comp)) : @path_connected_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_10714 (h0 : ring (ring (has_add (generalized_boolean_algebra (preorder (has_Inf (has_add Type))))))) : rank_condition (ring (has_add (generalized_boolean_algebra (preorder (has_Inf (has_add Type)))))) := sorry --non-trivial
lemma new_lemma_10715 (h1 : function.extfun Type list) : palindrome (function.extfun_app h1 (has_emptyc congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_10716 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_10717 (h0 : not (topological_space (add_group empty) -> false)) : @topological_space.separable_space.{0} (add_group.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_10718 (h0 : group (generalized_boolean_algebra (finset linarith.comp))) : normalizer_condition (generalized_boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_10719 (h0 : functor.add_const (ordered_add_comm_monoid (comm_monoid_with_zero empty)) empty) : @archimedean.{0} (comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (comm_monoid_with_zero.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_10720 (h0 : complete_lattice (has_star (semiring congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (has_star (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_10721 (h0 : function.extfun Type (functor.comp topological_space boolean_algebra.core)) : @preirreducible_space.{0} (boolean_algebra.core.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} boolean_algebra.core.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_10722 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_10723 (h0 : functor.add_const (ring (add_cancel_monoid Type)) Type) : @is_domain.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (add_cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_10724 (h0 : uniform_space (finset (has_Inf (ring linarith.comp)))) : separated_space (finset (has_Inf (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_10725 (h0 : function.extfun Type topological_space) : path_connected_space empty := sorry --non-trivial
lemma new_lemma_10726 (h0 : not (ring (linear_ordered_add_comm_group string_imp) -> false)) : @rank_condition.{0} (linear_ordered_add_comm_group.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_add_comm_group.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_10727 (h0 : topological_space (has_nndist environment.implicit_infer_kind)) : preirreducible_space (has_nndist environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_10728 (h1 : measurable_space char) (h2 : has_sup char) : has_measurable_sup char := sorry --non-trivial
lemma new_lemma_10729 (h0 : functor.add_const (topological_space (has_to_string Type)) Type) : @regular_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_to_string.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_10730 (h0 : monoid (normed_group (has_top (has_top linarith.comp_source)))) : monoid.fg (normed_group (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_10731 (h0 : functor.add_const (function.extfun Type ring) Type) : @rank_condition.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_10732 (h0 : fin has_zero.zero) : @add_monoid.fg.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (add_monoid.{1} (has_pos_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_10733 (h0 : topological_space (has_top (semiring linarith.comp))) : t0_space (has_top (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_10734 (h0 : functor.add_const (filter (semigroup pos)) (finset Type)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_10735 (h0 : group (add_cancel_monoid (add_left_cancel_monoid name))) : group.fg (add_cancel_monoid (add_left_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_10736 (h0 : functor.comp list finset name) : palindrome (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_10737 (h0 : has_mem.mem add_group has_emptyc.emptyc) : @is_add_cyclic.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} h0) (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_10738 (h0 : add_group (has_norm num)) : is_add_cyclic (has_norm num) := sorry --non-trivial
lemma new_lemma_10739 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_10740 (h0 : complete_lattice (has_pos_part (has_pos_part linarith.comp))) : complete_lattice.is_Sup_finite_compact (has_pos_part (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_10741 (h0 : topological_space (has_bot (comm_semigroup (has_Inf real)))) : discrete_topology (has_bot (comm_semigroup (has_Inf real))) := sorry --non-trivial
lemma new_lemma_10742 (h0 : monoid (finset num)) : monoid.fg (finset num) := sorry --non-trivial
lemma new_lemma_10743 (h0 : ring (has_neg_part (normed_comm_ring Type))) : is_principal_ideal_ring (has_neg_part (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_10744 (h0 : group (linear_ordered_add_comm_group (has_nnnorm to_additive.value_type))) : is_cyclic (linear_ordered_add_comm_group (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_10745 (h0 : uniform_space (partial_order (semiring num))) : complete_space (partial_order (semiring num)) := sorry --non-trivial
lemma new_lemma_10746 (h0 : functor.comp ring canonically_ordered_comm_semiring unsigned) : @rank_condition.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.comp.run.{0 0 0} ring.{0} canonically_ordered_comm_semiring.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_10747 (h0 : uniform_space (has_neg_part Type)) : complete_space (has_neg_part Type) := sorry --non-trivial
lemma new_lemma_10748 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} string_imp (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) string_imp)  := sorry --non-trivial
lemma new_lemma_10749 (h0 : add_monoid (semigroup (has_neg (ring (ring name))))) : add_monoid.fg (semigroup (has_neg (ring (ring name)))) := sorry --non-trivial
lemma new_lemma_10750 (h0 : group (has_bot real)) : normalizer_condition (has_bot real) := sorry --non-trivial
lemma new_lemma_10751 (h0 : topological_space (has_bot (ordered_comm_monoid real))) : regular_space (has_bot (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_10752 (h0 : ring (has_ssubset (random_gen linarith.ineq))) : rank_condition (has_ssubset (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_10753 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @totally_separated_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_10754 (h0 : cancel_comm_monoid_with_zero (complete_distrib_lattice (finset linarith.comp))) : unique_factorization_monoid (complete_distrib_lattice (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_10755 (h0 : function.extfun Type topological_space) : @t0_space.{0} (with_one.{0} (comm_ring.{0} to_additive.value_type)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} (comm_ring.{0} to_additive.value_type)))  := sorry --non-trivial
lemma new_lemma_10756 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (pseudo_metric_space.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} h0 (pseudo_metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_10757 (h0 : monoid (boolean_algebra.core (comm_group name))) : monoid.fg (boolean_algebra.core (comm_group name)) := sorry --non-trivial
lemma new_lemma_10758 (h0 : has_nnnorm reducibility_hints -> has_nnnorm reducibility_hints -> Prop) (h1 : has_nnnorm reducibility_hints) : set.finite (relation.refl_gen h0 h1) := sorry --non-trivial
lemma new_lemma_10759 (h0 : add_group (has_union (semiring (has_union (has_union empty))))) : is_add_cyclic (has_union (semiring (has_union (has_union empty)))) := sorry --non-trivial
lemma new_lemma_10760 (h0 : not (ring (simple_graph linarith.ineq) -> false)) : @is_domain.{0} (simple_graph.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (simple_graph.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_10761 (h0 : complete_lattice (group_with_zero (option (option (option ennreal))))) : is_compactly_generated (group_with_zero (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_10762 (h0 : topological_space (cancel_monoid congr_arg_kind)) : loc_path_connected_space (cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_10763 (h0 : complete_lattice (distrib (has_ssubset (has_nnnorm reducibility_hints)))) : complete_lattice.is_Sup_finite_compact (distrib (has_ssubset (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_10764 (h0 : functor.add_const (function.extfun (Type 1) ring) linarith.comp) : @rank_condition.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) linarith.comp h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_10765 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_10766 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) pos) : @archimedean.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) pos h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_10767 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_10768 (h0 : not (complete_lattice (linear_ordered_add_comm_group string_imp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_add_comm_group.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_add_comm_group.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_10769 (h0 : cancel_comm_monoid_with_zero (generalized_boolean_algebra (sub_neg_monoid real))) : unique_factorization_monoid (generalized_boolean_algebra (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_10770 (h0 : topological_space (has_div (uniform_space enat))) (h1 : preorder (has_div (uniform_space enat))) : order_topology (has_div (uniform_space enat)) := sorry --non-trivial
lemma new_lemma_10771 (h0 : topological_space (semi_normed_comm_ring (has_nnnorm (random_gen reducibility_hints)))) : path_connected_space (semi_normed_comm_ring (has_nnnorm (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_10772 (h0 : complete_lattice (linear_ordered_semiring (random_gen linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (linear_ordered_semiring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_10773 (h0 : uniform_space (plift (semiring (semiring (semiring empty))))) : separated_space (plift (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_10774 (h0 : functor.add_const (topological_space (monoid unsigned)) empty) : @t0_space.{0} (monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_10775 (h0 : not (topological_space (has_ssubset linarith.ineq) -> false)) : @totally_disconnected_space.{0} (has_ssubset.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_10776 (h0 : topological_space (nondiscrete_normed_field linarith.ineq)) (h1 : has_sub (nondiscrete_normed_field linarith.ineq)) : has_continuous_sub (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_10777 (h2 : add_group (random_gen char)) : is_add_cyclic (random_gen char) := sorry --non-trivial
lemma new_lemma_10778 (h0 : functor.add_const (topological_space (add_comm_monoid environment.implicit_infer_kind)) linarith.comp) : @totally_separated_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_10779 (h0 : topological_space (has_neg (has_add (finset pos)))) : preirreducible_space (has_neg (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_10780 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_10781 (h0 : topological_space (normed_comm_ring pos)) : locally_compact_space (normed_comm_ring pos) := sorry --non-trivial
lemma new_lemma_10782 (h0 : list auto.case_option -> Prop) (h1 : Exists (fun (x : list auto.case_option), h0 x)) : list.nodup (classical.some h1) := sorry --non-trivial
lemma new_lemma_10783 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (encodable.{0} char) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (encodable.{0} char))  := sorry --non-trivial
lemma new_lemma_10784 (h0 : functor.add_const (ring (canonically_ordered_monoid linarith.comp)) (has_neg (has_neg name))) : @strong_rank_condition.{0} (canonically_ordered_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_monoid.{0} linarith.comp)) (has_neg.{0} (has_neg.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_10785 (h0 : group (topological_space (has_nnnorm (has_nnnorm (mul_one_class (has_nnnorm char)))))) : is_cyclic (topological_space (has_nnnorm (has_nnnorm (mul_one_class (has_nnnorm char))))) := sorry --non-trivial
lemma new_lemma_10786 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @topological_space.separable_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_10787 (h1 : uniform_space (with_zero (has_inv linarith.ineq))) : complete_space (with_zero (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_10788 (h0 : topological_space (normed_lattice_add_comm_group (finset pos))) : totally_separated_space (normed_lattice_add_comm_group (finset pos)) := sorry --non-trivial
lemma new_lemma_10789 (h0 : functor.add_const (group (linear_ordered_field unsigned)) num) : @is_cyclic.{0} (linear_ordered_field.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (linear_ordered_field.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_10790 (h0 : topological_space (canonically_ordered_monoid Type)) : t0_space (canonically_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_10791 (h0 : functor.add_const (topological_space environment.implicit_infer_kind) linarith.comp) : @normal_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (topological_space.{0} environment.implicit_infer_kind) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_10792 (h0 : functor.add_const (complete_lattice (has_nndist environment.implicit_infer_kind)) name) : @is_compactly_generated.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_10793 (h2 : ring (has_inv string_imp)) : is_domain (has_inv string_imp) := sorry --non-trivial
lemma new_lemma_10794 (h0 : uniform_space (has_norm (random_gen (random_gen (has_norm empty))))) : separated_space (has_norm (random_gen (random_gen (has_norm empty)))) := sorry --non-trivial
lemma new_lemma_10795 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (preorder.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (preorder.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_10796 (h0 : list (encodable fun_info)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_10797 (h0 : topological_space (add_semigroup congr_arg_kind)) : irreducible_space (add_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_10798 (h0 : functor.add_const (list (boolean_algebra linarith.comp)) (finset (has_neg Type))) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_10799 (h0 : ring (comm_semigroup (sub_neg_monoid real))) : rank_condition (comm_semigroup (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_10800 (h0 : function.extfun Type group) : @normalizer_condition.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_10801 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_10802 (h0 : topological_space (normed_comm_ring (normed_comm_ring pos))) : topological_space.separable_space (normed_comm_ring (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_10803 (h0 : function.extfun (Type 1) topological_space) : @irreducible_space.{1} (plift.{1} num) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (plift.{1} num))  := sorry --non-trivial
lemma new_lemma_10804 (h0 : add_monoid (non_assoc_semiring (has_star congr_arg_kind))) : add_monoid.fg (non_assoc_semiring (has_star congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_10805 (h0 : not (ring (has_add (has_ssubset linarith.comp_source)) -> false)) : @rank_condition.{0} (has_add.{0} (has_ssubset.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (ring.{0} (has_add.{0} (has_ssubset.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_10806 (h0 : not (ring (random_gen fun_info) -> false)) : @strong_rank_condition.{0} (random_gen.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_10807 (h0 : topological_space (ordered_comm_ring linarith.comp)) : normal_space (ordered_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_10808 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (is_R_or_C.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (is_R_or_C.{0} empty))  := sorry --non-trivial
lemma new_lemma_10809 (h0 : ring (normed_group linarith.ineq)) : rank_condition (normed_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_10810 (h0 : topological_space (has_nndist (option pos))) : t0_space (has_nndist (option pos)) := sorry --non-trivial
lemma new_lemma_10811 (h0 : filter (add_cancel_monoid (has_add (has_add (has_neg pos))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_10812 (h0 : functor.add_const (topological_space (cancel_monoid name)) pos) : @locally_compact_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_10813 (h0 : topological_space (has_top (has_nnnorm (random_gen (has_ssubset fun_info))))) : totally_disconnected_space (has_top (has_nnnorm (random_gen (has_ssubset fun_info)))) := sorry --non-trivial
lemma new_lemma_10814 (h0 : topological_space (ring congr_arg_kind)) : preirreducible_space (ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_10815 (h0 : not (uniform_space (has_union congr_arg_kind) -> false)) : @separated_space.{0} (has_union.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_union.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_10816 (h0 : topological_space (ordered_comm_monoid (has_neg (ring Type)))) : discrete_topology (ordered_comm_monoid (has_neg (ring Type))) := sorry --non-trivial
lemma new_lemma_10817 (h0 : topological_space (has_pos_part (has_neg pos))) : sequential_space (has_pos_part (has_neg pos)) := sorry --non-trivial
lemma new_lemma_10818 (h0 : complete_lattice (topological_space (has_nnnorm fun_info))) : is_compactly_generated (topological_space (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_10819 (h0 : functor.add_const (list (simple_graph linarith.comp)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_10820 (h0 : functor.add_const (topological_space (mul_zero_class ennreal)) Type) : @totally_separated_space.{0} (mul_zero_class.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (mul_zero_class.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_10821 (h0 : uniform_space (canonically_ordered_comm_semiring linarith.comp)) : separated_space (canonically_ordered_comm_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_10822 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_pos_part.{0} (has_add.{0} linarith.comp)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} (has_add.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_10823 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_10824 (h0 : functor.add_const (filter (ring Type)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_10825 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_10826 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (preorder.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (preorder.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_10827 (h2 : complete_lattice (div_inv_monoid (has_nnnorm (has_nnnorm fun_info)))) : complete_lattice.is_Sup_finite_compact (div_inv_monoid (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_10828 (h1 : topological_space (semi_normed_ring linarith.comp_source)) : t0_space (semi_normed_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_10829 (h0 : num -> num -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_10830 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_10831 (h0 : topological_space (free_add_monoid congr_arg_kind)) : discrete_topology (free_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_10832 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_sub.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_sub.{0} empty))  := sorry --non-trivial
lemma new_lemma_10833 (h0 : complete_lattice (random_gen (semiring empty))) : is_atomistic (random_gen (semiring empty)) := sorry --non-trivial
lemma new_lemma_10834 (h0 : functor.add_const (ordered_add_comm_monoid (non_assoc_semiring empty)) (semiring (semiring unsigned))) : @archimedean.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (non_assoc_semiring.{0} empty)) (semiring.{0} (semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_10835 (h0 : not (topological_space (measure_theory.measure_space empty) -> false)) : @preirreducible_space.{0} (measure_theory.measure_space.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (measure_theory.measure_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_10836 (h0 : measurable_space (has_div linarith.ineq)) (h1 : filter (has_div linarith.ineq)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_10837 (h0 : finset char) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_10838 (h0 : not (ring (has_union empty) -> false)) : @strong_rank_condition.{0} (has_union.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (has_union.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_10839 (h0 : functor.add_const (function.extfun Type topological_space) name) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_10840 (h0 : functor.add_const (group (complete_distrib_lattice linarith.comp)) (finset (semigroup linarith.comp))) : @is_cyclic.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} linarith.comp)) (finset.{0} (semigroup.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_10841 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_10842 (h0 : group (dlist (has_nnnorm (has_nnnorm linarith.ineq)))) : is_cyclic (dlist (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_10843 (h0 : ordered_comm_monoid (add_cancel_monoid (has_add (has_add Type)))) : has_exists_mul_of_le (add_cancel_monoid (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_10844 (h0 : not (preorder string.iterator_imp -> false)) (h1 : preorder string_imp) (h2 : string.iterator_imp -> string_imp) : @strict_mono.{0 0} string.iterator_imp string_imp (@classical.by_contradiction'.{1} (preorder.{0} string.iterator_imp) h0) h1 h2  := sorry --non-trivial
lemma new_lemma_10845 (h0 : functor.add_const (topological_space (ordered_ring num)) num) : @irreducible_space.{0} (ordered_ring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_10846 (h0 : add_group (has_ssubset std_gen)) : is_add_cyclic (has_ssubset std_gen) := sorry --non-trivial
lemma new_lemma_10847 (h0 : topological_space (has_zero Type)) : preconnected_space (has_zero Type) := sorry --non-trivial
lemma new_lemma_10848 (h0 : add_group (semigroup (has_Inf (has_Inf (has_Inf linarith.comp))))) : is_add_cyclic (semigroup (has_Inf (has_Inf (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_10849 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_10850 (h0 : filter (has_inv linarith.ineq)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_10851 (h0 : ring (has_one (semiring (has_norm linarith.comp)))) : strong_rank_condition (has_one (semiring (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_10852 (h0 : not (topological_space (with_one (has_norm congr_arg_kind)) -> false)) : @preirreducible_space.{0} (with_one.{0} (has_norm.{0} congr_arg_kind)) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} (has_norm.{0} congr_arg_kind))) h0)  := sorry --non-trivial
lemma new_lemma_10853 (h0 : not (add_group (has_one empty) -> false)) : @is_add_cyclic.{0} (has_one.{0} empty) (@classical.by_contradiction'.{1} (add_group.{0} (has_one.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_10854 (h0 : semiring (measure_theory.measure_space (semiring (semiring unsigned)))) : is_noetherian_ring (measure_theory.measure_space (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_10855 (h0 : semiring (partial_order unsigned)) : is_noetherian_ring (partial_order unsigned) := sorry --non-trivial
lemma new_lemma_10856 (h0 : functor.add_const (add_group (semigroup Type)) (finset Type)) : @is_add_cyclic.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (add_group.{1} (semigroup.{1} Type)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_10857 (h0 : ring (complete_distrib_lattice (finset (finset (finset linarith.comp))))) : strong_rank_condition (complete_distrib_lattice (finset (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_10858 (h0 : uniform_space (normed_comm_ring num)) : complete_space (normed_comm_ring num) := sorry --non-trivial
lemma new_lemma_10859 (h0 : topological_space (denumerable (random_gen fun_info))) : path_connected_space (denumerable (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_10860 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (denumerable.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (denumerable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_10861 (h0 : ring (add_comm_monoid Type)) : rank_condition (add_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_10862 (h0 : fin has_zero.zero) : @topological_space.separable_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_10863 (h0 : group (complete_distrib_lattice (has_nndist (has_add Type)))) : is_cyclic (complete_distrib_lattice (has_nndist (has_add Type))) := sorry --non-trivial
lemma new_lemma_10864 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (denumerable.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (denumerable.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_10865 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (ring.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (ring.{0} num))  := sorry --non-trivial
lemma new_lemma_10866 (h0 : topological_space (complete_linear_order (semiring congr_arg_kind))) : path_connected_space (complete_linear_order (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_10867 (h0 : monoid (complete_distrib_lattice (has_neg_part Type))) : monoid.fg (complete_distrib_lattice (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_10868 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @t0_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_10869 (h0 : ring (ring num)) : is_principal_ideal_ring (ring num) := sorry --non-trivial
lemma new_lemma_10870 (h0 : add_monoid (finset (has_neg linarith.comp))) : add_monoid.fg (finset (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_10871 (h0 : group (add_cancel_monoid (finset pos))) : is_simple_group (add_cancel_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_10872 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (canonically_ordered_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (canonically_ordered_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_10873 (h1 : topological_space reducibility_hints) : totally_disconnected_space reducibility_hints := sorry --non-trivial
lemma new_lemma_10874 (h0 : topological_space (has_Inf (has_add linarith.comp))) : t0_space (has_Inf (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_10875 (h0 : function.extfun Type (functor.add_const (topological_space pos))) : @topological_space.separable_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} pos)) h0 pos))  := sorry --non-trivial
lemma new_lemma_10876 (h0 : topological_space (with_one (has_top (dlist to_additive.value_type)))) : locally_compact_space (with_one (has_top (dlist to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_10877 (h0 : group (has_edist (semiring empty))) : group.fg (has_edist (semiring empty)) := sorry --non-trivial
lemma new_lemma_10878 (h0 : functor.comp uniform_space boolean_algebra.core name) : @complete_space.{0} (boolean_algebra.core.{0} name) (@functor.comp.run.{0 0 0} uniform_space.{0} boolean_algebra.core.{0} name h0)  := sorry --non-trivial
lemma new_lemma_10879 (h0 : function.extfun Type group) : @normalizer_condition.{0} (finset.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (finset.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_10880 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (normed_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_10881 (h0 : not (topological_space (metric_space empty) -> false)) : @discrete_topology.{0} (metric_space.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_10882 (h0 : group (has_add (has_add (finset linarith.comp)))) : normalizer_condition (has_add (has_add (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_10883 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_10884 (h0 : group (cancel_monoid (option unsigned))) : normalizer_condition (cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_10885 (h0 : not (add_monoid (complete_semilattice_Sup linarith.comp) -> false)) : @add_monoid.fg.{0} (complete_semilattice_Sup.{0} linarith.comp) (@classical.by_contradiction'.{1} (add_monoid.{0} (complete_semilattice_Sup.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_10886 (h0 : ring (fintype (random_gen char))) : strong_rank_condition (fintype (random_gen char)) := sorry --non-trivial
lemma new_lemma_10887 (h0 : add_monoid (measurable_space.dynkin_system unsigned)) : add_monoid.fg (measurable_space.dynkin_system unsigned) := sorry --non-trivial
lemma new_lemma_10888 (h0 : complete_lattice (has_neg_part unsigned)) : is_atomistic (has_neg_part unsigned) := sorry --non-trivial
lemma new_lemma_10889 (h0 : topological_space (add_right_cancel_monoid congr_arg_kind)) : normal_space (add_right_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_10890 (h0 : topological_space (add_cancel_comm_monoid empty)) : locally_compact_space (add_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_10891 (h0 : topological_space (complete_distrib_lattice (has_add pos))) : t1_space (complete_distrib_lattice (has_add pos)) := sorry --non-trivial
lemma new_lemma_10892 (h0 : finset (has_to_string (add_comm_monoid Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_10893 (h0 : functor.add_const (filter (has_to_string linarith.comp)) (ring (ring environment.implicit_infer_kind))) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_10894 (h0 : list (canonically_ordered_monoid name)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_10895 (h0 : topological_space (has_top (has_norm num))) : t0_space (has_top (has_norm num)) := sorry --non-trivial
lemma new_lemma_10896 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (has_emptyc.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (has_emptyc.{0} empty))  := sorry --non-trivial
lemma new_lemma_10897 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} linarith.comp (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_10898 (h0 : topological_space (has_one (semiring congr_arg_kind))) : discrete_topology (has_one (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_10899 (h0 : functor.add_const (semiring (comm_group linarith.comp)) pos) : @is_noetherian_ring.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (comm_group.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_10900 (h0 : functor.add_const (monoid (ring name)) (cancel_monoid name)) : @monoid.fg.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (ring.{0} name)) (cancel_monoid.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_10901 (h0 : function.extfun (Type 1) list) : list.nodup (function.extfun_app h0 (plift (option empty))) := sorry --non-trivial
lemma new_lemma_10902 (h1 : not (ring (non_assoc_semiring linarith.comp_source) -> false)) : @is_domain.{0} (non_assoc_semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (non_assoc_semiring.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_10903 (h0 : list (semiring num)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_10904 (h0 : topological_space (has_nndist (finset pos))) : preconnected_space (has_nndist (finset pos)) := sorry --non-trivial
lemma new_lemma_10905 (h0 : filter (encodable fun_info)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_10906 (h0 : functor.add_const (complete_lattice (add_comm_monoid name)) (option (option pos))) : @is_compactly_generated.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_comm_monoid.{0} name)) (option.{0} (option.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_10907 (h0 : set (ereal -> ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_10908 (h0 : topological_space (complete_distrib_lattice environment.implicit_infer_kind)) : loc_path_connected_space (complete_distrib_lattice environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_10909 (h0 : ring (with_one string.iterator_imp)) : rank_condition (with_one string.iterator_imp) := sorry --non-trivial
lemma new_lemma_10910 (h0 : not (semiring (add_right_cancel_monoid empty) -> false)) : @is_noetherian_ring.{0} (add_right_cancel_monoid.{0} empty) (@classical.by_contradiction'.{1} (semiring.{0} (add_right_cancel_monoid.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_10911 (h1 : topological_space (topological_space linarith.ineq)) : t0_space (topological_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_10912 (h0 : complete_lattice (has_inner empty num)) : is_atomistic (has_inner empty num) := sorry --non-trivial
lemma new_lemma_10913 (h3 : topological_space fun_info) : t0_space fun_info := sorry --non-trivial
lemma new_lemma_10914 (h0 : not (uniform_space (with_one num) -> false)) : @complete_space.{0} (with_one.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (with_one.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_10915 (h0 : ordered_comm_monoid (has_add name)) : has_exists_mul_of_le (has_add name) := sorry --non-trivial
lemma new_lemma_10916 (h0 : function.extfun Type ring) : @is_domain.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_10917 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_10918 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (comm_monoid_with_zero.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (comm_monoid_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_10919 (h0 : topological_space (distrib (has_nnnorm linarith.comp_source))) : t0_space (distrib (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_10920 (h0 : ring (comm_ring (random_gen linarith.comp_source))) : rank_condition (comm_ring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_10921 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (ordered_ring.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (ordered_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_10922 (h0 : monoid (with_bot (has_inv (random_gen (has_inv to_additive.value_type))))) : monoid.fg (with_bot (has_inv (random_gen (has_inv to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_10923 (h0 : not (topological_space (has_norm fun_info) -> false)) : @discrete_topology.{0} (has_norm.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_10924 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) name) : @topological_space.separable_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_10925 (h0 : set (add_comm_semigroup enat -> mul_one_class (mul_one_class fun_info))) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_10926 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_10927 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_10928 (h0 : list (normed_comm_ring (boolean_algebra Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_10929 (h0 : filter (monoid ennreal)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_10930 (h0 : topological_space (mul_zero_class Type)) : t1_space (mul_zero_class Type) := sorry --non-trivial
lemma new_lemma_10931 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_10932 (h0 : topological_space (add_right_cancel_monoid (semiring num))) : discrete_topology (add_right_cancel_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_10933 (h0 : not (monoid (bin_tree empty) -> false)) : @monoid.fg.{0} (bin_tree.{0} empty) (@classical.by_contradiction'.{1} (monoid.{0} (bin_tree.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_10934 (h0 : topological_space (semigroup (semiring congr_arg_kind))) : irreducible_space (semigroup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_10935 (h0 : uniform_space (topological_space (has_nnnorm (denumerable char)))) : complete_space (topological_space (has_nnnorm (denumerable char))) := sorry --non-trivial
lemma new_lemma_10936 (h0 : functor.add_const (ordered_add_comm_monoid (ordered_comm_monoid Type)) pos) : @archimedean.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (ordered_comm_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_10937 (h0 : topological_space (has_bot (ordered_comm_monoid linarith.comp))) : preirreducible_space (has_bot (ordered_comm_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_10938 (h0 : function.extfun Type topological_space) : @normal_space.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_10939 (h3 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_nnnorm.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h3 (has_nnnorm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_10940 (h0 : functor.add_const (add_monoid (cancel_monoid num)) unsigned) : @add_monoid.fg.{0} (cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (cancel_monoid.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_10941 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @preirreducible_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_10942 (h0 : fin has_zero.zero) : @rank_condition.{0} (canonically_linear_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (canonically_linear_ordered_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_10943 (h0 : topological_space (has_add (has_add name))) : totally_disconnected_space (has_add (has_add name)) := sorry --non-trivial
lemma new_lemma_10944 (h0 : functor.add_const (function.extfun Type semiring) (ring Type)) : @is_noetherian_ring.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type semiring.{0}) (ring.{1} Type) h0) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_10945 (h0 : add_group (finset (has_to_string ennreal))) : is_add_cyclic (finset (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_10946 (h0 : topological_space (complete_distrib_lattice (has_add (comm_semigroup pos)))) : t1_space (complete_distrib_lattice (has_add (comm_semigroup pos))) := sorry --non-trivial
lemma new_lemma_10947 (h0 : not (filter (semiring congr_arg_kind) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_10948 (h0 : function.extfun Type topological_space) (h1 : option (function.extfun Type topological_space)) : @normal_space.{0} (add_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@option.lhoare.{1} (function.extfun.{2 1} Type topological_space.{0}) h0 h1) (add_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_10949 (h0 : group (add_left_cancel_semigroup (semiring empty))) : is_cyclic (add_left_cancel_semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_10950 (h0 : topological_space (left_cancel_semigroup congr_arg_kind)) : totally_separated_space (left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_10951 (h0 : topological_space (has_nnnorm occurrences)) : totally_disconnected_space (has_nnnorm occurrences) := sorry --non-trivial
lemma new_lemma_10952 (h0 : topological_space (has_ssubset (mul_one_class (random_gen (mul_one_class char))))) : t0_space (has_ssubset (mul_one_class (random_gen (mul_one_class char)))) := sorry --non-trivial
lemma new_lemma_10953 (h0 : topological_space (has_to_string (option ennreal))) : topological_space.separable_space (has_to_string (option ennreal)) := sorry --non-trivial
lemma new_lemma_10954 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normalizer_condition.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_10955 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (complete_semilattice_Sup.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (complete_semilattice_Sup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_10956 (h0 : monoid (ordered_ring (ordered_ring (ring (has_add (has_Inf Type)))))) : monoid.fg (ordered_ring (ordered_ring (ring (has_add (has_Inf Type))))) := sorry --non-trivial
lemma new_lemma_10957 (h0 : functor.add_const (complete_lattice (has_zero environment.implicit_infer_kind)) name) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_10958 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) (finset Type)) : @sequential_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_10959 (h1 : group (topological_space (has_nnnorm char))) : is_cyclic (topological_space (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_10960 (h0 : topological_space (add_cancel_monoid (option (option empty)))) : path_connected_space (add_cancel_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_10961 (h0 : has_add (mul_one_class std_gen)) (h1 : has_le (mul_one_class std_gen)) (h2 : mul_one_class std_gen) : add_le_cancellable h2 := sorry --non-trivial
lemma new_lemma_10962 (h0 : add_monoid (canonically_ordered_monoid Type)) : add_monoid.fg (canonically_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_10963 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_nnnorm.{0} char) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_nnnorm.{0} char))  := sorry --non-trivial
lemma new_lemma_10964 (h0 : topological_space (linear_ordered_comm_monoid_with_zero (semiring empty))) : t0_space (linear_ordered_comm_monoid_with_zero (semiring empty)) := sorry --non-trivial
lemma new_lemma_10965 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 znum) := sorry --non-trivial
lemma new_lemma_10966 (h0 : topological_space (has_append linarith.ineq)) : t0_space (has_append linarith.ineq) := sorry --non-trivial
lemma new_lemma_10967 (h0 : topological_space (add_cancel_monoid name)) : preirreducible_space (add_cancel_monoid name) := sorry --non-trivial
lemma new_lemma_10968 (h0 : functor.add_const (function.extfun Type topological_space) (ring Type)) : @locally_compact_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (ring.{1} Type) h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_10969 (h0 : topological_space (normed_linear_ordered_group (option (option empty)))) : totally_separated_space (normed_linear_ordered_group (option (option empty))) := sorry --non-trivial
lemma new_lemma_10970 (h0 : complete_lattice (add_cancel_comm_monoid congr_arg_kind)) : is_compactly_generated (add_cancel_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_10971 (h0 : function.extfun Type (prod (complete_distrib_lattice environment.implicit_infer_kind))) : id_rel (function.extfun_app h0 (complete_distrib_lattice environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_10972 (h0 : complete_lattice (has_nnnorm string_imp)) : complete_lattice.is_Sup_finite_compact (has_nnnorm string_imp) := sorry --non-trivial
lemma new_lemma_10973 (h0 : uniform_space (semiring (semiring (semiring congr_arg_kind)))) : separated_space (semiring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_10974 (h0 : uniform_space (has_one (has_norm (has_norm congr_arg_kind)))) : complete_space (has_one (has_norm (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_10975 (h0 : functor.add_const (group (semigroup pos)) pos) : @normalizer_condition.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_10976 (h0 : functor.comp ring normed_comm_ring pos) : @is_domain.{0} (normed_comm_ring.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} normed_comm_ring.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_10977 (h0 : topological_space (normed_comm_ring (comm_group (has_add (finset name))))) : preirreducible_space (normed_comm_ring (comm_group (has_add (finset name)))) := sorry --non-trivial
lemma new_lemma_10978 (h0 : functor.add_const (list (has_Sup num)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_10979 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (has_sub.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (has_sub.{0} num))  := sorry --non-trivial
lemma new_lemma_10980 (h0 : not (uniform_space (has_ssubset string.iterator_imp) -> false)) : @complete_space.{0} (has_ssubset.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_ssubset.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_10981 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (ordered_comm_group empty)) := sorry --non-trivial
lemma new_lemma_10982 (h0 : function.extfun Type group) : @is_cyclic.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_10983 (h0 : add_group (distrib_lattice (random_gen (comm_ring to_additive.value_type)))) : is_add_cyclic (distrib_lattice (random_gen (comm_ring to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_10984 (h0 : group (add_cancel_comm_monoid unsigned)) : group.fg (add_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_10985 (h0 : topological_space (id (option empty))) : preirreducible_space (id (option empty)) := sorry --non-trivial
lemma new_lemma_10986 (h0 : topological_space (random_gen linarith.comp_source)) : locally_compact_space (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_10987 (h0 : uniform_space (normed_lattice_add_comm_group (sub_neg_monoid (has_add real)))) : complete_space (normed_lattice_add_comm_group (sub_neg_monoid (has_add real))) := sorry --non-trivial
lemma new_lemma_10988 (h0 : add_group (has_append reducibility_hints)) : is_add_cyclic (has_append reducibility_hints) := sorry --non-trivial
lemma new_lemma_10989 (h2 : ring (has_top (with_bot congr_arg_kind))) : is_domain (has_top (with_bot congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_10990 (h0 : ring (ordered_ring unsigned)) : rank_condition (ordered_ring unsigned) := sorry --non-trivial
lemma new_lemma_10991 (h0 : add_group (complete_linear_order (left_cancel_semigroup unsigned))) : is_add_cyclic (complete_linear_order (left_cancel_semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_10992 (h0 : topological_space (distrib (random_gen linarith.comp_source))) : path_connected_space (distrib (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_10993 (h0 : functor.add_const (semiring (add_cancel_monoid Type)) (finset (has_to_string (has_add pos)))) : @is_noetherian_ring.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (add_cancel_monoid.{1} Type)) (finset.{0} (has_to_string.{0} (has_add.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_10994 (h0 : list (has_inv (random_gen (random_gen to_additive.value_type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_10995 (h0 : topological_space (generalized_boolean_algebra real)) : locally_compact_space (generalized_boolean_algebra real) := sorry --non-trivial
lemma new_lemma_10996 (h0 : topological_space (with_one (random_gen (random_gen linarith.ineq)))) : totally_separated_space (with_one (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_10997 (h0 : uniform_space (semigroup Type)) : complete_space (semigroup Type) := sorry --non-trivial
lemma new_lemma_10998 (h0 : group (has_nndist (has_add ennreal))) : group.fg (has_nndist (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_10999 (h0 : functor.add_const (topological_space (has_zero name)) environment.implicit_infer_kind) : @normal_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_11000 (h0 : ring (semigroup (ring Type))) : is_principal_ideal_ring (semigroup (ring Type)) := sorry --non-trivial
lemma new_lemma_11001 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_11002 (h0 : functor.add_const (group (add_cancel_monoid unsigned)) environment.implicit_infer_kind) : @is_simple_group.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_11003 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_11004 (h0 : topological_space (has_Inf (ordered_ring Type))) : regular_space (has_Inf (ordered_ring Type)) := sorry --non-trivial
lemma new_lemma_11005 (h0 : ring (simple_graph (finset (boolean_algebra.core pos)))) : is_domain (simple_graph (finset (boolean_algebra.core pos))) := sorry --non-trivial
lemma new_lemma_11006 (h0 h1 : multiset (has_compl (has_ssubset (has_ssubset char)))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_11007 (h0 : ordered_add_comm_monoid (ordered_comm_monoid (has_Inf (has_Inf real)))) : archimedean (ordered_comm_monoid (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_11008 (h0 : functor.add_const (ring (has_pos_part linarith.comp)) (has_neg name)) : @rank_condition.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_pos_part.{0} linarith.comp)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_11009 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_11010 (h0 : topological_space (cancel_monoid (semigroup Type))) : discrete_topology (cancel_monoid (semigroup Type)) := sorry --non-trivial
lemma new_lemma_11011 (h0 : functor.add_const (ordered_add_comm_monoid (normed_comm_ring pos)) name) : @archimedean.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (normed_comm_ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_11012 (h0 : function.extfun Type group) : @group.fg.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_11013 (h0 : pseudo_metric_space (has_dist congr_arg_kind) -> pseudo_metric_space (has_dist congr_arg_kind) -> Prop) : irreflexive h0 := sorry --non-trivial
lemma new_lemma_11014 (h0 : ordered_add_comm_monoid (cancel_monoid pos)) : archimedean (cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_11015 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring Type)) linarith.comp) : @loc_path_connected_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_11016 (h0 : functor.add_const (finset (semigroup environment.implicit_infer_kind)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_11017 (h0 : has_mem.mem (random_gen fun_info) has_emptyc.emptyc) : @is_domain.{0} (random_gen.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (random_gen.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_11018 (h0 : group (measurable_space (semiring congr_arg_kind))) : group.fg (measurable_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_11019 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_11020 (h0 : cancel_comm_monoid_with_zero (plift (has_bot empty))) : unique_factorization_monoid (plift (has_bot empty)) := sorry --non-trivial
lemma new_lemma_11021 (h0 : topological_space (ring (option (option empty)))) : locally_compact_space (ring (option (option empty))) := sorry --non-trivial
lemma new_lemma_11022 (h0 : topological_space (group_with_zero (option (option (option num))))) : totally_disconnected_space (group_with_zero (option (option (option num)))) := sorry --non-trivial
lemma new_lemma_11023 (h0 : group (canonically_linear_ordered_monoid real)) : group.fg (canonically_linear_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_11024 (h0 : group (measurable_space (random_gen (random_gen num)))) : normalizer_condition (measurable_space (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_11025 (h0 : functor.add_const (group (boolean_algebra name)) environment.implicit_infer_kind) : @group.fg.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_11026 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @t0_space.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_11027 (h1 : add_group (has_compl reducibility_hints)) : is_add_cyclic (has_compl reducibility_hints) := sorry --non-trivial
lemma new_lemma_11028 (h0 : complete_lattice (measurable_space (with_bot string_imp))) : is_atomistic (measurable_space (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_11029 (h0 : topological_space (left_cancel_monoid (semiring num))) : t1_space (left_cancel_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_11030 (h0 : topological_space (has_sup string_imp)) : path_connected_space (has_sup string_imp) := sorry --non-trivial
lemma new_lemma_11031 (h1 : char -> char -> Prop) (h2 h3 : char) : eqv_gen h1 h2 h3 := sorry --non-trivial
lemma new_lemma_11032 (h0 : function.extfun (finset Type) (has_mem.mem (has_top num))) : @add_monoid.fg.{0} (has_top.{0} num) (@finset.pi.empty.{1 0} Type add_monoid.{0} (has_top.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_11033 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_11034 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (is_R_or_C empty)) := sorry --non-trivial
lemma new_lemma_11035 (h0 : topological_space (finset (has_nndist name))) : totally_separated_space (finset (has_nndist name)) := sorry --non-trivial
lemma new_lemma_11036 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} real (@matrix.vec_empty.{0} (complete_lattice.{0} real) h0)  := sorry --non-trivial
lemma new_lemma_11037 (h1 : function.extfun Type ring) : @strong_rank_condition.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h1 (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_11038 (h0 : fin has_zero.zero) : @preconnected_space.{0} (has_bot.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_11039 (h0 : functor.add_const (uniform_space (is_R_or_C unsigned)) empty) : @separated_space.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (is_R_or_C.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_11040 (h0 : functor.add_const (topological_space (simple_graph pos)) linarith.comp) : @preirreducible_space.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_11041 (h0 : uniform_space (has_Inf linarith.comp)) : complete_space (has_Inf linarith.comp) := sorry --non-trivial
lemma new_lemma_11042 (h1 : ring (normed_field string_imp)) : rank_condition (normed_field string_imp) := sorry --non-trivial
lemma new_lemma_11043 (h0 : topological_space (boolean_algebra.core unsigned)) : preconnected_space (boolean_algebra.core unsigned) := sorry --non-trivial
lemma new_lemma_11044 (h0 : complete_lattice (has_top (random_gen linarith.comp_source))) : is_atomistic (has_top (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_11045 (h1 : complete_lattice (add_cancel_monoid (measurable_space (has_nnnorm (random_gen string_imp))))) : is_compactly_generated (add_cancel_monoid (measurable_space (has_nnnorm (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_11046 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_atomistic.{0} (has_dist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) complete_lattice.{0}) (has_dist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_11047 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (comm_semigroup.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} linarith.comp)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_11048 (h0 : ring (pseudo_metric_space (simple_graph unsigned))) : rank_condition (pseudo_metric_space (simple_graph unsigned)) := sorry --non-trivial
lemma new_lemma_11049 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_11050 (h1 : topological_space (with_bot (has_top (has_norm fun_info)))) : path_connected_space (with_bot (has_top (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_11051 (h0 : functor.add_const (uniform_space (semigroup pos)) name) : @complete_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_11052 (h1 : not (topological_space (topological_space char) -> false)) : @t0_space.{0} (topological_space.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (topological_space.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_11053 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_11054 (h0 : uniform_space (has_to_string (normed_comm_ring (normed_comm_ring Type)))) : separated_space (has_to_string (normed_comm_ring (normed_comm_ring Type))) := sorry --non-trivial
lemma new_lemma_11055 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_11056 (h0 : topological_space (ordered_comm_ring (has_Inf (has_add real)))) : locally_compact_space (ordered_comm_ring (has_Inf (has_add real))) := sorry --non-trivial
lemma new_lemma_11057 (h0 : not (add_group (add_right_cancel_monoid empty) -> false)) : @is_add_cyclic.{0} (add_right_cancel_monoid.{0} empty) (@classical.by_contradiction'.{1} (add_group.{0} (add_right_cancel_monoid.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_11058 (h0 : functor.add_const Prop (simple_graph linarith.comp)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_11059 (h0 : has_mem.mem (linear_ordered_semiring fun_info) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (linear_ordered_semiring.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_11060 (h1 : not (ring (has_compl string_imp) -> false)) : @rank_condition.{0} (has_compl.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_11061 (h0 : function.extfun Type ring) : @is_domain.{0} (normed_linear_ordered_group.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_linear_ordered_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_11062 (h0 : functor.add_const (functor.add_const (complete_lattice environment.implicit_infer_kind) pos) Type) : @is_compactly_generated.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (complete_lattice.{0} environment.implicit_infer_kind) pos (@functor.add_const.run.{0 1} (functor.add_const.{0 0} (complete_lattice.{0} environment.implicit_infer_kind) pos) Type h0))  := sorry --non-trivial
lemma new_lemma_11063 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preconnected_space.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_11064 (h0 : functor.add_const (topological_space (ring Type)) linarith.comp) : @preirreducible_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_11065 (h0 : topological_space (has_zero (ring (ring linarith.comp)))) : t0_space (has_zero (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_11066 (h0 : functor.add_const (group (has_add linarith.comp)) environment.implicit_infer_kind) : @group.fg.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_11067 (h1 : set (has_nnnorm reducibility_hints)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_11068 (h0 : has_coe (nondiscrete_normed_field environment.projection_info) Prop) (h1 : nondiscrete_normed_field environment.projection_info) : @coe_b.{1 1} (nondiscrete_normed_field.{0} environment.projection_info) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_11069 (h0 : topological_space (with_bot (semiring (random_gen num)))) : discrete_topology (with_bot (semiring (random_gen num))) := sorry --non-trivial
lemma new_lemma_11070 (h0 : ring (uniform_space linarith.comp_source)) : is_domain (uniform_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_11071 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (with_bot num)) := sorry --non-trivial
lemma new_lemma_11072 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @locally_compact_space.{0} string_imp (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) string_imp)  := sorry --non-trivial
lemma new_lemma_11073 (h0 : topological_space (complete_semilattice_Sup (linear_ordered_add_comm_group string_imp))) : path_connected_space (complete_semilattice_Sup (linear_ordered_add_comm_group string_imp)) := sorry --non-trivial
lemma new_lemma_11074 (h0 : topological_space (has_add real)) : locally_compact_space (has_add real) := sorry --non-trivial
lemma new_lemma_11075 (h0 : ring (has_compl enat)) : rank_condition (has_compl enat) := sorry --non-trivial
lemma new_lemma_11076 (h0 : group (comm_ring (comm_ring to_additive.value_type))) : is_cyclic (comm_ring (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_11077 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) pos) : @irreducible_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_11078 (h0 : group (complete_linear_order (semiring unsigned))) : group.fg (complete_linear_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_11079 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_11080 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_11081 (h0 : topological_space (has_nnnorm linarith.comp_source) -> Prop) (h1 : Exists (fun (x : topological_space (has_nnnorm linarith.comp_source)), h0 x)) : @t0_space.{0} (has_nnnorm.{0} linarith.comp_source) (@classical.some.{1} (topological_space.{0} (has_nnnorm.{0} linarith.comp_source)) h0 h1)  := sorry --non-trivial
lemma new_lemma_11082 (h0 : ring (uniform_space (normed_field char))) : is_domain (uniform_space (normed_field char)) := sorry --non-trivial
lemma new_lemma_11083 (h0 : ring (linear_ordered_comm_monoid_with_zero (option empty))) : rank_condition (linear_ordered_comm_monoid_with_zero (option empty)) := sorry --non-trivial
lemma new_lemma_11084 (h0 : functor.add_const (list (linear_ordered_comm_monoid_with_zero empty)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_11085 (h0 : topological_space (add_group (has_norm (has_norm (has_norm linarith.comp))))) : irreducible_space (add_group (has_norm (has_norm (has_norm linarith.comp)))) := sorry --non-trivial
lemma new_lemma_11086 (h1 : not (ring (has_emptyc congr_arg_kind) -> false)) : @strong_rank_condition.{0} (has_emptyc.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (has_emptyc.{0} congr_arg_kind)) h1)  := sorry --non-trivial
lemma new_lemma_11087 (h0 : finset (boolean_algebra.core (has_add Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_11088 (h0 : add_group (with_bot (has_top (has_top fun_info)))) : is_add_cyclic (with_bot (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_11089 (h0 : filter (denumerable (has_inv linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_11090 (h1 : not (add_group (comm_ring string_imp) -> false)) : @is_add_cyclic.{0} (comm_ring.{0} string_imp) (@classical.by_contradiction'.{1} (add_group.{0} (comm_ring.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_11091 (h0 : group (encodable (has_top (has_nnnorm to_additive.value_type)))) : group.fg (encodable (has_top (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_11092 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_11093 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_11094 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_nndist.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} num))  := sorry --non-trivial
lemma new_lemma_11095 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} to_additive.value_type (@function.extfun_app.{2 1} Type topological_space.{0} h0 to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_11096 (h0 : topological_space (has_nndist (has_neg ennreal))) : regular_space (has_nndist (has_neg ennreal)) := sorry --non-trivial
lemma new_lemma_11097 (h0 : ring (canonically_ordered_monoid Type)) : rank_condition (canonically_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_11098 (h0 : topological_space (normed_comm_ring (has_add name))) : locally_compact_space (normed_comm_ring (has_add name)) := sorry --non-trivial
lemma new_lemma_11099 (h0 : cancel_comm_monoid_with_zero (linear_ordered_comm_ring (semiring (semiring empty)))) : unique_factorization_monoid (linear_ordered_comm_ring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_11100 (h0 : topological_space (normed_comm_ring (finset (has_neg pos)))) : t0_space (normed_comm_ring (finset (has_neg pos))) := sorry --non-trivial
lemma new_lemma_11101 (h0 : fin has_zero.zero) : @is_simple_group.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (group.{1} (ordered_comm_ring.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_11102 (h0 : topological_space (has_ssubset (has_ssubset string.iterator_imp))) : t0_space (has_ssubset (has_ssubset string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_11103 (h0 : topological_space (boolean_algebra (has_Inf real))) : locally_compact_space (boolean_algebra (has_Inf real)) := sorry --non-trivial
lemma new_lemma_11104 (h0 : ring (has_one (semiring linarith.comp))) : is_domain (has_one (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_11105 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_11106 (h0 : fin has_zero.zero) : @complete_space.{0} (complete_distrib_lattice.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (complete_distrib_lattice.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_11107 (h0 : functor.add_const (ordered_comm_monoid (has_nndist name)) (has_add pos)) : @has_exists_mul_of_le.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_nndist.{0} name)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_11108 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) pos) : @t1_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_11109 (h0 : topological_space (canonically_ordered_comm_semiring (finset name))) : totally_separated_space (canonically_ordered_comm_semiring (finset name)) := sorry --non-trivial
lemma new_lemma_11110 (h0 : functor.add_const (topological_space (simple_graph linarith.comp)) pos) : @t0_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_11111 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (option.{0} (semiring.{0} (semiring.{0} (semiring.{0} (has_top.{0} (has_top.{0} congr_arg_kind)))))) (@function.extfun_app.{2 1} Type add_group.{0} h0 (option.{0} (semiring.{0} (semiring.{0} (semiring.{0} (has_top.{0} (has_top.{0} congr_arg_kind)))))))  := sorry --non-trivial
lemma new_lemma_11112 (h0 : function.extfun Type group) : @is_cyclic.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_11113 (h0 : topological_space (has_to_string (comm_group unsigned))) : totally_separated_space (has_to_string (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_11114 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @irreducible_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_11115 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) linarith.comp) : @locally_compact_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_11116 (h0 : topological_space (normed_comm_ring Type)) : path_connected_space (normed_comm_ring Type) := sorry --non-trivial
lemma new_lemma_11117 (h0 : group (has_neg_part (comm_group (comm_group Type)))) : is_cyclic (has_neg_part (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_11118 (h0 : topological_space (ordered_cancel_add_comm_monoid num)) : discrete_topology (ordered_cancel_add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_11119 (h0 : functor.add_const (functor.add_const (cancel_comm_monoid_with_zero occurrences) empty) empty) : @unique_factorization_monoid.{0} occurrences (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} occurrences) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} occurrences) empty) empty h0))  := sorry --non-trivial
lemma new_lemma_11120 (h0 : functor.add_const (complete_lattice (boolean_algebra environment.implicit_infer_kind)) name) : @is_compactly_generated.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_11121 (h0 : functor.add_const (uniform_space (normed_comm_ring pos)) name) : @separated_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (normed_comm_ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_11122 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_11123 (h0 : functor.add_const (topological_space (has_star empty)) num) : @locally_compact_space.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_11124 (h0 : topological_space (ordered_comm_monoid (has_neg (has_neg name)))) : normal_space (ordered_comm_monoid (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_11125 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) empty) : @preirreducible_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_11126 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_11127 (h0 : ring (mul_one_class linarith.ineq)) : strong_rank_condition (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_11128 (h0 : monoid (canonically_ordered_comm_semiring environment.implicit_infer_kind)) : monoid.fg (canonically_ordered_comm_semiring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_11129 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (comm_semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_11130 (h0 : list (has_top (has_nnnorm fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_11131 (h0 : complete_lattice (semigroup congr_arg_kind)) : is_atomistic (semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_11132 (h0 : function.extfun Type (functor.add_const (topological_space (ordered_ring unsigned)))) : @discrete_topology.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_11133 (h0 : topological_space (add_group (add_group (has_union (has_union linarith.comp))))) : irreducible_space (add_group (add_group (has_union (has_union linarith.comp)))) := sorry --non-trivial
lemma new_lemma_11134 (h0 : functor.add_const (function.extfun Type group) pos) : @group.fg.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_11135 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_11136 (h0 : not (add_group (distrib_lattice char) -> false)) : @is_add_cyclic.{0} (distrib_lattice.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (distrib_lattice.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_11137 (h0 : monoid (has_pos_part (has_neg (has_neg linarith.comp)))) : monoid.fg (has_pos_part (has_neg (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_11138 (h0 : uniform_space (add_cancel_monoid (finset (has_pos_part linarith.comp)))) : separated_space (add_cancel_monoid (finset (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_11139 (h0 : complete_lattice (complete_distrib_lattice (has_add (has_add Type)))) : is_atomistic (complete_distrib_lattice (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_11140 (h0 : functor.add_const (ordered_add_comm_monoid (as_linear_order empty)) unsigned) : @archimedean.{0} (as_linear_order.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (as_linear_order.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_11141 (h0 : topological_space (add_comm_monoid (has_to_string unsigned))) : preconnected_space (add_comm_monoid (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_11142 (h0 : cancel_comm_monoid_with_zero (complete_distrib_lattice ennreal)) : unique_factorization_monoid (complete_distrib_lattice ennreal) := sorry --non-trivial
lemma new_lemma_11143 (h0 : functor.add_const (topological_space (preorder congr_arg_kind)) congr_arg_kind) : @totally_separated_space.{0} (preorder.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_11144 (h0 : list (comm_ring char)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_11145 (h0 : function.extfun Type (functor.add_const (topological_space (has_Sup empty)))) : @topological_space.separable_space.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_Sup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_11146 (h0 : functor.add_const (complete_lattice (finset ennreal)) pos) : @is_compactly_generated.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_11147 (h0 : functor.add_const (functor.add_const (topological_space pos) pos) pos) : @locally_compact_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} pos) pos) pos h0))  := sorry --non-trivial
lemma new_lemma_11148 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_11149 (h0 : ring (ring (option (option (option unsigned))))) : rank_condition (ring (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_11150 (h0 : not (add_monoid (has_star num) -> false)) : @add_monoid.fg.{0} (has_star.{0} num) (@classical.by_contradiction'.{1} (add_monoid.{0} (has_star.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_11151 (h0 : add_monoid (ordered_comm_monoid Type)) : add_monoid.fg (ordered_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_11152 (h0 : uniform_space (semiring to_additive.value_type)) : separated_space (semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_11153 (h0 : set (mul_one_class (add_comm_semigroup linarith.ineq) -> mul_one_class char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_11154 (h0 : pnat) (h1 : thunk pnat) (h2 : list pnat) : @id.{1} Prop (pnat.coprime h0 (@list.ilast'.{0} pnat (@trace_call_stack.{0} pnat h1) h2))  := sorry --non-trivial
lemma new_lemma_11155 (h0 : monoid (has_star (semiring (semiring num)))) : monoid.fg (has_star (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_11156 (h0 : functor.add_const (add_monoid (mul_zero_class num)) empty) : @add_monoid.fg.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (mul_zero_class.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_11157 (h0 : ordered_comm_monoid (add_cancel_monoid (option (option ennreal)))) : has_exists_mul_of_le (add_cancel_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_11158 (h0 : topological_space (finset (ring linarith.comp))) : loc_path_connected_space (finset (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_11159 (h0 : topological_space (add_comm_monoid (has_add (has_add name)))) : discrete_topology (add_comm_monoid (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_11160 (h0 : complete_lattice (free_add_monoid num)) : complete_lattice.is_Sup_finite_compact (free_add_monoid num) := sorry --non-trivial
lemma new_lemma_11161 (h0 : filter (with_zero (distrib fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_11162 (h0 : ring (has_zero name)) : is_principal_ideal_ring (has_zero name) := sorry --non-trivial
lemma new_lemma_11163 (h0 : topological_space (boolean_algebra.core name)) : sequential_space (boolean_algebra.core name) := sorry --non-trivial
lemma new_lemma_11164 (h0 : functor.add_const (monoid (sub_neg_monoid linarith.comp)) pos) : @monoid.fg.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (sub_neg_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_11165 (h0 : not (group (random_gen congr_arg_kind) -> false)) : @normalizer_condition.{0} (random_gen.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (random_gen.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_11166 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_11167 (h0 : topological_space (normed_comm_ring Type)) : loc_path_connected_space (normed_comm_ring Type) := sorry --non-trivial
lemma new_lemma_11168 (h0 : complete_lattice (option (option unsigned))) : is_compactly_generated (option (option unsigned)) := sorry --non-trivial
lemma new_lemma_11169 (h0 h1 : multiset (non_unital_non_assoc_semiring char)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_11170 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) pos) : @regular_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_11171 (h0 : not (group (linear_ordered_comm_ring empty) -> false)) : @is_cyclic.{0} (linear_ordered_comm_ring.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_comm_ring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_11172 (h0 : topological_space (has_nndist (has_Inf (has_add pos)))) : normal_space (has_nndist (has_Inf (has_add pos))) := sorry --non-trivial
lemma new_lemma_11173 (h0 : topological_space (has_one empty)) : path_connected_space (has_one empty) := sorry --non-trivial
lemma new_lemma_11174 (h0 : group (pseudo_metric_space unsigned)) : group.fg (pseudo_metric_space unsigned) := sorry --non-trivial
lemma new_lemma_11175 (h0 : functor.add_const (topological_space ennreal) num) : totally_separated_space ennreal := sorry --non-trivial
lemma new_lemma_11176 (h0 : topological_space (has_emptyc (has_norm (random_gen (has_norm num))))) : locally_compact_space (has_emptyc (has_norm (random_gen (has_norm num)))) := sorry --non-trivial
lemma new_lemma_11177 (h0 : finset (uniform_space unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_11178 (h0 : function.extfun Type topological_space) : @t0_space.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_11179 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_11180 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (add_left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_11181 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_11182 (h0 : group (has_compl (has_nnnorm linarith.comp_source))) : is_cyclic (has_compl (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_11183 (h0 : topological_space (ordered_ring (option (option unsigned)))) : topological_space.separable_space (ordered_ring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_11184 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_11185 (h0 : complete_lattice (boolean_algebra unsigned)) : is_atomistic (boolean_algebra unsigned) := sorry --non-trivial
lemma new_lemma_11186 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_11187 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @group.fg.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_11188 (h0 h1 : multiset (has_lt linarith.ineq)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_11189 (h0 : group (with_one (has_norm to_additive.value_type))) : normalizer_condition (with_one (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_11190 (h0 : uniform_space (has_zero (ring linarith.comp))) : separated_space (has_zero (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_11191 (h0 : topological_space (complete_distrib_lattice num)) : totally_disconnected_space (complete_distrib_lattice num) := sorry --non-trivial
lemma new_lemma_11192 (h0 : ring (has_div (has_ssubset (mul_one_class string_imp)))) : is_domain (has_div (has_ssubset (mul_one_class string_imp))) := sorry --non-trivial
lemma new_lemma_11193 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (denumerable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} h0 (denumerable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_11194 (h2 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h2 (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_11195 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_11196 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_inter.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_inter.{0} num))  := sorry --non-trivial
lemma new_lemma_11197 (h0 : filter (linear_ordered_comm_group empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_11198 (h0 : topological_space (has_neg_part (boolean_algebra.core ennreal))) : t0_space (has_neg_part (boolean_algebra.core ennreal)) := sorry --non-trivial
lemma new_lemma_11199 (h0 : functor.add_const (group (semiring unsigned)) num) : @group.fg.{0} (semiring.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (semiring.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_11200 (h0 : functor.add_const (ordered_add_comm_monoid (has_dist empty)) (option empty)) : @archimedean.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_dist.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_11201 (h0 : complete_lattice (ordered_cancel_add_comm_monoid empty)) : is_compactly_generated (ordered_cancel_add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_11202 (h0 : fin has_zero.zero) : countable_Inter_filter (function.extfun_app (matrix.vec_empty h0) real) := sorry --non-trivial
lemma new_lemma_11203 (h0 h1 : not (multiset (uniform_space string.iterator_imp) -> false)) : multiset.disjoint (classical.by_contradiction' h0) (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_11204 (h0 : add_group (has_pos_part (finset (finset (finset linarith.comp))))) : is_add_cyclic (has_pos_part (finset (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_11205 (h0 : function.extfun Type (functor.add_const (functor.add_const (complete_lattice (linear_order empty)) empty))) : @complete_lattice.is_Sup_finite_compact.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_order.{0} empty)) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (complete_lattice.{0} (linear_order.{0} empty)) empty) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (functor.add_const.{0 0} (complete_lattice.{0} (linear_order.{0} empty)) empty)) h0 empty)))  := sorry --non-trivial
lemma new_lemma_11206 (h0 : not (monoid (linear_ordered_semiring num) -> false)) : @monoid.fg.{0} (linear_ordered_semiring.{0} num) (@classical.by_contradiction'.{1} (monoid.{0} (linear_ordered_semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_11207 (h0 : add_monoid (has_top linarith.comp)) : add_monoid.fg (has_top linarith.comp) := sorry --non-trivial
lemma new_lemma_11208 (h0 : functor.add_const (ring (has_add name)) (normed_comm_ring pos)) : @is_principal_ideal_ring.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} name)) (normed_comm_ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_11209 (h0 : functor.add_const (ring (ordered_comm_ring linarith.comp)) (has_nndist (has_neg name))) : @strong_rank_condition.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} linarith.comp)) (has_nndist.{0} (has_neg.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_11210 (h0 : complete_lattice (canonically_ordered_monoid (has_pos_part real))) : is_compactly_generated (canonically_ordered_monoid (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_11211 (h0 : functor.add_const (semiring (boolean_algebra name)) (comm_group name)) : @is_noetherian_ring.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (boolean_algebra.{0} name)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_11212 (h0 : functor.add_const (topological_space (has_add Type)) linarith.comp) : @topological_space.separable_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_11213 (h0 : ring (random_gen congr_arg_kind)) : strong_rank_condition (random_gen congr_arg_kind) := sorry --non-trivial
lemma new_lemma_11214 (h0 : complete_lattice (has_top (has_top (has_top (has_top linarith.comp_source))))) : is_compactly_generated (has_top (has_top (has_top (has_top linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_11215 (h0 : not (ring (has_norm empty) -> false)) : @rank_condition.{0} (has_norm.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (has_norm.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_11216 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (ordered_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_11217 (h0 : complete_lattice (semiring (has_top fun_info))) : is_atomistic (semiring (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_11218 (h0 : add_comm_monoid (ring ennreal) -> add_comm_monoid (ring ennreal) -> Prop) : is_symm (add_comm_monoid (ring ennreal)) h0 := sorry --non-trivial
lemma new_lemma_11219 (h0 : set (non_unital_non_assoc_semiring (normed_field linarith.ineq))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_11220 (h0 : functor.add_const (ring (has_nndist linarith.comp)) Type) : @is_domain.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (has_nndist.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_11221 (h0 : cancel_comm_monoid_with_zero (has_nndist ennreal)) : unique_factorization_monoid (has_nndist ennreal) := sorry --non-trivial
lemma new_lemma_11222 (h0 : topological_space (normed_comm_ring (option unsigned))) : normal_space (normed_comm_ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_11223 (h2 : ring congr_arg_kind) : is_domain congr_arg_kind := sorry --non-trivial
lemma new_lemma_11224 (h0 : functor.add_const (finset (semigroup environment.implicit_infer_kind)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_11225 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) (comm_group name)) : @path_connected_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_11226 (h0 : functor.add_const (function.extfun Type add_group) pos) : @is_add_cyclic.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) pos h0) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_11227 (h0 : topological_space (semigroup (has_nndist name))) : irreducible_space (semigroup (has_nndist name)) := sorry --non-trivial
lemma new_lemma_11228 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (canonically_linear_ordered_monoid.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (canonically_linear_ordered_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_11229 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (non_assoc_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (non_assoc_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_11230 (h0 : topological_space (finset (option congr_arg_kind))) : normal_space (finset (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_11231 (h0 : functor.add_const (topological_space (has_nndist empty)) num) : @preirreducible_space.{0} (has_nndist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_11232 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_11233 (h0 : cancel_comm_monoid_with_zero (comm_monoid empty)) : unique_factorization_monoid (comm_monoid empty) := sorry --non-trivial
lemma new_lemma_11234 (h0 : group (semigroup (has_to_string unsigned))) : group.fg (semigroup (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_11235 (h0 : topological_space (finset (generalized_boolean_algebra (generalized_boolean_algebra pos)))) : preconnected_space (finset (generalized_boolean_algebra (generalized_boolean_algebra pos))) := sorry --non-trivial
lemma new_lemma_11236 (h0 : function.extfun (Type 1) ring) : @rank_condition.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_11237 (h0 : functor.add_const (topological_space (filter num)) num) : @irreducible_space.{0} (filter.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (filter.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_11238 (h0 : ring (distrib_lattice (boolean_algebra.core fun_info))) : rank_condition (distrib_lattice (boolean_algebra.core fun_info)) := sorry --non-trivial
lemma new_lemma_11239 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_neg_part.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_neg_part.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_11240 (h0 : ring (boolean_algebra.core (finset (has_Inf (finset pos))))) : is_domain (boolean_algebra.core (finset (has_Inf (finset pos)))) := sorry --non-trivial
lemma new_lemma_11241 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_11242 (h0 : fin has_zero.zero) : @is_cyclic.{0} (canonically_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (canonically_ordered_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_11243 (h0 : add_monoid (preorder empty)) : add_monoid.fg (preorder empty) := sorry --non-trivial
lemma new_lemma_11244 (h0 : topological_space (boolean_algebra.core ennreal)) : totally_separated_space (boolean_algebra.core ennreal) := sorry --non-trivial
lemma new_lemma_11245 (h0 : functor.add_const (topological_space (option ennreal)) pos) : @loc_path_connected_space.{0} (option.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_11246 (h0 : not (filter (left_cancel_semigroup unsigned) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_11247 (h0 : ring (add_comm_monoid (finset pos))) : rank_condition (add_comm_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_11248 (h0 : ring (has_add name)) : is_domain (has_add name) := sorry --non-trivial
lemma new_lemma_11249 (h0 : topological_space (add_cancel_monoid (ring Type))) : path_connected_space (add_cancel_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_11250 (h0 : functor.add_const (function.extfun Type uniform_space) (has_add pos)) : @complete_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) (has_add.{0} pos) h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_11251 (h0 : not (ring (metric_space unsigned) -> false)) : @is_principal_ideal_ring.{0} (metric_space.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (metric_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_11252 (h0 : topological_space (comm_ring (has_ssubset (random_gen linarith.ineq)))) : irreducible_space (comm_ring (has_ssubset (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_11253 (h0 : function.extfun Type group) : @is_cyclic.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_11254 (h0 : functor.add_const (filter (has_Inf linarith.comp)) (ring pos)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_11255 (h0 : ring (normed_comm_ring (option (option num)))) : is_principal_ideal_ring (normed_comm_ring (option (option num))) := sorry --non-trivial
lemma new_lemma_11256 (h0 : topological_space (add_cancel_monoid (option (option (option (option pos)))))) : topological_space.separable_space (add_cancel_monoid (option (option (option (option pos))))) := sorry --non-trivial
lemma new_lemma_11257 (h0 : topological_space (canonically_linear_ordered_add_monoid (has_bot name))) : t0_space (canonically_linear_ordered_add_monoid (has_bot name)) := sorry --non-trivial
lemma new_lemma_11258 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (dlist.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (dlist.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_11259 (h0 : topological_space name) : discrete_topology name := sorry --non-trivial
lemma new_lemma_11260 (h0 : topological_space (ordered_comm_group (option unsigned))) : path_connected_space (ordered_comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_11261 (h0 : ordered_add_comm_monoid (has_pos_part (has_Inf Type))) : archimedean (has_pos_part (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_11262 (h0 : topological_space (canonically_linear_ordered_monoid real)) : path_connected_space (canonically_linear_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_11263 (h0 : ring (has_neg_part (has_add name))) : is_domain (has_neg_part (has_add name)) := sorry --non-trivial
lemma new_lemma_11264 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf real))) : topological_space.separable_space (canonically_linear_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_11265 (h0 : complete_lattice (has_neg (add_comm_monoid (has_add environment.implicit_infer_kind)))) : is_compactly_generated (has_neg (add_comm_monoid (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_11266 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_to_string empty)) := sorry --non-trivial
lemma new_lemma_11267 (h2 : not (group (comm_ring char) -> false)) : @is_cyclic.{0} (comm_ring.{0} char) (@classical.by_contradiction'.{1} (group.{0} (comm_ring.{0} char)) h2)  := sorry --non-trivial
lemma new_lemma_11268 (h2 : ring (has_nnnorm (simple_graph (add_cancel_comm_monoid linarith.comp_source)))) : strong_rank_condition (has_nnnorm (simple_graph (add_cancel_comm_monoid linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_11269 (h0 : topological_space (add_left_cancel_monoid (has_norm num))) : path_connected_space (add_left_cancel_monoid (has_norm num)) := sorry --non-trivial
lemma new_lemma_11270 (h0 h1 : multiset (semi_normed_ring string_imp)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_11271 (h0 : functor.add_const (function.extfun Type group) pos) : @is_simple_group.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_11272 (h0 : functor.add_const (add_group (comm_group Type)) name) : @is_add_cyclic.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (comm_group.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_11273 (h0 : list (semigroup linarith.comp)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_11274 (h0 : not (function.extfun Type topological_space -> false)) : @topological_space.separable_space.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_11275 (h0 : fin has_zero.zero) : @archimedean.{0} (has_bot.{0} linarith.comp) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (has_bot.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_11276 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_11277 (h0 : functor.add_const (monoid (has_to_string Type)) environment.implicit_infer_kind) : @monoid.fg.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (has_to_string.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_11278 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (distrib_lattice.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} h0 (distrib_lattice.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_11279 (h0 : topological_space (linear_ordered_add_comm_group (random_gen (comm_ring linarith.ineq)))) : irreducible_space (linear_ordered_add_comm_group (random_gen (comm_ring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_11280 (h0 : ring (add_cancel_comm_monoid empty)) : rank_condition (add_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_11281 (h0 : function.extfun Type ring) : @rank_condition.{0} (filter.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (filter.{0} num))  := sorry --non-trivial
lemma new_lemma_11282 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_11283 (h0 : ring (has_neg_part (has_neg_part Type))) : is_domain (has_neg_part (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_11284 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_11285 (h0 : functor.add_const (topological_space (semigroup unsigned)) (option unsigned)) : @t0_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_11286 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_11287 (h0 : functor.add_const (function.extfun Type ring) (option (option empty))) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (option.{0} (option.{0} empty)) h0) (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_11288 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_11289 (h0 : complete_lattice (metric_space (has_one unsigned))) : is_atomistic (metric_space (has_one unsigned)) := sorry --non-trivial
lemma new_lemma_11290 (h0 : uniform_space (has_nndist name)) : separated_space (has_nndist name) := sorry --non-trivial
lemma new_lemma_11291 (h0 : topological_space (normed_group (has_top linarith.comp_source))) : path_connected_space (normed_group (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_11292 (h0 : finset (boolean_algebra (has_add environment.implicit_infer_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_11293 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (semiring.{0} (has_bot.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_11294 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_nndist congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_11295 (h0 : complete_lattice (semiring (has_norm (has_norm linarith.comp)))) : complete_lattice.is_Sup_finite_compact (semiring (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_11296 (h0 : group (boolean_algebra (finset linarith.comp))) : normalizer_condition (boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_11297 (h0 : functor.add_const (function.extfun Type ring) (has_zero pos)) : @rank_condition.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (has_zero.{0} pos) h0) (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_11298 (h0 : topological_space (has_compl linarith.ineq)) : t0_space (has_compl linarith.ineq) := sorry --non-trivial
lemma new_lemma_11299 (h0 : complete_lattice (comm_group (option (option (option name))))) : is_compactly_generated (comm_group (option (option (option name)))) := sorry --non-trivial
lemma new_lemma_11300 (h0 : complete_lattice (simple_graph (mul_one_class linarith.ineq))) : complete_lattice.is_Sup_finite_compact (simple_graph (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_11301 (h0 : ordered_add_comm_monoid (complete_distrib_lattice (option empty))) : archimedean (complete_distrib_lattice (option empty)) := sorry --non-trivial
lemma new_lemma_11302 (h1 : complete_lattice (div_inv_monoid string_imp)) : complete_lattice.is_Sup_finite_compact (div_inv_monoid string_imp) := sorry --non-trivial
lemma new_lemma_11303 (h0 : functor.comp ring add_left_cancel_monoid to_additive.value_type) : @strong_rank_condition.{0} (add_left_cancel_monoid.{0} to_additive.value_type) (@functor.comp.run.{0 0 0} ring.{0} add_left_cancel_monoid.{0} to_additive.value_type h0)  := sorry --non-trivial
lemma new_lemma_11304 (h0 : ring (linear_ordered_add_comm_group linarith.comp_source)) : rank_condition (linear_ordered_add_comm_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_11305 (h0 : functor.add_const (topological_space (has_to_string Type)) pos) : @totally_separated_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_11306 (h0 : topological_space (linear_ordered_comm_ring num)) : normal_space (linear_ordered_comm_ring num) := sorry --non-trivial
lemma new_lemma_11307 (h0 : topological_space (has_Inf (has_Inf (has_Inf pos)))) : totally_disconnected_space (has_Inf (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_11308 (h0 : not (topological_space (simple_graph char) -> false)) : @t0_space.{0} (simple_graph.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (simple_graph.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_11309 (h0 : complete_lattice (add_comm_monoid (option empty))) : is_atomistic (add_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_11310 (h0 : group (comm_group (has_to_string (has_neg_part pos)))) : normalizer_condition (comm_group (has_to_string (has_neg_part pos))) := sorry --non-trivial
lemma new_lemma_11311 (h0 : topological_space (normed_lattice_add_comm_group (sub_neg_monoid real))) : regular_space (normed_lattice_add_comm_group (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_11312 (h0 : topological_space (ordered_comm_ring (has_add real))) : t1_space (ordered_comm_ring (has_add real)) := sorry --non-trivial
lemma new_lemma_11313 (h0 : topological_space (with_bot (has_norm num))) : totally_separated_space (with_bot (has_norm num)) := sorry --non-trivial
lemma new_lemma_11314 (h0 : add_group (has_to_string (option pos))) : is_add_cyclic (has_to_string (option pos)) := sorry --non-trivial
lemma new_lemma_11315 (h0 : functor.add_const (group (ordered_comm_ring linarith.comp)) Type) : @is_simple_group.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (ordered_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_11316 (h0 : topological_space (canonically_linear_ordered_monoid (has_neg name))) : t1_space (canonically_linear_ordered_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_11317 (h0 : uniform_space (semigroup (has_add Type))) : separated_space (semigroup (has_add Type)) := sorry --non-trivial
lemma new_lemma_11318 (h0 : topological_space (normed_comm_ring ennreal)) : regular_space (normed_comm_ring ennreal) := sorry --non-trivial
lemma new_lemma_11319 (h0 : add_group (has_nndist (comm_monoid unsigned))) : is_add_cyclic (has_nndist (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_11320 (h0 : topological_space (denumerable (has_inv (has_inv fun_info)))) : totally_disconnected_space (denumerable (has_inv (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_11321 (h0 : list (ordered_cancel_add_comm_monoid (comm_monoid unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_11322 (h0 : ring (has_add (has_add linarith.comp))) : is_domain (has_add (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_11323 (h0 : uniform_space (add_comm_monoid (ring (has_nndist (finset (finset (ring linarith.comp))))))) : complete_space (add_comm_monoid (ring (has_nndist (finset (finset (ring linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_11324 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_Sup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_11325 (h1 : topological_space nat) : totally_disconnected_space nat := sorry --non-trivial
lemma new_lemma_11326 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_11327 (h0 : uniform_space (topological_space (has_nnnorm char))) : complete_space (topological_space (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_11328 (h0 : uniform_space (has_nndist num)) : separated_space (has_nndist num) := sorry --non-trivial
lemma new_lemma_11329 (h0 : topological_space (semigroup (has_add linarith.comp))) : t0_space (semigroup (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_11330 (h0 : topological_space (has_well_founded pos)) : sequential_space (has_well_founded pos) := sorry --non-trivial
lemma new_lemma_11331 (h0 : has_mem.mem (has_emptyc num) has_emptyc.emptyc) : @is_cyclic.{0} (has_emptyc.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (has_emptyc.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_11332 (h0 : functor.add_const (monoid (normed_comm_ring name)) environment.implicit_infer_kind) : @monoid.fg.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (normed_comm_ring.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_11333 (h0 : topological_space (measurable_space name)) : t0_space (measurable_space name) := sorry --non-trivial
lemma new_lemma_11334 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) pos) : @discrete_topology.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_11335 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) pos) : @t1_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_11336 (h0 : complete_lattice (simple_graph (has_add pos))) : complete_lattice.is_Sup_finite_compact (simple_graph (has_add pos)) := sorry --non-trivial
lemma new_lemma_11337 (h1 : set (has_ssubset string_imp)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_11338 (h0 : topological_space (has_add to_additive.value_type)) : totally_disconnected_space (has_add to_additive.value_type) := sorry --non-trivial
lemma new_lemma_11339 (h0 : functor.add_const (topological_space (has_Inf pos)) (has_pos_part linarith.comp)) : @preconnected_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) (has_pos_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_11340 (h0 : not (has_mem.mem (complete_semilattice_Sup linarith.comp_source) has_emptyc.emptyc -> false)) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type add_group.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_11341 (h0 : set (simple_graph (mul_one_class (mul_one_class fun_info)))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_11342 (h0 : topological_space (non_assoc_semiring num)) : irreducible_space (non_assoc_semiring num) := sorry --non-trivial
lemma new_lemma_11343 (h0 : functor.add_const (ring (has_nndist environment.implicit_infer_kind)) pos) : @is_domain.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_11344 (h0 : ring (uniform_space (mul_one_class (mul_one_class (mul_one_class char))))) : is_domain (uniform_space (mul_one_class (mul_one_class (mul_one_class char)))) := sorry --non-trivial
lemma new_lemma_11345 (h0 : group (has_add (has_add Type))) : is_simple_group (has_add (has_add Type)) := sorry --non-trivial
lemma new_lemma_11346 (h0 : complete_lattice (has_append (has_nnnorm linarith.comp_source))) : is_compactly_generated (has_append (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_11347 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_11348 (h0 : topological_space (has_zero (comm_group (ring (comm_group name))))) : loc_path_connected_space (has_zero (comm_group (ring (comm_group name)))) := sorry --non-trivial
lemma new_lemma_11349 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_11350 (h0 : ring (has_pos_part (ring (ring linarith.comp)))) : is_principal_ideal_ring (has_pos_part (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_11351 (h0 : ring (ring (option pos))) : strong_rank_condition (ring (option pos)) := sorry --non-trivial
lemma new_lemma_11352 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_11353 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_principal_ideal_ring.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (ordered_comm_ring.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_11354 (h0 : function.extfun Type ring) : @rank_condition.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_11355 (h1 : has_mem.mem (complete_semilattice_Sup congr_arg_kind) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (complete_semilattice_Sup.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_11356 (h0 : function.extfun Type (functor.add_const (ring (omega_complete_partial_order empty)))) : @is_domain.{0} (omega_complete_partial_order.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (omega_complete_partial_order.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (omega_complete_partial_order.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_11357 (h1 : topological_space (normed_group (has_inv to_additive.value_type))) : irreducible_space (normed_group (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_11358 (h0 : preorder (add_comm_semigroup fun_info)) (h2 : Prop) : set.is_pwo (id (fun (h1 : add_comm_semigroup fun_info), h2)) := sorry --non-trivial
lemma new_lemma_11359 (h0 : ring (has_dist num)) : is_domain (has_dist num) := sorry --non-trivial
lemma new_lemma_11360 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (sub_neg_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_11361 (h0 : topological_space (id to_additive.value_type)) : t0_space (id to_additive.value_type) := sorry --non-trivial
lemma new_lemma_11362 (h0 : topological_space (has_Inf (has_Inf linarith.comp))) : totally_separated_space (has_Inf (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_11363 (h0 : functor.add_const (list (boolean_algebra Type)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_11364 (h0 : filter (pseudo_metric_space (option unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_11365 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_11366 (h0 : not (group (random_gen char) -> false)) : @is_cyclic.{0} (random_gen.{0} char) (@classical.by_contradiction'.{1} (group.{0} (random_gen.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_11367 (h0 : filter (add_comm_monoid (option (option empty)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_11368 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) num)  := sorry --non-trivial
lemma new_lemma_11369 (h0 : topological_space (with_bot (has_norm (random_gen linarith.ineq)))) : t0_space (with_bot (has_norm (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_11370 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_11371 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_11372 (h1 : ring (has_top (has_norm (has_inv to_additive.value_type)))) : rank_condition (has_top (has_norm (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_11373 (h0 : functor.add_const (ring (generalized_boolean_algebra pos)) (ordered_ring (has_add name))) : @strong_rank_condition.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (generalized_boolean_algebra.{0} pos)) (ordered_ring.{0} (has_add.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_11374 (h0 : topological_space (has_add (has_Inf (has_bot (has_add linarith.comp))))) : t0_space (has_add (has_Inf (has_bot (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_11375 (h0 : canonically_ordered_add_monoid congr_arg_kind -> canonically_ordered_add_monoid congr_arg_kind) (h1 : functor.add_const (list (canonically_ordered_add_monoid congr_arg_kind)) empty) : list.nodup (list.modify_last h0 (functor.add_const.run h1)) := sorry --non-trivial
lemma new_lemma_11376 (h0 : functor.add_const (topological_space (comm_group Type)) Type) : @regular_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (comm_group.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_11377 (h0 : functor.add_const (topological_space (has_pos_part empty)) empty) : @irreducible_space.{0} (has_pos_part.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_11378 (h0 : function.extfun Type (prod name)) : id_rel (function.extfun_app h0 name) := sorry --non-trivial
lemma new_lemma_11379 (h0 : topological_space (plift (bin_tree (semiring (semiring empty))))) : discrete_topology (plift (bin_tree (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_11380 (h0 : filter (has_zero (comm_group Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_11381 (h0 : functor.add_const (topological_space (comm_group ennreal)) unsigned) : @discrete_topology.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_11382 (h0 : fin has_zero.zero) : @regular_space.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_11383 (h0 : topological_space (random_gen (has_top linarith.ineq))) : discrete_topology (random_gen (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_11384 (h1 : ring congr_arg_kind) : rank_condition congr_arg_kind := sorry --non-trivial
lemma new_lemma_11385 (h0 : functor.add_const (topological_space (linear_ordered_comm_group empty)) unsigned) : @preirreducible_space.{0} (linear_ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_group.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_11386 (h0 : functor.add_const (add_monoid (has_add unsigned)) unsigned) : @add_monoid.fg.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_add.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_11387 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_11388 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_11389 (h0 : add_group (nondiscrete_normed_field (normed_field reducibility_hints))) : is_add_cyclic (nondiscrete_normed_field (normed_field reducibility_hints)) := sorry --non-trivial
lemma new_lemma_11390 (h0 : topological_space (semiring (ordered_ring unsigned))) : loc_path_connected_space (semiring (ordered_ring unsigned)) := sorry --non-trivial
lemma new_lemma_11391 (h0 : topological_space (has_pos_part (has_add (has_Inf linarith.comp)))) : regular_space (has_pos_part (has_add (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_11392 (h0 : function.extfun (Type 1) ordered_comm_monoid) : @has_exists_mul_of_le.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} h0 (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_11393 (h0 : topological_space (canonically_ordered_comm_semiring linarith.comp)) : path_connected_space (canonically_ordered_comm_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_11394 (h0 : topological_space (ring name)) : preconnected_space (ring name) := sorry --non-trivial
lemma new_lemma_11395 (h0 : add_monoid (complete_semilattice_Sup (has_top empty))) : add_monoid.fg (complete_semilattice_Sup (has_top empty)) := sorry --non-trivial
lemma new_lemma_11396 (h0 : functor.add_const (monoid (semigroup unsigned)) linarith.comp) : @monoid.fg.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (semigroup.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_11397 (h0 : ring (has_Inf (has_add name))) : is_principal_ideal_ring (has_Inf (has_add name)) := sorry --non-trivial
lemma new_lemma_11398 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_11399 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @sequential_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_11400 (h0 : topological_space (ordered_comm_ring (ring pos))) : locally_compact_space (ordered_comm_ring (ring pos)) := sorry --non-trivial
lemma new_lemma_11401 (h0 : topological_space (has_nndist (finset name))) : loc_path_connected_space (has_nndist (finset name)) := sorry --non-trivial
lemma new_lemma_11402 (h0 : list (free_add_monoid (ordered_ring unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_11403 (h0 : topological_space (has_nndist pos)) : topological_space.separable_space (has_nndist pos) := sorry --non-trivial
lemma new_lemma_11404 (h0 : topological_space (finset (option pos))) : irreducible_space (finset (option pos)) := sorry --non-trivial
lemma new_lemma_11405 (h1 : topological_space (uniform_space string_imp)) : t0_space (uniform_space string_imp) := sorry --non-trivial
lemma new_lemma_11406 (h0 : functor.add_const (function.extfun Type complete_lattice) (has_add (has_add pos))) : @is_atomistic.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) (has_add.{0} (has_add.{0} pos)) h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_11407 (h0 : finset (has_neg num) -> finset (has_neg num) -> Prop) : reflexive h0 := sorry --non-trivial
lemma new_lemma_11408 (h0 : group (has_top fun_info)) : is_cyclic (has_top fun_info) := sorry --non-trivial
lemma new_lemma_11409 (h0 : functor.add_const (topological_space (has_Sup empty)) num) : @loc_path_connected_space.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_11410 (h0 : ordered_comm_monoid (ordered_comm_ring (has_neg (has_neg name)))) : has_exists_mul_of_le (ordered_comm_ring (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_11411 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_11412 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_11413 (h0 : ring (has_one (semiring empty))) : rank_condition (has_one (semiring empty)) := sorry --non-trivial
lemma new_lemma_11414 (h0 : group (normed_comm_ring (has_to_string (has_to_string unsigned)))) : is_simple_group (normed_comm_ring (has_to_string (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_11415 (h0 : topological_space (has_neg (ring pos))) : locally_compact_space (has_neg (ring pos)) := sorry --non-trivial
lemma new_lemma_11416 (h0 : complete_lattice (generalized_boolean_algebra name)) : is_compactly_generated (generalized_boolean_algebra name) := sorry --non-trivial
lemma new_lemma_11417 (h0 : functor.add_const (topological_space (has_neg_part ennreal)) pos) : @normal_space.{0} (has_neg_part.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_11418 (h0 : pseudo_metric_space (has_zero unsigned)) (h1 : function.extfun Type add_monoid) : @has_lipschitz_add.{0} (has_zero.{0} unsigned) h0 (@function.extfun_app.{2 1} Type add_monoid.{0} h1 (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_11419 (h0 : topological_space (bin_tree (semiring congr_arg_kind))) : t1_space (bin_tree (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_11420 (h0 : functor.add_const (complete_lattice (add_cancel_monoid unsigned)) environment.implicit_infer_kind) : @is_compactly_generated.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_11421 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_11422 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (complete_linear_order.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (complete_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_11423 (h1 : topological_space (distrib linarith.ineq)) : totally_disconnected_space (distrib linarith.ineq) := sorry --non-trivial
lemma new_lemma_11424 (h0 : topological_space (complete_distrib_lattice (cancel_monoid name))) : t1_space (complete_distrib_lattice (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_11425 (h0 : semiring (ordered_comm_ring (has_Inf (has_bot Type)))) : is_noetherian_ring (ordered_comm_ring (has_Inf (has_bot Type))) := sorry --non-trivial
lemma new_lemma_11426 (h0 : topological_space (has_one congr_arg_kind)) : irreducible_space (has_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_11427 (h0 : group (boolean_algebra (comm_semigroup real))) : normalizer_condition (boolean_algebra (comm_semigroup real)) := sorry --non-trivial
lemma new_lemma_11428 (h0 : group (normed_group (semiring (semiring (semiring (semiring unsigned)))))) : group.fg (normed_group (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_11429 (h0 : ordered_add_comm_monoid (finset (has_Inf (has_pos_part pos)))) : archimedean (finset (has_Inf (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_11430 (h0 : topological_space (div_inv_monoid (has_inv linarith.ineq))) : path_connected_space (div_inv_monoid (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_11431 (h0 : functor.add_const (complete_lattice (non_assoc_semiring empty)) (semiring empty)) : @complete_lattice.is_Sup_finite_compact.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (non_assoc_semiring.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_11432 (h0 : group (has_to_string ennreal)) : is_cyclic (has_to_string ennreal) := sorry --non-trivial
lemma new_lemma_11433 (h0 : functor.add_const (functor.add_const (uniform_space linarith.comp) linarith.comp) pos) : @complete_space.{0} linarith.comp (@functor.add_const.run.{0 0} (uniform_space.{0} linarith.comp) linarith.comp (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (uniform_space.{0} linarith.comp) linarith.comp) pos h0))  := sorry --non-trivial
lemma new_lemma_11434 (h0 : complete_lattice (has_dist (option (option ennreal)))) : is_atomistic (has_dist (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_11435 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen linarith.comp))) : @path_connected_space.{0} (random_gen.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_11436 (h0 : fin has_zero.zero) : @archimedean.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (ordered_add_comm_monoid.{1} (has_bot.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_11437 (h0 : functor.add_const (topological_space (simple_graph Type)) pos) : @preconnected_space.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (simple_graph.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_11438 (h0 : functor.add_const (group (measurable_space.dynkin_system congr_arg_kind)) (semiring (semiring (semiring num)))) : @is_cyclic.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (measurable_space.dynkin_system.{0} congr_arg_kind)) (semiring.{0} (semiring.{0} (semiring.{0} num))) h0)  := sorry --non-trivial
lemma new_lemma_11439 (h0 : topological_space (measurable_space.dynkin_system (semiring unsigned))) : t0_space (measurable_space.dynkin_system (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_11440 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (simple_graph.{0} (has_Inf.{0} linarith.comp)) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (simple_graph.{0} (has_Inf.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_11441 (h0 : ordered_comm_monoid (ring (normed_comm_ring (has_add linarith.comp)))) : has_exists_mul_of_le (ring (normed_comm_ring (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_11442 (h0 : topological_space (denumerable fun_info)) : t0_space (denumerable fun_info) := sorry --non-trivial
lemma new_lemma_11443 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_11444 (h0 : ordered_comm_monoid (complete_distrib_lattice (has_neg (has_Inf Type)))) : has_exists_mul_of_le (complete_distrib_lattice (has_neg (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_11445 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_11446 (h0 : finset (option (option (option name)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_11447 (h0 : functor.add_const (topological_space (has_to_string Type)) name) : @topological_space.separable_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_11448 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_11449 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_11450 (h0 : monoid (has_inter unsigned)) : monoid.fg (has_inter unsigned) := sorry --non-trivial
lemma new_lemma_11451 (h0 : ring (sub_neg_monoid (has_neg name))) : is_principal_ideal_ring (sub_neg_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_11452 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (linear_order.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_order.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_11453 (h0 : functor.add_const (topological_space (bin_tree congr_arg_kind)) congr_arg_kind) : @discrete_topology.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_11454 (h0 : topological_space (normed_lattice_add_comm_group (has_add (has_add pos)))) : t0_space (normed_lattice_add_comm_group (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_11455 (h0 : group (add_comm_monoid (boolean_algebra Type))) : is_cyclic (add_comm_monoid (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_11456 (h0 : ring (has_norm linarith.comp)) : is_domain (has_norm linarith.comp) := sorry --non-trivial
lemma new_lemma_11457 (h0 : ring (linear_ordered_comm_group unsigned)) : strong_rank_condition (linear_ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_11458 (h1 : not (add_group (dlist char) -> false)) : @is_add_cyclic.{0} (dlist.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (dlist.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_11459 (h0 : functor.add_const (semiring (has_to_string environment.implicit_infer_kind)) linarith.comp) : @is_noetherian_ring.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (semiring.{0} (has_to_string.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_11460 (h0 : functor.add_const (ring (has_zero Type)) (has_neg Type)) : @is_domain.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (has_zero.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_11461 (h0 : functor.add_const (complete_lattice (boolean_algebra.core empty)) (option unsigned)) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.core.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} empty)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_11462 (h0 : function.extfun Type group) : @is_cyclic.{0} (left_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (left_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_11463 (h0 : complete_lattice (has_neg_part (comm_group (add_comm_monoid (comm_group (comm_group unsigned)))))) : is_atomistic (has_neg_part (comm_group (add_comm_monoid (comm_group (comm_group unsigned))))) := sorry --non-trivial
lemma new_lemma_11464 (h0 : functor.comp topological_space normed_comm_ring name) : @t1_space.{0} (normed_comm_ring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} normed_comm_ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_11465 (h0 : ring (has_add (random_gen (random_gen linarith.ineq)))) : is_domain (has_add (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_11466 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) unsigned) : @archimedean.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) unsigned h0) (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_11467 (h0 : topological_space (complete_distrib_lattice congr_arg_kind)) : preirreducible_space (complete_distrib_lattice congr_arg_kind) := sorry --non-trivial
lemma new_lemma_11468 (h0 : group (encodable fun_info)) : group.fg (encodable fun_info) := sorry --non-trivial
lemma new_lemma_11469 (h0 : semiring (has_neg (option (option pos)))) : is_noetherian_ring (has_neg (option (option pos))) := sorry --non-trivial
lemma new_lemma_11470 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_11471 (h2 : not (add_group (random_gen linarith.comp_source) -> false)) : @is_add_cyclic.{0} (random_gen.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (add_group.{0} (random_gen.{0} linarith.comp_source)) h2)  := sorry --non-trivial
lemma new_lemma_11472 (h0 : topological_space (add_comm_monoid (has_neg linarith.comp))) : discrete_topology (add_comm_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_11473 (h1 : ring (has_ssubset enat)) : is_domain (has_ssubset enat) := sorry --non-trivial
lemma new_lemma_11474 (h0 : functor.add_const (function.extfun Type monoid) environment.implicit_infer_kind) : monoid.fg real := sorry --non-trivial
lemma new_lemma_11475 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (finset.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_11476 (h0 : add_group (has_to_string (add_cancel_monoid Type))) : is_add_cyclic (has_to_string (add_cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_11477 (h0 : not (ring (has_inv fun_info) -> false)) : @rank_condition.{0} (has_inv.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (has_inv.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_11478 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (finset.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (finset.{0} num))  := sorry --non-trivial
lemma new_lemma_11479 (h0 : add_group (has_nnnorm (has_div string.iterator_imp))) : is_add_cyclic (has_nnnorm (has_div string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_11480 (h0 : filter (has_neg_part (has_neg_part (has_neg_part (comm_group (has_neg_part Type)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_11481 (h0 : function.extfun Type topological_space) : @normal_space.{0} (measurable_space.{0} (has_norm.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} (has_norm.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_11482 (h0 : group (finset unsigned)) : group.fg (finset unsigned) := sorry --non-trivial
lemma new_lemma_11483 (h0 : topological_space (measurable_space (has_norm (semiring empty)))) : discrete_topology (measurable_space (has_norm (semiring empty))) := sorry --non-trivial
lemma new_lemma_11484 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @preirreducible_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_11485 (h0 : list (semigroup (ring (semigroup environment.implicit_infer_kind)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_11486 (h0 : uniform_space (has_neg linarith.comp)) : complete_space (has_neg linarith.comp) := sorry --non-trivial
lemma new_lemma_11487 (h0 : functor.add_const (topological_space (comm_semigroup real)) name) : @t1_space.{0} (comm_semigroup.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_semigroup.{0} real)) name h0)  := sorry --non-trivial
lemma new_lemma_11488 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_11489 (h0 : function.extfun Type preorder) (h1 : linarith.comp_source -> set (measurable_space num)) : @filter.is_antitone_basis.{0 0} (measurable_space.{0} num) linarith.comp_source (@function.extfun_app.{2 1} Type preorder.{0} h0 linarith.comp_source) h1  := sorry --non-trivial
lemma new_lemma_11490 (h1 : ring (semi_normed_comm_ring (semi_normed_ring string_imp))) : strong_rank_condition (semi_normed_comm_ring (semi_normed_ring string_imp)) := sorry --non-trivial
lemma new_lemma_11491 (h0 : not (topological_space (has_norm num) -> false)) : @irreducible_space.{0} (has_norm.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_11492 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (ordered_comm_ring.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_11493 (h0 : topological_space (has_scalar Type (has_add environment.implicit_infer_kind))) : normal_space (has_scalar Type (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_11494 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) pos) : @sequential_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_11495 (h0 : functor.add_const (topological_space (bin_tree congr_arg_kind)) congr_arg_kind) : @locally_compact_space.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_11496 (h0 : functor.add_const (list (semigroup name)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_11497 (h0 : not (group (semi_normed_ring (has_nnnorm reducibility_hints)) -> false)) : @is_cyclic.{0} (semi_normed_ring.{0} (has_nnnorm.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (group.{0} (semi_normed_ring.{0} (has_nnnorm.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_11498 (h0 : uniform_space (canonically_ordered_add_monoid (option empty))) : complete_space (canonically_ordered_add_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_11499 (h0 : function.extfun Type topological_space) : @t1_space.{0} (as_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (as_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_11500 (h0 : ring (has_top (metric_space empty))) : rank_condition (has_top (metric_space empty)) := sorry --non-trivial
lemma new_lemma_11501 (h0 : topological_space (linear_ordered_semiring linarith.ineq)) : t0_space (linear_ordered_semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_11502 (h0 : function.extfun Type ring) : @is_domain.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_11503 (h1 : complete_lattice (dlist to_additive.value_type)) : is_compactly_generated (dlist to_additive.value_type) := sorry --non-trivial
lemma new_lemma_11504 (h0 : topological_space (add_comm_monoid (has_add Type))) : normal_space (add_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_11505 (h0 : add_group (add_comm_monoid (add_comm_monoid pos))) : is_add_cyclic (add_comm_monoid (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_11506 (h0 : topological_space (semigroup (has_pos_part (finset (finset Type))))) : t0_space (semigroup (has_pos_part (finset (finset Type)))) := sorry --non-trivial
lemma new_lemma_11507 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (pseudo_metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (pseudo_metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_11508 (h0 : semiring (id (semiring empty))) : is_noetherian_ring (id (semiring empty)) := sorry --non-trivial
lemma new_lemma_11509 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_11510 (h0 : add_group (random_gen (random_gen (has_nnnorm char)))) : is_add_cyclic (random_gen (random_gen (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_11511 (h0 : ring (boolean_algebra.core (option (option (option (option (option num))))))) : is_domain (boolean_algebra.core (option (option (option (option (option num)))))) := sorry --non-trivial
lemma new_lemma_11512 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_11513 (h0 : functor.add_const (topological_space (has_neg ennreal)) ennreal) : @topological_space.separable_space.{0} (has_neg.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_11514 (h0 : topological_space (simple_graph (has_add linarith.comp))) : irreducible_space (simple_graph (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_11515 (h0 : uniform_space (mul_one_class char)) : complete_space (mul_one_class char) := sorry --non-trivial
lemma new_lemma_11516 (h1 : topological_space (has_top linarith.ineq)) : path_connected_space (has_top linarith.ineq) := sorry --non-trivial
lemma new_lemma_11517 (h0 : ring (semi_normed_comm_ring (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm char)))))) : rank_condition (semi_normed_comm_ring (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm char))))) := sorry --non-trivial
lemma new_lemma_11518 (h0 : group (has_neg num)) : is_cyclic (has_neg num) := sorry --non-trivial
lemma new_lemma_11519 (h1 : topological_space (distrib string_imp)) : path_connected_space (distrib string_imp) := sorry --non-trivial
lemma new_lemma_11520 (h2 : set (add_comm_semigroup (mul_one_class std_gen) -> mul_one_class char)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_11521 (h0 : topological_space (finset (boolean_algebra Type))) : t0_space (finset (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_11522 (h0 : topological_space (has_to_string (has_to_string (has_neg_part Type)))) : t0_space (has_to_string (has_to_string (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_11523 (h0 : topological_space (add_comm_monoid (finset pos))) : preconnected_space (add_comm_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_11524 (h0 : functor.comp list finset pos) : list.nodup (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_11525 (h0 : add_group (has_compl to_additive.value_type)) : is_add_cyclic (has_compl to_additive.value_type) := sorry --non-trivial
lemma new_lemma_11526 (h0 : functor.add_const (finset (boolean_algebra.core Type)) ennreal) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_11527 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_inv.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_inv.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_11528 (h0 : ring (omega_complete_partial_order empty)) : strong_rank_condition (omega_complete_partial_order empty) := sorry --non-trivial
lemma new_lemma_11529 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (option.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (option.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_11530 (h0 : add_group (comm_semigroup (sub_neg_monoid (canonically_linear_ordered_monoid Type)))) : is_add_cyclic (comm_semigroup (sub_neg_monoid (canonically_linear_ordered_monoid Type))) := sorry --non-trivial
lemma new_lemma_11531 (h0 : complete_lattice (id fun_info)) : is_compactly_generated (id fun_info) := sorry --non-trivial
lemma new_lemma_11532 (h0 : topological_space (has_to_string unsigned)) : irreducible_space (has_to_string unsigned) := sorry --non-trivial
lemma new_lemma_11533 (h1 : set (linarith.ineq -> nondiscrete_normed_field char)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_11534 (h0 : topological_space (normed_lattice_add_comm_group pos)) : topological_space.separable_space (normed_lattice_add_comm_group pos) := sorry --non-trivial
lemma new_lemma_11535 (h0 : functor.add_const (complete_lattice (generalized_boolean_algebra linarith.comp)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (generalized_boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_11536 (h1 : complete_lattice (add_cancel_comm_monoid string_imp)) : complete_lattice.is_Sup_finite_compact (add_cancel_comm_monoid string_imp) := sorry --non-trivial
lemma new_lemma_11537 (h0 : functor.add_const (uniform_space (has_to_string linarith.comp)) (ring (has_neg pos))) : @separated_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_to_string.{0} linarith.comp)) (ring.{0} (has_neg.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_11538 (h0 : monoid (normed_lattice_add_comm_group (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid pos))))) : monoid.fg (normed_lattice_add_comm_group (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid pos)))) := sorry --non-trivial
lemma new_lemma_11539 (h0 : not (topological_space (with_one empty) -> false)) : @t0_space.{0} (with_one.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_11540 (h0 : functor.add_const (add_group (semigroup linarith.comp)) pos) : @is_add_cyclic.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_11541 (h0 : ordered_comm_monoid (finset (option (option unsigned)))) : has_exists_mul_of_le (finset (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_11542 (h0 : topological_space (distrib (has_ssubset (has_ssubset linarith.comp_source)))) (h1 : punit) : path_connected_space (distrib (has_ssubset (has_ssubset linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_11543 (h0 : functor.add_const (function.extfun Type topological_space) (has_add (has_add (ring (has_add linarith.comp))))) : @loc_path_connected_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_add.{0} (has_add.{0} (ring.{0} (has_add.{0} linarith.comp)))) h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_11544 (h0 : ring (denumerable (comm_ring char))) : is_domain (denumerable (comm_ring char)) := sorry --non-trivial
lemma new_lemma_11545 (h0 : group (has_zero (comm_group (comm_group name)))) : normalizer_condition (has_zero (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_11546 (h0 : topological_space (has_norm (random_gen empty))) : path_connected_space (has_norm (random_gen empty)) := sorry --non-trivial
lemma new_lemma_11547 (h0 : environment.projection_info -> multiset (nondiscrete_normed_field linarith.ineq)) (h1 : multiset (nondiscrete_normed_field linarith.ineq)) : multiset.subset (finsum h0) h1 := sorry --non-trivial
lemma new_lemma_11548 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_11549 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_domain.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ring.{0}) (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_11550 (h0 : topological_space (canonically_linear_ordered_monoid (has_neg pos))) : loc_path_connected_space (canonically_linear_ordered_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_11551 (h0 : filter (has_zero (has_add Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_11552 (h0 : filter (mul_zero_class (boolean_algebra.core Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_11553 (h1 : function.extfun Type (prod (add_right_cancel_monoid empty))) : id_rel (function.extfun_app h1 (add_right_cancel_monoid empty)) := sorry --non-trivial
lemma new_lemma_11554 (h0 : semiring (finset unsigned)) : is_noetherian_ring (finset unsigned) := sorry --non-trivial
lemma new_lemma_11555 (h0 : functor.add_const (finset (semigroup pos)) (finset environment.implicit_infer_kind)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_11556 (h0 : topological_space nnreal) : locally_compact_space nnreal := sorry --non-trivial
lemma new_lemma_11557 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) pos) : @preconnected_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_11558 (h0 : topological_space (ring (semigroup Type))) : discrete_topology (ring (semigroup Type)) := sorry --non-trivial
lemma new_lemma_11559 (h0 : topological_space (ordered_comm_ring pos)) : totally_separated_space (ordered_comm_ring pos) := sorry --non-trivial
lemma new_lemma_11560 (h0 : ring (canonically_linear_ordered_monoid (ordered_comm_monoid (has_add real)))) : rank_condition (canonically_linear_ordered_monoid (ordered_comm_monoid (has_add real))) := sorry --non-trivial
lemma new_lemma_11561 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (linear_order.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_11562 (h0 : topological_space (has_Sup unsigned)) : loc_path_connected_space (has_Sup unsigned) := sorry --non-trivial
lemma new_lemma_11563 (h0 : list (has_nndist (option (option (option (option (option (option (option empty))))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_11564 (h0 : topological_space (has_top (semiring (semiring congr_arg_kind)))) : locally_compact_space (has_top (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_11565 (h0 : linarith.ineq -> linarith.ineq -> Prop) : is_trans linarith.ineq h0 := sorry --non-trivial
lemma new_lemma_11566 (h0 : group (complete_distrib_lattice (finset Type))) : is_simple_group (complete_distrib_lattice (finset Type)) := sorry --non-trivial
lemma new_lemma_11567 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normal_space.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_11568 (h0 : topological_space (canonically_ordered_comm_semiring congr_arg_kind)) : preconnected_space (canonically_ordered_comm_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_11569 (h0 : functor.add_const (complete_lattice (left_cancel_monoid empty)) (option empty)) : @is_atomistic.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_11570 (h0 : group (has_emptyc (random_gen linarith.comp_source))) : is_cyclic (has_emptyc (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_11571 (h0 : add_group (canonically_linear_ordered_monoid (has_Inf real))) : is_add_cyclic (canonically_linear_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_11572 (h1 : not (topological_space (has_ssubset reducibility_hints) -> false)) : @t0_space.{0} (has_ssubset.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} reducibility_hints)) h1)  := sorry --non-trivial
lemma new_lemma_11573 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (semigroup name)) := sorry --non-trivial
lemma new_lemma_11574 (h0 : uniform_space real.angle) : complete_space real.angle := sorry --non-trivial
lemma new_lemma_11575 (h0 : functor.add_const (function.extfun (Type 1) ring) pos) : @is_principal_ideal_ring.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) pos h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_11576 (h0 h1 : list (add_comm_semigroup (add_comm_semigroup linarith.ineq))) : list.is_infix h0 h1 := sorry --non-trivial
lemma new_lemma_11577 (h0 : topological_space (has_nnnorm string_imp)) : path_connected_space (has_nnnorm string_imp) := sorry --non-trivial
lemma new_lemma_11578 (h0 : topological_space (mul_zero_class (has_neg_part unsigned))) : locally_compact_space (mul_zero_class (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_11579 (h0 : functor.add_const (topological_space (linear_order unsigned)) empty) : @discrete_topology.{0} (linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_11580 (h0 : function.extfun Type ring) : @rank_condition.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_11581 (h0 : topological_space (has_edist (option (option (option empty))))) : totally_disconnected_space (has_edist (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_11582 (h0 : ordered_comm_monoid (ordered_comm_monoid (has_neg (boolean_algebra.core Type)))) : has_exists_mul_of_le (ordered_comm_monoid (has_neg (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_11583 (h0 : functor.add_const (group (has_neg name)) Type) : @is_simple_group.{0} (has_neg.{0} name) (@functor.add_const.run.{0 1} (group.{0} (has_neg.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_11584 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (generalized_boolean_algebra.{0} (has_add.{0} pos)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} (has_add.{0} pos)))  := sorry --non-trivial
lemma new_lemma_11585 (h0 : topological_space (comm_group Type)) : discrete_topology (comm_group Type) := sorry --non-trivial
lemma new_lemma_11586 (h0 : add_monoid (with_bot empty)) : add_monoid.fg (with_bot empty) := sorry --non-trivial
lemma new_lemma_11587 (h0 : has_lt (mul_one_class string.iterator_imp)) : no_max_order (mul_one_class string.iterator_imp) := sorry --non-trivial
lemma new_lemma_11588 (h0 : group (boolean_algebra (has_add (boolean_algebra (has_add Type))))) : normalizer_condition (boolean_algebra (has_add (boolean_algebra (has_add Type)))) := sorry --non-trivial
lemma new_lemma_11589 (h0 : ring (add_right_cancel_monoid (semiring (semiring (semiring unsigned))))) : is_domain (add_right_cancel_monoid (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_11590 (h0 : add_monoid ereal) (h1 : add_submonoid ereal) : add_submonoid.fg h1 := sorry --non-trivial
lemma new_lemma_11591 (h0 : functor.add_const (topological_space (ordered_ring congr_arg_kind)) unsigned) : @topological_space.separable_space.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_11592 (h7 : ring linarith.comp_source) : is_domain linarith.comp_source := sorry --non-trivial
lemma new_lemma_11593 (h0 : monoid (boolean_algebra (finset pos))) : monoid.fg (boolean_algebra (finset pos)) := sorry --non-trivial
lemma new_lemma_11594 (h1 : has_lt (mul_one_class char)) : no_min_order (mul_one_class char) := sorry --non-trivial
lemma new_lemma_11595 (h0 : ring (fintype (has_nnnorm (has_nnnorm to_additive.value_type)))) : is_domain (fintype (has_nnnorm (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_11596 (h0 : functor.add_const (topological_space (preorder congr_arg_kind)) empty) : @irreducible_space.{0} (preorder.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_11597 (h0 : set (mul_one_class (mul_one_class enat))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_11598 (h0 : functor.add_const (semiring (generalized_boolean_algebra Type)) (ring linarith.comp)) : @is_noetherian_ring.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (generalized_boolean_algebra.{1} Type)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_11599 (h0 : not (topological_space (has_emptyc to_additive.value_type) -> false)) : @path_connected_space.{0} (has_emptyc.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_11600 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_11601 (h0 : topological_space (id (semiring empty)) -> empty) (h1 : not (coe_sort (set.range h0) -> false)) : @preirreducible_space.{0} (@id.{2} Type (semiring.{0} empty)) (@set.range_splitting.{0 0} (topological_space.{0} (@id.{2} Type (semiring.{0} empty))) empty h0 (@classical.by_contradiction'.{1} (@coe_sort.{1 2} (set.{0} empty) Type (@set.has_coe_to_sort.{0} empty) (@set.range.{0 1} empty (topological_space.{0} (@id.{2} Type (semiring.{0} empty))) h0)) h1))  := sorry --non-trivial
lemma new_lemma_11602 (h0 : semiring (complete_distrib_lattice (add_comm_monoid name))) : is_noetherian_ring (complete_distrib_lattice (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_11603 (h0 : set (ereal -> add_comm_semigroup char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_11604 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @irreducible_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_11605 (h0 : function.extfun Type ring) : @rank_condition.{0} (metric_space.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_11606 (h0 : ring (has_top (has_top unsigned))) : is_domain (has_top (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_11607 (h0 : topological_space (add_cancel_monoid (option pos))) : t0_space (add_cancel_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_11608 (h0 : topological_space (linear_order (semiring empty))) : totally_disconnected_space (linear_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_11609 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_11610 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (semigroup.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} num)) (option.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (semigroup.{0} num))) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.add_const.{0 0} (topological_space.{0} (semigroup.{0} num)))) (option.{0} (option.{0} unsigned))))  := sorry --non-trivial
lemma new_lemma_11611 (h0 : add_group (has_neg_part (has_neg_part Type))) : is_add_cyclic (has_neg_part (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_11612 (h0 h1 : multiset (uniform_space (mul_one_class string_imp))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_11613 (h1 : topological_space (linear_ordered_comm_group_with_zero (has_nnnorm linarith.ineq))) : totally_disconnected_space (linear_ordered_comm_group_with_zero (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_11614 (h0 : functor.comp group has_to_string Type) : @is_cyclic.{1} (has_to_string.{1} Type) (@functor.comp.run.{1 1 1} group.{1} has_to_string.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_11615 (h0 : functor.add_const (topological_space (has_to_string pos)) environment.implicit_infer_kind) : @loc_path_connected_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_11616 (h0 : add_group (nondiscrete_normed_field (mul_one_class (mul_one_class environment.projection_info)))) : is_add_cyclic (nondiscrete_normed_field (mul_one_class (mul_one_class environment.projection_info))) := sorry --non-trivial
lemma new_lemma_11617 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_bot.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_11618 (h0 : not (ring (has_sub unsigned) -> false)) : @is_domain.{0} (has_sub.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (has_sub.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_11619 (h1 : complete_lattice (topological_space (has_nnnorm char))) : is_compactly_generated (topological_space (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_11620 (h0 : ring (normed_group (random_gen (random_gen fun_info)))) : is_domain (normed_group (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_11621 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) (has_Inf pos)) : @preirreducible_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_11622 (h0 : ring (add_cancel_monoid (has_to_string (has_add pos)))) : rank_condition (add_cancel_monoid (has_to_string (has_add pos))) := sorry --non-trivial
lemma new_lemma_11623 (h0 : functor.add_const (complete_lattice (non_assoc_semiring empty)) num) : @is_compactly_generated.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (non_assoc_semiring.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_11624 (h0 : ring (ordered_comm_ring linarith.comp)) : strong_rank_condition (ordered_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_11625 (h0 : not (ring (has_one num) -> false)) : @is_domain.{0} (has_one.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (has_one.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_11626 (h0 : add_group (comm_ring (group_with_zero (random_gen (random_gen string_imp))))) : is_add_cyclic (comm_ring (group_with_zero (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_11627 (h0 : ordered_add_comm_monoid (add_comm_monoid (option (option (option empty))))) : archimedean (add_comm_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_11628 (h0 : uniform_space (linear_ordered_add_comm_group (random_gen (random_gen (random_gen string_imp))))) : complete_space (linear_ordered_add_comm_group (random_gen (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_11629 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (normed_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_11630 (h0 : not (ring (partial_order congr_arg_kind) -> false)) : @strong_rank_condition.{0} (partial_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (partial_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_11631 (h0 : not (topological_space (uniform_space (mul_one_class (mul_one_class linarith.ineq))) -> false)) : @t0_space.{0} (uniform_space.{0} (mul_one_class.{0} (mul_one_class.{0} linarith.ineq))) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} (mul_one_class.{0} (mul_one_class.{0} linarith.ineq)))) h0)  := sorry --non-trivial
lemma new_lemma_11632 (h2 : group (topological_space char)) : is_cyclic (topological_space char) := sorry --non-trivial
lemma new_lemma_11633 (h0 : group (add_cancel_monoid (has_neg_part (has_add (has_neg_part Type))))) : normalizer_condition (add_cancel_monoid (has_neg_part (has_add (has_neg_part Type)))) := sorry --non-trivial
lemma new_lemma_11634 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) Type) : @normal_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_11635 (h1 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : totally_separated_space empty := sorry --non-trivial
lemma new_lemma_11636 (h0 : topological_space (normed_group linarith.comp)) : locally_compact_space (normed_group linarith.comp) := sorry --non-trivial
lemma new_lemma_11637 (h0 : functor.add_const (list (canonically_linear_ordered_monoid Type)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_11638 (h0 : functor.add_const (uniform_space (simple_graph pos)) pos) : @separated_space.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (simple_graph.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_11639 (h0 : topological_space (canonically_linear_ordered_monoid (option pos))) : sequential_space (canonically_linear_ordered_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_11640 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} string_imp (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) string_imp)  := sorry --non-trivial
lemma new_lemma_11641 (h0 : ring (dlist (comm_ring linarith.ineq))) : rank_condition (dlist (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_11642 (h0 : topological_space (left_cancel_semigroup (semiring num))) : locally_compact_space (left_cancel_semigroup (semiring num)) := sorry --non-trivial
lemma new_lemma_11643 (h0 : functor.add_const (ring (left_cancel_monoid num)) (semiring unsigned)) : @rank_condition.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} num)) (semiring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_11644 (h0 : topological_space (linear_ordered_add_comm_group num)) : totally_separated_space (linear_ordered_add_comm_group num) := sorry --non-trivial
lemma new_lemma_11645 (h0 : topological_space (add_cancel_monoid (has_add unsigned))) : normal_space (add_cancel_monoid (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_11646 (h1 : uniform_space (uniform_space linarith.ineq)) : complete_space (uniform_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_11647 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_principal_ideal_ring.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_11648 (h0 : ring (linear_ordered_semiring (semiring congr_arg_kind))) : is_principal_ideal_ring (linear_ordered_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_11649 (h0 : group (linear_ordered_comm_ring num)) : is_cyclic (linear_ordered_comm_ring num) := sorry --non-trivial
lemma new_lemma_11650 (h0 : topological_space (has_top (normed_group (random_gen (random_gen linarith.comp_source))))) : totally_disconnected_space (has_top (normed_group (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_11651 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_11652 (h0 : topological_space (linear_ordered_semiring fun_info)) : irreducible_space (linear_ordered_semiring fun_info) := sorry --non-trivial
lemma new_lemma_11653 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_11654 (h0 : group (canonically_ordered_monoid (has_Inf Type))) : is_simple_group (canonically_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_11655 (h0 : functor.add_const (topological_space (has_to_string name)) pos) : @discrete_topology.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_11656 (h0 : ring (has_nndist (add_comm_monoid unsigned))) : rank_condition (has_nndist (add_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_11657 (h1 : uniform_space (random_gen (has_nnnorm char))) : complete_space (random_gen (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_11658 (h0 : topological_space (has_inter num)) : totally_disconnected_space (has_inter num) := sorry --non-trivial
lemma new_lemma_11659 (h0 : topological_space (complete_distrib_lattice real)) : discrete_topology (complete_distrib_lattice real) := sorry --non-trivial
lemma new_lemma_11660 (h0 : topological_space (semiring (has_norm empty))) : t0_space (semiring (has_norm empty)) := sorry --non-trivial
lemma new_lemma_11661 (h0 : topological_space (boolean_algebra (has_add (has_add name)))) : path_connected_space (boolean_algebra (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_11662 (h0 : list (normed_group congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_11663 (h0 : functor.add_const (monoid (bin_tree empty)) num) : @monoid.fg.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (bin_tree.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_11664 (h0 : functor.add_const (topological_space (boolean_algebra.core environment.implicit_infer_kind)) linarith.comp) : @normal_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_11665 (h0 : functor.add_const (function.extfun Type semiring) Type) : @is_noetherian_ring.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type semiring.{0}) Type h0) (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_11666 (h0 : prod (ordered_comm_ring pos) (ordered_comm_ring pos)) : set.diagonal (ordered_comm_ring pos) h0 := sorry --non-trivial
lemma new_lemma_11667 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_11668 (h0 : measurable_space (add_comm_semigroup std_gen)) (h1 : has_sup (add_comm_semigroup std_gen)) : has_measurable_sup (add_comm_semigroup std_gen) := sorry --non-trivial
lemma new_lemma_11669 (h0 : complete_lattice (has_norm (random_gen linarith.ineq))) : complete_lattice.is_Sup_finite_compact (has_norm (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_11670 (h0 : topological_space (has_neg_part (has_neg_part (add_comm_monoid Type)))) : normal_space (has_neg_part (has_neg_part (add_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_11671 (h0 : filter (normed_comm_ring (comm_group pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_11672 (h0 : functor.add_const (filter (has_pos_part name)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_11673 (h0 : ring (distrib_lattice (random_gen (random_gen (random_gen to_additive.value_type))))) : is_domain (distrib_lattice (random_gen (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_11674 (h0 : topological_space (metric_space (id (with_bot (id (has_one linarith.comp)))))) : preirreducible_space (metric_space (id (with_bot (id (has_one linarith.comp))))) := sorry --non-trivial
lemma new_lemma_11675 (h0 : not (uniform_space (random_gen char) -> false)) : @complete_space.{0} (random_gen.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (random_gen.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_11676 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (encodable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (encodable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_11677 (h0 : functor.add_const (group (comm_group ennreal)) linarith.comp) : @is_simple_group.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} ennreal)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_11678 (h0 : function.extfun Type group) : @group.fg.{0} (linear_ordered_comm_monoid_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_11679 (h0 : ordered_comm_monoid (has_neg (has_neg (ring (generalized_boolean_algebra (ring pos)))))) : has_exists_mul_of_le (has_neg (has_neg (ring (generalized_boolean_algebra (ring pos))))) := sorry --non-trivial
lemma new_lemma_11680 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_11681 (h0 : functor.add_const (topological_space (has_neg Type)) (ordered_ring linarith.comp)) : @sequential_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) (ordered_ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_11682 (h0 : group (has_to_string (finset (finset pos)))) : group.fg (has_to_string (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_11683 (h0 : topological_space (comm_group (pseudo_metric_space unsigned))) : loc_path_connected_space (comm_group (pseudo_metric_space unsigned)) := sorry --non-trivial
lemma new_lemma_11684 (h0 : uniform_space (denumerable (semi_normed_ring (semi_normed_ring linarith.comp_source)))) : complete_space (denumerable (semi_normed_ring (semi_normed_ring linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_11685 (h0 : ordered_add_comm_monoid (free_add_monoid congr_arg_kind)) : archimedean (free_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_11686 (h0 : ring (boolean_algebra.core Type)) : is_principal_ideal_ring (boolean_algebra.core Type) := sorry --non-trivial
lemma new_lemma_11687 (h0 : functor.add_const (semiring (has_nndist name)) Type) : @is_noetherian_ring.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 1} (semiring.{0} (has_nndist.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_11688 (h0 : topological_space (div_inv_monoid num)) : totally_separated_space (div_inv_monoid num) := sorry --non-trivial
lemma new_lemma_11689 (h0 : group (with_one (semiring empty))) : normalizer_condition (with_one (semiring empty)) := sorry --non-trivial
lemma new_lemma_11690 (h0 : group (has_pos_part (has_Inf (has_neg name)))) : group.fg (has_pos_part (has_Inf (has_neg name))) := sorry --non-trivial
lemma new_lemma_11691 (h0 : semiring (semigroup (mul_one_class linarith.comp))) : is_noetherian_ring (semigroup (mul_one_class linarith.comp)) := sorry --non-trivial
lemma new_lemma_11692 (h0 : functor.add_const (topological_space (ring Type)) environment.implicit_infer_kind) : @normal_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_11693 (h0 : complete_lattice (has_neg (option (option ennreal)))) : is_compactly_generated (has_neg (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_11694 (h0 : functor.add_const (list (add_comm_monoid name)) (finset (has_neg (finset environment.implicit_infer_kind)))) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_11695 (h0 : ordered_comm_monoid (finset (finset (has_Inf pos)))) : has_exists_mul_of_le (finset (finset (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_11696 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (has_one.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_11697 (h0 : functor.add_const (functor.add_const (topological_space Type) pos) pos) : @preirreducible_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) pos (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (topological_space.{1} Type) pos) pos h0))  := sorry --non-trivial
lemma new_lemma_11698 (h0 : functor.add_const (topological_space (has_to_string pos)) name) : @sequential_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_11699 (h0 : monoid (omega_complete_partial_order unsigned)) : monoid.fg (omega_complete_partial_order unsigned) := sorry --non-trivial
lemma new_lemma_11700 (h0 : topological_space (has_to_string (finset environment.implicit_infer_kind))) : path_connected_space (has_to_string (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_11701 (h0 : topological_space (has_bot empty)) : preirreducible_space (has_bot empty) := sorry --non-trivial
lemma new_lemma_11702 (h0 : topological_space (has_inner unsigned unsigned)) : loc_path_connected_space (has_inner unsigned unsigned) := sorry --non-trivial
lemma new_lemma_11703 (h0 : functor.add_const (group (has_Inf linarith.comp)) pos) : @group.fg.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_Inf.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_11704 (h0 : list (normed_linear_ordered_group (option empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_11705 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (linear_ordered_add_comm_group.{0} int) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_add_comm_group.{0} int))  := sorry --non-trivial
lemma new_lemma_11706 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @regular_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_11707 (h0 : topological_space (has_nnnorm string.iterator_imp)) (h1 : measurable_space (has_nnnorm string.iterator_imp)) : opens_measurable_space (has_nnnorm string.iterator_imp) := sorry --non-trivial
lemma new_lemma_11708 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @regular_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_11709 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) (has_add (ring Type))) : @topological_space.separable_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_ring.{0} pos)) (has_add.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_11710 (h0 : ring (add_comm_monoid (has_add (finset (add_comm_monoid Type))))) : strong_rank_condition (add_comm_monoid (has_add (finset (add_comm_monoid Type)))) := sorry --non-trivial
lemma new_lemma_11711 (h0 : has_mem.mem add_monoid has_emptyc.emptyc) : @add_monoid.fg.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type add_monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_monoid.{0} h0) (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_11712 (h0 : functor.comp topological_space has_to_string name) : @preirreducible_space.{0} (has_to_string.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} name h0)  := sorry --non-trivial
lemma new_lemma_11713 (h0 : list (monoid (option (option unsigned)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_11714 (h0 : complete_lattice (has_Inf (semigroup pos))) : complete_lattice.is_Sup_finite_compact (has_Inf (semigroup pos)) := sorry --non-trivial
lemma new_lemma_11715 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) pos) : @loc_path_connected_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_11716 (h0 : functor.comp complete_lattice has_nndist Type) : @complete_lattice.is_Sup_finite_compact.{1} (has_nndist.{1} Type) (@functor.comp.run.{1 1 1} complete_lattice.{1} has_nndist.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_11717 (h1 : has_mem.mem (with_one num) has_emptyc.emptyc) : @monoid.fg.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type monoid.{0} (with_one.{0} num) h1)  := sorry --non-trivial
lemma new_lemma_11718 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (finset.{0} (ring.{0} linarith.comp)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} (ring.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_11719 (h0 : group (complete_semilattice_Sup (has_top unsigned))) : group.fg (complete_semilattice_Sup (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_11720 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_neg.{0} (option.{0} name)) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_neg.{0} (option.{0} name)))  := sorry --non-trivial
lemma new_lemma_11721 (h0 : group (sub_neg_monoid (has_pos_part linarith.comp))) : normalizer_condition (sub_neg_monoid (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_11722 (h0 : topological_space (linear_ordered_field (has_to_string (has_to_string num)))) : normal_space (linear_ordered_field (has_to_string (has_to_string num))) := sorry --non-trivial
lemma new_lemma_11723 (h0 : add_group (linear_ordered_add_comm_group linarith.ineq)) : is_add_cyclic (linear_ordered_add_comm_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_11724 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) (ring Type)) : @t1_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_11725 (h0 : ring (is_R_or_C (semiring (option empty)))) : is_principal_ideal_ring (is_R_or_C (semiring (option empty))) := sorry --non-trivial
lemma new_lemma_11726 (h0 : ordered_comm_monoid (finset (ring name))) : has_exists_mul_of_le (finset (ring name)) := sorry --non-trivial
lemma new_lemma_11727 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (boolean_algebra.core.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_11728 (h0 : has_mem.mem (has_top fun_info) has_emptyc.emptyc) : @is_domain.{0} (has_top.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (has_top.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_11729 (h0 : filter (linear_ordered_cancel_comm_monoid empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_11730 (h0 : function.extfun Type topological_space) : @t0_space.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type topological_space.{0} h0 environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_11731 (h0 : filter (mul_zero_class (finset (has_add (has_add name))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_11732 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_11733 (h0 : ring (has_add (has_neg_part Type))) : is_domain (has_add (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_11734 (h0 : group (monoid (option unsigned))) : group.fg (monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_11735 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (linear_ordered_field (option ennreal))) := sorry --non-trivial
lemma new_lemma_11736 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_11737 (h0 : ordered_comm_monoid (comm_semigroup (has_pos_part real))) : has_exists_mul_of_le (comm_semigroup (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_11738 (h1 : topological_space (measurable_space congr_arg_kind)) : totally_separated_space (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_11739 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_nnnorm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_nnnorm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_11740 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (ordered_comm_monoid.{0} name) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (ordered_comm_monoid.{0} name)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_11741 (h0 : topological_space (measurable_space.dynkin_system num)) : locally_compact_space (measurable_space.dynkin_system num) := sorry --non-trivial
lemma new_lemma_11742 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_comm_semiring ennreal)) : unique_factorization_monoid (canonically_ordered_comm_semiring ennreal) := sorry --non-trivial
lemma new_lemma_11743 (h0 : topological_space (cancel_monoid environment.implicit_infer_kind)) : t0_space (cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_11744 (h1 h2 : multiset (has_compl (mul_one_class (mul_one_class reducibility_hints)))) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_11745 (h0 : complete_lattice (semi_normed_comm_ring linarith.ineq)) : complete_lattice.is_Sup_finite_compact (semi_normed_comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_11746 (h0 : prod (bin_tree (option unsigned)) (bin_tree (option unsigned))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_11747 (h0 : functor.add_const (ordered_comm_monoid (has_Inf name)) (has_neg name)) : @has_exists_mul_of_le.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_Inf.{0} name)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_11748 (h0 : functor.add_const (filter (ring Type)) (has_neg (ring pos))) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_11749 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring empty))) : @is_cyclic.{0} (linear_ordered_semiring.{0} empty) (@finset.pi.empty.{1 0} Type group.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_11750 (h0 : functor.add_const (cancel_comm_monoid_with_zero (semiring num)) num) : @unique_factorization_monoid.{0} (semiring.{0} num) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (semiring.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_11751 (h0 : list (linear_ordered_field (option (option (option (option unsigned)))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_11752 (h0 : ordered_comm_monoid (has_to_string (ordered_comm_ring environment.implicit_infer_kind))) : has_exists_mul_of_le (has_to_string (ordered_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_11753 (h0 : topological_space (complete_semilattice_Sup (random_gen (has_top to_additive.value_type)))) : locally_compact_space (complete_semilattice_Sup (random_gen (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_11754 (h0 : group (has_zero (ring (ring Type)))) : is_simple_group (has_zero (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_11755 (h2 : topological_space (has_ssubset (add_comm_semigroup fun_info))) : totally_disconnected_space (has_ssubset (add_comm_semigroup fun_info)) := sorry --non-trivial
lemma new_lemma_11756 (h0 : list (semigroup (finset (finset (has_pos_part Type))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_11757 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_11758 (h0 : add_group (boolean_algebra pos)) : is_add_cyclic (boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_11759 (h0 : not (topological_space (linear_ordered_semiring (has_top fun_info)) -> false)) : @totally_disconnected_space.{0} (linear_ordered_semiring.{0} (has_top.{0} fun_info)) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} (has_top.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_11760 (h0 : filter (canonically_linear_ordered_monoid (has_add (has_add real)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_11761 (h0 : monoid (random_gen (comm_ring (random_gen to_additive.value_type)))) : monoid.fg (random_gen (comm_ring (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_11762 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_simple_group.{0} (ordered_comm_monoid.{0} name) (@matrix.vec_empty.{0} (group.{0} (ordered_comm_monoid.{0} name)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_11763 (h0 : complete_lattice (pseudo_metric_space congr_arg_kind)) : is_compactly_generated (pseudo_metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_11764 (h2 : topological_space (denumerable (distrib_lattice (random_gen char)))) : totally_disconnected_space (denumerable (distrib_lattice (random_gen char))) := sorry --non-trivial
lemma new_lemma_11765 (h0 : ring (normed_comm_ring (has_add (finset (finset pos))))) : rank_condition (normed_comm_ring (has_add (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_11766 (h0 : topological_space (complete_distrib_lattice linarith.comp)) : totally_separated_space (complete_distrib_lattice linarith.comp) := sorry --non-trivial
lemma new_lemma_11767 (h0 : topological_space (has_norm (has_top to_additive.value_type))) : path_connected_space (has_norm (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_11768 (h0 : topological_space (canonically_linear_ordered_monoid (has_neg_part pos))) : path_connected_space (canonically_linear_ordered_monoid (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_11769 (h0 : has_mem.mem (has_union num) has_emptyc.emptyc) : @normalizer_condition.{0} (has_union.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (has_union.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_11770 (h0 : functor.add_const (topological_space (normed_comm_ring congr_arg_kind)) unsigned) : @preirreducible_space.{0} (normed_comm_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_11771 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) (has_Inf (ring pos))) : @has_exists_mul_of_le.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) (has_Inf.{0} (ring.{0} pos)) h0) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_11772 (h0 : topological_space (semi_normed_comm_ring (mul_one_class fun_info))) : t0_space (semi_normed_comm_ring (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_11773 (h1 : not (ring char -> false)) : @rank_condition.{0} char (@classical.by_contradiction'.{1} (ring.{0} char) h1)  := sorry --non-trivial
lemma new_lemma_11774 (h0 : filter (linear_ordered_add_comm_group (random_gen (random_gen to_additive.value_type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_11775 (h0 : prod (normed_field (mul_one_class reducibility_hints)) (normed_field (mul_one_class reducibility_hints))) : set.diagonal (normed_field (mul_one_class reducibility_hints)) h0 := sorry --non-trivial
lemma new_lemma_11776 (h0 : function.extfun (((Type -> Type) -> Type 1) -> Type 1) (function.extfun ((Type -> Type) -> Type 1))) : @is_compactly_generated.{0} (has_inv.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (@function.extfun_app.{3 3} (((Type → Type) → Type 1) → Type 1) (function.extfun.{3 2} ((Type → Type) → Type 1)) h0 (function.extfun.{2 2} (Type → Type))) (function.extfun.{2 1} Type)) complete_lattice.{0}) (has_inv.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_11777 (h1 : ring (denumerable string_imp)) : is_domain (denumerable string_imp) := sorry --non-trivial
lemma new_lemma_11778 (h0 : ring (has_add (finset Type))) : is_principal_ideal_ring (has_add (finset Type)) := sorry --non-trivial
lemma new_lemma_11779 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_11780 (h0 : functor.add_const (topological_space (has_to_string pos)) Type) : @totally_separated_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_11781 (h1 : not (add_group (has_emptyc linarith.comp) -> false)) : @is_add_cyclic.{0} (has_emptyc.{0} linarith.comp) (@classical.by_contradiction'.{1} (add_group.{0} (has_emptyc.{0} linarith.comp)) h1)  := sorry --non-trivial
lemma new_lemma_11782 (h0 : ordered_add_comm_monoid (finset (option (option pos)))) : archimedean (finset (option (option pos))) := sorry --non-trivial
lemma new_lemma_11783 (h0 : topological_space (has_zero pos)) : normal_space (has_zero pos) := sorry --non-trivial
lemma new_lemma_11784 (h0 : group (has_zero (has_to_string (has_to_string pos)))) : group.fg (has_zero (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_11785 (h0 : ring (ring (has_add pos))) : is_principal_ideal_ring (ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_11786 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_11787 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_11788 (h0 : functor.add_const (add_monoid (ordered_comm_monoid Type)) (has_neg (has_nndist linarith.comp))) : @add_monoid.fg.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (ordered_comm_monoid.{1} Type)) (has_neg.{0} (has_nndist.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_11789 (h0 : add_monoid (random_gen (random_gen unsigned))) : add_monoid.fg (random_gen (random_gen unsigned)) := sorry --non-trivial
lemma new_lemma_11790 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_11791 (h0 : functor.add_const (ring (normed_linear_ordered_group empty)) empty) : @is_domain.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (normed_linear_ordered_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_11792 (h0 h1 : option (topological_space (comm_group (has_neg (semigroup (has_neg (has_neg linarith.comp))))))) (h2 : topological_space (comm_group (has_neg (semigroup (has_neg (has_neg linarith.comp)))))) : loc_path_connected_space (comm_group (has_neg (semigroup (has_neg (has_neg linarith.comp))))) := sorry --non-trivial
lemma new_lemma_11793 (h0 : has_neg (nondiscrete_normed_field (add_comm_semigroup environment.projection_info))) (h1 : measurable_space (nondiscrete_normed_field (add_comm_semigroup environment.projection_info))) : has_measurable_neg (nondiscrete_normed_field (add_comm_semigroup environment.projection_info)) := sorry --non-trivial
lemma new_lemma_11794 (h0 : group (finset (has_add (has_Inf (has_add name))))) : group.fg (finset (has_add (has_Inf (has_add name)))) := sorry --non-trivial
lemma new_lemma_11795 (h0 : topological_space (add_cancel_monoid ennreal)) : path_connected_space (add_cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_11796 (h0 : not (ring (with_one unsigned) -> false)) : @is_domain.{0} (with_one.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (with_one.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_11797 (h1 : add_group (linear_ordered_add_comm_group reducibility_hints)) : is_add_cyclic (linear_ordered_add_comm_group reducibility_hints) := sorry --non-trivial
lemma new_lemma_11798 (h0 : function.extfun (Type 1) monoid) : @monoid.fg.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} h0 (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_11799 (h0 : group (normed_lattice_add_comm_group (has_Inf (has_add Type)))) : group.fg (normed_lattice_add_comm_group (has_Inf (has_add Type))) := sorry --non-trivial
lemma new_lemma_11800 (h0 : has_mem.mem (has_union congr_arg_kind) has_emptyc.emptyc) : @normalizer_condition.{0} (has_union.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type group.{0} (has_union.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_11801 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (normed_comm_ring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_11802 (h0 : functor.add_const (ring (left_cancel_semigroup num)) empty) : @is_domain.{0} (left_cancel_semigroup.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_semigroup.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_11803 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) (has_Inf pos)) : @regular_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_ring.{1} Type)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_11804 (h0 : functor.add_const (ring (has_add pos)) pos) : @strong_rank_condition.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_11805 (h0 : function.extfun (has_top (has_inv linarith.comp_source)) (fun (x : has_top (has_inv linarith.comp_source)), Prop)) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) (has_top.{0} (has_inv.{0} linarith.comp_source)) (@function.extfun_app.{1 1} (has_top.{0} (has_inv.{0} linarith.comp_source)) (λ (x : has_top.{0} (has_inv.{0} linarith.comp_source)), Prop) h0)  := sorry --non-trivial
lemma new_lemma_11806 (h0 : topological_space (id (comm_ring (random_gen (random_gen to_additive.value_type))))) : locally_compact_space (id (comm_ring (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_11807 (h0 : topological_space (generalized_boolean_algebra (has_Inf Type))) : preconnected_space (generalized_boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_11808 (h0 : group (denumerable linarith.comp_source)) : normalizer_condition (denumerable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_11809 (h0 : topological_space (random_gen empty)) : discrete_topology (random_gen empty) := sorry --non-trivial
lemma new_lemma_11810 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_11811 (h0 : group (dlist (has_inv linarith.comp_source))) : normalizer_condition (dlist (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_11812 (h0 : fin has_zero.zero) : @group.fg.{0} (has_bot.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (has_bot.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_11813 (h0 : complete_lattice (with_bot (has_top (has_top (has_top fun_info))))) : is_atomistic (with_bot (has_top (has_top (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_11814 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) environment.implicit_infer_kind) : @unique_factorization_monoid.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) environment.implicit_infer_kind h0) (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_11815 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_11816 (h0 : functor.add_const (topological_space (has_to_string Type)) pos) : @regular_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_11817 (h0 : functor.comp ring mul_zero_class name) : @strong_rank_condition.{0} (mul_zero_class.{0} name) (@functor.comp.run.{0 0 0} ring.{0} mul_zero_class.{0} name h0)  := sorry --non-trivial
lemma new_lemma_11818 (h0 : uniform_space (topological_space (has_ssubset (random_gen to_additive.value_type)))) : complete_space (topological_space (has_ssubset (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_11819 (h0 : topological_space (has_zero (option pos))) : regular_space (has_zero (option pos)) := sorry --non-trivial
lemma new_lemma_11820 (h0 : topological_space (linear_ordered_add_comm_group fun_info)) : t0_space (linear_ordered_add_comm_group fun_info) := sorry --non-trivial
lemma new_lemma_11821 (h0 : topological_space (add_group (has_norm (has_norm (measurable_space empty))))) : irreducible_space (add_group (has_norm (has_norm (measurable_space empty)))) := sorry --non-trivial
lemma new_lemma_11822 (h0 : function.extfun Type topological_space) : @normal_space.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_11823 (h0 : topological_space (has_add (ring (ring environment.implicit_infer_kind)))) : regular_space (has_add (ring (ring environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_11824 (h0 : complete_lattice (has_norm (has_norm congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (has_norm (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_11825 (h0 : functor.add_const (group (canonically_ordered_comm_semiring environment.implicit_infer_kind)) pos) : @is_simple_group.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_11826 (h0 : uniform_space (semigroup (finset (finset (finset (finset pos)))))) : complete_space (semigroup (finset (finset (finset (finset pos))))) := sorry --non-trivial
lemma new_lemma_11827 (h0 : add_group (comm_group (add_comm_monoid environment.implicit_infer_kind))) : is_add_cyclic (comm_group (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_11828 (h0 : functor.add_const (topological_space (has_add name)) linarith.comp) : @t0_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_11829 (h0 : topological_space (canonically_ordered_comm_semiring (option (option name)))) : regular_space (canonically_ordered_comm_semiring (option (option name))) := sorry --non-trivial
lemma new_lemma_11830 (h0 : functor.add_const (topological_space (add_comm_monoid unsigned)) congr_arg_kind) : @topological_space.separable_space.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_11831 (h0 : list (has_emptyc (has_top (has_top linarith.comp_source)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_11832 (h0 : functor.add_const (topological_space (ordered_ring num)) congr_arg_kind) : @normal_space.{0} (ordered_ring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_11833 (h0 : topological_space (random_gen (has_norm (has_norm (has_norm linarith.comp))))) : discrete_topology (random_gen (has_norm (has_norm (has_norm linarith.comp)))) := sorry --non-trivial
lemma new_lemma_11834 (h0 : topological_space (has_bot empty)) : locally_compact_space (has_bot empty) := sorry --non-trivial
lemma new_lemma_11835 (h0 : not (group (topological_space to_additive.value_type) -> false)) : @is_cyclic.{0} (topological_space.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (topological_space.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_11836 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @separated_space.{1} (has_Inf.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (has_Inf.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_11837 (h0 : has_mem.mem (random_gen congr_arg_kind) has_emptyc.emptyc) : @is_compactly_generated.{0} (random_gen.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_11838 (h0 : ring (linear_ordered_semiring (has_norm to_additive.value_type))) : strong_rank_condition (linear_ordered_semiring (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_11839 (h0 : functor.add_const (ordered_add_comm_monoid (has_pos_part linarith.comp)) (ring (has_add linarith.comp))) : @archimedean.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_pos_part.{0} linarith.comp)) (ring.{0} (has_add.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_11840 (h0 : with_bot Prop) (h1 : ne h0 has_bot.bot) : id (id (id (with_bot.unbot h0 h1))) := sorry --non-trivial
lemma new_lemma_11841 (h0 : monoid (normed_lattice_add_comm_group (has_bot Type))) : monoid.fg (normed_lattice_add_comm_group (has_bot Type)) := sorry --non-trivial
lemma new_lemma_11842 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_11843 (h0 : not (group (partial_order (semiring (semiring (semiring (semiring (semiring empty)))))) -> false)) : @is_cyclic.{0} (partial_order.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))))) (@classical.by_contradiction'.{1} (group.{0} (partial_order.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty))))))) h0)  := sorry --non-trivial
lemma new_lemma_11844 (h4 : complete_lattice (add_monoid linarith.ineq)) : complete_lattice.is_Sup_finite_compact (add_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_11845 (h5 : topological_space linarith.comp_source) : path_connected_space linarith.comp_source := sorry --non-trivial
lemma new_lemma_11846 (h0 : functor.add_const (finset (has_pos_part Type)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_11847 (h0 : add_monoid (normed_group (has_norm (has_norm (has_norm linarith.comp))))) : add_monoid.fg (normed_group (has_norm (has_norm (has_norm linarith.comp)))) := sorry --non-trivial
lemma new_lemma_11848 (h1 : topological_space (distrib (has_ssubset (has_nnnorm (has_nnnorm fun_info))))) : totally_disconnected_space (distrib (has_ssubset (has_nnnorm (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_11849 (h0 : topological_space (has_emptyc (has_norm num))) : totally_separated_space (has_emptyc (has_norm num)) := sorry --non-trivial
lemma new_lemma_11850 (h0 : topological_space (group_with_zero num)) : irreducible_space (group_with_zero num) := sorry --non-trivial
lemma new_lemma_11851 (h0 : complete_lattice (has_Inf (has_add real))) : is_compactly_generated (has_Inf (has_add real)) := sorry --non-trivial
lemma new_lemma_11852 (h0 : ring (complete_distrib_lattice (has_add Type))) : is_principal_ideal_ring (complete_distrib_lattice (has_add Type)) := sorry --non-trivial
lemma new_lemma_11853 (h0 : ring (has_nnnorm (mul_one_class fun_info))) : rank_condition (has_nnnorm (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_11854 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_11855 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (is_R_or_C empty)) := sorry --non-trivial
lemma new_lemma_11856 (h0 : group (ordered_semiring linarith.comp_source)) : group.fg (ordered_semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_11857 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_11858 (h0 : group (has_Sup (option (semiring empty)))) : normalizer_condition (has_Sup (option (semiring empty))) := sorry --non-trivial
lemma new_lemma_11859 (h0 : fin has_zero.zero) : @preconnected_space.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_11860 (h0 : topological_space (non_unital_non_assoc_semiring environment.projection_info)) : totally_disconnected_space (non_unital_non_assoc_semiring environment.projection_info) := sorry --non-trivial
lemma new_lemma_11861 (h0 : add_monoid (has_to_string (has_to_string ennreal))) : add_monoid.fg (has_to_string (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_11862 (h0 : topological_space (distrib_lattice fun_info)) : t0_space (distrib_lattice fun_info) := sorry --non-trivial
lemma new_lemma_11863 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_11864 (h0 : ordered_add_comm_monoid (has_zero linarith.comp)) : archimedean (has_zero linarith.comp) := sorry --non-trivial
lemma new_lemma_11865 (h0 : topological_space (finset (has_add Type))) : t1_space (finset (has_add Type)) := sorry --non-trivial
lemma new_lemma_11866 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_11867 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_11868 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_11869 (h0 : functor.add_const (semiring (ring name)) (has_pos_part (has_add (has_Inf linarith.comp)))) : @is_noetherian_ring.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (ring.{0} name)) (has_pos_part.{0} (has_add.{0} (has_Inf.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_11870 (h0 : topological_space (id (has_norm empty))) : totally_separated_space (id (has_norm empty)) := sorry --non-trivial
lemma new_lemma_11871 (h0 : add_group (has_add (has_add (ring linarith.comp)))) : is_add_cyclic (has_add (has_add (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_11872 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_11873 (h0 : has_mem.mem (normed_group linarith.comp) has_emptyc.emptyc) : @rank_condition.{0} (normed_group.{0} linarith.comp) (@finset.pi.empty.{1 0} Type ring.{0} (normed_group.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_11874 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_11875 (h0 : functor.add_const (finset (has_Inf pos)) (has_nndist Type)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_11876 (h0 : complete_lattice (has_ssubset (random_gen linarith.ineq))) : complete_lattice.is_Sup_finite_compact (has_ssubset (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_11877 (h0 : topological_space (ring (add_comm_monoid environment.implicit_infer_kind))) : t1_space (ring (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_11878 (h0 : complete_lattice (complete_semilattice_Sup string_imp)) : complete_lattice.is_Sup_finite_compact (complete_semilattice_Sup string_imp) := sorry --non-trivial
lemma new_lemma_11879 (h0 : topological_space (comm_group (has_add (has_add name)))) : regular_space (comm_group (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_11880 (h0 : topological_space (normed_comm_ring linarith.comp)) : normal_space (normed_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_11881 (h0 : add_group (filter (semiring (semiring (semiring (semiring empty)))))) : is_add_cyclic (filter (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_11882 (h0 : topological_space (uniform_space (mul_one_class (mul_one_class string.iterator_imp)))) : totally_disconnected_space (uniform_space (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_11883 (h0 : ring (has_neg_part congr_arg_kind)) : is_principal_ideal_ring (has_neg_part congr_arg_kind) := sorry --non-trivial
lemma new_lemma_11884 (h0 : uniform_space (pseudo_metric_space congr_arg_kind)) : separated_space (pseudo_metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_11885 (h1 : topological_space (denumerable (random_gen to_additive.value_type))) : path_connected_space (denumerable (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_11886 (h0 : not (filter (add_right_cancel_monoid linarith.comp) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_11887 (h0 : filter (bin_tree (semiring congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_11888 (h0 : ring (linear_ordered_semiring (has_norm num))) : is_domain (linear_ordered_semiring (has_norm num)) := sorry --non-trivial
lemma new_lemma_11889 (h0 : topological_space (random_gen (has_norm (has_norm (has_norm (has_norm empty)))))) : discrete_topology (random_gen (has_norm (has_norm (has_norm (has_norm empty))))) := sorry --non-trivial
lemma new_lemma_11890 (h0 : functor.add_const (function.extfun Type uniform_space) num) : @complete_space.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) num h0) (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_11891 (h0 : list (ring (has_append char))) (h1 : nat) (h2 : has_lt.lt h1 (list.length h0)) : @rank_condition.{0} (has_append.{0} char) (@list.nth_le.{0} (ring.{0} (has_append.{0} char)) h0 h1 h2)  := sorry --non-trivial
lemma new_lemma_11892 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_11893 (h0 : functor.add_const (uniform_space (has_neg_part Type)) environment.implicit_infer_kind) : @complete_space.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_neg_part.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_11894 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (complete_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_11895 (h0 : ordered_comm_monoid (has_add (has_Inf real))) : has_exists_mul_of_le (has_add (has_Inf real)) := sorry --non-trivial
lemma new_lemma_11896 (h0 : topological_space (semigroup (semiring empty))) : topological_space.separable_space (semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_11897 (h0 : topological_space (has_Inf (has_add (has_add Type)))) : preconnected_space (has_Inf (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_11898 (h0 : complete_lattice (id (semiring congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (id (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_11899 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} string_imp (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) string_imp)  := sorry --non-trivial
lemma new_lemma_11900 (h1 : group (random_gen congr_arg_kind)) : is_cyclic (random_gen congr_arg_kind) := sorry --non-trivial
lemma new_lemma_11901 (h0 : functor.add_const (group (add_cancel_monoid pos)) (has_to_string (has_neg linarith.comp))) : @normalizer_condition.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} pos)) (has_to_string.{0} (has_neg.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_11902 (h0 : topological_space linarith.comp_source) : irreducible_space linarith.comp_source := sorry --non-trivial
lemma new_lemma_11903 (h1 : filter (has_append to_additive.value_type)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_11904 (h0 : topological_space (partial_order empty)) : totally_disconnected_space (partial_order empty) := sorry --non-trivial
lemma new_lemma_11905 (h0 : topological_space (linear_ordered_add_comm_group (random_gen fun_info))) : t0_space (linear_ordered_add_comm_group (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_11906 (h0 : functor.add_const (cancel_comm_monoid_with_zero (left_cancel_monoid empty)) num) : @unique_factorization_monoid.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (left_cancel_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_11907 (h0 : topological_space (has_add (has_pos_part (has_pos_part pos)))) : sequential_space (has_add (has_pos_part (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_11908 (h0 : functor.add_const (add_group (ring ennreal)) ennreal) : @is_add_cyclic.{0} (ring.{0} ennreal) (@functor.add_const.run.{0 0} (add_group.{0} (ring.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_11909 (h0 : function.extfun Type group) : @normalizer_condition.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_11910 (h0 : semiring (linear_ordered_comm_group (option (option (option empty))))) : is_noetherian_ring (linear_ordered_comm_group (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_11911 (h1 : filter (fintype string_imp)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_11912 (h1 : ring (has_div string_imp)) : strong_rank_condition (has_div string_imp) := sorry --non-trivial
lemma new_lemma_11913 (h0 : topological_space (has_norm (semiring (has_norm fun_info)))) : discrete_topology (has_norm (semiring (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_11914 (h0 : ring (has_nndist (has_add ennreal))) : is_principal_ideal_ring (has_nndist (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_11915 (h0 : function.extfun (Type 1) topological_space) : @t1_space.{1} (has_bot.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_bot.{1} Type))  := sorry --non-trivial
lemma new_lemma_11916 (h0 : function.extfun Type (functor.comp uniform_space add_comm_monoid)) : @complete_space.{0} (add_comm_monoid.{0} name) (@functor.comp.run.{0 0 0} uniform_space.{0} add_comm_monoid.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} uniform_space.{0} add_comm_monoid.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_11917 (h0 : topological_space (has_to_string (has_add unsigned))) : t1_space (has_to_string (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_11918 (h0 : functor.add_const (group (semigroup Type)) (comm_group (has_add pos))) : @normalizer_condition.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (semigroup.{1} Type)) (comm_group.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_11919 (h1 : complete_lattice (has_norm (has_top linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (has_norm (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_11920 (h0 : semiring (sub_neg_monoid (has_Inf linarith.comp))) : is_noetherian_ring (sub_neg_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_11921 (h0 : complete_lattice (mul_one_class (metric_space char))) : is_compactly_generated (mul_one_class (metric_space char)) := sorry --non-trivial
lemma new_lemma_11922 (h0 : functor.add_const (topological_space (add_comm_monoid environment.implicit_infer_kind)) Type) : @t1_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_11923 (h0 : topological_space (has_le linarith.ineq)) : totally_disconnected_space (has_le linarith.ineq) := sorry --non-trivial
lemma new_lemma_11924 (h0 : functor.add_const (list (has_neg linarith.comp)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_11925 (h0 : cancel_comm_monoid_with_zero (normed_group (plift unsigned))) : unique_factorization_monoid (normed_group (plift unsigned)) := sorry --non-trivial
lemma new_lemma_11926 (h0 : function.extfun Type monoid) : @monoid.fg.{0} fun_info (@function.extfun_app.{2 1} Type monoid.{0} h0 fun_info)  := sorry --non-trivial
lemma new_lemma_11927 (h0 : functor.add_const (ordered_comm_monoid (ordered_comm_monoid Type)) linarith.comp) : @has_exists_mul_of_le.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (ordered_comm_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_11928 (h0 : topological_space (normed_comm_ring (finset environment.implicit_infer_kind))) : irreducible_space (normed_comm_ring (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_11929 (h0 : functor.add_const (topological_space (has_to_string name)) name) : @normal_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_11930 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} auto.case_option (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) auto.case_option)  := sorry --non-trivial
lemma new_lemma_11931 (h0 : functor.add_const (complete_lattice (has_add Type)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_add.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_11932 (h0 : ring (canonically_ordered_add_monoid unsigned)) : strong_rank_condition (canonically_ordered_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_11933 (h0 : list (topological_space (has_le linarith.comp_source))) : @totally_disconnected_space.{0} (has_le.{0} linarith.comp_source) (@list.ilast.{0} (topological_space.{0} (has_le.{0} linarith.comp_source)) (@inhabited_topological_space.{0} (has_le.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_11934 (h0 : topological_space (canonically_linear_ordered_monoid (option num))) : totally_disconnected_space (canonically_linear_ordered_monoid (option num)) := sorry --non-trivial
lemma new_lemma_11935 (h0 : prod (has_nndist unsigned) (has_nndist unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_11936 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_11937 (h0 : filter (comm_group pos)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_11938 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (ring.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ring.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_11939 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf real))) : topological_space.separable_space (normed_lattice_add_comm_group (has_Inf real)) := sorry --non-trivial
lemma new_lemma_11940 (h0 : has_add (add_comm_monoid name) -> has_add (add_comm_monoid name) -> Prop) : well_founded h0 := sorry --non-trivial
lemma new_lemma_11941 (h0 : functor.add_const (monoid (linear_ordered_cancel_comm_monoid empty)) unsigned) : @monoid.fg.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_11942 (h0 : ring (with_one (has_top to_additive.value_type))) : is_domain (with_one (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_11943 (h0 : complete_lattice (comm_group (finset name))) : is_compactly_generated (comm_group (finset name)) := sorry --non-trivial
lemma new_lemma_11944 (h0 : functor.add_const (ring (generalized_boolean_algebra pos)) (has_neg pos)) : @is_principal_ideal_ring.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (generalized_boolean_algebra.{0} pos)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_11945 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_11946 (h0 : filter (has_inv (random_gen (random_gen (random_gen (random_gen linarith.ineq)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_11947 (h0 : measurable_space std_gen) (h1 : has_sub std_gen) : has_measurable_sub₂ std_gen := sorry --non-trivial
lemma new_lemma_11948 (h0 : functor.add_const (finset (add_comm_monoid environment.implicit_infer_kind)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_11949 (h0 : ring (canonically_ordered_monoid (finset real))) : is_principal_ideal_ring (canonically_ordered_monoid (finset real)) := sorry --non-trivial
lemma new_lemma_11950 (h0 : function.extfun Type (functor.add_const (functor.add_const (complete_lattice (linear_order empty)) empty))) : @is_compactly_generated.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_order.{0} empty)) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (complete_lattice.{0} (linear_order.{0} empty)) empty) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (functor.add_const.{0 0} (complete_lattice.{0} (linear_order.{0} empty)) empty)) h0 num)))  := sorry --non-trivial
lemma new_lemma_11951 (h0 : functor.add_const (topological_space (has_nndist pos)) (has_Inf linarith.comp)) : @irreducible_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_11952 (h0 : group (distrib_lattice (random_gen linarith.comp_source))) : normalizer_condition (distrib_lattice (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_11953 (h0 : topological_space (boolean_algebra (has_add linarith.comp))) : topological_space.separable_space (boolean_algebra (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_11954 (h0 : topological_space (complete_distrib_lattice pos)) : regular_space (complete_distrib_lattice pos) := sorry --non-trivial
lemma new_lemma_11955 (h1 : function.extfun Type topological_space) : @totally_disconnected_space.{0} to_additive.value_type (@function.extfun_app.{2 1} Type topological_space.{0} h1 to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_11956 (h0 : comm_ring (add_cancel_monoid (option ennreal))) : local_ring (add_cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_11957 (h0 : ring (simple_graph (finset Type))) : is_domain (simple_graph (finset Type)) := sorry --non-trivial
lemma new_lemma_11958 (h0 : function.extfun Type topological_space) : @t1_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_11959 (h0 : uniform_space (plift empty)) : complete_space (plift empty) := sorry --non-trivial
lemma new_lemma_11960 (h0 : add_group (linear_ordered_semiring (has_norm linarith.comp))) : is_add_cyclic (linear_ordered_semiring (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_11961 (h0 : ring (uniform_space (id to_additive.value_type))) : strong_rank_condition (uniform_space (id to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_11962 (h0 : topological_space (add_comm_monoid (option unsigned))) : sequential_space (add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_11963 (h0 : complete_lattice linarith.ineq) : is_atomistic linarith.ineq := sorry --non-trivial
lemma new_lemma_11964 (h0 : list (finset (ring (ring (add_left_cancel_monoid (ring (ring (has_add (ring Type))))))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_11965 (h1 : add_group (has_ssubset ereal)) : is_add_cyclic (has_ssubset ereal) := sorry --non-trivial
lemma new_lemma_11966 (h0 : ring (has_to_string (finset Type))) : is_domain (has_to_string (finset Type)) := sorry --non-trivial
lemma new_lemma_11967 (h0 : ring (add_comm_monoid (mul_one_class (has_dist linarith.ineq)))) : is_domain (add_comm_monoid (mul_one_class (has_dist linarith.ineq))) := sorry --non-trivial
lemma new_lemma_11968 (h0 : functor.add_const (filter (has_neg_part linarith.comp)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_11969 (h0 : uniform_space (normed_field string_imp)) : complete_space (normed_field string_imp) := sorry --non-trivial
lemma new_lemma_11970 (h0 : functor.add_const (function.extfun Type group) Type) : @group.fg.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_11971 (h1 : list (linear_ordered_add_comm_group (random_gen string_imp))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_11972 (h0 : topological_space (comm_group linarith.comp)) : path_connected_space (comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_11973 (h0 : ordered_ring (semiring empty) -> ordered_ring (semiring empty) -> Prop) : is_total_preorder (ordered_ring (semiring empty)) h0 := sorry --non-trivial
lemma new_lemma_11974 (h0 : ring (linear_ordered_comm_group_with_zero enat)) : strong_rank_condition (linear_ordered_comm_group_with_zero enat) := sorry --non-trivial
lemma new_lemma_11975 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (linear_ordered_comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_11976 (h0 : complete_lattice (normed_comm_ring (ring environment.implicit_infer_kind))) : complete_lattice.is_Sup_finite_compact (normed_comm_ring (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_11977 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) name) : @t1_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_11978 (h0 : topological_space (comm_monoid (option (option empty)))) : preirreducible_space (comm_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_11979 (h0 : group (finset (finset (has_pos_part environment.implicit_infer_kind)))) : is_cyclic (finset (finset (has_pos_part environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_11980 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_11981 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_11982 (h0 : functor.add_const (topological_space (bin_tree empty)) num) : @discrete_topology.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_11983 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_noetherian_ring.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) semiring.{0}) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_11984 (h0 : monoid (has_to_string ennreal)) : monoid.fg (has_to_string ennreal) := sorry --non-trivial
lemma new_lemma_11985 (h0 : topological_space (has_bot (option (option (option (option (option unsigned))))))) : totally_separated_space (has_bot (option (option (option (option (option unsigned)))))) := sorry --non-trivial
lemma new_lemma_11986 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_11987 (h0 : functor.add_const Prop (has_zero (has_neg pos))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_11988 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem monoid)) : @monoid.fg.{0} (normed_group.{0} (random_gen.{0} (has_top.{0} (has_norm.{0} (has_top.{0} to_additive.value_type))))) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) monoid.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (normed_group.{0} (random_gen.{0} (has_top.{0} (has_norm.{0} (has_top.{0} to_additive.value_type))))))  := sorry --non-trivial
lemma new_lemma_11989 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ring name)) pos) : @unique_factorization_monoid.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_11990 (h0 : monoid (measurable_space (has_emptyc linarith.comp))) : monoid.fg (measurable_space (has_emptyc linarith.comp)) := sorry --non-trivial
lemma new_lemma_11991 (h0 : group (has_norm (has_norm (comm_ring (comm_ring (comm_ring fun_info)))))) : is_cyclic (has_norm (has_norm (comm_ring (comm_ring (comm_ring fun_info))))) := sorry --non-trivial
lemma new_lemma_11992 (h0 : not (topological_space (add_group num) -> false)) : @totally_disconnected_space.{0} (add_group.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_11993 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_11994 (h0 : functor.add_const (topological_space (add_comm_monoid unsigned)) empty) : @discrete_topology.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_11995 (h1 : has_mem.mem (with_one congr_arg_kind) has_emptyc.emptyc) : @is_atomistic.{0} (with_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_one.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_11996 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (denumerable.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (denumerable.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_11997 (h0 : topological_space (mul_one_class (add_comm_semigroup (mul_one_class std_gen)))) : t0_space (mul_one_class (add_comm_semigroup (mul_one_class std_gen))) := sorry --non-trivial
lemma new_lemma_11998 (h0 : ring (add_left_cancel_monoid (has_inv linarith.comp_source))) : rank_condition (add_left_cancel_monoid (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_11999 (h0 : ring (normed_lattice_add_comm_group (has_bot (sub_neg_monoid name)))) : is_principal_ideal_ring (normed_lattice_add_comm_group (has_bot (sub_neg_monoid name))) := sorry --non-trivial
lemma new_lemma_12000 (h0 : topological_space (comm_semigroup real)) : locally_compact_space (comm_semigroup real) := sorry --non-trivial
lemma new_lemma_12001 (h0 : filter (has_union (semiring congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_12002 (h0 : monoid (left_cancel_semigroup (option (option (option empty))))) : monoid.fg (left_cancel_semigroup (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_12003 (h1 : topological_space (has_neg_part std_gen)) : t0_space (has_neg_part std_gen) := sorry --non-trivial
lemma new_lemma_12004 (h0 : functor.add_const (group (option ennreal)) (option ennreal)) : @is_simple_group.{0} (option.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (option.{0} ennreal)) (option.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_12005 (h0 : add_monoid (has_Inf name)) : add_monoid.fg (has_Inf name) := sorry --non-trivial
lemma new_lemma_12006 (h0 : group (has_add (has_neg (finset Type)))) : group.fg (has_add (has_neg (finset Type))) := sorry --non-trivial
lemma new_lemma_12007 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_12008 (h0 : plift (partial_order num) -> plift (partial_order num) -> Prop) : is_total (plift (partial_order num)) h0 := sorry --non-trivial
lemma new_lemma_12009 (h0 : function.extfun Type (functor.add_const (topological_space (plift empty)))) : @loc_path_connected_space.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} empty)) unsigned (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (topological_space.{1} (plift.{1} empty))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_12010 (h0 : topological_space (ordered_comm_monoid real)) : totally_disconnected_space (ordered_comm_monoid real) := sorry --non-trivial
lemma new_lemma_12011 (h0 : ring (encodable (random_gen (random_gen to_additive.value_type)))) : rank_condition (encodable (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_12012 (h3 : set (enat -> std_gen)) : set.separates_points h3 := sorry --non-trivial
lemma new_lemma_12013 (h0 : not (finset (measurable_space.dynkin_system congr_arg_kind) -> false)) : finset.nonempty (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_12014 (h0 : topological_space (mul_one_class environment.projection_info)) : path_connected_space (mul_one_class environment.projection_info) := sorry --non-trivial
lemma new_lemma_12015 (h0 : ring (canonically_ordered_comm_semiring (finset (finset (has_to_string name))))) : rank_condition (canonically_ordered_comm_semiring (finset (finset (has_to_string name)))) := sorry --non-trivial
lemma new_lemma_12016 (h0 : functor.add_const (function.extfun Type filter) pos) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_12017 (h0 : complete_lattice (measurable_space (normed_group empty))) : is_compactly_generated (measurable_space (normed_group empty)) := sorry --non-trivial
lemma new_lemma_12018 (h0 : topological_space (add_cancel_monoid (finset (finset (finset (finset linarith.comp)))))) : path_connected_space (add_cancel_monoid (finset (finset (finset (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_12019 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @loc_path_connected_space.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero))) (@has_zero.zero.{0} nat nat.has_zero))) (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_12020 (h0 : add_group (has_union num)) : is_add_cyclic (has_union num) := sorry --non-trivial
lemma new_lemma_12021 (h1 : ring (distrib (has_ssubset char))) : rank_condition (distrib (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_12022 (h0 : functor.add_const (topological_space (left_cancel_monoid empty)) empty) : @topological_space.separable_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_12023 (h0 : not (filter (has_top linarith.comp_source) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_12024 (h0 : topological_space (mul_one_class to_additive.value_type)) : t0_space (mul_one_class to_additive.value_type) := sorry --non-trivial
lemma new_lemma_12025 (h0 : function.extfun Type (functor.comp topological_space complete_distrib_lattice)) : @t0_space.{0} (complete_distrib_lattice.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} complete_distrib_lattice.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_12026 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (linear_ordered_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_12027 (h1 : function.extfun (finset Type) (has_mem.mem (with_one congr_arg_kind))) : @irreducible_space.{0} (with_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} congr_arg_kind)) h1 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_12028 (h0 : set (measurable_space num)) : set.nonempty h0 := sorry --non-trivial
lemma new_lemma_12029 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_12030 (h0 : functor.add_const (ring (ring pos)) name) : @is_principal_ideal_ring.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_12031 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) pos) : @topological_space.separable_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_12032 (h0 : finset (has_nndist Type)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_12033 (h0 : complete_lattice (pseudo_metric_space (option (option (option unsigned))))) : complete_lattice.is_Sup_finite_compact (pseudo_metric_space (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_12034 (h0 : topological_space (finset (boolean_algebra.core (has_to_string ennreal)))) : irreducible_space (finset (boolean_algebra.core (has_to_string ennreal))) := sorry --non-trivial
lemma new_lemma_12035 (h0 : functor.add_const (ring (complete_distrib_lattice unsigned)) num) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_12036 (h0 : functor.add_const (functor.add_const (list (has_nndist unsigned)) environment.implicit_infer_kind) Type) : list.nodup (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_12037 (h0 : list (non_assoc_semiring linarith.comp_source)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_12038 (h0 : has_star (has_nnnorm linarith.ineq)) (h1 : ring (has_trivial_star (has_nnnorm linarith.ineq))) : rank_condition (has_trivial_star (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_12039 (h0 : not (topological_space reducibility_hints -> false)) : @path_connected_space.{0} reducibility_hints (@classical.by_contradiction'.{1} (topological_space.{0} reducibility_hints) h0)  := sorry --non-trivial
lemma new_lemma_12040 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) name) : @locally_compact_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_12041 (h0 : topological_space (has_bot empty) -> Prop) (h1 : Exists (fun (x : topological_space (has_bot empty)), h0 x)) : @totally_separated_space.{0} (has_bot.{0} empty) (@classical.some.{1} (topological_space.{0} (has_bot.{0} empty)) h0 h1)  := sorry --non-trivial
lemma new_lemma_12042 (h0 : has_zero pos -> has_zero pos -> has_zero pos) : left_cancelative h0 := sorry --non-trivial
lemma new_lemma_12043 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_12044 (h0 : topological_space (with_bot congr_arg_kind)) : normal_space (with_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_12045 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_12046 (h0 : topological_space (boolean_algebra (semigroup (semigroup Type)))) : preconnected_space (boolean_algebra (semigroup (semigroup Type))) := sorry --non-trivial
lemma new_lemma_12047 (h0 : group (add_comm_monoid (has_add Type))) : normalizer_condition (add_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_12048 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (canonically_linear_ordered_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_12049 (h0 h1 : multiset (add_comm_semigroup std_gen)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_12050 (h0 : group (has_compl (has_nnnorm (random_gen linarith.comp_source)))) : is_cyclic (has_compl (has_nnnorm (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_12051 (h0 : topological_space (normed_comm_ring (normed_comm_ring (mul_one_class Type)))) : t0_space (normed_comm_ring (normed_comm_ring (mul_one_class Type))) := sorry --non-trivial
lemma new_lemma_12052 (h0 : functor.comp topological_space has_nndist Type) : @preirreducible_space.{1} (has_nndist.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_nndist.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_12053 (h0 : functor.add_const (topological_space (ring Type)) pos) : @preirreducible_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_12054 (h0 : topological_space (boolean_algebra.core (has_add linarith.comp))) : t0_space (boolean_algebra.core (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_12055 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (add_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (add_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_12056 (h0 : group (has_neg (ring (ring (ring (mul_one_class (ring linarith.comp))))))) : is_simple_group (has_neg (ring (ring (ring (mul_one_class (ring linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_12057 (h0 : ring (has_norm (has_top to_additive.value_type))) : rank_condition (has_norm (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_12058 (h0 : fin has_zero.zero) : @path_connected_space.{1} (has_Inf.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_Inf.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_12059 (h0 : finset (normed_comm_ring (has_nndist name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_12060 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) pos) : @irreducible_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_12061 (h0 : functor.add_const (ring (has_pos_part linarith.comp)) pos) : @strong_rank_condition.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_pos_part.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_12062 (h0 : not (complete_lattice (free_add_monoid empty) -> false)) : @is_atomistic.{0} (free_add_monoid.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (free_add_monoid.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_12063 (h0 : semiring (linear_ordered_field empty)) : is_noetherian_ring (linear_ordered_field empty) := sorry --non-trivial
lemma new_lemma_12064 (h0 : topological_space (normed_lattice_add_comm_group (ordered_comm_monoid real))) : path_connected_space (normed_lattice_add_comm_group (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_12065 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_12066 (h0 : topological_space (boolean_algebra (has_neg linarith.comp))) : t0_space (boolean_algebra (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_12067 (h0 : topological_space (canonically_ordered_comm_semiring (has_pos_part linarith.comp))) : totally_separated_space (canonically_ordered_comm_semiring (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_12068 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_12069 (h0 : functor.comp topological_space ring environment.implicit_infer_kind) : @t1_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_12070 (h0 : linarith.ineq -> linarith.ineq -> Prop) : is_per linarith.ineq h0 := sorry --non-trivial
lemma new_lemma_12071 (h0 : ring (semi_normed_comm_ring (random_gen char))) : strong_rank_condition (semi_normed_comm_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_12072 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) name) : @regular_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_12073 (h0 : measurable_space char) (h1 : has_mul char) (h2 : measure_theory.measure char) : measure_theory.measure.is_mul_left_invariant h2 := sorry --non-trivial
lemma new_lemma_12074 (h0 : topological_space (add_left_cancel_semigroup num)) : t1_space (add_left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_12075 (h0 : function.extfun Type topological_space) : discrete_topology ennreal := sorry --non-trivial
lemma new_lemma_12076 (h0 : ring (has_Inf (generalized_boolean_algebra linarith.comp))) : strong_rank_condition (has_Inf (generalized_boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_12077 (h0 : semiring (measurable_space num)) : is_noetherian_ring (measurable_space num) := sorry --non-trivial
lemma new_lemma_12078 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) name) : @sequential_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_12079 (h0 : list (denumerable (random_gen (random_gen (random_gen linarith.comp_source))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_12080 (h1 : group (uniform_space char)) : is_cyclic (uniform_space char) := sorry --non-trivial
lemma new_lemma_12081 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @monoid.fg.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) monoid.{0}) (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_12082 (h0 : functor.add_const (ring (ring (finset pos))) linarith.comp) : @is_domain.{0} (ring.{0} (finset.{0} pos)) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} (finset.{0} pos))) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_12083 (h0 : complete_lattice (normed_comm_ring (has_add environment.implicit_infer_kind))) : complete_lattice.is_Sup_finite_compact (normed_comm_ring (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_12084 (h0 : complete_lattice (has_to_string (has_add (has_neg linarith.comp)))) : is_compactly_generated (has_to_string (has_add (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_12085 (h0 : uniform_space (has_norm (complete_semilattice_Sup unsigned))) : complete_space (has_norm (complete_semilattice_Sup unsigned)) := sorry --non-trivial
lemma new_lemma_12086 (h0 : fin has_zero.zero) : @is_simple_group.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (group.{0} (canonically_ordered_monoid.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_12087 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_12088 (h1 : add_group (fintype string_imp)) : is_add_cyclic (fintype string_imp) := sorry --non-trivial
lemma new_lemma_12089 (h0 : add_group (ordered_ring (semiring (semiring num)))) : is_add_cyclic (ordered_ring (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_12090 (h0 : function.extfun Type group) : @normalizer_condition.{0} (add_cancel_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (add_cancel_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_12091 (h0 : filter (distrib_lattice fun_info)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_12092 (h0 : prod (has_inter (option ennreal)) (has_inter (option ennreal))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_12093 (h0 : topological_space (normed_group (random_gen (random_gen (random_gen to_additive.value_type))))) : locally_compact_space (normed_group (random_gen (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_12094 (h0 : group (sub_neg_monoid (has_Inf (has_Inf pos)))) : is_cyclic (sub_neg_monoid (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_12095 (h0 : function.extfun (topological_space (ring unsigned)) (fun (x : topological_space (ring unsigned)), Prop)) (h1 : Exists (fun (x : topological_space (ring unsigned)), function.extfun_app h0 x)) : @totally_separated_space.{0} (ring.{0} unsigned) (@classical.some.{1} (topological_space.{0} (ring.{0} unsigned)) (@function.extfun_app.{1 1} (topological_space.{0} (ring.{0} unsigned)) (λ (x : topological_space.{0} (ring.{0} unsigned)), Prop) h0) h1)  := sorry --non-trivial
lemma new_lemma_12096 (h0 : uniform_space (id (linear_ordered_semiring unsigned))) : complete_space (id (linear_ordered_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_12097 (h0 : functor.add_const (list (normed_comm_ring linarith.comp)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_12098 (h0 : functor.add_const (filter (canonically_ordered_comm_semiring Type)) (has_neg pos)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_12099 (h0 : not (function.extfun Type list -> false)) : palindrome (function.extfun_app (classical.by_contradiction' h0) num) := sorry --non-trivial
lemma new_lemma_12100 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (as_linear_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (as_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_12101 (h0 : functor.add_const (topological_space (has_add pos)) Type) : @discrete_topology.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_12102 (h0 : functor.add_const (add_monoid (ring linarith.comp)) (ring pos)) : @add_monoid.fg.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (ring.{0} linarith.comp)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_12103 (h0 : topological_space (ordered_ring unsigned)) : path_connected_space (ordered_ring unsigned) := sorry --non-trivial
lemma new_lemma_12104 (h0 : group (bin_tree (semiring empty))) : normalizer_condition (bin_tree (semiring empty)) := sorry --non-trivial
lemma new_lemma_12105 (h0 : list (add_comm_monoid real)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_12106 (h0 : ring (random_gen (has_nnnorm linarith.ineq))) : strong_rank_condition (random_gen (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_12107 (h0 : functor.add_const (topological_space (preorder num)) empty) : @topological_space.separable_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_12108 (h0 : topological_space (measurable_space (has_top linarith.comp_source))) : path_connected_space (measurable_space (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_12109 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_12110 (h1 : ring (has_compl reducibility_hints)) : rank_condition (has_compl reducibility_hints) := sorry --non-trivial
lemma new_lemma_12111 (h0 : prod (add_comm_monoid (boolean_algebra name)) (add_comm_monoid (boolean_algebra name))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_12112 (h0 : ordered_comm_monoid (boolean_algebra.core (has_add (semigroup Type)))) : has_exists_mul_of_le (boolean_algebra.core (has_add (semigroup Type))) := sorry --non-trivial
lemma new_lemma_12113 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_12114 (h0 : functor.add_const (topological_space (ring Type)) Type) : @preconnected_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_12115 (h0 : ordered_comm_monoid (has_add (has_zero unsigned))) : has_exists_mul_of_le (has_add (has_zero unsigned)) := sorry --non-trivial
lemma new_lemma_12116 (h0 : functor.add_const (topological_space (plift congr_arg_kind)) num) : @preirreducible_space.{1} (plift.{1} congr_arg_kind) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_12117 (h0 : functor.add_const (ring (normed_comm_ring environment.implicit_infer_kind)) Type) : @is_domain.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ring.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_12118 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (comm_semigroup.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (comm_semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_12119 (h0 : monoid (has_add (option num))) : monoid.fg (has_add (option num)) := sorry --non-trivial
lemma new_lemma_12120 (h0 : add_group (sub_neg_monoid (has_Inf (has_Inf name)))) : is_add_cyclic (sub_neg_monoid (has_Inf (has_Inf name))) := sorry --non-trivial
lemma new_lemma_12121 (h0 : functor.add_const (group (has_neg name)) (has_neg Type)) : @normalizer_condition.{0} (has_neg.{0} name) (@functor.add_const.run.{0 1} (group.{0} (has_neg.{0} name)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_12122 (h0 : complete_lattice (ordered_comm_monoid real)) : is_compactly_generated (ordered_comm_monoid real) := sorry --non-trivial
lemma new_lemma_12123 (h0 : fin has_zero.zero) : @is_cyclic.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (group.{0} (ordered_comm_ring.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_12124 (h0 : functor.comp (functor.add_const (list (has_zero name))) option pos) : list.nodup (functor.add_const.run (functor.comp.run h0)) := sorry --non-trivial
lemma new_lemma_12125 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_12126 (h0 : functor.add_const Prop (has_zero pos)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_12127 (h0 : topological_space (ordered_comm_ring fun_info)) : path_connected_space (ordered_comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_12128 (h0 : function.extfun (set string_imp) (fun (x : set string_imp), Prop)) (h1 : string_imp) : set.sInter (function.extfun_app h0) h1 := sorry --non-trivial
lemma new_lemma_12129 (h0 : topological_space environment.projection_info) : totally_disconnected_space environment.projection_info := sorry --non-trivial
lemma new_lemma_12130 (h0 : topological_space (preorder congr_arg_kind)) : totally_separated_space (preorder congr_arg_kind) := sorry --non-trivial
lemma new_lemma_12131 (h0 : filter (monoid (option (option (option (option (option pos))))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_12132 (h0 : not (topological_space (has_sub unsigned) -> false)) : @locally_compact_space.{0} (has_sub.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_12133 (h0 : functor.add_const (group (has_nndist pos)) name) : @is_cyclic.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_12134 (h0 : add_group (ring (has_Inf (finset linarith.comp)))) : is_add_cyclic (ring (has_Inf (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_12135 (h0 : uniform_space (complete_semilattice_Sup congr_arg_kind)) : complete_space (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_12136 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (finset.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (finset.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_12137 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (linear_ordered_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_12138 (h0 : functor.add_const (function.extfun (Type 1) group) environment.implicit_infer_kind) : @normalizer_condition.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) environment.implicit_infer_kind h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_12139 (h0 : functor.add_const (add_monoid (add_cancel_monoid Type)) Type) : @add_monoid.fg.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (add_monoid.{1} (add_cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_12140 (h0 : function.extfun Type ring) : @rank_condition.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_12141 (h0 : add_group (canonically_ordered_monoid (has_neg (has_neg name)))) : is_add_cyclic (canonically_ordered_monoid (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_12142 (h0 : fin has_zero.zero) : @discrete_topology.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_12143 (h0 : ring (has_nndist (has_add Type))) : is_domain (has_nndist (has_add Type)) := sorry --non-trivial
lemma new_lemma_12144 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_12145 (h0 : complete_lattice (has_inv string_imp)) : is_compactly_generated (has_inv string_imp) := sorry --non-trivial
lemma new_lemma_12146 (h0 : functor.add_const (group (semigroup pos)) linarith.comp) : @group.fg.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_12147 (h1 : topological_space (random_gen (has_nnnorm (comm_ring char)))) : t0_space (random_gen (has_nnnorm (comm_ring char))) := sorry --non-trivial
lemma new_lemma_12148 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @path_connected_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_12149 (h0 : not (function.extfun (Type 1) topological_space -> false)) : @normal_space.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@classical.by_contradiction'.{3} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_12150 (h0 : functor.add_const (ring (comm_group environment.implicit_infer_kind)) Type) : @is_principal_ideal_ring.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ring.{0} (comm_group.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_12151 (h0 : uniform_space (cancel_monoid (has_add (has_neg_part linarith.comp)))) : separated_space (cancel_monoid (has_add (has_neg_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_12152 (h0 : group (distrib_lattice (has_nnnorm (has_nnnorm linarith.comp_source)))) : is_cyclic (distrib_lattice (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_12153 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_12154 (h0 : topological_space (has_neg (finset (finset Type)))) : regular_space (has_neg (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_12155 (h0 : topological_space (dlist (has_nnnorm (has_nnnorm to_additive.value_type)))) : locally_compact_space (dlist (has_nnnorm (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_12156 (h0 : function.extfun nat fin) : @group.fg.{0} (canonically_linear_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (group.{0} (canonically_linear_ordered_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_12157 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (distrib_lattice.{0} (has_nnnorm.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (distrib_lattice.{0} (has_nnnorm.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_12158 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (encodable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (encodable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_12159 (h0 : functor.add_const (add_group (has_zero unsigned)) Type) : @is_add_cyclic.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 1} (add_group.{0} (has_zero.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_12160 (h0 : topological_space (has_Inf (ring linarith.comp))) : totally_disconnected_space (has_Inf (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_12161 (h0 : function.extfun (Type -> Type) (function.extfun Type)) (h1 : function.extfun nat fin) : @has_measurable_neg.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type has_neg.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 has_neg.{0}) (has_pos_part.{0} real)) (@matrix.vec_empty.{0} (measurable_space.{0} (has_pos_part.{0} real)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) (@function.extfun_app.{1 1} nat fin h1 (@has_zero.zero.{0} nat nat.has_zero))) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_12162 (h0 : multiset (semi_normed_ring linarith.comp_source)) (h1 : not (multiset (semi_normed_ring linarith.comp_source) -> false)) : multiset.disjoint h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_12163 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.dynkin_system.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_12164 (h0 : function.extfun Type group) : @group.fg.{0} (fintype.{0} char) (@function.extfun_app.{2 1} Type group.{0} h0 (fintype.{0} char))  := sorry --non-trivial
lemma new_lemma_12165 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_12166 (h0 : uniform_space (add_cancel_monoid Type)) : separated_space (add_cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_12167 (h0 : functor.comp topological_space has_to_string Type) : @preirreducible_space.{1} (has_to_string.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_to_string.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_12168 (h0 : topological_space (ring (has_add (boolean_algebra.core pos)))) : topological_space.separable_space (ring (has_add (boolean_algebra.core pos))) := sorry --non-trivial
lemma new_lemma_12169 (h0 : fin has_zero.zero) : @archimedean.{0} (ordered_comm_ring.{0} linarith.comp) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (ordered_comm_ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_12170 (h2 : topological_space (nondiscrete_normed_field linarith.ineq)) : totally_disconnected_space (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_12171 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_12172 (h0 : topological_space (random_gen (semiring unsigned))) : preirreducible_space (random_gen (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_12173 (h0 : measurable_space (has_nnnorm fun_info)) (h1 : filter (has_nnnorm fun_info)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_12174 (h0 : topological_space (has_to_string (normed_comm_ring linarith.comp))) : t0_space (has_to_string (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_12175 (h0 : group (has_neg (has_add (has_neg_part ennreal)))) : is_simple_group (has_neg (has_add (has_neg_part ennreal))) := sorry --non-trivial
lemma new_lemma_12176 (h0 : ring (boolean_algebra (has_nndist Type))) : strong_rank_condition (boolean_algebra (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_12177 (h0 : ring (ordered_cancel_add_comm_monoid (option ennreal))) : strong_rank_condition (ordered_cancel_add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_12178 (h0 : not (topological_space (linear_ordered_comm_group_with_zero (mul_one_class linarith.ineq)) -> false)) : @totally_disconnected_space.{0} (linear_ordered_comm_group_with_zero.{0} (mul_one_class.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_group_with_zero.{0} (mul_one_class.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_12179 (h0 : not (topological_space (non_unital_non_assoc_semiring (has_nnnorm enat)) -> false)) : @t0_space.{0} (non_unital_non_assoc_semiring.{0} (has_nnnorm.{0} enat)) (@classical.by_contradiction'.{1} (topological_space.{0} (non_unital_non_assoc_semiring.{0} (has_nnnorm.{0} enat))) h0)  := sorry --non-trivial
lemma new_lemma_12180 (h0 : ordered_add_comm_monoid (pseudo_metric_space (option empty))) : archimedean (pseudo_metric_space (option empty)) := sorry --non-trivial
lemma new_lemma_12181 (h0 : functor.comp topological_space has_to_string pos) : @discrete_topology.{0} (has_to_string.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_12182 (h0 : function.extfun Type ring) : @is_domain.{0} (ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_12183 (h0 : finset (ordered_comm_ring (has_add (has_add (has_add pos))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_12184 (h0 : functor.add_const (uniform_space (has_nndist environment.implicit_infer_kind)) pos) : @complete_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_12185 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_12186 (h0 : group (distrib_lattice fun_info)) : normalizer_condition (distrib_lattice fun_info) := sorry --non-trivial
lemma new_lemma_12187 (h0 : function.extfun linarith.comp_source (fun (x : linarith.comp_source), Prop)) : Exists (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_12188 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @is_cyclic.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_12189 (h0 : function.extfun (finset Type -> Prop) (function.extfun (finset Type))) : @complete_space.{0} (has_one.{0} linarith.comp) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} linarith.comp)) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) h0 (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} linarith.comp))) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_12190 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_12191 (h0 : function.extfun Type (functor.comp topological_space has_neg)) : @locally_compact_space.{0} (has_neg.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_neg.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_12192 (h1 : has_inv (with_bot linarith.comp_source) -> Prop) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) (has_inv.{0} (with_bot.{0} linarith.comp_source)) h1  := sorry --non-trivial
lemma new_lemma_12193 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_12194 (h0 : group (has_nnnorm (normed_field linarith.ineq))) : is_cyclic (has_nnnorm (normed_field linarith.ineq)) := sorry --non-trivial
lemma new_lemma_12195 (h0 : ring (ordered_cancel_add_comm_monoid (option empty))) : is_domain (ordered_cancel_add_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_12196 (h0 : ring (add_comm_semigroup (mul_one_class fun_info))) : rank_condition (add_comm_semigroup (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_12197 (h0 : filter (ring ennreal)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_12198 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (mul_zero_class.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_12199 (h0 : topological_space (linear_ordered_semiring (semiring (semiring linarith.comp)))) : discrete_topology (linear_ordered_semiring (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_12200 (h0 : multiset (with_bot (plift congr_arg_kind))) : multiset.nodup h0 := sorry --non-trivial
lemma new_lemma_12201 (h0 : topological_space (group_with_zero (option ennreal))) : normal_space (group_with_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_12202 (h0 : group (add_comm_monoid (semigroup unsigned))) : is_cyclic (add_comm_monoid (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_12203 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_12204 (h0 : functor.add_const (filter (has_dist num)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_12205 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_12206 (h0 : uniform_space (has_norm (has_top to_additive.value_type))) : separated_space (has_norm (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_12207 (h0 : function.extfun (prod unsigned unsigned) (fun (x : prod unsigned unsigned), Prop)) : symmetric_rel (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_12208 (h0 : group (add_left_cancel_monoid (has_nnnorm (has_nnnorm fun_info)))) : is_cyclic (add_left_cancel_monoid (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_12209 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (ordered_comm_monoid.{1} (has_bot.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_12210 (h0 : list (normed_comm_ring (has_to_string (has_to_string (has_add unsigned))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_12211 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_12212 (h0 : topological_space (monoid (has_dist (option unsigned)))) : preirreducible_space (monoid (has_dist (option unsigned))) := sorry --non-trivial
lemma new_lemma_12213 (h0 : group (normed_lattice_add_comm_group (has_Inf pos))) : group.fg (normed_lattice_add_comm_group (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_12214 (h0 : not (semiring (semiring congr_arg_kind) -> false)) : @is_noetherian_ring.{0} (semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (semiring.{0} (semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_12215 (h1 : group (has_ssubset (random_gen string_imp))) : is_cyclic (has_ssubset (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_12216 (h0 : has_mem.mem (metric_space num) has_emptyc.emptyc) : @group.fg.{0} (metric_space.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (metric_space.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_12217 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 to_additive.value_type) := sorry --non-trivial
lemma new_lemma_12218 (h0 : function.extfun Type (functor.add_const (complete_lattice (has_star empty)))) : @is_compactly_generated.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_star.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (has_star.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_12219 (h0 : functor.add_const (topological_space (cancel_monoid name)) Type) : @loc_path_connected_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_12220 (h0 : cancel_comm_monoid_with_zero (has_bot (finset pos))) : unique_factorization_monoid (has_bot (finset pos)) := sorry --non-trivial
lemma new_lemma_12221 (h0 : function.extfun Type (functor.add_const (topological_space auto.case_option))) : @preirreducible_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} auto.case_option)) h0 empty))  := sorry --non-trivial
lemma new_lemma_12222 (h0 : functor.add_const (group (has_dist empty)) num) : @group.fg.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (has_dist.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_12223 (h1 : topological_space linarith.ineq) : locally_compact_space linarith.ineq := sorry --non-trivial
lemma new_lemma_12224 (h0 : monoid (complete_linear_order (semiring num))) : monoid.fg (complete_linear_order (semiring num)) := sorry --non-trivial
lemma new_lemma_12225 (h1 : uniform_space (measurable_space (random_gen (random_gen string_imp)))) : complete_space (measurable_space (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_12226 (h0 : ring (denumerable (random_gen (random_gen linarith.comp_source)))) : is_domain (denumerable (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_12227 (h0 : topological_space (boolean_algebra.core pos)) : totally_separated_space (boolean_algebra.core pos) := sorry --non-trivial
lemma new_lemma_12228 (h0 : topological_space (semi_normed_comm_ring (parser (has_ssubset string_imp)))) : t0_space (semi_normed_comm_ring (parser (has_ssubset string_imp))) := sorry --non-trivial
lemma new_lemma_12229 (h0 : functor.add_const (topological_space (complete_distrib_lattice unsigned)) empty) : @t0_space.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_12230 (h0 : monoid (simple_graph (boolean_algebra.core (finset pos)))) : monoid.fg (simple_graph (boolean_algebra.core (finset pos))) := sorry --non-trivial
lemma new_lemma_12231 (h1 : ring (add_monoid fun_info)) : is_domain (add_monoid fun_info) := sorry --non-trivial
lemma new_lemma_12232 (h0 : ordered_add_comm_monoid (canonically_ordered_add_monoid num)) : archimedean (canonically_ordered_add_monoid num) := sorry --non-trivial
lemma new_lemma_12233 (h0 : cancel_comm_monoid_with_zero (boolean_algebra.core (has_add (has_add (has_add (has_add pos)))))) : unique_factorization_monoid (boolean_algebra.core (has_add (has_add (has_add (has_add pos))))) := sorry --non-trivial
lemma new_lemma_12234 (h0 : functor.add_const (topological_space (has_neg Type)) linarith.comp) : @locally_compact_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_12235 (h1 : monoid (measurable_space linarith.ineq)) : monoid.fg (measurable_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_12236 (h0 : topological_space (boolean_algebra (has_neg_part (has_neg_part Type)))) : loc_path_connected_space (boolean_algebra (has_neg_part (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_12237 (h0 : group (complete_semilattice_Sup char)) : is_cyclic (complete_semilattice_Sup char) := sorry --non-trivial
lemma new_lemma_12238 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_12239 (h0 : not (group (semi_normed_ring string.iterator_imp) -> false)) : @is_cyclic.{0} (semi_normed_ring.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (group.{0} (semi_normed_ring.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_12240 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_bot.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_12241 (h0 : topological_space (canonically_ordered_comm_semiring (lex name))) : locally_compact_space (canonically_ordered_comm_semiring (lex name)) := sorry --non-trivial
lemma new_lemma_12242 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) name) : @locally_compact_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_12243 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} h0 (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_12244 (h0 : topological_space (has_one (has_norm fun_info))) : t0_space (has_one (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_12245 (h0 : complete_lattice (has_neg (has_neg Type))) : is_compactly_generated (has_neg (has_neg Type)) := sorry --non-trivial
lemma new_lemma_12246 (h0 : functor.comp group comm_group unsigned) : @is_simple_group.{0} (comm_group.{0} unsigned) (@functor.comp.run.{0 0 0} group.{0} comm_group.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_12247 (h0 : topological_space (boolean_algebra.core num)) : path_connected_space (boolean_algebra.core num) := sorry --non-trivial
lemma new_lemma_12248 (h0 : topological_space (semigroup (has_neg environment.implicit_infer_kind))) : preirreducible_space (semigroup (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_12249 (h0 : functor.add_const (ordered_comm_monoid (canonically_ordered_monoid linarith.comp)) (finset pos)) : @has_exists_mul_of_le.{0} (canonically_ordered_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (canonically_ordered_monoid.{0} linarith.comp)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_12250 (h0 : filter (semigroup Type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_12251 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (filter unsigned)) := sorry --non-trivial
lemma new_lemma_12252 (h0 : add_monoid (has_zero num)) : add_monoid.fg (has_zero num) := sorry --non-trivial
lemma new_lemma_12253 (h0 : add_group (linear_ordered_comm_group congr_arg_kind)) : is_add_cyclic (linear_ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_12254 (h0 : functor.add_const (filter (linear_ordered_field unsigned)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_12255 (h0 : functor.comp ring has_add pos) : @rank_condition.{0} (has_add.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} has_add.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_12256 (h0 : group (metric_space (linear_ordered_semiring congr_arg_kind))) : normalizer_condition (metric_space (linear_ordered_semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_12257 (h0 : topological_space (preorder (semiring (semiring (semiring (semiring (semiring num))))))) : normal_space (preorder (semiring (semiring (semiring (semiring (semiring num)))))) := sorry --non-trivial
lemma new_lemma_12258 (h1 : group (has_append linarith.comp_source)) : is_cyclic (has_append linarith.comp_source) := sorry --non-trivial
lemma new_lemma_12259 (h0 : finset (ordered_comm_ring (sub_neg_monoid pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_12260 (h0 : mul_one_class (uniform_space reducibility_hints)) (h1 : uniform_space (uniform_space (mul_one_class (submonoid (uniform_space reducibility_hints))))) : complete_space (uniform_space (mul_one_class (submonoid (uniform_space reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_12261 (h0 : add_group (add_comm_semigroup (normed_field std_gen))) : is_add_cyclic (add_comm_semigroup (normed_field std_gen)) := sorry --non-trivial
lemma new_lemma_12262 (h0 : not (monoid (has_emptyc linarith.ineq) -> false)) : @monoid.fg.{0} (has_emptyc.{0} linarith.ineq) (@classical.by_contradiction'.{1} (monoid.{0} (has_emptyc.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_12263 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @totally_separated_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_12264 (h0 : ring (ring (option (option unsigned)))) : rank_condition (ring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_12265 (h0 : function.extfun Type complete_lattice) : is_compactly_generated (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_12266 (h0 : functor.add_const (finset (has_pos_part Type)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_12267 (h0 : topological_space (has_neg pos)) : locally_compact_space (has_neg pos) := sorry --non-trivial
lemma new_lemma_12268 (h0 : measurable_space fun_info) (h2 : Prop) : measurable_set (id (fun (h1 : fun_info), h2)) := sorry --non-trivial
lemma new_lemma_12269 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (with_one.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (with_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_12270 (h0 : not (has_mem.mem (has_inv num) has_emptyc.emptyc -> false)) : @monoid.fg.{0} (has_inv.{0} num) (@finset.pi.empty.{1 0} Type monoid.{0} (has_inv.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_inv.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_12271 (h0 : complete_lattice (generalized_boolean_algebra linarith.comp)) : complete_lattice.is_Sup_finite_compact (generalized_boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_12272 (h0 : complete_lattice (has_to_string environment.implicit_infer_kind)) : complete_lattice.is_Sup_finite_compact (has_to_string environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_12273 (h0 : functor.add_const (ring (semigroup num)) congr_arg_kind) : @rank_condition.{0} (semigroup.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_12274 (h0 : topological_space (normed_group linarith.comp)) : t0_space (normed_group linarith.comp) := sorry --non-trivial
lemma new_lemma_12275 (h0 : functor.add_const (topological_space pos) ennreal) : @t1_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) ennreal h0)  := sorry --non-trivial
lemma new_lemma_12276 (h0 : finset (comm_group (option (option (option (option name)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_12277 (h0 : functor.add_const (function.extfun (Type 1) ring) Type) : @rank_condition.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) Type h0) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_12278 (h0 : topological_space (boolean_algebra (has_pos_part (finset linarith.comp)))) : t0_space (boolean_algebra (has_pos_part (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_12279 (h0 : not (topological_space (has_norm num) -> false)) : @path_connected_space.{0} (has_norm.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_12280 (h0 : topological_space (has_zero pos)) : totally_separated_space (has_zero pos) := sorry --non-trivial
lemma new_lemma_12281 (h0 : group (boolean_algebra (has_add name))) : normalizer_condition (boolean_algebra (has_add name)) := sorry --non-trivial
lemma new_lemma_12282 (h0 : uniform_space (has_star num)) : separated_space (has_star num) := sorry --non-trivial
lemma new_lemma_12283 (h0 : topological_space (dlist (has_ssubset (has_nnnorm string_imp)))) : t0_space (dlist (has_ssubset (has_nnnorm string_imp))) := sorry --non-trivial
lemma new_lemma_12284 (h0 : fin has_zero.zero) : @totally_separated_space.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (comm_semigroup.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_12285 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_12286 (h0 : list (ring (has_add linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_12287 (h0 : functor.add_const (filter (finset pos)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_12288 (h0 : functor.add_const (add_monoid (as_linear_order empty)) empty) : @add_monoid.fg.{0} (as_linear_order.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (as_linear_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_12289 (h0 : complete_lattice (has_top (random_gen (has_top linarith.ineq)))) : is_compactly_generated (has_top (random_gen (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_12290 (h0 : function.extfun Type ring) : @rank_condition.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_12291 (h0 : functor.add_const (topological_space (cancel_monoid unsigned)) Type) : @t0_space.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_12292 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_12293 (h1 : add_group (add_comm_semigroup environment.projection_info)) : is_add_cyclic (add_comm_semigroup environment.projection_info) := sorry --non-trivial
lemma new_lemma_12294 (h0 : functor.add_const (topological_space (has_nndist Type)) name) : @totally_separated_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_12295 (h1 : function.extfun Type list) : list.nodup (function.extfun_app h1 (with_one linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_12296 (h0 : functor.add_const (topological_space (cancel_monoid environment.implicit_infer_kind)) Type) : @normal_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_12297 (h0 : functor.add_const (semiring (semigroup empty)) (is_R_or_C (option (option unsigned)))) : @is_noetherian_ring.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (semigroup.{0} empty)) (is_R_or_C.{0} (option.{0} (option.{0} unsigned))) h0)  := sorry --non-trivial
lemma new_lemma_12298 (h0 : ordered_add_comm_monoid (has_add (has_Inf linarith.comp))) : archimedean (has_add (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_12299 (h0 : not (ring (random_gen num) -> false)) : @rank_condition.{0} (random_gen.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_12300 (h0 : ring (finset (option name))) : rank_condition (finset (option name)) := sorry --non-trivial
lemma new_lemma_12301 (h0 : group (has_nndist linarith.comp)) : is_cyclic (has_nndist linarith.comp) := sorry --non-trivial
lemma new_lemma_12302 (h0 : topological_space (nondiscrete_normed_field (add_comm_semigroup ereal))) : path_connected_space (nondiscrete_normed_field (add_comm_semigroup ereal)) := sorry --non-trivial
lemma new_lemma_12303 (h0 : complete_lattice (distrib_lattice (has_inv linarith.comp_source))) : is_atomistic (distrib_lattice (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_12304 (h0 : complete_lattice (random_gen (has_inv linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (random_gen (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_12305 (h0 : add_group (has_pos_part (has_neg (ordered_comm_monoid real)))) : is_add_cyclic (has_pos_part (has_neg (ordered_comm_monoid real))) := sorry --non-trivial
lemma new_lemma_12306 (h0 : topological_space (ordered_comm_monoid (has_neg Type))) : totally_disconnected_space (ordered_comm_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_12307 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (measure_theory.measure_space congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_12308 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_12309 (h0 : group (has_norm (has_top (has_top (has_top fun_info))))) : is_cyclic (has_norm (has_top (has_top (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_12310 (h0 : list (dlist (has_top (denumerable (denumerable (comm_ring to_additive.value_type)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_12311 (h0 : add_group (add_cancel_monoid num)) : is_add_cyclic (add_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_12312 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} num (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) num)  := sorry --non-trivial
lemma new_lemma_12313 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @path_connected_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_12314 (h0 : group (semigroup (option (option (option ennreal))))) : normalizer_condition (semigroup (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_12315 (h0 : add_group (nondiscrete_normed_field ereal)) : is_add_cyclic (nondiscrete_normed_field ereal) := sorry --non-trivial
lemma new_lemma_12316 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_12317 (h0 : complete_lattice (denumerable linarith.ineq)) : is_compactly_generated (denumerable linarith.ineq) := sorry --non-trivial
lemma new_lemma_12318 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_12319 (h0 : functor.add_const (group (has_to_string linarith.comp)) environment.implicit_infer_kind) : @is_cyclic.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_12320 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_12321 (h0 : uniform_space (canonically_linear_ordered_monoid ennreal)) : complete_space (canonically_linear_ordered_monoid ennreal) := sorry --non-trivial
lemma new_lemma_12322 (h0 : topological_space (linear_ordered_comm_ring (option (option congr_arg_kind)))) : discrete_topology (linear_ordered_comm_ring (option (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_12323 (h0 : order_hom nat (topological_space (with_one to_additive.value_type))) : @totally_separated_space.{0} (with_one.{0} to_additive.value_type) (@monotonic_sequence_limit.{0} (topological_space.{0} (with_one.{0} to_additive.value_type)) (@topological_space.partial_order.{0} (with_one.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_12324 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) pos) : @path_connected_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_12325 (h0 : functor.add_const (list (add_cancel_monoid Type)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_12326 (h1 : ring (has_append (has_nnnorm (random_gen reducibility_hints)))) : rank_condition (has_append (has_nnnorm (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_12327 (h0 : group (linear_ordered_add_comm_group (has_inv (has_inv (denumerable fun_info))))) : group.fg (linear_ordered_add_comm_group (has_inv (has_inv (denumerable fun_info)))) := sorry --non-trivial
lemma new_lemma_12328 (h0 : add_group (normed_comm_ring (ring environment.implicit_infer_kind))) : is_add_cyclic (normed_comm_ring (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_12329 (h0 : topological_space (normed_comm_ring empty)) : t0_space (normed_comm_ring empty) := sorry --non-trivial
lemma new_lemma_12330 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_12331 (h0 : functor.add_const (ordered_comm_monoid (add_comm_monoid unsigned)) name) : @has_exists_mul_of_le.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (add_comm_monoid.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_12332 (h0 : functor.add_const (finset (complete_distrib_lattice empty)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_12333 (h0 : topological_space (has_neg (finset unsigned))) : t0_space (has_neg (finset unsigned)) := sorry --non-trivial
lemma new_lemma_12334 (h0 : functor.add_const (functor.comp topological_space has_add ennreal) Type) : @sequential_space.{0} (has_add.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} ennreal (@functor.add_const.run.{0 1} (functor.comp.{0 0 0} topological_space.{0} has_add.{0} ennreal) Type h0))  := sorry --non-trivial
lemma new_lemma_12335 (h0 : topological_space (mul_one_class fun_info)) (h1 : has_lt (topological_space.opens (mul_one_class fun_info))) : no_max_order (topological_space.opens (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_12336 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_12337 (h0 : topological_space (has_add (add_cancel_monoid (has_neg (has_neg (has_neg pos)))))) : preconnected_space (has_add (add_cancel_monoid (has_neg (has_neg (has_neg pos))))) := sorry --non-trivial
lemma new_lemma_12338 (h0 : topological_space (id (random_gen to_additive.value_type))) : locally_compact_space (id (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_12339 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (linear_ordered_comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_12340 (h0 : monoid (has_one empty)) : monoid.fg (has_one empty) := sorry --non-trivial
lemma new_lemma_12341 (h0 : functor.add_const (ring (has_add pos)) name) : @is_principal_ideal_ring.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_12342 (h0 : function.extfun Type (functor.add_const (topological_space (ordered_ring empty)))) : @preirreducible_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (ordered_ring.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_12343 (h0 : functor.add_const (function.extfun Type list) name) : list.nodup (function.extfun_app (functor.add_const.run h0) (ring name)) := sorry --non-trivial
lemma new_lemma_12344 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_12345 (h0 : functor.add_const (topological_space (finset Type)) environment.implicit_infer_kind) : @preirreducible_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_12346 (h0 : ring (option (semiring num))) : rank_condition (option (semiring num)) := sorry --non-trivial
lemma new_lemma_12347 (h0 : ring (has_one (has_one (has_one linarith.comp)))) : is_domain (has_one (has_one (has_one linarith.comp))) := sorry --non-trivial
lemma new_lemma_12348 (h0 : not (complete_lattice (has_ssubset string.iterator_imp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_ssubset.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_ssubset.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_12349 (h1 : ring (linear_ordered_add_comm_group (random_gen (random_gen (random_gen char))))) : strong_rank_condition (linear_ordered_add_comm_group (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_12350 (h0 : group (partial_order (semiring unsigned))) : is_cyclic (partial_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_12351 (h0 : measure_theory.measure_space congr_arg_kind -> measure_theory.measure_space congr_arg_kind -> Prop) : is_antisymm (measure_theory.measure_space congr_arg_kind) h0 := sorry --non-trivial
lemma new_lemma_12352 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) name) : @discrete_topology.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_12353 (h0 : functor.add_const (uniform_space (boolean_algebra.core environment.implicit_infer_kind)) linarith.comp) : @complete_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_12354 (h0 : uniform_space (has_emptyc (semiring (has_norm empty)))) : complete_space (has_emptyc (semiring (has_norm empty))) := sorry --non-trivial
lemma new_lemma_12355 (h0 : finset (has_add (has_to_string (has_nndist (has_add name))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_12356 (h0 : topological_space (has_lt real.angle)) (h1 : preorder (has_lt real.angle)) : order_topology (has_lt real.angle) := sorry --non-trivial
lemma new_lemma_12357 (h2 : complete_lattice (uniform_space reducibility_hints)) : complete_lattice.is_Sup_finite_compact (uniform_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_12358 (h0 : functor.add_const (function.extfun (Type 1) finset) environment.implicit_infer_kind) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_12359 (h0 : filter (has_Sup num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_12360 (h0 : functor.add_const (complete_lattice (non_assoc_semiring unsigned)) unsigned) : @is_atomistic.{0} (non_assoc_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (non_assoc_semiring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_12361 (h0 : complete_lattice (linear_ordered_comm_group_with_zero linarith.ineq)) : is_compactly_generated (linear_ordered_comm_group_with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_12362 (h0 : functor.add_const (add_monoid (bin_tree empty)) (semiring num)) : @add_monoid.fg.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (bin_tree.{0} empty)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_12363 (h0 : functor.add_const (topological_space (semigroup name)) Type) : @preirreducible_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_12364 (h0 : topological_space (add_cancel_monoid pos)) : path_connected_space (add_cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_12365 (h0 : uniform_space (has_neg (has_neg pos))) : separated_space (has_neg (has_neg pos)) := sorry --non-trivial
lemma new_lemma_12366 (h1 : Prop) : set.separates_points (id (fun (h0 : linarith.ineq -> fun_info), h1)) := sorry --non-trivial
lemma new_lemma_12367 (h0 : topological_space (bin_tree num)) : topological_space.separable_space (bin_tree num) := sorry --non-trivial
lemma new_lemma_12368 (h0 : topological_space (canonically_linear_ordered_monoid (option ennreal))) : t1_space (canonically_linear_ordered_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_12369 (h0 : functor.add_const (group (has_Inf Type)) Type) : @is_cyclic.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (has_Inf.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_12370 (h0 : topological_space (canonically_linear_ordered_monoid (sub_neg_monoid Type))) : discrete_topology (canonically_linear_ordered_monoid (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_12371 (h0 : has_mem.mem (is_R_or_C (semiring (semiring empty))) has_emptyc.emptyc) : @is_cyclic.{0} (is_R_or_C.{0} (semiring.{0} (semiring.{0} empty))) (@finset.pi.empty.{1 0} Type group.{0} (is_R_or_C.{0} (semiring.{0} (semiring.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_12372 (h0 : topological_space (has_norm (semiring congr_arg_kind))) : irreducible_space (has_norm (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_12373 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_add to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_12374 (h0 : topological_space (id (semiring (semiring congr_arg_kind)))) : path_connected_space (id (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_12375 (h0 : functor.add_const (list (has_to_string linarith.comp)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_12376 (h0 : topological_space (cancel_monoid (has_add unsigned))) : irreducible_space (cancel_monoid (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_12377 (h0 : not (topological_space (with_one num) -> false)) : @t0_space.{0} (with_one.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_12378 (h0 : topological_space (has_inter (option ennreal))) : path_connected_space (has_inter (option ennreal)) := sorry --non-trivial
lemma new_lemma_12379 (h0 : has_neg (has_div enat)) (h1 : measurable_space (has_div enat)) : has_measurable_neg (has_div enat) := sorry --non-trivial
lemma new_lemma_12380 (h0 : fin has_zero.zero) : @is_add_cyclic.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (add_group.{1} (generalized_boolean_algebra.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_12381 (h0 : not (list (topological_space linarith.comp_source) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_12382 (h0 : add_group (comm_ring (random_gen string_imp))) : is_add_cyclic (comm_ring (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_12383 (h0 : topological_space (mul_zero_class (option (option (option ennreal))))) : t0_space (mul_zero_class (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_12384 (h0 : add_group (option (semiring (semiring num)))) : is_add_cyclic (option (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_12385 (h0 : ring (has_le string.iterator_imp)) : strong_rank_condition (has_le string.iterator_imp) := sorry --non-trivial
lemma new_lemma_12386 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_12387 (h0 : topological_space (cancel_monoid (semiring (semiring (semiring (semiring empty)))))) : locally_compact_space (cancel_monoid (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_12388 (h0 : topological_space (add_comm_monoid Type)) : sequential_space (add_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_12389 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_12390 (h0 : function.extfun Type (functor.add_const (uniform_space (omega_complete_partial_order empty)))) : @separated_space.{0} (omega_complete_partial_order.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (omega_complete_partial_order.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (omega_complete_partial_order.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_12391 (h0 : functor.add_const (add_monoid (boolean_algebra unsigned)) linarith.comp) : @add_monoid.fg.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (boolean_algebra.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_12392 (h0 : complete_lattice real) : is_compactly_generated real := sorry --non-trivial
lemma new_lemma_12393 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (linear_ordered_semiring empty)) := sorry --non-trivial
lemma new_lemma_12394 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_12395 (h0 : uniform_space (has_le (mul_one_class std_gen))) : complete_space (has_le (mul_one_class std_gen)) := sorry --non-trivial
lemma new_lemma_12396 (h0 : add_monoid (has_nndist pos)) : add_monoid.fg (has_nndist pos) := sorry --non-trivial
lemma new_lemma_12397 (h0 : topological_space (ring (has_add name))) : loc_path_connected_space (ring (has_add name)) := sorry --non-trivial
lemma new_lemma_12398 (h0 : fin has_zero.zero) : @regular_space.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_12399 (h0 : group (has_compl (random_gen to_additive.value_type))) : group.fg (has_compl (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_12400 (h0 : semiring (semigroup (has_add (has_add Type)))) : is_noetherian_ring (semigroup (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_12401 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_12402 (h0 : function.extfun Type group) : @is_cyclic.{0} (preorder.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (preorder.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_12403 (h0 : ring (complete_semilattice_Sup (random_gen (random_gen fun_info)))) : rank_condition (complete_semilattice_Sup (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_12404 (h0 : ordered_comm_monoid (normed_comm_ring (option (has_neg_part pos)))) : has_exists_mul_of_le (normed_comm_ring (option (has_neg_part pos))) := sorry --non-trivial
lemma new_lemma_12405 (h0 : ring (comm_ring (semi_normed_ring reducibility_hints))) : is_domain (comm_ring (semi_normed_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_12406 (h0 : topological_space (ordered_cancel_add_comm_monoid (option (option (option (option pos)))))) : loc_path_connected_space (ordered_cancel_add_comm_monoid (option (option (option (option pos))))) := sorry --non-trivial
lemma new_lemma_12407 (h1 : filter (distrib_lattice to_additive.value_type)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_12408 (h0 : topological_space (has_neg linarith.comp)) : sequential_space (has_neg linarith.comp) := sorry --non-trivial
lemma new_lemma_12409 (h0 : fin has_zero.zero) : @group.fg.{0} (generalized_boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (group.{0} (generalized_boolean_algebra.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_12410 (h0 : topological_space (with_bot congr_arg_kind)) : irreducible_space (with_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_12411 (h0 : topological_space (has_Sup (semiring num))) : topological_space.separable_space (has_Sup (semiring num)) := sorry --non-trivial
lemma new_lemma_12412 (h0 : uniform_space (has_emptyc (has_top linarith.ineq))) : complete_space (has_emptyc (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_12413 (h0 : topological_space (canonically_ordered_comm_semiring (boolean_algebra.core (has_add pos)))) : normal_space (canonically_ordered_comm_semiring (boolean_algebra.core (has_add pos))) := sorry --non-trivial
lemma new_lemma_12414 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_12415 (h0 : has_mem.mem (complete_semilattice_Sup num) has_emptyc.emptyc) : @t0_space.{0} (complete_semilattice_Sup.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_12416 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (normed_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (normed_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_12417 (h0 : semiring (cancel_monoid name)) : is_noetherian_ring (cancel_monoid name) := sorry --non-trivial
lemma new_lemma_12418 (h1 : group (random_gen linarith.comp_source)) : is_cyclic (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_12419 (h0 : filter (ordered_cancel_comm_monoid (option unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_12420 (h0 : topological_space (add_comm_monoid linarith.comp)) : topological_space.separable_space (add_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_12421 (h0 : topological_space (finset unsigned)) : sequential_space (finset unsigned) := sorry --non-trivial
lemma new_lemma_12422 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) pos) : @topological_space.separable_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_12423 (h0 : topological_space (finset (has_neg (ring (ring linarith.comp))))) : irreducible_space (finset (has_neg (ring (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_12424 (h0 : has_lt (normed_field std_gen)) : no_max_order (normed_field std_gen) := sorry --non-trivial
lemma new_lemma_12425 (h0 : fin has_zero.zero) : @is_simple_group.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (group.{1} (normed_lattice_add_comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_12426 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_domain.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_12427 (h0 : topological_space (normed_group (comm_ring (has_ssubset linarith.ineq)))) : totally_disconnected_space (normed_group (comm_ring (has_ssubset linarith.ineq))) := sorry --non-trivial
lemma new_lemma_12428 (h0 : complete_lattice (complete_semilattice_Sup linarith.ineq)) : complete_lattice.is_Sup_finite_compact (complete_semilattice_Sup linarith.ineq) := sorry --non-trivial
lemma new_lemma_12429 (h0 : measurable_space ereal) (h1 : set ereal) : measurable_set h1 := sorry --non-trivial
lemma new_lemma_12430 (h0 : complete_lattice (mul_one_class (add_comm_semigroup string.iterator_imp))) : complete_lattice.is_Sup_finite_compact (mul_one_class (add_comm_semigroup string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_12431 (h0 : functor.add_const (finset (filter empty)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_12432 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} to_additive.value_type (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_12433 (h0 : functor.add_const (group (has_to_string linarith.comp)) linarith.comp) : @is_simple_group.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_12434 (h3 : set (linarith.ineq -> char)) : set.separates_points h3 := sorry --non-trivial
lemma new_lemma_12435 (h0 : set (has_lt linarith.ineq)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_12436 (h0 : topological_space std_gen) (h1 : preorder std_gen) : order_topology std_gen := sorry --non-trivial
lemma new_lemma_12437 (h0 : complete_lattice (ring linarith.comp)) : complete_lattice.is_Sup_finite_compact (ring linarith.comp) := sorry --non-trivial
lemma new_lemma_12438 (h0 : functor.add_const (function.extfun (Type 1) ring) (finset linarith.comp)) : @is_domain.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) (finset.{0} linarith.comp) h0) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_12439 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_Sup.{0} (ordered_ring.{0} (ordered_ring.{0} empty))) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_Sup.{0} (ordered_ring.{0} (ordered_ring.{0} empty))))  := sorry --non-trivial
lemma new_lemma_12440 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_12441 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space empty))) : @complete_space.{0} (measurable_space.{0} empty) (@finset.pi.empty.{1 0} Type uniform_space.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_12442 (h0 : ring (generalized_boolean_algebra (has_Inf (has_Inf pos)))) : is_domain (generalized_boolean_algebra (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_12443 (h1 : complete_lattice (with_zero string_imp)) : is_compactly_generated (with_zero string_imp) := sorry --non-trivial
lemma new_lemma_12444 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) pos) : @t1_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_12445 (h0 : ring (distrib (has_nnnorm char))) : rank_condition (distrib (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_12446 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_12447 (h0 : not (group (has_top unsigned) -> false)) : @normalizer_condition.{0} (has_top.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (has_top.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_12448 (h0 : functor.comp topological_space has_zero unsigned) : @path_connected_space.{0} (has_zero.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_12449 (h0 : list (ordered_comm_ring (has_pos_part (finset Type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_12450 (h0 : topological_space (canonically_ordered_comm_semiring (ring name))) : normal_space (canonically_ordered_comm_semiring (ring name)) := sorry --non-trivial
lemma new_lemma_12451 (h0 : functor.add_const (topological_space (cancel_monoid pos)) name) : @loc_path_connected_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_12452 (h0 : functor.add_const (topological_space (boolean_algebra.core linarith.comp)) (has_Inf pos)) : @irreducible_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} linarith.comp)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_12453 (h0 : complete_lattice (boolean_algebra (has_add (has_add pos)))) : is_compactly_generated (boolean_algebra (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_12454 (h0 : group (linear_ordered_add_comm_group (random_gen (has_nnnorm (has_nnnorm char))))) : is_cyclic (linear_ordered_add_comm_group (random_gen (has_nnnorm (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_12455 (h0 : topological_space (comm_monoid empty)) : loc_path_connected_space (comm_monoid empty) := sorry --non-trivial
lemma new_lemma_12456 (h0 : complete_lattice (linear_ordered_comm_group (option (option empty)))) : is_compactly_generated (linear_ordered_comm_group (option (option empty))) := sorry --non-trivial
lemma new_lemma_12457 (h0 : not (complete_lattice (with_one num) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_one.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_12458 (h0 : not (cancel_comm_monoid_with_zero (has_norm empty) -> false)) : @unique_factorization_monoid.{0} (has_norm.{0} empty) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (has_norm.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_12459 (h0 : semiring (ordered_comm_monoid environment.implicit_infer_kind)) : is_noetherian_ring (ordered_comm_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_12460 (h0 : complete_lattice (complete_linear_order (semiring unsigned))) : complete_lattice.is_Sup_finite_compact (complete_linear_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_12461 (h0 : uniform_space (partial_order num)) : separated_space (partial_order num) := sorry --non-trivial
lemma new_lemma_12462 (h0 : functor.add_const (ordered_add_comm_monoid (has_Inf pos)) (has_Inf Type)) : @archimedean.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_Inf.{0} pos)) (has_Inf.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_12463 (h0 : monoid (generalized_boolean_algebra name)) : monoid.fg (generalized_boolean_algebra name) := sorry --non-trivial
lemma new_lemma_12464 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_12465 (h0 : ring (metric_space linarith.comp_source)) : strong_rank_condition (metric_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_12466 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (ordered_cancel_add_comm_monoid.{0} (option.{0} (option.{0} pos))) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} (option.{0} (option.{0} pos))))  := sorry --non-trivial
lemma new_lemma_12467 (h0 : group (comm_ring (random_gen (has_ssubset to_additive.value_type)))) : group.fg (comm_ring (random_gen (has_ssubset to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_12468 (h0 : ring (comm_group (comm_group (has_to_string name)))) : is_principal_ideal_ring (comm_group (comm_group (has_to_string name))) := sorry --non-trivial
lemma new_lemma_12469 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (complete_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_12470 (h0 : topological_space (normed_group (random_gen to_additive.value_type))) : path_connected_space (normed_group (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_12471 (h1 : complete_lattice (mul_one_class (mul_one_class (add_comm_semigroup ereal)))) : complete_lattice.is_Sup_finite_compact (mul_one_class (mul_one_class (add_comm_semigroup ereal))) := sorry --non-trivial
lemma new_lemma_12472 (h0 : functor.add_const (function.extfun Type complete_lattice) environment.implicit_infer_kind) : @is_compactly_generated.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) environment.implicit_infer_kind h0) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_12473 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_12474 (h0 : functor.add_const (group (canonically_ordered_comm_semiring ennreal)) unsigned) : @is_cyclic.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_comm_semiring.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_12475 (h2 : topological_space (mul_one_class linarith.ineq)) (h3 : preorder (mul_one_class linarith.ineq)) : order_closed_topology (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_12476 (h0 : functor.add_const (function.extfun Type list) pos) : palindrome (function.extfun_app (functor.add_const.run h0) (has_add pos)) := sorry --non-trivial
lemma new_lemma_12477 (h0 : not (ring (add_monoid (has_inv fun_info)) -> false)) : @strong_rank_condition.{0} (add_monoid.{0} (has_inv.{0} fun_info)) (@classical.by_contradiction'.{1} (ring.{0} (add_monoid.{0} (has_inv.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_12478 (h0 : group (finset linarith.comp)) : group.fg (finset linarith.comp) := sorry --non-trivial
lemma new_lemma_12479 (h0 : functor.add_const (group (normed_comm_ring unsigned)) linarith.comp) : @normalizer_condition.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_12480 (h0 : group (linear_order (semiring empty))) : normalizer_condition (linear_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_12481 (h0 : ordered_add_comm_monoid (simple_graph congr_arg_kind)) : archimedean (simple_graph congr_arg_kind) := sorry --non-trivial
lemma new_lemma_12482 (h3 : filter (comm_ring char)) : filter.ne_bot h3 := sorry --non-trivial
lemma new_lemma_12483 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_12484 (h0 : functor.add_const (topological_space (partial_order empty)) congr_arg_kind) : @loc_path_connected_space.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_12485 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (topological_space.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (topological_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_12486 (h0 : group (normed_comm_ring (ring pos))) : normalizer_condition (normed_comm_ring (ring pos)) := sorry --non-trivial
lemma new_lemma_12487 (h0 : topological_space (with_bot fun_info)) : discrete_topology (with_bot fun_info) := sorry --non-trivial
lemma new_lemma_12488 (h0 : complete_lattice (normed_group (has_top (has_top (has_top (has_top to_additive.value_type)))))) : is_compactly_generated (normed_group (has_top (has_top (has_top (has_top to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_12489 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_12490 (h0 : ordered_comm_monoid (canonically_ordered_monoid name)) : has_exists_mul_of_le (canonically_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_12491 (h0 : add_group (simple_graph (option (option (option empty))))) : is_add_cyclic (simple_graph (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_12492 (h0 : functor.add_const (ordered_add_comm_monoid (mul_zero_class empty)) (semiring empty)) : @archimedean.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (mul_zero_class.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_12493 (h0 : function.extfun Type group) : @group.fg.{0} (encodable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (encodable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_12494 (h0 : complete_lattice (boolean_algebra.core (option (option unsigned)))) : is_atomistic (boolean_algebra.core (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_12495 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_noetherian_ring.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) semiring.{0}) (linear_ordered_comm_monoid_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_12496 (h0 : group (finset (option ennreal))) : is_cyclic (finset (option ennreal)) := sorry --non-trivial
lemma new_lemma_12497 (h0 : group (with_bot (has_nnnorm (random_gen (random_gen string_imp))))) : is_cyclic (with_bot (has_nnnorm (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_12498 (h0 : finset (linear_order num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_12499 (h0 : topological_space (with_zero (semiring (semiring num)))) : path_connected_space (with_zero (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_12500 (h0 : function.extfun Type topological_space) : @t0_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_12501 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @rank_condition.{0} (@id.{2} Type to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ring.{0}) (@id.{2} Type to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_12502 (h1 : ring (comm_ring reducibility_hints)) : rank_condition (comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_12503 (h0 : has_Inf (has_Inf real) -> has_Inf (has_Inf real) -> Prop) : is_antisymm (has_Inf (has_Inf real)) h0 := sorry --non-trivial
lemma new_lemma_12504 (h0 : ring (semi_normed_ring linarith.comp_source)) : is_domain (semi_normed_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_12505 (h0 : group (fintype char)) : is_cyclic (fintype char) := sorry --non-trivial
lemma new_lemma_12506 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @group.fg.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_12507 (h0 : functor.add_const (semiring (plift unsigned)) (semiring unsigned)) : @is_noetherian_ring.{1} (plift.{1} unsigned) (@functor.add_const.run.{1 0} (semiring.{1} (plift.{1} unsigned)) (semiring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_12508 (h0 : functor.add_const (group (semigroup linarith.comp)) environment.implicit_infer_kind) : @normalizer_condition.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_12509 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_12510 (h0 : finset (cancel_monoid (monoid pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_12511 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @separated_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 uniform_space.{1}) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_12512 (h0 : fin has_zero.zero) : @rank_condition.{0} (complete_linear_order.{0} (semiring.{0} (linear_ordered_comm_ring.{0} congr_arg_kind))) (@matrix.vec_empty.{0} (ring.{0} (complete_linear_order.{0} (semiring.{0} (linear_ordered_comm_ring.{0} congr_arg_kind)))) h0)  := sorry --non-trivial
lemma new_lemma_12513 (h0 : functor.add_const (complete_lattice (has_add environment.implicit_infer_kind)) linarith.comp) : @is_compactly_generated.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_add.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_12514 (h0 : topological_space (ordered_comm_ring (has_Inf (has_Inf (has_Inf Type))))) : loc_path_connected_space (ordered_comm_ring (has_Inf (has_Inf (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_12515 (h0 : group (has_ssubset (random_gen linarith.ineq))) : is_cyclic (has_ssubset (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_12516 (h0 : complete_lattice (linear_ordered_field (option (option ennreal)))) : complete_lattice.is_Sup_finite_compact (linear_ordered_field (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_12517 (h0 : complete_lattice (has_one (has_norm (has_norm fun_info)))) : is_atomistic (has_one (has_norm (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_12518 (h0 : finset (complete_distrib_lattice (option (option (option (option (option (option pos)))))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_12519 (h0 : ring (has_pos_part (has_add (has_add (ring (has_add (has_add pos))))))) : is_domain (has_pos_part (has_add (has_add (ring (has_add (has_add pos)))))) := sorry --non-trivial
lemma new_lemma_12520 (h0 : complete_lattice (comm_semigroup (has_add real))) : complete_lattice.is_Sup_finite_compact (comm_semigroup (has_add real)) := sorry --non-trivial
lemma new_lemma_12521 (h0 : monoid (boolean_algebra.core (finset linarith.comp))) : monoid.fg (boolean_algebra.core (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_12522 (h0 : monoid (simple_graph (has_Inf (has_Inf (has_add linarith.comp))))) : monoid.fg (simple_graph (has_Inf (has_Inf (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_12523 (h0 : topological_space (monoid (option (option ennreal)))) : totally_disconnected_space (monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_12524 (h0 : monoid (has_top (semiring (has_top congr_arg_kind)))) : monoid.fg (has_top (semiring (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_12525 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{1} (semigroup.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (semigroup.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_12526 (h0 : uniform_space (partial_order (has_top unsigned))) : complete_space (partial_order (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_12527 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_cancel_monoid Type)) name) : @unique_factorization_monoid.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (add_cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_12528 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @preconnected_space.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_12529 (h0 : function.extfun nat fin) : @normalizer_condition.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (group.{1} (canonically_linear_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_12530 (h0 : uniform_space (has_Inf (has_add (has_add (has_Inf (has_add linarith.comp)))))) : complete_space (has_Inf (has_add (has_add (has_Inf (has_add linarith.comp))))) := sorry --non-trivial
lemma new_lemma_12531 (h0 : uniform_space (has_zero empty)) : complete_space (has_zero empty) := sorry --non-trivial
lemma new_lemma_12532 (h0 : group (has_nndist (has_neg linarith.comp))) : normalizer_condition (has_nndist (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_12533 (h0 : functor.add_const (list (semigroup linarith.comp)) (ring linarith.comp)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_12534 (h0 : functor.add_const (functor.add_const (ring linarith.comp) name) name) : @strong_rank_condition.{0} linarith.comp (@functor.add_const.run.{0 0} (ring.{0} linarith.comp) name (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ring.{0} linarith.comp) name) name h0))  := sorry --non-trivial
lemma new_lemma_12535 (h0 : ring (linear_ordered_comm_monoid_with_zero (option unsigned))) : is_domain (linear_ordered_comm_monoid_with_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_12536 (h0 : uniform_space (random_gen (metric_space (metric_space linarith.comp)))) : separated_space (random_gen (metric_space (metric_space linarith.comp))) := sorry --non-trivial
lemma new_lemma_12537 (h0 : functor.add_const (uniform_space (add_group empty)) num) : @separated_space.{0} (add_group.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_group.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_12538 (h0 : ring (has_nnnorm linarith.comp_source)) : is_domain (has_nnnorm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_12539 (h0 : topological_space (add_cancel_monoid (comm_group (cancel_monoid name)))) : preirreducible_space (add_cancel_monoid (comm_group (cancel_monoid name))) := sorry --non-trivial
lemma new_lemma_12540 (h0 : topological_space (has_pos_part (has_Inf (has_Inf (has_Inf (has_Inf real)))))) : irreducible_space (has_pos_part (has_Inf (has_Inf (has_Inf (has_Inf real))))) := sorry --non-trivial
lemma new_lemma_12541 (h0 : functor.add_const (topological_space (bin_tree unsigned)) congr_arg_kind) : @locally_compact_space.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_12542 (h0 : functor.add_const (ring (has_to_string Type)) (has_neg environment.implicit_infer_kind)) : @is_domain.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_to_string.{1} Type)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_12543 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (add_right_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_12544 (h0 : topological_space (ring ennreal)) : locally_compact_space (ring ennreal) := sorry --non-trivial
lemma new_lemma_12545 (h0 h1 : multiset (has_lt (mul_one_class fun_info))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_12546 (h0 : group (ring name)) : group.fg (ring name) := sorry --non-trivial
lemma new_lemma_12547 (h0 : functor.add_const (topological_space (has_add Type)) linarith.comp) : @t0_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_12548 (h0 : functor.add_const (topological_space (boolean_algebra pos)) pos) : @topological_space.separable_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_12549 (h0 : list (complete_semilattice_Sup string_imp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_12550 (h0 : ring (normed_group (has_inv (has_ssubset to_additive.value_type)))) : rank_condition (normed_group (has_inv (has_ssubset to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_12551 (h0 : group (has_norm to_additive.value_type)) : group.fg (has_norm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_12552 (h0 : finset (linear_ordered_field (has_neg_part (comm_group (option (option name)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_12553 (h0 : topological_space (boolean_algebra (has_pos_part (has_add pos)))) : locally_compact_space (boolean_algebra (has_pos_part (has_add pos))) := sorry --non-trivial
lemma new_lemma_12554 (h0 : not (group (with_one congr_arg_kind) -> false)) : @normalizer_condition.{0} (with_one.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (with_one.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_12555 (h0 : functor.add_const (topological_space (preorder num)) empty) : @totally_disconnected_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_12556 (h0 : monoid (simple_graph (option empty))) : monoid.fg (simple_graph (option empty)) := sorry --non-trivial
lemma new_lemma_12557 (h0 : functor.add_const (function.extfun Type filter) pos) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_12558 (h0 : topological_space (normed_group (with_one congr_arg_kind))) : totally_disconnected_space (normed_group (with_one congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_12559 (h0 : functor.comp ordered_add_comm_monoid add_comm_monoid Type) : @archimedean.{1} (add_comm_monoid.{1} Type) (@functor.comp.run.{1 1 1} ordered_add_comm_monoid.{1} add_comm_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_12560 (h0 : topological_space (has_emptyc (random_gen (has_norm to_additive.value_type)))) : irreducible_space (has_emptyc (random_gen (has_norm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_12561 (h0 : functor.add_const (list (boolean_algebra.core Type)) (has_add (has_add Type))) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_12562 (h0 : topological_space (finset name)) : topological_space.separable_space (finset name) := sorry --non-trivial
lemma new_lemma_12563 (h0 : group (has_Inf pos)) : is_cyclic (has_Inf pos) := sorry --non-trivial
lemma new_lemma_12564 (h0 : topological_space (has_pos_part (has_Inf (has_neg Type)))) : locally_compact_space (has_pos_part (has_Inf (has_neg Type))) := sorry --non-trivial
lemma new_lemma_12565 (h0 : topological_space (dlist (random_gen linarith.ineq))) : t0_space (dlist (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_12566 (h0 : functor.add_const Prop (has_nndist (semigroup pos))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_12567 (h0 : function.extfun nat fin) : @totally_disconnected_space.{0} (has_add.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_12568 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_12569 (h0 : group (generalized_boolean_algebra (has_bot real))) : group.fg (generalized_boolean_algebra (has_bot real)) := sorry --non-trivial
lemma new_lemma_12570 (h0 : complete_lattice (with_bot (semiring (random_gen linarith.comp_source)))) : complete_lattice.is_Sup_finite_compact (with_bot (semiring (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_12571 (h1 : monoid (with_one (random_gen (has_emptyc to_additive.value_type)))) : monoid.fg (with_one (random_gen (has_emptyc to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_12572 (h0 : fin has_zero.zero) : @is_atomistic.{0} (canonically_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (canonically_ordered_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_12573 (h0 : function.extfun nat fin) : @t1_space.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_12574 (h0 : filter (semigroup (has_neg_part (has_neg_part Type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_12575 (h0 : functor.add_const (ordered_comm_monoid (mul_zero_class pos)) (option pos)) : @has_exists_mul_of_le.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (mul_zero_class.{0} pos)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_12576 (h0 : functor.add_const (topological_space (add_left_cancel_semigroup unsigned)) congr_arg_kind) : @loc_path_connected_space.{0} (add_left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_12577 (h0 : topological_space (left_cancel_semigroup (partial_order num))) : totally_separated_space (left_cancel_semigroup (partial_order num)) := sorry --non-trivial
lemma new_lemma_12578 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_12579 (h0 : ring (normed_comm_ring (comm_group Type))) : is_domain (normed_comm_ring (comm_group Type)) := sorry --non-trivial
lemma new_lemma_12580 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (measurable_space.dynkin_system.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_12581 (h0 : ordered_add_comm_monoid (normed_linear_ordered_group unsigned)) : archimedean (normed_linear_ordered_group unsigned) := sorry --non-trivial
lemma new_lemma_12582 (h0 : topological_space (has_neg (finset (finset (finset pos))))) : loc_path_connected_space (has_neg (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_12583 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) real) : @sequential_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_12584 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (has_one unsigned)) := sorry --non-trivial
lemma new_lemma_12585 (h0 : has_mem.mem (has_norm linarith.comp) has_emptyc.emptyc) : @complete_space.{0} (has_norm.{0} linarith.comp) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_norm.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_12586 (h0 : not (uniform_space (normed_field linarith.comp_source) -> false)) : @complete_space.{0} (normed_field.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (uniform_space.{0} (normed_field.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_12587 (h0 : ring (has_bot (option (option (option (option empty)))))) : strong_rank_condition (has_bot (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_12588 (h0 : ring (has_to_string (has_add ennreal))) : is_principal_ideal_ring (has_to_string (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_12589 (h2 : list (has_emptyc (random_gen linarith.comp_source))) : list.nodup h2 := sorry --non-trivial
lemma new_lemma_12590 (h0 : monoid (linear_ordered_comm_ring (semiring (semiring empty)))) : monoid.fg (linear_ordered_comm_ring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_12591 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) linarith.comp) : @irreducible_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_12592 (h0 : ring (has_nndist (ring environment.implicit_infer_kind))) : strong_rank_condition (has_nndist (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_12593 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_ssubset.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_ssubset.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_12594 (h0 : group (has_union congr_arg_kind)) : is_cyclic (has_union congr_arg_kind) := sorry --non-trivial
lemma new_lemma_12595 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_12596 (h0 : ring (ordered_ring num)) : is_principal_ideal_ring (ordered_ring num) := sorry --non-trivial
lemma new_lemma_12597 (h0 : topological_space (normed_group (random_gen (random_gen linarith.comp_source)))) : locally_compact_space (normed_group (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_12598 (h1 : ring string) : is_domain string := sorry --non-trivial
lemma new_lemma_12599 (h0 : topological_space (has_zero (has_scalar environment.implicit_infer_kind Type))) : t1_space (has_zero (has_scalar environment.implicit_infer_kind Type)) := sorry --non-trivial
lemma new_lemma_12600 (h0 : functor.add_const (functor.comp ring comm_group unsigned) Type) : @strong_rank_condition.{0} (comm_group.{0} unsigned) (@functor.comp.run.{0 0 0} ring.{0} comm_group.{0} unsigned (@functor.add_const.run.{0 1} (functor.comp.{0 0 0} ring.{0} comm_group.{0} unsigned) Type h0))  := sorry --non-trivial
lemma new_lemma_12601 (h0 : complete_lattice (ordered_ring congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (ordered_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_12602 (h0 : topological_space (has_add (has_zero unsigned))) : preconnected_space (has_add (has_zero unsigned)) := sorry --non-trivial
lemma new_lemma_12603 (h0 : group (omega_complete_partial_order string_imp)) : is_cyclic (omega_complete_partial_order string_imp) := sorry --non-trivial
lemma new_lemma_12604 (h0 : topological_space (has_to_string (comm_group unsigned))) : totally_disconnected_space (has_to_string (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_12605 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (comm_semigroup.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_12606 (h0 : group (add_comm_monoid (has_nndist Type))) : is_cyclic (add_comm_monoid (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_12607 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_12608 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (has_inter.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_inter.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_12609 (h0 : group (has_star num)) : group.fg (has_star num) := sorry --non-trivial
lemma new_lemma_12610 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_bot.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_12611 (h0 : fin has_zero.zero) : @group.fg.{0} (sub_neg_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (sub_neg_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_12612 (h0 : complete_lattice (comm_monoid unsigned)) : is_atomistic (comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_12613 (h0 : function.extfun Type ring) : @is_domain.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_12614 (h0 : uniform_space (has_emptyc (has_top empty))) : separated_space (has_emptyc (has_top empty)) := sorry --non-trivial
lemma new_lemma_12615 (h0 : topological_space (complete_distrib_lattice congr_arg_kind)) : t1_space (complete_distrib_lattice congr_arg_kind) := sorry --non-trivial
lemma new_lemma_12616 (h1 : topological_space (has_ssubset (has_to_string (random_gen (comm_ring reducibility_hints))))) : t0_space (has_ssubset (has_to_string (random_gen (comm_ring reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_12617 (h0 : functor.add_const (ring (add_cancel_monoid environment.implicit_infer_kind)) (finset ennreal)) : @is_domain.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) (finset.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_12618 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) linarith.comp) : @preconnected_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_12619 (h1 : function.extfun Type uniform_space) : @complete_space.{0} (distrib_lattice.{0} string_imp) (@function.extfun_app.{2 1} Type uniform_space.{0} h1 (distrib_lattice.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_12620 (h0 : topological_space (has_star (has_top (filter (has_top (semiring empty)))))) : discrete_topology (has_star (has_top (filter (has_top (semiring empty))))) := sorry --non-trivial
lemma new_lemma_12621 (h0 : monoid (has_emptyc (has_norm (has_norm linarith.comp_source)))) : monoid.fg (has_emptyc (has_norm (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_12622 (h0 : function.extfun (Type 1) topological_space) : @preirreducible_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_12623 (h0 : topological_space (as_linear_order num)) : locally_compact_space (as_linear_order num) := sorry --non-trivial
lemma new_lemma_12624 (h0 : topological_space (pseudo_metric_space empty)) : locally_compact_space (pseudo_metric_space empty) := sorry --non-trivial
lemma new_lemma_12625 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_bot.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_12626 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_edist empty)) := sorry --non-trivial
lemma new_lemma_12627 (h0 : ring (cancel_monoid (semigroup Type))) : rank_condition (cancel_monoid (semigroup Type)) := sorry --non-trivial
lemma new_lemma_12628 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_12629 (h0 : complete_lattice (has_top (has_inv (has_inv to_additive.value_type)))) : complete_lattice.is_Sup_finite_compact (has_top (has_inv (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_12630 (h0 : not (add_group (has_sub linarith.comp) -> false)) : @is_add_cyclic.{0} (has_sub.{0} linarith.comp) (@classical.by_contradiction'.{1} (add_group.{0} (has_sub.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_12631 (h0 : semiring (left_cancel_monoid (semiring (semiring empty)))) : is_noetherian_ring (left_cancel_monoid (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_12632 (h0 : topological_space (has_nndist ennreal)) : preirreducible_space (has_nndist ennreal) := sorry --non-trivial
lemma new_lemma_12633 (h0 : filter (add_monoid (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_12634 (h0 : topological_space (finset (comm_group Type))) : totally_disconnected_space (finset (comm_group Type)) := sorry --non-trivial
lemma new_lemma_12635 (h0 : functor.add_const (topological_space (finset linarith.comp)) pos) : @locally_compact_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_12636 (h0 : not (complete_lattice (comm_ring fun_info) -> false)) : @is_compactly_generated.{0} (comm_ring.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (comm_ring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_12637 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) linarith.comp) : @t0_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_12638 (h0 : topological_space pos) : t0_space pos := sorry --non-trivial
lemma new_lemma_12639 (h0 : complete_lattice (linear_ordered_semiring (semiring (semiring unsigned)))) : is_compactly_generated (linear_ordered_semiring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_12640 (h0 : topological_space (normed_lattice_add_comm_group (has_neg (has_neg pos)))) : discrete_topology (normed_lattice_add_comm_group (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_12641 (h0 : uniform_space (has_top (random_gen fun_info))) : separated_space (has_top (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_12642 (h0 : function.extfun Type group) : @is_cyclic.{0} (normed_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_12643 (h2 : has_mem.mem group has_emptyc.emptyc) : @normalizer_condition.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h2) (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_12644 (h0 : add_monoid (comm_group (has_add environment.implicit_infer_kind))) : add_monoid.fg (comm_group (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_12645 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_12646 (h0 : ring (free_add_monoid congr_arg_kind)) : strong_rank_condition (free_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_12647 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_bot.{0} (ordered_comm_monoid.{0} linarith.comp)) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_bot.{0} (ordered_comm_monoid.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_12648 (h0 : topological_space (has_add (ring ennreal))) : t1_space (has_add (ring ennreal)) := sorry --non-trivial
lemma new_lemma_12649 (h0 : ordered_add_comm_monoid (add_right_cancel_monoid num)) : archimedean (add_right_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_12650 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra.core Type)) linarith.comp) : @has_exists_mul_of_le.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (boolean_algebra.core.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_12651 (h0 : topological_space (sub_neg_monoid (has_neg (has_neg name)))) : totally_disconnected_space (sub_neg_monoid (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_12652 (h0 : add_group (add_comm_monoid (has_neg_part unsigned))) : is_add_cyclic (add_comm_monoid (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_12653 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @locally_compact_space.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) num)  := sorry --non-trivial
lemma new_lemma_12654 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_12655 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_12656 (h0 : functor.comp ring has_neg name) : @is_principal_ideal_ring.{0} (has_neg.{0} name) (@functor.comp.run.{0 0 0} ring.{0} has_neg.{0} name h0)  := sorry --non-trivial
lemma new_lemma_12657 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_12658 (h0 : topological_space (has_add (finset (has_to_string linarith.comp)))) : topological_space.separable_space (has_add (finset (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_12659 (h0 : group (has_pos_part (has_neg (finset pos)))) : group.fg (has_pos_part (has_neg (finset pos))) := sorry --non-trivial
lemma new_lemma_12660 (h0 : function.extfun (Type 1) uniform_space) : @complete_space.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_12661 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_12662 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (is_R_or_C.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (is_R_or_C.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_12663 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_12664 (h0 : add_monoid (plift (semiring (semiring congr_arg_kind)))) : add_monoid.fg (plift (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_12665 (h0 : add_group (boolean_algebra.core pos)) : is_add_cyclic (boolean_algebra.core pos) := sorry --non-trivial
lemma new_lemma_12666 (h0 : topological_space (topological_space (with_one reducibility_hints))) : t0_space (topological_space (with_one reducibility_hints)) := sorry --non-trivial
lemma new_lemma_12667 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (normed_comm_ring.{0} num) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (normed_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_12668 (h0 : topological_space (measure_theory.measure_space (semiring congr_arg_kind))) : irreducible_space (measure_theory.measure_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_12669 (h0 : topological_space (mul_one_class ereal)) : t0_space (mul_one_class ereal) := sorry --non-trivial
lemma new_lemma_12670 (h0 : ring (ring (finset Type))) : is_principal_ideal_ring (ring (finset Type)) := sorry --non-trivial
lemma new_lemma_12671 (h0 : topological_space (has_zero (has_to_string unsigned))) : t1_space (has_zero (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_12672 (h0 : has_neg (mul_one_class fun_info)) (h2 : measurable_space (mul_one_class fun_info)) : has_measurable_neg (mul_one_class fun_info) := sorry --non-trivial
lemma new_lemma_12673 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_12674 (h0 : functor.add_const (uniform_space (finset Type)) (finset Type)) : @complete_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (finset.{1} Type)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_12675 (h0 : topological_space (add_comm_monoid (add_comm_monoid Type))) : irreducible_space (add_comm_monoid (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_12676 (h0 : ring (generalized_boolean_algebra (canonically_linear_ordered_monoid name))) : is_domain (generalized_boolean_algebra (canonically_linear_ordered_monoid name)) := sorry --non-trivial
lemma new_lemma_12677 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (bin_tree.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} num))  := sorry --non-trivial
lemma new_lemma_12678 (h0 : functor.add_const (filter Type) (finset (finset (finset (finset (finset linarith.comp)))))) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_12679 (h0 : cancel_comm_monoid_with_zero (has_to_string (add_cancel_monoid name))) : unique_factorization_monoid (has_to_string (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_12680 (h0 : topological_space (comm_group (option (option pos)))) : totally_disconnected_space (comm_group (option (option pos))) := sorry --non-trivial
lemma new_lemma_12681 (h0 : group (boolean_algebra (has_Inf pos))) : group.fg (boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_12682 (h0 : cancel_comm_monoid_with_zero (mul_zero_class name)) : unique_factorization_monoid (mul_zero_class name) := sorry --non-trivial
lemma new_lemma_12683 (h0 : topological_space (comm_group (has_add Type))) : normal_space (comm_group (has_add Type)) := sorry --non-trivial
lemma new_lemma_12684 (h0 : topological_space (normed_linear_ordered_group (semiring congr_arg_kind))) : preirreducible_space (normed_linear_ordered_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_12685 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_12686 (h0 : functor.add_const (monoid (boolean_algebra.core environment.implicit_infer_kind)) linarith.comp) : @monoid.fg.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_12687 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @totally_separated_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_12688 (h0 : complete_lattice (has_emptyc (has_top (has_norm to_additive.value_type)))) : is_atomistic (has_emptyc (has_top (has_norm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_12689 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (has_nnnorm.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_nnnorm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_12690 (h0 : not (filter (dlist to_additive.value_type) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_12691 (h0 : complete_lattice (encodable linarith.ineq)) : is_compactly_generated (encodable linarith.ineq) := sorry --non-trivial
lemma new_lemma_12692 (h0 : uniform_space (preorder (ordered_ring empty))) : complete_space (preorder (ordered_ring empty)) := sorry --non-trivial
lemma new_lemma_12693 (h0 : cancel_comm_monoid_with_zero (ordered_comm_monoid (has_Inf pos))) : unique_factorization_monoid (ordered_comm_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_12694 (h0 : not (has_mem.mem (complete_semilattice_Sup empty) has_emptyc.emptyc -> false)) : @discrete_topology.{0} (complete_semilattice_Sup.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} empty) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} empty) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_12695 (h0 : function.extfun (Type 1) complete_lattice) : @is_compactly_generated.{1} (plift.{1} congr_arg_kind) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (plift.{1} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_12696 (h0 : complete_lattice (has_top (random_gen (random_gen to_additive.value_type)))) : is_compactly_generated (has_top (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_12697 (h0 : set (has_div fun_info)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_12698 (h0 : group (add_cancel_monoid ennreal)) : is_cyclic (add_cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_12699 (h0 : functor.add_const (ring (boolean_algebra environment.implicit_infer_kind)) name) : @is_domain.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_12700 (h0 : functor.add_const (ring (semigroup Type)) Type) : @is_principal_ideal_ring.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (semigroup.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_12701 (h0 : add_group (distrib (has_nnnorm enat))) : is_add_cyclic (distrib (has_nnnorm enat)) := sorry --non-trivial
lemma new_lemma_12702 (h0 : ordered_comm_monoid (normed_comm_ring (has_add (finset unsigned)))) : has_exists_mul_of_le (normed_comm_ring (has_add (finset unsigned))) := sorry --non-trivial
lemma new_lemma_12703 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (ordered_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_12704 (h0 : function.extfun Type ring) : @is_domain.{0} (has_one.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_one.{0} num))  := sorry --non-trivial
lemma new_lemma_12705 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) congr_arg_kind) : @path_connected_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_12706 (h0 : group (generalized_boolean_algebra (has_add (has_add pos)))) : is_simple_group (generalized_boolean_algebra (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_12707 (h0 : not (topological_space (linear_ordered_semiring congr_arg_kind) -> false)) : @irreducible_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_12708 (h0 : ring (metric_space (semiring (semiring empty)))) : rank_condition (metric_space (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_12709 (h1 : topological_space (non_unital_non_assoc_semiring char)) : path_connected_space (non_unital_non_assoc_semiring char) := sorry --non-trivial
lemma new_lemma_12710 (h0 : filter (distrib_lattice (denumerable (distrib (random_gen (random_gen to_additive.value_type)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_12711 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (mul_zero_class unsigned)) := sorry --non-trivial
lemma new_lemma_12712 (h0 : fin has_zero.zero) : @is_simple_group.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (group.{0} (has_add.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_12713 (h0 : topological_space (semigroup (option unsigned))) : loc_path_connected_space (semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_12714 (h0 : functor.add_const (function.extfun Type ring) environment.implicit_infer_kind) : @strong_rank_condition.{0} (cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) environment.implicit_infer_kind h0) (cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_12715 (h0 : functor.add_const (complete_lattice (semigroup pos)) linarith.comp) : @is_compactly_generated.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_12716 (h0 : topological_space (has_div (mul_one_class (mul_one_class char)))) : totally_disconnected_space (has_div (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_12717 (h0 : functor.add_const (topological_space (has_add linarith.comp)) linarith.comp) : @preconnected_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_12718 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_12719 (h0 : topological_space (has_Inf (finset Type))) : preconnected_space (has_Inf (finset Type)) := sorry --non-trivial
lemma new_lemma_12720 (h0 : topological_space (with_bot (has_top linarith.comp_source))) : totally_separated_space (with_bot (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_12721 (h0 : functor.add_const (group (has_Sup empty)) congr_arg_kind) : @normalizer_condition.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (has_Sup.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_12722 (h0 : finset (canonically_ordered_add_monoid (option empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_12723 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} num (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) num)  := sorry --non-trivial
lemma new_lemma_12724 (h0 : functor.add_const (complete_lattice (has_add Type)) linarith.comp) : @is_atomistic.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_add.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_12725 (h1 : complete_lattice (uniform_space reducibility_hints)) : is_compactly_generated (uniform_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_12726 (h0 : functor.comp complete_lattice has_zero ennreal) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} ennreal) (@functor.comp.run.{0 0 0} complete_lattice.{0} has_zero.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_12727 (h0 : set (mul_one_class linarith.ineq)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_12728 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_12729 (h0 : uniform_space (has_to_string (has_neg name))) : complete_space (has_to_string (has_neg name)) := sorry --non-trivial
lemma new_lemma_12730 (h0 : functor.add_const (ordered_comm_monoid (has_to_string unsigned)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_to_string.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_12731 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_bot.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_12732 (h0 : complete_lattice (with_one unsigned)) : is_compactly_generated (with_one unsigned) := sorry --non-trivial
lemma new_lemma_12733 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (dlist string_imp)) := sorry --non-trivial
lemma new_lemma_12734 (h0 : topological_space (has_Inf (has_Inf Type))) : preirreducible_space (has_Inf (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_12735 (h0 : add_group (has_norm (random_gen (random_gen linarith.ineq)))) : is_add_cyclic (has_norm (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_12736 (h0 : functor.add_const (topological_space (ring name)) (comm_group name)) : @totally_separated_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_12737 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (finset pos)) := sorry --non-trivial
lemma new_lemma_12738 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_12739 (h0 : monoid (has_to_string (has_neg (ring Type)))) : monoid.fg (has_to_string (has_neg (ring Type))) := sorry --non-trivial
lemma new_lemma_12740 (h0 : topological_space (has_inv (measure_theory.measure_space char))) : t0_space (has_inv (measure_theory.measure_space char)) := sorry --non-trivial
lemma new_lemma_12741 (h0 : ring (left_cancel_monoid (option unsigned))) : is_principal_ideal_ring (left_cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_12742 (h0 : function.extfun (finset Type) (has_mem.mem (with_one num))) : @add_monoid.fg.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type add_monoid.{0} (with_one.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_12743 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_12744 (h0 : functor.add_const (monoid (finset Type)) Type) : @monoid.fg.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (monoid.{1} (finset.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_12745 (h0 : functor.add_const (topological_space auto.case_option) num) : @discrete_topology.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) num h0)  := sorry --non-trivial
lemma new_lemma_12746 (h0 : empty -> unsigned -> Prop) : relator.right_total h0 := sorry --non-trivial
lemma new_lemma_12747 (h0 : functor.add_const (add_group (complete_distrib_lattice unsigned)) empty) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (complete_distrib_lattice.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_12748 (h0 : topological_space (has_norm (random_gen (has_nnnorm (random_gen fun_info))))) : irreducible_space (has_norm (random_gen (has_nnnorm (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_12749 (h0 : topological_space (mul_zero_class linarith.comp)) : totally_separated_space (mul_zero_class linarith.comp) := sorry --non-trivial
lemma new_lemma_12750 (h0 : function.extfun Type topological_space) : @t1_space.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_12751 (h0 : ring (option (semiring congr_arg_kind))) : is_principal_ideal_ring (option (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_12752 (h2 : ring (distrib to_additive.value_type)) : rank_condition (distrib to_additive.value_type) := sorry --non-trivial
lemma new_lemma_12753 (h0 : functor.add_const (group (pseudo_metric_space empty)) congr_arg_kind) : @normalizer_condition.{0} (pseudo_metric_space.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (pseudo_metric_space.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_12754 (h0 : add_right_cancel_monoid (has_top congr_arg_kind) -> add_right_cancel_monoid (has_top congr_arg_kind) -> Prop) : is_strict_order (add_right_cancel_monoid (has_top congr_arg_kind)) h0 := sorry --non-trivial
lemma new_lemma_12755 (h0 : topological_space (has_add (has_to_string (has_to_string congr_arg_kind)))) : preconnected_space (has_add (has_to_string (has_to_string congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_12756 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (normed_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_12757 (h0 : functor.add_const (topological_space (simple_graph linarith.comp)) (finset pos)) : @irreducible_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} linarith.comp)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_12758 (h0 : ring (partial_order empty)) : is_domain (partial_order empty) := sorry --non-trivial
lemma new_lemma_12759 (h0 : list (ordered_comm_ring (ring (has_Inf linarith.comp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_12760 (h0 : functor.add_const (group (complete_distrib_lattice pos)) Type) : @is_simple_group.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (complete_distrib_lattice.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_12761 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_emptyc.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_12762 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (canonically_linear_ordered_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_12763 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) Type) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_12764 (h0 : functor.add_const (ring (has_zero name)) linarith.comp) : @rank_condition.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_12765 (h2 : add_group (add_comm_semigroup linarith.ineq)) : is_add_cyclic (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_12766 (h0 : list (metric_space (semiring empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_12767 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (as_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (as_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_12768 (h0 : functor.add_const (function.extfun Type add_group) pos) : @is_add_cyclic.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) pos h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_12769 (h0 : functor.add_const (topological_space (add_comm_monoid name)) linarith.comp) : @regular_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_12770 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_12771 (h0 : simple_graph (option empty)) (h1 : option empty) : simple_graph.support h0 h1 := sorry --non-trivial
lemma new_lemma_12772 (h0 : cancel_comm_monoid_with_zero (has_pos_part (has_neg pos))) : unique_factorization_monoid (has_pos_part (has_neg pos)) := sorry --non-trivial
lemma new_lemma_12773 (h0 : topological_space (as_linear_order unsigned)) : t0_space (as_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_12774 (h0 : topological_space (add_group (semiring (semiring (semiring (semiring empty)))))) : preirreducible_space (add_group (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_12775 (h0 : topological_space (ordered_comm_ring (ring name))) : irreducible_space (ordered_comm_ring (ring name)) := sorry --non-trivial
lemma new_lemma_12776 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (has_inv.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_inv.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_12777 (h0 : functor.add_const (topological_space (plift congr_arg_kind)) (semiring empty)) : @totally_disconnected_space.{1} (plift.{1} congr_arg_kind) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} congr_arg_kind)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_12778 (h0 : filter (finset (finset environment.implicit_infer_kind))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_12779 (h0 : topological_space (preorder (semiring (semiring (semiring num))))) : t1_space (preorder (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_12780 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_12781 (h0 : topological_space (sub_neg_monoid (has_pos_part linarith.comp))) : topological_space.separable_space (sub_neg_monoid (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_12782 (h0 : functor.add_const (topological_space (semigroup pos)) unsigned) : @t1_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_12783 (h0 : ring (mul_one_class to_additive.value_type)) : rank_condition (mul_one_class to_additive.value_type) := sorry --non-trivial
lemma new_lemma_12784 (h0 : complete_lattice (with_one (has_inv (random_gen string_imp)))) : is_atomistic (with_one (has_inv (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_12785 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_12786 (h0 : function.extfun Type topological_space) : @regular_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_12787 (h0 : function.extfun (Type 1) (functor.add_const (add_monoid pos))) : @add_monoid.fg.{0} pos (@functor.add_const.run.{0 1} (add_monoid.{0} pos) Type (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (add_monoid.{0} pos)) h0 Type))  := sorry --non-trivial
lemma new_lemma_12788 (h0 : ring (distrib_lattice (fintype znum))) : strong_rank_condition (distrib_lattice (fintype znum)) := sorry --non-trivial
lemma new_lemma_12789 (h0 : functor.add_const (topological_space (boolean_algebra.core linarith.comp)) (ring name)) : @preconnected_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} linarith.comp)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_12790 (h0 : functor.add_const (ring (has_star unsigned)) empty) : @rank_condition.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_star.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_12791 (h0 : functor.comp topological_space linear_ordered_field unsigned) : @locally_compact_space.{0} (linear_ordered_field.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} unsigned)) name (@functor.comp.run.{0 0 0} topological_space.{0} linear_ordered_field.{0} unsigned h0))  := sorry --non-trivial
lemma new_lemma_12792 (h0 : functor.add_const (list (is_R_or_C empty)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_12793 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_12794 (h0 : filter (has_to_string (add_comm_monoid environment.implicit_infer_kind))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_12795 (h0 : finset (add_cancel_monoid (has_to_string name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_12796 (h0 : topological_space (measurable_space (semiring linarith.comp))) : t0_space (measurable_space (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_12797 (h0 : topological_space (denumerable (has_ssubset linarith.comp_source))) : t0_space (denumerable (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_12798 (h0 : functor.add_const (topological_space (linear_ordered_field pos)) pos) : @sequential_space.{0} (linear_ordered_field.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_12799 (h2 : has_neg environment.projection_info) (h3 : measurable_space environment.projection_info) : has_measurable_neg environment.projection_info := sorry --non-trivial
lemma new_lemma_12800 (h0 : group (has_compl (random_gen char))) : group.fg (has_compl (random_gen char)) := sorry --non-trivial
lemma new_lemma_12801 (h0 : functor.add_const (ordered_add_comm_monoid (cancel_monoid empty)) empty) : @archimedean.{0} (cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_12802 (h0 : finset (boolean_algebra (ordered_ring linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_12803 (h0 : topological_space (ring (finset (has_add pos)))) : discrete_topology (ring (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_12804 (h0 : not (topological_space (random_gen linarith.comp) -> false)) : @locally_compact_space.{0} (random_gen.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_12805 (h0 : functor.add_const (topological_space (normed_comm_ring name)) name) : @preirreducible_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_12806 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_12807 (h1 : set (add_group enat -> linarith.ineq)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_12808 (h0 : ring (ring (has_add name))) : is_domain (ring (has_add name)) := sorry --non-trivial
lemma new_lemma_12809 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) linarith.comp) : @sequential_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_12810 (h0 : filter (has_top (monoid (has_norm to_additive.value_type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_12811 (h0 : functor.add_const (ring (has_Sup unsigned)) empty) : @rank_condition.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_Sup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_12812 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (ordered_comm_ring.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_12813 (h0 : fin has_zero.zero) : @archimedean.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) h0) (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_12814 (h0 : ring (add_comm_monoid (option (option (option unsigned))))) : strong_rank_condition (add_comm_monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_12815 (h0 : functor.add_const (ring (boolean_algebra.core Type)) environment.implicit_infer_kind) : @is_domain.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.core.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_12816 (h0 : function.extfun nat fin) : @is_add_cyclic.{0} (has_to_string.{0} real) (@function.extfun_app.{2 1} Type add_group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type add_group.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (has_to_string.{0} real))  := sorry --non-trivial
lemma new_lemma_12817 (h0 : complete_lattice (has_div string_imp)) : is_compactly_generated (has_div string_imp) := sorry --non-trivial
lemma new_lemma_12818 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_12819 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (pseudo_metric_space pos)) := sorry --non-trivial
lemma new_lemma_12820 (h0 : semiring (left_cancel_semigroup (semiring num))) : is_noetherian_ring (left_cancel_semigroup (semiring num)) := sorry --non-trivial
lemma new_lemma_12821 (h0 : ring (comm_group (has_to_string pos))) : strong_rank_condition (comm_group (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_12822 (h1 : topological_space (linear_ordered_add_comm_monoid_with_top char)) : t0_space (linear_ordered_add_comm_monoid_with_top char) := sorry --non-trivial
lemma new_lemma_12823 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_12824 (h0 : ring (random_gen (comm_ring fun_info))) : is_domain (random_gen (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_12825 (h0 : complete_lattice (has_Sup (option (option congr_arg_kind)))) : is_compactly_generated (has_Sup (option (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_12826 (h0 : topological_space (linear_ordered_comm_ring (semiring (semiring (semiring congr_arg_kind))))) : discrete_topology (linear_ordered_comm_ring (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_12827 (h0 : functor.add_const (finset (preorder empty)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_12828 (h0 : add_group (add_comm_semigroup (cancel_monoid (mul_one_class (normed_field fun_info))))) : is_add_cyclic (add_comm_semigroup (cancel_monoid (mul_one_class (normed_field fun_info)))) := sorry --non-trivial
lemma new_lemma_12829 (h1 : random_gen fun_info -> random_gen fun_info -> bool) : is_dec_refl h1 := sorry --non-trivial
lemma new_lemma_12830 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_12831 (h0 : group (topological_space (comm_ring to_additive.value_type))) : is_cyclic (topological_space (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_12832 (h0 : cancel_comm_monoid_with_zero (complete_distrib_lattice (finset Type))) : unique_factorization_monoid (complete_distrib_lattice (finset Type)) := sorry --non-trivial
lemma new_lemma_12833 (h0 : topological_space (has_ssubset (add_right_cancel_monoid linarith.ineq))) : path_connected_space (has_ssubset (add_right_cancel_monoid linarith.ineq)) := sorry --non-trivial
lemma new_lemma_12834 (h0 : functor.add_const (group (add_comm_monoid linarith.comp)) (ring Type)) : @normalizer_condition.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (add_comm_monoid.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_12835 (h0 : functor.comp filter pseudo_metric_space unsigned) : countable_Inter_filter (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_12836 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_12837 (h0 : cancel_comm_monoid_with_zero (ring (boolean_algebra linarith.comp))) : unique_factorization_monoid (ring (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_12838 (h0 : ring (finset (has_nndist name))) : strong_rank_condition (finset (has_nndist name)) := sorry --non-trivial
lemma new_lemma_12839 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_12840 (h1 : ring (linear_ordered_semiring (has_norm (has_norm linarith.ineq)))) : strong_rank_condition (linear_ordered_semiring (has_norm (has_norm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_12841 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_12842 (h0 : topological_space (measurable_space (has_norm empty))) : totally_disconnected_space (measurable_space (has_norm empty)) := sorry --non-trivial
lemma new_lemma_12843 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_inter unsigned)) := sorry --non-trivial
lemma new_lemma_12844 (h0 : ring (has_scalar (has_neg_part ennreal) ennreal)) : strong_rank_condition (has_scalar (has_neg_part ennreal) ennreal) := sorry --non-trivial
lemma new_lemma_12845 (h0 : uniform_space (has_add (finset (finset pos)))) : separated_space (has_add (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_12846 (h0 : not (topological_space (encodable to_additive.value_type) -> false)) : @t0_space.{0} (encodable.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (encodable.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_12847 (h0 : fin has_zero.zero) : @sequential_space.{1} (add_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (add_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_12848 (h0 : topological_space (add_group (semiring (has_norm linarith.comp)))) : t0_space (add_group (semiring (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_12849 (h0 : ring (has_compl (random_gen fun_info))) : strong_rank_condition (has_compl (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_12850 (h0 : group (id (has_norm empty))) : group.fg (id (has_norm empty)) := sorry --non-trivial
lemma new_lemma_12851 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (canonically_ordered_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_12852 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) pos) : @has_exists_mul_of_le.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) pos h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_12853 (h0 : topological_space (has_add (has_neg Type))) : sequential_space (has_add (has_neg Type)) := sorry --non-trivial
lemma new_lemma_12854 (h0 : functor.add_const (topological_space (ordered_cancel_add_comm_monoid pos)) (option pos)) : @totally_disconnected_space.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_cancel_add_comm_monoid.{0} pos)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_12855 (h0 : add_monoid (has_add (has_pos_part (has_pos_part (has_pos_part environment.implicit_infer_kind))))) : add_monoid.fg (has_add (has_pos_part (has_pos_part (has_pos_part environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_12856 (h0 : functor.add_const (ring (has_pos_part pos)) linarith.comp) : @strong_rank_condition.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_pos_part.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_12857 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (normed_group fun_info)) := sorry --non-trivial
lemma new_lemma_12858 (h0 : function.extfun Type topological_space) : @normal_space.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_12859 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @complete_space.{0} (has_add.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (has_add.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_12860 (h0 : complete_lattice (canonically_ordered_monoid (has_Inf (has_add pos)))) : is_atomistic (canonically_ordered_monoid (has_Inf (has_add pos))) := sorry --non-trivial
lemma new_lemma_12861 (h0 : filter (topological_space (bin_tree unsigned))) : @locally_compact_space.{0} (bin_tree.{0} unsigned) (@filter.Limsup.{0} (topological_space.{0} (bin_tree.{0} unsigned)) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (bin_tree.{0} unsigned)) (@topological_space.complete_lattice.{0} (bin_tree.{0} unsigned))) h0)  := sorry --non-trivial
lemma new_lemma_12862 (h0 : semiring (has_Inf (has_add pos))) : is_noetherian_ring (has_Inf (has_add pos)) := sorry --non-trivial
lemma new_lemma_12863 (h0 : add_group (ordered_cancel_add_comm_monoid empty)) : is_add_cyclic (ordered_cancel_add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_12864 (h0 : has_vadd num congr_arg_kind) : has_faithful_vadd num congr_arg_kind := sorry --non-trivial
lemma new_lemma_12865 (h0 : filter (has_neg (has_to_string name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_12866 (h0 : group (is_R_or_C num)) : is_cyclic (is_R_or_C num) := sorry --non-trivial
lemma new_lemma_12867 (h0 : filter (topological_space (has_nnnorm fun_info))) : filter.is_countably_generated h0 := sorry --non-trivial
lemma new_lemma_12868 (h0 : functor.add_const (topological_space (comm_monoid empty)) empty) : @t0_space.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_12869 (h0 : function.extfun Type group) : @is_cyclic.{0} (measurable_space.dynkin_system.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.dynkin_system.{0} empty))  := sorry --non-trivial
lemma new_lemma_12870 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_12871 (h0 : complete_lattice (has_neg num)) : complete_lattice.is_Sup_finite_compact (has_neg num) := sorry --non-trivial
lemma new_lemma_12872 (h0 : group (comm_semigroup (has_bot (sub_neg_monoid name)))) : is_cyclic (comm_semigroup (has_bot (sub_neg_monoid name))) := sorry --non-trivial
lemma new_lemma_12873 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (mul_zero_class.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (mul_zero_class.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_12874 (h1 : not (monoid (measurable_space num) -> false)) : @monoid.fg.{0} (measurable_space.{0} num) (@classical.by_contradiction'.{1} (monoid.{0} (measurable_space.{0} num)) h1)  := sorry --non-trivial
lemma new_lemma_12875 (h0 : ring (has_emptyc (has_top (has_top num)))) : strong_rank_condition (has_emptyc (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_12876 (h0 : prod (has_add unsigned) (has_add unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_12877 (h0 : topological_space (has_add ennreal)) : t1_space (has_add ennreal) := sorry --non-trivial
lemma new_lemma_12878 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (with_one.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (with_one.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_12879 (h1 : has_lt (has_nnnorm (mul_one_class linarith.ineq))) : no_max_order (has_nnnorm (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_12880 (h0 : topological_space (complete_distrib_lattice environment.implicit_infer_kind)) : t1_space (complete_distrib_lattice environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_12881 (h1 : filter (add_left_cancel_monoid to_additive.value_type)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_12882 (h0 : std_gen -> std_gen -> Prop) (h1 : filter std_gen) : filter.frequently (acc h0) h1 := sorry --non-trivial
lemma new_lemma_12883 (h0 : ring (normed_group empty)) : strong_rank_condition (normed_group empty) := sorry --non-trivial
lemma new_lemma_12884 (h0 : ring (mul_one_class (normed_field (mul_one_class (normed_field std_gen))))) : is_domain (mul_one_class (normed_field (mul_one_class (normed_field std_gen)))) := sorry --non-trivial
lemma new_lemma_12885 (h0 : topological_space (boolean_algebra.core environment.implicit_infer_kind)) : totally_disconnected_space (boolean_algebra.core environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_12886 (h0 : topological_space (add_group (semiring unsigned))) : totally_disconnected_space (add_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_12887 (h0 : topological_space (has_add (mul_one_class linarith.comp))) : t0_space (has_add (mul_one_class linarith.comp)) := sorry --non-trivial
lemma new_lemma_12888 (h0 : monoid (with_bot linarith.comp_source)) : monoid.fg (with_bot linarith.comp_source) := sorry --non-trivial
lemma new_lemma_12889 (h0 : monoid (ring unsigned)) : monoid.fg (ring unsigned) := sorry --non-trivial
lemma new_lemma_12890 (h0 : functor.add_const (topological_space (ordered_ring empty)) empty) : @discrete_topology.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_12891 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) (ring (ring environment.implicit_infer_kind))) : @path_connected_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) (ring.{0} (ring.{0} environment.implicit_infer_kind)) h0)  := sorry --non-trivial
lemma new_lemma_12892 (h0 : ordered_add_comm_monoid (has_dist (option (option empty)))) : archimedean (has_dist (option (option empty))) := sorry --non-trivial
lemma new_lemma_12893 (h0 : topological_space (has_bot (has_bot (has_add Type)))) : preconnected_space (has_bot (has_bot (has_add Type))) := sorry --non-trivial
lemma new_lemma_12894 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) pos) : @totally_separated_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_12895 (h0 : fin has_zero.zero) : @normal_space.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_12896 (h0 : function.extfun nat fin) : @is_compactly_generated.{0} (canonically_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (complete_lattice.{0} (canonically_ordered_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_12897 (h0 : functor.add_const (add_group (add_cancel_monoid Type)) pos) : @is_add_cyclic.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (add_cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_12898 (h3 : topological_space (distrib (has_ssubset linarith.comp_source))) : path_connected_space (distrib (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_12899 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_12900 (h0 : uniform_space (has_pos_part (canonically_linear_ordered_monoid real))) : complete_space (has_pos_part (canonically_linear_ordered_monoid real)) := sorry --non-trivial
lemma new_lemma_12901 (h2 : topological_space (add_cancel_comm_monoid char)) : totally_disconnected_space (add_cancel_comm_monoid char) := sorry --non-trivial
lemma new_lemma_12902 (h0 : topological_space (add_cancel_comm_monoid (random_gen string_imp))) : t0_space (add_cancel_comm_monoid (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_12903 (h0 : monoid (has_nndist (finset Type))) : monoid.fg (has_nndist (finset Type)) := sorry --non-trivial
lemma new_lemma_12904 (h1 : ring (has_norm string_imp)) : strong_rank_condition (has_norm string_imp) := sorry --non-trivial
lemma new_lemma_12905 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_inter ennreal)) := sorry --non-trivial
lemma new_lemma_12906 (h0 : functor.add_const (topological_space (finset linarith.comp)) (has_neg Type)) : @locally_compact_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_12907 (h1 : topological_space (mul_one_class char)) : path_connected_space (mul_one_class char) := sorry --non-trivial
lemma new_lemma_12908 (h0 : functor.add_const (add_group (sub_neg_monoid pos)) linarith.comp) : @is_add_cyclic.{0} (sub_neg_monoid.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (sub_neg_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_12909 (h0 : functor.add_const (topological_space (semigroup Type)) linarith.comp) : @loc_path_connected_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_12910 (h0 : complete_lattice (normed_group (has_norm to_additive.value_type))) : is_atomistic (normed_group (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_12911 (h0 : add_group (has_inv linarith.ineq)) : is_add_cyclic (has_inv linarith.ineq) := sorry --non-trivial
lemma new_lemma_12912 (h0 : topological_space (has_neg_part (has_add Type))) : preirreducible_space (has_neg_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_12913 (h0 : filter (semigroup (option ennreal))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_12914 (h0 : set (ereal -> add_comm_semigroup (add_comm_semigroup linarith.ineq))) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_12915 (h0 : filter (with_bot (comm_ring to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_12916 (h0 : monoid (plift congr_arg_kind)) : monoid.fg (plift congr_arg_kind) := sorry --non-trivial
lemma new_lemma_12917 (h0 : functor.add_const (topological_space (has_add ennreal)) name) : @locally_compact_space.{0} (has_add.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_12918 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_add.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_add.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_12919 (h0 : functor.add_const (function.extfun Type ring) name) : @is_domain.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name h0) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_12920 (h1 : group (normed_group linarith.comp_source)) : normalizer_condition (normed_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_12921 (h0 : ring (has_nndist (finset (finset linarith.comp)))) : rank_condition (has_nndist (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_12922 (h0 : function.extfun Type complete_lattice) : complete_lattice.is_Sup_finite_compact (measurable_space string_imp) := sorry --non-trivial
lemma new_lemma_12923 (h0 : topological_space (has_neg (finset (finset (finset (finset Type)))))) : locally_compact_space (has_neg (finset (finset (finset (finset Type))))) := sorry --non-trivial
lemma new_lemma_12924 (h0 : monoid (random_gen (semiring (has_top (semiring num))))) : monoid.fg (random_gen (semiring (has_top (semiring num)))) := sorry --non-trivial
lemma new_lemma_12925 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (measurable_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_12926 (h0 : complete_lattice (linear_ordered_comm_ring (semiring empty))) : is_atomistic (linear_ordered_comm_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_12927 (h0 : topological_space (add_cancel_monoid (has_neg name))) : t0_space (add_cancel_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_12928 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (add_cancel_comm_monoid empty)) := sorry --non-trivial
lemma new_lemma_12929 (h0 : complete_lattice (with_one (has_norm to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (with_one (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_12930 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @irreducible_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_12931 (h0 : cancel_comm_monoid_with_zero (nondiscrete_normed_field fun_info)) (h1 : add_group (gcd_monoid (nondiscrete_normed_field fun_info))) : is_add_cyclic (gcd_monoid (nondiscrete_normed_field fun_info)) := sorry --non-trivial
lemma new_lemma_12932 (h0 : uniform_space (preorder (semiring empty))) : complete_space (preorder (semiring empty)) := sorry --non-trivial
lemma new_lemma_12933 (h0 : functor.add_const (function.extfun Type semiring) Type) : @is_noetherian_ring.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type semiring.{0}) Type h0) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_12934 (h1 : has_mem.mem (function.extfun Type) has_emptyc.emptyc) : @complete_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) h1) uniform_space.{0}) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_12935 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (canonically_linear_ordered_monoid pos)) := sorry --non-trivial
lemma new_lemma_12936 (h0 : group linarith.comp_source) : group.fg linarith.comp_source := sorry --non-trivial
lemma new_lemma_12937 (h0 : topological_space (ordered_cancel_add_comm_monoid (option (option unsigned)))) : t0_space (ordered_cancel_add_comm_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_12938 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @regular_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_12939 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (linear_ordered_comm_group.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_12940 (h0 : topological_space (ring (has_Inf (ring pos)))) : locally_compact_space (ring (has_Inf (ring pos))) := sorry --non-trivial
lemma new_lemma_12941 (h0 : functor.comp group cancel_monoid name) : @normalizer_condition.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} group.{0} cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_12942 (h1 : punit) (h2 : ring (mul_one_class (category_theory.hom_of_element reducibility_hints h1))) : is_domain (mul_one_class (category_theory.hom_of_element reducibility_hints h1)) := sorry --non-trivial
lemma new_lemma_12943 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_12944 (h0 : function.extfun Type (functor.add_const (uniform_space (add_left_cancel_semigroup empty)))) : @complete_space.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_left_cancel_semigroup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (add_left_cancel_semigroup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_12945 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (canonically_ordered_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (canonically_ordered_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_12946 (h0 : functor.add_const (semiring (simple_graph pos)) pos) : @is_noetherian_ring.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (simple_graph.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_12947 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) linarith.comp) : @regular_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_12948 (h0 : group (normed_group (semiring (has_top congr_arg_kind)))) : normalizer_condition (normed_group (semiring (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_12949 (h0 : list (ordered_comm_ring (has_add pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_12950 (h0 : monoid (has_norm (semiring (random_gen (semiring congr_arg_kind))))) : monoid.fg (has_norm (semiring (random_gen (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_12951 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_12952 (h0 : topological_space (partial_order num)) : preirreducible_space (partial_order num) := sorry --non-trivial
lemma new_lemma_12953 (h1 : function.extfun (finset Type) (has_mem.mem (measurable_space fun_info))) : @rank_condition.{0} (measurable_space.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} fun_info)) h1 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_12954 (h0 : prod (linear_order unsigned) (linear_order unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_12955 (h0 : topological_space (normed_group (random_gen (random_gen num)))) : t0_space (normed_group (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_12956 (h0 : uniform_space (has_sub linarith.comp)) : separated_space (has_sub linarith.comp) := sorry --non-trivial
lemma new_lemma_12957 (h0 : Exists (fun (x : nat), has_lt.lt x has_zero.zero)) : @t1_space.{0} (generalized_boolean_algebra.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (generalized_boolean_algebra.{0} real)) (@classical.subtype_of_exists.{0} nat (λ (x : nat), @has_lt.lt.{0} nat nat.has_lt x (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_12958 (h0 : functor.comp topological_space has_to_string Type) : @regular_space.{1} (has_to_string.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_to_string.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_12959 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} h0 (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_12960 (h0 : functor.add_const (topological_space (has_neg pos)) (finset (finset (finset name)))) : @path_connected_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) (finset.{0} (finset.{0} (finset.{0} name))) h0)  := sorry --non-trivial
lemma new_lemma_12961 (h2 : has_lt (add_comm_semigroup string.iterator_imp)) : no_max_order (add_comm_semigroup string.iterator_imp) := sorry --non-trivial
lemma new_lemma_12962 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_12963 (h1 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_12964 (h0 : topological_space (canonically_ordered_comm_semiring (ring linarith.comp))) : loc_path_connected_space (canonically_ordered_comm_semiring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_12965 (h0 : topological_space (has_Inf (has_add (has_Inf (has_add linarith.comp))))) : t1_space (has_Inf (has_add (has_Inf (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_12966 (h0 : complete_lattice (linear_ordered_add_comm_group (has_norm fun_info))) : is_compactly_generated (linear_ordered_add_comm_group (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_12967 (h0 : complete_lattice (linear_ordered_field (has_neg congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (linear_ordered_field (has_neg congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_12968 (h0 : topological_space (mul_zero_class (option (option pos)))) : regular_space (mul_zero_class (option (option pos))) := sorry --non-trivial
lemma new_lemma_12969 (h0 : ordered_comm_monoid (has_add real)) : has_exists_mul_of_le (has_add real) := sorry --non-trivial
lemma new_lemma_12970 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_12971 (h0 : topological_space (ring empty)) : normal_space (ring empty) := sorry --non-trivial
lemma new_lemma_12972 (h0 : uniform_space (complete_distrib_lattice (semiring (semiring unsigned)))) : separated_space (complete_distrib_lattice (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_12973 (h0 : complete_lattice (finset (has_to_string (ring (mul_one_class Type))))) : is_compactly_generated (finset (has_to_string (ring (mul_one_class Type)))) := sorry --non-trivial
lemma new_lemma_12974 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @irreducible_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_12975 (h0 : ordered_add_comm_monoid (ordered_comm_monoid (has_add Type))) : archimedean (ordered_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_12976 (h0 : topological_space (add_cancel_monoid (finset pos))) : normal_space (add_cancel_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_12977 (h0 : topological_space (has_zero linarith.comp)) : loc_path_connected_space (has_zero linarith.comp) := sorry --non-trivial
lemma new_lemma_12978 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} ennreal (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) ennreal)  := sorry --non-trivial
lemma new_lemma_12979 (h0 : functor.add_const (group (pseudo_emetric_space name)) (has_neg Type)) : @group.fg.{0} (pseudo_emetric_space.{0} name) (@functor.add_const.run.{0 1} (group.{0} (pseudo_emetric_space.{0} name)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_12980 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_12981 (h0 : functor.comp topological_space complete_distrib_lattice Type) : @topological_space.separable_space.{1} (complete_distrib_lattice.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} complete_distrib_lattice.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_12982 (h0 : functor.add_const (list (add_comm_monoid Type)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_12983 (h0 : not (topological_space (denumerable fun_info) -> false)) : @t0_space.{0} (denumerable.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_12984 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_inv.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_inv.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_12985 (h0 : not (complete_lattice (with_zero linarith.ineq) -> false)) : @is_compactly_generated.{0} (with_zero.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_zero.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_12986 (h0 : topological_space (has_to_string (mul_one_class linarith.comp))) : preconnected_space (has_to_string (mul_one_class linarith.comp)) := sorry --non-trivial
lemma new_lemma_12987 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem add_monoid)) : @add_monoid.fg.{0} (metric_space.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_monoid.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_monoid.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_12988 (h0 : functor.add_const (functor.add_const (uniform_space nnreal) num) num) : separated_space nnreal := sorry --non-trivial
lemma new_lemma_12989 (h0 : functor.add_const (topological_space (has_to_string Type)) Type) : @path_connected_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_to_string.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_12990 (h0 : ring (semi_normed_ring std_gen)) : strong_rank_condition (semi_normed_ring std_gen) := sorry --non-trivial
lemma new_lemma_12991 (h0 : ring (has_nndist empty)) : strong_rank_condition (has_nndist empty) := sorry --non-trivial
lemma new_lemma_12992 (h0 : topological_space (comm_ring (random_gen (random_gen string_imp)))) : totally_disconnected_space (comm_ring (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_12993 (h0 : topological_space (cancel_monoid (cancel_monoid (mul_zero_class Type)))) : t1_space (cancel_monoid (cancel_monoid (mul_zero_class Type))) := sorry --non-trivial
lemma new_lemma_12994 (h0 : ring (cancel_monoid name)) : strong_rank_condition (cancel_monoid name) := sorry --non-trivial
lemma new_lemma_12995 (h0 : semiring (has_star (has_top unsigned))) : is_noetherian_ring (has_star (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_12996 (h0 : complete_lattice (boolean_algebra (ring (ring (ring pos))))) : is_compactly_generated (boolean_algebra (ring (ring (ring pos)))) := sorry --non-trivial
lemma new_lemma_12997 (h1 : topological_space (comm_ring linarith.comp_source)) : t0_space (comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_12998 (h0 : topological_space (measurable_space.dynkin_system unsigned)) : discrete_topology (measurable_space.dynkin_system unsigned) := sorry --non-trivial
lemma new_lemma_12999 (h0 : topological_space (distrib_lattice (has_inv linarith.comp_source))) : totally_separated_space (distrib_lattice (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_13000 (h0 : function.extfun Type group) : @group.fg.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_13001 (h0 : functor.add_const (topological_space (add_comm_monoid name)) (comm_group Type)) : @irreducible_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} name)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_13002 (h0 : filter (boolean_algebra environment.implicit_infer_kind)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_13003 (h0 : ring (has_zero (finset environment.implicit_infer_kind))) : strong_rank_condition (has_zero (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_13004 (h0 : uniform_space (has_add num)) : separated_space (has_add num) := sorry --non-trivial
lemma new_lemma_13005 (h1 : filter (topological_space (mul_one_class enat))) (h2 : set (mul_one_class enat)) : @is_path_connected.{0} (mul_one_class.{0} enat) (@filter.Limsup.{0} (topological_space.{0} (mul_one_class.{0} enat)) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (mul_one_class.{0} enat)) (@topological_space.complete_lattice.{0} (mul_one_class.{0} enat))) h1) h2  := sorry --non-trivial
lemma new_lemma_13006 (h0 : fin has_zero.zero) : @archimedean.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (ordered_add_comm_monoid.{1} (generalized_boolean_algebra.{1} Type)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) h0) (@has_zero.zero.{0} nat nat.has_zero))) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_13007 (h0 : add_monoid (simple_graph (has_Inf linarith.comp))) : add_monoid.fg (simple_graph (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_13008 (h0 : ring (div_inv_monoid (random_gen string_imp))) : is_domain (div_inv_monoid (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_13009 (h1 : group (add_left_cancel_monoid (random_gen (random_gen string_imp)))) : is_cyclic (add_left_cancel_monoid (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_13010 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_13011 (h0 : ring (fintype (random_gen linarith.comp_source))) : rank_condition (fintype (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_13012 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_edist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_edist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_13013 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_13014 (h0 : topological_space (add_left_cancel_monoid linarith.ineq)) : t0_space (add_left_cancel_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_13015 (h0 : ordered_add_comm_monoid (has_nndist (finset environment.implicit_infer_kind))) : archimedean (has_nndist (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_13016 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (add_right_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_right_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_13017 (h0 : uniform_space (add_cancel_monoid congr_arg_kind)) : complete_space (add_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_13018 (h0 : topological_space (mul_zero_class pos)) : loc_path_connected_space (mul_zero_class pos) := sorry --non-trivial
lemma new_lemma_13019 (h0 : topological_space (semi_normed_comm_ring (has_top (random_gen linarith.comp_source)))) : locally_compact_space (semi_normed_comm_ring (has_top (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_13020 (h0 : prod (add_semigroup (option (option (option empty)))) (add_semigroup (option (option (option empty))))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_13021 (h0 : functor.add_const (functor.add_const (topological_space linarith.comp) (has_add pos)) pos) : @preirreducible_space.{0} linarith.comp (@functor.add_const.run.{0 0} (topological_space.{0} linarith.comp) (has_add.{0} pos) (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} linarith.comp) (has_add.{0} pos)) pos h0))  := sorry --non-trivial
lemma new_lemma_13022 (h0 : ring (has_add linarith.ineq)) : strong_rank_condition (has_add linarith.ineq) := sorry --non-trivial
lemma new_lemma_13023 (h0 : topological_space (with_one (has_top linarith.comp))) : normal_space (with_one (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_13024 (h0 : add_monoid (has_add real)) : add_monoid.fg (has_add real) := sorry --non-trivial
lemma new_lemma_13025 (h0 : topological_space (random_gen (distrib_lattice string_imp))) : path_connected_space (random_gen (distrib_lattice string_imp)) := sorry --non-trivial
lemma new_lemma_13026 (h0 : uniform_space (ring environment.implicit_infer_kind)) : complete_space (ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_13027 (h0 : functor.add_const (topological_space (bin_tree num)) congr_arg_kind) : @locally_compact_space.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_13028 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) environment.implicit_infer_kind) : @t0_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_13029 (h0 : uniform_space linarith.comp) : separated_space linarith.comp := sorry --non-trivial
lemma new_lemma_13030 (h0 : topological_space (mul_zero_class (semiring num))) : topological_space.separable_space (mul_zero_class (semiring num)) := sorry --non-trivial
lemma new_lemma_13031 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_13032 (h0 : ring (has_add (ring linarith.comp))) : is_principal_ideal_ring (has_add (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_13033 (h0 : uniform_space (non_assoc_semiring (semiring (semiring (semiring empty))))) : complete_space (non_assoc_semiring (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_13034 (h0 : monoid (has_add (finset (group_with_zero name)))) : monoid.fg (has_add (finset (group_with_zero name))) := sorry --non-trivial
lemma new_lemma_13035 (h0 : functor.add_const (filter (has_nndist Type)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_13036 (h0 : functor.comp topological_space canonically_ordered_comm_semiring name) : @totally_disconnected_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_13037 (h0 : function.extfun Type topological_space) : @regular_space.{0} (semilattice_inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semilattice_inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_13038 (h0 : function.extfun Type ring) : @rank_condition.{0} (finset.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (finset.{0} num))  := sorry --non-trivial
lemma new_lemma_13039 (h0 : ring (has_one congr_arg_kind)) : is_domain (has_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_13040 (h0 : function.extfun nat fin) : @is_compactly_generated.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (ordered_comm_ring.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_13041 (h0 : not (topological_space (has_norm num) -> false)) : @normal_space.{0} (has_norm.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_13042 (h0 : topological_space (has_top (has_top (has_top (has_top fun_info))))) : totally_separated_space (has_top (has_top (has_top (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_13043 (h0 : topological_space (has_norm (random_gen fun_info))) : discrete_topology (has_norm (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_13044 (h0 : fin has_zero.zero) : @group.fg.{0} (canonically_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (group.{0} (canonically_ordered_monoid.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_13045 (h0 : finset (boolean_algebra (comm_group unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_13046 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_13047 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) unsigned) : @normal_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_13048 (h0 : functor.add_const (group (generalized_boolean_algebra linarith.comp)) (finset pos)) : @group.fg.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (generalized_boolean_algebra.{0} linarith.comp)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_13049 (h0 : functor.add_const (functor.comp topological_space has_neg_part environment.implicit_infer_kind) Type) : @totally_separated_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 1} (functor.comp.{0 0 0} topological_space.{0} has_neg_part.{0} environment.implicit_infer_kind) Type h0))  := sorry --non-trivial
lemma new_lemma_13050 (h0 : functor.add_const (monoid (add_cancel_monoid environment.implicit_infer_kind)) (has_add pos)) : @monoid.fg.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_13051 (h0 : ordered_add_comm_monoid (has_Sup (option num))) : archimedean (has_Sup (option num)) := sorry --non-trivial
lemma new_lemma_13052 (h0 : topological_space (has_zero (boolean_algebra Type))) : topological_space.separable_space (has_zero (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_13053 (h0 : ordered_comm_monoid (has_nndist (has_to_string (has_to_string unsigned)))) : has_exists_mul_of_le (has_nndist (has_to_string (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_13054 (h0 : has_lt (has_compl (mul_one_class enat))) : no_max_order (has_compl (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_13055 (h0 : uniform_space (linear_ordered_add_comm_group fun_info)) : complete_space (linear_ordered_add_comm_group fun_info) := sorry --non-trivial
lemma new_lemma_13056 (h0 : topological_space (complete_linear_order (semiring (semiring (semiring (semiring unsigned)))))) : normal_space (complete_linear_order (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_13057 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_13058 (h0 : topological_space (semigroup (finset (finset (has_nndist name))))) : normal_space (semigroup (finset (finset (has_nndist name)))) := sorry --non-trivial
lemma new_lemma_13059 (h0 : add_group (has_zero name)) : is_add_cyclic (has_zero name) := sorry --non-trivial
lemma new_lemma_13060 (h0 : functor.add_const (topological_space (add_comm_monoid name)) pos) : @discrete_topology.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_13061 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_13062 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_cyclic.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_13063 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_13064 (h0 : ring (simple_graph name)) : is_principal_ideal_ring (simple_graph name) := sorry --non-trivial
lemma new_lemma_13065 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_13066 (h0 : complete_lattice (has_to_string (boolean_algebra name))) : is_atomistic (has_to_string (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_13067 (h0 : topological_space (has_neg_part (has_add pos))) : t1_space (has_neg_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_13068 (h0 : uniform_space (has_one (has_norm linarith.comp))) : complete_space (has_one (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_13069 (h0 : complete_lattice (complete_distrib_lattice (has_neg (has_neg pos)))) : is_atomistic (complete_distrib_lattice (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_13070 (h0 : topological_space (add_cancel_monoid (has_bot unsigned))) : path_connected_space (add_cancel_monoid (has_bot unsigned)) := sorry --non-trivial
lemma new_lemma_13071 (h0 : functor.add_const (topological_space (ordered_comm_ring real)) Type) : @t0_space.{0} (ordered_comm_ring.{0} real) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_ring.{0} real)) Type h0)  := sorry --non-trivial
lemma new_lemma_13072 (h0 : topological_space (boolean_algebra (add_comm_monoid name))) : locally_compact_space (boolean_algebra (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_13073 (h0 : add_group (has_append string.iterator_imp)) : is_add_cyclic (has_append string.iterator_imp) := sorry --non-trivial
lemma new_lemma_13074 (h0 : topological_space (mul_one_class (mul_one_class std_gen))) (h1 : set (mul_one_class (mul_one_class std_gen))) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_13075 (h0 : complete_lattice (left_cancel_monoid num)) : complete_lattice.is_Sup_finite_compact (left_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_13076 (h0 : functor.add_const (topological_space (left_cancel_monoid congr_arg_kind)) congr_arg_kind) : @totally_disconnected_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_13077 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_neg_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_13078 (h0 : finset (measure_theory.measure_space (semiring congr_arg_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_13079 (h0 : topological_space (monoid (option (option congr_arg_kind)))) : locally_compact_space (monoid (option (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_13080 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (ordered_comm_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_13081 (h0 : complete_lattice (has_zero (finset Type))) : complete_lattice.is_Sup_finite_compact (has_zero (finset Type)) := sorry --non-trivial
lemma new_lemma_13082 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_13083 (h0 : semiring (simple_graph (has_add Type))) : is_noetherian_ring (simple_graph (has_add Type)) := sorry --non-trivial
lemma new_lemma_13084 (h1 : topological_space (has_emptyc (random_gen string_imp))) : totally_separated_space (has_emptyc (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_13085 (h0 : functor.add_const (function.extfun Type topological_space) name) : @totally_separated_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_13086 (h0 : not (function.extfun (finset Type) (has_mem.mem num) -> false)) : @is_compactly_generated.{0} num (@finset.pi.empty.{1 0} Type complete_lattice.{0} num (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num)) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_13087 (h0 : list (has_zero (comm_group pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_13088 (h0 : complete_lattice (random_gen fun_info)) : complete_lattice.is_Sup_finite_compact (random_gen fun_info) := sorry --non-trivial
lemma new_lemma_13089 (h0 : topological_space (comm_semigroup (has_Inf (sub_neg_monoid linarith.comp)))) : t1_space (comm_semigroup (has_Inf (sub_neg_monoid linarith.comp))) := sorry --non-trivial
lemma new_lemma_13090 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_13091 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @irreducible_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_13092 (h0 : group (has_compl to_additive.value_type)) : is_cyclic (has_compl to_additive.value_type) := sorry --non-trivial
lemma new_lemma_13093 (h0 : has_mem.mem (has_zero linarith.comp) has_emptyc.emptyc) : @locally_compact_space.{0} (has_zero.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_zero.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_13094 (h0 : group (finset (boolean_algebra Type))) : is_cyclic (finset (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_13095 (h0 : list (add_comm_monoid (has_add (has_add (has_add (has_add (has_neg_part unsigned))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_13096 (h0 : ring (finset (has_nndist name))) : is_domain (finset (has_nndist name)) := sorry --non-trivial
lemma new_lemma_13097 (h0 : topological_space (has_to_string (normed_comm_ring name))) : irreducible_space (has_to_string (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_13098 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (comm_group pos)) := sorry --non-trivial
lemma new_lemma_13099 (h0 : monoid (has_emptyc (random_gen to_additive.value_type))) : monoid.fg (has_emptyc (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_13100 (h0 : function.extfun Type (functor.comp topological_space has_neg)) : @regular_space.{0} (has_neg.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_neg.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_13101 (h0 : ring (partial_order congr_arg_kind)) : is_principal_ideal_ring (partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_13102 (h0 : monoid_with_zero (option pos) -> monoid_with_zero (option pos) -> Prop) : is_symm (monoid_with_zero (option pos)) h0 := sorry --non-trivial
lemma new_lemma_13103 (h0 : not (topological_space (topological_space reducibility_hints) -> false)) : @totally_disconnected_space.{0} (topological_space.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (topological_space.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_13104 (h0 : topological_space (add_comm_monoid (option (option unsigned)))) : loc_path_connected_space (add_comm_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_13105 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_emptyc.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_emptyc.{0} empty))  := sorry --non-trivial
lemma new_lemma_13106 (h0 : topological_space (add_cancel_monoid (ring (ring (ring Type))))) : regular_space (add_cancel_monoid (ring (ring (ring Type)))) := sorry --non-trivial
lemma new_lemma_13107 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_13108 (h0 : functor.add_const (group (has_add environment.implicit_infer_kind)) pos) : @group.fg.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_13109 (h0 : functor.add_const (function.extfun Type group) Type) : @normalizer_condition.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_13110 (h0 : functor.add_const (topological_space (canonically_linear_ordered_monoid ennreal)) ennreal) : @loc_path_connected_space.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_13111 (h0 : group (has_Inf (boolean_algebra.core Type))) : is_cyclic (has_Inf (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_13112 (h0 : topological_space (partial_order (semiring empty))) : discrete_topology (partial_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_13113 (h0 : uniform_space (with_zero (has_nnnorm (denumerable to_additive.value_type)))) : complete_space (with_zero (has_nnnorm (denumerable to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_13114 (h0 : complete_lattice (normed_field char)) : is_compactly_generated (normed_field char) := sorry --non-trivial
lemma new_lemma_13115 (h0 : prod (boolean_algebra linarith.comp) (boolean_algebra linarith.comp)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_13116 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (with_one empty)) := sorry --non-trivial
lemma new_lemma_13117 (h0 : ring (has_nndist (has_add (has_add name)))) : is_principal_ideal_ring (has_nndist (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_13118 (h0 : topological_space (semigroup (ring environment.implicit_infer_kind))) : t1_space (semigroup (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_13119 (h0 : functor.add_const (finset (non_assoc_semiring empty)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_13120 (h0 : function.extfun Type (prod (canonically_ordered_comm_semiring pos))) : id_rel (function.extfun_app h0 (canonically_ordered_comm_semiring pos)) := sorry --non-trivial
lemma new_lemma_13121 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_lattice_add_comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_13122 (h0 : functor.add_const (function.extfun (Type 1) semiring) linarith.comp) : @is_noetherian_ring.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) semiring.{1}) linarith.comp h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_13123 (h0 : complete_lattice (semi_normed_comm_ring linarith.ineq)) : is_compactly_generated (semi_normed_comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_13124 (h0 : functor.add_const (topological_space (has_nndist name)) linarith.comp) : @loc_path_connected_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_13125 (h0 : add_monoid (add_right_cancel_monoid unsigned)) : add_monoid.fg (add_right_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_13126 (h0 : ring (normed_group (has_ssubset string_imp))) : strong_rank_condition (normed_group (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_13127 (h0 : functor.add_const (group (boolean_algebra unsigned)) (ring (has_to_string linarith.comp))) : @group.fg.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} unsigned)) (ring.{0} (has_to_string.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_13128 (h0 : function.extfun Type (functor.add_const (functor.add_const (complete_lattice (linear_order empty)) unsigned))) : @complete_lattice.is_Sup_finite_compact.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_order.{0} empty)) unsigned (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (complete_lattice.{0} (linear_order.{0} empty)) unsigned) (option.{0} (option.{0} (option.{0} unsigned))) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (functor.add_const.{0 0} (complete_lattice.{0} (linear_order.{0} empty)) unsigned)) h0 (option.{0} (option.{0} (option.{0} unsigned))))))  := sorry --non-trivial
lemma new_lemma_13129 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_13130 (h0 : topological_space (has_add (has_to_string (has_add unsigned)))) : locally_compact_space (has_add (has_to_string (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_13131 (h0 : complete_lattice (id (has_norm (semiring empty)))) : is_compactly_generated (id (has_norm (semiring empty))) := sorry --non-trivial
lemma new_lemma_13132 (h0 : topological_space (measure_theory.measure_space linarith.comp)) : t0_space (measure_theory.measure_space linarith.comp) := sorry --non-trivial
lemma new_lemma_13133 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) (has_add pos)) : @irreducible_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_13134 (h0 : topological_space (boolean_algebra.core unsigned)) : topological_space.separable_space (boolean_algebra.core unsigned) := sorry --non-trivial
lemma new_lemma_13135 (h1 : complete_lattice (uniform_space linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (uniform_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_13136 (h0 : complete_lattice (metric_space num)) : is_compactly_generated (metric_space num) := sorry --non-trivial
lemma new_lemma_13137 (h0 : functor.comp monoid ring linarith.comp) : @monoid.fg.{0} (ring.{0} linarith.comp) (@functor.comp.run.{0 0 0} monoid.{0} ring.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_13138 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) (has_neg pos)) : @sequential_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_13139 (h0 : list (list Prop)) : list.head (id (id (id (id (list.head h0))))) := sorry --non-trivial
lemma new_lemma_13140 (h0 : not (function.extfun Type topological_space -> false)) : @topological_space.separable_space.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_13141 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (boolean_algebra real)) := sorry --non-trivial
lemma new_lemma_13142 (h0 : complete_lattice (has_zero (has_add ennreal))) : is_compactly_generated (has_zero (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_13143 (h0 : uniform_space (mul_zero_class (semiring (semiring (semiring empty))))) : separated_space (mul_zero_class (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_13144 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_13145 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (encodable.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (encodable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_13146 (h0 : add_group (has_star (semiring congr_arg_kind))) : is_add_cyclic (has_star (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_13147 (h0 : complete_lattice (normed_group (comm_ring fun_info))) : is_compactly_generated (normed_group (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_13148 (h0 : function.extfun Type (functor.comp topological_space semigroup)) : @regular_space.{0} (semigroup.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} semigroup.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_13149 (h0 : functor.add_const (functor.add_const (complete_lattice (semigroup empty)) empty) empty) : @is_atomistic.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} empty)) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (complete_lattice.{0} (semigroup.{0} empty)) empty) empty h0))  := sorry --non-trivial
lemma new_lemma_13150 (h0 : fin has_zero.zero) : @strong_rank_condition.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (has_bot.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_13151 (h0 : topological_space (complete_semilattice_Sup (has_inv linarith.ineq))) : t0_space (complete_semilattice_Sup (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_13152 (h0 : ring (cancel_monoid (has_add environment.implicit_infer_kind))) : strong_rank_condition (cancel_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_13153 (h0 : topological_space (free_add_monoid unsigned)) : t1_space (free_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_13154 (h0 : topological_space (has_edist (option (option (option empty))))) : path_connected_space (has_edist (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_13155 (h0 : not (ring (has_union empty) -> false)) : @is_domain.{0} (has_union.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (has_union.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_13156 (h0 : group (non_unital_non_assoc_semiring (has_nnnorm char))) : is_cyclic (non_unital_non_assoc_semiring (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_13157 (h0 : group num) : group.fg num := sorry --non-trivial
lemma new_lemma_13158 (h0 : function.extfun Type topological_space) : @sequential_space.{0} ordering (@function.extfun_app.{2 1} Type topological_space.{0} h0 ordering)  := sorry --non-trivial
lemma new_lemma_13159 (h0 : topological_space (left_cancel_semigroup (semiring (semiring (semiring congr_arg_kind))))) : discrete_topology (left_cancel_semigroup (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_13160 (h0 : functor.add_const (topological_space (plift num)) (semiring (semiring (semiring num)))) : @normal_space.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} num)) (semiring.{0} (semiring.{0} (semiring.{0} num))) h0)  := sorry --non-trivial
lemma new_lemma_13161 (h0 : functor.add_const (list (boolean_algebra Type)) (finset Type)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_13162 (h0 : topological_space (boolean_algebra (boolean_algebra pos))) : loc_path_connected_space (boolean_algebra (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_13163 (h0 : monoid (has_add (ring (has_nndist (has_nndist (has_nndist (has_add name))))))) : monoid.fg (has_add (ring (has_nndist (has_nndist (has_nndist (has_add name)))))) := sorry --non-trivial
lemma new_lemma_13164 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra.core linarith.comp)) (has_neg Type)) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (boolean_algebra.core.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_13165 (h0 : functor.comp topological_space canonically_ordered_comm_semiring name) : @loc_path_connected_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_13166 (h0 : functor.add_const (filter (boolean_algebra Type)) environment.implicit_infer_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_13167 (h0 : fin has_zero.zero) : @topological_space.separable_space.{0} (sub_neg_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_13168 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (option.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (option.{0} num))  := sorry --non-trivial
lemma new_lemma_13169 (h0 : topological_space (add_comm_monoid (has_Inf Type))) : t0_space (add_comm_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_13170 (h0 : list (has_sdiff (finset pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_13171 (h0 : group (fintype (linear_ordered_add_comm_group (has_nnnorm fun_info)))) : is_cyclic (fintype (linear_ordered_add_comm_group (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_13172 (h0 : cancel_comm_monoid_with_zero (omega_complete_partial_order num)) : unique_factorization_monoid (omega_complete_partial_order num) := sorry --non-trivial
lemma new_lemma_13173 (h0 : monoid (has_top (add_group congr_arg_kind))) : monoid.fg (has_top (add_group congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_13174 (h0 : monoid (linear_ordered_add_comm_group (has_inv (random_gen (has_inv linarith.comp_source))))) : monoid.fg (linear_ordered_add_comm_group (has_inv (random_gen (has_inv linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_13175 (h0 : functor.add_const (complete_lattice (semiring congr_arg_kind)) empty) : @is_atomistic.{0} (semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semiring.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_13176 (h0 : functor.add_const (functor.add_const (topological_space (add_left_cancel_semigroup empty)) num) (semiring empty)) : @loc_path_connected_space.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} empty)) num (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} empty)) num) (semiring.{0} empty) h0))  := sorry --non-trivial
lemma new_lemma_13177 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_edist.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_edist.{0} num))  := sorry --non-trivial
lemma new_lemma_13178 (h0 : topological_space (simple_graph (ring Type))) : totally_separated_space (simple_graph (ring Type)) := sorry --non-trivial
lemma new_lemma_13179 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (measurable_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_13180 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_13181 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) pos) : @preconnected_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_13182 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_13183 (h0 : add_group (has_lt linarith.ineq)) : is_add_cyclic (has_lt linarith.ineq) := sorry --non-trivial
lemma new_lemma_13184 (h0 : ordered_add_comm_monoid (simple_graph linarith.comp)) : archimedean (simple_graph linarith.comp) := sorry --non-trivial
lemma new_lemma_13185 (h0 : add_group (semi_normed_ring to_additive.value_type)) : is_add_cyclic (semi_normed_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_13186 (h1 : add_group (fintype linarith.comp_source)) : is_add_cyclic (fintype linarith.comp_source) := sorry --non-trivial
lemma new_lemma_13187 (h0 : uniform_space (add_cancel_monoid (has_neg environment.implicit_infer_kind))) : separated_space (add_cancel_monoid (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_13188 (h0 : functor.add_const (group (ring Type)) (ring (finset Type))) : @group.fg.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (ring.{1} Type)) (ring.{1} (finset.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_13189 (h0 : topological_space (has_nndist (option (option empty)))) : path_connected_space (has_nndist (option (option empty))) := sorry --non-trivial
lemma new_lemma_13190 (h0 : topological_space (distrib_lattice (random_gen linarith.comp_source))) : t0_space (distrib_lattice (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_13191 (h1 : group (has_norm fun_info)) : is_cyclic (has_norm fun_info) := sorry --non-trivial
lemma new_lemma_13192 (h0 : topological_space (encodable linarith.ineq)) : irreducible_space (encodable linarith.ineq) := sorry --non-trivial
lemma new_lemma_13193 (h0 : topological_space (ring (has_add linarith.comp))) : discrete_topology (ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_13194 (h0 : functor.add_const (topological_space (ring (has_Inf pos))) Type) : @locally_compact_space.{0} (ring.{0} (has_Inf.{0} pos)) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} (has_Inf.{0} pos))) Type h0)  := sorry --non-trivial
lemma new_lemma_13195 (h0 : filter (semigroup (cancel_monoid pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_13196 (h0 : uniform_space (simple_graph (ring (has_pos_part linarith.comp)))) : complete_space (simple_graph (ring (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_13197 (h0 : topological_space (has_union (has_norm (has_norm (has_norm empty))))) : totally_disconnected_space (has_union (has_norm (has_norm (has_norm empty)))) := sorry --non-trivial
lemma new_lemma_13198 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_zero name)) Type) : @unique_factorization_monoid.{0} (has_zero.{0} name) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (has_zero.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_13199 (h0 : functor.add_const (group (add_comm_monoid Type)) (has_to_string linarith.comp)) : @group.fg.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (add_comm_monoid.{1} Type)) (has_to_string.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_13200 (h0 : topological_space (boolean_algebra.core (semigroup (has_neg_part unsigned)))) : discrete_topology (boolean_algebra.core (semigroup (has_neg_part unsigned))) := sorry --non-trivial
lemma new_lemma_13201 (h0 : not (uniform_space (measurable_space.dynkin_system num) -> false)) : @complete_space.{0} (measurable_space.dynkin_system.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (measurable_space.dynkin_system.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_13202 (h0 : topological_space (has_union (has_norm linarith.comp))) : irreducible_space (has_union (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_13203 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_sub.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_sub.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_13204 (h0 : fin has_zero.zero) : @archimedean.{0} (ordered_comm_ring.{0} (finset.{0} pos)) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (ordered_comm_ring.{0} (finset.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_13205 (h0 : topological_space (add_cancel_monoid (has_add (has_to_string pos)))) : preconnected_space (add_cancel_monoid (has_add (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_13206 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @strong_rank_condition.{0} fun_info (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) fun_info)  := sorry --non-trivial
lemma new_lemma_13207 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @complete_lattice.is_Sup_finite_compact.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) complete_lattice.{0}) (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_13208 (h0 : topological_space (complete_distrib_lattice (option empty))) : normal_space (complete_distrib_lattice (option empty)) := sorry --non-trivial
lemma new_lemma_13209 (h1 : ring (has_nnnorm to_additive.value_type)) : rank_condition (has_nnnorm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_13210 (h0 : filter (id string_imp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_13211 (h0 : topological_space (comm_monoid congr_arg_kind)) : totally_separated_space (comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_13212 (h0 : topological_space (bin_tree (semiring congr_arg_kind))) : preirreducible_space (bin_tree (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_13213 (h0 : functor.add_const (topological_space (non_assoc_semiring congr_arg_kind)) unsigned) : @locally_compact_space.{0} (non_assoc_semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_13214 (h0 : ring (boolean_algebra (has_neg pos))) : is_principal_ideal_ring (boolean_algebra (has_neg pos)) := sorry --non-trivial
lemma new_lemma_13215 (h0 : group (generalized_boolean_algebra real)) : normalizer_condition (generalized_boolean_algebra real) := sorry --non-trivial
lemma new_lemma_13216 (h0 : topological_space (ring (semigroup unsigned))) : t1_space (ring (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_13217 (h0 : ring (distrib (random_gen (random_gen reducibility_hints)))) : rank_condition (distrib (random_gen (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_13218 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) congr_arg_kind) : @totally_separated_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_13219 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (bin_tree.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (bin_tree.{0} empty))  := sorry --non-trivial
lemma new_lemma_13220 (h0 : functor.add_const (ordered_comm_monoid (add_comm_monoid pos)) linarith.comp) : @has_exists_mul_of_le.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (add_comm_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_13221 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_13222 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) (has_add Type)) : @totally_disconnected_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_13223 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen linarith.ineq))) : @monoid.fg.{0} (random_gen.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type monoid.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.ineq)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_13224 (h0 : functor.add_const (group (has_zero linarith.comp)) (mul_one_class (mul_one_class (ring linarith.comp)))) : @group.fg.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} linarith.comp)) (mul_one_class.{0} (mul_one_class.{0} (ring.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_13225 (h0 : functor.add_const (topological_space (has_neg_part Type)) name) : @irreducible_space.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg_part.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_13226 (h0 : group (canonically_ordered_monoid (has_Inf real))) : is_cyclic (canonically_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_13227 (h0 : fin has_zero.zero) : @is_cyclic.{0} (ordered_comm_monoid.{0} real) (@matrix.vec_empty.{0} (group.{0} (ordered_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_13228 (h0 : not (ring empty -> false)) : @rank_condition.{0} empty (@classical.by_contradiction'.{1} (ring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_13229 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @irreducible_space.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (normed_lattice_add_comm_group.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_13230 (h0 : functor.add_const (topological_space (generalized_boolean_algebra name)) (has_neg name)) : @t0_space.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} name)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_13231 (h0 : topological_space (linear_ordered_add_comm_group (random_gen (random_gen linarith.ineq)))) : totally_disconnected_space (linear_ordered_add_comm_group (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_13232 (h0 : functor.add_const (filter (canonically_linear_ordered_monoid unsigned)) num) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_13233 (h0 : ordered_comm_monoid (has_nndist Type)) : has_exists_mul_of_le (has_nndist Type) := sorry --non-trivial
lemma new_lemma_13234 (h0 : topological_space (add_cancel_monoid (has_pos_part pos))) : irreducible_space (add_cancel_monoid (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_13235 (h0 : ring (has_union linarith.comp)) : is_domain (has_union linarith.comp) := sorry --non-trivial
lemma new_lemma_13236 (h0 : topological_space (generalized_boolean_algebra (has_add Type))) : irreducible_space (generalized_boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_13237 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_neg.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_13238 (h0 : not (has_scalar (measurable_space.dynkin_system empty) unsigned -> false)) : @has_faithful_scalar.{0 0} (measurable_space.dynkin_system.{0} empty) unsigned (@classical.by_contradiction'.{1} (has_scalar.{0 0} (measurable_space.dynkin_system.{0} empty) unsigned) h0)  := sorry --non-trivial
lemma new_lemma_13239 (h0 : ring (canonically_linear_ordered_monoid (has_Inf Type))) : is_domain (canonically_linear_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_13240 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_13241 (h0 : functor.add_const (topological_space (add_comm_monoid name)) Type) : @irreducible_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_13242 (h0 : topological_space (has_compl fun_info)) (h1 : add_group (has_compl fun_info)) : topological_add_group (has_compl fun_info) := sorry --non-trivial
lemma new_lemma_13243 (h0 : topological_space (free_add_monoid (semiring num))) : locally_compact_space (free_add_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_13244 (h0 : functor.add_const (list (generalized_boolean_algebra pos)) (has_nndist (ring linarith.comp))) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_13245 (h0 : cancel_comm_monoid_with_zero (comm_group Type)) : unique_factorization_monoid (comm_group Type) := sorry --non-trivial
lemma new_lemma_13246 (h0 : functor.add_const (topological_space (ring name)) pos) : @sequential_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_13247 (h0 : complete_lattice (has_ssubset (metric_space (metric_space to_additive.value_type)))) : is_compactly_generated (has_ssubset (metric_space (metric_space to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_13248 (h0 : topological_space (has_Inf (has_pos_part (has_add (has_Inf real))))) : preirreducible_space (has_Inf (has_pos_part (has_add (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_13249 (h0 : topological_space (monoid (option (option empty)))) : totally_disconnected_space (monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_13250 (h0 : topological_space (plift (left_cancel_semigroup unsigned))) : normal_space (plift (left_cancel_semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_13251 (h0 : filter (boolean_algebra (has_add unsigned))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_13252 (h0 : ring (canonically_linear_ordered_monoid Type)) : rank_condition (canonically_linear_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_13253 (h0 : functor.add_const (ring (partial_order num)) (semiring num)) : @is_principal_ideal_ring.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (partial_order.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_13254 (h0 : has_mem.mem (random_gen linarith.comp_source) has_emptyc.emptyc) : @totally_separated_space.{0} (random_gen.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_13255 (h0 : set (simple_graph (mul_one_class (mul_one_class linarith.ineq)))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_13256 (h0 : ring (normed_linear_ordered_group unsigned)) : rank_condition (normed_linear_ordered_group unsigned) := sorry --non-trivial
lemma new_lemma_13257 (h0 : functor.add_const (semiring (semigroup Type)) (finset environment.implicit_infer_kind)) : @is_noetherian_ring.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (semigroup.{1} Type)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_13258 (h0 : complete_lattice (semigroup Type)) : is_compactly_generated (semigroup Type) := sorry --non-trivial
lemma new_lemma_13259 (h0 : pfun (add_comm_semigroup fun_info) Prop) (h1 : coe_sort (pfun.dom h0)) : pfun.as_subtype h0 h1 := sorry --non-trivial
lemma new_lemma_13260 (h0 : functor.add_const (topological_space (add_comm_monoid environment.implicit_infer_kind)) Type) : @sequential_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_13261 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_13262 (h1 : topological_space (random_gen to_additive.value_type)) : irreducible_space (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_13263 (h0 : list (boolean_algebra (has_Inf pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_13264 (h0 : set to_additive.value_type) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_13265 (h0 : not (topological_space (has_sub congr_arg_kind) -> false)) : @discrete_topology.{0} (has_sub.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_13266 (h0 : group (has_to_string (has_add name))) : group.fg (has_to_string (has_add name)) := sorry --non-trivial
lemma new_lemma_13267 (h0 : functor.add_const (fin has_zero.zero) real) : @rank_condition.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (has_bot.{1} Type)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) real h0))  := sorry --non-trivial
lemma new_lemma_13268 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_13269 (h0 : functor.add_const (topological_space (ring pos)) name) : @topological_space.separable_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_13270 (h0 : uniform_space (canonically_ordered_comm_semiring (has_add pos))) : complete_space (canonically_ordered_comm_semiring (has_add pos)) := sorry --non-trivial
lemma new_lemma_13271 (h0 : not (ring (add_right_cancel_monoid empty) -> false)) : @strong_rank_condition.{0} (add_right_cancel_monoid.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (add_right_cancel_monoid.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_13272 (h0 : group (measurable_space num)) : is_cyclic (measurable_space num) := sorry --non-trivial
lemma new_lemma_13273 (h0 : topological_space (normed_linear_ordered_group char)) : path_connected_space (normed_linear_ordered_group char) := sorry --non-trivial
lemma new_lemma_13274 (h0 : group (topological_space (has_nnnorm linarith.comp_source))) : group.fg (topological_space (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_13275 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (complete_distrib_lattice.{0} name) (@matrix.vec_empty.{0} (group.{0} (complete_distrib_lattice.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_13276 (h0 : monoid (with_bot (denumerable fun_info))) : monoid.fg (with_bot (denumerable fun_info)) := sorry --non-trivial
lemma new_lemma_13277 (h0 : topological_space (boolean_algebra (has_Inf Type))) : sequential_space (boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_13278 (h1 : complete_lattice (has_ssubset linarith.ineq)) : is_compactly_generated (has_ssubset linarith.ineq) := sorry --non-trivial
lemma new_lemma_13279 (h3 : topological_space (with_one num)) : totally_separated_space (with_one num) := sorry --non-trivial
lemma new_lemma_13280 (h0 : topological_space (has_emptyc (has_top (has_top (has_top (has_top (has_top fun_info))))))) : locally_compact_space (has_emptyc (has_top (has_top (has_top (has_top (has_top fun_info)))))) := sorry --non-trivial
lemma new_lemma_13281 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_13282 (h0 : cancel_comm_monoid_with_zero (has_neg_part (has_add (has_add name)))) : unique_factorization_monoid (has_neg_part (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_13283 (h0 : topological_space (normed_field (random_gen (comm_ring (random_gen (random_gen char)))))) : path_connected_space (normed_field (random_gen (comm_ring (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_13284 (h0 : not (add_monoid (bin_tree congr_arg_kind) -> false)) : @add_monoid.fg.{0} (bin_tree.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_monoid.{0} (bin_tree.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_13285 (h0 : uniform_space (add_cancel_monoid (ring (finset name)))) : complete_space (add_cancel_monoid (ring (finset name))) := sorry --non-trivial
lemma new_lemma_13286 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (complete_distrib_lattice.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_13287 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_13288 (h0 : topological_space (canonically_ordered_comm_semiring (finset linarith.comp))) : t1_space (canonically_ordered_comm_semiring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_13289 (h0 : ring (ring (has_add (has_add name)))) : strong_rank_condition (ring (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_13290 (h0 : not (uniform_space (semi_normed_ring enat) -> false)) : @complete_space.{0} (semi_normed_ring.{0} enat) (@classical.by_contradiction'.{1} (uniform_space.{0} (semi_normed_ring.{0} enat)) h0)  := sorry --non-trivial
lemma new_lemma_13291 (h0 : topological_space (dlist string_imp)) : totally_disconnected_space (dlist string_imp) := sorry --non-trivial
lemma new_lemma_13292 (h0 : functor.add_const (topological_space (finset pos)) name) : @preirreducible_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_13293 (h0 : topological_space (random_gen (mul_one_class (random_gen reducibility_hints)))) : t0_space (random_gen (mul_one_class (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_13294 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_13295 (h0 : ring (add_group (semiring (semiring linarith.comp)))) : rank_condition (add_group (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_13296 (h0 : not (filter (has_top fun_info) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_13297 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra pos)) name) : @archimedean.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_13298 (h0 : function.extfun Type (functor.add_const (group (semigroup empty)))) : @group.fg.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} empty)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (semigroup.{0} empty))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_13299 (h0 : functor.add_const (filter (has_nndist linarith.comp)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_13300 (h0 : list (id (has_inv (has_inv (random_gen (random_gen linarith.comp_source)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_13301 (h0 : functor.add_const (topological_space (has_nndist (comm_group pos))) environment.implicit_infer_kind) : @topological_space.separable_space.{0} (has_nndist.{0} (comm_group.{0} pos)) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} (comm_group.{0} pos))) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_13302 (h0 : ring (pseudo_metric_space (option (option pos)))) : strong_rank_condition (pseudo_metric_space (option (option pos))) := sorry --non-trivial
lemma new_lemma_13303 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_13304 (h0 : uniform_space (has_union (has_top linarith.comp))) : complete_space (has_union (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_13305 (h0 : functor.add_const (topological_space (free_add_monoid empty)) num) : @preirreducible_space.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_13306 (h0 : functor.add_const (semiring (left_cancel_semigroup num)) empty) : @is_noetherian_ring.{0} (left_cancel_semigroup.{0} num) (@functor.add_const.run.{0 0} (semiring.{0} (left_cancel_semigroup.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_13307 (h0 : functor.add_const (topological_space (generalized_boolean_algebra name)) Type) : @regular_space.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (generalized_boolean_algebra.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_13308 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (finset.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (finset.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_13309 (h1 : topological_space (has_nnnorm linarith.comp_source)) : path_connected_space (has_nnnorm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_13310 (h0 : complete_lattice (complete_distrib_lattice (option (option (option empty))))) : is_compactly_generated (complete_distrib_lattice (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_13311 (h0 : functor.add_const (monoid (finset linarith.comp)) environment.implicit_infer_kind) : @monoid.fg.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (finset.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_13312 (h0 : ring (has_norm (distrib_lattice (distrib_lattice to_additive.value_type)))) : invariant_basis_number (has_norm (distrib_lattice (distrib_lattice to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_13313 (h0 : functor.add_const (complete_lattice (add_group unsigned)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (add_group.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_13314 (h0 : topological_space (denumerable fun_info)) : irreducible_space (denumerable fun_info) := sorry --non-trivial
lemma new_lemma_13315 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (comm_semigroup.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) h0) (comm_semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_13316 (h0 : topological_space (finset (option unsigned))) : totally_disconnected_space (finset (option unsigned)) := sorry --non-trivial
lemma new_lemma_13317 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (boolean_algebra.core.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (boolean_algebra.core.{0} empty))  := sorry --non-trivial
lemma new_lemma_13318 (h0 : functor.add_const (ring (has_to_string linarith.comp)) linarith.comp) : @is_principal_ideal_ring.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_13319 (h0 : group (comm_group (has_to_string unsigned))) : group.fg (comm_group (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_13320 (h0 : topological_space (sub_neg_monoid (ordered_comm_monoid real))) : preirreducible_space (sub_neg_monoid (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_13321 (h0 : add_monoid (has_sdiff (option (option (option (option unsigned)))))) : add_monoid.fg (has_sdiff (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_13322 (h0 : list (bin_tree congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_13323 (h0 : ring (has_zero ennreal)) : is_domain (has_zero ennreal) := sorry --non-trivial
lemma new_lemma_13324 (h0 : cancel_comm_monoid_with_zero (boolean_algebra.core (has_add (has_Inf (has_add (has_Inf Type)))))) : unique_factorization_monoid (boolean_algebra.core (has_add (has_Inf (has_add (has_Inf Type))))) := sorry --non-trivial
lemma new_lemma_13325 (h0 : functor.add_const (topological_space (has_to_string name)) (finset Type)) : @sequential_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} name)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_13326 (h0 : topological_space fun_info) (h1 : function.extfun (fun_info -> Type) (function.extfun fun_info)) : is_preconnected (function.extfun_app (function.extfun_app h1 (fun (x : fun_info), Prop))) := sorry --non-trivial
lemma new_lemma_13327 (h0 : cancel_comm_monoid_with_zero (has_dist (option empty))) : unique_factorization_monoid (has_dist (option empty)) := sorry --non-trivial
lemma new_lemma_13328 (h0 : topological_space (set.set_semiring unsigned)) : preirreducible_space (set.set_semiring unsigned) := sorry --non-trivial
lemma new_lemma_13329 (h0 : topological_space (has_neg_part (add_comm_monoid unsigned))) : totally_disconnected_space (has_neg_part (add_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_13330 (h0 : functor.add_const (add_monoid (has_to_string pos)) (ring pos)) : @add_monoid.fg.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_to_string.{0} pos)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_13331 (h0 : functor.add_const (function.extfun Type uniform_space) (finset pos)) : @complete_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) (finset.{0} pos) h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_13332 (h0 : group (measurable_space (random_gen (random_gen fun_info)))) : normalizer_condition (measurable_space (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_13333 (h0 : topological_space (simple_graph (has_neg (ring (ring Type))))) : t1_space (simple_graph (has_neg (ring (ring Type)))) := sorry --non-trivial
lemma new_lemma_13334 (h0 : add_group (bin_tree (semiring (semiring (semiring unsigned))))) : is_add_cyclic (bin_tree (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_13335 (h0 : add_group (non_assoc_semiring congr_arg_kind)) : is_add_cyclic (non_assoc_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_13336 (h0 : functor.add_const (topological_space (plift empty)) (semiring num)) : @locally_compact_space.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} empty)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_13337 (h0 : functor.add_const (add_monoid (complete_distrib_lattice linarith.comp)) linarith.comp) : @add_monoid.fg.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (complete_distrib_lattice.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_13338 (h0 : group (dlist (has_nnnorm linarith.ineq))) : is_cyclic (dlist (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_13339 (h0 : function.extfun (fun_info -> Type) (function.extfun fun_info)) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) fun_info (@function.extfun_app.{1 1} fun_info (λ (x : fun_info), Prop) (@function.extfun_app.{2 1} (fun_info → Type) (function.extfun.{1 1} fun_info) h0 (λ (x : fun_info), Prop)))  := sorry --non-trivial
lemma new_lemma_13340 (h0 : complete_lattice (simple_graph to_additive.value_type)) : is_compactly_generated (simple_graph to_additive.value_type) := sorry --non-trivial
lemma new_lemma_13341 (h0 : ordered_add_comm_monoid (has_add (option (option (option pos))))) : archimedean (has_add (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_13342 (h0 : ring (with_bot (has_top congr_arg_kind))) : rank_condition (with_bot (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_13343 (h0 : functor.add_const (topological_space (has_neg_part name)) name) : @topological_space.separable_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_13344 (h0 : topological_space (generalized_boolean_algebra (ring (has_Inf Type)))) : t0_space (generalized_boolean_algebra (ring (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_13345 (h2 : ring (has_emptyc num)) : rank_condition (has_emptyc num) := sorry --non-trivial
lemma new_lemma_13346 (h1 : topological_space (complete_semilattice_Sup (random_gen string_imp))) : t0_space (complete_semilattice_Sup (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_13347 (h0 : topological_space (has_star (semiring (option unsigned)))) : t1_space (has_star (semiring (option unsigned))) := sorry --non-trivial
lemma new_lemma_13348 (h0 : topological_space (boolean_algebra.core (cancel_monoid ennreal))) : t0_space (boolean_algebra.core (cancel_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_13349 (h0 : functor.add_const (add_group (has_to_string Type)) pos) : @is_add_cyclic.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (has_to_string.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_13350 (h1 : topological_space (has_norm num)) : locally_compact_space (has_norm num) := sorry --non-trivial
lemma new_lemma_13351 (h0 : topological_space (has_to_string (ring (has_neg linarith.comp)))) : totally_disconnected_space (has_to_string (ring (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_13352 (h0 : add_group (has_star (semiring (semiring (semiring num))))) : is_add_cyclic (has_star (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_13353 (h0 : ring (has_inv (has_add fun_info))) : strong_rank_condition (has_inv (has_add fun_info)) := sorry --non-trivial
lemma new_lemma_13354 (h0 : complete_lattice (add_comm_monoid (has_bot real))) : is_atomistic (add_comm_monoid (has_bot real)) := sorry --non-trivial
lemma new_lemma_13355 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) pos) : @t1_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_13356 (h0 : ring (mul_zero_class (finset environment.implicit_infer_kind))) : is_principal_ideal_ring (mul_zero_class (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_13357 (h0 : uniform_space (distrib_lattice (has_inv linarith.ineq))) : complete_space (distrib_lattice (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_13358 (h0 : not (ring (with_bot linarith.comp) -> false)) : @is_domain.{0} (with_bot.{0} linarith.comp) (@classical.by_contradiction'.{1} (ring.{0} (with_bot.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_13359 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra.core ennreal)) unsigned) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} ennreal) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.core.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_13360 (h0 : functor.add_const (topological_space (has_nndist name)) (ring (finset pos))) : @totally_disconnected_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) (ring.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_13361 (h0 : topological_space (canonically_ordered_monoid (has_Inf linarith.comp))) : locally_compact_space (canonically_ordered_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_13362 (h0 : functor.add_const (function.extfun Type filter) pos) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) (has_zero pos)) := sorry --non-trivial
lemma new_lemma_13363 (h0 : functor.add_const (ring (add_group empty)) congr_arg_kind) : @rank_condition.{0} (add_group.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (add_group.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_13364 (h0 : function.extfun Type topological_space) : @t1_space.{0} (add_cancel_monoid.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_13365 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring Type)) (ring (ring (ring pos)))) : @sequential_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) (ring.{0} (ring.{0} (ring.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_13366 (h0 : functor.add_const (complete_lattice (add_cancel_monoid pos)) name) : @is_atomistic.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_13367 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_13368 (h4 : complete_lattice (simple_graph to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (simple_graph to_additive.value_type) := sorry --non-trivial
lemma new_lemma_13369 (h0 : complete_lattice (with_one (mul_one_class string.iterator_imp))) : is_compactly_generated (with_one (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_13370 (h0 : topological_space (semigroup (option (option unsigned)))) : totally_separated_space (semigroup (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_13371 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_domain.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_13372 (h0 : group (complete_distrib_lattice (ring pos))) : normalizer_condition (complete_distrib_lattice (ring pos)) := sorry --non-trivial
lemma new_lemma_13373 (h0 : function.extfun nat fin) : @is_cyclic.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (group.{0} (ordered_comm_ring.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))))  := sorry --non-trivial
lemma new_lemma_13374 (h0 : ordered_comm_monoid (has_to_string (finset (has_to_string pos)))) : has_exists_mul_of_le (has_to_string (finset (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_13375 (h0 : ordered_comm_monoid (add_cancel_monoid Type)) : has_exists_mul_of_le (add_cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_13376 (h0 : complete_lattice (add_comm_monoid (has_add pos))) : is_compactly_generated (add_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_13377 (h0 : has_mem.mem (linear_ordered_semiring empty) has_emptyc.emptyc) : @t0_space.{0} (linear_ordered_semiring.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_13378 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @preirreducible_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_13379 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_13380 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @normal_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_13381 (h0 : topological_space (complete_linear_order (semiring congr_arg_kind))) : t0_space (complete_linear_order (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_13382 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_13383 (h0 : topological_space (semi_normed_ring (has_nnnorm char))) : totally_disconnected_space (semi_normed_ring (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_13384 (h0 : topological_space (simple_graph (option congr_arg_kind))) : preconnected_space (simple_graph (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_13385 (h0 : monoid (normed_comm_ring (ring name))) : monoid.fg (normed_comm_ring (ring name)) := sorry --non-trivial
lemma new_lemma_13386 (h0 : functor.add_const (semiring (finset pos)) linarith.comp) : @is_noetherian_ring.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (finset.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_13387 (h0 : complete_lattice (with_one (random_gen linarith.ineq))) : is_compactly_generated (with_one (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_13388 (h0 : cancel_comm_monoid_with_zero (ring environment.implicit_infer_kind)) : unique_factorization_monoid (ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_13389 (h0 : not (filter (random_gen linarith.comp_source) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_13390 (h0 : functor.comp topological_space ring name) : @topological_space.separable_space.{0} (ring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_13391 (h0 : ring (has_compl to_additive.value_type)) : rank_condition (has_compl to_additive.value_type) := sorry --non-trivial
lemma new_lemma_13392 (h1 : set (normed_field (mul_one_class (uniform_space string.iterator_imp)))) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_13393 (h0 : topological_space (normed_group (has_inv string_imp))) : t0_space (normed_group (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_13394 (h0 : functor.comp group has_nndist environment.implicit_infer_kind) : @is_cyclic.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_13395 (h0 : filter (mul_zero_class (has_add ennreal))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_13396 (h1 : filter (encodable (linear_ordered_add_comm_group char))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_13397 (h0 : functor.add_const (topological_space auto.case_option) unsigned) : @preirreducible_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) unsigned h0)  := sorry --non-trivial
lemma new_lemma_13398 (h0 : functor.add_const (group (add_cancel_monoid empty)) empty) : @normalizer_condition.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_13399 (h0 : functor.add_const (topological_space (has_inter unsigned)) (option (option empty))) : @normal_space.{0} (has_inter.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_inter.{0} unsigned)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_13400 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) pos) : @normal_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_13401 (h0 : has_mem.mem linarith.comp_source has_emptyc.emptyc) : @monoid.fg.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type monoid.{0} linarith.comp_source h0)  := sorry --non-trivial
lemma new_lemma_13402 (h0 : list (boolean_algebra (has_add (has_add (add_comm_monoid pos))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_13403 (h1 : topological_space fun_info) : locally_compact_space fun_info := sorry --non-trivial
lemma new_lemma_13404 (h0 : ring (has_nndist (option ennreal))) : is_principal_ideal_ring (has_nndist (option ennreal)) := sorry --non-trivial
lemma new_lemma_13405 (h0 : functor.add_const (topological_space (has_star num)) (semiring num)) : @totally_disconnected_space.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_13406 (h1 : topological_space (complete_semilattice_Sup (has_inv (has_ssubset string_imp)))) : path_connected_space (complete_semilattice_Sup (has_inv (has_ssubset string_imp))) := sorry --non-trivial
lemma new_lemma_13407 (h0 : function.extfun Type (functor.comp topological_space canonically_ordered_comm_semiring)) : @t1_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_13408 (h0 : ring (dlist (has_inv fun_info))) : strong_rank_condition (dlist (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_13409 (h0 : ordered_comm_monoid (has_nndist (option (option pos)))) : has_exists_mul_of_le (has_nndist (option (option pos))) := sorry --non-trivial
lemma new_lemma_13410 (h0 : topological_space (add_comm_monoid (finset name))) : locally_compact_space (add_comm_monoid (finset name)) := sorry --non-trivial
lemma new_lemma_13411 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_13412 (h0 : functor.add_const (complete_lattice (canonically_ordered_comm_semiring name)) linarith.comp) : @is_compactly_generated.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_ordered_comm_semiring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_13413 (h0 : group (has_lt (mul_one_class to_additive.value_type))) : is_cyclic (has_lt (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_13414 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_13415 (h0 : functor.add_const (ring (boolean_algebra.core linarith.comp)) name) : @rank_condition.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_13416 (h0 : add_comm_monoid (semigroup pos) -> add_comm_monoid (semigroup pos) -> Prop) : is_symm (add_comm_monoid (semigroup pos)) h0 := sorry --non-trivial
lemma new_lemma_13417 (h0 : functor.add_const (topological_space (has_Inf name)) Type) : @loc_path_connected_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_13418 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (filter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (filter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_13419 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_13420 (h0 : ring (topological_space (fintype (random_gen linarith.ineq)))) : strong_rank_condition (topological_space (fintype (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_13421 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_13422 (h0 : thunk Prop) (h1 : list Prop) : @list.ilast'.{0} Prop (@trace_call_stack.{0} Prop h0) h1  := sorry --non-trivial
lemma new_lemma_13423 (h0 : topological_space (comm_semigroup (sub_neg_monoid real))) : path_connected_space (comm_semigroup (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_13424 (h0 : has_mem.mem (has_norm num) has_emptyc.emptyc) : @is_compactly_generated.{0} (has_norm.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_norm.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_13425 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preirreducible_space.{0} (cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_13426 (h0 : function.extfun (Type 1) cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} h0 (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_13427 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ring unsigned)) environment.implicit_infer_kind) : @unique_factorization_monoid.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ring.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_13428 (h0 : group (boolean_algebra (finset linarith.comp))) : is_cyclic (boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_13429 (h0 : functor.add_const (topological_space (has_nndist name)) (comm_group name)) : @locally_compact_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_13430 (h1 : linarith.ineq -> linarith.ineq -> Prop) : is_directed linarith.ineq h1 := sorry --non-trivial
lemma new_lemma_13431 (h0 : topological_space (simple_graph (ring pos))) : preirreducible_space (simple_graph (ring pos)) := sorry --non-trivial
lemma new_lemma_13432 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (free_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (free_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_13433 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (add_group empty)) := sorry --non-trivial
lemma new_lemma_13434 (h0 : set (non_unital_non_assoc_semiring (mul_one_class fun_info))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_13435 (h0 : functor.add_const (topological_space (semigroup pos)) environment.implicit_infer_kind) : @discrete_topology.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_13436 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_13437 (h2 : topological_space (semi_normed_ring string_imp)) : t0_space (semi_normed_ring string_imp) := sorry --non-trivial
lemma new_lemma_13438 (h0 : add_comm_monoid (finset pos) -> add_comm_monoid (finset pos) -> Prop) : is_symm (add_comm_monoid (finset pos)) h0 := sorry --non-trivial
lemma new_lemma_13439 (h0 : function.extfun (random_gen fun_info) (fun (x : random_gen fun_info), Prop)) : set.infinite (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_13440 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_13441 (h0 : functor.add_const (group (boolean_algebra pos)) linarith.comp) : @normalizer_condition.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_13442 (h0 : semiring (mul_one_class ereal)) (h1 : ideal (mul_one_class ereal)) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_13443 (h2 : complete_lattice (mul_one_class (add_comm_semigroup ereal))) : complete_lattice.is_Sup_finite_compact (mul_one_class (add_comm_semigroup ereal)) := sorry --non-trivial
lemma new_lemma_13444 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (simple_graph.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (simple_graph.{0} empty))  := sorry --non-trivial
lemma new_lemma_13445 (h0 : ring (normed_group (has_norm (has_norm fun_info)))) : is_domain (normed_group (has_norm (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_13446 (h0 : complete_lattice (random_gen (has_ssubset linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (random_gen (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_13447 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_13448 (h0 : functor.add_const (topological_space (pseudo_metric_space pos)) (option pos)) : @preconnected_space.{0} (pseudo_metric_space.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} pos)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_13449 (h0 : function.extfun nat fin) : @totally_disconnected_space.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_13450 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (preorder.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_13451 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @t1_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_13452 (h0 : topological_space (boolean_algebra (has_add real))) : locally_compact_space (boolean_algebra (has_add real)) := sorry --non-trivial
lemma new_lemma_13453 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (free_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (free_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_13454 (h0 : uniform_space (has_bot Type)) : complete_space (has_bot Type) := sorry --non-trivial
lemma new_lemma_13455 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_monoid (has_bot pos))) : unique_factorization_monoid (canonically_ordered_monoid (has_bot pos)) := sorry --non-trivial
lemma new_lemma_13456 (h0 : not (topological_space (distrib char) -> false)) : @totally_disconnected_space.{0} (distrib.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_13457 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) linarith.comp) : @sequential_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_13458 (h0 : finset (boolean_algebra (boolean_algebra Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_13459 (h0 : topological_space (simple_graph (finset pos))) : regular_space (simple_graph (finset pos)) := sorry --non-trivial
lemma new_lemma_13460 (h0 : function.extfun nat fin) : @normalizer_condition.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_13461 (h0 : functor.add_const (function.extfun Type monoid) environment.implicit_infer_kind) : @monoid.fg.{0} (boolean_algebra.{0} (has_add.{0} pos)) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) environment.implicit_infer_kind h0) (boolean_algebra.{0} (has_add.{0} pos)))  := sorry --non-trivial
lemma new_lemma_13462 (h0 : topological_space (has_one (semiring congr_arg_kind))) : t1_space (has_one (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_13463 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_13464 (h0 : functor.add_const (topological_space (has_neg pos)) linarith.comp) : @sequential_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_13465 (h0 : functor.add_const (topological_space (has_neg ennreal)) ennreal) : @discrete_topology.{0} (has_neg.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_13466 (h0 : topological_space (normed_lattice_add_comm_group (has_neg pos))) : locally_compact_space (normed_lattice_add_comm_group (has_neg pos)) := sorry --non-trivial
lemma new_lemma_13467 (h0 : functor.add_const (ring (has_neg_part name)) linarith.comp) : @is_principal_ideal_ring.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_neg_part.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_13468 (h0 : fin has_zero.zero) : @is_domain.{0} (has_pos_part.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (has_pos_part.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_13469 (h0 : complete_lattice (with_bot (has_inv to_additive.value_type))) : is_compactly_generated (with_bot (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_13470 (h0 : topological_space (has_emptyc (random_gen fun_info))) : irreducible_space (has_emptyc (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_13471 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_13472 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (denumerable fun_info)) := sorry --non-trivial
lemma new_lemma_13473 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @discrete_topology.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_13474 (h0 : ring (semiring (random_gen congr_arg_kind))) : strong_rank_condition (semiring (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_13475 (h0 : semiring (nondiscrete_normed_field string.iterator_imp)) (h1 : ideal (nondiscrete_normed_field string.iterator_imp)) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_13476 (h0 : topological_space (distrib (has_ssubset to_additive.value_type))) : t0_space (distrib (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_13477 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_13478 (h0 : topological_space (add_left_cancel_semigroup unsigned)) : totally_disconnected_space (add_left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_13479 (h0 : measurable_space (has_ssubset fun_info)) (h1 : set (has_ssubset fun_info)) : measurable_set h1 := sorry --non-trivial
lemma new_lemma_13480 (h0 : functor.add_const (finset (has_Sup unsigned)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_13481 (h0 : topological_space (omega_complete_partial_order congr_arg_kind)) : normal_space (omega_complete_partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_13482 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (non_assoc_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (non_assoc_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_13483 (h0 : set (mul_one_class char -> fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_13484 (h0 : finset (cancel_monoid (has_add Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_13485 (h0 : functor.add_const (ordered_add_comm_monoid (has_add linarith.comp)) linarith.comp) : @archimedean.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_add.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_13486 (h0 : topological_space environment.implicit_infer_kind) : normal_space environment.implicit_infer_kind := sorry --non-trivial
lemma new_lemma_13487 (h0 : topological_space (has_zero (has_add (has_add name)))) : locally_compact_space (has_zero (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_13488 (h0 : topological_space (has_add (has_add linarith.comp))) : locally_compact_space (has_add (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_13489 (h0 : functor.add_const (topological_space (comm_monoid empty)) empty) : @discrete_topology.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_13490 (h0 : functor.add_const Prop (normed_comm_ring (has_neg (has_neg linarith.comp)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_13491 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (complete_distrib_lattice.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_13492 (h0 : topological_space (normed_group (comm_ring linarith.ineq))) : path_connected_space (normed_group (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_13493 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_13494 (h0 : functor.add_const (ring (measurable_space.dynkin_system unsigned)) unsigned) : @is_principal_ideal_ring.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (measurable_space.dynkin_system.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_13495 (h0 : ring (has_bot pos)) : strong_rank_condition (has_bot pos) := sorry --non-trivial
lemma new_lemma_13496 (h0 : semiring (add_cancel_monoid (ring Type))) : is_noetherian_ring (add_cancel_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_13497 (h0 : topological_space (semigroup linarith.comp)) : path_connected_space (semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_13498 (h1 : complete_lattice (with_one to_additive.value_type)) : is_atomistic (with_one to_additive.value_type) := sorry --non-trivial
lemma new_lemma_13499 (h0 : fin has_zero.zero) : @preconnected_space.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_13500 (h0 : cancel_comm_monoid_with_zero (generalized_boolean_algebra (has_add Type))) : unique_factorization_monoid (generalized_boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_13501 (h0 : functor.add_const (ordered_add_comm_monoid znum) (option (option empty))) : @archimedean.{0} znum (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} znum) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_13502 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} pos (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) pos)  := sorry --non-trivial
lemma new_lemma_13503 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring fun_info))) : @totally_disconnected_space.{0} (linear_ordered_semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_13504 (h1 : topological_space (has_compl std_gen)) : t0_space (has_compl std_gen) := sorry --non-trivial
lemma new_lemma_13505 (h0 : set (add_comm_semigroup (add_comm_semigroup enat) -> linarith.ineq)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_13506 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_pos_part pos)) (has_neg linarith.comp)) : @unique_factorization_monoid.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_pos_part.{0} pos)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_13507 (h0 : topological_space (comm_group (has_neg linarith.comp))) : locally_compact_space (comm_group (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_13508 (h0 : topological_space (has_dist unsigned)) : discrete_topology (has_dist unsigned) := sorry --non-trivial
lemma new_lemma_13509 (h0 : add_monoid (mul_zero_class (option (option name)))) : add_monoid.fg (mul_zero_class (option (option name))) := sorry --non-trivial
lemma new_lemma_13510 (h0 : group (ring (has_zero Type))) : normalizer_condition (ring (has_zero Type)) := sorry --non-trivial
lemma new_lemma_13511 (h0 : complete_lattice (has_one (has_norm (semiring (semiring (semiring empty)))))) : is_compactly_generated (has_one (has_norm (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_13512 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) Type) : @totally_disconnected_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (boolean_algebra.core.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_13513 (h0 : functor.add_const (ring (has_neg Type)) Type) : @strong_rank_condition.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (has_neg.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_13514 (h1 : topological_space (random_gen linarith.comp_source)) : locally_compact_space (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_13515 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (is_R_or_C.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (is_R_or_C.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_13516 (h0 : topological_space (linear_ordered_add_comm_group string_imp)) : path_connected_space (linear_ordered_add_comm_group string_imp) := sorry --non-trivial
lemma new_lemma_13517 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_13518 (h0 : functor.add_const (semiring (canonically_linear_ordered_monoid real)) real) : @is_noetherian_ring.{0} (canonically_linear_ordered_monoid.{0} real) (@functor.add_const.run.{0 0} (semiring.{0} (canonically_linear_ordered_monoid.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_13519 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (mul_zero_class.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (mul_zero_class.{0} empty))  := sorry --non-trivial
lemma new_lemma_13520 (h0 : functor.add_const (list (complete_distrib_lattice num)) num) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_13521 (h0 : has_mem.mem ring has_emptyc.emptyc) : @strong_rank_condition.{0} linarith.comp (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_13522 (h0 : function.extfun Type topological_space) : topological_space.separable_space ennreal := sorry --non-trivial
lemma new_lemma_13523 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @t0_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_13524 (h0 : not (complete_lattice (complete_semilattice_Sup unsigned) -> false)) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (complete_semilattice_Sup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_13525 (h0 : function.extfun Type topological_space) : @t0_space.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_13526 (h0 : topological_space (distrib_lattice (has_norm fun_info))) : totally_separated_space (distrib_lattice (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_13527 (h0 : group (has_zero (linear_ordered_comm_monoid_with_zero pos))) : group.fg (has_zero (linear_ordered_comm_monoid_with_zero pos)) := sorry --non-trivial
lemma new_lemma_13528 (h0 : add_monoid (non_assoc_semiring unsigned)) : add_monoid.fg (non_assoc_semiring unsigned) := sorry --non-trivial
lemma new_lemma_13529 (h0 : functor.add_const (topological_space (has_neg pos)) linarith.comp) : @t1_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_13530 (h0 : add_group (with_bot (has_norm (has_norm (has_norm (has_norm congr_arg_kind)))))) : is_add_cyclic (with_bot (has_norm (has_norm (has_norm (has_norm congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_13531 (h0 : topological_space (normed_group num)) : totally_disconnected_space (normed_group num) := sorry --non-trivial
lemma new_lemma_13532 (h1 : semiring environment.projection_info) (h2 : ideal environment.projection_info) : ideal.is_maximal h2 := sorry --non-trivial
lemma new_lemma_13533 (h0 : function.extfun Type (functor.add_const (complete_lattice (normed_comm_ring empty)))) : @is_atomistic.{0} (normed_comm_ring.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_comm_ring.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (normed_comm_ring.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_13534 (h0 : functor.add_const (topological_space (has_nndist Type)) name) : @discrete_topology.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_13535 (h0 : functor.add_const (add_monoid (add_group empty)) congr_arg_kind) : @add_monoid.fg.{0} (add_group.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (add_group.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_13536 (h0 : ring (preorder (semiring empty))) : strong_rank_condition (preorder (semiring empty)) := sorry --non-trivial
lemma new_lemma_13537 (h0 : prod (comm_monoid unsigned) (comm_monoid unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_13538 (h0 : uniform_space (finset pos)) : complete_space (finset pos) := sorry --non-trivial
lemma new_lemma_13539 (h0 : functor.add_const (ring (has_Inf name)) (has_neg Type)) : @strong_rank_condition.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (has_Inf.{0} name)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_13540 (h0 : ring (random_gen char)) : rank_condition (random_gen char) := sorry --non-trivial
lemma new_lemma_13541 (h1 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h1 (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_13542 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) linarith.comp) : @path_connected_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_13543 (h0 : semiring (has_union (semiring empty))) : is_noetherian_ring (has_union (semiring empty)) := sorry --non-trivial
lemma new_lemma_13544 (h0 : functor.add_const (topological_space (complete_distrib_lattice linarith.comp)) name) : @irreducible_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_13545 (h0 : topological_space (has_nndist (has_add (has_nndist linarith.comp)))) : t0_space (has_nndist (has_add (has_nndist linarith.comp))) := sorry --non-trivial
lemma new_lemma_13546 (h0 : uniform_space (has_top (semiring unsigned))) : complete_space (has_top (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_13547 (h0 : topological_space (has_Sup (semiring congr_arg_kind))) : normal_space (has_Sup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_13548 (h0 : topological_space (ordered_comm_monoid (has_pos_part linarith.comp))) : locally_compact_space (ordered_comm_monoid (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_13549 (h0 : functor.add_const (list (add_cancel_monoid linarith.comp)) (has_zero (has_zero (has_zero linarith.comp)))) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_13550 (h0 : group (add_comm_monoid (semigroup Type))) : is_simple_group (add_comm_monoid (semigroup Type)) := sorry --non-trivial
lemma new_lemma_13551 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_13552 (h0 : ordered_comm_monoid (mul_zero_class (has_neg pos))) : has_exists_mul_of_le (mul_zero_class (has_neg pos)) := sorry --non-trivial
lemma new_lemma_13553 (h0 : measurable_space (has_div char)) (h1 : filter (has_div char)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_13554 (h0 : uniform_space (has_Inf (has_add (has_add pos)))) : separated_space (has_Inf (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_13555 (h0 : topological_space (add_cancel_monoid (has_add linarith.comp))) : discrete_topology (add_cancel_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_13556 (h0 : fin has_zero.zero) : @t0_space.{0} (ordered_comm_monoid.{0} (has_pos_part.{0} pos)) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} (has_pos_part.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_13557 (h0 : ring (has_nnnorm std_gen)) : rank_condition (has_nnnorm std_gen) := sorry --non-trivial
lemma new_lemma_13558 (h0 : topological_space (ring Type)) : regular_space (ring Type) := sorry --non-trivial
lemma new_lemma_13559 (h0 : ring (comm_group (finset Type))) : is_domain (comm_group (finset Type)) := sorry --non-trivial
lemma new_lemma_13560 (h0 h1 : multiset (mul_one_class (add_comm_semigroup enat))) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_13561 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (distrib_lattice.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (distrib_lattice.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_13562 (h0 : filter (sub_neg_monoid pos)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_13563 (h0 : ring (filter (option (option (option (option empty)))))) : rank_condition (filter (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_13564 (h0 : functor.add_const (complete_lattice (comm_group unsigned)) (comm_group (has_neg_part pos))) : @is_compactly_generated.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} unsigned)) (comm_group.{0} (has_neg_part.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_13565 (h0 : topological_space (random_gen (random_gen linarith.comp_source))) : path_connected_space (random_gen (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_13566 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (dlist.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (dlist.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_13567 (h0 : topological_space (with_one (has_top (semiring unsigned)))) : t0_space (with_one (has_top (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_13568 (h0 : functor.add_const (ring (normed_comm_ring pos)) pos) : @is_domain.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_13569 (h0 : topological_space (ordered_comm_monoid (has_Inf (finset (has_neg (has_add (has_Inf (has_Inf Type)))))))) : normal_space (ordered_comm_monoid (has_Inf (finset (has_neg (has_add (has_Inf (has_Inf Type))))))) := sorry --non-trivial
lemma new_lemma_13570 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_13571 (h0 : topological_space (with_one (has_norm fun_info))) : discrete_topology (with_one (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_13572 (h0 : functor.add_const (topological_space pos) pos) : @discrete_topology.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) pos h0)  := sorry --non-trivial
lemma new_lemma_13573 (h0 : not (topological_space (measurable_space congr_arg_kind) -> false)) : @t0_space.{0} (measurable_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_13574 (h0 : functor.add_const (topological_space (add_cancel_monoid empty)) empty) : @discrete_topology.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_13575 (h0 : topological_space (has_nndist empty)) : normal_space (has_nndist empty) := sorry --non-trivial
lemma new_lemma_13576 (h0 : functor.comp topological_space comm_group pos) : @locally_compact_space.{0} (comm_group.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_13577 (h0 : group (boolean_algebra (has_bot pos))) : group.fg (boolean_algebra (has_bot pos)) := sorry --non-trivial
lemma new_lemma_13578 (h0 : topological_space (has_neg name)) : preirreducible_space (has_neg name) := sorry --non-trivial
lemma new_lemma_13579 (h0 : functor.add_const (function.extfun Type ring) unsigned) : @is_principal_ideal_ring.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) unsigned h0) (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_13580 (h0 : complete_lattice (distrib (mul_one_class (random_gen char))) -> random_gen (random_gen char)) (h1 : not (coe_sort (set.range h0) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (distrib.{0} (mul_one_class.{0} (random_gen.{0} char))) (@set.range_splitting.{0 0} (complete_lattice.{0} (distrib.{0} (mul_one_class.{0} (random_gen.{0} char)))) (random_gen.{0} (random_gen.{0} char)) h0 (@classical.by_contradiction'.{1} (@coe_sort.{1 2} (set.{0} (random_gen.{0} (random_gen.{0} char))) Type (@set.has_coe_to_sort.{0} (random_gen.{0} (random_gen.{0} char))) (@set.range.{0 1} (random_gen.{0} (random_gen.{0} char)) (complete_lattice.{0} (distrib.{0} (mul_one_class.{0} (random_gen.{0} char)))) h0)) h1))  := sorry --non-trivial
lemma new_lemma_13581 (h0 : ring (has_nnnorm name)) : rank_condition (has_nnnorm name) := sorry --non-trivial
lemma new_lemma_13582 (h0 : ring empty) (h1 : cancel_comm_monoid_with_zero (normed_group (add_right_cancel_monoid (metric_space (subring empty))))) : unique_factorization_monoid (normed_group (add_right_cancel_monoid (metric_space (subring empty)))) := sorry --non-trivial
lemma new_lemma_13583 (h0 : not (ring (mul_zero_class empty) -> false)) : @is_principal_ideal_ring.{0} (mul_zero_class.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (mul_zero_class.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_13584 (h0 : function.extfun Type group) : @is_cyclic.{0} (linear_ordered_add_comm_group.{0} char) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_add_comm_group.{0} char))  := sorry --non-trivial
lemma new_lemma_13585 (h1 : measurable_space (has_ssubset linarith.ineq)) (h2 : filter (has_ssubset linarith.ineq)) : filter.is_measurably_generated h2 := sorry --non-trivial
lemma new_lemma_13586 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_13587 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_norm.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_13588 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_13589 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (has_pos_part.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (has_pos_part.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_13590 (h0 : topological_space (canonically_linear_ordered_monoid (semigroup (has_to_string num)))) : preconnected_space (canonically_linear_ordered_monoid (semigroup (has_to_string num))) := sorry --non-trivial
lemma new_lemma_13591 (h0 : functor.add_const (topological_space (add_left_cancel_semigroup empty)) unsigned) : @totally_separated_space.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_13592 (h0 : group (has_zero (has_add linarith.comp))) : group.fg (has_zero (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_13593 (h0 : functor.add_const (topological_space (mul_zero_class ennreal)) name) : @t1_space.{0} (mul_zero_class.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_13594 (h0 : complete_lattice (cancel_monoid linarith.comp)) : is_atomistic (cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_13595 (h0 : ring (filter (semiring num))) : is_domain (filter (semiring num)) := sorry --non-trivial
lemma new_lemma_13596 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_13597 (h0 : function.extfun Type group) : @group.fg.{0} to_additive.value_type (@function.extfun_app.{2 1} Type group.{0} h0 to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_13598 (h0 : topological_space (with_one linarith.comp_source)) : locally_compact_space (with_one linarith.comp_source) := sorry --non-trivial
lemma new_lemma_13599 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_13600 (h0 : functor.add_const (ring (boolean_algebra Type)) (finset environment.implicit_infer_kind)) : @is_domain.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.{1} Type)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_13601 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_13602 (h0 : ring (simple_graph (mul_one_class reducibility_hints))) : is_domain (simple_graph (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_13603 (h0 : functor.add_const (topological_space (partial_order num)) empty) : @irreducible_space.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_13604 (h1 : uniform_space (has_add fun_info)) : complete_space (has_add fun_info) := sorry --non-trivial
lemma new_lemma_13605 (h2 : ring (has_div to_additive.value_type)) : is_domain (has_div to_additive.value_type) := sorry --non-trivial
lemma new_lemma_13606 (h0 : complete_lattice (has_zero environment.implicit_infer_kind)) : is_atomistic (has_zero environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_13607 (h0 : functor.add_const (semiring (has_Inf pos)) pos) : @is_noetherian_ring.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (has_Inf.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_13608 (h0 : function.extfun Type (functor.add_const (monoid (linear_order empty)))) : @monoid.fg.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (linear_order.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (monoid.{0} (linear_order.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_13609 (h0 : functor.add_const (group (ordered_cancel_add_comm_monoid unsigned)) pos) : @group.fg.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (ordered_cancel_add_comm_monoid.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_13610 (h1 : topological_space (has_le reducibility_hints)) : totally_disconnected_space (has_le reducibility_hints) := sorry --non-trivial
lemma new_lemma_13611 (h0 : uniform_space (ring (finset linarith.comp))) : complete_space (ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_13612 (h0 : topological_space (with_one (has_norm linarith.ineq))) : path_connected_space (with_one (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_13613 (h0 : functor.add_const (topological_space (has_nndist pos)) (finset pos)) : @locally_compact_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_13614 (h0 : topological_space (has_add num)) : loc_path_connected_space (has_add num) := sorry --non-trivial
lemma new_lemma_13615 (h0 : ring (random_gen (has_ssubset (random_gen char)))) : rank_condition (random_gen (has_ssubset (random_gen char))) := sorry --non-trivial
lemma new_lemma_13616 (h0 : functor.add_const (ring (plift unsigned)) congr_arg_kind) : @is_principal_ideal_ring.{1} (plift.{1} unsigned) (@functor.add_const.run.{1 0} (ring.{1} (plift.{1} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_13617 (h0 : functor.add_const (complete_lattice (add_comm_monoid unsigned)) pos) : @is_atomistic.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_comm_monoid.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_13618 (h1 : complete_lattice (has_inv linarith.ineq)) : is_compactly_generated (has_inv linarith.ineq) := sorry --non-trivial
lemma new_lemma_13619 (h0 : fin has_zero.zero) : @is_domain.{1} (ring.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_13620 (h1 : not (uniform_space (has_compl string_imp) -> false)) : @complete_space.{0} (has_compl.{0} string_imp) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_compl.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_13621 (h0 : topological_space (bin_tree (semiring (semiring (semiring num))))) : discrete_topology (bin_tree (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_13622 (h0 : functor.add_const (topological_space (has_nndist pos)) environment.implicit_infer_kind) : @sequential_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_13623 (h0 : topological_space (has_neg_part (has_neg_part unsigned))) : path_connected_space (has_neg_part (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_13624 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) (ring pos)) : @totally_separated_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_13625 (h1 : not (ring (id linarith.comp) -> false)) : @is_domain.{0} (@id.{2} Type linarith.comp) (@classical.by_contradiction'.{1} (ring.{0} (@id.{2} Type linarith.comp)) h1)  := sorry --non-trivial
lemma new_lemma_13626 (h0 : functor.add_const (topological_space (comm_group ennreal)) name) : @locally_compact_space.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_13627 (h0 : not (topological_space (mul_zero_class empty) -> false)) : @locally_compact_space.{0} (mul_zero_class.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (mul_zero_class.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_13628 (h0 : uniform_space (comm_group pos)) : complete_space (comm_group pos) := sorry --non-trivial
lemma new_lemma_13629 (h0 : topological_space (canonically_ordered_monoid (has_Inf linarith.comp))) : t1_space (canonically_ordered_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_13630 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 pos) := sorry --non-trivial
lemma new_lemma_13631 (h0 : topological_space (cancel_monoid num)) : preconnected_space (cancel_monoid num) := sorry --non-trivial
lemma new_lemma_13632 (h0 : function.extfun Type (functor.comp topological_space has_neg_part)) : @sequential_space.{0} (has_neg_part.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} name (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_neg_part.{0}) h0 name))))  := sorry --non-trivial
lemma new_lemma_13633 (h1 : add_group (has_norm (semiring (random_gen (semiring linarith.comp))))) : is_add_cyclic (has_norm (semiring (random_gen (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_13634 (h0 : ring (finset (has_add (boolean_algebra (has_add (has_add (has_zero (ring Type)))))))) : is_domain (finset (has_add (boolean_algebra (has_add (has_add (has_zero (ring Type))))))) := sorry --non-trivial
lemma new_lemma_13635 (h1 : has_mem.mem empty has_emptyc.emptyc) : @rank_condition.{0} empty (@finset.pi.empty.{1 0} Type ring.{0} empty h1)  := sorry --non-trivial
lemma new_lemma_13636 (h0 : uniform_space (mul_zero_class (semiring num))) : complete_space (mul_zero_class (semiring num)) := sorry --non-trivial
lemma new_lemma_13637 (h0 : complete_lattice (has_nndist (finset linarith.comp))) : complete_lattice.is_Sup_finite_compact (has_nndist (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_13638 (h0 : functor.add_const (group (semigroup empty)) empty) : @is_cyclic.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_13639 (h0 : topological_space (finset (boolean_algebra Type))) : regular_space (finset (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_13640 (h0 : has_mem.mem (measurable_space num) has_emptyc.emptyc) : @totally_separated_space.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_13641 (h0 : functor.add_const (complete_lattice (has_Inf name)) Type) : @is_atomistic.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_Inf.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_13642 (h0 : complete_lattice (normed_group (random_gen linarith.comp_source))) : is_atomistic (normed_group (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_13643 (h0 : group Type) : is_cyclic Type := sorry --non-trivial
lemma new_lemma_13644 (h0 : complete_lattice (add_left_cancel_monoid (random_gen fun_info))) : complete_lattice.is_Sup_finite_compact (add_left_cancel_monoid (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_13645 (h0 : functor.add_const (function.extfun (Type 1) filter) linarith.comp) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_13646 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_13647 (h0 : filter (add_cancel_monoid (finset (finset (finset pos))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_13648 (h0 : functor.add_const (topological_space (ring linarith.comp)) environment.implicit_infer_kind) : @sequential_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_13649 (h0 : group (has_add (has_neg (has_neg (has_nndist (ring pos)))))) : is_cyclic (has_add (has_neg (has_neg (has_nndist (ring pos))))) := sorry --non-trivial
lemma new_lemma_13650 (h0 : not (uniform_space (measurable_space.dynkin_system unsigned) -> false)) : @complete_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (measurable_space.dynkin_system.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_13651 (h0 : add_group (has_lt (mul_one_class (mul_one_class string.iterator_imp)))) : is_add_cyclic (has_lt (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_13652 (h0 : has_mem.mem (normed_group congr_arg_kind) has_emptyc.emptyc) : @discrete_topology.{0} (normed_group.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_13653 (h0 : topological_space (has_norm (has_inv linarith.comp_source))) : irreducible_space (has_norm (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_13654 (h0 : uniform_space (cancel_monoid (option (option pos)))) : complete_space (cancel_monoid (option (option pos))) := sorry --non-trivial
lemma new_lemma_13655 (h0 : complete_lattice (comm_semigroup name)) : is_compactly_generated (comm_semigroup name) := sorry --non-trivial
lemma new_lemma_13656 (h0 : topological_space (complete_distrib_lattice (complete_distrib_lattice unsigned))) : totally_separated_space (complete_distrib_lattice (complete_distrib_lattice unsigned)) := sorry --non-trivial
lemma new_lemma_13657 (h0 : topological_space (has_add (has_to_string Type))) : discrete_topology (has_add (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_13658 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_13659 (h1 : topological_space (has_add to_additive.value_type)) : totally_disconnected_space (has_add to_additive.value_type) := sorry --non-trivial
lemma new_lemma_13660 (h0 : fin has_zero.zero) : @regular_space.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_bot.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_13661 (h0 : topological_space (cancel_monoid (boolean_algebra.core Type))) : t0_space (cancel_monoid (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_13662 (h0 : add_monoid (mul_zero_class (has_neg_part (has_add (has_neg (has_neg_part name)))))) : add_monoid.fg (mul_zero_class (has_neg_part (has_add (has_neg (has_neg_part name))))) := sorry --non-trivial
lemma new_lemma_13663 (h0 : uniform_space (has_to_string (finset environment.implicit_infer_kind))) : complete_space (has_to_string (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_13664 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (semi_normed_comm_ring.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (semi_normed_comm_ring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_13665 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_13666 (h0 : topological_space (has_emptyc (has_top (has_top fun_info)))) : locally_compact_space (has_emptyc (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_13667 (h1 : topological_space (has_le string.iterator_imp)) (h2 : preorder (has_le string.iterator_imp)) : order_closed_topology (has_le string.iterator_imp) := sorry --non-trivial
lemma new_lemma_13668 (h0 : function.extfun (Type 1) ordered_comm_monoid) : @has_exists_mul_of_le.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} h0 (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_13669 (h0 : group (has_top num)) : group.fg (has_top num) := sorry --non-trivial
lemma new_lemma_13670 (h1 : function.extfun Type topological_space) : @t0_space.{0} (has_emptyc.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (has_emptyc.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_13671 (h0 : functor.add_const (topological_space (boolean_algebra.core environment.implicit_infer_kind)) name) : @discrete_topology.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_13672 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) pos) : @regular_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_13673 (h0 : function.extfun Type (functor.add_const (group (free_add_monoid empty)))) : @normalizer_condition.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (free_add_monoid.{0} empty)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (free_add_monoid.{0} empty))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_13674 (h0 : functor.add_const (uniform_space (comm_group name)) unsigned) : @separated_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (comm_group.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_13675 (h0 : uniform_space (add_comm_monoid (finset environment.implicit_infer_kind))) : separated_space (add_comm_monoid (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_13676 (h0 : linarith.ineq -> linarith.ineq -> Prop) : irreflexive h0 := sorry --non-trivial
lemma new_lemma_13677 (h0 : topological_space (has_lt (mul_one_class linarith.ineq))) : path_connected_space (has_lt (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_13678 (h0 : topological_space (ring (option num))) : topological_space.separable_space (ring (option num)) := sorry --non-trivial
lemma new_lemma_13679 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_comm_monoid name)) (has_add name)) : @unique_factorization_monoid.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_comm_monoid.{0} name)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_13680 (h0 : ring (mul_one_class (normed_field (bin_tree linarith.ineq)))) : strong_rank_condition (mul_one_class (normed_field (bin_tree linarith.ineq))) := sorry --non-trivial
lemma new_lemma_13681 (h0 : uniform_space (has_to_string (has_neg_part (comm_group Type)))) : complete_space (has_to_string (has_neg_part (comm_group Type))) := sorry --non-trivial
lemma new_lemma_13682 (h0 : function.extfun (Type 1) add_monoid) : @add_monoid.fg.{1} (normed_lattice_add_comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} h0 (normed_lattice_add_comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_13683 (h0 : group (canonically_ordered_comm_semiring (finset (finset pos)))) : is_simple_group (canonically_ordered_comm_semiring (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_13684 (h0 : list (preorder empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_13685 (h0 : topological_space (normed_group fun_info)) : totally_separated_space (normed_group fun_info) := sorry --non-trivial
lemma new_lemma_13686 (h0 : ring (has_neg_part (option (option (canonically_linear_ordered_monoid pos))))) : strong_rank_condition (has_neg_part (option (option (canonically_linear_ordered_monoid pos)))) := sorry --non-trivial
lemma new_lemma_13687 (h0 : function.extfun Type (functor.comp ring has_add)) : @is_domain.{0} (has_add.{0} unsigned) (@functor.comp.run.{0 0 0} ring.{0} has_add.{0} unsigned (@functor.comp.run.{0 0 0} ring.{0} has_add.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} has_add.{0}) h0 unsigned)))  := sorry --non-trivial
lemma new_lemma_13688 (h0 : function.extfun Type ring) : @is_domain.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_13689 (h1 : ring (fintype linarith.comp_source)) : is_domain (fintype linarith.comp_source) := sorry --non-trivial
lemma new_lemma_13690 (h0 : functor.add_const (ordered_comm_monoid (add_comm_monoid environment.implicit_infer_kind)) Type) : @has_exists_mul_of_le.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_13691 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @totally_disconnected_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_13692 (h0 : topological_space (add_left_cancel_monoid (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) : t0_space (add_left_cancel_monoid (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_13693 (h0 : add_monoid (linear_ordered_semiring (semiring (semiring congr_arg_kind)))) : add_monoid.fg (linear_ordered_semiring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_13694 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) (cancel_monoid linarith.comp)) : @t1_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) (cancel_monoid.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_13695 (h0 : function.extfun Type group) : @normalizer_condition.{0} (linear_order.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_13696 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (add_semigroup empty)) := sorry --non-trivial
lemma new_lemma_13697 (h0 : functor.add_const (ring (ordered_comm_ring linarith.comp)) (ring (ring (ordered_ring Type)))) : @rank_condition.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (ordered_comm_ring.{0} linarith.comp)) (ring.{1} (ring.{1} (ordered_ring.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_13698 (h0 : not (ring (topological_space int) -> false)) : @rank_condition.{0} (topological_space.{0} int) (@classical.by_contradiction'.{1} (ring.{0} (topological_space.{0} int)) h0)  := sorry --non-trivial
lemma new_lemma_13699 (h0 : not (ring (random_gen fun_info) -> false)) : @is_domain.{0} (random_gen.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_13700 (h0 : functor.add_const (ordered_add_comm_monoid (ring linarith.comp)) (has_neg (has_nndist pos))) : @archimedean.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ring.{0} linarith.comp)) (has_neg.{0} (has_nndist.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_13701 (h0 : complete_lattice (measure_theory.measure_space (semiring unsigned))) : is_compactly_generated (measure_theory.measure_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_13702 (h0 : group (generalized_boolean_algebra name)) : is_cyclic (generalized_boolean_algebra name) := sorry --non-trivial
lemma new_lemma_13703 (h0 : complete_lattice (left_cancel_monoid (semiring empty))) : is_compactly_generated (left_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_13704 (h0 : function.extfun nat fin) : @group.fg.{0} (has_nndist.{0} pos) (@matrix.vec_empty.{0} (group.{0} (has_nndist.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_13705 (h0 : ring (add_cancel_monoid (has_neg linarith.comp))) : rank_condition (add_cancel_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_13706 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (add_left_cancel_semigroup.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_left_cancel_semigroup.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_13707 (h0 : topological_space (has_top (random_gen linarith.comp_source))) : totally_disconnected_space (has_top (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_13708 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_bot empty)) := sorry --non-trivial
lemma new_lemma_13709 (h0 : monoid (cancel_monoid (semigroup Type))) : monoid.fg (cancel_monoid (semigroup Type)) := sorry --non-trivial
lemma new_lemma_13710 (h0 : topological_space (has_add (option (option (option ennreal))))) : preconnected_space (has_add (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_13711 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_13712 (h0 : add_monoid (canonically_linear_ordered_monoid (option num))) : add_monoid.fg (canonically_linear_ordered_monoid (option num)) := sorry --non-trivial
lemma new_lemma_13713 (h0 : uniform_space (has_Sup num)) : separated_space (has_Sup num) := sorry --non-trivial
lemma new_lemma_13714 (h0 : function.extfun Type (functor.add_const (list (add_group empty)))) : list.nodup (functor.add_const.run (function.extfun_app h0 num)) := sorry --non-trivial
lemma new_lemma_13715 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_13716 (h0 : topological_space (boolean_algebra (has_Inf pos))) : preconnected_space (boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_13717 (h2 : has_neg (mul_one_class linarith.ineq)) (h3 : measurable_space (mul_one_class linarith.ineq)) : has_measurable_neg (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_13718 (h0 : function.extfun (Type 1) topological_space) : @totally_disconnected_space.{1} (plift.{1} num) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (plift.{1} num))  := sorry --non-trivial
lemma new_lemma_13719 (h0 : not (complete_lattice (has_inf fun_info) -> false)) : @is_compactly_generated.{0} (has_inf.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_inf.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_13720 (h0 : functor.add_const (topological_space (has_zero unsigned)) linarith.comp) : @t1_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_13721 (h0 : group (filter (complete_distrib_lattice empty))) : is_cyclic (filter (complete_distrib_lattice empty)) := sorry --non-trivial
lemma new_lemma_13722 (h0 : functor.add_const (list (generalized_boolean_algebra linarith.comp)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_13723 (h0 : topological_space (has_top (has_top congr_arg_kind))) : discrete_topology (has_top (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_13724 (h0 : functor.comp topological_space ring linarith.comp) : @t0_space.{0} (ring.{0} linarith.comp) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_13725 (h0 : fin has_zero.zero) : @strong_rank_condition.{0} (simple_graph.{0} (has_Inf.{0} linarith.comp)) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (simple_graph.{0} (has_Inf.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_13726 (h0 : functor.add_const (finset (has_neg name)) (mul_zero_class Type)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_13727 (h2 : has_add char) (h3 : has_le char) (h4 : char) : add_le_cancellable h4 := sorry --non-trivial
lemma new_lemma_13728 (h0 : ordered_add_comm_monoid (semigroup (finset Type))) : archimedean (semigroup (finset Type)) := sorry --non-trivial
lemma new_lemma_13729 (h0 : topological_space (monoid_with_zero pos)) : totally_separated_space (monoid_with_zero pos) := sorry --non-trivial
lemma new_lemma_13730 (h0 : group (with_one (has_norm num))) : normalizer_condition (with_one (has_norm num)) := sorry --non-trivial
lemma new_lemma_13731 (h0 : group (option unsigned)) : normalizer_condition (option unsigned) := sorry --non-trivial
lemma new_lemma_13732 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_13733 (h0 : functor.add_const (ordered_comm_monoid (has_nndist pos)) (finset pos)) : @has_exists_mul_of_le.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_nndist.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_13734 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (semigroup pos)) := sorry --non-trivial
lemma new_lemma_13735 (h0 : functor.add_const (topological_space (comm_group name)) (comm_group (comm_group name))) : @totally_separated_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) (comm_group.{0} (comm_group.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_13736 (h0 : ordered_comm_monoid (generalized_boolean_algebra (generalized_boolean_algebra Type))) : has_exists_mul_of_le (generalized_boolean_algebra (generalized_boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_13737 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (comm_semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_13738 (h0 : semiring (has_inter ennreal)) : is_noetherian_ring (has_inter ennreal) := sorry --non-trivial
lemma new_lemma_13739 (h0 : functor.add_const (topological_space (normed_comm_ring (has_neg linarith.comp))) linarith.comp) : @regular_space.{0} (normed_comm_ring.{0} (has_neg.{0} linarith.comp)) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} (has_neg.{0} linarith.comp))) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_13740 (h0 : functor.add_const Prop (add_comm_monoid ennreal)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_13741 (h0 : topological_space (semigroup (has_add name))) : t1_space (semigroup (has_add name)) := sorry --non-trivial
lemma new_lemma_13742 (h0 : topological_space (linear_ordered_comm_group unsigned)) : preconnected_space (linear_ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_13743 (h0 : functor.add_const (uniform_space (boolean_algebra.core linarith.comp)) (ring Type)) : @separated_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (boolean_algebra.core.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_13744 (h0 : topological_space (finset (comm_group name))) : t1_space (finset (comm_group name)) := sorry --non-trivial
lemma new_lemma_13745 (h0 : ordered_add_comm_monoid (distrib_lattice (random_gen to_additive.value_type))) : archimedean (distrib_lattice (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_13746 (h0 : group (canonically_ordered_monoid (has_Inf real))) : normalizer_condition (canonically_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_13747 (h0 : ordered_add_comm_monoid (boolean_algebra.core (ordered_ring pos))) : archimedean (boolean_algebra.core (ordered_ring pos)) := sorry --non-trivial
lemma new_lemma_13748 (h0 : topological_space (has_neg (normed_comm_ring Type))) : totally_separated_space (has_neg (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_13749 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (finset pos)) := sorry --non-trivial
lemma new_lemma_13750 (h0 : not (topological_space (measurable_space.dynkin_system char) -> false)) : @path_connected_space.{0} (measurable_space.dynkin_system.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.dynkin_system.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_13751 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @separated_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) uniform_space.{0}) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_13752 (h0 : topological_space (ring (ring linarith.comp))) : topological_space.separable_space (ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_13753 (h0 : group (distrib_lattice (has_inv (has_top linarith.comp_source)))) : is_cyclic (distrib_lattice (has_inv (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_13754 (h0 : topological_space (canonically_linear_ordered_monoid (option ennreal))) : preirreducible_space (canonically_linear_ordered_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_13755 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_one.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (has_one.{0} num))  := sorry --non-trivial
lemma new_lemma_13756 (h0 : topological_space (has_to_string (comm_group (has_to_string (has_to_string pos))))) : totally_separated_space (has_to_string (comm_group (has_to_string (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_13757 (h0 : topological_space (has_zero (add_cancel_monoid (has_add (boolean_algebra name))))) : normal_space (has_zero (add_cancel_monoid (has_add (boolean_algebra name)))) := sorry --non-trivial
lemma new_lemma_13758 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (comm_semigroup.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_13759 (h0 : add_group (semi_normed_comm_ring (random_gen to_additive.value_type))) : is_add_cyclic (semi_normed_comm_ring (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_13760 (h0 : ordered_add_comm_monoid (has_pos_part (ring (ring Type)))) : archimedean (has_pos_part (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_13761 (h0 : finset (comm_group (finset linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_13762 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (simple_graph.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (simple_graph.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_13763 (h0 : add_group (complete_linear_order (semiring unsigned))) : is_add_cyclic (complete_linear_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_13764 (h0 : semiring (has_star (semiring (semiring congr_arg_kind)))) : is_noetherian_ring (has_star (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_13765 (h0 : function.extfun (Type 1) topological_space) : @discrete_topology.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_13766 (h0 : functor.add_const (semiring nnreal) (semiring empty)) : is_noetherian_ring nnreal := sorry --non-trivial
lemma new_lemma_13767 (h0 : functor.add_const (group (ring name)) (has_neg Type)) : @is_cyclic.{0} (ring.{0} name) (@functor.add_const.run.{0 1} (group.{0} (ring.{0} name)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_13768 (h0 : functor.comp group has_to_string name) : @normalizer_condition.{0} (has_to_string.{0} name) (@functor.comp.run.{0 0 0} group.{0} has_to_string.{0} name h0)  := sorry --non-trivial
lemma new_lemma_13769 (h0 : add_group (distrib (comm_ring (random_gen reducibility_hints)))) : is_add_cyclic (distrib (comm_ring (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_13770 (h0 : topological_space (normed_comm_ring (finset (finset environment.implicit_infer_kind)))) : normal_space (normed_comm_ring (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_13771 (h0 : has_mem.mem (metric_space linarith.comp) has_emptyc.emptyc) : @separated_space.{0} (metric_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type uniform_space.{0} (metric_space.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_13772 (h0 : not (monoid (id unsigned) -> false)) : @monoid.fg.{0} (@id.{2} Type unsigned) (@classical.by_contradiction'.{1} (monoid.{0} (@id.{2} Type unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_13773 (h1 h2 : multiset (has_compl std_gen)) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_13774 (h0 : functor.add_const (list (has_to_string pos)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_13775 (h0 : topological_space (linear_ordered_add_comm_group (has_inv to_additive.value_type))) : path_connected_space (linear_ordered_add_comm_group (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_13776 (h0 : uniform_space (has_norm (has_norm linarith.comp))) : separated_space (has_norm (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_13777 (h0 : add_group (finset (has_add Type))) : is_add_cyclic (finset (has_add Type)) := sorry --non-trivial
lemma new_lemma_13778 (h0 : topological_space (has_top linarith.comp_source)) : totally_separated_space (has_top linarith.comp_source) := sorry --non-trivial
lemma new_lemma_13779 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) (has_nndist pos)) : @separated_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) uniform_space.{1}) (has_nndist.{0} pos) h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_13780 (h0 : has_mem.mem (random_gen num) has_emptyc.emptyc) : @is_atomistic.{0} (random_gen.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_13781 (h0 : finset (ring (semiring empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_13782 (h0 : not (complete_lattice (linear_ordered_semiring unsigned) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_13783 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_13784 (h0 : ring (non_assoc_semiring (semiring (semiring congr_arg_kind)))) : strong_rank_condition (non_assoc_semiring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_13785 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_13786 (h2 : topological_space (has_append fun_info)) : t0_space (has_append fun_info) := sorry --non-trivial
lemma new_lemma_13787 (h0 : ring (id (random_gen congr_arg_kind))) : rank_condition (id (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_13788 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (left_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_13789 (h0 : complete_lattice (generalized_boolean_algebra Type)) : complete_lattice.is_Sup_finite_compact (generalized_boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_13790 (h0 : topological_space (ring (has_add (has_neg_part (semigroup (has_add Type)))))) : preirreducible_space (ring (has_add (has_neg_part (semigroup (has_add Type))))) := sorry --non-trivial
lemma new_lemma_13791 (h0 : functor.add_const (complete_lattice (comm_group linarith.comp)) environment.implicit_infer_kind) : @is_atomistic.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_13792 (h0 : topological_space (complete_semilattice_Sup (has_top (has_inv fun_info)))) : locally_compact_space (complete_semilattice_Sup (has_top (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_13793 (h0 : fin has_zero.zero) : @path_connected_space.{0} (add_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_13794 (h0 : has_mem.mem (semiring to_additive.value_type) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (semiring.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_13795 (h0 : not (topological_space (mul_one_class to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (mul_one_class.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (mul_one_class.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_13796 (h0 : function.extfun Type topological_space) : @normal_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_13797 (h0 : functor.add_const (topological_space (has_add real)) real) : @preconnected_space.{0} (has_add.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_13798 (h0 : topological_space (metric_space (has_top linarith.comp))) : locally_compact_space (metric_space (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_13799 (h0 : function.extfun Type group) : @is_cyclic.{0} (add_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (add_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_13800 (h0 : functor.add_const (topological_space (cancel_monoid unsigned)) unsigned) : @path_connected_space.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_13801 (h0 : not (uniform_space (uniform_space reducibility_hints) -> false)) : @complete_space.{0} (uniform_space.{0} reducibility_hints) (@classical.by_contradiction'.{1} (uniform_space.{0} (uniform_space.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_13802 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (with_one.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_13803 (h2 : ring (normed_group fun_info)) : strong_rank_condition (normed_group fun_info) := sorry --non-trivial
lemma new_lemma_13804 (h0 : topological_space (has_pos_part (finset linarith.comp))) : totally_disconnected_space (has_pos_part (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_13805 (h1 : uniform_space (uniform_space to_additive.value_type)) : complete_space (uniform_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_13806 (h0 : functor.comp topological_space has_to_string Type) : @path_connected_space.{1} (has_to_string.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_to_string.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_13807 (h0 : functor.add_const (group (complete_distrib_lattice name)) linarith.comp) : @is_simple_group.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_13808 (h1 : list (semi_normed_comm_ring to_additive.value_type)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_13809 (h0 : pnat) (h1 : ulower nat) (h2 : fin (nat.succ (ulower.up h1)) -> ulower pnat) (h3 : fin (ulower.up h1)) : pnat.coprime h0 (ulower.up (matrix.vec_tail h2 h3)) := sorry --non-trivial
lemma new_lemma_13810 (h0 : topological_space (complete_semilattice_Sup (random_gen (random_gen fun_info)))) : path_connected_space (complete_semilattice_Sup (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_13811 (h0 : uniform_space (linear_ordered_comm_ring (semiring (semiring unsigned)))) : separated_space (linear_ordered_comm_ring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_13812 (h0 : set (add_comm_semigroup (add_comm_semigroup ereal) -> mul_one_class enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_13813 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) name) : @sequential_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_13814 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (add_semigroup.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type monoid.{0} h0 (add_semigroup.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_13815 (h0 : add_monoid (mul_zero_class empty)) : add_monoid.fg (mul_zero_class empty) := sorry --non-trivial
lemma new_lemma_13816 (h0 : uniform_space (ring (option (option (option pos))))) : separated_space (ring (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_13817 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) linarith.comp) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_13818 (h0 : topological_space (add_cancel_monoid (has_neg (has_Inf name)))) : t0_space (add_cancel_monoid (has_neg (has_Inf name))) := sorry --non-trivial
lemma new_lemma_13819 (h0 : fin has_zero.zero) : @group.fg.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (group.{1} (comm_semigroup.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_13820 (h0 : topological_space (has_emptyc (random_gen (random_gen fun_info)))) : path_connected_space (has_emptyc (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_13821 (h0 : uniform_space (complete_distrib_lattice (finset (finset Type)))) : separated_space (complete_distrib_lattice (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_13822 (h0 : topological_space nnreal) : topological_space.separable_space nnreal := sorry --non-trivial
lemma new_lemma_13823 (h0 : functor.add_const (topological_space (complete_distrib_lattice real)) name) : @t1_space.{0} (complete_distrib_lattice.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} real)) name h0)  := sorry --non-trivial
lemma new_lemma_13824 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_13825 (h4 : function.extfun Type topological_space) : @totally_disconnected_space.{0} linarith.ineq (@function.extfun_app.{2 1} Type topological_space.{0} h4 linarith.ineq)  := sorry --non-trivial
lemma new_lemma_13826 (h0 : monoid (measurable_space.dynkin_system (linear_ordered_semiring empty))) : monoid.fg (measurable_space.dynkin_system (linear_ordered_semiring empty)) := sorry --non-trivial
lemma new_lemma_13827 (h0 : topological_space (with_one (semiring empty))) : totally_disconnected_space (with_one (semiring empty)) := sorry --non-trivial
lemma new_lemma_13828 (h0 : not (topological_space (left_cancel_semigroup num) -> false)) : @t0_space.{0} (left_cancel_semigroup.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_semigroup.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_13829 (h0 : ring (has_neg (option name))) : strong_rank_condition (has_neg (option name)) := sorry --non-trivial
lemma new_lemma_13830 (h0 : ring (simple_graph (has_add Type))) : rank_condition (simple_graph (has_add Type)) := sorry --non-trivial
lemma new_lemma_13831 (h0 : group (has_norm (has_nnnorm (has_nnnorm (has_top linarith.comp_source))))) : group.fg (has_norm (has_nnnorm (has_nnnorm (has_top linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_13832 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_13833 (h0 : ring (uniform_space (mul_one_class string_imp))) : rank_condition (uniform_space (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_13834 (h0 : functor.add_const (ring (cancel_monoid pos)) linarith.comp) : @strong_rank_condition.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (cancel_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_13835 (h0 : ring (fintype (has_nnnorm (has_nnnorm fun_info)))) : rank_condition (fintype (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_13836 (h0 : not (complete_lattice (denumerable char) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (denumerable.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (denumerable.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_13837 (h0 : function.extfun (Type 1) complete_lattice) : @is_compactly_generated.{1} (plift.{1} num) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (plift.{1} num))  := sorry --non-trivial
lemma new_lemma_13838 (h0 : topological_space (ring (has_neg Type))) : t1_space (ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_13839 (h0 : function.extfun (Type 1) topological_space) : @loc_path_connected_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_13840 (h0 : linear_ordered_field num -> linear_ordered_field num -> Prop) : is_symm (linear_ordered_field num) h0 := sorry --non-trivial
lemma new_lemma_13841 (h0 : topological_space (has_to_string environment.implicit_infer_kind)) : path_connected_space (has_to_string environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_13842 (h0 : functor.add_const (topological_space znum) (option unsigned)) : @topological_space.separable_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_13843 (h0 : topological_space (has_one (id empty))) : preirreducible_space (has_one (id empty)) := sorry --non-trivial
lemma new_lemma_13844 (h0 : ring (dlist (encodable fun_info))) : rank_condition (dlist (encodable fun_info)) := sorry --non-trivial
lemma new_lemma_13845 (h0 : functor.add_const (list (has_to_string pos)) (ring environment.implicit_infer_kind)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_13846 (h0 : topological_space (sub_neg_monoid (has_neg (has_neg name)))) : irreducible_space (sub_neg_monoid (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_13847 (h0 : uniform_space (random_gen congr_arg_kind)) : separated_space (random_gen congr_arg_kind) := sorry --non-trivial
lemma new_lemma_13848 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) linarith.comp) : @preirreducible_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_13849 (h0 : uniform_space (monoid (option (semiring empty)))) : complete_space (monoid (option (semiring empty))) := sorry --non-trivial
lemma new_lemma_13850 (h0 : with_bot (list Prop)) (h1 : ne h0 has_bot.bot) : list.tfae (with_bot.unbot h0 h1) := sorry --non-trivial
lemma new_lemma_13851 (h0 : fin has_zero.zero) : @t0_space.{0} (has_add.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_13852 (h0 : ring (semi_normed_ring (metric_space reducibility_hints))) : rank_condition (semi_normed_ring (metric_space reducibility_hints)) := sorry --non-trivial
lemma new_lemma_13853 (h0 : add_group (has_inv (random_gen to_additive.value_type))) : is_add_cyclic (has_inv (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_13854 (h0 : pseudo_metric_space (ordered_cancel_add_comm_monoid pos)) (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @has_lipschitz_add.{0} (ordered_cancel_add_comm_monoid.{0} pos) h0 (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 add_monoid.{0}) (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_13855 (h0 : topological_space (canonically_ordered_comm_semiring (finset (finset name)))) : loc_path_connected_space (canonically_ordered_comm_semiring (finset (finset name))) := sorry --non-trivial
lemma new_lemma_13856 (h0 : fin has_zero.zero) : @preconnected_space.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_13857 (h3 : topological_space (denumerable char)) (h4 : measurable_space (denumerable char)) : opens_measurable_space (denumerable char) := sorry --non-trivial
lemma new_lemma_13858 (h0 : functor.add_const (finset (has_to_string linarith.comp)) (has_pos_part (finset linarith.comp))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_13859 (h0 : functor.add_const (group (add_comm_monoid pos)) name) : @group.fg.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_13860 (h0 : cancel_comm_monoid_with_zero (has_neg (has_neg_part (has_neg_part name)))) : unique_factorization_monoid (has_neg (has_neg_part (has_neg_part name))) := sorry --non-trivial
lemma new_lemma_13861 (h0 : topological_space (has_nndist (semigroup Type))) : topological_space.separable_space (has_nndist (semigroup Type)) := sorry --non-trivial
lemma new_lemma_13862 (h0 : complete_lattice (ordered_comm_ring real)) : is_compactly_generated (ordered_comm_ring real) := sorry --non-trivial
lemma new_lemma_13863 (h0 : group (finset (finset (finset environment.implicit_infer_kind)))) : group.fg (finset (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_13864 (h0 : add_group (normed_linear_ordered_group empty)) : is_add_cyclic (normed_linear_ordered_group empty) := sorry --non-trivial
lemma new_lemma_13865 (h0 : functor.add_const (topological_space (ring name)) pos) : @path_connected_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_13866 (h0 : functor.add_const (ring (has_to_string Type)) (finset linarith.comp)) : @is_principal_ideal_ring.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_to_string.{1} Type)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_13867 (h0 : complete_lattice (ordered_comm_monoid (has_Inf (has_Inf (has_Inf Type))))) : is_compactly_generated (ordered_comm_monoid (has_Inf (has_Inf (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_13868 (h0 : topological_space (finset (finset linarith.comp))) : loc_path_connected_space (finset (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_13869 (h0 : topological_space (normed_linear_ordered_group (semiring unsigned))) : loc_path_connected_space (normed_linear_ordered_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_13870 (h0 : list (has_Inf (has_Inf linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_13871 (h1 : function.extfun (finset Type) (has_mem.mem (with_bot linarith.comp_source))) : @is_compactly_generated.{0} (with_bot.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} linarith.comp_source)) h1 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_13872 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (complete_lattice.{0} (sub_neg_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_13873 (h0 : filter (id (has_norm (has_top empty)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_13874 (h0 : ring (has_pos_part real)) : is_principal_ideal_ring (has_pos_part real) := sorry --non-trivial
lemma new_lemma_13875 (h0 : topological_space (has_inv (random_gen to_additive.value_type))) : locally_compact_space (has_inv (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_13876 (h0 : cancel_comm_monoid_with_zero (has_nndist (finset linarith.comp))) : unique_factorization_monoid (has_nndist (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_13877 (h0 : topological_space (has_to_string (normed_linear_ordered_group pos))) : topological_space.separable_space (has_to_string (normed_linear_ordered_group pos)) := sorry --non-trivial
lemma new_lemma_13878 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @t1_space.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (boolean_algebra.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_13879 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (complete_semilattice_Sup.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_13880 (h0 : topological_space (has_pos_part (finset pos))) : preirreducible_space (has_pos_part (finset pos)) := sorry --non-trivial
lemma new_lemma_13881 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (canonically_ordered_comm_semiring.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_ordered_comm_semiring.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_13882 (h0 : topological_space (has_scalar empty congr_arg_kind)) : irreducible_space (has_scalar empty congr_arg_kind) := sorry --non-trivial
lemma new_lemma_13883 (h0 : functor.add_const (add_group (generalized_boolean_algebra linarith.comp)) linarith.comp) : @is_add_cyclic.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (generalized_boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_13884 (h0 : group (boolean_algebra.core (has_nndist (has_add name)))) : group.fg (boolean_algebra.core (has_nndist (has_add name))) := sorry --non-trivial
lemma new_lemma_13885 (h0 : cancel_comm_monoid_with_zero (add_comm_monoid (has_add environment.implicit_infer_kind))) : unique_factorization_monoid (add_comm_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_13886 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_13887 (h0 : functor.add_const (finset (add_comm_monoid Type)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_13888 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) name) : @discrete_topology.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_13889 (h0 : topological_space (has_nndist (has_add pos))) : sequential_space (has_nndist (has_add pos)) := sorry --non-trivial
lemma new_lemma_13890 (h0 : functor.add_const (filter (has_neg Type)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_13891 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_13892 (h0 : group (with_one (random_gen num))) : is_cyclic (with_one (random_gen num)) := sorry --non-trivial
lemma new_lemma_13893 (h0 : monoid (has_union empty)) : monoid.fg (has_union empty) := sorry --non-trivial
lemma new_lemma_13894 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_principal_ideal_ring.{1} (has_bot.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (has_bot.{1} Type))  := sorry --non-trivial
lemma new_lemma_13895 (h0 : function.extfun (Type 1) topological_space) : @totally_disconnected_space.{1} (plift.{1} (option.{0} unsigned)) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (plift.{1} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_13896 (h1 : has_lt (has_ssubset (mul_one_class string.iterator_imp))) : no_max_order (has_ssubset (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_13897 (h0 : group (has_to_string environment.implicit_infer_kind)) : is_cyclic (has_to_string environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_13898 (h0 : ordered_comm_monoid (has_nndist (has_add unsigned))) : has_exists_mul_of_le (has_nndist (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_13899 (h0 : functor.add_const (group (has_neg linarith.comp)) environment.implicit_infer_kind) : @normalizer_condition.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_13900 (h0 : ring (linear_ordered_field (option (option (option unsigned))))) : rank_condition (linear_ordered_field (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_13901 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_13902 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type semiring.{0} h0 (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_13903 (h0 : topological_space (has_zero (has_to_string pos))) : t1_space (has_zero (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_13904 (h0 : functor.add_const (topological_space (ordered_comm_monoid Type)) (has_add pos)) : @t0_space.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_monoid.{1} Type)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_13905 (h0 : functor.add_const (function.extfun Type topological_space) name) : @sequential_space.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_13906 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (has_ssubset.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_ssubset.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_13907 (h0 : topological_space (distrib_lattice (random_gen (random_gen fun_info)))) : totally_separated_space (distrib_lattice (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_13908 (h0 : topological_space (nondiscrete_normed_field linarith.ineq)) (h1 : set (nondiscrete_normed_field linarith.ineq)) : dense h1 := sorry --non-trivial
lemma new_lemma_13909 (h0 : functor.add_const (uniform_space (normed_comm_ring Type)) Type) : @complete_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (normed_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_13910 (h0 : topological_space (comm_group pos)) : loc_path_connected_space (comm_group pos) := sorry --non-trivial
lemma new_lemma_13911 (h0 : functor.add_const (topological_space (pseudo_metric_space ennreal)) ennreal) : @locally_compact_space.{0} (pseudo_metric_space.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_13912 (h0 : set (add_comm_semigroup (mul_one_class enat))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_13913 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (distrib_lattice.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (distrib_lattice.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_13914 (h0 : functor.add_const (finset (preorder num)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_13915 (h0 : cancel_comm_monoid_with_zero (mul_zero_class congr_arg_kind)) : unique_factorization_monoid (mul_zero_class congr_arg_kind) := sorry --non-trivial
lemma new_lemma_13916 (h0 : finset (bin_tree (semiring (semiring (semiring (semiring empty)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_13917 (h0 : functor.add_const (add_group (left_cancel_semigroup empty)) (option empty)) : @is_add_cyclic.{0} (left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (left_cancel_semigroup.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_13918 (h0 : topological_space (has_Inf (ordered_comm_monoid pos))) : preirreducible_space (has_Inf (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_13919 (h0 : functor.add_const (topological_space (ordered_ring num)) num) : @discrete_topology.{0} (ordered_ring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_13920 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_13921 (h0 : topological_space (canonically_ordered_comm_semiring (normed_comm_ring ennreal))) : t1_space (canonically_ordered_comm_semiring (normed_comm_ring ennreal)) := sorry --non-trivial
lemma new_lemma_13922 (h0 : ring (add_right_cancel_monoid empty)) : is_principal_ideal_ring (add_right_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_13923 (h0 : functor.add_const (function.extfun Type topological_space) name) : @t1_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_13924 (h0 : with_bot empty -> with_bot empty -> Prop) (h1 : set (with_bot empty)) : set.unbounded h0 h1 := sorry --non-trivial
lemma new_lemma_13925 (h0 : not (topological_space (semi_normed_comm_ring linarith.ineq) -> false)) : @locally_compact_space.{0} (semi_normed_comm_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_comm_ring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_13926 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_13927 (h0 : topological_space (add_comm_semigroup reducibility_hints)) : t0_space (add_comm_semigroup reducibility_hints) := sorry --non-trivial
lemma new_lemma_13928 (h0 : functor.add_const (uniform_space (cancel_monoid name)) Type) : @separated_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (uniform_space.{0} (cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_13929 (h0 : functor.comp ring semigroup name) : @strong_rank_condition.{0} (semigroup.{0} name) (@functor.comp.run.{0 0 0} ring.{0} semigroup.{0} name h0)  := sorry --non-trivial
lemma new_lemma_13930 (h0 : function.extfun Type topological_space) : @t0_space.{0} (finset.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_13931 (h0 : function.extfun Type ring) : @rank_condition.{0} (as_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (as_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_13932 (h0 : function.extfun (Type 1) monoid) : @monoid.fg.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} h0 (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_13933 (h0 : functor.add_const (group (complete_distrib_lattice Type)) pos) : @is_simple_group.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (complete_distrib_lattice.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_13934 (h0 : complete_lattice (preorder congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (preorder congr_arg_kind) := sorry --non-trivial
lemma new_lemma_13935 (h0 : functor.add_const (topological_space (option num)) congr_arg_kind) : @totally_separated_space.{0} (option.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_13936 (h0 : functor.add_const (topological_space (comm_group pos)) ennreal) : @totally_separated_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_13937 (h0 : topological_space (with_one (has_ssubset (has_top (has_ssubset to_additive.value_type))))) : locally_compact_space (with_one (has_ssubset (has_top (has_ssubset to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_13938 (h0 : function.extfun Type (functor.add_const (group (finset ennreal)))) : @is_cyclic.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} ennreal)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (finset.{0} ennreal))) h0 num))  := sorry --non-trivial
lemma new_lemma_13939 (h0 : topological_space (has_ssubset (has_nnnorm (has_nnnorm linarith.comp_source)))) : path_connected_space (has_ssubset (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_13940 (h0 : functor.add_const (ordered_add_comm_monoid (has_Inf (ring Type))) Type) : @archimedean.{1} (has_Inf.{1} (ring.{1} Type)) (@functor.add_const.run.{1 1} (ordered_add_comm_monoid.{1} (has_Inf.{1} (ring.{1} Type))) Type h0)  := sorry --non-trivial
lemma new_lemma_13941 (h0 : functor.add_const (filter (semigroup linarith.comp)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_13942 (h0 : group (has_Inf (has_pos_part (has_add (has_add pos))))) : is_cyclic (has_Inf (has_pos_part (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_13943 (h0 : functor.add_const (filter (canonically_linear_ordered_monoid name)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_13944 (h0 : functor.add_const (topological_space (ordered_comm_monoid name)) name) : @t0_space.{0} (ordered_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_13945 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (simple_graph pos)) := sorry --non-trivial
lemma new_lemma_13946 (h0 : functor.add_const (group (has_pos_part name)) real) : @group.fg.{0} (has_pos_part.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_pos_part.{0} name)) real h0)  := sorry --non-trivial
lemma new_lemma_13947 (h0 : ring (has_ssubset (metric_space char))) : is_domain (has_ssubset (metric_space char)) := sorry --non-trivial
lemma new_lemma_13948 (h0 : not (group (has_add linarith.ineq) -> false)) : @is_cyclic.{0} (has_add.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (has_add.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_13949 (h0 : topological_space (has_compl (random_gen to_additive.value_type))) : t0_space (has_compl (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_13950 (h0 : has_mem.mem (linear_ordered_semiring congr_arg_kind) has_emptyc.emptyc) : @irreducible_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_13951 (h0 : topological_space (comm_ring (mul_one_class (has_lt to_additive.value_type)))) : totally_disconnected_space (comm_ring (mul_one_class (has_lt to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_13952 (h0 : topological_space (linear_ordered_field (option num))) : discrete_topology (linear_ordered_field (option num)) := sorry --non-trivial
lemma new_lemma_13953 (h0 : topological_space (has_neg_part (comm_group Type))) : t1_space (has_neg_part (comm_group Type)) := sorry --non-trivial
lemma new_lemma_13954 (h0 : set (has_le (mul_one_class (mul_one_class (mul_one_class enat))))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_13955 (h0 : filter (has_neg (comm_group Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_13956 (h0 : topological_space (simple_graph (has_add pos))) : discrete_topology (simple_graph (has_add pos)) := sorry --non-trivial
lemma new_lemma_13957 (h0 : function.extfun Type group) : @normalizer_condition.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_13958 (h0 : topological_space (normed_comm_ring Type)) : locally_compact_space (normed_comm_ring Type) := sorry --non-trivial
lemma new_lemma_13959 (h0 : monoid (finset (has_add (add_comm_monoid name)))) : monoid.fg (finset (has_add (add_comm_monoid name))) := sorry --non-trivial
lemma new_lemma_13960 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (add_left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_13961 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} h0 (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_13962 (h0 : fin has_zero.zero) : @strong_rank_condition.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_13963 (h0 : functor.add_const (function.extfun (Type 1) filter) pos) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (has_neg Type)) := sorry --non-trivial
lemma new_lemma_13964 (h0 : topological_space (canonically_ordered_comm_semiring ennreal)) : preconnected_space (canonically_ordered_comm_semiring ennreal) := sorry --non-trivial
lemma new_lemma_13965 (h0 : functor.add_const (topological_space (comm_group pos)) Type) : @totally_separated_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_13966 (h0 : uniform_space (has_star (semiring unsigned))) : separated_space (has_star (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_13967 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_inner.{0 0} unsigned unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inner.{0 0} unsigned unsigned))  := sorry --non-trivial
lemma new_lemma_13968 (h0 : topological_space (mul_one_class (add_comm_semigroup char))) : t0_space (mul_one_class (add_comm_semigroup char)) := sorry --non-trivial
lemma new_lemma_13969 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) linarith.comp) : @t1_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_13970 (h0 : functor.add_const (semiring (boolean_algebra pos)) (has_neg (has_neg (has_neg Type)))) : @is_noetherian_ring.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (semiring.{0} (boolean_algebra.{0} pos)) (has_neg.{1} (has_neg.{1} (has_neg.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_13971 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) Type) : @totally_separated_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (add_cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_13972 (h0 : add_monoid (has_norm (semiring num))) : add_monoid.fg (has_norm (semiring num)) := sorry --non-trivial
lemma new_lemma_13973 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (canonically_ordered_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_13974 (h0 : topological_space (has_neg (option (option unsigned)))) : preirreducible_space (has_neg (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_13975 (h0 : list (dlist (has_nnnorm (random_gen linarith.ineq)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_13976 (h0 : functor.add_const (topological_space (has_Inf name)) pos) : @totally_separated_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_13977 (h0 : ring (plift (metric_space string_imp))) : rank_condition (plift (metric_space string_imp)) := sorry --non-trivial
lemma new_lemma_13978 (h0 : functor.add_const (function.extfun Type uniform_space) linarith.comp) : @separated_space.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) linarith.comp h0) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_13979 (h0 : topological_space (boolean_algebra (has_add (has_add (has_neg (has_add (finset linarith.comp))))))) : t0_space (boolean_algebra (has_add (has_add (has_neg (has_add (finset linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_13980 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_13981 (h0 : functor.add_const (topological_space (preorder num)) num) : @totally_disconnected_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_13982 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_13983 (h0 : std_gen -> std_gen -> Prop) (h1 : list std_gen) : list.chain' h0 h1 := sorry --non-trivial
lemma new_lemma_13984 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_13985 (h0 : functor.add_const (finset (semigroup name)) (finset environment.implicit_infer_kind)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_13986 (h0 : group (add_group string_imp)) : group.fg (add_group string_imp) := sorry --non-trivial
lemma new_lemma_13987 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (ordered_comm_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_13988 (h0 : topological_space (has_pos_part (ring name))) : topological_space.separable_space (has_pos_part (ring name)) := sorry --non-trivial
lemma new_lemma_13989 (h0 : group (non_assoc_semiring (semiring (semiring unsigned)))) : group.fg (non_assoc_semiring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_13990 (h0 : functor.add_const (finset (has_edist unsigned)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_13991 (h0 : set (set std_gen)) : is_pi_system h0 := sorry --non-trivial
lemma new_lemma_13992 (h0 : add_monoid (option num)) : add_monoid.fg (option num) := sorry --non-trivial
lemma new_lemma_13993 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (encodable.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (encodable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_13994 (h0 : complete_lattice (semi_normed_comm_ring (mul_one_class linarith.ineq))) : complete_lattice.is_Sup_finite_compact (semi_normed_comm_ring (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_13995 (h0 : ring (ring (option (option ennreal)))) : rank_condition (ring (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_13996 (h0 : function.extfun Type topological_space) : irreducible_space real := sorry --non-trivial
lemma new_lemma_13997 (h0 : function.extfun Type group) : @group.fg.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_13998 (h0 : functor.comp topological_space boolean_algebra name) : @t0_space.{0} (boolean_algebra.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.{0} name h0)  := sorry --non-trivial
lemma new_lemma_13999 (h0 : cancel_comm_monoid_with_zero (has_to_string (normed_linear_ordered_group Type))) : unique_factorization_monoid (has_to_string (normed_linear_ordered_group Type)) := sorry --non-trivial
lemma new_lemma_14000 (h0 : topological_space (normed_comm_ring (has_add linarith.comp))) : t1_space (normed_comm_ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_14001 (h0 : list (has_inv (random_gen (has_top (has_top (has_top linarith.ineq)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_14002 (h0 : functor.add_const (finset (cancel_monoid environment.implicit_infer_kind)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_14003 (h0 : ring (has_append (has_nnnorm (comm_ring (has_nnnorm to_additive.value_type))))) : is_domain (has_append (has_nnnorm (comm_ring (has_nnnorm to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_14004 (h0 : cancel_comm_monoid_with_zero (linear_order (option unsigned))) : unique_factorization_monoid (linear_order (option unsigned)) := sorry --non-trivial
lemma new_lemma_14005 (h0 : group (ordered_cancel_add_comm_monoid congr_arg_kind)) : normalizer_condition (ordered_cancel_add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_14006 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_14007 (h0 : add_monoid (has_add (has_add (option name)))) : add_monoid.fg (has_add (has_add (option name))) := sorry --non-trivial
lemma new_lemma_14008 (h0 : complete_lattice (has_add (has_pos_part pos))) : complete_lattice.is_Sup_finite_compact (has_add (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_14009 (h0 : ring (linear_ordered_semiring (has_norm (has_norm num)))) : is_domain (linear_ordered_semiring (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_14010 (h0 : semiring (monoid (option (option empty)))) : is_noetherian_ring (monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_14011 (h0 : function.extfun (Type 1) topological_space) : @totally_separated_space.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_14012 (h0 : group (boolean_algebra.core (comm_group Type))) : is_simple_group (boolean_algebra.core (comm_group Type)) := sorry --non-trivial
lemma new_lemma_14013 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @strong_rank_condition.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_14014 (h0 : ring (random_gen (has_nnnorm linarith.ineq))) : rank_condition (random_gen (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_14015 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc linarith.ineq))) : @path_connected_space.{0} (has_emptyc.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} linarith.ineq)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_14016 (h0 : topological_space (add_left_cancel_semigroup congr_arg_kind)) : t1_space (add_left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_14017 (h0 : ring (normed_comm_ring (has_add (finset (has_to_string (has_add (finset pos))))))) : rank_condition (normed_comm_ring (has_add (finset (has_to_string (has_add (finset pos)))))) := sorry --non-trivial
lemma new_lemma_14018 (h0 : uniform_space (simple_graph (mul_one_class linarith.ineq))) : complete_space (simple_graph (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_14019 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (cancel_monoid.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_14020 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @strong_rank_condition.{0} linarith.comp (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) linarith.comp)  := sorry --non-trivial
lemma new_lemma_14021 (h0 : functor.add_const (group (simple_graph pos)) name) : @group.fg.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (simple_graph.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_14022 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (dlist linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_14023 (h0 : ring (has_ssubset (mul_one_class (mul_one_class reducibility_hints)))) : rank_condition (has_ssubset (mul_one_class (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_14024 (h0 : function.extfun nat fin) : @regular_space.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_14025 (h0 : functor.add_const (group (ordered_ring unsigned)) unsigned) : @is_cyclic.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (ordered_ring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_14026 (h0 : topological_space (has_add (option pos))) : totally_disconnected_space (has_add (option pos)) := sorry --non-trivial
lemma new_lemma_14027 (h0 : add_group (has_le (mul_one_class string.iterator_imp))) : is_add_cyclic (has_le (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_14028 (h0 : uniform_space (has_Sup (option (option empty)))) : separated_space (has_Sup (option (option empty))) := sorry --non-trivial
lemma new_lemma_14029 (h0 : add_group (has_to_string name)) : is_add_cyclic (has_to_string name) := sorry --non-trivial
lemma new_lemma_14030 (h0 : add_monoid (comm_semigroup (sub_neg_monoid (has_bot (has_add pos))))) : add_monoid.fg (comm_semigroup (sub_neg_monoid (has_bot (has_add pos)))) := sorry --non-trivial
lemma new_lemma_14031 (h0 : function.extfun Type topological_space) : @t1_space.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_14032 (h0 : functor.add_const (ring pos) Type) : @strong_rank_condition.{0} pos (@functor.add_const.run.{0 1} (ring.{0} pos) Type h0)  := sorry --non-trivial
lemma new_lemma_14033 (h0 : functor.add_const (cancel_comm_monoid_with_zero (sub_neg_monoid linarith.comp)) name) : @unique_factorization_monoid.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (sub_neg_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_14034 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_14035 (h0 : filter (dlist (add_monoid (add_monoid (add_monoid (add_monoid char)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_14036 (h0 : ring (has_to_string (option unsigned))) : is_principal_ideal_ring (has_to_string (option unsigned)) := sorry --non-trivial
lemma new_lemma_14037 (h0 : add_monoid (has_pos_part (ring (has_nndist Type)))) : add_monoid.fg (has_pos_part (ring (has_nndist Type))) := sorry --non-trivial
lemma new_lemma_14038 (h0 : linear_order (option num) -> linear_order (option num) -> Prop) : irreflexive h0 := sorry --non-trivial
lemma new_lemma_14039 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 uniform_space.{0}) (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_14040 (h0 : group (complete_distrib_lattice (finset name))) : is_simple_group (complete_distrib_lattice (finset name)) := sorry --non-trivial
lemma new_lemma_14041 (h0 : add_group (has_append (random_gen char))) : is_add_cyclic (has_append (random_gen char)) := sorry --non-trivial
lemma new_lemma_14042 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) pos) : @preirreducible_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_14043 (h0 : functor.add_const (add_group (normed_comm_ring pos)) (has_add Type)) : @is_add_cyclic.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (add_group.{0} (normed_comm_ring.{0} pos)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_14044 (h0 : functor.add_const (monoid (complete_distrib_lattice Type)) (boolean_algebra (has_add pos))) : @monoid.fg.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (complete_distrib_lattice.{1} Type)) (boolean_algebra.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_14045 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} to_additive.value_type (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_14046 (h0 : topological_space (semigroup (option ennreal))) : locally_compact_space (semigroup (option ennreal)) := sorry --non-trivial
lemma new_lemma_14047 (h0 : topological_space (topological_space (random_gen char))) : totally_disconnected_space (topological_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_14048 (h0 : topological_space (functor.const congr_arg_kind empty)) : discrete_topology (functor.const congr_arg_kind empty) := sorry --non-trivial
lemma new_lemma_14049 (h0 : functor.add_const (ring (boolean_algebra linarith.comp)) linarith.comp) : @rank_condition.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_14050 (h0 : functor.add_const (topological_space (finset linarith.comp)) Type) : @regular_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_14051 (h0 : topological_space (comm_group (sub_neg_monoid Type))) : path_connected_space (comm_group (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_14052 (h0 : function.extfun Type topological_space) : @t0_space.{0} (mul_zero_class.{0} (semiring.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} (semiring.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_14053 (h0 : functor.add_const (ring (generalized_boolean_algebra pos)) Type) : @is_principal_ideal_ring.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (generalized_boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_14054 (h0 : random_gen linarith.ineq -> random_gen linarith.ineq -> Prop) : total h0 := sorry --non-trivial
lemma new_lemma_14055 (h0 : ring (has_union (semiring (semiring empty)))) : rank_condition (has_union (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_14056 (h0 : ordered_comm_monoid (boolean_algebra.core (has_neg_part Type))) : has_exists_mul_of_le (boolean_algebra.core (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_14057 (h0 : not (ring (omega_complete_partial_order fun_info) -> false)) : @strong_rank_condition.{0} (omega_complete_partial_order.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (omega_complete_partial_order.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_14058 (h0 : function.extfun (denumerable linarith.comp_source) (fun (x : denumerable linarith.comp_source), Prop)) : set.nonempty (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_14059 (h0 : ring (add_group (semiring (has_top congr_arg_kind)))) : strong_rank_condition (add_group (semiring (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_14060 (h0 : topological_space (encodable (random_gen to_additive.value_type))) : path_connected_space (encodable (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_14061 (h0 : fin has_zero.zero) : @is_simple_group.{0} (canonically_linear_ordered_monoid.{0} (has_Inf.{0} real)) (@matrix.vec_empty.{0} (group.{0} (canonically_linear_ordered_monoid.{0} (has_Inf.{0} real))) h0)  := sorry --non-trivial
lemma new_lemma_14062 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_14063 (h0 : topological_space (add_comm_monoid (has_add name))) : totally_separated_space (add_comm_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_14064 (h0 : functor.add_const (add_group (monoid empty)) empty) : @is_add_cyclic.{0} (monoid.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_14065 (h0 : topological_space (pseudo_metric_space (option ennreal))) : t0_space (pseudo_metric_space (option ennreal)) := sorry --non-trivial
lemma new_lemma_14066 (h0 : finset (comm_group (add_cancel_monoid pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_14067 (h0 : functor.add_const (topological_space (add_semigroup empty)) empty) : @t1_space.{0} (add_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_14068 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_14069 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @complete_lattice.is_Sup_finite_compact.{1} Type (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) Type)  := sorry --non-trivial
lemma new_lemma_14070 (h0 : cancel_comm_monoid_with_zero (add_right_cancel_monoid (has_top empty))) : unique_factorization_monoid (add_right_cancel_monoid (has_top empty)) := sorry --non-trivial
lemma new_lemma_14071 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_14072 (h0 : function.extfun nat fin) : @is_principal_ideal_ring.{1} (has_Inf.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (has_Inf.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_14073 (h0 : not (complete_lattice (conditionally_complete_linear_order unsigned) -> false)) : @is_compactly_generated.{0} (conditionally_complete_linear_order.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (conditionally_complete_linear_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_14074 (h0 : functor.add_const (list (add_comm_monoid linarith.comp)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_14075 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_14076 (h0 : fin has_zero.zero) : @regular_space.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_14077 (h0 : add_monoid (monoid (option (option empty)))) : add_monoid.fg (monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_14078 (h0 : functor.add_const (uniform_space (option num)) num) : @complete_space.{0} (option.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (option.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_14079 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_14080 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_top.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_14081 (h0 : complete_lattice (has_top fun_info)) : is_atomistic (has_top fun_info) := sorry --non-trivial
lemma new_lemma_14082 (h0 : add_group string_imp) : is_add_cyclic string_imp := sorry --non-trivial
lemma new_lemma_14083 (h0 : filter (has_to_string (has_add pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_14084 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_14085 (h0 : functor.add_const (topological_space (left_cancel_semigroup unsigned)) empty) : @irreducible_space.{0} (left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_14086 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (option.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (option.{0} num))  := sorry --non-trivial
lemma new_lemma_14087 (h0 : functor.add_const (add_monoid (add_comm_monoid Type)) environment.implicit_infer_kind) : @add_monoid.fg.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (add_comm_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_14088 (h0 : topological_space (has_top (random_gen linarith.ineq))) : t0_space (has_top (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_14089 (h0 : functor.add_const (function.extfun Type ring) environment.implicit_infer_kind) : @rank_condition.{0} (has_neg.{0} (has_add.{0} (normed_comm_ring.{0} (boolean_algebra.{0} (finset.{0} pos))))) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) environment.implicit_infer_kind h0) (has_neg.{0} (has_add.{0} (normed_comm_ring.{0} (boolean_algebra.{0} (finset.{0} pos))))))  := sorry --non-trivial
lemma new_lemma_14090 (h0 : has_lift fun_info (topological_space (normed_group (denumerable fun_info)))) (h1 : fun_info) : @irreducible_space.{0} (normed_group.{0} (denumerable.{0} fun_info)) (@lift.{1 1} fun_info (topological_space.{0} (normed_group.{0} (denumerable.{0} fun_info))) h0 h1)  := sorry --non-trivial
lemma new_lemma_14091 (h0 : topological_space (has_union (has_norm (semiring linarith.comp)))) : preirreducible_space (has_union (has_norm (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_14092 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_14093 (h0 : topological_space (with_zero (has_nnnorm fun_info))) : totally_disconnected_space (with_zero (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_14094 (h1 : monoid (random_gen string_imp)) : monoid.fg (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_14095 (h0 : functor.add_const (add_monoid (has_to_string Type)) (has_to_string (has_to_string linarith.comp))) : @add_monoid.fg.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (has_to_string.{1} Type)) (has_to_string.{0} (has_to_string.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_14096 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @t1_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_14097 (h0 : topological_space std_gen) : connected_space std_gen := sorry --non-trivial
lemma new_lemma_14098 (h0 : functor.add_const (complete_lattice (ordered_cancel_add_comm_monoid empty)) congr_arg_kind) : @is_compactly_generated.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_cancel_add_comm_monoid.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_14099 (h0 : ring (topological_space (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) : is_domain (topological_space (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_14100 (h0 : list (semigroup num)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_14101 (h0 : topological_space (add_right_cancel_monoid congr_arg_kind)) : topological_space.separable_space (add_right_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_14102 (h0 : topological_space (has_emptyc (with_bot string_imp))) : t0_space (has_emptyc (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_14103 (h0 : topological_space (has_union empty)) : path_connected_space (has_union empty) := sorry --non-trivial
lemma new_lemma_14104 (h0 : functor.add_const (functor.add_const (function.extfun Type measurable_space) pos) Type) (h1 : functor.add_const (has_div linarith.comp) Type) : @has_measurable_div₂.{0} linarith.comp (@function.extfun_app.{2 1} Type measurable_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type measurable_space.{0}) pos (@functor.add_const.run.{1 1} (functor.add_const.{1 0} (function.extfun.{2 1} Type measurable_space.{0}) pos) Type h0)) linarith.comp) (@functor.add_const.run.{0 1} (has_div.{0} linarith.comp) Type h1)  := sorry --non-trivial
lemma new_lemma_14105 (h0 : topological_space (with_bot (semiring (has_top congr_arg_kind)))) : normal_space (with_bot (semiring (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_14106 (h0 : ring (semigroup (option pos))) : is_domain (semigroup (option pos)) := sorry --non-trivial
lemma new_lemma_14107 (h1 : complete_lattice (has_nnnorm to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (has_nnnorm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_14108 (h0 : functor.add_const (topological_space (has_add linarith.comp)) name) : @preconnected_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_14109 (h0 : topological_space (finset Type)) : irreducible_space (finset Type) := sorry --non-trivial
lemma new_lemma_14110 (h0 : topological_space (partial_order congr_arg_kind)) : t0_space (partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_14111 (h0 : ordered_comm_monoid (has_zero (has_add unsigned))) : has_exists_mul_of_le (has_zero (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_14112 (h0 : not (filter (non_assoc_semiring congr_arg_kind) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_14113 (h0 : measurable_space (normed_field (mul_one_class linarith.ineq))) (h1 : measure_theory.measure (normed_field (mul_one_class linarith.ineq))) : measure_theory.has_no_atoms h1 := sorry --non-trivial
lemma new_lemma_14114 (h0 : filter (preorder empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_14115 (h0 : topological_space (canonically_ordered_monoid (has_Inf linarith.comp))) : totally_separated_space (canonically_ordered_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_14116 (h1 : char -> complete_lattice (mul_one_class std_gen)) (h2 : unit) (h3 : char) : @complete_lattice.is_Sup_finite_compact.{0} (mul_one_class.{0} std_gen) (@matrix.row.{0 0} char (complete_lattice.{0} (mul_one_class.{0} std_gen)) h1 h2 h3)  := sorry --non-trivial
lemma new_lemma_14117 (h0 : not (topological_space (non_assoc_semiring num) -> false)) : @discrete_topology.{0} (non_assoc_semiring.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (non_assoc_semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_14118 (h0 : topological_space (has_emptyc linarith.ineq)) : totally_separated_space (has_emptyc linarith.ineq) := sorry --non-trivial
lemma new_lemma_14119 (h0 : filter (add_left_cancel_monoid string_imp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_14120 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_14121 (h0 : add_group (linear_ordered_semiring (has_norm num))) : is_add_cyclic (linear_ordered_semiring (has_norm num)) := sorry --non-trivial
lemma new_lemma_14122 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_14123 (h0 : functor.add_const Prop (cancel_monoid environment.implicit_infer_kind)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_14124 (h0 : uniform_space (ordered_comm_group empty)) : complete_space (ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_14125 (h0 : topological_space (has_neg_part (comm_group ennreal))) : loc_path_connected_space (has_neg_part (comm_group ennreal)) := sorry --non-trivial
lemma new_lemma_14126 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_dist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_dist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_14127 (h0 : cancel_comm_monoid_with_zero (has_top congr_arg_kind)) : unique_factorization_monoid (has_top congr_arg_kind) := sorry --non-trivial
lemma new_lemma_14128 (h0 : filter (mul_zero_class (finset unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_14129 (h0 : topological_space (uniform_space (mul_one_class to_additive.value_type))) : t0_space (uniform_space (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_14130 (h3 : set (add_comm_semigroup (add_comm_semigroup (mul_one_class (mul_one_class string.iterator_imp))) -> enat)) : set.separates_points h3 := sorry --non-trivial
lemma new_lemma_14131 (h0 : functor.add_const (ring (cancel_monoid empty)) unsigned) : @is_principal_ideal_ring.{0} (cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (cancel_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_14132 (h0 : function.extfun Type topological_space) : @t0_space.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_14133 (h0 : topological_space (linear_ordered_comm_group_with_zero fun_info)) : t0_space (linear_ordered_comm_group_with_zero fun_info) := sorry --non-trivial
lemma new_lemma_14134 (h0 : topological_space (ordered_comm_ring (has_neg (has_add (ring (has_neg linarith.comp)))))) : irreducible_space (ordered_comm_ring (has_neg (has_add (ring (has_neg linarith.comp))))) := sorry --non-trivial
lemma new_lemma_14135 (h0 : topological_space (dlist (has_norm to_additive.value_type))) : totally_disconnected_space (dlist (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_14136 (h0 : not (ring (has_div linarith.ineq) -> false)) : @is_domain.{0} (has_div.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (has_div.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_14137 (h0 : functor.add_const (topological_space (add_comm_monoid name)) (boolean_algebra pos)) : @preirreducible_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) (boolean_algebra.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_14138 (h0 : functor.add_const (topological_space (semigroup name)) name) : @preconnected_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_14139 (h0 : topological_space linarith.comp_source) : totally_disconnected_space linarith.comp_source := sorry --non-trivial
lemma new_lemma_14140 (h1 : add_group (topological_space (ordered_semiring to_additive.value_type))) : is_add_cyclic (topological_space (ordered_semiring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_14141 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) (has_pos_part Type)) : @regular_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} linarith.comp)) (has_pos_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_14142 (h0 : group (has_inv (random_gen (random_gen to_additive.value_type)))) : is_cyclic (has_inv (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_14143 (h0 : list (has_Inf (has_Inf (has_neg (has_neg Type))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_14144 (h0 : ring (has_pos_part name)) : strong_rank_condition (has_pos_part name) := sorry --non-trivial
lemma new_lemma_14145 (h0 : not (complete_lattice (semi_normed_comm_ring char) -> false)) : @is_compactly_generated.{0} (semi_normed_comm_ring.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semi_normed_comm_ring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_14146 (h3 : add_group (has_nnnorm linarith.comp_source)) : is_add_cyclic (has_nnnorm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_14147 (h0 : fin has_zero.zero) : @rank_condition.{0} (complete_distrib_lattice.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (complete_distrib_lattice.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_14148 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (preorder num)) := sorry --non-trivial
lemma new_lemma_14149 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_14150 (h1 : function.extfun Type monoid) : @monoid.fg.{0} (measurable_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} h1 (measurable_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_14151 (h0 : functor.add_const (add_monoid (has_to_string Type)) environment.implicit_infer_kind) : @add_monoid.fg.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (has_to_string.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_14152 (h0 : functor.add_const (finset (preorder num)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_14153 (h0 : ring (fintype (has_nnnorm linarith.comp_source))) : is_domain (fintype (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_14154 (h0 : ring (has_sub unsigned)) : strong_rank_condition (has_sub unsigned) := sorry --non-trivial
lemma new_lemma_14155 (h0 : functor.add_const (complete_lattice (normed_comm_ring pos)) Type) : @is_atomistic.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (normed_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_14156 (h0 : not (add_monoid (with_one empty) -> false)) : @add_monoid.fg.{0} (with_one.{0} empty) (@classical.by_contradiction'.{1} (add_monoid.{0} (with_one.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_14157 (h0 : ring (id (semiring (semiring unsigned)))) : is_domain (id (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_14158 (h0 : functor.comp group add_comm_monoid unsigned) : @is_simple_group.{0} (add_comm_monoid.{0} unsigned) (@functor.comp.run.{0 0 0} group.{0} add_comm_monoid.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_14159 (h0 : functor.add_const (cancel_comm_monoid_with_zero (finset linarith.comp)) linarith.comp) : @unique_factorization_monoid.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (finset.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_14160 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_14161 (h0 : filter (has_ssubset (add_left_cancel_monoid (has_nnnorm fun_info)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_14162 (h0 : not (topological_space (complete_semilattice_Sup to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_14163 (h0 : function.extfun Type ring) : @is_domain.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_14164 (h0 : topological_space (has_neg_part (option ennreal))) : topological_space.separable_space (has_neg_part (option ennreal)) := sorry --non-trivial
lemma new_lemma_14165 (h0 : topological_space (boolean_algebra (has_Inf pos))) : locally_compact_space (boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_14166 (h0 : function.extfun Type group) : @is_simple_group.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_14167 (h0 : uniform_space (uniform_space (mul_one_class (mul_one_class (mul_one_class char))))) : complete_space (uniform_space (mul_one_class (mul_one_class (mul_one_class char)))) := sorry --non-trivial
lemma new_lemma_14168 (h0 : functor.add_const (list (plift empty)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_14169 (h0 : topological_space (ring (has_add unsigned))) : preirreducible_space (ring (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_14170 (h0 : measurable_space (normed_field linarith.ineq)) (h1 : filter (normed_field linarith.ineq)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_14171 (h0 : not (group (plift num) -> false)) : @group.fg.{1} (plift.{1} num) (@classical.by_contradiction'.{2} (group.{1} (plift.{1} num)) h0)  := sorry --non-trivial
lemma new_lemma_14172 (h0 : prod (partial_order (option (has_star unsigned))) (partial_order (option (has_star unsigned)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_14173 (h0 : function.extfun (Type 1) topological_space) : @irreducible_space.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_14174 (h0 : functor.add_const (topological_space (cancel_monoid name)) environment.implicit_infer_kind) : @regular_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_14175 (h3 : ring fun_info) : strong_rank_condition fun_info := sorry --non-trivial
lemma new_lemma_14176 (h0 : functor.add_const (topological_space (ring Type)) name) : @normal_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_14177 (h0 : functor.add_const (topological_space (has_add unsigned)) pos) : @irreducible_space.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_14178 (h0 : functor.add_const (topological_space (boolean_algebra pos)) real) : @t1_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_14179 (h0 : uniform_space (normed_lattice_add_comm_group (has_Inf (has_add (has_add (has_pos_part pos)))))) : complete_space (normed_lattice_add_comm_group (has_Inf (has_add (has_add (has_pos_part pos))))) := sorry --non-trivial
lemma new_lemma_14180 (h0 : topological_space (semigroup num)) : t0_space (semigroup num) := sorry --non-trivial
lemma new_lemma_14181 (h1 : uniform_space (semi_normed_comm_ring (comm_ring fun_info))) : complete_space (semi_normed_comm_ring (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_14182 (h0 : function.extfun nat fin) : @is_noetherian_ring.{0} (ordered_comm_ring.{0} name) (@matrix.vec_empty.{0} (semiring.{0} (ordered_comm_ring.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_14183 (h0 : functor.add_const (ordered_comm_monoid (semigroup name)) (finset name)) : @has_exists_mul_of_le.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (semigroup.{0} name)) (finset.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_14184 (h0 : fin has_zero.zero) : @irreducible_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_14185 (h0 : functor.add_const Prop (has_to_string (ring (has_to_string (has_to_string Type))))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_14186 (h1 : function.extfun Type add_group) : @is_add_cyclic.{0} empty (@function.extfun_app.{2 1} Type add_group.{0} h1 empty)  := sorry --non-trivial
lemma new_lemma_14187 (h0 : uniform_space (has_nnnorm (mul_one_class reducibility_hints))) : complete_space (has_nnnorm (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_14188 (h0 : ring (emetric_space (semiring unsigned))) : is_principal_ideal_ring (emetric_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_14189 (h0 : topological_space (add_comm_monoid (comm_semigroup real))) : loc_path_connected_space (add_comm_monoid (comm_semigroup real)) := sorry --non-trivial
lemma new_lemma_14190 (h0 : not (topological_space (measurable_space empty) -> false)) : @preirreducible_space.{0} (measurable_space.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_14191 (h0 : functor.add_const (topological_space (group_with_zero congr_arg_kind)) num) : @preconnected_space.{0} (group_with_zero.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (group_with_zero.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_14192 (h0 : functor.add_const (add_monoid (free_add_monoid congr_arg_kind)) empty) : add_monoid.fg (free_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_14193 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_14194 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_14195 (h0 : topological_space (has_append fun_info)) (h1 : preorder (has_append fun_info)) : order_topology (has_append fun_info) := sorry --non-trivial
lemma new_lemma_14196 (h0 : topological_space (has_neg (finset (finset (finset pos))))) : t0_space (has_neg (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_14197 (h0 : function.extfun Type (functor.add_const (semiring znum))) : @is_noetherian_ring.{0} znum (@functor.add_const.run.{0 0} (semiring.{0} znum) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (semiring.{0} znum)) h0 empty))  := sorry --non-trivial
lemma new_lemma_14198 (h0 : group (simple_graph (has_nndist (ring (has_nndist Type))))) : is_cyclic (simple_graph (has_nndist (ring (has_nndist Type)))) := sorry --non-trivial
lemma new_lemma_14199 (h0 : add_monoid (semigroup (comm_group name))) : add_monoid.fg (semigroup (comm_group name)) := sorry --non-trivial
lemma new_lemma_14200 (h0 : functor.add_const (list (preorder empty)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_14201 (h0 : functor.add_const (uniform_space (complete_distrib_lattice linarith.comp)) Type) : @complete_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (complete_distrib_lattice.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_14202 (h0 : ring (sub_neg_monoid pos)) : strong_rank_condition (sub_neg_monoid pos) := sorry --non-trivial
lemma new_lemma_14203 (h0 : ring linarith.ineq) : is_domain linarith.ineq := sorry --non-trivial
lemma new_lemma_14204 (h0 : has_mem.mem (id num) has_emptyc.emptyc) : filter.ne_bot (finset.pi.empty filter (id num) h0) := sorry --non-trivial
lemma new_lemma_14205 (h0 : topological_space (has_pos_part (finset linarith.comp))) : sequential_space (has_pos_part (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_14206 (h0 : topological_space (linear_ordered_comm_monoid_with_zero (semiring (semiring (semiring empty))))) : t1_space (linear_ordered_comm_monoid_with_zero (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_14207 (h2 : set (std_gen -> fun_info)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_14208 (h0 : group (random_gen linarith.ineq)) : is_cyclic (random_gen linarith.ineq) := sorry --non-trivial
lemma new_lemma_14209 (h0 : add_monoid (has_top (semiring congr_arg_kind))) : add_monoid.fg (has_top (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_14210 (h0 : functor.add_const Prop (has_neg (has_neg unsigned))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_14211 (h0 : topological_space (comm_group (finset environment.implicit_infer_kind))) : regular_space (comm_group (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_14212 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) linarith.comp) : @preconnected_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_14213 (h0 : not (cancel_comm_monoid_with_zero (measurable_space.dynkin_system unsigned) -> false)) : @unique_factorization_monoid.{0} (measurable_space.dynkin_system.{0} unsigned) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (measurable_space.dynkin_system.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_14214 (h0 : complete_lattice (has_one (semiring (semiring (has_top (has_top fun_info)))))) : is_compactly_generated (has_one (semiring (semiring (has_top (has_top fun_info))))) := sorry --non-trivial
lemma new_lemma_14215 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (sub_neg_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_14216 (h0 : functor.add_const (add_group (has_zero pos)) environment.implicit_infer_kind) : @is_add_cyclic.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_zero.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_14217 (h0 : functor.add_const (cancel_comm_monoid_with_zero (normed_comm_ring Type)) name) : @unique_factorization_monoid.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (normed_comm_ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_14218 (h1 : ring (has_top (random_gen string_imp))) : strong_rank_condition (has_top (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_14219 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_14220 (h0 : ring (boolean_algebra.core (ring (ring (has_Inf (has_add name)))))) : strong_rank_condition (boolean_algebra.core (ring (ring (has_Inf (has_add name))))) := sorry --non-trivial
lemma new_lemma_14221 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preirreducible_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_14222 (h0 : not (topological_space (has_compl enat) -> false)) : @totally_disconnected_space.{0} (has_compl.{0} enat) (@classical.by_contradiction'.{1} (topological_space.{0} (has_compl.{0} enat)) h0)  := sorry --non-trivial
lemma new_lemma_14223 (h1 : topological_space (distrib_lattice (distrib (comm_ring fun_info)))) : totally_disconnected_space (distrib_lattice (distrib (comm_ring fun_info))) := sorry --non-trivial
lemma new_lemma_14224 (h0 : functor.add_const (ring linarith.comp) linarith.comp) : @is_principal_ideal_ring.{0} linarith.comp (@functor.add_const.run.{0 0} (ring.{0} linarith.comp) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_14225 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_14226 (h0 : filter (normed_lattice_add_comm_group (has_Inf Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_14227 (h0 : add_group (has_Sup (option empty))) : is_add_cyclic (has_Sup (option empty)) := sorry --non-trivial
lemma new_lemma_14228 (h0 : monoid (add_comm_monoid (has_to_string (has_add unsigned)))) : monoid.fg (add_comm_monoid (has_to_string (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_14229 (h0 : ring (complete_semilattice_Sup (has_norm string_imp))) : is_domain (complete_semilattice_Sup (has_norm string_imp)) := sorry --non-trivial
lemma new_lemma_14230 (h0 : topological_space (with_one (random_gen (has_top num)))) : totally_disconnected_space (with_one (random_gen (has_top num))) := sorry --non-trivial
lemma new_lemma_14231 (h0 : complete_lattice (has_ssubset string.iterator_imp)) : complete_lattice.is_Sup_finite_compact (has_ssubset string.iterator_imp) := sorry --non-trivial
lemma new_lemma_14232 (h0 : set (add_comm_semigroup (add_comm_semigroup fun_info) -> string.iterator_imp)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_14233 (h0 : topological_space (boolean_algebra.core (add_comm_monoid (has_nndist name)))) : preirreducible_space (boolean_algebra.core (add_comm_monoid (has_nndist name))) := sorry --non-trivial
lemma new_lemma_14234 (h0 : functor.add_const (ring (cancel_monoid name)) name) : @strong_rank_condition.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_14235 (h0 : topological_space (has_to_string (finset environment.implicit_infer_kind))) : discrete_topology (has_to_string (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_14236 (h0 : function.extfun nat fin) : @is_compactly_generated.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (generalized_boolean_algebra.{1} Type)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_14237 (h0 : complete_lattice (plift (semiring (semiring (semiring unsigned))))) : is_compactly_generated (plift (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_14238 (h0 : filter (has_top (semiring empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_14239 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_14240 (h0 : complete_lattice (non_unital_non_assoc_semiring (has_ssubset char))) : complete_lattice.is_Sup_finite_compact (non_unital_non_assoc_semiring (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_14241 (h0 : topological_space (canonically_linear_ordered_monoid (measurable_space.dynkin_system (option unsigned)))) : regular_space (canonically_linear_ordered_monoid (measurable_space.dynkin_system (option unsigned))) := sorry --non-trivial
lemma new_lemma_14242 (h0 : complete_lattice (has_ssubset (random_gen to_additive.value_type))) : is_compactly_generated (has_ssubset (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_14243 (h0 : fin has_zero.zero) : @sequential_space.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (complete_distrib_lattice.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_14244 (h0 : group (add_comm_monoid (ring linarith.comp))) : is_simple_group (add_comm_monoid (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_14245 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} pos (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) pos)  := sorry --non-trivial
lemma new_lemma_14246 (h0 : topological_space (comm_ring (has_ssubset (random_gen (has_ssubset fun_info))))) : irreducible_space (comm_ring (has_ssubset (random_gen (has_ssubset fun_info)))) := sorry --non-trivial
lemma new_lemma_14247 (h0 : monoid (boolean_algebra.core name)) : monoid.fg (boolean_algebra.core name) := sorry --non-trivial
lemma new_lemma_14248 (h0 : topological_space (has_dist ennreal)) : totally_disconnected_space (has_dist ennreal) := sorry --non-trivial
lemma new_lemma_14249 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_bot.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type group.{0} h0 (has_bot.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_14250 (h0 : not (topological_space (add_group empty) -> false)) : @t0_space.{0} (add_group.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_14251 (h0 : topological_space (comm_semigroup (has_neg (has_neg (has_bot Type))))) : sequential_space (comm_semigroup (has_neg (has_neg (has_bot Type)))) := sorry --non-trivial
lemma new_lemma_14252 (h0 : uniform_space (has_pos_part (ordered_comm_monoid linarith.comp))) : complete_space (has_pos_part (ordered_comm_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_14253 (h3 : set (std_gen -> enat)) : set.separates_points h3 := sorry --non-trivial
lemma new_lemma_14254 (h0 : ring (simple_graph (has_nnnorm (has_nnnorm linarith.ineq)))) : rank_condition (simple_graph (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_14255 (h0 : functor.add_const (ordered_comm_monoid (has_add Type)) Type) : @has_exists_mul_of_le.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (ordered_comm_monoid.{1} (has_add.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_14256 (h0 : functor.add_const (ordered_add_comm_monoid (cancel_monoid name)) name) : @archimedean.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_14257 (h0 : functor.add_const (ring (has_to_string linarith.comp)) pos) : @is_principal_ideal_ring.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_14258 (h0 : topological_space (has_le environment.projection_info)) : totally_disconnected_space (has_le environment.projection_info) := sorry --non-trivial
lemma new_lemma_14259 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_14260 (h0 : topological_space (add_left_cancel_semigroup congr_arg_kind)) : totally_separated_space (add_left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_14261 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_14262 (h0 : topological_space (is_R_or_C (semiring num))) : t1_space (is_R_or_C (semiring num)) := sorry --non-trivial
lemma new_lemma_14263 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (lex.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (lex.{0} name))  := sorry --non-trivial
lemma new_lemma_14264 (h0 : functor.add_const (ring (cancel_monoid name)) Type) : @strong_rank_condition.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_14265 (h0 : ring (generalized_boolean_algebra (finset Type))) : rank_condition (generalized_boolean_algebra (finset Type)) := sorry --non-trivial
lemma new_lemma_14266 (h0 : topological_space (partial_order unsigned)) : totally_separated_space (partial_order unsigned) := sorry --non-trivial
lemma new_lemma_14267 (h0 : group (add_cancel_monoid (finset (has_pos_part pos)))) : is_cyclic (add_cancel_monoid (finset (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_14268 (h0 : topological_space (normed_comm_ring name)) : regular_space (normed_comm_ring name) := sorry --non-trivial
lemma new_lemma_14269 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_14270 (h0 : functor.add_const (add_group (has_neg name)) environment.implicit_infer_kind) : @is_add_cyclic.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (has_neg.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_14271 (h0 : functor.add_const (ring (has_pos_part pos)) (has_neg (has_neg name))) : @strong_rank_condition.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_pos_part.{0} pos)) (has_neg.{0} (has_neg.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_14272 (h0 : uniform_space (mul_zero_class (boolean_algebra.core name))) : separated_space (mul_zero_class (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_14273 (h0 : topological_space (linear_order (add_left_cancel_semigroup (add_left_cancel_semigroup unsigned)))) : irreducible_space (linear_order (add_left_cancel_semigroup (add_left_cancel_semigroup unsigned))) := sorry --non-trivial
lemma new_lemma_14274 (h0 : not (add_monoid (normed_group empty) -> false)) : @add_monoid.fg.{0} (normed_group.{0} empty) (@classical.by_contradiction'.{1} (add_monoid.{0} (normed_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_14275 (h0 : topological_space (has_neg (finset (finset (has_nndist name))))) : loc_path_connected_space (has_neg (finset (finset (has_nndist name)))) := sorry --non-trivial
lemma new_lemma_14276 (h0 : complete_lattice (cancel_monoid (has_add pos))) : is_atomistic (cancel_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_14277 (h0 : ring (boolean_algebra (has_add (has_add (has_add linarith.comp))))) : rank_condition (boolean_algebra (has_add (has_add (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_14278 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @t1_space.{0} (has_add.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_14279 (h0 : topological_space (random_gen (has_top fun_info))) : totally_disconnected_space (random_gen (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_14280 (h0 : ring (measurable_space (has_top empty))) : strong_rank_condition (measurable_space (has_top empty)) := sorry --non-trivial
lemma new_lemma_14281 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (distrib_lattice.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (distrib_lattice.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_14282 (h0 : function.extfun Type topological_space) : @t0_space.{0} (pseudo_metric_space.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_14283 (h1 : ring (distrib (mul_one_class (mul_one_class (mul_one_class fun_info))))) : rank_condition (distrib (mul_one_class (mul_one_class (mul_one_class fun_info)))) := sorry --non-trivial
lemma new_lemma_14284 (h0 : functor.add_const (monoid (has_zero unsigned)) Type) : @monoid.fg.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 1} (monoid.{0} (has_zero.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_14285 (h0 : functor.add_const (ordered_comm_monoid (has_nndist name)) (has_add environment.implicit_infer_kind)) : @has_exists_mul_of_le.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_nndist.{0} name)) (has_add.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_14286 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_14287 (h0 : semiring (pseudo_metric_space (comm_monoid unsigned))) : is_noetherian_ring (pseudo_metric_space (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_14288 (h0 : functor.add_const (ordered_add_comm_monoid (add_cancel_monoid name)) name) : @archimedean.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_14289 (h0 : functor.add_const (ring (preorder num)) congr_arg_kind) : @is_principal_ideal_ring.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (preorder.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_14290 (h0 : topological_space (topological_space (has_inv to_additive.value_type))) : path_connected_space (topological_space (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_14291 (h0 : topological_space (has_nnnorm fun_info)) (h1 : add_group (has_nnnorm fun_info)) : topological_add_group (has_nnnorm fun_info) := sorry --non-trivial
lemma new_lemma_14292 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_14293 (h0 : functor.add_const (filter (finset Type)) (ring environment.implicit_infer_kind)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_14294 (h0 : list (has_nnnorm (random_gen char))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_14295 (h0 : topological_space (group_with_zero (option (option ennreal)))) : loc_path_connected_space (group_with_zero (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_14296 (h0 : function.extfun Type topological_space) : @t0_space.{0} (encodable.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (encodable.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_14297 (h0 : ring (ordered_comm_monoid (has_neg pos))) : rank_condition (ordered_comm_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_14298 (h0 : functor.add_const (group (semigroup pos)) (has_add Type)) : @is_simple_group.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (semigroup.{0} pos)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_14299 (h1 : complete_lattice (simple_graph linarith.ineq)) : is_compactly_generated (simple_graph linarith.ineq) := sorry --non-trivial
lemma new_lemma_14300 (h0 : function.extfun nat fin) : @normalizer_condition.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (group.{1} (has_bot.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_14301 (h0 : topological_space (ring (has_zero Type))) : path_connected_space (ring (has_zero Type)) := sorry --non-trivial
lemma new_lemma_14302 (h0 : topological_space (semi_normed_comm_ring (has_ssubset (has_ssubset char)))) : path_connected_space (semi_normed_comm_ring (has_ssubset (has_ssubset char))) := sorry --non-trivial
lemma new_lemma_14303 (h0 : topological_space (has_ssubset (random_gen (has_nnnorm fun_info)))) : locally_compact_space (has_ssubset (random_gen (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_14304 (h0 : topological_space (left_cancel_monoid (semiring unsigned))) : loc_path_connected_space (left_cancel_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_14305 (h0 : functor.add_const (topological_space (has_neg pos)) Type) : @locally_compact_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_14306 (h0 : functor.add_const (topological_space (has_nndist name)) name) : @path_connected_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_14307 (h0 : add_monoid (finset ennreal)) : add_monoid.fg (finset ennreal) := sorry --non-trivial
lemma new_lemma_14308 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_14309 (h0 : topological_space (monoid_with_zero pos)) : preirreducible_space (monoid_with_zero pos) := sorry --non-trivial
lemma new_lemma_14310 (h0 : topological_space (normed_group (has_norm (has_union linarith.comp)))) : preirreducible_space (normed_group (has_norm (has_union linarith.comp))) := sorry --non-trivial
lemma new_lemma_14311 (h0 : not (group to_additive.value_type -> false)) : @is_cyclic.{0} to_additive.value_type (@classical.by_contradiction'.{1} (group.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_14312 (h0 : functor.add_const (group (has_star num)) (semiring (semiring (semiring congr_arg_kind)))) : @is_cyclic.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (group.{0} (has_star.{0} num)) (semiring.{0} (semiring.{0} (semiring.{0} congr_arg_kind))) h0)  := sorry --non-trivial
lemma new_lemma_14313 (h0 h1 : multiset (has_div reducibility_hints)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_14314 (h0 : uniform_space (encodable (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source))))) : complete_space (encodable (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_14315 (h0 : list (canonically_ordered_comm_semiring environment.implicit_infer_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_14316 (h0 : function.extfun Type ring) : @rank_condition.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_14317 (h0 : complete_lattice (has_inter num)) : complete_lattice.is_Sup_finite_compact (has_inter num) := sorry --non-trivial
lemma new_lemma_14318 (h0 : functor.add_const (topological_space (has_neg pos)) name) : @locally_compact_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_14319 (h0 : topological_space (normed_lattice_add_comm_group name)) : regular_space (normed_lattice_add_comm_group name) := sorry --non-trivial
lemma new_lemma_14320 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) pos) : @unique_factorization_monoid.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) pos h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_14321 (h0 : has_lt (linear_ordered_comm_group_with_zero enat)) : no_max_order (linear_ordered_comm_group_with_zero enat) := sorry --non-trivial
lemma new_lemma_14322 (h0 : uniform_space (dlist (has_nnnorm fun_info))) : complete_space (dlist (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_14323 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} congr_arg_kind (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_14324 (h0 : topological_space (normed_comm_ring (has_pos_part linarith.comp))) : t1_space (normed_comm_ring (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_14325 (h0 : functor.add_const (complete_lattice (comm_monoid empty)) (option unsigned)) : @is_atomistic.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_monoid.{0} empty)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_14326 (h0 : topological_space (has_lt (mul_one_class (mul_one_class (mul_one_class enat))))) : path_connected_space (has_lt (mul_one_class (mul_one_class (mul_one_class enat)))) := sorry --non-trivial
lemma new_lemma_14327 (h0 : ring (has_nndist (option (option empty)))) : is_domain (has_nndist (option (option empty))) := sorry --non-trivial
lemma new_lemma_14328 (h0 : functor.add_const (group (has_bot empty)) (option empty)) : @normalizer_condition.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (has_bot.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_14329 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) unsigned) : @totally_disconnected_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_14330 (h0 : topological_space (has_to_string (comm_group pos))) : t0_space (has_to_string (comm_group pos)) := sorry --non-trivial
lemma new_lemma_14331 (h0 : fin has_zero.zero) (h1 : ulower (ulower pnat)) : pnat.coprime (matrix.vec_empty h0) (ulower.up (ulower.up h1)) := sorry --non-trivial
lemma new_lemma_14332 (h0 : functor.add_const (ring (add_cancel_monoid unsigned)) (has_neg_part name)) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} unsigned)) (has_neg_part.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_14333 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} name (@function.extfun_app.{2 1} Type topological_space.{0} h0 name)  := sorry --non-trivial
lemma new_lemma_14334 (h0 : topological_space (has_add (has_neg name))) : normal_space (has_add (has_neg name)) := sorry --non-trivial
lemma new_lemma_14335 (h0 : function.extfun (Type 1) topological_space) : @t1_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_14336 (h0 : functor.add_const (uniform_space (linear_ordered_cancel_comm_monoid empty)) (option empty)) : @separated_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_14337 (h0 : topological_space (normed_lattice_add_comm_group (has_add name))) : loc_path_connected_space (normed_lattice_add_comm_group (has_add name)) := sorry --non-trivial
lemma new_lemma_14338 (h0 : functor.add_const (list (has_Inf pos)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_14339 (h0 : not (has_mem.mem (linear_ordered_semiring linarith.comp) has_emptyc.emptyc -> false)) : @is_atomistic.{0} (linear_ordered_semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (linear_ordered_semiring.{0} linarith.comp) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} linarith.comp) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_14340 (h0 : functor.add_const (function.extfun Type semiring) environment.implicit_infer_kind) : @is_noetherian_ring.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) environment.implicit_infer_kind h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_14341 (h0 : ring (distrib (has_nnnorm linarith.ineq))) : rank_condition (distrib (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_14342 (h0 : topological_space (ordered_comm_monoid real)) : loc_path_connected_space (ordered_comm_monoid real) := sorry --non-trivial
lemma new_lemma_14343 (h0 : complete_lattice (add_cancel_monoid (add_comm_monoid Type))) : is_compactly_generated (add_cancel_monoid (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_14344 (h0 : complete_lattice (with_bot char)) : is_compactly_generated (with_bot char) := sorry --non-trivial
lemma new_lemma_14345 (h0 : functor.comp ordered_add_comm_monoid has_add Type) : @archimedean.{1} (has_add.{1} Type) (@functor.comp.run.{1 1 1} ordered_add_comm_monoid.{1} has_add.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_14346 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_14347 (h0 : group (has_add linarith.ineq)) : is_cyclic (has_add linarith.ineq) := sorry --non-trivial
lemma new_lemma_14348 (h0 : function.extfun Type topological_space) : @t0_space.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_14349 (h0 : add_group (complete_distrib_lattice real)) : is_add_cyclic (complete_distrib_lattice real) := sorry --non-trivial
lemma new_lemma_14350 (h0 : ring (has_Sup unsigned)) : strong_rank_condition (has_Sup unsigned) := sorry --non-trivial
lemma new_lemma_14351 (h0 : group (boolean_algebra.core (cancel_monoid name))) : group.fg (boolean_algebra.core (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_14352 (h0 : has_mem.mem (has_top num) has_emptyc.emptyc) : @t0_space.{0} (has_top.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_14353 (h0 : function.extfun (Type 1) (functor.add_const (topological_space pos))) : @loc_path_connected_space.{0} pos (@functor.add_const.run.{0 1} (topological_space.{0} pos) Type (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (topological_space.{0} pos)) h0 Type))  := sorry --non-trivial
lemma new_lemma_14354 (h0 : list (filter Prop)) (h1 : ne h0 list.nil) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@list.last.{0} (filter.{0} Prop) h0 h1)  := sorry --non-trivial
lemma new_lemma_14355 (h0 : topological_space (has_ssubset (random_gen to_additive.value_type))) : locally_compact_space (has_ssubset (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_14356 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (group_with_zero.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} h0 (group_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_14357 (h0 : group (semi_normed_ring (has_nnnorm linarith.comp_source))) : is_cyclic (semi_normed_ring (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_14358 (h0 : functor.add_const (ring (ring pos)) Type) : @is_domain.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_14359 (h0 : topological_space (linear_ordered_semiring (semiring (semiring (semiring congr_arg_kind))))) : locally_compact_space (linear_ordered_semiring (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_14360 (h0 : complete_lattice (semi_normed_comm_ring (random_gen char))) : complete_lattice.is_Sup_finite_compact (semi_normed_comm_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_14361 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_14362 (h3 : add_group (has_append linarith.ineq)) : is_add_cyclic (has_append linarith.ineq) := sorry --non-trivial
lemma new_lemma_14363 (h0 : add_group (option (semiring (semiring (semiring (semiring congr_arg_kind)))))) : is_add_cyclic (option (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_14364 (h0 : monoid (semiring (has_top linarith.comp_source))) : monoid.fg (semiring (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_14365 (h0 : topological_space (has_union (semiring (has_union (random_gen congr_arg_kind))))) : normal_space (has_union (semiring (has_union (random_gen congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_14366 (h0 : functor.add_const (filter (semigroup pos)) (has_add pos)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_14367 (h0 : add_group (normed_field std_gen)) : is_add_cyclic (normed_field std_gen) := sorry --non-trivial
lemma new_lemma_14368 (h0 : function.extfun Type (functor.add_const (add_group (semigroup empty)))) : @is_add_cyclic.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_group.{0} (semigroup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_14369 (h0 : list ennreal) : palindrome h0 := sorry --non-trivial
lemma new_lemma_14370 (h0 : topological_space (has_add (has_add Type))) : path_connected_space (has_add (has_add Type)) := sorry --non-trivial
lemma new_lemma_14371 (h0 : functor.add_const (function.extfun (Type 1) add_group) Type) : @is_add_cyclic.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) add_group.{1}) Type h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_14372 (h0 : function.extfun Type topological_space) : @regular_space.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_14373 (h0 : has_mem.mem empty has_emptyc.emptyc) : @rank_condition.{0} empty (@finset.pi.empty.{1 0} Type ring.{0} empty h0)  := sorry --non-trivial
lemma new_lemma_14374 (h0 : functor.add_const (ring (linear_ordered_comm_monoid_with_zero unsigned)) empty) : @is_principal_ideal_ring.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_14375 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_14376 (h0 : monoid (has_one (semiring (semiring num)))) : monoid.fg (has_one (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_14377 (h0 : topological_space (finset (has_nndist (finset (finset pos))))) : normal_space (finset (has_nndist (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_14378 (h0 : group (linear_ordered_add_comm_group_with_top char)) : is_cyclic (linear_ordered_add_comm_group_with_top char) := sorry --non-trivial
lemma new_lemma_14379 (h0 : finset (normed_group congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_14380 (h0 : monoid (measurable_space (has_inv fun_info))) : monoid.fg (measurable_space (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_14381 (h0 : topological_space (finset (option (option (option (option (option (option (option unsigned))))))))) : discrete_topology (finset (option (option (option (option (option (option (option unsigned)))))))) := sorry --non-trivial
lemma new_lemma_14382 (h0 : add_group (linear_ordered_comm_group_with_zero (mul_one_class reducibility_hints))) : is_add_cyclic (linear_ordered_comm_group_with_zero (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_14383 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) h0) (@has_zero.zero.{0} nat nat.has_zero))) (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_14384 (h0 : functor.add_const (topological_space (normed_comm_ring empty)) ennreal) : @loc_path_connected_space.{0} (normed_comm_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} empty)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_14385 (h0 : group (has_norm (has_norm (semiring fun_info)))) : is_cyclic (has_norm (has_norm (semiring fun_info))) := sorry --non-trivial
lemma new_lemma_14386 (h6 : ring (has_ssubset environment.projection_info)) : is_domain (has_ssubset environment.projection_info) := sorry --non-trivial
lemma new_lemma_14387 (h0 : topological_space (add_right_cancel_monoid (semiring unsigned))) : irreducible_space (add_right_cancel_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_14388 (h0 : not (complete_lattice (has_union num) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_union.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_union.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_14389 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_14390 (h0 : not (complete_lattice (has_star congr_arg_kind) -> false)) : @is_atomistic.{0} (has_star.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_star.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_14391 (h0 h1 h2 : std_gen -> std_gen) : function.semiconj h0 h1 h2 := sorry --non-trivial
lemma new_lemma_14392 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_14393 (h0 : ring (has_nndist linarith.comp)) : rank_condition (has_nndist linarith.comp) := sorry --non-trivial
lemma new_lemma_14394 (h0 : topological_space (has_zero (has_add linarith.comp))) : regular_space (has_zero (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_14395 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) linarith.comp) : @topological_space.separable_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_14396 (h0 : filter (finset (mul_one_class linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_14397 (h1 : complete_lattice (has_union linarith.comp)) : complete_lattice.is_Sup_finite_compact (has_union linarith.comp) := sorry --non-trivial
lemma new_lemma_14398 (h0 : ring (finset (comm_group (has_neg_part (comm_group pos))))) : is_domain (finset (comm_group (has_neg_part (comm_group pos)))) := sorry --non-trivial
lemma new_lemma_14399 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (linear_ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_14400 (h0 : group (mul_zero_class environment.implicit_infer_kind)) : is_cyclic (mul_zero_class environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_14401 (h0 : filter (has_add (has_to_string (has_add pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_14402 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @separated_space.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) uniform_space.{0}) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_14403 (h0 : topological_space (has_top (has_top fun_info))) : t0_space (has_top (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_14404 (h0 : not (complete_lattice (complete_semilattice_Sup linarith.comp) -> false)) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} linarith.comp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (complete_semilattice_Sup.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_14405 (h0 : group (denumerable (random_gen (random_gen reducibility_hints)))) : is_cyclic (denumerable (random_gen (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_14406 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (canonically_linear_ordered_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_14407 (h0 : ring (ring (has_pos_part pos))) : strong_rank_condition (ring (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_14408 (h0 : complete_lattice (with_bot (random_gen to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (with_bot (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_14409 (h0 : list (has_Sup (ordered_ring empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_14410 (h0 : functor.add_const (ordered_comm_monoid (semigroup Type)) name) : @has_exists_mul_of_le.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (semigroup.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_14411 (h0 : group (ordered_comm_group congr_arg_kind)) : is_cyclic (ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_14412 (h0 : functor.add_const (topological_space (has_star num)) congr_arg_kind) : @topological_space.separable_space.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_14413 (h0 : not (uniform_space (with_one linarith.comp_source) -> false)) : @separated_space.{0} (with_one.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (uniform_space.{0} (with_one.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_14414 (h0 : topological_space (has_lt (mul_one_class (mul_one_class char)))) (h1 : has_inf (has_lt (mul_one_class (mul_one_class char)))) : has_continuous_inf (has_lt (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_14415 (h0 : not (add_monoid (non_assoc_semiring empty) -> false)) : @add_monoid.fg.{0} (non_assoc_semiring.{0} empty) (@classical.by_contradiction'.{1} (add_monoid.{0} (non_assoc_semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_14416 (h0 : function.extfun Type (functor.add_const (filter ennreal))) : filter.ne_bot (functor.add_const.run (function.extfun_app h0 ennreal)) := sorry --non-trivial
lemma new_lemma_14417 (h0 : filter (finset (finset name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_14418 (h0 : fun_info -> fun_info -> Prop) : is_order_connected fun_info h0 := sorry --non-trivial
lemma new_lemma_14419 (h0 : ring (random_gen (has_top to_additive.value_type))) : rank_condition (random_gen (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_14420 (h0 : group (comm_group (semigroup Type))) : is_cyclic (comm_group (semigroup Type)) := sorry --non-trivial
lemma new_lemma_14421 (h1 : ring (has_ssubset (has_lt linarith.comp_source))) : strong_rank_condition (has_ssubset (has_lt linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_14422 (h0 : functor.add_const (functor.add_const (uniform_space (non_assoc_semiring empty)) empty) empty) : @separated_space.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (non_assoc_semiring.{0} empty)) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (uniform_space.{0} (non_assoc_semiring.{0} empty)) empty) empty h0))  := sorry --non-trivial
lemma new_lemma_14423 (h0 : topological_space (add_group (has_union linarith.comp))) : preirreducible_space (add_group (has_union linarith.comp)) := sorry --non-trivial
lemma new_lemma_14424 (h0 : topological_space (canonically_ordered_monoid (has_add (has_add real)))) : regular_space (canonically_ordered_monoid (has_add (has_add real))) := sorry --non-trivial
lemma new_lemma_14425 (h0 : finset (add_cancel_monoid (boolean_algebra.core pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_14426 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_14427 (h0 : functor.add_const (functor.add_const (monoid auto.case_option) unsigned) unsigned) : @monoid.fg.{0} auto.case_option (@functor.add_const.run.{0 0} (monoid.{0} auto.case_option) unsigned (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (monoid.{0} auto.case_option) unsigned) unsigned h0))  := sorry --non-trivial
lemma new_lemma_14428 (h0 : topological_space (non_assoc_semiring (option (option unsigned)))) : t1_space (non_assoc_semiring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_14429 (h0 : topological_space (finset (ring (ring (mul_one_class linarith.comp))))) : t0_space (finset (ring (ring (mul_one_class linarith.comp)))) := sorry --non-trivial
lemma new_lemma_14430 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_14431 (h0 : ring (add_monoid (has_subset linarith.comp_source))) : strong_rank_condition (add_monoid (has_subset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_14432 (h0 : topological_space (comm_group (div_inv_monoid unsigned))) : irreducible_space (comm_group (div_inv_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_14433 (h0 : ring (ordered_cancel_add_comm_monoid (option congr_arg_kind))) : is_principal_ideal_ring (ordered_cancel_add_comm_monoid (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_14434 (h0 : functor.add_const (function.extfun (Type 1) ring) Type) : @rank_condition.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) Type h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_14435 (h0 : functor.add_const (topological_space (has_neg unsigned)) pos) : @irreducible_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_14436 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_14437 (h0 : filter (denumerable (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_14438 (h0 : set (has_compl (mul_one_class (has_le linarith.comp_source)))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_14439 (h0 : topological_space (has_neg (finset (finset name)))) : irreducible_space (has_neg (finset (finset name))) := sorry --non-trivial
lemma new_lemma_14440 (h0 : functor.add_const (add_group (has_nndist Type)) linarith.comp) : @is_add_cyclic.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (has_nndist.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_14441 (h0 : fin has_zero.zero) : @separated_space.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_14442 (h0 : functor.add_const (complete_lattice (measurable_space.dynkin_system unsigned)) empty) : @is_compactly_generated.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (measurable_space.dynkin_system.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_14443 (h0 : has_mem.mem (has_one num) has_emptyc.emptyc) : @add_monoid.fg.{0} (has_one.{0} num) (@finset.pi.empty.{1 0} Type add_monoid.{0} (has_one.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_14444 (h0 : uniform_space (normed_lattice_add_comm_group (has_Inf Type))) : separated_space (normed_lattice_add_comm_group (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_14445 (h0 : list (ordered_comm_group unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_14446 (h0 : functor.add_const (topological_space (has_Inf Type)) name) : @t0_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_Inf.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_14447 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_14448 (h0 : function.extfun Type topological_space) : @regular_space.{0} (boolean_algebra.core.{0} (has_Inf.{0} pos)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} (has_Inf.{0} pos)))  := sorry --non-trivial
lemma new_lemma_14449 (h0 : topological_space (comm_semigroup (ordered_comm_monoid pos))) : path_connected_space (comm_semigroup (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_14450 (h0 : functor.add_const (add_group (ring pos)) name) : @is_add_cyclic.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_14451 (h0 : topological_space (has_zero (semigroup (comm_group (comm_group (has_add pos)))))) : preconnected_space (has_zero (semigroup (comm_group (comm_group (has_add pos))))) := sorry --non-trivial
lemma new_lemma_14452 (h0 : functor.add_const (ordered_comm_monoid (normed_comm_ring name)) (has_add (has_add pos))) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (normed_comm_ring.{0} name)) (has_add.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_14453 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (add_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_14454 (h1 : ring (normed_group linarith.comp_source)) : is_domain (normed_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_14455 (h0 : topological_space (non_assoc_semiring (option (option (option empty))))) : loc_path_connected_space (non_assoc_semiring (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_14456 (h0 : complete_lattice (distrib (mul_one_class (mul_one_class fun_info)))) : complete_lattice.is_Sup_finite_compact (distrib (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_14457 (h0 : group (complete_linear_order num)) : normalizer_condition (complete_linear_order num) := sorry --non-trivial
lemma new_lemma_14458 (h0 : uniform_space (ring (has_pos_part (has_Inf (has_Inf pos))))) : complete_space (ring (has_pos_part (has_Inf (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_14459 (h1 : list (id string_imp)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_14460 (h0 : ring (has_to_string pos)) : strong_rank_condition (has_to_string pos) := sorry --non-trivial
lemma new_lemma_14461 (h0 : functor.add_const (group (semigroup linarith.comp)) linarith.comp) : @group.fg.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_14462 (h0 : add_group (has_to_string (finset (has_Inf linarith.comp)))) : is_add_cyclic (has_to_string (finset (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_14463 (h0 : group (non_assoc_semiring (semiring unsigned))) : normalizer_condition (non_assoc_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_14464 (h0 : functor.add_const (cancel_comm_monoid_with_zero (plift unsigned)) empty) : @unique_factorization_monoid.{1} (plift.{1} unsigned) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (plift.{1} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_14465 (h0 : add_monoid (free_add_monoid unsigned)) : add_monoid.fg (free_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_14466 (h0 : functor.add_const (ring (normed_linear_ordered_group congr_arg_kind)) empty) : @rank_condition.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (normed_linear_ordered_group.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_14467 (h0 : topological_space (normed_comm_ring (ring (finset linarith.comp)))) : totally_disconnected_space (normed_comm_ring (ring (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_14468 (h0 : functor.add_const Prop (add_comm_monoid congr_arg_kind)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_14469 (h0 : complete_lattice (has_inner unsigned (option unsigned))) : complete_lattice.is_Sup_finite_compact (has_inner unsigned (option unsigned)) := sorry --non-trivial
lemma new_lemma_14470 (h1 : topological_space (has_ssubset char)) (h2 : add_group (has_ssubset char)) : topological_add_group (has_ssubset char) := sorry --non-trivial
lemma new_lemma_14471 (h0 : functor.add_const (function.extfun Type topological_space) name) : @discrete_topology.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_14472 (h0 : topological_space (has_neg (semigroup name))) : t1_space (has_neg (semigroup name)) := sorry --non-trivial
lemma new_lemma_14473 (h0 : ring (boolean_algebra (comm_group (comm_group Type)))) : is_principal_ideal_ring (boolean_algebra (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_14474 (h0 : function.extfun Type (prod (option ennreal))) : id_rel (function.extfun_app h0 (option ennreal)) := sorry --non-trivial
lemma new_lemma_14475 (h0 : semiring (add_comm_semigroup (has_mod enat))) (h1 : ideal (add_comm_semigroup (has_mod enat))) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_14476 (h0 : ring (measurable_space.dynkin_system unsigned)) : is_principal_ideal_ring (measurable_space.dynkin_system unsigned) := sorry --non-trivial
lemma new_lemma_14477 (h0 : ring (canonically_ordered_monoid to_additive.value_type)) : strong_rank_condition (canonically_ordered_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_14478 (h0 : function.extfun Type topological_space) : @t1_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_14479 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_14480 (h0 : topological_space (canonically_ordered_monoid (has_add real))) : path_connected_space (canonically_ordered_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_14481 (h0 : functor.add_const (ring (has_nndist unsigned)) unsigned) : @rank_condition.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_14482 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_14483 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_separated_space.{0} (with_one.{0} (with_bot.{0} (has_top.{0} linarith.comp))) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (with_one.{0} (with_bot.{0} (has_top.{0} linarith.comp))))  := sorry --non-trivial
lemma new_lemma_14484 (h0 : functor.add_const (uniform_space (comm_group unsigned)) unsigned) : @separated_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (comm_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_14485 (h4 : ring (distrib reducibility_hints)) : rank_condition (distrib reducibility_hints) := sorry --non-trivial
lemma new_lemma_14486 (h0 : complete_lattice (has_Inf (has_Inf real))) : is_compactly_generated (has_Inf (has_Inf real)) := sorry --non-trivial
lemma new_lemma_14487 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) (finset linarith.comp)) : @has_exists_mul_of_le.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) (finset.{0} linarith.comp) h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_14488 (h0 : functor.add_const (semiring (boolean_algebra.core Type)) pos) : @is_noetherian_ring.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (boolean_algebra.core.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_14489 (h0 : functor.add_const (topological_space (normed_linear_ordered_group empty)) empty) : @preirreducible_space.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_14490 (h0 : functor.add_const (topological_space (has_to_string Type)) (has_Inf (has_Inf Type))) : @irreducible_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_to_string.{1} Type)) (has_Inf.{1} (has_Inf.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_14491 (h0 : not (filter (complete_semilattice_Sup char) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_14492 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_14493 (h0 : topological_space (normed_group char)) : totally_disconnected_space (normed_group char) := sorry --non-trivial
lemma new_lemma_14494 (h0 : topological_space nnreal) : preirreducible_space nnreal := sorry --non-trivial
lemma new_lemma_14495 (h0 : ring (mul_zero_class unsigned)) : strong_rank_condition (mul_zero_class unsigned) := sorry --non-trivial
lemma new_lemma_14496 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @rank_condition.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (simple_graph.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_14497 (h0 : functor.add_const (uniform_space (canonically_ordered_monoid linarith.comp)) (has_bot real)) : @separated_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (canonically_ordered_monoid.{0} linarith.comp)) (has_bot.{0} real) h0)  := sorry --non-trivial
lemma new_lemma_14498 (h0 : functor.add_const (finset (semigroup name)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_14499 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @is_cyclic.{0} linarith.comp (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) linarith.comp)  := sorry --non-trivial
lemma new_lemma_14500 (h1 : topological_space (nondiscrete_normed_field (normed_field (normed_field char)))) (h2 : punit) : totally_disconnected_space (nondiscrete_normed_field (normed_field (normed_field char))) := sorry --non-trivial
lemma new_lemma_14501 (h0 : list (semigroup (option empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_14502 (h0 : function.extfun Type topological_space) : @t0_space.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_14503 (h0 : topological_space (pseudo_metric_space unsigned)) : discrete_topology (pseudo_metric_space unsigned) := sorry --non-trivial
lemma new_lemma_14504 (h3 : set (semigroup linarith.ineq -> linarith.ineq)) : set.separates_points h3 := sorry --non-trivial
lemma new_lemma_14505 (h0 : functor.add_const (topological_space (generalized_boolean_algebra Type)) Type) : @loc_path_connected_space.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_14506 (h0 : functor.add_const (monoid (has_edist empty)) unsigned) : @monoid.fg.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (has_edist.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_14507 (h0 : uniform_space (measurable_space (has_norm linarith.ineq))) : complete_space (measurable_space (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_14508 (h0 : ring (monoid_with_zero unsigned) -> ring (monoid_with_zero unsigned) -> Prop) : reflexive h0 := sorry --non-trivial
lemma new_lemma_14509 (h0 : ring (linear_ordered_add_comm_group (has_norm fun_info))) : rank_condition (linear_ordered_add_comm_group (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_14510 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} h0 (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_14511 (h0 : complete_lattice (has_norm linarith.comp)) : is_atomistic (has_norm linarith.comp) := sorry --non-trivial
lemma new_lemma_14512 (h0 : functor.add_const (topological_space (bin_tree num)) num) : @topological_space.separable_space.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_14513 (h0 : uniform_space (with_one (has_top linarith.comp))) : separated_space (with_one (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_14514 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (fintype.{0} string_imp) (@functor.comp.run.{0 0 0} group.{0} fintype.{0} string_imp (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} fintype.{0}) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.comp.{0 0 0} group.{0} fintype.{0})) string_imp))  := sorry --non-trivial
lemma new_lemma_14515 (h1 : semiring (mul_one_class (add_comm_semigroup ereal))) (h2 : ideal (mul_one_class (add_comm_semigroup ereal))) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_14516 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup pos)) name) : @archimedean.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semigroup.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_14517 (h0 : topological_space (measurable_space num)) : totally_disconnected_space (measurable_space num) := sorry --non-trivial
lemma new_lemma_14518 (h0 : functor.add_const (group (has_to_string Type)) linarith.comp) : @is_cyclic.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_to_string.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_14519 (h0 : nat -> topological_space (has_ssubset char) -> topological_space (has_ssubset char)) (h1 : not (nat -> false)) (h2 : topological_space (has_ssubset char)) : t0_space (has_ssubset char) := sorry --non-trivial
lemma new_lemma_14520 (h0 : complete_lattice (distrib (has_compl (has_nnnorm enat)))) : is_compactly_generated (distrib (has_compl (has_nnnorm enat))) := sorry --non-trivial
lemma new_lemma_14521 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (is_R_or_C.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (is_R_or_C.{0} empty))  := sorry --non-trivial
lemma new_lemma_14522 (h0 : function.extfun (Type 1) topological_space) : @preconnected_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_14523 (h0 : ordered_add_comm_monoid (linear_ordered_comm_monoid_with_zero (option empty))) : archimedean (linear_ordered_comm_monoid_with_zero (option empty)) := sorry --non-trivial
lemma new_lemma_14524 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_ssubset.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_ssubset.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_14525 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_14526 (h0 : list (has_bot (option empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_14527 (h0 : functor.add_const (add_monoid (ring environment.implicit_infer_kind)) (has_neg Type)) : @add_monoid.fg.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (add_monoid.{0} (ring.{0} environment.implicit_infer_kind)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_14528 (h0 : not (topological_space (with_bot empty) -> false)) : @totally_disconnected_space.{0} (with_bot.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_14529 (h0 : topological_space (has_bot congr_arg_kind)) : path_connected_space (has_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_14530 (h0 : function.extfun (Type 1) (functor.comp complete_lattice has_neg_part)) : @is_compactly_generated.{1} (has_neg_part.{1} Type) (@functor.comp.run.{1 1 1} complete_lattice.{1} has_neg_part.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} complete_lattice.{1} has_neg_part.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_14531 (h0 : function.extfun (finset Type) (has_mem.mem (semiring linarith.comp_source))) : @totally_separated_space.{0} (semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_14532 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_14533 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_14534 (h1 : add_group std_gen) : is_add_cyclic std_gen := sorry --non-trivial
lemma new_lemma_14535 (h0 : topological_space (has_nndist (mul_zero_class pos))) : irreducible_space (has_nndist (mul_zero_class pos)) := sorry --non-trivial
lemma new_lemma_14536 (h0 : functor.add_const (filter (as_linear_order unsigned)) num) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_14537 (h0 : functor.add_const (add_group (comm_group Type)) (has_neg (finset (has_neg Type)))) : @is_add_cyclic.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 1} (add_group.{1} (comm_group.{1} Type)) (has_neg.{1} (finset.{1} (has_neg.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_14538 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (measurable_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} h0 (measurable_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_14539 (h0 : has_add (option (option ennreal)) -> has_add (option (option ennreal)) -> Prop) : is_symm (has_add (option (option ennreal))) h0 := sorry --non-trivial
lemma new_lemma_14540 (h0 : topological_space (normed_group (random_gen (has_norm linarith.comp_source)))) : irreducible_space (normed_group (random_gen (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_14541 (h0 : functor.add_const (add_monoid (has_star empty)) empty) : @add_monoid.fg.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_star.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_14542 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_bot.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_14543 (h0 : uniform_space (semi_normed_ring (has_ssubset (has_ssubset reducibility_hints)))) : complete_space (semi_normed_ring (has_ssubset (has_ssubset reducibility_hints))) := sorry --non-trivial
lemma new_lemma_14544 (h0 : monoid (linear_ordered_semiring (has_norm (has_norm num)))) : monoid.fg (linear_ordered_semiring (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_14545 (h0 : topological_space (add_comm_semigroup enat)) (h1 : set (add_comm_semigroup enat)) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_14546 (h0 : topological_space (has_zero environment.implicit_infer_kind)) : discrete_topology (has_zero environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_14547 (h0 : functor.add_const (semiring (has_add linarith.comp)) environment.implicit_infer_kind) : @is_noetherian_ring.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (has_add.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_14548 (h0 : group (plift (has_top (has_top (has_top empty))))) : normalizer_condition (plift (has_top (has_top (has_top empty)))) := sorry --non-trivial
lemma new_lemma_14549 (h0 : finset (simple_graph empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_14550 (h0 : ordered_comm_monoid (complete_distrib_lattice num)) : has_exists_mul_of_le (complete_distrib_lattice num) := sorry --non-trivial
lemma new_lemma_14551 (h0 : topological_space (finset (finset environment.implicit_infer_kind))) : t0_space (finset (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_14552 (h0 : ring (normed_comm_ring (has_add (has_add Type)))) : is_principal_ideal_ring (normed_comm_ring (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_14553 (h0 : functor.add_const (topological_space (has_bot empty)) congr_arg_kind) : @t0_space.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_14554 (h0 : uniform_space (add_comm_monoid (has_add pos))) : separated_space (add_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_14555 (h0 : ring (has_zero (has_pos_part (has_Inf (has_pos_part Type))))) : is_principal_ideal_ring (has_zero (has_pos_part (has_Inf (has_pos_part Type)))) := sorry --non-trivial
lemma new_lemma_14556 (h0 : functor.add_const (group (has_inter ennreal)) ennreal) : @group.fg.{0} (has_inter.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (has_inter.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_14557 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_14558 (h1 : has_neg (mul_one_class enat)) (h2 : measurable_space (mul_one_class enat)) : has_measurable_neg (mul_one_class enat) := sorry --non-trivial
lemma new_lemma_14559 (h0 : functor.comp cancel_comm_monoid_with_zero comm_group Type) : @unique_factorization_monoid.{1} (comm_group.{1} Type) (@functor.comp.run.{1 1 1} cancel_comm_monoid_with_zero.{1} comm_group.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_14560 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} linarith.comp (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_14561 (h1 : ring (linear_ordered_add_comm_group string_imp)) : rank_condition (linear_ordered_add_comm_group string_imp) := sorry --non-trivial
lemma new_lemma_14562 (h0 : functor.add_const (filter (semigroup unsigned)) environment.implicit_infer_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_14563 (h0 : function.extfun (finset Type -> Prop) (function.extfun (finset Type))) : @rank_condition.{0} to_additive.value_type (@finset.pi.empty.{1 0} Type ring.{0} to_additive.value_type (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) to_additive.value_type) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) h0 (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) to_additive.value_type)) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_14564 (h1 : ring (normed_group fun_info)) : strong_rank_condition (normed_group fun_info) := sorry --non-trivial
lemma new_lemma_14565 (h0 : functor.add_const (topological_space (has_neg unsigned)) (has_neg linarith.comp)) : @t0_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_14566 (h0 : set (set fun_info)) : is_countably_spanning h0 := sorry --non-trivial
lemma new_lemma_14567 (h0 : topological_space (has_one empty)) : topological_space.separable_space (has_one empty) := sorry --non-trivial
lemma new_lemma_14568 (h0 : topological_space empty) : t1_space empty := sorry --non-trivial
lemma new_lemma_14569 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_14570 (h0 : function.extfun Type (functor.comp topological_space normed_comm_ring)) : @totally_disconnected_space.{0} (normed_comm_ring.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} normed_comm_ring.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} normed_comm_ring.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_14571 (h0 : group (measurable_space.dynkin_system (semiring (semiring empty)))) : is_cyclic (measurable_space.dynkin_system (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_14572 (h0 : topological_space (simple_graph (boolean_algebra.core pos))) : preconnected_space (simple_graph (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_14573 (h1 : set (add_comm_semigroup ereal)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_14574 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (complete_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (complete_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_14575 (h0 : not (ring (has_one unsigned) -> false)) : @is_domain.{0} (has_one.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (has_one.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_14576 (h0 : ring (has_neg (has_add (has_add (finset pos))))) : strong_rank_condition (has_neg (has_add (has_add (finset pos)))) := sorry --non-trivial
lemma new_lemma_14577 (h0 : add_monoid (sub_neg_monoid pos)) : add_monoid.fg (sub_neg_monoid pos) := sorry --non-trivial
lemma new_lemma_14578 (h1 : topological_space (has_union empty)) : totally_separated_space (has_union empty) := sorry --non-trivial
lemma new_lemma_14579 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (measurable_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_14580 (h0 : topological_space (monoid_with_zero pos)) : totally_disconnected_space (monoid_with_zero pos) := sorry --non-trivial
lemma new_lemma_14581 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_14582 (h0 : functor.add_const (filter (finset Type)) environment.implicit_infer_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_14583 (h0 : topological_space (filter (semiring (semiring (semiring empty))))) : topological_space.separable_space (filter (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_14584 (h0 : topological_space (canonically_ordered_comm_semiring (option (finset (comm_group pos))))) : discrete_topology (canonically_ordered_comm_semiring (option (finset (comm_group pos)))) := sorry --non-trivial
lemma new_lemma_14585 (h0 : function.extfun Type group) : @is_cyclic.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_14586 (h1 h2 : multiset (random_gen linarith.comp_source)) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_14587 (h0 : group (has_neg_part (option pos))) : is_cyclic (has_neg_part (option pos)) := sorry --non-trivial
lemma new_lemma_14588 (h0 : functor.add_const (topological_space (has_inter empty)) unsigned) : @discrete_topology.{0} (has_inter.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_inter.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_14589 (h0 : ring (has_neg (option (option unsigned)))) : is_domain (has_neg (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_14590 (h0 : add_monoid (add_comm_monoid (option ennreal))) : add_monoid.fg (add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_14591 (h0 : add_group (group_with_zero (option (option ennreal)))) : is_add_cyclic (group_with_zero (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_14592 (h0 : topological_space (has_bot (comm_semigroup (sub_neg_monoid name)))) : loc_path_connected_space (has_bot (comm_semigroup (sub_neg_monoid name))) := sorry --non-trivial
lemma new_lemma_14593 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra environment.implicit_infer_kind)) pos) : @archimedean.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_14594 (h0 : functor.add_const (add_group (add_comm_monoid Type)) pos) : @is_add_cyclic.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (add_comm_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_14595 (h0 : functor.add_const (ordered_comm_monoid (has_neg linarith.comp)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_neg.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_14596 (h0 : topological_space (boolean_algebra.core (comm_group (comm_group name)))) : topological_space.separable_space (boolean_algebra.core (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_14597 (h0 : char -> char -> Prop) (h1 h3 : char) : eqv_gen h0 h1 h3 := sorry --non-trivial
lemma new_lemma_14598 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_neg.{0} (option.{0} (option.{0} pos))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} (option.{0} (option.{0} pos))))  := sorry --non-trivial
lemma new_lemma_14599 (h0 : topological_space (has_union (semiring complex))) : path_connected_space (has_union (semiring complex)) := sorry --non-trivial
lemma new_lemma_14600 (h0 : topological_space (has_add (normed_comm_ring ennreal))) : irreducible_space (has_add (normed_comm_ring ennreal)) := sorry --non-trivial
lemma new_lemma_14601 (h1 : function.extfun Type group) : @group.fg.{0} linarith.ineq (@function.extfun_app.{2 1} Type group.{0} h1 linarith.ineq)  := sorry --non-trivial
lemma new_lemma_14602 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group linarith.comp_source))) : @totally_separated_space.{0} (normed_group.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_14603 (h0 : function.extfun Type (functor.add_const (finset (comm_monoid empty)))) : finset.nonempty (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_14604 (h0 : topological_space (ordered_ring (semiring empty))) : topological_space.separable_space (ordered_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_14605 (h0 : function.extfun nat fin) : @t1_space.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_14606 (h0 : group (has_inv (has_nnnorm (has_nnnorm (has_nnnorm to_additive.value_type))))) : group.fg (has_inv (has_nnnorm (has_nnnorm (has_nnnorm to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_14607 (h0 : topological_space (linear_ordered_semiring (semiring fun_info))) : totally_disconnected_space (linear_ordered_semiring (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_14608 (h0 : topological_space ereal) (h1 : set ereal) : is_closed h1 := sorry --non-trivial
lemma new_lemma_14609 (h0 : cancel_comm_monoid_with_zero (ordered_comm_ring (has_neg pos))) : unique_factorization_monoid (ordered_comm_ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_14610 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @irreducible_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_14611 (h0 : functor.add_const (function.extfun Type ring) (has_add linarith.comp)) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (has_add.{0} linarith.comp) h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_14612 (h0 : ring (simple_graph (mul_one_class string.iterator_imp))) : is_domain (simple_graph (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_14613 (h0 : functor.add_const (finset (has_Inf pos)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_14614 (h0 : add_monoid (metric_space (semiring (semiring congr_arg_kind)))) : add_monoid.fg (metric_space (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_14615 (h0 : add_monoid (boolean_algebra pos)) : add_monoid.fg (boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_14616 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (has_nnnorm.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_nnnorm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_14617 (h0 : not (add_group (semi_normed_ring (mul_one_class reducibility_hints)) -> false)) : @is_add_cyclic.{0} (semi_normed_ring.{0} (mul_one_class.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (add_group.{0} (semi_normed_ring.{0} (mul_one_class.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_14618 (h0 : topological_space (has_nndist (option pos))) : t1_space (has_nndist (option pos)) := sorry --non-trivial
lemma new_lemma_14619 (h0 : set (has_le string.iterator_imp)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_14620 (h0 : monoid (linear_ordered_comm_ring (semiring congr_arg_kind))) : monoid.fg (linear_ordered_comm_ring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_14621 (h0 : nat) (h1 : not (topological_space (nat.partition h0) -> false)) : @irreducible_space.{0} (nat.partition h0) (@classical.by_contradiction'.{1} (topological_space.{0} (nat.partition h0)) h1)  := sorry --non-trivial
lemma new_lemma_14622 (h0 : functor.comp group mul_zero_class Type) : @is_cyclic.{1} (mul_zero_class.{1} Type) (@functor.comp.run.{1 1 1} group.{1} mul_zero_class.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_14623 (h0 : topological_space (normed_linear_ordered_group (semiring (semiring (semiring (semiring congr_arg_kind)))))) : t0_space (normed_linear_ordered_group (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_14624 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (semigroup.{0} (finset.{0} ennreal)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semigroup.{0} (finset.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_14625 (h0 : functor.add_const (topological_space (has_neg_part environment.implicit_infer_kind)) pos) : @path_connected_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_14626 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) Type) : @preconnected_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_14627 (h0 : monoid (has_to_string (has_add environment.implicit_infer_kind))) : monoid.fg (has_to_string (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_14628 (h0 : topological_space (ring (finset (has_pos_part pos)))) : discrete_topology (ring (finset (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_14629 (h0 : group (measurable_space fun_info)) : group.fg (measurable_space fun_info) := sorry --non-trivial
lemma new_lemma_14630 (h0 : topological_space (has_top (has_norm fun_info))) : normal_space (has_top (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_14631 (h0 : ring (linear_ordered_add_comm_group fun_info)) : rank_condition (linear_ordered_add_comm_group fun_info) := sorry --non-trivial
lemma new_lemma_14632 (h1 : add_group (non_unital_non_assoc_semiring (mul_one_class string.iterator_imp))) : is_add_cyclic (non_unital_non_assoc_semiring (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_14633 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_14634 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type add_group.{0} h0 environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_14635 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (mul_zero_class.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (mul_zero_class.{0} empty))  := sorry --non-trivial
lemma new_lemma_14636 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_14637 (h0 : functor.add_const (ring (has_to_string linarith.comp)) linarith.comp) : @rank_condition.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_14638 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} name (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) name)  := sorry --non-trivial
lemma new_lemma_14639 (h0 : has_lt (has_ssubset (has_inf ereal))) : no_max_order (has_ssubset (has_inf ereal)) := sorry --non-trivial
lemma new_lemma_14640 (h0 : list (semi_normed_comm_ring to_additive.value_type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_14641 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) linarith.comp)  := sorry --non-trivial
lemma new_lemma_14642 (h0 : functor.add_const (group (semigroup Type)) environment.implicit_infer_kind) : @group.fg.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (semigroup.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_14643 (h0 : filter (has_norm (has_top (has_top congr_arg_kind)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_14644 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) unsigned) : @t0_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_14645 (h1 : list string_imp) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_14646 (h2 : not (topological_space (dlist to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (dlist.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (dlist.{0} to_additive.value_type)) h2)  := sorry --non-trivial
lemma new_lemma_14647 (h0 : ordered_comm_monoid (add_cancel_monoid (has_neg_part environment.implicit_infer_kind))) : has_exists_mul_of_le (add_cancel_monoid (has_neg_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_14648 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_14649 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_14650 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @rank_condition.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_14651 (h0 : topological_space (has_zero (option ennreal))) : sequential_space (has_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_14652 (h0 : not (topological_space (linear_ordered_add_comm_group linarith.comp_source) -> false)) : @totally_separated_space.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_14653 (h0 : ring (pseudo_metric_space linarith.ineq)) : is_domain (pseudo_metric_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_14654 (h0 : topological_space (normed_comm_ring empty)) : locally_compact_space (normed_comm_ring empty) := sorry --non-trivial
lemma new_lemma_14655 (h0 : topological_space (has_nndist environment.implicit_infer_kind)) : totally_disconnected_space (has_nndist environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_14656 (h0 : functor.add_const (complete_lattice (comm_group name)) unsigned) : @is_compactly_generated.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_14657 (h0 : cancel_comm_monoid_with_zero (boolean_algebra.core (has_neg_part Type))) : unique_factorization_monoid (boolean_algebra.core (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_14658 (h2 : complete_lattice (distrib (denumerable char))) : complete_lattice.is_Sup_finite_compact (distrib (denumerable char)) := sorry --non-trivial
lemma new_lemma_14659 (h0 : group (has_top (comm_ring (comm_ring linarith.ineq)))) : group.fg (has_top (comm_ring (comm_ring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_14660 (h0 : topological_space (has_nnnorm (random_gen linarith.ineq))) : totally_disconnected_space (has_nnnorm (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_14661 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (has_Inf (has_Inf linarith.comp))) : @preirreducible_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) (has_Inf.{0} (has_Inf.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_14662 (h0 : ring (has_top (has_top (metric_space (semiring num))))) : is_domain (has_top (has_top (metric_space (semiring num)))) := sorry --non-trivial
lemma new_lemma_14663 (h0 : functor.add_const (ring (lattice empty)) empty) : @is_domain.{0} (lattice.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (lattice.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_14664 (h0 : function.extfun nat fin) : @topological_space.separable_space.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_14665 (h0 : topological_space (boolean_algebra (has_neg name))) : normal_space (boolean_algebra (has_neg name)) := sorry --non-trivial
lemma new_lemma_14666 (h0 : functor.add_const (add_monoid (has_to_string Type)) pos) : @add_monoid.fg.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (has_to_string.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_14667 (h0 : ring (distrib (has_compl reducibility_hints))) : is_domain (distrib (has_compl reducibility_hints)) := sorry --non-trivial
lemma new_lemma_14668 (h0 : complete_lattice (has_bot (has_Inf pos))) : is_compactly_generated (has_bot (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_14669 (h0 : functor.add_const (topological_space (has_zero name)) environment.implicit_infer_kind) : @topological_space.separable_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_14670 (h0 : topological_space (finset (option (option (option (option (option ennreal))))))) : normal_space (finset (option (option (option (option (option ennreal)))))) := sorry --non-trivial
lemma new_lemma_14671 (h1 : add_group (add_comm_semigroup (add_comm_semigroup ereal))) : is_add_cyclic (add_comm_semigroup (add_comm_semigroup ereal)) := sorry --non-trivial
lemma new_lemma_14672 (h0 : topological_space (boolean_algebra.core ennreal)) : locally_compact_space (boolean_algebra.core ennreal) := sorry --non-trivial
lemma new_lemma_14673 (h0 : topological_space (normed_lattice_add_comm_group name)) : t1_space (normed_lattice_add_comm_group name) := sorry --non-trivial
lemma new_lemma_14674 (h0 : uniform_space (with_bot (random_gen (random_gen string_imp)))) : complete_space (with_bot (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_14675 (h0 : functor.add_const (topological_space (has_neg name)) linarith.comp) : @normal_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_14676 (h0 : topological_space (has_add num)) : regular_space (has_add num) := sorry --non-trivial
lemma new_lemma_14677 (h0 : ordered_comm_monoid (cancel_monoid (comm_group name))) : has_exists_mul_of_le (cancel_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_14678 (h0 : function.extfun (Type 1) complete_lattice) : @complete_lattice.is_Sup_finite_compact.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_14679 (h1 : has_neg (nondiscrete_normed_field linarith.ineq)) (h2 : measurable_space (nondiscrete_normed_field linarith.ineq)) : has_measurable_neg (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_14680 (h0 : ring (has_emptyc (has_top num))) : is_domain (has_emptyc (has_top num)) := sorry --non-trivial
lemma new_lemma_14681 (h0 : function.extfun (Type 1) group) : @is_cyclic.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_14682 (h0 : not (uniform_space (bin_tree num) -> false)) : @complete_space.{0} (bin_tree.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (bin_tree.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_14683 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (ordered_cancel_add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_14684 (h0 : ring (ring (boolean_algebra.core name))) : is_domain (ring (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_14685 (h0 : set (distrib (mul_one_class string_imp))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_14686 (h0 : ring (encodable (has_nnnorm fun_info))) : rank_condition (encodable (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_14687 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_14688 (h0 : not (add_group (random_gen linarith.ineq) -> false)) : @is_add_cyclic.{0} (random_gen.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (random_gen.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_14689 (h0 : functor.add_const (list (add_cancel_monoid linarith.comp)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_14690 (h0 : ring std_gen) : is_domain std_gen := sorry --non-trivial
lemma new_lemma_14691 (h2 : uniform_space (nondiscrete_normed_field char)) (h3 : topological_space (uniform_space.separation_quotient (nondiscrete_normed_field char))) : t0_space (uniform_space.separation_quotient (nondiscrete_normed_field char)) := sorry --non-trivial
lemma new_lemma_14692 (h0 : functor.add_const (uniform_space (has_add environment.implicit_infer_kind)) linarith.comp) : @separated_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_add.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_14693 (h0 : fin has_zero.zero) : @discrete_topology.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_14694 (h0 : monoid (sub_neg_monoid (has_Inf pos))) : monoid.fg (sub_neg_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_14695 (h0 : preorder std_gen) (h1 : topological_space std_gen) : Sup_convergence_class std_gen := sorry --non-trivial
lemma new_lemma_14696 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_14697 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_14698 (h0 : uniform_space num) : complete_space num := sorry --non-trivial
lemma new_lemma_14699 (h0 : finset (id unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_14700 (h0 : topological_space congr_arg_kind) : irreducible_space congr_arg_kind := sorry --non-trivial
lemma new_lemma_14701 (h0 : functor.add_const (ring (has_add pos)) (ring Type)) : @rank_condition.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_add.{0} pos)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_14702 (h0 : not (has_mem.mem (function.extfun Type) has_emptyc.emptyc -> false)) : @irreducible_space.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{0} (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (finset.{2} ((Type → Type) → Type 1)) (@finset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type) (@has_emptyc.emptyc.{2} (finset.{2} ((Type → Type) → Type 1)) (@finset.has_emptyc.{2} ((Type → Type) → Type 1)))) h0)) topological_space.{0}) (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_14703 (h0 : functor.add_const (cancel_comm_monoid_with_zero (cancel_monoid Type)) Type) : @unique_factorization_monoid.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (cancel_comm_monoid_with_zero.{1} (cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_14704 (h0 : uniform_space (has_top (has_top num))) : separated_space (has_top (has_top num)) := sorry --non-trivial
lemma new_lemma_14705 (h0 : add_group (free_add_monoid (option congr_arg_kind))) : is_add_cyclic (free_add_monoid (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_14706 (h0 : uniform_space (mul_zero_class ennreal)) : separated_space (mul_zero_class ennreal) := sorry --non-trivial
lemma new_lemma_14707 (h0 : group (simple_graph linarith.comp)) : is_simple_group (simple_graph linarith.comp) := sorry --non-trivial
lemma new_lemma_14708 (h0 : complete_lattice (ordered_comm_ring (sub_neg_monoid Type))) : is_atomistic (ordered_comm_ring (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_14709 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_14710 (h3 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h3) (encodable linarith.ineq)) := sorry --non-trivial
lemma new_lemma_14711 (h0 : filter (has_top string_imp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_14712 (h0 : functor.add_const (add_group (has_norm unsigned)) num) : @is_add_cyclic.{0} (has_norm.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (has_norm.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_14713 (h0 : group (canonically_ordered_monoid real)) : is_cyclic (canonically_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_14714 (h0 : complete_lattice (option (option ennreal))) : is_compactly_generated (option (option ennreal)) := sorry --non-trivial
lemma new_lemma_14715 (h0 : functor.add_const (group (has_to_string environment.implicit_infer_kind)) Type) : @is_simple_group.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (group.{0} (has_to_string.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_14716 (h1 : function.extfun Type ring) : @rank_condition.{0} (has_inv.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} h1 (has_inv.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_14717 (h0 : group (sub_neg_monoid (finset (finset (has_Inf Type))))) : is_simple_group (sub_neg_monoid (finset (finset (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_14718 (h0 : not (ring (distrib fun_info) -> false)) : @strong_rank_condition.{0} (distrib.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_14719 (h0 : functor.add_const (list (ordered_comm_ring Type)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_14720 (h0 : has_mem.mem num has_emptyc.emptyc) : @totally_disconnected_space.{0} num (@finset.pi.empty.{1 0} Type topological_space.{0} num h0)  := sorry --non-trivial
lemma new_lemma_14721 (h0 : topological_space (has_to_string (finset linarith.comp))) : sequential_space (has_to_string (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_14722 (h0 : uniform_space (distrib (metric_space to_additive.value_type))) : complete_space (distrib (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_14723 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (linear_ordered_comm_group ennreal)) := sorry --non-trivial
lemma new_lemma_14724 (h0 : group (canonically_ordered_monoid (has_Inf (ordered_comm_monoid real)))) : is_cyclic (canonically_ordered_monoid (has_Inf (ordered_comm_monoid real))) := sorry --non-trivial
lemma new_lemma_14725 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (mul_zero_class.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_14726 (h0 : finset (cancel_monoid (option unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_14727 (h0 : uniform_space (has_norm (has_inv fun_info))) : complete_space (has_norm (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_14728 (h0 : topological_space (has_norm (semiring (semiring fun_info)))) : normal_space (has_norm (semiring (semiring fun_info))) := sorry --non-trivial
lemma new_lemma_14729 (h0 : group (normed_group linarith.comp_source)) : is_cyclic (normed_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_14730 (h0 : topological_space (ring (option ennreal))) : locally_compact_space (ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_14731 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (filter.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (filter.{0} num))  := sorry --non-trivial
lemma new_lemma_14732 (h1 : topological_space (topological_space (comm_ring fun_info))) : path_connected_space (topological_space (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_14733 (h1 : topological_space (random_gen (has_top congr_arg_kind))) : totally_separated_space (random_gen (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_14734 (h1 : set (has_le string_imp)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_14735 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (add_cancel_monoid empty)) := sorry --non-trivial
lemma new_lemma_14736 (h0 : functor.add_const (function.extfun Type add_group) pos) : @is_add_cyclic.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) pos h0) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_14737 (h0 : uniform_space (ring (has_add (finset pos)))) : separated_space (ring (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_14738 (h0 : functor.add_const (group (add_cancel_monoid linarith.comp)) (finset Type)) : @is_cyclic.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (add_cancel_monoid.{0} linarith.comp)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_14739 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_14740 (h0 : functor.add_const (topological_space (has_zero name)) (comm_group Type)) : @irreducible_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} name)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_14741 (h0 : uniform_space (has_add linarith.comp)) : complete_space (has_add linarith.comp) := sorry --non-trivial
lemma new_lemma_14742 (h0 : topological_space (has_inv (has_nnnorm (has_nnnorm (has_inv linarith.ineq))))) : totally_disconnected_space (has_inv (has_nnnorm (has_nnnorm (has_inv linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_14743 (h0 : filter (option name)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_14744 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (free_add_monoid.{0} num) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (free_add_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_14745 (h0 : ring (has_nnnorm (dlist to_additive.value_type))) : is_domain (has_nnnorm (dlist to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_14746 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_14747 (h0 : topological_space (boolean_algebra.core environment.implicit_infer_kind)) : sequential_space (boolean_algebra.core environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_14748 (h0 : function.extfun nat fin) : @is_compactly_generated.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (canonically_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_14749 (h0 : functor.add_const (ring (has_star congr_arg_kind)) unsigned) : @is_principal_ideal_ring.{0} (has_star.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_star.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_14750 (h0 : function.extfun Type topological_space) : @t0_space.{0} (ordered_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_14751 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_14752 (h0 : functor.add_const (list (left_cancel_monoid empty)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_14753 (h0 : functor.add_const (topological_space (has_nndist unsigned)) name) : @totally_disconnected_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_14754 (h0 : topological_space (has_zero (has_to_string (has_to_string name)))) : topological_space.separable_space (has_zero (has_to_string (has_to_string name))) := sorry --non-trivial
lemma new_lemma_14755 (h0 : filter (has_sub (semiring unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_14756 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_14757 (h0 : topological_space (linear_ordered_field linarith.comp_source)) : t0_space (linear_ordered_field linarith.comp_source) := sorry --non-trivial
lemma new_lemma_14758 (h0 : uniform_space (ordered_ring (ordered_ring unsigned))) : separated_space (ordered_ring (ordered_ring unsigned)) := sorry --non-trivial
lemma new_lemma_14759 (h0 : add_group (add_monoid (has_compl linarith.comp_source))) : is_add_cyclic (add_monoid (has_compl linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_14760 (h0 : ring (non_unital_non_assoc_semiring (comm_ring to_additive.value_type))) : rank_condition (non_unital_non_assoc_semiring (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_14761 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_14762 (h0 : complete_lattice (complete_distrib_lattice string_imp)) : is_compactly_generated (complete_distrib_lattice string_imp) := sorry --non-trivial
lemma new_lemma_14763 (h0 : topological_space (ordered_comm_monoid (has_add pos))) : totally_disconnected_space (ordered_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_14764 (h0 : topological_space (normed_comm_ring (has_to_string (has_to_string (has_add linarith.comp))))) : locally_compact_space (normed_comm_ring (has_to_string (has_to_string (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_14765 (h0 : ring (uniform_space string_imp)) : rank_condition (uniform_space string_imp) := sorry --non-trivial
lemma new_lemma_14766 (h0 : functor.add_const (topological_space (normed_comm_ring name)) pos) : @regular_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_14767 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_14768 (h0 : not (prod (has_sub empty) (has_sub empty) -> false)) : id_rel (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_14769 (h0 : topological_space (add_comm_monoid (comm_group pos))) : topological_space.separable_space (add_comm_monoid (comm_group pos)) := sorry --non-trivial
lemma new_lemma_14770 (h0 : not (ring (linear_ordered_add_comm_group char) -> false)) : @is_domain.{0} (linear_ordered_add_comm_group.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_add_comm_group.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_14771 (h0 : has_mem.mem (normed_group (has_top linarith.comp_source)) has_emptyc.emptyc) : @totally_separated_space.{0} (normed_group.{0} (has_top.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} (has_top.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_14772 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_dist.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_dist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_14773 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (measurable_space.dynkin_system.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_14774 (h0 : add_group (has_nndist name)) : is_add_cyclic (has_nndist name) := sorry --non-trivial
lemma new_lemma_14775 (h0 : group (has_pos_part (has_Inf name))) : group.fg (has_pos_part (has_Inf name)) := sorry --non-trivial
lemma new_lemma_14776 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_14777 (h0 : functor.add_const (topological_space (add_comm_monoid name)) Type) : @regular_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_14778 (h0 : topological_space (has_Sup (semiring (semiring (semiring (semiring empty)))))) : totally_separated_space (has_Sup (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_14779 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (semiring.{0} (has_top.{0} fun_info)) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (semiring.{0} (has_top.{0} fun_info)))  := sorry --non-trivial
lemma new_lemma_14780 (h0 : complete_lattice (filter (option (option (option (option empty)))))) : is_compactly_generated (filter (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_14781 (h0 : topological_space (has_star (semiring num))) : totally_separated_space (has_star (semiring num)) := sorry --non-trivial
lemma new_lemma_14782 (h0 : topological_space (ordered_comm_ring (has_Inf (has_Inf linarith.comp)))) : t1_space (ordered_comm_ring (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_14783 (h0 : filter (has_dist num)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_14784 (h0 : ring (add_group (semiring (semiring (semiring empty))))) : rank_condition (add_group (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_14785 (h0 : functor.add_const (topological_space (has_nndist Type)) pos) : @totally_disconnected_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_14786 (h1 : topological_space (measurable_space (random_gen string_imp))) : totally_disconnected_space (measurable_space (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_14787 (h0 : finset (has_pos_part (finset linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_14788 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_14789 (h0 : topological_space (semigroup (comm_group (comm_group name)))) : sequential_space (semigroup (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_14790 (h0 : topological_space (boolean_algebra (finset (finset Type)))) : locally_compact_space (boolean_algebra (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_14791 (h0 : topological_space (bin_tree fun_info)) : t0_space (bin_tree fun_info) := sorry --non-trivial
lemma new_lemma_14792 (h0 : ring (div_inv_monoid to_additive.value_type)) : strong_rank_condition (div_inv_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_14793 (h0 : not (topological_space (dlist linarith.ineq) -> false)) : @path_connected_space.{0} (dlist.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (dlist.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_14794 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) environment.implicit_infer_kind) : @regular_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_14795 (h0 : ring (uniform_space (mul_one_class string.iterator_imp))) : is_domain (uniform_space (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_14796 (h0 : topological_space (has_ssubset (random_gen fun_info))) : totally_disconnected_space (has_ssubset (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_14797 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_14798 (h0 : cancel_comm_monoid_with_zero (option (semiring (semiring (semiring (semiring (semiring empty))))))) : unique_factorization_monoid (option (semiring (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_14799 (h0 : complete_lattice (has_pos_part (has_pos_part (has_pos_part Type)))) : is_compactly_generated (has_pos_part (has_pos_part (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_14800 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (add_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_14801 (h0 : complete_lattice (semigroup (has_pos_part linarith.comp))) : complete_lattice.is_Sup_finite_compact (semigroup (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_14802 (h0 : has_mem.mem (has_emptyc to_additive.value_type) has_emptyc.emptyc) : @complete_space.{0} (has_emptyc.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_emptyc.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_14803 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) Type) : @t0_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_14804 (h0 : list (has_norm (with_one (comm_ring linarith.ineq)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_14805 (h0 : functor.add_const (ring (has_to_string environment.implicit_infer_kind)) pos) : @is_principal_ideal_ring.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_14806 (h0 : group (complete_distrib_lattice (generalized_boolean_algebra Type))) : group.fg (complete_distrib_lattice (generalized_boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_14807 (h0 : ring (add_comm_monoid (option unsigned))) : strong_rank_condition (add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_14808 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (linear_ordered_add_comm_monoid_with_top.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_add_comm_monoid_with_top.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_14809 (h0 : topological_space (metric_space (has_union (has_union linarith.comp)))) : normal_space (metric_space (has_union (has_union linarith.comp))) := sorry --non-trivial
lemma new_lemma_14810 (h0 : functor.add_const (cancel_comm_monoid_with_zero (sub_neg_monoid linarith.comp)) pos) : @unique_factorization_monoid.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (sub_neg_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_14811 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @regular_space.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_14812 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @unique_factorization_monoid.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (ordered_comm_ring.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_14813 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (measurable_space.dynkin_system.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (measurable_space.dynkin_system.{0} empty))  := sorry --non-trivial
lemma new_lemma_14814 (h0 : topological_space (add_right_cancel_monoid empty)) : totally_separated_space (add_right_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_14815 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (boolean_algebra.core.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} h0 (boolean_algebra.core.{0} empty))  := sorry --non-trivial
lemma new_lemma_14816 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) (has_zero Type)) : @discrete_topology.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} linarith.comp)) (has_zero.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_14817 (h0 : group (semiring (has_norm linarith.comp))) : is_cyclic (semiring (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_14818 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} linarith.comp_source (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_14819 (h0 : complete_lattice (complete_distrib_lattice (ring (option pos)))) : is_compactly_generated (complete_distrib_lattice (ring (option pos))) := sorry --non-trivial
lemma new_lemma_14820 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_bot.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_14821 (h0 : functor.add_const (ordered_add_comm_monoid (option unsigned)) unsigned) : @archimedean.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (option.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_14822 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (boolean_algebra (has_neg_part name))) : @path_connected_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) (boolean_algebra.{0} (has_neg_part.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_14823 (h0 : ring (canonically_ordered_comm_semiring congr_arg_kind)) : strong_rank_condition (canonically_ordered_comm_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_14824 (h0 : group (denumerable (denumerable (denumerable char)))) : is_cyclic (denumerable (denumerable (denumerable char))) := sorry --non-trivial
lemma new_lemma_14825 (h0 : topological_space (canonically_linear_ordered_monoid (option (option ennreal)))) : discrete_topology (canonically_linear_ordered_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_14826 (h0 : ring (linear_ordered_semiring (random_gen linarith.comp_source))) : rank_condition (linear_ordered_semiring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_14827 (h0 : ring (canonically_ordered_monoid Type)) : strong_rank_condition (canonically_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_14828 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_14829 (h0 : topological_space (add_cancel_monoid (has_neg (has_neg (has_neg (mul_one_class Type)))))) : preirreducible_space (add_cancel_monoid (has_neg (has_neg (has_neg (mul_one_class Type))))) := sorry --non-trivial
lemma new_lemma_14830 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup linarith.comp)) linarith.comp) : @archimedean.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semigroup.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_14831 (h0 : prod (as_linear_order (option (option (option empty)))) (as_linear_order (option (option (option empty))))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_14832 (h0 : not (topological_space (topological_space (has_nnnorm linarith.ineq)) -> false)) : @t0_space.{0} (topological_space.{0} (has_nnnorm.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (topological_space.{0} (topological_space.{0} (has_nnnorm.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_14833 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_14834 (h1 : complete_lattice (random_gen (normed_group linarith.comp))) : is_compactly_generated (random_gen (normed_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_14835 (h0 : topological_space (linear_ordered_semiring (semiring (semiring unsigned)))) : t0_space (linear_ordered_semiring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_14836 (h0 : list (has_to_string (option ennreal))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_14837 (h0 : topological_space (complete_distrib_lattice (has_pos_part (has_add (has_pos_part Type))))) : totally_separated_space (complete_distrib_lattice (has_pos_part (has_add (has_pos_part Type)))) := sorry --non-trivial
lemma new_lemma_14838 (h0 : monoid (complete_distrib_lattice pos)) : monoid.fg (complete_distrib_lattice pos) := sorry --non-trivial
lemma new_lemma_14839 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_14840 (h0 : topological_space (finset environment.implicit_infer_kind)) : preconnected_space (finset environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_14841 (h0 : topological_space (has_Inf (has_Inf pos))) : normal_space (has_Inf (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_14842 (h0 : topological_space (has_norm (has_norm (has_norm linarith.comp_source)))) : path_connected_space (has_norm (has_norm (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_14843 (h2 : measurable_space (mul_one_class enat)) (h3 : measure_theory.measure (mul_one_class enat)) : measure_theory.is_finite_measure h3 := sorry --non-trivial
lemma new_lemma_14844 (h0 : functor.add_const (topological_space (ordered_ring congr_arg_kind)) unsigned) : @totally_separated_space.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_14845 (h0 : semiring (comm_group (has_to_string (has_to_string name)))) : is_noetherian_ring (comm_group (has_to_string (has_to_string name))) := sorry --non-trivial
lemma new_lemma_14846 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @topological_space.separable_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_14847 (h0 : topological_space (finset (has_add (has_to_string linarith.comp)))) : preirreducible_space (finset (has_add (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_14848 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @path_connected_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_14849 (h0 : function.extfun (finset ((Type -> Type) -> Type 1)) (has_mem.mem (function.extfun Type))) : @path_connected_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@function.extfun_app.{3 0} (finset.{2} ((Type → Type) → Type 1)) (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (finset.{2} ((Type → Type) → Type 1)) (@finset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type)) h0 (@has_emptyc.emptyc.{2} (finset.{2} ((Type → Type) → Type 1)) (@finset.has_emptyc.{2} ((Type → Type) → Type 1))))) topological_space.{0}) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_14850 (h0 : functor.add_const (functor.add_const (topological_space Type) pos) linarith.comp) : @totally_disconnected_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) pos (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (topological_space.{1} Type) pos) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_14851 (h0 : functor.add_const (group (finset pos)) Type) : @group.fg.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (finset.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_14852 (h0 : set (add_comm_semigroup std_gen -> reducibility_hints)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_14853 (h0 : functor.add_const (topological_space (has_zero unsigned)) name) : @t1_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_14854 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_14855 (h0 : functor.add_const (ring (linear_ordered_comm_monoid_with_zero empty)) empty) : @rank_condition.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_14856 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_14857 (h0 : topological_space (has_neg_part name)) : totally_disconnected_space (has_neg_part name) := sorry --non-trivial
lemma new_lemma_14858 (h0 : topological_space (comm_ring (normed_group (random_gen (comm_ring to_additive.value_type))))) : t0_space (comm_ring (normed_group (random_gen (comm_ring to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_14859 (h0 : functor.add_const (topological_space (has_pos_part pos)) (ring Type)) : @discrete_topology.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_pos_part.{0} pos)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_14860 (h0 : topological_space (has_pos_part (ordered_ring linarith.comp))) : irreducible_space (has_pos_part (ordered_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_14861 (h0 : topological_space (random_gen (mul_one_class (mul_one_class reducibility_hints)))) : totally_disconnected_space (random_gen (mul_one_class (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_14862 (h0 : add_monoid (has_bot (has_add real))) : add_monoid.fg (has_bot (has_add real)) := sorry --non-trivial
lemma new_lemma_14863 (h0 : functor.add_const (topological_space (left_cancel_monoid empty)) unsigned) : @normal_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_14864 (h0 : group (boolean_algebra (ring (finset Type)))) : normalizer_condition (boolean_algebra (ring (finset Type))) := sorry --non-trivial
lemma new_lemma_14865 (h0 : group (with_zero to_additive.value_type)) : is_cyclic (with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_14866 (h0 : list (monoid num)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_14867 (h0 : add_monoid (has_star (semiring unsigned))) : add_monoid.fg (has_star (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_14868 (h0 : list (mul_zero_class (add_comm_monoid Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_14869 (h0 : topological_space (denumerable (random_gen (complete_semilattice_Sup string_imp)))) : t0_space (denumerable (random_gen (complete_semilattice_Sup string_imp))) := sorry --non-trivial
lemma new_lemma_14870 (h0 : topological_space (semi_normed_ring (mul_one_class to_additive.value_type))) : t0_space (semi_normed_ring (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_14871 (h0 : ring (normed_group (has_ssubset to_additive.value_type))) : rank_condition (normed_group (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_14872 (h0 : complete_lattice (complete_semilattice_Sup (semiring congr_arg_kind))) : is_compactly_generated (complete_semilattice_Sup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_14873 (h0 : measurable_space fun_info) (h1 : measure_theory.measure fun_info) : measure_theory.measure.is_complete h1 := sorry --non-trivial
lemma new_lemma_14874 (h0 : uniform_space (has_inv (has_nnnorm (has_nnnorm (random_gen linarith.ineq))))) : complete_space (has_inv (has_nnnorm (has_nnnorm (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_14875 (h0 : functor.add_const (topological_space (simple_graph linarith.comp)) (has_add name)) : @regular_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} linarith.comp)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_14876 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) name) : @path_connected_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_14877 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem monoid)) : @monoid.fg.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) monoid.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_14878 (h0 : filter (group_with_zero (option (option num)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_14879 (h1 : random_gen (linear_ordered_add_comm_group char) -> random_gen (linear_ordered_add_comm_group char) -> bool) : is_dec_refl h1 := sorry --non-trivial
lemma new_lemma_14880 (h0 : complete_lattice (has_inv (random_gen (has_ssubset fun_info)))) : complete_lattice.is_Sup_finite_compact (has_inv (random_gen (has_ssubset fun_info))) := sorry --non-trivial
lemma new_lemma_14881 (h0 : monoid (random_gen (random_gen linarith.comp_source))) : monoid.fg (random_gen (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_14882 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_14883 (h0 : prod (has_top empty) (has_top empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_14884 (h0 : topological_space (has_neg (mul_one_class string.iterator_imp))) : t0_space (has_neg (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_14885 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) (has_neg (has_neg Type))) : @t1_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} pos)) (has_neg.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_14886 (h0 : not (semiring (add_right_cancel_monoid unsigned) -> false)) : @is_noetherian_ring.{0} (add_right_cancel_monoid.{0} unsigned) (@classical.by_contradiction'.{1} (semiring.{0} (add_right_cancel_monoid.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_14887 (h0 : topological_space (plift (semiring (semiring (semiring num))))) : totally_separated_space (plift (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_14888 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (partial_order.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_14889 (h0 : functor.add_const (ring (has_nndist pos)) name) : @strong_rank_condition.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_14890 (h0 : topological_space (comm_group pos)) : preirreducible_space (comm_group pos) := sorry --non-trivial
lemma new_lemma_14891 (h0 : ring (has_inv (linear_ordered_add_comm_group string_imp))) : rank_condition (has_inv (linear_ordered_add_comm_group string_imp)) := sorry --non-trivial
lemma new_lemma_14892 (h0 : topological_space (add_comm_semigroup (mul_one_class fun_info))) : totally_disconnected_space (add_comm_semigroup (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_14893 (h0 : fin has_zero.zero) : normal_space real := sorry --non-trivial
lemma new_lemma_14894 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @complete_lattice.is_Sup_finite_compact.{0} to_additive.value_type (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) complete_lattice.{0}) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_14895 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_14896 (h0 : topological_space (linear_ordered_semiring (has_norm linarith.comp_source))) : totally_separated_space (linear_ordered_semiring (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_14897 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_14898 (h0 : has_mem.mem (random_gen linarith.comp) has_emptyc.emptyc) : @add_monoid.fg.{0} (random_gen.{0} linarith.comp) (@finset.pi.empty.{1 0} Type add_monoid.{0} (random_gen.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_14899 (h0 : functor.add_const (complete_lattice (has_neg name)) environment.implicit_infer_kind) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_14900 (h0 : add_monoid (has_add (has_add (has_add name)))) : add_monoid.fg (has_add (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_14901 (h0 : uniform_space (has_lt (has_lt char))) : complete_space (has_lt (has_lt char)) := sorry --non-trivial
lemma new_lemma_14902 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_nnnorm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_nnnorm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_14903 (h0 : cancel_comm_monoid_with_zero (boolean_algebra (comm_group (has_add (has_add pos))))) : unique_factorization_monoid (boolean_algebra (comm_group (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_14904 (h0 : topological_space (boolean_algebra.core name)) : t1_space (boolean_algebra.core name) := sorry --non-trivial
lemma new_lemma_14905 (h0 : functor.add_const (cancel_comm_monoid_with_zero (uniform_space Type)) pos) : @unique_factorization_monoid.{1} (uniform_space.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (uniform_space.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_14906 (h0 : topological_space (has_nndist (has_add unsigned))) : discrete_topology (has_nndist (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_14907 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (comm_ring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_ring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_14908 (h0 : functor.add_const (complete_lattice (complete_distrib_lattice unsigned)) (has_neg_part pos)) : @is_compactly_generated.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (complete_distrib_lattice.{0} unsigned)) (has_neg_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_14909 (h0 : ring (comm_ring string_imp)) : strong_rank_condition (comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_14910 (h0 : ring (add_cancel_monoid (boolean_algebra.core pos))) : rank_condition (add_cancel_monoid (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_14911 (h0 : functor.add_const (topological_space (has_to_string unsigned)) Type) : @t0_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_14912 (h0 : unsigned -> unsigned -> Prop) : is_trans unsigned h0 := sorry --non-trivial
lemma new_lemma_14913 (h0 : topological_space (add_group congr_arg_kind)) : preirreducible_space (add_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_14914 (h0 : topological_space (semi_normed_ring (comm_ring (comm_ring reducibility_hints)))) : t0_space (semi_normed_ring (comm_ring (comm_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_14915 (h0 : add_group (random_gen (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) : is_add_cyclic (random_gen (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_14916 (h0 : topological_space (non_unital_non_assoc_semiring (simple_graph (mul_one_class fun_info)))) : t0_space (non_unital_non_assoc_semiring (simple_graph (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_14917 (h0 : functor.add_const (complete_lattice (has_add pos)) environment.implicit_infer_kind) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_add.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_14918 (h0 : topological_space (has_add (finset (finset (has_pos_part pos))))) : topological_space.separable_space (has_add (finset (finset (has_pos_part pos)))) := sorry --non-trivial
lemma new_lemma_14919 (h0 : functor.add_const (semiring (normed_comm_ring unsigned)) Type) : @is_noetherian_ring.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 1} (semiring.{0} (normed_comm_ring.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_14920 (h2 : complete_lattice (complete_semilattice_Sup fun_info)) : complete_lattice.is_Sup_finite_compact (complete_semilattice_Sup fun_info) := sorry --non-trivial
lemma new_lemma_14921 (h0 : functor.add_const (ring (complete_distrib_lattice unsigned)) linarith.comp) : @rank_condition.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_14922 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_14923 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (normed_linear_ordered_group unsigned)) := sorry --non-trivial
lemma new_lemma_14924 (h0 : functor.add_const (topological_space (has_zero ennreal)) num) : @preirreducible_space.{0} (has_zero.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_14925 (h0 : topological_space (has_nndist (comm_group (comm_group Type)))) : preirreducible_space (has_nndist (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_14926 (h0 : functor.add_const (add_group (complete_distrib_lattice name)) (ring pos)) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (complete_distrib_lattice.{0} name)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_14927 (h0 : group (partial_order (semiring (semiring (semiring (semiring unsigned)))))) : is_cyclic (partial_order (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_14928 (h0 : add_group (has_add linarith.comp)) : is_add_cyclic (has_add linarith.comp) := sorry --non-trivial
lemma new_lemma_14929 (h0 : functor.add_const (topological_space (has_nndist pos)) (has_neg (ring (ring Type)))) : @topological_space.separable_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} pos)) (has_neg.{1} (ring.{1} (ring.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_14930 (h0 : functor.add_const (group (cancel_monoid pos)) (option unsigned)) : @normalizer_condition.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (cancel_monoid.{0} pos)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_14931 (h0 : functor.add_const (add_monoid (comm_group pos)) Type) : @add_monoid.fg.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (add_monoid.{0} (comm_group.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_14932 (h0 : filter (normed_comm_ring Type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_14933 (h0 : functor.add_const (uniform_space (mul_zero_class empty)) num) : @separated_space.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (mul_zero_class.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_14934 (h0 : complete_lattice (normed_group (has_top unsigned))) : complete_lattice.is_Sup_finite_compact (normed_group (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_14935 (h0 : finset (has_zero (option (option (option (option unsigned)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_14936 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_14937 (h0 : add_group (plift unsigned)) : is_add_cyclic (plift unsigned) := sorry --non-trivial
lemma new_lemma_14938 (h0 : not (group (add_group unsigned) -> false)) : @normalizer_condition.{0} (add_group.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (add_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_14939 (h0 : functor.add_const (filter (boolean_algebra linarith.comp)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_14940 (h0 : ring (has_add (has_pos_part Type))) : rank_condition (has_add (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_14941 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_14942 (h0 : functor.add_const (complete_lattice (has_to_string linarith.comp)) (finset (has_nndist Type))) : @is_compactly_generated.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_to_string.{0} linarith.comp)) (finset.{1} (has_nndist.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_14943 (h0 : ordered_comm_monoid (has_add (option (option pos)))) : has_exists_mul_of_le (has_add (option (option pos))) := sorry --non-trivial
lemma new_lemma_14944 (h0 : topological_space (canonically_linear_ordered_monoid (option ennreal))) : totally_separated_space (canonically_linear_ordered_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_14945 (h1 : topological_space (has_compl fun_info)) : path_connected_space (has_compl fun_info) := sorry --non-trivial
lemma new_lemma_14946 (h1 : has_lt (has_div string_imp)) : no_max_order (has_div string_imp) := sorry --non-trivial
lemma new_lemma_14947 (h0 : topological_space (comm_semigroup (sub_neg_monoid (boolean_algebra name)))) : preirreducible_space (comm_semigroup (sub_neg_monoid (boolean_algebra name))) := sorry --non-trivial
lemma new_lemma_14948 (h0 : complete_lattice (topological_space fun_info)) : is_compactly_generated (topological_space fun_info) := sorry --non-trivial
lemma new_lemma_14949 (h0 : functor.add_const (complete_lattice (normed_comm_ring linarith.comp)) linarith.comp) : @is_compactly_generated.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_14950 (h0 : group (measure_theory.measure_space congr_arg_kind)) : is_cyclic (measure_theory.measure_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_14951 (h0 : group (has_zero (finset (pseudo_metric_space (has_neg Type))))) : group.fg (has_zero (finset (pseudo_metric_space (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_14952 (h0 : list (add_cancel_monoid (has_neg environment.implicit_infer_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_14953 (h0 : topological_space (has_add num)) : preirreducible_space (has_add num) := sorry --non-trivial
lemma new_lemma_14954 (h0 : semiring (with_bot (has_top fun_info))) : is_noetherian_ring (with_bot (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_14955 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) environment.implicit_infer_kind) : @t0_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_14956 (h0 : functor.comp topological_space canonically_ordered_comm_semiring pos) : @preconnected_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_14957 (h0 : not (topological_space (partial_order unsigned) -> false)) : @preirreducible_space.{0} (partial_order.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (partial_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_14958 (h0 : ring (with_bot (semiring (semiring (semiring (semiring congr_arg_kind)))))) : is_domain (with_bot (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_14959 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_14960 (h0 : ordered_add_comm_monoid (add_cancel_monoid (finset (finset linarith.comp)))) : archimedean (add_cancel_monoid (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_14961 (h0 : has_mem.mem (with_one num) has_emptyc.emptyc) : @rank_condition.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (with_one.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_14962 (h0 : functor.add_const (group (comm_group linarith.comp)) linarith.comp) : @group.fg.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_14963 (h0 : uniform_space (complete_linear_order ereal)) : complete_space (complete_linear_order ereal) := sorry --non-trivial
lemma new_lemma_14964 (h0 : complete_lattice (has_norm (has_inv fun_info))) : complete_lattice.is_Sup_finite_compact (has_norm (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_14965 (h0 : add_group (measurable_space linarith.comp_source)) : is_add_cyclic (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_14966 (h0 : functor.add_const (topological_space (ordered_cancel_add_comm_monoid unsigned)) unsigned) : @totally_disconnected_space.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_cancel_add_comm_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_14967 (h0 : topological_space (add_cancel_monoid (normed_comm_ring Type))) : path_connected_space (add_cancel_monoid (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_14968 (h0 : functor.add_const (topological_space (mul_zero_class congr_arg_kind)) unsigned) : @t1_space.{0} (mul_zero_class.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_14969 (h0 : complete_lattice (semi_normed_ring string_imp)) : complete_lattice.is_Sup_finite_compact (semi_normed_ring string_imp) := sorry --non-trivial
lemma new_lemma_14970 (h1 : topological_space (div_inv_monoid string_imp)) : path_connected_space (div_inv_monoid string_imp) := sorry --non-trivial
lemma new_lemma_14971 (h0 : uniform_space (has_to_string (finset pos))) : complete_space (has_to_string (finset pos)) := sorry --non-trivial
lemma new_lemma_14972 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_14973 (h0 : functor.add_const (add_monoid (has_zero name)) unsigned) : @add_monoid.fg.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_zero.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_14974 (h0 : not (complete_lattice (linear_ordered_semiring num) -> false)) : @is_compactly_generated.{0} (linear_ordered_semiring.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_14975 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) Type) := sorry --non-trivial
lemma new_lemma_14976 (h1 : ring (normed_field ereal)) : strong_rank_condition (normed_field ereal) := sorry --non-trivial
lemma new_lemma_14977 (h0 : functor.add_const (function.extfun Type monoid) unsigned) : @monoid.fg.{0} (complete_distrib_lattice.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) unsigned h0) (complete_distrib_lattice.{0} num))  := sorry --non-trivial
lemma new_lemma_14978 (h0 : functor.add_const (ring (ring Type)) pos) : @rank_condition.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_14979 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_bot.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_14980 (h0 : semiring (linear_ordered_comm_group (option (option (option (option (option empty))))))) : is_noetherian_ring (linear_ordered_comm_group (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_14981 (h0 : functor.add_const (ring (has_nndist pos)) Type) : @is_principal_ideal_ring.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_nndist.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_14982 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_14983 (h0 : ring (denumerable (random_gen (random_gen linarith.ineq)))) : strong_rank_condition (denumerable (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_14984 (h0 : topological_space (canonically_ordered_comm_semiring (has_neg (has_Inf Type)))) : locally_compact_space (canonically_ordered_comm_semiring (has_neg (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_14985 (h0 : ring (linear_ordered_semiring (has_norm empty))) : strong_rank_condition (linear_ordered_semiring (has_norm empty)) := sorry --non-trivial
lemma new_lemma_14986 (h0 : topological_space (has_bot pos)) : preconnected_space (has_bot pos) := sorry --non-trivial
lemma new_lemma_14987 (h0 : not (ring (has_ssubset (mul_one_class reducibility_hints)) -> false)) : @rank_condition.{0} (has_ssubset.{0} (mul_one_class.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} (mul_one_class.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_14988 (h0 : topological_space (id (complete_semilattice_Sup (semiring congr_arg_kind)))) : normal_space (id (complete_semilattice_Sup (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_14989 (h0 : not (topological_space (semiring num) -> false)) : @irreducible_space.{0} (semiring.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_14990 (h2 : topological_space fun_info) (h3 : preorder fun_info) : order_closed_topology fun_info := sorry --non-trivial
lemma new_lemma_14991 (h0 : group (partial_order (semiring (semiring (semiring (semiring num)))))) : normalizer_condition (partial_order (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_14992 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_14993 (h0 : topological_space (semigroup (boolean_algebra.core environment.implicit_infer_kind))) : path_connected_space (semigroup (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_14994 (h0 : functor.add_const (filter (has_add name)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_14995 (h0 : add_monoid (has_add pos)) : add_monoid.fg (has_add pos) := sorry --non-trivial
lemma new_lemma_14996 (h0 : functor.add_const (topological_space (boolean_algebra.core environment.implicit_infer_kind)) Type) : @path_connected_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_14997 (h0 : list (has_dist (option empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_14998 (h0 : topological_space (plift congr_arg_kind)) : discrete_topology (plift congr_arg_kind) := sorry --non-trivial
lemma new_lemma_14999 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (has_add.{0} name) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_add.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_15000 (h0 : not (uniform_space (uniform_space (mul_one_class string_imp)) -> false)) : @complete_space.{0} (uniform_space.{0} (mul_one_class.{0} string_imp)) (@classical.by_contradiction'.{1} (uniform_space.{0} (uniform_space.{0} (mul_one_class.{0} string_imp))) h0)  := sorry --non-trivial
lemma new_lemma_15001 (h1 : ring (add_monoid (has_nnnorm char))) : is_domain (add_monoid (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_15002 (h0 : group (ring (has_neg (has_neg Type)))) : is_cyclic (ring (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_15003 (h0 : cancel_comm_monoid_with_zero (semiring (semiring unsigned))) : unique_factorization_monoid (semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_15004 (h0 : list (comm_group name)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_15005 (h0 : topological_space (ordered_comm_ring (boolean_algebra.core (ring (boolean_algebra.core Type))))) : preirreducible_space (ordered_comm_ring (boolean_algebra.core (ring (boolean_algebra.core Type)))) := sorry --non-trivial
lemma new_lemma_15006 (h0 : function.extfun (Type 1) ring) : @is_domain.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_15007 (h1 : topological_space (has_le environment.projection_info)) : path_connected_space (has_le environment.projection_info) := sorry --non-trivial
lemma new_lemma_15008 (h0 : functor.add_const (uniform_space (has_neg_part Type)) unsigned) : @separated_space.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_neg_part.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_15009 (h0 : not (complete_lattice (has_ssubset reducibility_hints) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_ssubset.{0} reducibility_hints) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_ssubset.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_15010 (h0 : functor.add_const (topological_space (finset pos)) pos) : @totally_disconnected_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_15011 (h0 : functor.comp monoid comm_group unsigned) : @monoid.fg.{0} (comm_group.{0} unsigned) (@functor.comp.run.{0 0 0} monoid.{0} comm_group.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_15012 (h5 : topological_space (mul_one_class ereal)) : path_connected_space (mul_one_class ereal) := sorry --non-trivial
lemma new_lemma_15013 (h0 : not (list nnreal -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_15014 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (mul_zero_class.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_15015 (h0 : function.extfun (Type 1) complete_lattice) : @is_compactly_generated.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_15016 (h0 : functor.add_const (ring (plift unsigned)) empty) : @is_principal_ideal_ring.{1} (plift.{1} unsigned) (@functor.add_const.run.{1 0} (ring.{1} (plift.{1} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_15017 (h0 : functor.add_const (functor.comp add_group add_comm_monoid unsigned) pos) : @is_add_cyclic.{0} (add_comm_monoid.{0} unsigned) (@functor.comp.run.{0 0 0} add_group.{0} add_comm_monoid.{0} unsigned (@functor.add_const.run.{0 1} (functor.comp.{0 0 0} add_group.{0} add_comm_monoid.{0} unsigned) Type (@functor.comp.run.{0 0 0} add_group.{0} add_comm_monoid.{0} unsigned (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} add_group.{0} add_comm_monoid.{0} unsigned) pos h0))))  := sorry --non-trivial
lemma new_lemma_15018 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (add_left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_15019 (h0 : ring (sub_neg_monoid (has_Inf pos))) : is_principal_ideal_ring (sub_neg_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_15020 (h0 : topological_space (add_cancel_monoid empty)) : path_connected_space (add_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_15021 (h0 : not (complete_lattice (linear_ordered_semiring empty) -> false)) : @is_atomistic.{0} (linear_ordered_semiring.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_15022 (h0 : ring (has_top string_imp)) : strong_rank_condition (has_top string_imp) := sorry --non-trivial
lemma new_lemma_15023 (h0 : add_group (has_neg_part environment.projection_info)) : is_add_cyclic (has_neg_part environment.projection_info) := sorry --non-trivial
lemma new_lemma_15024 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_sub empty)) num) : @unique_factorization_monoid.{0} (has_sub.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_sub.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_15025 (h0 : topological_space (ordered_comm_monoid (has_pos_part (ordered_comm_monoid Type)))) : locally_compact_space (ordered_comm_monoid (has_pos_part (ordered_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_15026 (h0 : functor.add_const (ordered_comm_monoid (has_nndist linarith.comp)) name) : @has_exists_mul_of_le.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_nndist.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_15027 (h0 : function.extfun (Type 1) (functor.add_const (monoid Type))) : @monoid.fg.{1} Type (@functor.add_const.run.{1 1} (monoid.{1} Type) (finset.{1} (finset.{1} (finset.{1} (finset.{1} (has_add.{1} Type))))) (@function.extfun_app.{3 2} (Type 1) (functor.add_const.{1 1} (monoid.{1} Type)) h0 (finset.{1} (finset.{1} (finset.{1} (finset.{1} (has_add.{1} Type)))))))  := sorry --non-trivial
lemma new_lemma_15028 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (is_R_or_C.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (is_R_or_C.{0} empty))  := sorry --non-trivial
lemma new_lemma_15029 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) pos) : @topological_space.separable_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_15030 (h0 : add_comm_monoid (option (option ennreal)) -> add_comm_monoid (option (option ennreal)) -> Prop) : is_symm (add_comm_monoid (option (option ennreal))) h0 := sorry --non-trivial
lemma new_lemma_15031 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_15032 (h0 : topological_space (distrib (mul_one_class (mul_one_class (mul_one_class string.iterator_imp))))) : t0_space (distrib (mul_one_class (mul_one_class (mul_one_class string.iterator_imp)))) := sorry --non-trivial
lemma new_lemma_15033 (h0 : topological_space (finset (finset (finset pos)))) : loc_path_connected_space (finset (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_15034 (h1 : filter (linear_ordered_add_comm_group string_imp)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_15035 (h0 : topological_space (measurable_space (random_gen linarith.ineq))) : irreducible_space (measurable_space (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_15036 (h0 : ring (sub_neg_monoid (has_add pos))) : is_principal_ideal_ring (sub_neg_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_15037 (h2 : measurable_space string.iterator_imp) (h3 : filter string.iterator_imp) : filter.is_measurably_generated h3 := sorry --non-trivial
lemma new_lemma_15038 (h0 : uniform_space (topological_space (has_lt (comm_ring (denumerable (comm_ring char)))))) : complete_space (topological_space (has_lt (comm_ring (denumerable (comm_ring char))))) := sorry --non-trivial
lemma new_lemma_15039 (h0 : topological_space (has_norm (has_norm empty))) : path_connected_space (has_norm (has_norm empty)) := sorry --non-trivial
lemma new_lemma_15040 (h0 : functor.add_const Prop (has_to_string (option pos))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_15041 (h0 : topological_space (semigroup (add_comm_monoid Type))) : sequential_space (semigroup (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_15042 (h0 : add_group (monoid (canonically_ordered_add_monoid unsigned))) : is_add_cyclic (monoid (canonically_ordered_add_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_15043 (h0 : ordered_comm_monoid (has_pos_part (has_add (has_pos_part linarith.comp)))) : has_exists_mul_of_le (has_pos_part (has_add (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_15044 (h0 : group (boolean_algebra congr_arg_kind)) : group.fg (boolean_algebra congr_arg_kind) := sorry --non-trivial
lemma new_lemma_15045 (h0 : function.extfun Type topological_space) : @t0_space.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_15046 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_disconnected_space.{0} (@id.{2} Type (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty))))) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (@id.{2} Type (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty))))))  := sorry --non-trivial
lemma new_lemma_15047 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_15048 (h0 : function.extfun Type (functor.add_const (add_monoid (ordered_comm_group empty)))) : @add_monoid.fg.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (ordered_comm_group.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_monoid.{0} (ordered_comm_group.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_15049 (h0 : set (mul_one_class (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup fun_info))) -> char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_15050 (h0 : cancel_comm_monoid_with_zero (semiring (semiring empty))) : unique_factorization_monoid (semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_15051 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_15052 (h0 : set (fun_info -> add_comm_semigroup ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_15053 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_15054 (h0 : topological_space (monoid empty)) : preirreducible_space (monoid empty) := sorry --non-trivial
lemma new_lemma_15055 (h0 : ring (boolean_algebra.core Type)) : rank_condition (boolean_algebra.core Type) := sorry --non-trivial
lemma new_lemma_15056 (h0 : functor.comp topological_space comm_ring to_additive.value_type) : @totally_disconnected_space.{0} (comm_ring.{0} to_additive.value_type) (@functor.comp.run.{0 0 0} topological_space.{0} comm_ring.{0} to_additive.value_type h0)  := sorry --non-trivial
lemma new_lemma_15057 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_cancel_monoid linarith.comp)) Type) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (add_cancel_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_15058 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (has_neg congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_15059 (h0 : topological_space (add_group (semiring congr_arg_kind))) : irreducible_space (add_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_15060 (h0 : functor.add_const (topological_space (pseudo_metric_space ennreal)) pos) : @locally_compact_space.{0} (pseudo_metric_space.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_15061 (h0 : topological_space (has_add (normed_comm_ring Type))) : topological_space.separable_space (has_add (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_15062 (h0 : functor.add_const (topological_space (pseudo_metric_space ennreal)) ennreal) : @path_connected_space.{0} (pseudo_metric_space.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_15063 (h0 : filter (has_top (has_norm (has_norm fun_info)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_15064 (h0 : not (topological_space (has_one empty) -> false)) : @locally_compact_space.{0} (has_one.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_one.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_15065 (h0 : topological_space (has_to_string (comm_group pos))) : regular_space (has_to_string (comm_group pos)) := sorry --non-trivial
lemma new_lemma_15066 (h0 : uniform_space (ring (has_Inf (has_Inf pos)))) : complete_space (ring (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_15067 (h0 : functor.add_const (list (has_neg linarith.comp)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_15068 (h0 : functor.add_const (topological_space (preorder unsigned)) empty) : @totally_separated_space.{0} (preorder.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_15069 (h1 : group (complete_semilattice_Sup linarith.comp)) : is_cyclic (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_15070 (h0 : functor.add_const (topological_space (ordered_ring empty)) (semiring unsigned)) : @discrete_topology.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} empty)) (semiring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_15071 (h0 : topological_space (has_pos_part (has_Inf linarith.comp))) : irreducible_space (has_pos_part (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_15072 (h0 : topological_space (has_compl (has_ssubset string_imp))) : path_connected_space (has_compl (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_15073 (h0 : ring (generalized_boolean_algebra (generalized_boolean_algebra (has_nndist name)))) : rank_condition (generalized_boolean_algebra (generalized_boolean_algebra (has_nndist name))) := sorry --non-trivial
lemma new_lemma_15074 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_15075 (h0 : functor.add_const (topological_space (partial_order empty)) (semiring num)) : @locally_compact_space.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} empty)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_15076 (h0 : list (mul_zero_class (finset environment.implicit_infer_kind))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_15077 (h0 : group (canonically_linear_ordered_monoid name)) : is_simple_group (canonically_linear_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_15078 (h0 : complete_lattice (canonically_ordered_comm_semiring (has_neg_part Type))) : is_compactly_generated (canonically_ordered_comm_semiring (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_15079 (h0 : has_mem.mem (id empty) has_emptyc.emptyc) : filter.ne_bot (finset.pi.empty filter (id empty) h0) := sorry --non-trivial
lemma new_lemma_15080 (h0 : functor.add_const (function.extfun Type complete_lattice) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) linarith.comp h0) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_15081 (h0 : list (ring (has_neg_part unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_15082 (h1 : topological_space std_gen) (h2 : set (set std_gen)) : topological_space.is_topological_basis h2 := sorry --non-trivial
lemma new_lemma_15083 (h0 : ring (has_add (finset (finset ennreal)))) : strong_rank_condition (has_add (finset (finset ennreal))) := sorry --non-trivial
lemma new_lemma_15084 (h0 : functor.add_const (ring (cancel_monoid unsigned)) (option (option (option empty)))) : @strong_rank_condition.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (cancel_monoid.{0} unsigned)) (option.{0} (option.{0} (option.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_15085 (h0 : function.extfun Type ring) : @is_domain.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_15086 (h0 : topological_space (non_unital_non_assoc_semiring (mul_one_class string.iterator_imp))) : path_connected_space (non_unital_non_assoc_semiring (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_15087 (h2 : complete_lattice string_imp) : is_compactly_generated string_imp := sorry --non-trivial
lemma new_lemma_15088 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_15089 (h0 : functor.add_const (group (finset Type)) (has_nndist linarith.comp)) : @group.fg.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (finset.{1} Type)) (has_nndist.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_15090 (h0 : topological_space (complete_distrib_lattice (canonically_ordered_add_monoid (monoid unsigned)))) : path_connected_space (complete_distrib_lattice (canonically_ordered_add_monoid (monoid unsigned))) := sorry --non-trivial
lemma new_lemma_15091 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (canonically_ordered_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_15092 (h0 : function.extfun Type ring) : @is_domain.{0} auto.case_option (@function.extfun_app.{2 1} Type ring.{0} h0 auto.case_option)  := sorry --non-trivial
lemma new_lemma_15093 (h1 : topological_space (has_top (has_ssubset string_imp))) : t0_space (has_top (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_15094 (h0 : functor.add_const Prop (linear_ordered_field congr_arg_kind)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_15095 (h0 : topological_space (has_to_string (has_to_string (finset (finset linarith.comp))))) : path_connected_space (has_to_string (has_to_string (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_15096 (h0 : topological_space (generalized_boolean_algebra linarith.comp)) : normal_space (generalized_boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_15097 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (measurable_space.{0} (has_norm.{0} linarith.ineq)) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (measurable_space.{0} (has_norm.{0} linarith.ineq)))  := sorry --non-trivial
lemma new_lemma_15098 (h0 : functor.add_const (function.extfun (Type 1) ring) (finset environment.implicit_infer_kind)) : @is_principal_ideal_ring.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) (finset.{0} environment.implicit_infer_kind) h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_15099 (h0 : group (has_bot (has_Inf pos))) : is_cyclic (has_bot (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_15100 (h0 : topological_space (semigroup (finset (ring ennreal)))) : discrete_topology (semigroup (finset (ring ennreal))) := sorry --non-trivial
lemma new_lemma_15101 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_15102 (h0 : topological_space (ordered_cancel_add_comm_monoid unsigned)) : t1_space (ordered_cancel_add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_15103 (h0 : fin has_zero.zero) : @is_simple_group.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) h0) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_15104 (h0 : ordered_comm_monoid (comm_group (option (option (option ennreal))))) : has_exists_mul_of_le (comm_group (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_15105 (h0 : functor.add_const (group (has_neg pos)) Type) : @is_simple_group.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (has_neg.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_15106 (h0 : uniform_space (random_gen (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source))))) : complete_space (random_gen (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_15107 (h0 : topological_space (complete_distrib_lattice (option (option (option ennreal))))) : irreducible_space (complete_distrib_lattice (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_15108 (h0 : functor.add_const (group (bin_tree num)) (semiring empty)) : @normalizer_condition.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (group.{0} (bin_tree.{0} num)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_15109 (h1 : ring (measurable_space (has_norm congr_arg_kind))) : strong_rank_condition (measurable_space (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_15110 (h0 : uniform_space (div_inv_monoid (has_nnnorm fun_info))) : complete_space (div_inv_monoid (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_15111 (h0 : functor.add_const (cancel_comm_monoid_with_zero (semigroup linarith.comp)) (has_neg_part (has_neg_part Type))) : @unique_factorization_monoid.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (semigroup.{0} linarith.comp)) (has_neg_part.{1} (has_neg_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_15112 (h0 : topological_space (sub_neg_monoid linarith.comp)) : preirreducible_space (sub_neg_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_15113 (h0 : complete_lattice (has_star (semiring unsigned))) : is_compactly_generated (has_star (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_15114 (h1 : topological_space (with_zero (has_nnnorm char))) : t0_space (with_zero (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_15115 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) environment.implicit_infer_kind) : @totally_separated_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_15116 (h1 : not (topological_space (semi_normed_ring linarith.ineq) -> false)) : @t0_space.{0} (semi_normed_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_ring.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_15117 (h0 : ring (add_left_cancel_monoid (has_nnnorm (has_nnnorm fun_info)))) : is_domain (add_left_cancel_monoid (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_15118 (h0 : uniform_space (has_ssubset (metric_space linarith.comp_source))) : complete_space (has_ssubset (metric_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_15119 (h0 : filter (normed_lattice_add_comm_group (has_nndist pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_15120 (h0 : cancel_comm_monoid_with_zero (has_to_string (has_to_string (has_to_string pos)))) : unique_factorization_monoid (has_to_string (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_15121 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (mul_zero_class.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} empty))  := sorry --non-trivial
lemma new_lemma_15122 (h0 : complete_lattice (has_norm empty)) : is_compactly_generated (has_norm empty) := sorry --non-trivial
lemma new_lemma_15123 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_15124 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) linarith.comp) : @loc_path_connected_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_15125 (h0 : topological_space (has_emptyc (has_top (has_top linarith.comp_source)))) : totally_disconnected_space (has_emptyc (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_15126 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf pos))) : t0_space (normed_lattice_add_comm_group (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_15127 (h0 : complete_lattice (with_one (random_gen (random_gen string_imp)))) : complete_lattice.is_Sup_finite_compact (with_one (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_15128 (h0 : group (has_Inf real)) : group.fg (has_Inf real) := sorry --non-trivial
lemma new_lemma_15129 (h0 : topological_space (complete_semilattice_Sup linarith.comp)) : preirreducible_space (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_15130 (h0 : functor.add_const (filter (finset name)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_15131 (h0 : ring (has_nndist ennreal)) : invariant_basis_number (has_nndist ennreal) := sorry --non-trivial
lemma new_lemma_15132 (h0 : function.extfun Type topological_space) : @t0_space.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_15133 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg name)) : @t0_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{0} name) h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_15134 (h0 : list (filter unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_15135 (h0 : not (complete_lattice (mul_one_class reducibility_hints) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (mul_one_class.{0} reducibility_hints) (@classical.by_contradiction'.{1} (complete_lattice.{0} (mul_one_class.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_15136 (h0 : functor.add_const (function.extfun Type finset) Type) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_15137 (h1 : ring (simple_graph string_imp)) : rank_condition (simple_graph string_imp) := sorry --non-trivial
lemma new_lemma_15138 (h1 : not (ring ennreal -> false)) : @is_domain.{0} ennreal (@classical.by_contradiction'.{1} (ring.{0} ennreal) h1)  := sorry --non-trivial
lemma new_lemma_15139 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_top.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} fun_info))))))) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_top.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} fun_info))))))))  := sorry --non-trivial
lemma new_lemma_15140 (h0 : not (finset (linear_ordered_comm_ring congr_arg_kind) -> false)) : finset.nonempty (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_15141 (h1 : topological_space (distrib_lattice linarith.comp_source)) : totally_separated_space (distrib_lattice linarith.comp_source) := sorry --non-trivial
lemma new_lemma_15142 (h0 : filter (boolean_algebra (comm_group (comm_group Type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_15143 (h0 : functor.add_const (ring (has_to_string Type)) pos) : @is_principal_ideal_ring.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_to_string.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_15144 (h0 : ring (finset (finset Type))) : is_domain (finset (finset Type)) := sorry --non-trivial
lemma new_lemma_15145 (h0 : topological_space (has_neg (has_neg_part pos))) : loc_path_connected_space (has_neg (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_15146 (h0 : topological_space (has_compl (has_ssubset string_imp))) : totally_disconnected_space (has_compl (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_15147 (h0 : add_group (has_top (random_gen (random_gen (random_gen (random_gen fun_info)))))) : is_add_cyclic (has_top (random_gen (random_gen (random_gen (random_gen fun_info))))) := sorry --non-trivial
lemma new_lemma_15148 (h0 : functor.add_const (complete_lattice (has_neg Type)) name) : @is_compactly_generated.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_neg.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_15149 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) pos) : @topological_space.separable_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_15150 (h0 : ring (denumerable (has_nnnorm (has_nnnorm linarith.ineq)))) : is_domain (denumerable (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_15151 (h0 : functor.add_const (complete_lattice (finset environment.implicit_infer_kind)) linarith.comp) : @is_compactly_generated.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_15152 (h0 : functor.add_const (topological_space (bin_tree congr_arg_kind)) congr_arg_kind) : @totally_disconnected_space.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_15153 (h0 : topological_space (add_comm_monoid real)) : t0_space (add_comm_monoid real) := sorry --non-trivial
lemma new_lemma_15154 (h1 : topological_space (has_emptyc congr_arg_kind)) : totally_disconnected_space (has_emptyc congr_arg_kind) := sorry --non-trivial
lemma new_lemma_15155 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) pos) : @loc_path_connected_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_15156 (h0 : topological_space (complete_distrib_lattice (has_add environment.implicit_infer_kind))) : totally_separated_space (complete_distrib_lattice (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_15157 (h0 : ring (canonically_ordered_comm_semiring name)) : is_principal_ideal_ring (canonically_ordered_comm_semiring name) := sorry --non-trivial
lemma new_lemma_15158 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring linarith.comp)) Type) : @sequential_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_15159 (h0 : ring (with_bot (has_norm (random_gen congr_arg_kind)))) : is_domain (with_bot (has_norm (random_gen congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_15160 (h0 : topological_space (semigroup (has_add (has_Inf linarith.comp)))) : locally_compact_space (semigroup (has_add (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_15161 (h0 : topological_space (complete_semilattice_Sup (semiring congr_arg_kind))) : preirreducible_space (complete_semilattice_Sup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_15162 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_15163 (h0 : uniform_space (boolean_algebra.core (has_add pos))) : separated_space (boolean_algebra.core (has_add pos)) := sorry --non-trivial
lemma new_lemma_15164 (h0 : topological_space (has_edist num)) : totally_separated_space (has_edist num) := sorry --non-trivial
lemma new_lemma_15165 (h0 : functor.add_const (topological_space (has_neg_part pos)) name) : @irreducible_space.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_15166 (h0 : topological_space (canonically_ordered_comm_semiring (has_neg name))) : preconnected_space (canonically_ordered_comm_semiring (has_neg name)) := sorry --non-trivial
lemma new_lemma_15167 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_15168 (h0 : group (has_to_string (has_to_string Type))) : normalizer_condition (has_to_string (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_15169 (h0 : functor.comp group finset Type) : @group.fg.{1} (finset.{1} Type) (@functor.comp.run.{1 1 1} group.{1} finset.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_15170 (h0 : semiring (add_comm_semigroup ereal)) (h2 : ideal (add_comm_semigroup ereal)) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_15171 (h0 : topological_space (option (option pos))) : preconnected_space (option (option pos)) := sorry --non-trivial
lemma new_lemma_15172 (h0 : list (with_one (has_top fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_15173 (h0 : functor.add_const (function.extfun Type group) (has_pos_part pos)) : @normalizer_condition.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) (has_pos_part.{0} pos) h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_15174 (h0 : functor.add_const (topological_space (free_add_monoid congr_arg_kind)) unsigned) : @loc_path_connected_space.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_15175 (h0 : fun_info -> fun_info -> Prop) : equivalence h0 := sorry --non-trivial
lemma new_lemma_15176 (h0 : uniform_space (has_ssubset (add_comm_semigroup enat))) : complete_space (has_ssubset (add_comm_semigroup enat)) := sorry --non-trivial
lemma new_lemma_15177 (h0 : functor.add_const (functor.add_const Prop (ring Type)) Type) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_15178 (h0 : not (ring (has_compl string_imp) -> false)) : @strong_rank_condition.{0} (has_compl.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_15179 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_15180 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_dist.{0} num) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_dist.{0} num))  := sorry --non-trivial
lemma new_lemma_15181 (h0 : functor.add_const (function.extfun Type ring) Type) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_15182 (h0 : list (has_star (semiring (semiring (semiring empty))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_15183 (h0 : not (uniform_space (id to_additive.value_type) -> false)) : @complete_space.{0} (@id.{2} Type to_additive.value_type) (@classical.by_contradiction'.{1} (uniform_space.{0} (@id.{2} Type to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_15184 (h1 : not (ring (has_append fun_info) -> false)) : @rank_condition.{0} (has_append.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (has_append.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_15185 (h0 : topological_space (has_add (comm_semigroup (has_bot (sub_neg_monoid real))))) : path_connected_space (has_add (comm_semigroup (has_bot (sub_neg_monoid real)))) := sorry --non-trivial
lemma new_lemma_15186 (h0 : functor.add_const (function.extfun Type group) pos) : @normalizer_condition.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_15187 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_15188 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (with_bot.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (with_bot.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_15189 (h0 : set (mul_one_class (add_comm_semigroup string.iterator_imp) -> add_comm_semigroup enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_15190 (h0 : topological_space (semigroup (has_neg name))) : irreducible_space (semigroup (has_neg name)) := sorry --non-trivial
lemma new_lemma_15191 (h0 : functor.add_const (semiring (finset name)) name) : @is_noetherian_ring.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (finset.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_15192 (h0 : topological_space (normed_comm_ring (has_add pos))) : preirreducible_space (normed_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_15193 (h0 : functor.add_const (functor.add_const (topological_space znum) empty) unsigned) : @discrete_topology.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} znum) empty) unsigned h0))  := sorry --non-trivial
lemma new_lemma_15194 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @rank_condition.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_15195 (h0 : topological_space (has_add (ring (has_add (has_add (has_add linarith.comp)))))) : sequential_space (has_add (ring (has_add (has_add (has_add linarith.comp))))) := sorry --non-trivial
lemma new_lemma_15196 (h0 : functor.add_const (uniform_space (has_zero Type)) (ring linarith.comp)) : @complete_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_zero.{1} Type)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_15197 (h0 : ring (add_cancel_comm_monoid (has_nnnorm linarith.comp_source))) : is_domain (add_cancel_comm_monoid (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_15198 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (complete_distrib_lattice.{0} linarith.comp) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (complete_distrib_lattice.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_15199 (h2 : set (has_ssubset char)) : set.finite h2 := sorry --non-trivial
lemma new_lemma_15200 (h0 : functor.add_const (finset (is_R_or_C unsigned)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_15201 (h0 : has_mem.mem (semiring linarith.comp_source) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (semiring.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_15202 (h0 : topological_space (canonically_linear_ordered_monoid (option ennreal))) : preconnected_space (canonically_linear_ordered_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_15203 (h0 : uniform_space (distrib_lattice (random_gen to_additive.value_type))) : complete_space (distrib_lattice (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_15204 (h0 : filter (boolean_algebra (comm_group (comm_group pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_15205 (h0 : finset (has_neg_part unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_15206 (h0 : group (canonically_linear_ordered_monoid (has_Inf pos))) : is_cyclic (canonically_linear_ordered_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_15207 (h0 : not (group (random_gen empty) -> false)) : @group.fg.{0} (random_gen.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (random_gen.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_15208 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) linarith.comp) : @irreducible_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_15209 (h0 : ring (canonically_ordered_comm_semiring (comm_group Type))) : rank_condition (canonically_ordered_comm_semiring (comm_group Type)) := sorry --non-trivial
lemma new_lemma_15210 (h0 : uniform_space (add_left_cancel_semigroup unsigned)) : complete_space (add_left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_15211 (h0 : not (uniform_space (add_left_cancel_monoid char) -> false)) : @complete_space.{0} (add_left_cancel_monoid.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (add_left_cancel_monoid.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_15212 (h0 : complete_lattice (linear_ordered_field (finset ennreal))) : is_atomistic (linear_ordered_field (finset ennreal)) := sorry --non-trivial
lemma new_lemma_15213 (h0 : topological_space (comm_ring (mul_one_class char))) : totally_disconnected_space (comm_ring (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_15214 (h0 : topological_space (preorder num)) : t1_space (preorder num) := sorry --non-trivial
lemma new_lemma_15215 (h0 : topological_space (measure_theory.measure_space num)) : t1_space (measure_theory.measure_space num) := sorry --non-trivial
lemma new_lemma_15216 (h1 : ring (has_inv string_imp)) : strong_rank_condition (has_inv string_imp) := sorry --non-trivial
lemma new_lemma_15217 (h0 : uniform_space (add_comm_monoid (ring (finset linarith.comp)))) : complete_space (add_comm_monoid (ring (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_15218 (h0 : ring (boolean_algebra (finset pos))) : strong_rank_condition (boolean_algebra (finset pos)) := sorry --non-trivial
lemma new_lemma_15219 (h0 : topological_space (generalized_boolean_algebra (has_neg (has_neg Type)))) : loc_path_connected_space (generalized_boolean_algebra (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_15220 (h0 : function.extfun Type (functor.add_const (uniform_space (ordered_ring empty)))) : @separated_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_ring.{0} empty)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (ordered_ring.{0} empty))) h0 num))  := sorry --non-trivial
lemma new_lemma_15221 (h0 : topological_space (boolean_algebra (has_Inf pos))) : totally_separated_space (boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_15222 (h0 : ordered_add_comm_monoid (normed_group string_imp)) : archimedean (normed_group string_imp) := sorry --non-trivial
lemma new_lemma_15223 (h0 : topological_space (normed_group (has_norm linarith.comp))) : totally_disconnected_space (normed_group (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_15224 (h0 : functor.add_const (finset (boolean_algebra Type)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_15225 (h0 : filter (with_zero (random_gen linarith.comp_source))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_15226 (h0 : functor.add_const (list (has_to_string Type)) environment.implicit_infer_kind) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_15227 (h0 : topological_space (has_edist (option (option (option empty))))) : irreducible_space (has_edist (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_15228 (h0 : ring (finset (option (option ennreal)))) : is_domain (finset (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_15229 (h0 : topological_space (ordered_comm_ring name)) : topological_space.separable_space (ordered_comm_ring name) := sorry --non-trivial
lemma new_lemma_15230 (h0 : has_mem.mem linarith.comp has_emptyc.emptyc) : @is_atomistic.{0} linarith.comp (@finset.pi.empty.{1 0} Type complete_lattice.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_15231 (h0 : functor.add_const (topological_space (normed_comm_ring name)) linarith.comp) : @topological_space.separable_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_15232 (h0 : list (complete_semilattice_Sup (has_ssubset (has_ssubset (random_gen fun_info))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_15233 (h0 : group (has_Inf (ring pos))) : normalizer_condition (has_Inf (ring pos)) := sorry --non-trivial
lemma new_lemma_15234 (h1 : monoid (with_one congr_arg_kind)) : monoid.fg (with_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_15235 (h0 : functor.add_const (semiring (has_Inf pos)) name) : @is_noetherian_ring.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (has_Inf.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_15236 (h1 : ring (topological_space fun_info)) : is_domain (topological_space fun_info) := sorry --non-trivial
lemma new_lemma_15237 (h0 : ring (has_to_string (has_pos_part name))) : is_domain (has_to_string (has_pos_part name)) := sorry --non-trivial
lemma new_lemma_15238 (h0 : add_group (measurable_space (random_gen (has_inv linarith.comp_source)))) : is_add_cyclic (measurable_space (random_gen (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_15239 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_15240 (h0 : not (topological_space (measurable_space.dynkin_system congr_arg_kind) -> false)) : @totally_disconnected_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_15241 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (comm_semigroup.{0} name) (@matrix.vec_empty.{0} (semiring.{0} (comm_semigroup.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_15242 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @totally_disconnected_space.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_15243 (h0 : functor.add_const (group (ordered_comm_monoid pos)) pos) : @normalizer_condition.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (ordered_comm_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_15244 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (div_inv_monoid.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (div_inv_monoid.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_15245 (h0 : functor.add_const (topological_space (has_to_string unsigned)) environment.implicit_infer_kind) : @t1_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_15246 (h0 : ring (canonically_ordered_add_monoid unsigned)) : is_principal_ideal_ring (canonically_ordered_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_15247 (h0 : monoid (has_neg (comm_group (comm_group Type)))) : monoid.fg (has_neg (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_15248 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (add_left_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_left_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_15249 (h1 : topological_space (fintype string_imp)) : t0_space (fintype string_imp) := sorry --non-trivial
lemma new_lemma_15250 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_15251 (h0 : topological_space (has_to_string (option (option ennreal)))) : t0_space (has_to_string (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_15252 (h0 : functor.add_const (uniform_space (has_to_string Type)) (has_to_string (has_to_string Type))) : @separated_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (has_to_string.{1} Type)) (has_to_string.{1} (has_to_string.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_15253 (h0 : topological_space (add_comm_monoid num)) : path_connected_space (add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_15254 (h0 : topological_space (has_pos_part (ordered_ring name))) : locally_compact_space (has_pos_part (ordered_ring name)) := sorry --non-trivial
lemma new_lemma_15255 (h0 : topological_space (boolean_algebra (has_Inf (has_neg linarith.comp)))) : t0_space (boolean_algebra (has_Inf (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_15256 (h0 : functor.add_const (functor.add_const (uniform_space nnreal) empty) num) : separated_space nnreal := sorry --non-trivial
lemma new_lemma_15257 (h0 : functor.add_const (group (add_comm_monoid Type)) Type) : @normalizer_condition.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (add_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_15258 (h0 : semiring (has_nndist (finset name))) : is_noetherian_ring (has_nndist (finset name)) := sorry --non-trivial
lemma new_lemma_15259 (h0 : not (group (add_group fun_info) -> false)) : @normalizer_condition.{0} (add_group.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (add_group.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_15260 (h0 : topological_space (comm_monoid (option unsigned))) : t0_space (comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_15261 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_15262 (h0 : topological_space (ordered_comm_ring linarith.comp)) : discrete_topology (ordered_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_15263 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_Inf name)) linarith.comp) : @unique_factorization_monoid.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_Inf.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_15264 (h0 : functor.add_const (list (add_cancel_monoid unsigned)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_15265 (h0 : group (has_add (has_neg Type))) : normalizer_condition (has_add (has_neg Type)) := sorry --non-trivial
lemma new_lemma_15266 (h0 : uniform_space (has_norm (has_norm linarith.comp))) : complete_space (has_norm (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_15267 (h0 : ring (mul_zero_class unsigned)) : is_principal_ideal_ring (mul_zero_class unsigned) := sorry --non-trivial
lemma new_lemma_15268 (h0 : topological_space (has_to_string name)) : irreducible_space (has_to_string name) := sorry --non-trivial
lemma new_lemma_15269 (h0 : topological_space (has_pos_part (finset linarith.comp))) : loc_path_connected_space (has_pos_part (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_15270 (h0 : topological_space (ordered_comm_monoid (canonically_ordered_monoid real))) : topological_space.separable_space (ordered_comm_monoid (canonically_ordered_monoid real)) := sorry --non-trivial
lemma new_lemma_15271 (h0 : functor.add_const (function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) linarith.comp) : @has_exists_mul_of_le.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) (@functor.add_const.run.{2 0} (function.extfun.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1))) linarith.comp h0) ordered_comm_monoid.{1}) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_15272 (h0 : topological_space (add_comm_monoid linarith.comp)) : loc_path_connected_space (add_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_15273 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) pos) : @preirreducible_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_15274 (h0 : add_zero_class (random_gen fun_info)) (h1 : topological_space (add_submonoid (random_gen fun_info))) : path_connected_space (add_submonoid (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_15275 (h0 : complete_lattice (comm_ring (has_nnnorm (has_nnnorm char)))) : complete_lattice.is_Sup_finite_compact (comm_ring (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_15276 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_15277 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_neg.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_neg.{0} num))  := sorry --non-trivial
lemma new_lemma_15278 (h1 : function.extfun Type complete_lattice) : is_atomistic (measurable_space string_imp) := sorry --non-trivial
lemma new_lemma_15279 (h0 : group (add_cancel_monoid (finset pos))) : is_cyclic (add_cancel_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_15280 (h0 : functor.add_const (ring (canonically_ordered_monoid pos)) linarith.comp) : @strong_rank_condition.{0} (canonically_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_15281 (h0 : group (add_group (has_norm (has_norm empty)))) : is_cyclic (add_group (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_15282 (h0 : topological_space (has_top (random_gen (random_gen (random_gen fun_info))))) : locally_compact_space (has_top (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_15283 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_15284 (h1 : uniform_space (has_ssubset reducibility_hints)) : complete_space (has_ssubset reducibility_hints) := sorry --non-trivial
lemma new_lemma_15285 (h0 : functor.add_const (semiring (semigroup linarith.comp)) linarith.comp) : @is_noetherian_ring.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (semigroup.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_15286 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (linear_ordered_comm_monoid_with_zero (option empty))) := sorry --non-trivial
lemma new_lemma_15287 (h0 : function.extfun Type topological_space) : @normal_space.{0} (ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_15288 (h0 : not (topological_space (div_inv_monoid congr_arg_kind) -> false)) : @preirreducible_space.{0} (div_inv_monoid.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (div_inv_monoid.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_15289 (h0 : group (cancel_monoid congr_arg_kind)) : normalizer_condition (cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_15290 (h0 : not (group num -> false)) : @normalizer_condition.{0} num (@classical.by_contradiction'.{1} (group.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_15291 (h0 : not (monoid (normed_group linarith.ineq) -> false)) : @monoid.fg.{0} (normed_group.{0} linarith.ineq) (@classical.by_contradiction'.{1} (monoid.{0} (normed_group.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_15292 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_add_cyclic.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) add_group.{0}) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_15293 (h0 : functor.add_const (ordered_comm_monoid (has_zero linarith.comp)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_zero.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_15294 (h0 : semiring (normed_comm_ring (boolean_algebra name))) : is_noetherian_ring (normed_comm_ring (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_15295 (h0 : topological_space (random_gen (random_gen (comm_ring linarith.ineq)))) : irreducible_space (random_gen (random_gen (comm_ring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_15296 (h0 : ring (pseudo_metric_space (finset (has_add name)))) : is_principal_ideal_ring (pseudo_metric_space (finset (has_add name))) := sorry --non-trivial
lemma new_lemma_15297 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_15298 (h0 : group (has_bot Type)) : group.fg (has_bot Type) := sorry --non-trivial
lemma new_lemma_15299 (h0 : functor.add_const (group (finset Type)) pos) : @is_simple_group.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (finset.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_15300 (h0 : topological_space (metric_space (has_top (has_top (has_top unsigned))))) : t0_space (metric_space (has_top (has_top (has_top unsigned)))) := sorry --non-trivial
lemma new_lemma_15301 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normalizer_condition.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_15302 (h0 : topological_space (has_emptyc (has_top to_additive.value_type))) : totally_disconnected_space (has_emptyc (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_15303 (h0 : topological_space (boolean_algebra (has_Inf (has_Inf Type)))) : normal_space (boolean_algebra (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_15304 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (preorder.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (preorder.{0} num))  := sorry --non-trivial
lemma new_lemma_15305 (h0 : functor.add_const (ring (boolean_algebra.core environment.implicit_infer_kind)) environment.implicit_infer_kind) : @strong_rank_condition.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_15306 (h0 : group (cancel_monoid linarith.comp)) : is_simple_group (cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_15307 (h0 : list (normed_comm_ring (ring linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_15308 (h0 : functor.add_const (ring (ordered_comm_monoid linarith.comp)) name) : @is_principal_ideal_ring.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_15309 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (random_gen.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (random_gen.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_15310 (h0 : group (has_neg_part (comm_group (has_neg_part pos)))) : is_cyclic (has_neg_part (comm_group (has_neg_part pos))) := sorry --non-trivial
lemma new_lemma_15311 (h0 : filter (has_inter (option num))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_15312 (h0 : functor.add_const (complete_lattice (has_bot empty)) unsigned) : @is_atomistic.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_bot.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_15313 (h0 : filter (linear_ordered_add_comm_group (random_gen (random_gen char)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_15314 (h0 : not (function.extfun Type topological_space -> false)) : @t1_space.{0} (mul_zero_class.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (mul_zero_class.{0} empty))  := sorry --non-trivial
lemma new_lemma_15315 (h0 : topological_space (add_cancel_monoid environment.implicit_infer_kind)) : normal_space (add_cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_15316 (h1 : complete_lattice (encodable (has_nnnorm (has_nnnorm fun_info)))) : is_compactly_generated (encodable (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_15317 (h0 : topological_space (monoid_with_zero (option ennreal))) : discrete_topology (monoid_with_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_15318 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (distrib_lattice linarith.ineq)) := sorry --non-trivial
lemma new_lemma_15319 (h0 : group (normed_group (random_gen (random_gen (random_gen fun_info))))) : normalizer_condition (normed_group (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_15320 (h0 : functor.add_const (group (has_edist empty)) unsigned) : @is_cyclic.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (has_edist.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_15321 (h0 : semiring (semiring num)) : is_noetherian_ring (semiring num) := sorry --non-trivial
lemma new_lemma_15322 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_atomistic.{0} (has_sub.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) complete_lattice.{0}) (has_sub.{0} empty))  := sorry --non-trivial
lemma new_lemma_15323 (h0 : ring (boolean_algebra (has_add unsigned))) : strong_rank_condition (boolean_algebra (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_15324 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_nndist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_15325 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ordered_comm_monoid linarith.comp)) (ring Type)) : @unique_factorization_monoid.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (ordered_comm_monoid.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_15326 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (has_emptyc.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_emptyc.{0} empty))  := sorry --non-trivial
lemma new_lemma_15327 (h1 : ring (has_norm linarith.ineq)) : is_domain (has_norm linarith.ineq) := sorry --non-trivial
lemma new_lemma_15328 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (add_right_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_right_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_15329 (h0 : complete_lattice (has_ssubset (has_nnnorm (random_gen fun_info)))) : is_compactly_generated (has_ssubset (has_nnnorm (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_15330 (h0 : set (non_unital_non_assoc_semiring (mul_one_class fun_info))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_15331 (h0 : monoid (finset (ring Type))) : monoid.fg (finset (ring Type)) := sorry --non-trivial
lemma new_lemma_15332 (h0 : semiring (has_nnnorm (mul_one_class char))) (h1 : ideal (has_nnnorm (mul_one_class char))) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_15333 (h0 : topological_space (add_cancel_monoid (has_nndist (has_pos_part (has_add pos))))) : preirreducible_space (add_cancel_monoid (has_nndist (has_pos_part (has_add pos)))) := sorry --non-trivial
lemma new_lemma_15334 (h0 : complete_lattice (with_one (semiring unsigned))) : is_atomistic (with_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_15335 (h0 : uniform_space (semiring empty)) : complete_space (semiring empty) := sorry --non-trivial
lemma new_lemma_15336 (h0 : ring (has_norm (random_gen num))) : rank_condition (has_norm (random_gen num)) := sorry --non-trivial
lemma new_lemma_15337 (h2 : complete_lattice (has_div linarith.comp_source)) : is_compactly_generated (has_div linarith.comp_source) := sorry --non-trivial
lemma new_lemma_15338 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (normed_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_15339 (h0 : ring (linear_order (semiring (semiring empty)))) : rank_condition (linear_order (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_15340 (h0 : topological_space (random_gen (has_norm fun_info))) : discrete_topology (random_gen (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_15341 (h0 : topological_space (has_append (has_ssubset char))) : totally_disconnected_space (has_append (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_15342 (h0 : complete_lattice (finset (ring Type))) : complete_lattice.is_Sup_finite_compact (finset (ring Type)) := sorry --non-trivial
lemma new_lemma_15343 (h0 : ring (boolean_algebra.core (has_add (comm_group (has_neg name))))) : rank_condition (boolean_algebra.core (has_add (comm_group (has_neg name)))) := sorry --non-trivial
lemma new_lemma_15344 (h1 : ring (has_lt char)) : strong_rank_condition (has_lt char) := sorry --non-trivial
lemma new_lemma_15345 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @t1_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_15346 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_15347 (h0 : group (has_to_string (comm_group unsigned))) : is_simple_group (has_to_string (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_15348 (h0 : function.extfun Type group) : @group.fg.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (measure_theory.measure_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_15349 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_15350 (h0 : functor.add_const (topological_space (ring pos)) (has_neg Type)) : @t1_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_15351 (h1 : filter (pseudo_emetric_space char)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_15352 (h0 : ring (has_to_string (option name))) : is_domain (has_to_string (option name)) := sorry --non-trivial
lemma new_lemma_15353 (h1 : list (with_one (random_gen (random_gen linarith.comp_source)))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_15354 (h0 : not (group (has_compl (has_append linarith.comp_source)) -> false)) : @is_cyclic.{0} (has_compl.{0} (has_append.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (group.{0} (has_compl.{0} (has_append.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_15355 (h0 : functor.add_const (topological_space (canonically_linear_ordered_monoid ennreal)) (option ennreal)) : @totally_separated_space.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} ennreal)) (option.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_15356 (h1 : measurable_space (add_comm_semigroup std_gen)) (h2 : set (add_comm_semigroup std_gen)) : measurable_set h2 := sorry --non-trivial
lemma new_lemma_15357 (h0 : function.extfun Type uniform_space) : @complete_space.{0} string_imp (@function.extfun_app.{2 1} Type uniform_space.{0} h0 string_imp)  := sorry --non-trivial
lemma new_lemma_15358 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (finset linarith.comp)) : @totally_separated_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (finset.{0} linarith.comp) h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_15359 (h0 : fin has_zero.zero) : @totally_separated_space.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_15360 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_15361 (h0 : uniform_space (normed_comm_ring (normed_comm_ring name))) : complete_space (normed_comm_ring (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_15362 (h0 : functor.add_const (ordered_add_comm_monoid (canonically_ordered_comm_semiring Type)) Type) : @archimedean.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 1} (ordered_add_comm_monoid.{1} (canonically_ordered_comm_semiring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_15363 (h0 : group (has_to_string congr_arg_kind)) : normalizer_condition (has_to_string congr_arg_kind) := sorry --non-trivial
lemma new_lemma_15364 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra unsigned)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_15365 (h1 : not (topological_space (semiring num) -> false)) : @discrete_topology.{0} (semiring.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} num)) h1)  := sorry --non-trivial
lemma new_lemma_15366 (h0 : add_monoid (add_cancel_monoid (has_neg num))) : add_monoid.fg (add_cancel_monoid (has_neg num)) := sorry --non-trivial
lemma new_lemma_15367 (h0 : topological_space (has_nndist (comm_group Type))) : regular_space (has_nndist (comm_group Type)) := sorry --non-trivial
lemma new_lemma_15368 (h0 : ring (uniform_space (mul_one_class string.iterator_imp))) : rank_condition (uniform_space (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_15369 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) linarith.comp) : @preconnected_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_15370 (h0 : complete_lattice (linear_ordered_comm_ring num)) : is_atomistic (linear_ordered_comm_ring num) := sorry --non-trivial
lemma new_lemma_15371 (h0 : topological_space (comm_semigroup (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid real))))) : sequential_space (comm_semigroup (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid real)))) := sorry --non-trivial
lemma new_lemma_15372 (h0 : not (monoid (complete_semilattice_Sup unsigned) -> false)) : @monoid.fg.{0} (complete_semilattice_Sup.{0} unsigned) (@classical.by_contradiction'.{1} (monoid.{0} (complete_semilattice_Sup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_15373 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_15374 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (normed_comm_ring.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_comm_ring.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_15375 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (with_bot fun_info)) := sorry --non-trivial
lemma new_lemma_15376 (h0 : function.extfun Type group) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_15377 (h0 : functor.add_const (add_group (finset Type)) Type) : @is_add_cyclic.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (add_group.{1} (finset.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_15378 (h0 : not (list (topological_space to_additive.value_type) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_15379 (h0 : group (canonically_ordered_comm_semiring pos)) : normalizer_condition (canonically_ordered_comm_semiring pos) := sorry --non-trivial
lemma new_lemma_15380 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) environment.implicit_infer_kind) : @preirreducible_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_15381 (h0 : complete_lattice (finset (option (option (option (option (option (option ennreal)))))))) : is_atomistic (finset (option (option (option (option (option (option ennreal))))))) := sorry --non-trivial
lemma new_lemma_15382 (h0 : semiring (has_add (sub_neg_monoid linarith.comp))) : is_noetherian_ring (has_add (sub_neg_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_15383 (h0 : topological_space (ring (semigroup (has_zero linarith.comp)))) : preconnected_space (ring (semigroup (has_zero linarith.comp))) := sorry --non-trivial
lemma new_lemma_15384 (h0 : ring (with_bot unsigned)) : is_domain (with_bot unsigned) := sorry --non-trivial
lemma new_lemma_15385 (h0 : functor.add_const (finset (option name)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_15386 (h0 : group (semiring (random_gen (random_gen (has_inv (has_inv linarith.ineq)))))) : normalizer_condition (semiring (random_gen (random_gen (has_inv (has_inv linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_15387 (h0 : functor.add_const (topological_space (comm_group pos)) name) : @regular_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_15388 (h0 : functor.add_const (filter (normed_comm_ring pos)) (option (option (option pos)))) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_15389 (h0 : ring empty -> ring empty -> Prop) : reflexive h0 := sorry --non-trivial
lemma new_lemma_15390 (h0 : functor.add_const (list (ring Type)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_15391 (h0 : topological_space (cancel_monoid (option (option pos)))) : t0_space (cancel_monoid (option (option pos))) := sorry --non-trivial
lemma new_lemma_15392 (h0 : group (has_nndist (has_Inf (has_Inf (has_add Type))))) : group.fg (has_nndist (has_Inf (has_Inf (has_add Type)))) := sorry --non-trivial
lemma new_lemma_15393 (h0 : function.extfun Type multiset) : @multiset.inf.{0} Prop (@lattice.to_semilattice_inf.{0} Prop (@conditionally_complete_lattice.to_lattice.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice))) (@bounded_order.to_order_top.{0} Prop (@preorder.to_has_le.{0} Prop (@partial_order.to_preorder.{0} Prop (@semilattice_inf.to_partial_order.{0} Prop (@lattice.to_semilattice_inf.{0} Prop (@conditionally_complete_lattice.to_lattice.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)))))) Prop.bounded_order) (@function.extfun_app.{2 1} Type multiset.{0} h0 Prop)  := sorry --non-trivial
lemma new_lemma_15394 (h0 : topological_space (has_edist (option empty))) : totally_disconnected_space (has_edist (option empty)) := sorry --non-trivial
lemma new_lemma_15395 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @is_cyclic.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_15396 (h1 : topological_space (measurable_space unsigned)) : locally_compact_space (measurable_space unsigned) := sorry --non-trivial
lemma new_lemma_15397 (h0 : has_mem.mem (semiring (random_gen linarith.ineq)) has_emptyc.emptyc) : @path_connected_space.{0} (semiring.{0} (random_gen.{0} linarith.ineq)) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} (random_gen.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_15398 (h0 : functor.add_const (filter (boolean_algebra environment.implicit_infer_kind)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_15399 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_15400 (h0 : topological_space (complete_semilattice_Sup linarith.ineq)) : t0_space (complete_semilattice_Sup linarith.ineq) := sorry --non-trivial
lemma new_lemma_15401 (h1 : not (topological_space (with_one to_additive.value_type) -> false)) : @path_connected_space.{0} (with_one.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_15402 (h0 : set (has_nnnorm ereal)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_15403 (h0 : fin has_zero.zero) : @path_connected_space.{0} (ring.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_15404 (h0 : functor.add_const (topological_space (left_cancel_monoid empty)) unsigned) : @irreducible_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_15405 (h0 : functor.add_const (complete_lattice (canonically_linear_ordered_monoid name)) name) : @is_atomistic.{0} (canonically_linear_ordered_monoid.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_linear_ordered_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_15406 (h0 : topological_space (canonically_ordered_monoid (sub_neg_monoid name))) : totally_disconnected_space (canonically_ordered_monoid (sub_neg_monoid name)) := sorry --non-trivial
lemma new_lemma_15407 (h0 : functor.add_const (ring (has_neg Type)) (has_zero (has_neg (ring pos)))) : @is_domain.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_neg.{1} Type)) (has_zero.{0} (has_neg.{0} (ring.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_15408 (h0 : functor.add_const (topological_space (cancel_monoid unsigned)) environment.implicit_infer_kind) : @locally_compact_space.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_15409 (h0 : group (ordered_cancel_add_comm_monoid (option (option pos)))) : group.fg (ordered_cancel_add_comm_monoid (option (option pos))) := sorry --non-trivial
lemma new_lemma_15410 (h0 : monoid (add_cancel_comm_monoid (semiring empty))) : monoid.fg (add_cancel_comm_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_15411 (h1 : ring (has_emptyc linarith.comp)) : strong_rank_condition (has_emptyc linarith.comp) := sorry --non-trivial
lemma new_lemma_15412 (h0 : set (has_lt (mul_one_class (mul_one_class fun_info)))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_15413 (h0 : topological_space (ordered_comm_monoid (finset name))) : sequential_space (ordered_comm_monoid (finset name)) := sorry --non-trivial
lemma new_lemma_15414 (h0 : topological_space (complete_semilattice_Sup (semiring congr_arg_kind))) : topological_space.separable_space (complete_semilattice_Sup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_15415 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (measurable_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (measurable_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_15416 (h0 : filter (topological_space empty)) : irreducible_space empty := sorry --non-trivial
lemma new_lemma_15417 (h0 : functor.comp (functor.comp complete_lattice has_zero) with_top nnreal) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} ennreal) (@functor.comp.run.{0 0 0} complete_lattice.{0} has_zero.{0} ennreal (@functor.comp.run.{0 0 0} (functor.comp.{0 0 0} complete_lattice.{0} has_zero.{0}) with_top.{0} nnreal h0))  := sorry --non-trivial
lemma new_lemma_15418 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_star.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_star.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_15419 (h0 : group (has_neg Type)) : normalizer_condition (has_neg Type) := sorry --non-trivial
lemma new_lemma_15420 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_15421 (h0 : ring (boolean_algebra.core name)) : strong_rank_condition (boolean_algebra.core name) := sorry --non-trivial
lemma new_lemma_15422 (h0 : functor.add_const (topological_space (has_nndist Type)) linarith.comp) : @t1_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_15423 (h0 : not (uniform_space (measurable_space to_additive.value_type) -> false)) : @separated_space.{0} (measurable_space.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (uniform_space.{0} (measurable_space.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_15424 (h0 : functor.add_const (complete_lattice (has_neg name)) name) : @is_compactly_generated.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_15425 (h0 : functor.add_const (ordered_comm_monoid (has_zero pos)) linarith.comp) : @has_exists_mul_of_le.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_zero.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_15426 (h0 : topological_space (boolean_algebra (has_to_string (finset (finset pos))))) : topological_space.separable_space (boolean_algebra (has_to_string (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_15427 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @totally_separated_space.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_15428 (h0 : functor.add_const (topological_space (has_add Type)) linarith.comp) : @locally_compact_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_15429 (h0 : finset (has_neg (ring (option unsigned)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_15430 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_15431 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_15432 (h3 : ring (add_left_cancel_monoid char)) : strong_rank_condition (add_left_cancel_monoid char) := sorry --non-trivial
lemma new_lemma_15433 (h0 : uniform_space (linear_ordered_semiring (linear_ordered_semiring linarith.comp))) : separated_space (linear_ordered_semiring (linear_ordered_semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_15434 (h0 : topological_space (ring (finset pos))) : discrete_topology (ring (finset pos)) := sorry --non-trivial
lemma new_lemma_15435 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (linear_ordered_field.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_15436 (h0 : ring (has_top (random_gen (random_gen (random_gen (random_gen linarith.comp_source)))))) : is_domain (has_top (random_gen (random_gen (random_gen (random_gen linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_15437 (h0 : ring (has_compl (random_gen linarith.ineq))) : rank_condition (has_compl (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_15438 (h1 : uniform_space (has_div to_additive.value_type)) : complete_space (has_div to_additive.value_type) := sorry --non-trivial
lemma new_lemma_15439 (h0 : ring (has_pos_part (has_pos_part pos))) : rank_condition (has_pos_part (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_15440 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} h0 (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_15441 (h0 : not (add_group (random_gen (random_gen linarith.comp_source)) -> false)) : @is_add_cyclic.{0} (random_gen.{0} (random_gen.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (add_group.{0} (random_gen.{0} (random_gen.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_15442 (h0 : topological_space (normed_lattice_add_comm_group real)) : normal_space (normed_lattice_add_comm_group real) := sorry --non-trivial
lemma new_lemma_15443 (h0 : topological_space (normed_comm_ring (finset pos))) : totally_separated_space (normed_comm_ring (finset pos)) := sorry --non-trivial
lemma new_lemma_15444 (h0 : functor.add_const (add_monoid (add_cancel_monoid environment.implicit_infer_kind)) linarith.comp) : @add_monoid.fg.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_15445 (h1 : group (with_one congr_arg_kind)) : is_cyclic (with_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_15446 (h0 : functor.add_const (topological_space (canonically_ordered_monoid pos)) linarith.comp) : @loc_path_connected_space.{0} (canonically_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_15447 (h0 : topological_space (generalized_boolean_algebra (has_neg linarith.comp))) : preconnected_space (generalized_boolean_algebra (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_15448 (h0 : functor.add_const (add_group (has_add unsigned)) linarith.comp) : @is_add_cyclic.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (has_add.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_15449 (h0 : functor.comp topological_space has_zero ennreal) : @discrete_topology.{0} (has_zero.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_15450 (h0 : topological_space (has_pos_part (has_nndist (comm_monoid pos)))) : topological_space.separable_space (has_pos_part (has_nndist (comm_monoid pos))) := sorry --non-trivial
lemma new_lemma_15451 (h0 : function.extfun Type topological_space) : @t0_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_15452 (h0 : linear_ordered_field (linear_ordered_cancel_comm_monoid unsigned)) (h1 : cau_seq (linear_ordered_cancel_comm_monoid unsigned) has_abs.abs) : cau_seq.pos h1 := sorry --non-trivial
lemma new_lemma_15453 (h0 : group (has_nnnorm (has_nnnorm (random_gen (random_gen linarith.ineq))))) : group.fg (has_nnnorm (has_nnnorm (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_15454 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (linear_ordered_field pos)) := sorry --non-trivial
lemma new_lemma_15455 (h0 : functor.add_const (topological_space (ring Type)) (has_neg Type)) : @t0_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ring.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_15456 (h0 : functor.add_const (cancel_comm_monoid_with_zero (canonically_ordered_comm_semiring linarith.comp)) unsigned) : @unique_factorization_monoid.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_15457 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_15458 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_disconnected_space.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_15459 (h0 : uniform_space (has_compl (random_gen (has_inv string_imp)))) : complete_space (has_compl (random_gen (has_inv string_imp))) := sorry --non-trivial
lemma new_lemma_15460 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_15461 (h0 : uniform_space (has_bot (has_add (has_Inf linarith.comp)))) : complete_space (has_bot (has_add (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_15462 (h1 : topological_space (has_nnnorm string_imp)) : totally_disconnected_space (has_nnnorm string_imp) := sorry --non-trivial
lemma new_lemma_15463 (h0 : topological_space (canonically_linear_ordered_monoid (sub_neg_monoid (has_Inf Type)))) : t1_space (canonically_linear_ordered_monoid (sub_neg_monoid (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_15464 (h0 : measurable_space (nondiscrete_normed_field (add_comm_semigroup linarith.ineq))) (h1 : measure_theory.measure (nondiscrete_normed_field (add_comm_semigroup linarith.ineq))) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_15465 (h0 : topological_space (canonically_ordered_monoid (has_add (has_add pos)))) : regular_space (canonically_ordered_monoid (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_15466 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_comm_semiring (option pos))) : unique_factorization_monoid (canonically_ordered_comm_semiring (option pos)) := sorry --non-trivial
lemma new_lemma_15467 (h0 : topological_space (has_star (option unsigned))) : totally_separated_space (has_star (option unsigned)) := sorry --non-trivial
lemma new_lemma_15468 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot linarith.comp))) : @strong_rank_condition.{0} (with_bot.{0} linarith.comp) (@finset.pi.empty.{1 0} Type ring.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_15469 (h0 : functor.add_const (topological_space (finset name)) Type) : @normal_space.{0} (finset.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_15470 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) linarith.comp) : @preconnected_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_15471 (h0 : group (has_pos_part (has_pos_part (has_Inf pos)))) : is_simple_group (has_pos_part (has_pos_part (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_15472 (h0 : complete_lattice (mul_zero_class (semiring (semiring (semiring unsigned))))) : complete_lattice.is_Sup_finite_compact (mul_zero_class (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_15473 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_compactly_generated.{0} linarith.comp (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_15474 (h0 : functor.add_const (topological_space (boolean_algebra pos)) environment.implicit_infer_kind) : @path_connected_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_15475 (h0 : fin has_zero.zero) : @sequential_space.{0} (semigroup.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (semigroup.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))))  := sorry --non-trivial
lemma new_lemma_15476 (h0 : semiring (boolean_algebra (ring (finset pos)))) : is_noetherian_ring (boolean_algebra (ring (finset pos))) := sorry --non-trivial
lemma new_lemma_15477 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (as_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (as_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_15478 (h0 : add_group (has_to_string (finset (normed_comm_ring (has_add Type))))) : is_add_cyclic (has_to_string (finset (normed_comm_ring (has_add Type)))) := sorry --non-trivial
lemma new_lemma_15479 (h0 : functor.add_const (semiring (has_to_string pos)) linarith.comp) : @is_noetherian_ring.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (has_to_string.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_15480 (h0 : topological_space (ordered_comm_ring (sub_neg_monoid real))) : regular_space (ordered_comm_ring (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_15481 (h0 : list (add_cancel_monoid pos)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_15482 (h0 : functor.add_const (function.extfun Type ring) pos) : @rank_condition.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_15483 (h0 : topological_space (has_neg (has_add Type))) : normal_space (has_neg (has_add Type)) := sorry --non-trivial
lemma new_lemma_15484 (h0 : topological_space (canonically_ordered_comm_semiring (with_zero ennreal))) : topological_space.separable_space (canonically_ordered_comm_semiring (with_zero ennreal)) := sorry --non-trivial
lemma new_lemma_15485 (h0 : function.extfun Type ring) : @rank_condition.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_15486 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_15487 (h0 : topological_space (measurable_space linarith.comp)) : t0_space (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_15488 (h0 : group (random_gen (metric_space num))) : is_cyclic (random_gen (metric_space num)) := sorry --non-trivial
lemma new_lemma_15489 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (bin_tree empty)) := sorry --non-trivial
lemma new_lemma_15490 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_Sup.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_15491 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_simple_group.{0} real (@matrix.vec_empty.{0} (group.{0} real) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_15492 (h0 : ring (has_zero (boolean_algebra.core pos))) : rank_condition (has_zero (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_15493 (h0 : set (has_nnnorm (has_le to_additive.value_type))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_15494 (h0 : functor.add_const (group (has_zero Type)) pos) : @normalizer_condition.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_zero.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_15495 (h0 : topological_space (mul_one_class (mul_one_class string.iterator_imp))) : t0_space (mul_one_class (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_15496 (h0 : function.extfun Type ring) : @is_domain.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_15497 (h0 : group (add_cancel_comm_monoid linarith.comp_source)) : normalizer_condition (add_cancel_comm_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_15498 (h0 : complete_lattice (mul_one_class (mul_one_class fun_info))) : complete_lattice.is_Sup_finite_compact (mul_one_class (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_15499 (h0 : add_group (boolean_algebra.core environment.implicit_infer_kind)) : is_add_cyclic (boolean_algebra.core environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_15500 (h0 : functor.add_const (topological_space (comm_group name)) name) : @regular_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_15501 (h0 : complete_lattice reducibility_hints) : is_compactly_generated reducibility_hints := sorry --non-trivial
lemma new_lemma_15502 (h0 : functor.add_const (semiring (boolean_algebra linarith.comp)) (has_Inf linarith.comp)) : @is_noetherian_ring.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (boolean_algebra.{0} linarith.comp)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_15503 (h0 : monoid (id (has_norm to_additive.value_type))) : monoid.fg (id (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_15504 (h0 : functor.add_const (complete_lattice (linear_ordered_cancel_comm_monoid unsigned)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_15505 (h1 : not (filter (fintype to_additive.value_type) -> false)) : filter.ne_bot (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_15506 (h0 : ring (has_bot (sub_neg_monoid Type))) : rank_condition (has_bot (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_15507 (h0 : topological_space (has_to_string (has_add ennreal))) : discrete_topology (has_to_string (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_15508 (h0 : not (ring num -> false)) : @is_principal_ideal_ring.{0} num (@classical.by_contradiction'.{1} (ring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_15509 (h0 : functor.add_const (filter (normed_comm_ring linarith.comp)) (boolean_algebra (ring Type))) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_15510 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_15511 (h0 : group (comm_group (option pos))) : normalizer_condition (comm_group (option pos)) := sorry --non-trivial
lemma new_lemma_15512 (h0 : topological_space (nondiscrete_normed_field (add_comm_semigroup environment.projection_info))) (h1 : add_group (nondiscrete_normed_field (add_comm_semigroup environment.projection_info))) : topological_add_group (nondiscrete_normed_field (add_comm_semigroup environment.projection_info)) := sorry --non-trivial
lemma new_lemma_15513 (h0 : function.extfun Type topological_space) : @regular_space.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_15514 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (left_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_15515 (h0 : topological_space (has_pos_part (ring pos))) : irreducible_space (has_pos_part (ring pos)) := sorry --non-trivial
lemma new_lemma_15516 (h0 : functor.add_const (finset (semiring num)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_15517 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_bot.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_15518 (h0 : topological_space (simple_graph (has_add Type))) : normal_space (simple_graph (has_add Type)) := sorry --non-trivial
lemma new_lemma_15519 (h0 : functor.add_const (topological_space (ring pos)) (has_neg (has_neg (has_neg Type)))) : @path_connected_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} pos)) (has_neg.{1} (has_neg.{1} (has_neg.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_15520 (h0 : functor.add_const (ordered_comm_monoid (add_cancel_monoid Type)) Type) : @has_exists_mul_of_le.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (ordered_comm_monoid.{1} (add_cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_15521 (h0 : topological_space (semigroup (option congr_arg_kind))) : preirreducible_space (semigroup (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_15522 (h0 : monoid (has_top (has_top (semiring (semiring (has_top (has_top (semiring unsigned)))))))) : monoid.fg (has_top (has_top (semiring (semiring (has_top (has_top (semiring unsigned))))))) := sorry --non-trivial
lemma new_lemma_15523 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_15524 (h0 : ordered_add_comm_monoid (comm_monoid (semiring (semiring unsigned)))) : archimedean (comm_monoid (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_15525 (h0 : ring (has_ssubset (metric_space (has_nnnorm (comm_ring char))))) : rank_condition (has_ssubset (metric_space (has_nnnorm (comm_ring char)))) := sorry --non-trivial
lemma new_lemma_15526 (h0 : topological_space (finset (ring Type))) : sequential_space (finset (ring Type)) := sorry --non-trivial
lemma new_lemma_15527 (h0 : functor.add_const (ordered_add_comm_monoid (has_pos_part name)) (has_Inf real)) : @archimedean.{0} (has_pos_part.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_pos_part.{0} name)) (has_Inf.{0} real) h0)  := sorry --non-trivial
lemma new_lemma_15528 (h0 : complete_lattice (with_bot linarith.ineq)) : complete_lattice.is_Sup_finite_compact (with_bot linarith.ineq) := sorry --non-trivial
lemma new_lemma_15529 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (cancel_monoid.{0} (has_to_string.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} (has_to_string.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_15530 (h0 : not (topological_space (metric_space string_imp) -> false)) : @path_connected_space.{0} (metric_space.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_15531 (h0 : topological_space (has_neg (has_neg_part pos))) : topological_space.separable_space (has_neg (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_15532 (h0 : ring (semiring (has_norm congr_arg_kind))) : is_domain (semiring (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_15533 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @path_connected_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_15534 (h0 : filter (has_zero environment.implicit_infer_kind)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_15535 (h1 : topological_space (has_top congr_arg_kind)) : totally_disconnected_space (has_top congr_arg_kind) := sorry --non-trivial
lemma new_lemma_15536 (h0 : set (omega_complete_partial_order ereal)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_15537 (h0 : functor.add_const (topological_space (ring name)) name) : @discrete_topology.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_15538 (h0 : functor.add_const (topological_space (has_neg unsigned)) ennreal) : @normal_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_15539 (h0 : ring (has_lt std_gen)) : is_domain (has_lt std_gen) := sorry --non-trivial
lemma new_lemma_15540 (h0 : filter (has_union (has_norm linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_15541 (h0 : functor.add_const (topological_space (ring pos)) Type) : @preirreducible_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_15542 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (group_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_15543 (h0 : multiset (topological_space (normed_group linarith.comp_source))) : @irreducible_space.{0} (normed_group.{0} linarith.comp_source) (@multiset.inf.{0} (topological_space.{0} (normed_group.{0} linarith.comp_source)) (@lattice.to_semilattice_inf.{0} (topological_space.{0} (normed_group.{0} linarith.comp_source)) (@conditionally_complete_lattice.to_lattice.{0} (topological_space.{0} (normed_group.{0} linarith.comp_source)) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (normed_group.{0} linarith.comp_source)) (@topological_space.complete_lattice.{0} (normed_group.{0} linarith.comp_source))))) (@bounded_order.to_order_top.{0} (topological_space.{0} (normed_group.{0} linarith.comp_source)) (@preorder.to_has_le.{0} (topological_space.{0} (normed_group.{0} linarith.comp_source)) (@partial_order.to_preorder.{0} (topological_space.{0} (normed_group.{0} linarith.comp_source)) (@semilattice_inf.to_partial_order.{0} (topological_space.{0} (normed_group.{0} linarith.comp_source)) (@lattice.to_semilattice_inf.{0} (topological_space.{0} (normed_group.{0} linarith.comp_source)) (@conditionally_complete_lattice.to_lattice.{0} (topological_space.{0} (normed_group.{0} linarith.comp_source)) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (normed_group.{0} linarith.comp_source)) (@topological_space.complete_lattice.{0} (normed_group.{0} linarith.comp_source)))))))) (@complete_lattice.to_bounded_order.{0} (topological_space.{0} (normed_group.{0} linarith.comp_source)) (@topological_space.complete_lattice.{0} (normed_group.{0} linarith.comp_source)))) h0)  := sorry --non-trivial
lemma new_lemma_15544 (h0 : ring (comm_group (has_add (has_add ennreal)))) : is_principal_ideal_ring (comm_group (has_add (has_add ennreal))) := sorry --non-trivial
lemma new_lemma_15545 (h1 : add_group (with_zero linarith.comp_source)) : is_add_cyclic (with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_15546 (h0 : topological_space (has_one (semiring congr_arg_kind))) : preirreducible_space (has_one (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_15547 (h0 : topological_space (boolean_algebra (finset linarith.comp))) : sequential_space (boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_15548 (h0 : topological_space (distrib_lattice (random_gen (random_gen fun_info)))) : path_connected_space (distrib_lattice (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_15549 (h0 : add_group (ordered_comm_semiring char)) : is_add_cyclic (ordered_comm_semiring char) := sorry --non-trivial
lemma new_lemma_15550 (h0 : topological_space (ring (has_add unsigned))) : t1_space (ring (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_15551 (h1 : uniform_space (add_left_cancel_monoid (has_ssubset linarith.ineq))) : complete_space (add_left_cancel_monoid (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_15552 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (linear_ordered_field.{0} (ring.{0} pos)) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (linear_ordered_field.{0} (ring.{0} pos)))  := sorry --non-trivial
lemma new_lemma_15553 (h0 : topological_space (linear_ordered_add_comm_monoid_with_top (semiring congr_arg_kind))) : t0_space (linear_ordered_add_comm_monoid_with_top (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_15554 (h0 : has_lt (add_comm_semigroup reducibility_hints)) : no_max_order (add_comm_semigroup reducibility_hints) := sorry --non-trivial
lemma new_lemma_15555 (h0 : not (topological_space (option empty) -> false)) : @normal_space.{0} (option.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_15556 (h0 : topological_space (option (option (option (option (option empty)))))) (h1 : set (option (option (option (option (option empty)))))) : is_preirreducible h1 := sorry --non-trivial
lemma new_lemma_15557 (h3 : has_lt (nondiscrete_normed_field string.iterator_imp)) : no_max_order (nondiscrete_normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_15558 (h0 : topological_space (ordered_comm_monoid (ring Type))) : t0_space (ordered_comm_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_15559 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (comm_semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (comm_semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_15560 (h0 : not (ring (has_ssubset fun_info) -> false)) : @rank_condition.{0} (has_ssubset.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_15561 (h0 : functor.add_const (topological_space (partial_order congr_arg_kind)) unsigned) : @normal_space.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_15562 (h0 : uniform_space (option (semiring num))) : separated_space (option (semiring num)) := sorry --non-trivial
lemma new_lemma_15563 (h2 : not (topological_space (distrib char) -> false)) : @t0_space.{0} (distrib.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib.{0} char)) h2)  := sorry --non-trivial
lemma new_lemma_15564 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_15565 (h0 : add_group (denumerable (random_gen to_additive.value_type))) : is_add_cyclic (denumerable (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_15566 (h0 : not (group (encodable fun_info) -> false)) : @group.fg.{0} (encodable.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (encodable.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_15567 (h0 : function.extfun Type topological_space) : @t0_space.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_15568 (h0 : topological_space (with_one (with_bot to_additive.value_type))) : totally_disconnected_space (with_one (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_15569 (h0 : function.extfun (finset Type) (has_mem.mem congr_arg_kind)) : @is_atomistic.{0} congr_arg_kind (@finset.pi.empty.{1 0} Type complete_lattice.{0} congr_arg_kind (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) congr_arg_kind) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_15570 (h0 : ring (random_gen (has_nnnorm to_additive.value_type))) : strong_rank_condition (random_gen (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_15571 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_15572 (h0 : ring (pseudo_metric_space pos)) : is_domain (pseudo_metric_space pos) := sorry --non-trivial
lemma new_lemma_15573 (h0 : group (has_dist unsigned)) : group.fg (has_dist unsigned) := sorry --non-trivial
lemma new_lemma_15574 (h0 : not (ring (has_top linarith.comp_source) -> false)) : @rank_condition.{0} (has_top.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (has_top.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_15575 (h0 : add_group (denumerable (comm_ring (comm_ring char)))) : is_add_cyclic (denumerable (comm_ring (comm_ring char))) := sorry --non-trivial
lemma new_lemma_15576 (h0 : add_group (preorder (option empty))) : is_add_cyclic (preorder (option empty)) := sorry --non-trivial
lemma new_lemma_15577 (h0 : group (comm_monoid unsigned)) : normalizer_condition (comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_15578 (h1 : has_mem.mem (id congr_arg_kind) has_emptyc.emptyc) : @is_atomistic.{0} (@id.{2} Type congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (@id.{2} Type congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_15579 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_15580 (h0 h1 : multiset (simple_graph char)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_15581 (h0 : functor.add_const (complete_lattice (has_Sup unsigned)) unsigned) : @is_atomistic.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_Sup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_15582 (h0 : function.extfun Type (functor.comp list add_cancel_monoid)) : palindrome (functor.comp.run (function.extfun_app h0 environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_15583 (h0 : ereal -> ereal) (h1 : ereal) : function.is_fixed_pt h0 h1 := sorry --non-trivial
lemma new_lemma_15584 (h0 : multiset (linear_order unsigned)) : multiset.nodup h0 := sorry --non-trivial
lemma new_lemma_15585 (h0 : add_group (semigroup (has_neg (ring (mul_one_class environment.implicit_infer_kind))))) : is_add_cyclic (semigroup (has_neg (ring (mul_one_class environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_15586 (h0 : set (set empty)) : is_countably_spanning h0 := sorry --non-trivial
lemma new_lemma_15587 (h0 : filter (has_union (has_top (has_top (semiring linarith.comp))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_15588 (h1 : has_mem.mem ring has_emptyc.emptyc) : @rank_condition.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h1) (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_15589 (h0 : function.extfun nat fin) : @rank_condition.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_15590 (h0 : topological_space (distrib (has_nnnorm (has_nnnorm char)))) : t0_space (distrib (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_15591 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_15592 (h0 : has_coe (nondiscrete_normed_field ereal) Prop) (h1 : nondiscrete_normed_field ereal) : @coe_b.{1 1} (nondiscrete_normed_field.{0} ereal) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_15593 (h0 : uniform_space (semi_normed_ring (denumerable reducibility_hints))) : complete_space (semi_normed_ring (denumerable reducibility_hints)) := sorry --non-trivial
lemma new_lemma_15594 (h0 : ring (comm_group (add_comm_monoid (has_neg_part name)))) : rank_condition (comm_group (add_comm_monoid (has_neg_part name))) := sorry --non-trivial
lemma new_lemma_15595 (h0 : topological_space (random_gen (semiring empty))) : normal_space (random_gen (semiring empty)) := sorry --non-trivial
lemma new_lemma_15596 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (linear_ordered_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (linear_ordered_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_15597 (h0 : topological_space (boolean_algebra.core (option name))) : sequential_space (boolean_algebra.core (option name)) := sorry --non-trivial
lemma new_lemma_15598 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) (ring linarith.comp)) : @has_exists_mul_of_le.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) (ring.{0} linarith.comp) h0) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_15599 (h0 : functor.add_const (uniform_space (normed_comm_ring pos)) pos) : @complete_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (normed_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_15600 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (has_Inf Type)) : @preirreducible_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} pos)) (has_Inf.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_15601 (h0 : topological_space (mul_zero_class environment.implicit_infer_kind)) : preirreducible_space (mul_zero_class environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_15602 (h0 : function.extfun Type (functor.comp topological_space has_neg_part)) : @totally_disconnected_space.{0} (has_neg_part.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_neg_part.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_15603 (h0 : not (group (has_append linarith.ineq) -> false)) : @is_cyclic.{0} (has_append.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (has_append.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_15604 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_15605 (h0 : topological_space (with_bot num)) : locally_compact_space (with_bot num) := sorry --non-trivial
lemma new_lemma_15606 (h0 : ring (canonically_ordered_comm_semiring (option empty))) : strong_rank_condition (canonically_ordered_comm_semiring (option empty)) := sorry --non-trivial
lemma new_lemma_15607 (h0 : uniform_space (has_neg congr_arg_kind)) : separated_space (has_neg congr_arg_kind) := sorry --non-trivial
lemma new_lemma_15608 (h1 : set (fun_info -> std_gen)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_15609 (h0 : ordered_add_comm_monoid (normed_comm_ring (normed_comm_ring (finset pos)))) : archimedean (normed_comm_ring (normed_comm_ring (finset pos))) := sorry --non-trivial
lemma new_lemma_15610 (h0 : measurable_space (normed_field (normed_field (normed_field linarith.ineq)))) (h1 : has_add (normed_field (normed_field (normed_field linarith.ineq)))) (h2 : measure_theory.measure (normed_field (normed_field (normed_field linarith.ineq)))) : measure_theory.measure.is_add_left_invariant h2 := sorry --non-trivial
lemma new_lemma_15611 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} linarith.comp_source (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 add_monoid.{0}) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_15612 (h0 : monoid (has_Inf (sub_neg_monoid Type))) : monoid.fg (has_Inf (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_15613 (h0 : topological_space (id (semiring (semiring (semiring (semiring (semiring congr_arg_kind))))))) : discrete_topology (id (semiring (semiring (semiring (semiring (semiring congr_arg_kind)))))) := sorry --non-trivial
lemma new_lemma_15614 (h0 : complete_lattice (distrib (random_gen linarith.ineq))) : complete_lattice.is_Sup_finite_compact (distrib (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_15615 (h0 : not (function.extfun (finset Type) (has_mem.mem (semiring empty)) -> false)) : @strong_rank_condition.{0} (semiring.{0} empty) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} empty)) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} empty))) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_15616 (h2 : ring (linear_ordered_add_comm_group to_additive.value_type)) : rank_condition (linear_ordered_add_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_15617 (h0 : cancel_comm_monoid_with_zero (has_bot (add_cancel_monoid (add_semigroup (option unsigned))))) : unique_factorization_monoid (has_bot (add_cancel_monoid (add_semigroup (option unsigned)))) := sorry --non-trivial
lemma new_lemma_15618 (h0 : has_mem.mem (semiring fun_info) has_emptyc.emptyc) : @normalizer_condition.{0} (semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type group.{0} (semiring.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_15619 (h1 h2 : multiset reducibility_hints) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_15620 (h0 : topological_space (boolean_algebra.core (has_neg linarith.comp))) : sequential_space (boolean_algebra.core (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_15621 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @totally_separated_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_15622 (h0 h1 : multiset (semi_normed_comm_ring string.iterator_imp)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_15623 (h0 : filter (has_nndist (add_comm_monoid environment.implicit_infer_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_15624 (h0 : functor.add_const (topological_space (canonically_ordered_monoid linarith.comp)) linarith.comp) : @sequential_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_15625 (h0 : monoid (has_one (has_top (has_norm (has_top empty))))) : monoid.fg (has_one (has_top (has_norm (has_top empty)))) := sorry --non-trivial
lemma new_lemma_15626 (h0 : functor.add_const (complete_lattice (ring name)) pos) : @is_atomistic.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_15627 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) linarith.comp) : @t0_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_15628 (h0 : ring (add_cancel_comm_monoid unsigned)) : is_principal_ideal_ring (add_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_15629 (h0 : functor.add_const (function.extfun (Type 1) group) linarith.comp) : @group.fg.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) linarith.comp h0) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_15630 (h0 : topological_space (div_inv_monoid to_additive.value_type)) : t0_space (div_inv_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_15631 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (left_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (left_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_15632 (h0 : complete_lattice (denumerable (has_ssubset linarith.comp_source))) : is_compactly_generated (denumerable (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_15633 (h0 : topological_space (has_pos_part (has_neg pos))) : topological_space.separable_space (has_pos_part (has_neg pos)) := sorry --non-trivial
lemma new_lemma_15634 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} congr_arg_kind (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_15635 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_15636 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_15637 (h0 : add_group (div_inv_monoid fun_info)) : is_add_cyclic (div_inv_monoid fun_info) := sorry --non-trivial
lemma new_lemma_15638 (h0 : topological_space (option unsigned)) : t0_space (option unsigned) := sorry --non-trivial
lemma new_lemma_15639 (h1 : uniform_space (random_gen (comm_ring (comm_ring (comm_ring char))))) : complete_space (random_gen (comm_ring (comm_ring (comm_ring char)))) := sorry --non-trivial
lemma new_lemma_15640 (h0 : complete_lattice (ordered_comm_ring (has_add (has_add (has_add (has_pos_part (sub_neg_monoid name))))))) : is_atomistic (ordered_comm_ring (has_add (has_add (has_add (has_pos_part (sub_neg_monoid name)))))) := sorry --non-trivial
lemma new_lemma_15641 (h0 : list (has_edist (semiring unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_15642 (h0 : has_mem.mem Type has_emptyc.emptyc) : @totally_separated_space.{1} Type (@finset.pi.empty.{2 1} (Type 1) topological_space.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_15643 (h0 : functor.add_const (topological_space (add_comm_monoid environment.implicit_infer_kind)) Type) : @topological_space.separable_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_15644 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @discrete_topology.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_15645 (h0 : group (distrib_lattice to_additive.value_type)) : group.fg (distrib_lattice to_additive.value_type) := sorry --non-trivial
lemma new_lemma_15646 (h0 : group (add_cancel_monoid (has_add environment.implicit_infer_kind))) : is_simple_group (add_cancel_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_15647 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_15648 (h0 : complete_lattice (has_neg (comm_group unsigned))) : complete_lattice.is_Sup_finite_compact (has_neg (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_15649 (h0 : functor.add_const (list (add_left_cancel_semigroup unsigned)) congr_arg_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_15650 (h0 : group (has_norm (has_inv linarith.ineq))) : is_cyclic (has_norm (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_15651 (h0 : list (boolean_algebra.core (boolean_algebra.core (has_dist congr_arg_kind)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_15652 (h1 : complete_lattice (id linarith.comp)) : is_compactly_generated (id linarith.comp) := sorry --non-trivial
lemma new_lemma_15653 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_15654 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (non_assoc_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_15655 (h0 : group (bin_tree num)) : normalizer_condition (bin_tree num) := sorry --non-trivial
lemma new_lemma_15656 (h1 : set (enat -> enat)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_15657 (h0 : functor.add_const (topological_space (omega_complete_partial_order empty)) empty) : @totally_disconnected_space.{0} (omega_complete_partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (omega_complete_partial_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_15658 (h0 : topological_space (has_add linarith.comp)) : totally_separated_space (has_add linarith.comp) := sorry --non-trivial
lemma new_lemma_15659 (h0 : functor.add_const (ring (has_nndist ennreal)) ennreal) : @strong_rank_condition.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_15660 (h0 : cancel_comm_monoid_with_zero (has_Inf (has_Inf (ring (has_Inf linarith.comp))))) : unique_factorization_monoid (has_Inf (has_Inf (ring (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_15661 (h0 : group (has_norm (random_gen (has_top char)))) : group.fg (has_norm (random_gen (has_top char))) := sorry --non-trivial
lemma new_lemma_15662 (h0 : function.extfun Type group) : @normalizer_condition.{0} (is_R_or_C.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (is_R_or_C.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_15663 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_15664 (h0 : uniform_space (random_gen (has_top (has_top (has_top linarith.comp_source))))) : complete_space (random_gen (has_top (has_top (has_top linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_15665 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_15666 (h0 : list (as_linear_order unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_15667 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_15668 (h0 : function.extfun (Type 1) group) : @group.fg.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_15669 (h0 : group (pseudo_emetric_space (semiring num))) : group.fg (pseudo_emetric_space (semiring num)) := sorry --non-trivial
lemma new_lemma_15670 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (normed_linear_ordered_group.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_linear_ordered_group.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_15671 (h0 : functor.add_const (ordered_comm_monoid (ordered_comm_monoid linarith.comp)) (has_add (finset linarith.comp))) : @has_exists_mul_of_le.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ordered_comm_monoid.{0} linarith.comp)) (has_add.{0} (finset.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_15672 (h0 : semiring (complete_distrib_lattice empty)) : is_noetherian_ring (complete_distrib_lattice empty) := sorry --non-trivial
lemma new_lemma_15673 (h0 : ordered_comm_monoid (ring (ring (option pos)))) : has_exists_mul_of_le (ring (ring (option pos))) := sorry --non-trivial
lemma new_lemma_15674 (h0 : uniform_space (simple_graph Type)) : complete_space (simple_graph Type) := sorry --non-trivial
lemma new_lemma_15675 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @archimedean.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (boolean_algebra.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_15676 (h0 : functor.add_const (filter (ordered_comm_ring Type)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_15677 (h0 : topological_space (with_one (has_norm empty))) : irreducible_space (with_one (has_norm empty)) := sorry --non-trivial
lemma new_lemma_15678 (h0 : add_group (add_comm_monoid (finset linarith.comp))) : is_add_cyclic (add_comm_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_15679 (h0 : function.extfun Type (functor.comp group canonically_ordered_comm_semiring)) : @is_simple_group.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.comp.run.{0 0 0} group.{0} canonically_ordered_comm_semiring.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} canonically_ordered_comm_semiring.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_15680 (h0 : functor.add_const (topological_space (free_add_monoid empty)) num) : @topological_space.separable_space.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_15681 (h0 : not (has_mem.mem (has_norm linarith.comp_source) has_emptyc.emptyc -> false)) : @irreducible_space.{0} (has_norm.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_15682 (h0 : filter (has_neg (has_add Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_15683 (h0 : functor.add_const (topological_space (has_add Type)) pos) : @path_connected_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_15684 (h0 : functor.add_const (function.extfun Type ring) pos) : @rank_condition.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_15685 (h0 : functor.add_const (list (left_cancel_semigroup empty)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_15686 (h0 : fin has_zero.zero) : @normal_space.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (normed_lattice_add_comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_15687 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) environment.implicit_infer_kind) : @preirreducible_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_15688 (h0 : topological_space (semigroup (finset (boolean_algebra linarith.comp)))) : topological_space.separable_space (semigroup (finset (boolean_algebra linarith.comp))) := sorry --non-trivial
lemma new_lemma_15689 (h0 : filter (semigroup linarith.comp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_15690 (h0 : functor.add_const (ordered_comm_monoid (has_neg pos)) (has_add (has_Inf linarith.comp))) : @has_exists_mul_of_le.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_neg.{0} pos)) (has_add.{0} (has_Inf.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_15691 (h0 : list (has_inv (random_gen (has_top (random_gen fun_info))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_15692 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_bot.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_15693 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_15694 (h0 : set (has_nnnorm string_imp)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_15695 (h0 : ring (add_cancel_comm_monoid (random_gen reducibility_hints))) : strong_rank_condition (add_cancel_comm_monoid (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_15696 (h0 : monoid (canonically_linear_ordered_monoid (has_Inf (has_add real)))) : monoid.fg (canonically_linear_ordered_monoid (has_Inf (has_add real))) := sorry --non-trivial
lemma new_lemma_15697 (h1 : complete_lattice (encodable (has_inv (has_nnnorm linarith.comp_source)))) : complete_lattice.is_Sup_finite_compact (encodable (has_inv (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_15698 (h0 : topological_space (has_neg_part name)) : topological_space.separable_space (has_neg_part name) := sorry --non-trivial
lemma new_lemma_15699 (h0 : topological_space (distrib (has_ssubset fun_info))) : t0_space (distrib (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_15700 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_15701 (h0 : functor.add_const (topological_space (semigroup Type)) environment.implicit_infer_kind) : @regular_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_15702 (h0 : add_monoid (non_assoc_semiring (has_norm empty))) : add_monoid.fg (non_assoc_semiring (has_norm empty)) := sorry --non-trivial
lemma new_lemma_15703 (h0 : topological_space (semigroup (ring Type))) : preirreducible_space (semigroup (ring Type)) := sorry --non-trivial
lemma new_lemma_15704 (h0 : monoid (add_cancel_monoid (ring name))) : monoid.fg (add_cancel_monoid (ring name)) := sorry --non-trivial
lemma new_lemma_15705 (h0 : topological_space (add_cancel_monoid (option unsigned))) : loc_path_connected_space (add_cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_15706 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_15707 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) name) : @loc_path_connected_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_15708 (h0 : ring (non_unital_non_assoc_semiring (mul_one_class linarith.comp_source))) : rank_condition (non_unital_non_assoc_semiring (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_15709 (h0 : topological_space (with_one (measurable_space.dynkin_system num))) : discrete_topology (with_one (measurable_space.dynkin_system num)) := sorry --non-trivial
lemma new_lemma_15710 (h0 : complete_lattice (has_add Type)) : is_atomistic (has_add Type) := sorry --non-trivial
lemma new_lemma_15711 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_15712 (h2 : topological_space (has_div linarith.ineq)) : path_connected_space (has_div linarith.ineq) := sorry --non-trivial
lemma new_lemma_15713 (h0 : topological_space (has_neg_part (has_add environment.implicit_infer_kind))) : irreducible_space (has_neg_part (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_15714 (h0 : ring (normed_group fun_info)) : rank_condition (normed_group fun_info) := sorry --non-trivial
lemma new_lemma_15715 (h0 : add_group (has_neg (has_neg_part Type))) : is_add_cyclic (has_neg (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_15716 (h0 : uniform_space (normed_lattice_add_comm_group (sub_neg_monoid (has_bot real)))) : complete_space (normed_lattice_add_comm_group (sub_neg_monoid (has_bot real))) := sorry --non-trivial
lemma new_lemma_15717 (h0 : functor.add_const (add_group (semigroup name)) linarith.comp) : @is_add_cyclic.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_15718 (h0 : functor.add_const (topological_space (has_Inf name)) linarith.comp) : @totally_separated_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_15719 (h1 : monoid (with_one string_imp)) : monoid.fg (with_one string_imp) := sorry --non-trivial
lemma new_lemma_15720 (h0 : topological_space (comm_group (has_add Type))) : irreducible_space (comm_group (has_add Type)) := sorry --non-trivial
lemma new_lemma_15721 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (canonically_ordered_add_monoid.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_add_monoid.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_15722 (h0 : uniform_space (id (has_norm (has_top num)))) : separated_space (id (has_norm (has_top num))) := sorry --non-trivial
lemma new_lemma_15723 (h0 : multiset (semi_normed_comm_ring linarith.ineq)) (h1 : not (multiset (semi_normed_comm_ring linarith.ineq) -> false)) : multiset.disjoint h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_15724 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preirreducible_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_15725 (h0 : ordered_comm_monoid (comm_semigroup (has_bot name))) : has_exists_mul_of_le (comm_semigroup (has_bot name)) := sorry --non-trivial
lemma new_lemma_15726 (h0 : filter (has_norm (random_gen (comm_ring linarith.ineq)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_15727 (h0 : add_monoid (metric_space (semiring (has_top (has_top empty))))) : add_monoid.fg (metric_space (semiring (has_top (has_top empty)))) := sorry --non-trivial
lemma new_lemma_15728 (h0 : add_group (add_comm_monoid (add_comm_monoid ennreal))) : is_add_cyclic (add_comm_monoid (add_comm_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_15729 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_neg unsigned)) := sorry --non-trivial
lemma new_lemma_15730 (h0 : add_group (add_group (semiring (semiring unsigned)))) : is_add_cyclic (add_group (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_15731 (h0 : topological_space (pseudo_metric_space (option (option (option (option ennreal)))))) : preirreducible_space (pseudo_metric_space (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_15732 (h0 : functor.add_const (finset (canonically_linear_ordered_monoid name)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_15733 (h0 : finset (comm_group (has_neg pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_15734 (h0 : functor.add_const (topological_space (sub_neg_monoid pos)) linarith.comp) : @regular_space.{0} (sub_neg_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_15735 (h0 : cancel_comm_monoid_with_zero (has_nndist (option ennreal))) : unique_factorization_monoid (has_nndist (option ennreal)) := sorry --non-trivial
lemma new_lemma_15736 (h1 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : discrete_topology empty := sorry --non-trivial
lemma new_lemma_15737 (h0 : functor.add_const (function.extfun Type complete_lattice) Type) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type complete_lattice.{0}) Type h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_15738 (h0 : functor.add_const (topological_space (ring Type)) (has_to_string linarith.comp)) : @topological_space.separable_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) (has_to_string.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_15739 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_15740 (h0 : topological_space (has_append (has_ssubset (has_ssubset (denumerable string_imp))))) : totally_disconnected_space (has_append (has_ssubset (has_ssubset (denumerable string_imp)))) := sorry --non-trivial
lemma new_lemma_15741 (h0 : functor.add_const (complete_lattice (add_semigroup empty)) empty) : @is_atomistic.{0} (add_semigroup.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_15742 (h0 : functor.add_const (topological_space (has_zero Type)) (comm_group pos)) : @loc_path_connected_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) (comm_group.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_15743 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_15744 (h0 : functor.add_const (complete_lattice (cancel_monoid empty)) empty) : @is_compactly_generated.{0} (cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_15745 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_15746 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (canonically_linear_ordered_monoid.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_linear_ordered_monoid.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_15747 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_15748 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_add.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_add.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_15749 (h0 : list (has_neg_part (has_add (has_neg_part ennreal)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_15750 (h1 : Prop) : set.separates_points (id (fun (h0 : char -> ereal), h1)) := sorry --non-trivial
lemma new_lemma_15751 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_15752 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @normalizer_condition.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (group.{1} (generalized_boolean_algebra.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_15753 (h0 : finset (ordered_cancel_add_comm_monoid (complete_distrib_lattice pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_15754 (h0 : topological_space (complete_distrib_lattice (option ennreal))) : discrete_topology (complete_distrib_lattice (option ennreal)) := sorry --non-trivial
lemma new_lemma_15755 (h0 : functor.comp topological_space comm_group name) : @locally_compact_space.{0} (comm_group.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} name h0)  := sorry --non-trivial
lemma new_lemma_15756 (h0 : group (ring (has_Inf (has_Inf linarith.comp)))) : is_cyclic (ring (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_15757 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (has_union unsigned)) := sorry --non-trivial
lemma new_lemma_15758 (h0 : topological_space (has_neg (normed_comm_ring Type))) : preconnected_space (has_neg (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_15759 (h0 : group (semi_normed_comm_ring linarith.ineq)) : is_cyclic (semi_normed_comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_15760 (h0 : functor.add_const (finset (measurable_space.dynkin_system num)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_15761 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (dlist.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (dlist.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_15762 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_15763 (h0 : topological_space (normed_group (semiring empty))) : t0_space (normed_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_15764 (h0 : uniform_space (comm_group unsigned)) : separated_space (comm_group unsigned) := sorry --non-trivial
lemma new_lemma_15765 (h0 : function.extfun (finset Type) (has_mem.mem (has_one linarith.comp))) : @locally_compact_space.{0} (has_one.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_15766 (h0 : topological_space (semigroup (has_neg Type))) : locally_compact_space (semigroup (has_neg Type)) := sorry --non-trivial
lemma new_lemma_15767 (h0 : not (filter (measurable_space linarith.comp) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_15768 (h0 : monoid (has_top (has_norm empty))) : monoid.fg (has_top (has_norm empty)) := sorry --non-trivial
lemma new_lemma_15769 (h0 : topological_space ereal) (h1 : preorder ereal) : order_topology ereal := sorry --non-trivial
lemma new_lemma_15770 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_15771 (h0 : not (topological_space (semiring (random_gen fun_info)) -> false)) : @locally_compact_space.{0} (semiring.{0} (random_gen.{0} fun_info)) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} (random_gen.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_15772 (h0 : ring (has_pos_part empty)) : is_principal_ideal_ring (has_pos_part empty) := sorry --non-trivial
lemma new_lemma_15773 (h0 : uniform_space (monoid_with_zero empty)) : separated_space (monoid_with_zero empty) := sorry --non-trivial
lemma new_lemma_15774 (h0 : function.extfun Type topological_space) : @t1_space.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_15775 (h0 : group (linear_ordered_semiring (semiring (semiring (semiring empty))))) : normalizer_condition (linear_ordered_semiring (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_15776 (h0 : set (set char)) : measurable_space.dynkin_system.generate_has h0 is_bot := sorry --non-trivial
lemma new_lemma_15777 (h0 : ring (random_gen linarith.comp_source)) : rank_condition (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_15778 (h0 : ordered_comm_monoid (ring (has_neg_part (boolean_algebra environment.implicit_infer_kind)))) : has_exists_mul_of_le (ring (has_neg_part (boolean_algebra environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_15779 (h0 h2 : multiset (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup linarith.ineq))))) : multiset.le h0 h2 := sorry --non-trivial
lemma new_lemma_15780 (h1 : not (complete_lattice (distrib fun_info) -> false)) : @is_compactly_generated.{0} (distrib.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (distrib.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_15781 (h0 : not (prod (add_group congr_arg_kind) (add_group congr_arg_kind) -> false)) : id_rel (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_15782 (h0 : topological_space (ordered_ring (semiring num))) : discrete_topology (ordered_ring (semiring num)) := sorry --non-trivial
lemma new_lemma_15783 (h0 : functor.add_const (topological_space (has_nndist pos)) pos) : @preirreducible_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_15784 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (partial_order (ordered_ring empty))) := sorry --non-trivial
lemma new_lemma_15785 (h0 : functor.add_const (group (has_neg linarith.comp)) (finset environment.implicit_infer_kind)) : @group.fg.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} linarith.comp)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_15786 (h0 : cancel_comm_monoid_with_zero (add_group (semiring (semiring (semiring unsigned))))) : unique_factorization_monoid (add_group (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_15787 (h0 : topological_space (measurable_space (semiring unsigned))) : discrete_topology (measurable_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_15788 (h0 : ring (has_add (has_Inf name))) : is_domain (has_add (has_Inf name)) := sorry --non-trivial
lemma new_lemma_15789 (h0 : list (linear_ordered_comm_monoid_with_zero congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_15790 (h0 : topological_space (has_nndist (finset pos))) : totally_separated_space (has_nndist (finset pos)) := sorry --non-trivial
lemma new_lemma_15791 (h0 : function.extfun Type group) : @is_cyclic.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_15792 (h0 : monoid (canonically_ordered_comm_semiring (option empty))) : monoid.fg (canonically_ordered_comm_semiring (option empty)) := sorry --non-trivial
lemma new_lemma_15793 (h0 : set (nondiscrete_normed_field linarith.ineq)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_15794 (h0 : topological_space (add_cancel_monoid (semigroup (comm_group (comm_group Type))))) : preconnected_space (add_cancel_monoid (semigroup (comm_group (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_15795 (h0 : functor.add_const (uniform_space (boolean_algebra.core pos)) Type) : @separated_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (boolean_algebra.core.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_15796 (h0 : topological_space (add_monoid linarith.ineq)) : totally_disconnected_space (add_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_15797 (h0 : measurable_space (semiring linarith.comp_source)) (h1 : function.extfun Type has_add) (h2 : measure_theory.measure (semiring linarith.comp_source)) : @measure_theory.measure.is_add_left_invariant.{0} (semiring.{0} linarith.comp_source) h0 (@function.extfun_app.{2 1} Type has_add.{0} h1 (semiring.{0} linarith.comp_source)) h2  := sorry --non-trivial
lemma new_lemma_15798 (h0 : id (semiring (has_norm linarith.ineq)) -> id (semiring (has_norm linarith.ineq)) -> Prop) : is_equiv (id (semiring (has_norm linarith.ineq))) h0 := sorry --non-trivial
lemma new_lemma_15799 (h0 : set (has_lt fun_info)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_15800 (h0 : topological_space (has_le (mul_one_class string_imp))) : path_connected_space (has_le (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_15801 (h0 : functor.add_const (topological_space (semigroup empty)) (semiring empty)) : @totally_separated_space.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_15802 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) Type) : @normal_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_15803 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (preorder empty)) := sorry --non-trivial
lemma new_lemma_15804 (h0 : ring (boolean_algebra (has_add name))) : rank_condition (boolean_algebra (has_add name)) := sorry --non-trivial
lemma new_lemma_15805 (h0 : function.extfun (finset Type) (has_mem.mem (semiring empty))) : @is_atomistic.{0} (semiring.{0} empty) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (semiring.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_15806 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_inv.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inv.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_15807 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_15808 (h0 : functor.add_const (add_monoid (left_cancel_semigroup congr_arg_kind)) congr_arg_kind) : @add_monoid.fg.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (left_cancel_semigroup.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_15809 (h0 : add_monoid (left_cancel_semigroup (semiring empty))) : add_monoid.fg (left_cancel_semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_15810 (h0 : topological_space (canonically_ordered_comm_semiring (ring pos))) : locally_compact_space (canonically_ordered_comm_semiring (ring pos)) := sorry --non-trivial
lemma new_lemma_15811 (h0 : functor.add_const (complete_lattice (ring environment.implicit_infer_kind)) (has_neg pos)) : @is_compactly_generated.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} environment.implicit_infer_kind)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_15812 (h1 : complete_lattice (comm_ring (metric_space (metric_space to_additive.value_type)))) : is_compactly_generated (comm_ring (metric_space (metric_space to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_15813 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_15814 (h0 : list (monoid (comm_monoid unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_15815 (h0 : complete_lattice (option (semiring (semiring empty)))) : is_atomistic (option (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_15816 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_15817 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_15818 (h0 : add_group (add_group empty)) : is_add_cyclic (add_group empty) := sorry --non-trivial
lemma new_lemma_15819 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (left_cancel_monoid.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (left_cancel_monoid.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_15820 (h0 : group ordering) : group.fg ordering := sorry --non-trivial
lemma new_lemma_15821 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @irreducible_space.{0} (has_emptyc.{0} (has_norm.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_emptyc.{0} (has_norm.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_15822 (h0 : list (generalized_boolean_algebra (has_nndist (ring pos)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_15823 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_15824 (h0 : ring (random_gen to_additive.value_type)) : is_principal_ideal_ring (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_15825 (h1 : group (encodable char)) : is_cyclic (encodable char) := sorry --non-trivial
lemma new_lemma_15826 (h0 : topological_space (finset (has_add name))) : totally_separated_space (finset (has_add name)) := sorry --non-trivial
lemma new_lemma_15827 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @topological_space.separable_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_15828 (h0 : list (add_cancel_monoid (has_add name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_15829 (h0 : not (add_monoid (bin_tree num) -> false)) : @add_monoid.fg.{0} (bin_tree.{0} num) (@classical.by_contradiction'.{1} (add_monoid.{0} (bin_tree.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_15830 (h0 : topological_space (div_inv_monoid (option empty))) : discrete_topology (div_inv_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_15831 (h0 : topological_space (ordered_comm_monoid (has_pos_part (boolean_algebra.core (has_Inf Type))))) : path_connected_space (ordered_comm_monoid (has_pos_part (boolean_algebra.core (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_15832 (h0 : topological_space (with_zero (has_nnnorm char))) : path_connected_space (with_zero (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_15833 (h0 : add_monoid (with_one congr_arg_kind)) : add_monoid.fg (with_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_15834 (h0 : functor.add_const (semiring (cancel_monoid name)) (semigroup (add_cancel_monoid Type))) : @is_noetherian_ring.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (semiring.{0} (cancel_monoid.{0} name)) (semigroup.{1} (add_cancel_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_15835 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_15836 (h0 : topological_space (non_assoc_semiring (option unsigned))) : totally_separated_space (non_assoc_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_15837 (h1 : monoid (measurable_space congr_arg_kind)) : monoid.fg (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_15838 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) linarith.comp) : @preirreducible_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_15839 (h0 : topological_space (has_top (random_gen (random_gen fun_info)))) : t0_space (has_top (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_15840 (h0 : functor.add_const (add_monoid (semigroup unsigned)) (has_nndist (ring linarith.comp))) : @add_monoid.fg.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (semigroup.{0} unsigned)) (has_nndist.{0} (ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_15841 (h0 : function.extfun (Type 1) topological_space) : @t1_space.{1} (pseudo_metric_space.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (pseudo_metric_space.{1} Type))  := sorry --non-trivial
lemma new_lemma_15842 (h0 : not (filter (bin_tree unsigned) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_15843 (h0 : topological_space (add_cancel_monoid (finset (has_pos_part (finset (finset pos)))))) : path_connected_space (add_cancel_monoid (finset (has_pos_part (finset (finset pos))))) := sorry --non-trivial
lemma new_lemma_15844 (h0 : ring (has_top (has_add string_imp))) : is_domain (has_top (has_add string_imp)) := sorry --non-trivial
lemma new_lemma_15845 (h0 : uniform_space (ring Type)) : separated_space (ring Type) := sorry --non-trivial
lemma new_lemma_15846 (h0 : cancel_comm_monoid_with_zero (has_pos_part (has_add real))) : unique_factorization_monoid (has_pos_part (has_add real)) := sorry --non-trivial
lemma new_lemma_15847 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @is_cyclic.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_15848 (h0 : fin has_zero.zero) : @is_cyclic.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (group.{1} (canonically_ordered_monoid.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_15849 (h0 : topological_space (has_pos_part real)) : t0_space (has_pos_part real) := sorry --non-trivial
lemma new_lemma_15850 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_15851 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @loc_path_connected_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_15852 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_15853 (h0 : list (with_one (with_bot (has_ssubset (has_norm fun_info))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_15854 (h0 : functor.add_const (add_group (has_pos_part pos)) linarith.comp) : @is_add_cyclic.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_pos_part.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_15855 (h0 : functor.add_const (function.extfun Type add_monoid) pos) : @add_monoid.fg.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) pos h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_15856 (h0 : topological_space (boolean_algebra.core (has_to_string pos))) : topological_space.separable_space (boolean_algebra.core (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_15857 (h0 : topological_space (add_cancel_comm_monoid unsigned)) : preirreducible_space (add_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_15858 (h0 : functor.add_const (functor.add_const (cancel_comm_monoid_with_zero pos) unsigned) pos) : @unique_factorization_monoid.{0} pos (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} pos) unsigned (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} pos) unsigned) pos h0))  := sorry --non-trivial
lemma new_lemma_15859 (h0 : topological_space (has_neg (has_add pos))) : preconnected_space (has_neg (has_add pos)) := sorry --non-trivial
lemma new_lemma_15860 (h0 : filter (has_sdiff empty)) (h1 : has_sdiff empty -> Prop) : @filter.limsup.{0 0} Prop (has_sdiff.{0} empty) (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice) h0 h1  := sorry --non-trivial
lemma new_lemma_15861 (h0 : monoid (semigroup Type)) : monoid.fg (semigroup Type) := sorry --non-trivial
lemma new_lemma_15862 (h0 : topological_space (finset Type)) : normal_space (finset Type) := sorry --non-trivial
lemma new_lemma_15863 (h0 : prod (has_add (option (option (option ennreal)))) (has_add (option (option (option ennreal))))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_15864 (h0 : functor.add_const (function.extfun Type list) name) : palindrome (function.extfun_app (functor.add_const.run h0) (comm_group name)) := sorry --non-trivial
lemma new_lemma_15865 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_15866 (h0 : complete_lattice (dlist (with_zero (with_zero (dlist fun_info))))) : is_compactly_generated (dlist (with_zero (with_zero (dlist fun_info)))) := sorry --non-trivial
lemma new_lemma_15867 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @group.fg.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_15868 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_15869 (h0 : topological_space (has_ssubset (metric_space to_additive.value_type))) : t0_space (has_ssubset (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_15870 (h1 : ring (normed_field linarith.comp_source)) : is_domain (normed_field linarith.comp_source) := sorry --non-trivial
lemma new_lemma_15871 (h0 : topological_space (has_star (semiring (semiring (semiring (semiring unsigned)))))) : discrete_topology (has_star (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_15872 (h0 : functor.add_const (topological_space (cancel_monoid name)) pos) : @preconnected_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_15873 (h1 : ring (comm_ring (metric_space (has_lt (metric_space linarith.comp_source))))) : strong_rank_condition (comm_ring (metric_space (has_lt (metric_space linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_15874 (h0 : topological_space (boolean_algebra.core (boolean_algebra (boolean_algebra Type)))) : sequential_space (boolean_algebra.core (boolean_algebra (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_15875 (h0 : cancel_comm_monoid_with_zero (has_add (has_add linarith.comp))) : unique_factorization_monoid (has_add (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_15876 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (preorder.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (preorder.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_15877 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_15878 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_15879 (h0 : complete_lattice (has_to_string (option (option (option pos))))) : is_atomistic (has_to_string (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_15880 (h0 : functor.add_const (function.extfun Type monoid) (boolean_algebra name)) : @monoid.fg.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) (boolean_algebra.{0} name) h0) (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_15881 (h0 : not (topological_space (has_emptyc to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (has_emptyc.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_15882 (h0 : topological_space (cancel_monoid num)) : topological_space.separable_space (cancel_monoid num) := sorry --non-trivial
lemma new_lemma_15883 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_15884 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_15885 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_15886 (h0 : ring (monoid_with_zero congr_arg_kind)) : is_domain (monoid_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_15887 (h0 : group (has_add (mul_one_class Type))) : is_cyclic (has_add (mul_one_class Type)) := sorry --non-trivial
lemma new_lemma_15888 (h0 : uniform_space (linear_ordered_comm_ring (semiring (semiring (semiring congr_arg_kind))))) : complete_space (linear_ordered_comm_ring (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_15889 (h0 : filter (canonically_ordered_comm_semiring unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_15890 (h0 : ring (ring (has_neg pos))) : rank_condition (ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_15891 (h0 : function.extfun Type (functor.add_const (ring auto.case_option))) : @is_domain.{0} auto.case_option (@functor.add_const.run.{0 0} (ring.{0} auto.case_option) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} auto.case_option)) h0 num))  := sorry --non-trivial
lemma new_lemma_15892 (h0 : has_mem.mem group has_emptyc.emptyc) : @normalizer_condition.{0} (free_add_monoid.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (free_add_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_15893 (h0 : ring (ring (has_add linarith.comp))) : rank_condition (ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_15894 (h0 : finset (normed_lattice_add_comm_group (has_Inf Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_15895 (h0 : function.extfun Type group) : @is_cyclic.{0} (left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_15896 (h0 : uniform_space (measurable_space (has_top (has_top (has_top fun_info))))) : complete_space (measurable_space (has_top (has_top (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_15897 (h0 : group (with_bot (comm_ring fun_info))) : is_cyclic (with_bot (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_15898 (h0 : topological_space (add_comm_monoid (finset (finset linarith.comp)))) : path_connected_space (add_comm_monoid (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_15899 (h0 : complete_lattice enat) : complete_lattice.is_Sup_finite_compact enat := sorry --non-trivial
lemma new_lemma_15900 (h0 : topological_space (has_neg (has_add name))) : totally_disconnected_space (has_neg (has_add name)) := sorry --non-trivial
lemma new_lemma_15901 (h0 : list (has_norm (boolean_algebra.core (random_gen linarith.comp_source)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_15902 (h0 : has_mem.mem group has_emptyc.emptyc) : @is_cyclic.{0} (linear_ordered_semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (linear_ordered_semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_15903 (h0 : functor.add_const (function.extfun Type uniform_space) pos) : @complete_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) pos h0) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_15904 (h0 : uniform_space (semigroup (has_nndist (ring (has_pos_part (has_to_string Type)))))) : separated_space (semigroup (has_nndist (ring (has_pos_part (has_to_string Type))))) := sorry --non-trivial
lemma new_lemma_15905 (h1 : ring (normed_field (metric_space (metric_space to_additive.value_type)))) : strong_rank_condition (normed_field (metric_space (metric_space to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_15906 (h2 : measurable_space char) (h3 : measure_theory.measure char) : measure_theory.is_finite_measure h3 := sorry --non-trivial
lemma new_lemma_15907 (h0 : group (add_cancel_monoid (complete_distrib_lattice (boolean_algebra linarith.comp)))) : is_cyclic (add_cancel_monoid (complete_distrib_lattice (boolean_algebra linarith.comp))) := sorry --non-trivial
lemma new_lemma_15908 (h0 : topological_space (canonically_ordered_comm_semiring (option (option empty)))) : preirreducible_space (canonically_ordered_comm_semiring (option (option empty))) := sorry --non-trivial
lemma new_lemma_15909 (h0 : not (topological_space (with_one empty) -> false)) : @locally_compact_space.{0} (with_one.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_15910 (h0 : list (comm_group (has_to_string pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_15911 (h0 : functor.add_const (topological_space (bin_tree congr_arg_kind)) unsigned) : @topological_space.separable_space.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_15912 (h0 : functor.add_const (cancel_comm_monoid_with_zero (canonically_ordered_add_monoid empty)) (option empty)) : @unique_factorization_monoid.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (canonically_ordered_add_monoid.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_15913 (h0 : topological_space (simple_graph (mul_one_class string.iterator_imp))) (h1 : add_group (simple_graph (mul_one_class string.iterator_imp))) : topological_add_group (simple_graph (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_15914 (h0 : topological_space (finset (has_neg Type))) : regular_space (finset (has_neg Type)) := sorry --non-trivial
lemma new_lemma_15915 (h0 : topological_space (has_Inf (complete_distrib_lattice (ordered_ring (ring (has_pos_part pos)))))) : normal_space (has_Inf (complete_distrib_lattice (ordered_ring (ring (has_pos_part pos))))) := sorry --non-trivial
lemma new_lemma_15916 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_15917 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (add_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_15918 (h0 : complete_lattice (linear_ordered_field (option num))) : is_compactly_generated (linear_ordered_field (option num)) := sorry --non-trivial
lemma new_lemma_15919 (h0 : topological_space (pseudo_metric_space (option (option ennreal)))) : irreducible_space (pseudo_metric_space (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_15920 (h2 : std_gen -> std_gen -> Prop) (h3 h4 : std_gen) : eqv_gen h2 h3 h4 := sorry --non-trivial
lemma new_lemma_15921 (h0 : functor.add_const (function.extfun (Type 1) filter) pos) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_15922 (h0 : prod (add_comm_monoid (option num)) (add_comm_monoid (option num))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_15923 (h0 : ring (add_right_cancel_monoid empty)) : rank_condition (add_right_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_15924 (h0 : monoid (semiring (semiring congr_arg_kind))) : monoid.fg (semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_15925 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_15926 (h0 : topological_space (has_one linarith.comp_source)) : path_connected_space (has_one linarith.comp_source) := sorry --non-trivial
lemma new_lemma_15927 (h0 : topological_space (has_pos_part (has_neg (has_Inf name)))) : regular_space (has_pos_part (has_neg (has_Inf name))) := sorry --non-trivial
lemma new_lemma_15928 (h0 : topological_space (complete_distrib_lattice linarith.comp)) : path_connected_space (complete_distrib_lattice linarith.comp) := sorry --non-trivial
lemma new_lemma_15929 (h0 : complete_lattice (has_zero Type)) : is_compactly_generated (has_zero Type) := sorry --non-trivial
lemma new_lemma_15930 (h0 : ring (random_gen (has_nnnorm (has_nnnorm (has_lt (has_nnnorm linarith.ineq)))))) : strong_rank_condition (random_gen (has_nnnorm (has_nnnorm (has_lt (has_nnnorm linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_15931 (h0 : function.extfun Type (prod (complete_distrib_lattice (option (option num))))) : id_rel (function.extfun_app h0 (complete_distrib_lattice (option (option num)))) := sorry --non-trivial
lemma new_lemma_15932 (h0 : complete_lattice (normed_comm_ring Type)) : is_compactly_generated (normed_comm_ring Type) := sorry --non-trivial
lemma new_lemma_15933 (h0 : function.extfun Type (functor.add_const (topological_space (has_Sup empty)))) : @loc_path_connected_space.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} empty)) (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_Sup.{0} empty))) h0 (semiring.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_15934 (h0 : functor.add_const (list (ring linarith.comp)) (finset environment.implicit_infer_kind)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_15935 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (finset.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (finset.{0} num))  := sorry --non-trivial
lemma new_lemma_15936 (h0 : filter (has_inter (option unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_15937 (h0 : topological_space (ordered_comm_ring (ordered_comm_ring (ring Type)))) : path_connected_space (ordered_comm_ring (ordered_comm_ring (ring Type))) := sorry --non-trivial
lemma new_lemma_15938 (h0 : semiring (boolean_algebra.core name)) : is_noetherian_ring (boolean_algebra.core name) := sorry --non-trivial
lemma new_lemma_15939 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) (comm_group name)) : @sequential_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_15940 (h0 : topological_space (semigroup (option (option (option empty))))) : loc_path_connected_space (semigroup (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_15941 (h0 : char -> std_gen -> Prop) (h1 : option char) (h2 : option std_gen) : option.rel h0 h1 h2 := sorry --non-trivial
lemma new_lemma_15942 (h0 : topological_space (with_one (has_top (has_top fun_info)))) : path_connected_space (with_one (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_15943 (h0 : topological_space (nondiscrete_normed_field (normed_field (normed_field char)))) : t0_space (nondiscrete_normed_field (normed_field (normed_field char))) := sorry --non-trivial
lemma new_lemma_15944 (h0 : complete_lattice (semi_normed_comm_ring to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (semi_normed_comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_15945 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_star.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_star.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_15946 (h0 : topological_space (linear_ordered_comm_ring (has_top empty))) : normal_space (linear_ordered_comm_ring (has_top empty)) := sorry --non-trivial
lemma new_lemma_15947 (h0 : functor.add_const (topological_space (has_zero Type)) (ring environment.implicit_infer_kind)) : @totally_separated_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_15948 (h0 : monoid (add_comm_monoid (has_to_string pos))) : monoid.fg (add_comm_monoid (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_15949 (h0 : complete_lattice (has_bot (has_add pos))) : complete_lattice.is_Sup_finite_compact (has_bot (has_add pos)) := sorry --non-trivial
lemma new_lemma_15950 (h0 : fin has_zero.zero) : @normal_space.{1} (has_Inf.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_Inf.{1} Type)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_15951 (h0 : complete_lattice (has_add (has_add (has_add (boolean_algebra real))))) : is_atomistic (has_add (has_add (has_add (boolean_algebra real)))) := sorry --non-trivial
lemma new_lemma_15952 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (ring.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (ring.{0} num))  := sorry --non-trivial
lemma new_lemma_15953 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_15954 (h1 : has_mem.mem (complete_semilattice_Sup (has_norm linarith.comp_source)) has_emptyc.emptyc) : @totally_separated_space.{0} (complete_semilattice_Sup.{0} (has_norm.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} (has_norm.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_15955 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_add_cyclic.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_group.{1}) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_15956 (h0 : add_monoid (finset (option pos))) : add_monoid.fg (finset (option pos)) := sorry --non-trivial
lemma new_lemma_15957 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) (has_neg Type)) : @totally_separated_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_15958 (h0 : topological_space (boolean_algebra.core (has_add Type))) : path_connected_space (boolean_algebra.core (has_add Type)) := sorry --non-trivial
lemma new_lemma_15959 (h0 : functor.add_const (functor.add_const (group pos) unsigned) (option pos)) : @normalizer_condition.{0} pos (@functor.add_const.run.{0 0} (group.{0} pos) unsigned (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (group.{0} pos) unsigned) (option.{0} pos) h0))  := sorry --non-trivial
lemma new_lemma_15960 (h0 : topological_space (with_one (has_norm unsigned))) : irreducible_space (with_one (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_15961 (h0 : topological_space (add_comm_monoid Type)) : preconnected_space (add_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_15962 (h0 : group (has_neg_part (finset environment.implicit_infer_kind))) : is_cyclic (has_neg_part (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_15963 (h0 : topological_space (pseudo_metric_space (has_nndist ennreal))) : irreducible_space (pseudo_metric_space (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_15964 (h0 : list (finset (boolean_algebra unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_15965 (h0 : topological_space (has_inter (option num))) : normal_space (has_inter (option num)) := sorry --non-trivial
lemma new_lemma_15966 (h0 : group (has_neg (has_add (finset (finset pos))))) : group.fg (has_neg (has_add (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_15967 (h0 : functor.add_const (uniform_space (free_add_monoid unsigned)) empty) : @separated_space.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (free_add_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_15968 (h0 : functor.add_const (uniform_space (has_Inf linarith.comp)) (has_add pos)) : @separated_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_Inf.{0} linarith.comp)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_15969 (h0 : functor.add_const (ring (add_comm_monoid Type)) linarith.comp) : @is_domain.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (add_comm_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_15970 (h0 : topological_space (linear_ordered_add_comm_group (random_gen (random_gen string_imp)))) : totally_separated_space (linear_ordered_add_comm_group (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_15971 (h0 : ring (denumerable reducibility_hints)) : rank_condition (denumerable reducibility_hints) := sorry --non-trivial
lemma new_lemma_15972 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_15973 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (filter.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (filter.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_15974 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_15975 (h0 : topological_space (canonically_ordered_monoid (ordered_comm_ring real))) : preirreducible_space (canonically_ordered_monoid (ordered_comm_ring real)) := sorry --non-trivial
lemma new_lemma_15976 (h0 : finset (mul_zero_class (finset (finset (has_nndist Type))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_15977 (h0 : finset (has_nndist (option (option (option (option (option empty))))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_15978 (h0 : functor.add_const (filter (ring pos)) (finset (has_neg linarith.comp))) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_15979 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (semigroup.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} h0 (semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_15980 (h0 : topological_space (has_Inf (has_Inf Type))) : path_connected_space (has_Inf (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_15981 (h0 : not (topological_space (comm_ring linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (comm_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (comm_ring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_15982 (h0 : topological_space (monoid_with_zero (ring pos))) : normal_space (monoid_with_zero (ring pos)) := sorry --non-trivial
lemma new_lemma_15983 (h0 : functor.add_const (add_monoid (plift num)) (semiring (semiring (semiring empty)))) : @add_monoid.fg.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (add_monoid.{1} (plift.{1} num)) (semiring.{0} (semiring.{0} (semiring.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_15984 (h0 : topological_space (mul_one_class (mul_one_class char))) (h1 : preorder (mul_one_class (mul_one_class char))) : order_closed_topology (mul_one_class (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_15985 (h0 : topological_space (has_nndist (has_neg_part pos))) : regular_space (has_nndist (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_15986 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (uniform_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (uniform_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_15987 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @t1_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_15988 (h0 : topological_space (add_comm_monoid unsigned)) : topological_space.separable_space (add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_15989 (h0 : add_monoid (has_zero (has_to_string environment.implicit_infer_kind))) : add_monoid.fg (has_zero (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_15990 (h0 : function.extfun Type ring) : @rank_condition.{0} (linear_ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_15991 (h0 : uniform_space (id (semiring (semiring (semiring (semiring empty)))))) : separated_space (id (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_15992 (h0 : topological_space (canonically_ordered_monoid (has_Inf real))) : loc_path_connected_space (canonically_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_15993 (h0 : function.extfun (Type 1) filter) : filter.ne_bot (function.extfun_app h0 (add_cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_15994 (h1 : complete_lattice (denumerable linarith.ineq)) : complete_lattice.is_Sup_finite_compact (denumerable linarith.ineq) := sorry --non-trivial
lemma new_lemma_15995 (h0 : topological_space (plift congr_arg_kind)) : path_connected_space (plift congr_arg_kind) := sorry --non-trivial
lemma new_lemma_15996 (h1 : function.extfun (finset Type) (has_mem.mem (with_one congr_arg_kind))) : @totally_disconnected_space.{0} (with_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} congr_arg_kind)) h1 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_15997 (h0 : add_group (denumerable (comm_ring (comm_ring (has_nnnorm fun_info))))) : is_add_cyclic (denumerable (comm_ring (comm_ring (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_15998 (h0 : monoid (measurable_space.dynkin_system linarith.comp)) : monoid.fg (measurable_space.dynkin_system linarith.comp) := sorry --non-trivial
lemma new_lemma_15999 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
