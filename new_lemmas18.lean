import imports
lemma new_lemma_144000 (h0 : measurable_space (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup fun_info))))) (h1 : set (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup fun_info))))) : measurable_set h1 := sorry --non-trivial
lemma new_lemma_144001 (h0 : functor.comp topological_space has_neg name) : @normal_space.{0} (has_neg.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} name h0)  := sorry --non-trivial
lemma new_lemma_144002 (h0 : functor.add_const (complete_lattice (has_inter empty)) ennreal) : @is_atomistic.{0} (has_inter.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_inter.{0} empty)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_144003 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_144004 (h0 : topological_space (ordered_comm_monoid (has_Inf (boolean_algebra.core (has_add Type))))) : irreducible_space (ordered_comm_monoid (has_Inf (boolean_algebra.core (has_add Type)))) := sorry --non-trivial
lemma new_lemma_144005 (h0 : filter (group_with_zero (option (option (option (option (option ennreal))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_144006 (h0 : uniform_space (boolean_algebra.core congr_arg_kind)) : separated_space (boolean_algebra.core congr_arg_kind) := sorry --non-trivial
lemma new_lemma_144007 (h1 : ring (topological_space fun_info)) : rank_condition (topological_space fun_info) := sorry --non-trivial
lemma new_lemma_144008 (h0 : topological_space real) : loc_path_connected_space real := sorry --non-trivial
lemma new_lemma_144009 (h0 : decidable_eq (partial_order empty)) (h1 : equiv.perm (partial_order empty)) : equiv.perm.is_swap h1 := sorry --non-trivial
lemma new_lemma_144010 (h0 : complete_lattice (has_zero (has_to_string unsigned))) : is_compactly_generated (has_zero (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_144011 (h1 : add_group (nondiscrete_normed_field fun_info)) : is_add_cyclic (nondiscrete_normed_field fun_info) := sorry --non-trivial
lemma new_lemma_144012 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_to_string.{0} (option.{0} ennreal)) (@functor.comp.run.{0 0 0} complete_lattice.{0} has_to_string.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} complete_lattice.{0} has_to_string.{0}) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.comp.{0 0 0} complete_lattice.{0} has_to_string.{0})) (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_144013 (h0 : prod nnreal nnreal) : id_rel h0 := sorry --non-trivial
lemma new_lemma_144014 (h0 : monoid (preorder congr_arg_kind)) : monoid.fg (preorder congr_arg_kind) := sorry --non-trivial
lemma new_lemma_144015 (h0 : topological_space (has_neg ennreal)) : totally_separated_space (has_neg ennreal) := sorry --non-trivial
lemma new_lemma_144016 (h0 : thunk Prop) : @id.{1} Prop (@trace_call_stack.{0} Prop h0)  := sorry --non-trivial
lemma new_lemma_144017 (h2 : ring (encodable linarith.ineq)) : is_domain (encodable linarith.ineq) := sorry --non-trivial
lemma new_lemma_144018 (h1 : complete_lattice (has_div (mul_one_class string_imp))) : complete_lattice.is_Sup_finite_compact (has_div (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_144019 (h0 : topological_space (has_nndist (has_to_string name))) : preirreducible_space (has_nndist (has_to_string name)) := sorry --non-trivial
lemma new_lemma_144020 (h0 : functor.add_const (function.extfun Type monoid) num -> Prop) (h1 : Exists (fun (x : functor.add_const (function.extfun Type monoid) num), h0 x)) : @monoid.fg.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) num (@classical.some.{2} (functor.add_const.{1 0} (function.extfun.{2 1} Type monoid.{0}) num) h0 h1)) (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_144021 (h4 : set (linarith.ineq -> linarith.ineq)) : set.separates_points h4 := sorry --non-trivial
lemma new_lemma_144022 (h0 : complete_lattice (has_top (has_norm (has_top fun_info)))) : complete_lattice.is_Sup_finite_compact (has_top (has_norm (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_144023 (h0 : functor.add_const (topological_space (has_inter num)) unsigned) : @irreducible_space.{0} (has_inter.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_inter.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_144024 (h0 : add_monoid (cancel_monoid (has_add (has_add (has_add name))))) : add_monoid.fg (cancel_monoid (has_add (has_add (has_add name)))) := sorry --non-trivial
lemma new_lemma_144025 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @complete_space.{0} (@id.{2} Type string_imp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) uniform_space.{0}) (@id.{2} Type string_imp))  := sorry --non-trivial
lemma new_lemma_144026 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg_part.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_144027 (h0 : not (ring (random_gen (has_nnnorm (random_gen char))) -> false)) : @strong_rank_condition.{0} (random_gen.{0} (has_nnnorm.{0} (random_gen.{0} char))) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} (has_nnnorm.{0} (random_gen.{0} char)))) h0)  := sorry --non-trivial
lemma new_lemma_144028 (h0 : topological_space (has_bot (sub_neg_monoid Type))) : loc_path_connected_space (has_bot (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_144029 (h0 : group (normed_field (has_nnnorm (denumerable reducibility_hints)))) : is_cyclic (normed_field (has_nnnorm (denumerable reducibility_hints))) := sorry --non-trivial
lemma new_lemma_144030 (h0 : functor.add_const (semiring (finset ennreal)) num) : @is_noetherian_ring.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 0} (semiring.{0} (finset.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_144031 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (as_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (as_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_144032 (h0 : topological_space (ordered_comm_ring pos)) : sequential_space (ordered_comm_ring pos) := sorry --non-trivial
lemma new_lemma_144033 (h0 : ring (random_gen (topological_space (topological_space linarith.ineq)))) : strong_rank_condition (random_gen (topological_space (topological_space linarith.ineq))) := sorry --non-trivial
lemma new_lemma_144034 (h0 : not (uniform_space (linear_ordered_comm_group_with_zero char) -> false)) : @complete_space.{0} (linear_ordered_comm_group_with_zero.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (linear_ordered_comm_group_with_zero.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_144035 (h0 : functor.add_const (topological_space (generalized_boolean_algebra Type)) (has_neg (has_neg linarith.comp))) : @preirreducible_space.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) (has_neg.{0} (has_neg.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_144036 (h0 : complete_lattice (has_compl (has_ssubset char))) : complete_lattice.is_Sup_finite_compact (has_compl (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_144037 (h0 : topological_space (ring (has_neg pos))) : preirreducible_space (ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_144038 (h0 : topological_space (with_one (measurable_space (metric_space linarith.comp)))) : discrete_topology (with_one (measurable_space (metric_space linarith.comp))) := sorry --non-trivial
lemma new_lemma_144039 (h0 : function.extfun (set congr_arg_kind) (fun (x : set congr_arg_kind), Prop)) : is_countably_spanning (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_144040 (h0 : uniform_space (add_comm_semigroup (mul_one_class reducibility_hints))) : complete_space (add_comm_semigroup (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_144041 (h0 : functor.comp ordered_add_comm_monoid has_to_string name) : @archimedean.{0} (has_to_string.{0} name) (@functor.comp.run.{0 0 0} ordered_add_comm_monoid.{0} has_to_string.{0} name h0)  := sorry --non-trivial
lemma new_lemma_144042 (h0 : finset (has_neg (has_add (has_add (ring (has_add stieltjes_function)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_144043 (h0 : ring (has_ssubset environment.projection_info)) : is_domain (has_ssubset environment.projection_info) := sorry --non-trivial
lemma new_lemma_144044 (h0 : add_group (denumerable (random_gen linarith.ineq))) : is_add_cyclic (denumerable (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_144045 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_144046 (h0 : topological_space (has_nndist environment.implicit_infer_kind)) : path_connected_space (has_nndist environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_144047 (h0 : not (has_mem.mem (with_bot num) has_emptyc.emptyc -> false)) : @path_connected_space.{0} (with_bot.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_144048 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @regular_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_144049 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) Type) : @path_connected_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_144050 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_144051 (h0 : functor.add_const (filter (semigroup pos)) (has_to_string environment.implicit_infer_kind)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_144052 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (complete_linear_order num)) := sorry --non-trivial
lemma new_lemma_144053 (h0 : topological_space (mul_one_class linarith.ineq)) : path_connected_space (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_144054 (h0 : functor.add_const (list (has_nndist Type)) (ring environment.implicit_infer_kind)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_144055 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @archimedean.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ordered_add_comm_monoid.{1}) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_144056 (h0 : semiring (has_add (has_add real))) : is_noetherian_ring (has_add (has_add real)) := sorry --non-trivial
lemma new_lemma_144057 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_repr.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_repr.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_144058 (h0 : complete_lattice (add_left_cancel_monoid linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (add_left_cancel_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_144059 (h0 : complete_lattice (has_neg congr_arg_kind)) : is_compactly_generated (has_neg congr_arg_kind) := sorry --non-trivial
lemma new_lemma_144060 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_dist.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (has_dist.{0} num))  := sorry --non-trivial
lemma new_lemma_144061 (h0 : ring (add_comm_semigroup (finset std_gen))) : is_domain (add_comm_semigroup (finset std_gen)) := sorry --non-trivial
lemma new_lemma_144062 (h0 : topological_space (id (has_norm unsigned))) : locally_compact_space (id (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_144063 (h0 : group (has_Inf (boolean_algebra.core linarith.comp))) : is_cyclic (has_Inf (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_144064 (h0 : fin has_zero.zero) : @discrete_topology.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_144065 (h0 : functor.add_const (topological_space (has_Inf pos)) Type) : @normal_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_144066 (h0 : function.extfun Type (functor.add_const (list pos))) : palindrome (functor.add_const.run (function.extfun_app h0 unsigned)) := sorry --non-trivial
lemma new_lemma_144067 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) Type) : @t1_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_144068 (h0 : canonically_ordered_monoid real -> canonically_ordered_monoid real -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_144069 (h0 : topological_space (has_div to_additive.value_type)) (h1 : preorder (has_div to_additive.value_type)) : order_closed_topology (has_div to_additive.value_type) := sorry --non-trivial
lemma new_lemma_144070 (h0 : char -> char -> Prop) : is_strict_order char h0 := sorry --non-trivial
lemma new_lemma_144071 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_144072 (h0 : functor.comp has_lt has_lt linarith.ineq) : @no_max_order.{0} (has_lt.{0} linarith.ineq) (@functor.comp.run.{0 0 0} has_lt.{0} has_lt.{0} linarith.ineq h0)  := sorry --non-trivial
lemma new_lemma_144073 (h0 : topological_space (has_pos_part (has_neg real))) : normal_space (has_pos_part (has_neg real)) := sorry --non-trivial
lemma new_lemma_144074 (h0 : group (canonically_linear_ordered_monoid (has_neg name))) : is_cyclic (canonically_linear_ordered_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_144075 (h0 : has_mem.mem (has_top num) has_emptyc.emptyc) : multiset.nodup (finset.pi.empty multiset (has_top num) h0) := sorry --non-trivial
lemma new_lemma_144076 (h0 : topological_space (random_gen (has_norm linarith.comp))) : discrete_topology (random_gen (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_144077 (h1 : topological_space (distrib_lattice linarith.ineq)) : path_connected_space (distrib_lattice linarith.ineq) := sorry --non-trivial
lemma new_lemma_144078 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_Sup.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_Sup.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_144079 (h0 : uniform_space (semiring (semiring linarith.comp))) : complete_space (semiring (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_144080 (h0 : functor.add_const (topological_space (preorder num)) (semiring num)) : @normal_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_144081 (h0 : add_monoid (linear_ordered_semiring (semiring unsigned))) : add_monoid.fg (linear_ordered_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_144082 (h0 : topological_space (linear_ordered_add_comm_group (with_bot to_additive.value_type))) : locally_compact_space (linear_ordered_add_comm_group (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_144083 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} h0 (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_144084 (h0 : filter (has_add (boolean_algebra (has_Inf pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_144085 (h0 : topological_space (preorder (semiring (semiring unsigned)))) : locally_compact_space (preorder (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_144086 (h0 : add_group (cancel_monoid (has_to_string (has_to_string ennreal)))) : is_add_cyclic (cancel_monoid (has_to_string (has_to_string ennreal))) := sorry --non-trivial
lemma new_lemma_144087 (h0 : functor.add_const (ring (boolean_algebra name)) (has_add (has_add (has_add name)))) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} name)) (has_add.{0} (has_add.{0} (has_add.{0} name))) h0)  := sorry --non-trivial
lemma new_lemma_144088 (h0 : has_lt (semi_normed_comm_ring (mul_one_class fun_info))) : no_max_order (semi_normed_comm_ring (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_144089 (h0 : not (topological_space (distrib string.iterator_imp) -> false)) : @totally_disconnected_space.{0} (distrib.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_144090 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (option.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (option.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_144091 (h0 : topological_space (random_gen (semiring num))) : preirreducible_space (random_gen (semiring num)) := sorry --non-trivial
lemma new_lemma_144092 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_144093 (h0 : functor.add_const (ring (is_R_or_C empty)) unsigned) : @strong_rank_condition.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (is_R_or_C.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_144094 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) Type) : @discrete_topology.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (add_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_144095 (h0 : not (filter (has_inv linarith.comp_source) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_144096 (h0 : add_group (has_ssubset (random_gen (mul_one_class to_additive.value_type)))) : is_add_cyclic (has_ssubset (random_gen (mul_one_class to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_144097 (h0 : ring (has_Sup congr_arg_kind)) : is_domain (has_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_144098 (h0 : complete_lattice (has_ssubset (normed_field linarith.ineq))) : complete_lattice.is_Sup_finite_compact (has_ssubset (normed_field linarith.ineq)) := sorry --non-trivial
lemma new_lemma_144099 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_144100 (h4 : ring (semi_normed_comm_ring (comm_ring char))) : is_domain (semi_normed_comm_ring (comm_ring char)) := sorry --non-trivial
lemma new_lemma_144101 (h0 : topological_space (boolean_algebra (add_comm_monoid Type))) : preconnected_space (boolean_algebra (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_144102 (h0 : add_group (distrib_lattice (random_gen char))) : is_add_cyclic (distrib_lattice (random_gen char)) := sorry --non-trivial
lemma new_lemma_144103 (h0 : topological_space (has_pos_part (has_pos_part linarith.comp))) : locally_compact_space (has_pos_part (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_144104 (h0 : set (simple_graph reducibility_hints)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_144105 (h0 : add_group (complete_semilattice_Sup (semiring (semiring (semiring (semiring num)))))) : is_add_cyclic (complete_semilattice_Sup (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_144106 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_144107 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra unsigned)) linarith.comp) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_144108 (h0 : topological_space (boolean_algebra.core linarith.comp)) : t1_space (boolean_algebra.core linarith.comp) := sorry --non-trivial
lemma new_lemma_144109 (h0 : functor.add_const (monoid (has_add linarith.comp)) (finset linarith.comp)) : @monoid.fg.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (has_add.{0} linarith.comp)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_144110 (h0 : functor.add_const (cancel_comm_monoid_with_zero (preorder congr_arg_kind)) empty) : @unique_factorization_monoid.{0} (preorder.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (preorder.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_144111 (h0 : topological_space (add_comm_semigroup char)) : totally_disconnected_space (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_144112 (h0 : function.extfun (Type 1) group) : @is_simple_group.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_144113 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_144114 (h0 : functor.add_const (group (semigroup linarith.comp)) linarith.comp) : @is_simple_group.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_144115 (h0 : functor.add_const (complete_lattice (boolean_algebra.core name)) linarith.comp) : @is_compactly_generated.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_144116 (h0 : functor.add_const (ring (add_comm_monoid (finset pos))) environment.implicit_infer_kind) : @is_domain.{0} (add_comm_monoid.{0} (finset.{0} pos)) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} (finset.{0} pos))) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_144117 (h0 : not (complete_lattice (add_group empty) -> false)) : @is_compactly_generated.{0} (add_group.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (add_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_144118 (h0 : topological_space (linear_ordered_add_comm_group (random_gen string_imp))) : totally_disconnected_space (linear_ordered_add_comm_group (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_144119 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (canonically_ordered_add_monoid.{0} num) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (canonically_ordered_add_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_144120 (h0 : ring (div_inv_monoid string_imp)) : strong_rank_condition (div_inv_monoid string_imp) := sorry --non-trivial
lemma new_lemma_144121 (h0 : not (list Prop -> false)) : list.ilast (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_144122 (h0 : topological_space (boolean_algebra (has_neg pos))) : path_connected_space (boolean_algebra (has_neg pos)) := sorry --non-trivial
lemma new_lemma_144123 (h0 : complete_lattice (id (semiring (semiring (semiring empty))))) : is_atomistic (id (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_144124 (h1 : topological_space (has_nnnorm linarith.comp_source)) (h2 : preorder (has_nnnorm linarith.comp_source)) : order_closed_topology (has_nnnorm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_144125 (h1 : add_group (linear_ordered_comm_group_with_zero string_imp)) : is_add_cyclic (linear_ordered_comm_group_with_zero string_imp) := sorry --non-trivial
lemma new_lemma_144126 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (finset.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (finset.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_144127 (h0 : cancel_comm_monoid_with_zero (sub_neg_monoid (has_Inf (has_Inf Type)))) : unique_factorization_monoid (sub_neg_monoid (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_144128 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (linear_ordered_semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_144129 (h0 : ordered_add_comm_monoid (has_neg (comm_group Type))) : archimedean (has_neg (comm_group Type)) := sorry --non-trivial
lemma new_lemma_144130 (h0 : topological_space (ordered_comm_monoid (has_Inf Type))) : totally_disconnected_space (ordered_comm_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_144131 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_144132 (h0 : topological_space (ordered_cancel_add_comm_monoid congr_arg_kind)) : totally_disconnected_space (ordered_cancel_add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_144133 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (comm_semigroup.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} h0 (comm_semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_144134 (h0 : cancel_comm_monoid_with_zero (non_assoc_semiring (semiring (semiring empty)))) : unique_factorization_monoid (non_assoc_semiring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_144135 (h1 : topological_space (nondiscrete_normed_field (normed_field (normed_field char)))) (h2 : preorder (nondiscrete_normed_field (normed_field (normed_field char)))) : order_closed_topology (nondiscrete_normed_field (normed_field (normed_field char))) := sorry --non-trivial
lemma new_lemma_144136 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_neg_part.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg_part.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_144137 (h0 : add_group (has_sub (semiring congr_arg_kind))) : is_add_cyclic (has_sub (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_144138 (h0 : topological_space (has_zero (has_to_string ennreal))) : totally_disconnected_space (has_zero (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_144139 (h0 : complete_lattice (random_gen empty)) : complete_lattice.is_Sup_finite_compact (random_gen empty) := sorry --non-trivial
lemma new_lemma_144140 (h0 : function.extfun Type group) : @is_cyclic.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_144141 (h0 : group (semigroup (comm_group Type))) : is_cyclic (semigroup (comm_group Type)) := sorry --non-trivial
lemma new_lemma_144142 (h0 : functor.add_const Prop (has_neg (has_add Type))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_144143 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_144144 (h0 : add_group (with_one (cancel_monoid_with_zero (random_gen fun_info)))) : is_add_cyclic (with_one (cancel_monoid_with_zero (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_144145 (h0 : functor.add_const (add_group (generalized_boolean_algebra name)) pos) : @is_add_cyclic.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (generalized_boolean_algebra.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_144146 (h0 : functor.comp ring has_ssubset enat) : @strong_rank_condition.{0} (has_ssubset.{0} enat) (@functor.comp.run.{0 0 0} ring.{0} has_ssubset.{0} enat h0)  := sorry --non-trivial
lemma new_lemma_144147 (h0 : measurable_space (has_lt (non_unital_non_assoc_semiring (non_unital_non_assoc_semiring enat)))) (h1 : filter (has_lt (non_unital_non_assoc_semiring (non_unital_non_assoc_semiring enat)))) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_144148 (h0 : semiring (mul_one_class (add_comm_semigroup ereal))) (h1 : ideal (mul_one_class (add_comm_semigroup ereal))) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_144149 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_144150 (h0 : functor.comp (functor.comp topological_space has_neg_part) option unsigned) : @t0_space.{0} (has_neg_part.{0} (option.{0} unsigned)) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} (option.{0} unsigned) (@functor.comp.run.{0 0 0} (functor.comp.{0 0 0} topological_space.{0} has_neg_part.{0}) option.{0} unsigned h0))  := sorry --non-trivial
lemma new_lemma_144151 (h0 : topological_space (boolean_algebra.core unsigned)) : preirreducible_space (boolean_algebra.core unsigned) := sorry --non-trivial
lemma new_lemma_144152 (h0 : complete_lattice (has_pos_part (canonically_ordered_monoid real))) : is_compactly_generated (has_pos_part (canonically_ordered_monoid real)) := sorry --non-trivial
lemma new_lemma_144153 (h0 : not (topological_space (has_emptyc (random_gen fun_info)) -> false)) : @irreducible_space.{0} (has_emptyc.{0} (random_gen.{0} fun_info)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} (random_gen.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_144154 (h0 : functor.add_const (functor.add_const Prop (normed_comm_ring Type)) name) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_144155 (h0 : topological_space (boolean_algebra (has_neg_part (add_cancel_monoid pos)))) : t0_space (boolean_algebra (has_neg_part (add_cancel_monoid pos))) := sorry --non-trivial
lemma new_lemma_144156 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) linarith.comp) : @locally_compact_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_144157 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_144158 (h0 : uniform_space (with_bot fun_info)) : separated_space (with_bot fun_info) := sorry --non-trivial
lemma new_lemma_144159 (h0 : not (has_mem.mem (with_bot linarith.comp_source) has_emptyc.emptyc -> false)) : @irreducible_space.{0} (with_bot.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_144160 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_144161 (h0 : topological_space (has_neg_part (ring pos))) : totally_disconnected_space (has_neg_part (ring pos)) := sorry --non-trivial
lemma new_lemma_144162 (h0 : topological_space (has_compl (mul_one_class (mul_one_class char)))) (h1 : add_group (has_compl (mul_one_class (mul_one_class char)))) : topological_add_group (has_compl (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_144163 (h0 : not (topological_space (linear_ordered_semiring congr_arg_kind) -> false)) : @discrete_topology.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_144164 (h0 : complete_lattice (measurable_space (has_top unsigned))) : complete_lattice.is_Sup_finite_compact (measurable_space (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_144165 (h0 : not (ring (dlist char) -> false)) : @strong_rank_condition.{0} (dlist.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (dlist.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_144166 (h0 : function.extfun Type topological_space) : @t0_space.{0} (comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_144167 (h0 : group (cancel_monoid (add_comm_monoid (has_add name)))) : normalizer_condition (cancel_monoid (add_comm_monoid (has_add name))) := sorry --non-trivial
lemma new_lemma_144168 (h0 : not (topological_space (linear_ordered_add_comm_group (with_bot linarith.comp_source)) -> false)) : @path_connected_space.{0} (linear_ordered_add_comm_group.{0} (with_bot.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_add_comm_group.{0} (with_bot.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_144169 (h0 : functor.add_const (ring (add_cancel_monoid empty)) unsigned) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_144170 (h0 : topological_space (ordered_ring (semiring (semiring (semiring (semiring unsigned)))))) : locally_compact_space (ordered_ring (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_144171 (h0 : topological_space (comm_group (mul_zero_class unsigned))) : t1_space (comm_group (mul_zero_class unsigned)) := sorry --non-trivial
lemma new_lemma_144172 (h0 : topological_space (finset (boolean_algebra pos))) : normal_space (finset (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_144173 (h0 : nat) (h1 : has_mul Type) (h2 : ulower (ulower (fin has_zero.zero))) : commute (matrix.vec_empty (ulower.up (ulower.up h2))) (zmod h0) := sorry --non-trivial
lemma new_lemma_144174 (h0 : topological_space (boolean_algebra (has_add (has_add (has_add name))))) : regular_space (boolean_algebra (has_add (has_add (has_add name)))) := sorry --non-trivial
lemma new_lemma_144175 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_bot.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_144176 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_144177 (h0 : topological_space (has_add (option name))) : preirreducible_space (has_add (option name)) := sorry --non-trivial
lemma new_lemma_144178 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_144179 (h0 : filter (has_neg num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_144180 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) name) : @irreducible_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_144181 (h0 : ring (simple_graph (boolean_algebra.core (ring Type)))) : is_domain (simple_graph (boolean_algebra.core (ring Type))) := sorry --non-trivial
lemma new_lemma_144182 (h0 : functor.add_const (add_group (has_to_string name)) linarith.comp) : @is_add_cyclic.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (has_to_string.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_144183 (h0 : complete_lattice (with_bot (has_top (has_norm (has_top (has_top (emetric_space linarith.ineq))))))) : is_atomistic (with_bot (has_top (has_norm (has_top (has_top (emetric_space linarith.ineq)))))) := sorry --non-trivial
lemma new_lemma_144184 (h1 : not (complete_lattice (comm_ring linarith.comp_source) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (comm_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (comm_ring.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_144185 (h0 : group (normed_group (has_norm linarith.comp_source))) : is_cyclic (normed_group (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_144186 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (complete_distrib_lattice (option pos))) := sorry --non-trivial
lemma new_lemma_144187 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) (ring Type)) : @t0_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} pos)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_144188 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_144189 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_144190 (h0 : functor.add_const (function.extfun (Type -> Type) (function.extfun Type)) linarith.ineq) : @complete_space.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@functor.add_const.run.{1 0} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) linarith.ineq h0) uniform_space.{0}) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_144191 (h0 : semiring (measurable_space.dynkin_system num)) : is_noetherian_ring (measurable_space.dynkin_system num) := sorry --non-trivial
lemma new_lemma_144192 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) (ring environment.implicit_infer_kind)) : @path_connected_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_144193 (h0 : complete_lattice (ring (option (option pos)))) : is_compactly_generated (ring (option (option pos))) := sorry --non-trivial
lemma new_lemma_144194 (h0 : list (free_add_monoid linarith.comp_source)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_144195 (h0 : topological_space (has_add (finset (has_neg Type)))) : t1_space (has_add (finset (has_neg Type))) := sorry --non-trivial
lemma new_lemma_144196 (h0 : filter (mul_zero_class environment.implicit_infer_kind)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_144197 (h0 : topological_space (linear_ordered_field empty)) : topological_space.separable_space (linear_ordered_field empty) := sorry --non-trivial
lemma new_lemma_144198 (h0 : group (add_left_cancel_semigroup (semiring (option unsigned)))) : group.fg (add_left_cancel_semigroup (semiring (option unsigned))) := sorry --non-trivial
lemma new_lemma_144199 (h0 : topological_space (has_zero (has_to_string unsigned))) : locally_compact_space (has_zero (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_144200 (h0 : complete_lattice (add_group (has_union (semiring linarith.comp)))) : is_atomistic (add_group (has_union (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_144201 (h0 : functor.add_const (topological_space (mul_zero_class pos)) pos) : @path_connected_space.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_144202 (h0 : set (has_lt (mul_one_class char))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_144203 (h0 : semiring (plift (semiring (semiring num)))) : is_noetherian_ring (plift (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_144204 (h0 : functor.add_const (topological_space (mul_zero_class ennreal)) Type) : @preconnected_space.{0} (mul_zero_class.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (mul_zero_class.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_144205 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_144206 (h0 : topological_space (finset environment.implicit_infer_kind)) : discrete_topology (finset environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_144207 (h0 : functor.add_const (topological_space (complete_distrib_lattice environment.implicit_infer_kind)) name) : @sequential_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_144208 (h0 : list (has_inv (has_norm linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_144209 (h0 : topological_space (has_neg (ring (finset linarith.comp)))) : t1_space (has_neg (ring (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_144210 (h0 : topological_space (canonically_ordered_monoid (has_add (normed_lattice_add_comm_group pos)))) : locally_compact_space (canonically_ordered_monoid (has_add (normed_lattice_add_comm_group pos))) := sorry --non-trivial
lemma new_lemma_144211 (h0 : semiring (has_to_string (has_to_string Type))) : is_noetherian_ring (has_to_string (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_144212 (h0 : functor.add_const (topological_space (cancel_monoid pos)) Type) : @t0_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_144213 (h0 : add_group (linear_ordered_comm_group ennreal)) : is_add_cyclic (linear_ordered_comm_group ennreal) := sorry --non-trivial
lemma new_lemma_144214 (h0 : functor.add_const (complete_lattice (has_zero Type)) (has_neg_part pos)) : @is_atomistic.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_zero.{1} Type)) (has_neg_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_144215 (h0 : function.extfun (finset Type) (has_mem.mem (id linarith.comp))) : @normal_space.{0} (@id.{2} Type linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (@id.{2} Type linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_144216 (h0 : topological_space (has_add (has_to_string (has_neg Type)))) : irreducible_space (has_add (has_to_string (has_neg Type))) := sorry --non-trivial
lemma new_lemma_144217 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_144218 (h0 : topological_space (boolean_algebra (has_add (has_add (has_add environment.implicit_infer_kind))))) : sequential_space (boolean_algebra (has_add (has_add (has_add environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_144219 (h0 h1 : linarith.comp_source -> linarith.comp_source -> linarith.comp_source) : left_distributive h0 h1 := sorry --non-trivial
lemma new_lemma_144220 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @locally_compact_space.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_144221 (h0 : functor.add_const (complete_lattice (finset pos)) unsigned) : @is_compactly_generated.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_144222 (h0 : add_group (has_lt environment.projection_info)) : is_add_cyclic (has_lt environment.projection_info) := sorry --non-trivial
lemma new_lemma_144223 (h0 : topological_space (has_dist ennreal)) : discrete_topology (has_dist ennreal) := sorry --non-trivial
lemma new_lemma_144224 (h0 : topological_space (has_neg num)) : preconnected_space (has_neg num) := sorry --non-trivial
lemma new_lemma_144225 (h1 h2 : multiset (mul_one_class ereal)) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_144226 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} num (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 num)  := sorry --non-trivial
lemma new_lemma_144227 (h0 : topological_space (ordered_comm_ring linarith.comp)) : totally_disconnected_space (ordered_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_144228 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} name (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) name)  := sorry --non-trivial
lemma new_lemma_144229 (h0 : complete_lattice (normed_lattice_add_comm_group (sub_neg_monoid pos))) : is_compactly_generated (normed_lattice_add_comm_group (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_144230 (h0 : functor.add_const (cancel_comm_monoid_with_zero (simple_graph ennreal)) unsigned) : @unique_factorization_monoid.{0} (simple_graph.{0} ennreal) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (simple_graph.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_144231 (h0 : filter (has_Inf (has_Inf pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_144232 (h0 : has_mem.mem (has_emptyc linarith.comp_source) has_emptyc.emptyc) : @is_domain.{0} (has_emptyc.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (has_emptyc.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_144233 (h0 : topological_space (has_emptyc (complete_distrib_lattice string_imp))) : path_connected_space (has_emptyc (complete_distrib_lattice string_imp)) := sorry --non-trivial
lemma new_lemma_144234 (h0 : list (pseudo_metric_space (option congr_arg_kind))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_144235 (h0 : function.extfun Type (functor.comp topological_space has_nndist)) : @loc_path_connected_space.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_nndist.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_144236 (h0 : complete_lattice (has_nndist (has_nndist ennreal))) : is_atomistic (has_nndist (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_144237 (h0 : filter (encodable linarith.ineq)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_144238 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_144239 (h3 : ring (normed_group linarith.ineq)) : is_domain (normed_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_144240 (h0 : functor.add_const (finset (has_neg Type)) (ring (has_neg linarith.comp))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_144241 (h0 : option (complete_distrib_lattice unsigned) -> option (complete_distrib_lattice unsigned) -> Prop) : is_trans (option (complete_distrib_lattice unsigned)) h0 := sorry --non-trivial
lemma new_lemma_144242 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 znum) := sorry --non-trivial
lemma new_lemma_144243 (h0 : functor.add_const (list (linear_order unsigned)) (option empty)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_144244 (h0 : functor.add_const (finset (ordered_comm_monoid linarith.comp)) (ring pos)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_144245 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_144246 (h0 : functor.add_const (topological_space (cancel_monoid pos)) Type) : @sequential_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_144247 (h0 : ordered_comm_monoid (add_cancel_monoid (finset (finset environment.implicit_infer_kind)))) : has_exists_mul_of_le (add_cancel_monoid (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_144248 (h1 : add_group (semi_normed_ring char)) : is_add_cyclic (semi_normed_ring char) := sorry --non-trivial
lemma new_lemma_144249 (h0 : topological_space (non_unital_non_assoc_semiring string.iterator_imp)) : path_connected_space (non_unital_non_assoc_semiring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_144250 (h0 : topological_space (measure_theory.measure_space unsigned)) : preirreducible_space (measure_theory.measure_space unsigned) := sorry --non-trivial
lemma new_lemma_144251 (h0 : mul_zero_class (has_top empty) -> mul_zero_class (has_top empty) -> Prop) : is_strict_order (mul_zero_class (has_top empty)) h0 := sorry --non-trivial
lemma new_lemma_144252 (h0 : not (ring (has_sub unsigned) -> false)) : @rank_condition.{0} (has_sub.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (has_sub.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_144253 (h0 : prod (linear_ordered_semiring empty) (linear_ordered_semiring empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_144254 (h0 : topological_space (normed_comm_ring (has_to_string Type))) : totally_separated_space (normed_comm_ring (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_144255 (h0 : not (topological_space (semiring (random_gen linarith.comp_source)) -> false)) : @totally_separated_space.{0} (semiring.{0} (random_gen.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} (random_gen.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_144256 (h1 : topological_space (semi_normed_ring linarith.comp_source)) : path_connected_space (semi_normed_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_144257 (h0 : functor.comp ordered_comm_monoid add_cancel_monoid linarith.comp) : @has_exists_mul_of_le.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} add_cancel_monoid.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_144258 (h0 : list (boolean_algebra (has_neg (has_neg_part Type)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_144259 (h0 : topological_space (normed_comm_ring (finset linarith.comp))) : totally_disconnected_space (normed_comm_ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_144260 (h0 : Prop) (h1 : fin has_zero.zero) : category_theory.hom_of_element h0 (matrix.vec_empty h1) := sorry --non-trivial
lemma new_lemma_144261 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @path_connected_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_144262 (h0 : functor.add_const (uniform_space (boolean_algebra pos)) name) : @complete_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_144263 (h0 : functor.add_const (uniform_space znum) num) : @separated_space.{0} znum (@functor.add_const.run.{0 0} (uniform_space.{0} znum) num h0)  := sorry --non-trivial
lemma new_lemma_144264 (h0 : function.extfun Type group) : @is_cyclic.{0} (comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_144265 (h1 : topological_space (simple_graph ereal)) (h2 : add_group (simple_graph ereal)) : topological_add_group (simple_graph ereal) := sorry --non-trivial
lemma new_lemma_144266 (h0 : functor.add_const (topological_space (has_to_string environment.implicit_infer_kind)) Type) : @t1_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_144267 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) h0) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_144268 (h0 : functor.add_const (semiring (sub_neg_monoid congr_arg_kind)) unsigned) : @is_noetherian_ring.{0} (sub_neg_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (semiring.{0} (sub_neg_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_144269 (h0 : ordered_add_comm_monoid (boolean_algebra (has_add (has_add (has_add pos))))) : archimedean (boolean_algebra (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_144270 (h0 : function.extfun Type topological_space) : @t0_space.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_144271 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_144272 (h0 : functor.add_const (filter (has_to_string pos)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_144273 (h0 : ordered_add_comm_monoid (ring (add_comm_monoid name))) : archimedean (ring (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_144274 (h0 : function.extfun (Type 1) topological_space) : @t1_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_144275 (h0 : topological_space (sub_neg_monoid (has_neg (has_neg real)))) : normal_space (sub_neg_monoid (has_neg (has_neg real))) := sorry --non-trivial
lemma new_lemma_144276 (h0 : topological_space (linear_ordered_add_comm_monoid_with_top ennreal)) : locally_compact_space (linear_ordered_add_comm_monoid_with_top ennreal) := sorry --non-trivial
lemma new_lemma_144277 (h0 : not (filter (order_dual num) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_144278 (h0 : functor.add_const (complete_lattice (ordered_comm_monoid pos)) linarith.comp) : @is_atomistic.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_comm_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_144279 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_144280 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_144281 (h0 : uniform_space (comm_semigroup (has_Inf real))) : complete_space (comm_semigroup (has_Inf real)) := sorry --non-trivial
lemma new_lemma_144282 (h0 : ring (distrib (has_nnnorm (has_nnnorm char)))) : rank_condition (distrib (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_144283 (h0 : ordered_add_comm_monoid (monoid (option empty))) : archimedean (monoid (option empty)) := sorry --non-trivial
lemma new_lemma_144284 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen empty))) : @complete_space.{0} (random_gen.{0} empty) (@finset.pi.empty.{1 0} Type uniform_space.{0} (random_gen.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_144285 (h0 : prod (has_union unsigned) (has_union unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_144286 (h0 : not (list (complete_semilattice_Sup fun_info) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_144287 (h0 : function.extfun nat fin) : @irreducible_space.{1} (finset.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (finset.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_144288 (h0 : complete_lattice (add_semigroup (option empty))) : is_atomistic (add_semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_144289 (h0 : functor.add_const (topological_space (linear_ordered_comm_group empty)) unsigned) : @locally_compact_space.{0} (linear_ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_group.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_144290 (h0 : topological_space (finset (ring environment.implicit_infer_kind))) : discrete_topology (finset (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_144291 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_144292 (h0 : list (distrib_lattice (random_gen (random_gen (random_gen (random_gen (random_gen string_imp))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_144293 (h1 : complete_lattice (uniform_space string.iterator_imp)) : complete_lattice.is_Sup_finite_compact (uniform_space string.iterator_imp) := sorry --non-trivial
lemma new_lemma_144294 (h0 : topological_space (add_cancel_monoid (has_add (has_neg (ring linarith.comp))))) : t0_space (add_cancel_monoid (has_add (has_neg (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_144295 (h0 : ring (ordered_comm_ring (has_add pos))) : is_principal_ideal_ring (ordered_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_144296 (h0 : ring (boolean_algebra.core (has_add (comm_group name)))) : strong_rank_condition (boolean_algebra.core (has_add (comm_group name))) := sorry --non-trivial
lemma new_lemma_144297 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_inner.{0 0} (ordered_ring.{0} (option.{0} empty)) (semiring.{0} empty)) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_inner.{0 0} (ordered_ring.{0} (option.{0} empty)) (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_144298 (h0 : ring (add_cancel_monoid (finset pos))) : rank_condition (add_cancel_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_144299 (h0 : ordered_comm_monoid (comm_group name)) : has_exists_mul_of_le (comm_group name) := sorry --non-trivial
lemma new_lemma_144300 (h0 : topological_space (with_bot (semiring (semiring unsigned)))) : preirreducible_space (with_bot (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_144301 (h0 : fin has_zero.zero) : @discrete_topology.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_144302 (h0 : add_monoid (has_Inf (canonically_ordered_monoid real))) : add_monoid.fg (has_Inf (canonically_ordered_monoid real)) := sorry --non-trivial
lemma new_lemma_144303 (h0 : function.extfun Type group) : @is_cyclic.{0} (@id.{2} Type linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (@id.{2} Type linarith.ineq))  := sorry --non-trivial
lemma new_lemma_144304 (h0 : functor.comp monoid has_neg_part name) : @monoid.fg.{0} (has_neg_part.{0} name) (@functor.comp.run.{0 0 0} monoid.{0} has_neg_part.{0} name h0)  := sorry --non-trivial
lemma new_lemma_144305 (h0 : functor.add_const (function.extfun Type add_group) name) : @is_add_cyclic.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) name h0) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_144306 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_144307 (h0 : not (uniform_space (add_right_cancel_monoid congr_arg_kind) -> false)) : @complete_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_144308 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (has_top.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} congr_arg_kind)))))) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_top.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} congr_arg_kind)))))))  := sorry --non-trivial
lemma new_lemma_144309 (h0 : functor.add_const (add_monoid (as_linear_order empty)) num) : @add_monoid.fg.{0} (as_linear_order.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (as_linear_order.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_144310 (h0 : fin has_zero.zero) : @loc_path_connected_space.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_linear_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_144311 (h0 : topological_space (canonically_linear_ordered_monoid (has_neg name))) : topological_space.separable_space (canonically_linear_ordered_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_144312 (h0 : topological_space (complete_distrib_lattice (has_add real))) : preconnected_space (complete_distrib_lattice (has_add real)) := sorry --non-trivial
lemma new_lemma_144313 (h1 : uniform_space (has_inf char)) : complete_space (has_inf char) := sorry --non-trivial
lemma new_lemma_144314 (h0 : function.extfun Type (functor.add_const (topological_space (has_bot empty)))) : @t1_space.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_bot.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_144315 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_144316 (h3 : ring string.iterator_imp) : strong_rank_condition string.iterator_imp := sorry --non-trivial
lemma new_lemma_144317 (h0 : not (complete_lattice (has_add to_additive.value_type) -> false)) : @is_compactly_generated.{0} (has_add.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_add.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_144318 (h0 : functor.add_const (uniform_space (ordered_ring num)) empty) : @complete_space.{0} (ordered_ring.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_ring.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_144319 (h0 : function.extfun (finset Type) (has_mem.mem (has_top empty))) : @totally_separated_space.{0} (has_top.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_144320 (h0 : topological_space (normed_comm_ring Type)) : normal_space (normed_comm_ring Type) := sorry --non-trivial
lemma new_lemma_144321 (h0 : complete_lattice (linear_ordered_field (cancel_monoid (has_add unsigned)))) : is_compactly_generated (linear_ordered_field (cancel_monoid (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_144322 (h0 : functor.comp topological_space complete_distrib_lattice ennreal) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_144323 (h0 : function.extfun Type (functor.comp topological_space has_zero)) : @discrete_topology.{0} (has_zero.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_zero.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_144324 (h0 : add_monoid (canonically_ordered_monoid real)) : add_monoid.fg (canonically_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_144325 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_144326 (h0 : ring (has_inter (option (option (option empty))))) : strong_rank_condition (has_inter (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_144327 (h0 : list (finset name)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_144328 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_144329 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_144330 (h1 : complete_lattice (linear_ordered_add_comm_group fun_info)) : is_atomistic (linear_ordered_add_comm_group fun_info) := sorry --non-trivial
lemma new_lemma_144331 (h0 : ring (dlist (random_gen (random_gen fun_info)))) : strong_rank_condition (dlist (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_144332 (h0 : topological_space (normed_comm_ring linarith.comp)) : t0_space (normed_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_144333 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_144334 (h0 : complete_lattice (add_cancel_monoid num)) : is_atomistic (add_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_144335 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_144336 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_144337 (h0 : add_monoid (has_pos_part (has_pos_part linarith.comp))) : add_monoid.fg (has_pos_part (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_144338 (h0 : ring (metric_space reducibility_hints)) : strong_rank_condition (metric_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_144339 (h0 : topological_space (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup enat)))) : path_connected_space (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup enat))) := sorry --non-trivial
lemma new_lemma_144340 (h0 : functor.add_const (functor.add_const (topological_space Type) pos) pos) : @path_connected_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) pos (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (topological_space.{1} Type) pos) pos h0))  := sorry --non-trivial
lemma new_lemma_144341 (h0 : not (group (id congr_arg_kind) -> false)) : @is_cyclic.{0} (@id.{2} Type congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (@id.{2} Type congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_144342 (h0 : finset (filter (complete_distrib_lattice empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_144343 (h0 : not (add_group (option empty) -> false)) : @is_add_cyclic.{0} (option.{0} empty) (@classical.by_contradiction'.{1} (add_group.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_144344 (h0 : function.extfun (ring nnreal -> false) (fun (x : ring nnreal -> false), false)) : @rank_condition.{0} nnreal (@classical.by_contradiction'.{1} (ring.{0} nnreal) (@function.extfun_app.{0 0} (ring.{0} nnreal → false) (λ (x : ring.{0} nnreal → false), false) h0))  := sorry --non-trivial
lemma new_lemma_144345 (h0 : semiring (normed_group (semiring (semiring (semiring (semiring num)))))) : is_noetherian_ring (normed_group (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_144346 (h0 : uniform_space (semi_normed_ring (mul_one_class (mul_one_class reducibility_hints)))) : complete_space (semi_normed_ring (mul_one_class (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_144347 (h0 : function.extfun Type group) : @group.fg.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_144348 (h1 : group (has_top (random_gen to_additive.value_type))) : is_cyclic (has_top (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_144349 (h0 : topological_space (complete_semilattice_Sup (random_gen linarith.comp_source))) : path_connected_space (complete_semilattice_Sup (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_144350 (h0 : has_neg (has_neg name) -> Prop) : zzz_forall h0 := sorry --non-trivial
lemma new_lemma_144351 (h0 : functor.add_const (topological_space (has_to_string name)) name) : @loc_path_connected_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_144352 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf Type))) : irreducible_space (normed_lattice_add_comm_group (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_144353 (h0 : ring (ordered_comm_ring (has_add Type))) : is_principal_ideal_ring (ordered_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_144354 (h0 : functor.comp topological_space mul_zero_class name) : @preconnected_space.{0} (mul_zero_class.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} name h0)  := sorry --non-trivial
lemma new_lemma_144355 (h0 : functor.add_const (topological_space (boolean_algebra Type)) Type) : @irreducible_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_144356 (h0 : function.extfun Type group) : @normalizer_condition.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_144357 (h0 : list (topological_space (random_gen (has_ssubset to_additive.value_type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_144358 (h3 : complete_lattice (mul_one_class (metric_space linarith.comp_source))) : is_compactly_generated (mul_one_class (metric_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_144359 (h0 : ring (semigroup string.iterator_imp)) : is_domain (semigroup string.iterator_imp) := sorry --non-trivial
lemma new_lemma_144360 (h0 : topological_space (boolean_algebra.core (has_to_string name))) : path_connected_space (boolean_algebra.core (has_to_string name)) := sorry --non-trivial
lemma new_lemma_144361 (h0 : not (add_group (has_one linarith.comp) -> false)) : @is_add_cyclic.{0} (has_one.{0} linarith.comp) (@classical.by_contradiction'.{1} (add_group.{0} (has_one.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_144362 (h0 : topological_space (add_cancel_monoid (has_add name))) : totally_separated_space (add_cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_144363 (h0 : encodable (has_top to_additive.value_type) -> encodable (has_top to_additive.value_type) -> bool) : is_dec_refl h0 := sorry --non-trivial
lemma new_lemma_144364 (h0 : add_group (random_gen (has_inv fun_info))) : is_add_cyclic (random_gen (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_144365 (h0 : topological_space (ordered_cancel_add_comm_monoid (option (option pos)))) : sequential_space (ordered_cancel_add_comm_monoid (option (option pos))) := sorry --non-trivial
lemma new_lemma_144366 (h0 : functor.add_const (topological_space (left_cancel_semigroup num)) num) : @path_connected_space.{0} (left_cancel_semigroup.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_144367 (h0 : add_group (has_one (has_norm (has_norm (has_norm linarith.comp))))) : is_add_cyclic (has_one (has_norm (has_norm (has_norm linarith.comp)))) := sorry --non-trivial
lemma new_lemma_144368 (h0 : topological_space (distrib (random_gen to_additive.value_type))) : t0_space (distrib (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_144369 (h0 : complete_lattice (add_cancel_monoid (cancel_monoid environment.implicit_infer_kind))) : is_atomistic (add_cancel_monoid (cancel_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_144370 (h0 : complete_lattice (semigroup (semigroup environment.implicit_infer_kind))) : is_compactly_generated (semigroup (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_144371 (h0 : functor.add_const (topological_space (option empty)) congr_arg_kind) : @normal_space.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_144372 (h0 : semiring (generalized_boolean_algebra (ring name))) : is_noetherian_ring (generalized_boolean_algebra (ring name)) := sorry --non-trivial
lemma new_lemma_144373 (h0 : functor.add_const (topological_space (is_R_or_C empty)) (option empty)) : @normal_space.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_144374 (h0 : topological_space (normed_lattice_add_comm_group name)) : irreducible_space (normed_lattice_add_comm_group name) := sorry --non-trivial
lemma new_lemma_144375 (h0 : group (has_compl (has_nnnorm char))) : is_cyclic (has_compl (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_144376 (h0 : topological_space (measurable_space linarith.comp)) : path_connected_space (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_144377 (h0 : list (has_add (has_pos_part (finset linarith.comp)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_144378 (h0 : not (ring (with_bot empty) -> false)) : @is_domain.{0} (with_bot.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (with_bot.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_144379 (h0 : semiring (add_right_cancel_monoid (has_edist empty))) : is_noetherian_ring (add_right_cancel_monoid (has_edist empty)) := sorry --non-trivial
lemma new_lemma_144380 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preirreducible_space.{0} (add_cancel_monoid.{0} (ring.{0} linarith.comp)) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (add_cancel_monoid.{0} (ring.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_144381 (h0 : list (has_neg environment.implicit_infer_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_144382 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (normed_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (normed_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_144383 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_compactly_generated.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_144384 (h0 : topological_space (ring (has_add (has_add ennreal)))) : topological_space.separable_space (ring (has_add (has_add ennreal))) := sorry --non-trivial
lemma new_lemma_144385 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_144386 (h0 : topological_space (has_top (id linarith.comp))) : totally_disconnected_space (has_top (id linarith.comp)) := sorry --non-trivial
lemma new_lemma_144387 (h0 : simple_graph std_gen) (h1 : sym2 std_gen) : simple_graph.edge_set h0 h1 := sorry --non-trivial
lemma new_lemma_144388 (h0 : topological_space (has_neg (has_to_string congr_arg_kind))) : totally_separated_space (has_neg (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_144389 (h0 : list (add_cancel_monoid (option (option empty)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_144390 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_144391 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_144392 (h0 : function.extfun Type (functor.comp topological_space has_add)) : @preirreducible_space.{0} (has_add.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_add.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_144393 (h0 : topological_space (has_bot (has_pos_part pos))) : loc_path_connected_space (has_bot (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_144394 (h0 : group (ring (ring pos))) : normalizer_condition (ring (ring pos)) := sorry --non-trivial
lemma new_lemma_144395 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (encodable linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_144396 (h0 : group (add_comm_monoid (has_neg (has_neg (has_neg pos))))) : is_simple_group (add_comm_monoid (has_neg (has_neg (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_144397 (h0 : ring (random_gen (topological_space (has_nnnorm linarith.ineq)))) : strong_rank_condition (random_gen (topological_space (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_144398 (h0 : topological_space (has_append (mul_one_class char))) : t0_space (has_append (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_144399 (h0 : fin has_zero.zero) : @separated_space.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (has_pos_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_144400 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @discrete_topology.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_144401 (h0 : uniform_space (add_cancel_monoid (has_nndist pos))) : separated_space (add_cancel_monoid (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_144402 (h0 : finset (ordered_comm_monoid (has_add (has_neg name)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_144403 (h0 : ring (non_assoc_semiring (semiring (option (option congr_arg_kind))))) : rank_condition (non_assoc_semiring (semiring (option (option congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_144404 (h0 : not (complete_lattice (has_nnnorm (comm_ring reducibility_hints)) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_nnnorm.{0} (comm_ring.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_nnnorm.{0} (comm_ring.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_144405 (h1 : function.extfun Type complete_lattice) : is_atomistic (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_144406 (h0 : prod (non_assoc_semiring unsigned) (non_assoc_semiring unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_144407 (h0 : not (ring (measurable_space (random_gen fun_info)) -> false)) : @strong_rank_condition.{0} (measurable_space.{0} (random_gen.{0} fun_info)) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.{0} (random_gen.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_144408 (h0 : topological_space (has_pos_part (ordered_comm_monoid Type))) : preconnected_space (has_pos_part (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_144409 (h0 : topological_space (has_ssubset (mul_one_class (mul_one_class (mul_one_class char))))) : path_connected_space (has_ssubset (mul_one_class (mul_one_class (mul_one_class char)))) := sorry --non-trivial
lemma new_lemma_144410 (h1 : topological_space (encodable linarith.comp_source)) : path_connected_space (encodable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_144411 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_144412 (h0 : not (uniform_space (simple_graph linarith.ineq) -> false)) : @complete_space.{0} (simple_graph.{0} linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (simple_graph.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_144413 (h0 : topological_space (has_div fun_info)) : path_connected_space (has_div fun_info) := sorry --non-trivial
lemma new_lemma_144414 (h0 : topological_space (add_comm_monoid (finset Type))) : discrete_topology (add_comm_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_144415 (h0 : functor.add_const (topological_space (add_comm_monoid environment.implicit_infer_kind)) Type) : @irreducible_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_144416 (h0 : function.extfun (Type 1) ordered_add_comm_monoid) : @archimedean.{1} (plift.{1} (semiring.{0} empty)) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} h0 (plift.{1} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_144417 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_inv.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inv.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_144418 (h0 : group (denumerable (comm_ring (comm_ring char)))) : is_cyclic (denumerable (comm_ring (comm_ring char))) := sorry --non-trivial
lemma new_lemma_144419 (h0 : functor.add_const (ordered_comm_monoid (has_add Type)) pos) : @has_exists_mul_of_le.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (has_add.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_144420 (h0 : complete_lattice (generalized_boolean_algebra (has_Inf Type))) : complete_lattice.is_Sup_finite_compact (generalized_boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_144421 (h0 : topological_space (semigroup (has_add (has_Inf environment.implicit_infer_kind)))) : loc_path_connected_space (semigroup (has_add (has_Inf environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_144422 (h1 : not (complete_lattice (topological_space string_imp) -> false)) : complete_lattice.is_Sup_finite_compact (topological_space string_imp) := sorry --non-trivial
lemma new_lemma_144423 (h0 : add_group (has_neg (has_neg ennreal))) : is_add_cyclic (has_neg (has_neg ennreal)) := sorry --non-trivial
lemma new_lemma_144424 (h0 : function.extfun Type topological_space) : @t0_space.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_144425 (h0 : topological_space (linear_ordered_comm_ring (ordered_cancel_comm_monoid (order_dual congr_arg_kind)))) : t1_space (linear_ordered_comm_ring (ordered_cancel_comm_monoid (order_dual congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_144426 (h0 : function.extfun (((Type -> Type) -> Type 1) -> Type 1) (function.extfun ((Type -> Type) -> Type 1))) : @rank_condition.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (@function.extfun_app.{3 3} (((Type → Type) → Type 1) → Type 1) (function.extfun.{3 2} ((Type → Type) → Type 1)) h0 (function.extfun.{2 2} (Type → Type))) (function.extfun.{2 1} Type)) ring.{0}) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_144427 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_144428 (h0 : ring (boolean_algebra.core (has_to_string name))) : is_domain (boolean_algebra.core (has_to_string name)) := sorry --non-trivial
lemma new_lemma_144429 (h0 : functor.add_const (topological_space (mul_zero_class ennreal)) Type) : @irreducible_space.{0} (mul_zero_class.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (mul_zero_class.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_144430 (h0 : uniform_space (with_one (with_bot string_imp))) : complete_space (with_one (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_144431 (h0 : has_mem.mem (id linarith.comp) has_emptyc.emptyc) : @normalizer_condition.{0} (@id.{2} Type linarith.comp) (@finset.pi.empty.{1 0} Type group.{0} (@id.{2} Type linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_144432 (h0 : topological_space (ordered_comm_ring (has_add (has_Inf real)))) : regular_space (ordered_comm_ring (has_add (has_Inf real))) := sorry --non-trivial
lemma new_lemma_144433 (h0 : function.extfun nat fin) : @is_noetherian_ring.{0} (sub_neg_monoid.{0} name) (@matrix.vec_empty.{0} (semiring.{0} (sub_neg_monoid.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_144434 (h0 : ring (has_Inf (finset (finset pos)))) : is_domain (has_Inf (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_144435 (h0 : topological_space (has_inter (has_to_string (has_to_string (has_to_string num))))) : preconnected_space (has_inter (has_to_string (has_to_string (has_to_string num)))) := sorry --non-trivial
lemma new_lemma_144436 (h0 : ring (random_gen (topological_space linarith.ineq))) : is_domain (random_gen (topological_space linarith.ineq)) := sorry --non-trivial
lemma new_lemma_144437 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (ring unsigned)) := sorry --non-trivial
lemma new_lemma_144438 (h0 : function.extfun Type topological_space) : @t1_space.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_144439 (h0 : not (topological_space (linear_ordered_add_comm_group linarith.ineq) -> false)) : @path_connected_space.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_add_comm_group.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_144440 (h0 : topological_space (ring Type)) : loc_path_connected_space (ring Type) := sorry --non-trivial
lemma new_lemma_144441 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_144442 (h0 : add_monoid (measurable_space.dynkin_system (semiring (semiring empty)))) : add_monoid.fg (measurable_space.dynkin_system (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_144443 (h0 : topological_space (normed_comm_ring (has_add name))) : discrete_topology (normed_comm_ring (has_add name)) := sorry --non-trivial
lemma new_lemma_144444 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} h0 linarith.comp)  := sorry --non-trivial
lemma new_lemma_144445 (h0 : complete_lattice (normed_field string_imp)) : is_compactly_generated (normed_field string_imp) := sorry --non-trivial
lemma new_lemma_144446 (h0 : functor.add_const (topological_space (bin_tree unsigned)) congr_arg_kind) : @preirreducible_space.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_144447 (h0 : not (topological_space (mul_zero_class congr_arg_kind) -> false)) : @preirreducible_space.{0} (mul_zero_class.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (mul_zero_class.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_144448 (h0 : topological_space (add_comm_monoid (comm_semigroup (sub_neg_monoid real)))) : t0_space (add_comm_monoid (comm_semigroup (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_144449 (h0 : functor.add_const (uniform_space (has_Inf linarith.comp)) pos) : @complete_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_Inf.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_144450 (h0 : uniform_space (has_Sup (ordered_comm_group (option (ordered_comm_group empty))))) : separated_space (has_Sup (ordered_comm_group (option (ordered_comm_group empty)))) := sorry --non-trivial
lemma new_lemma_144451 (h0 : topological_space (finset (normed_comm_ring Type))) : normal_space (finset (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_144452 (h0 : functor.add_const (complete_lattice (ring pos)) environment.implicit_infer_kind) : @is_compactly_generated.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_144453 (h0 : topological_space (as_linear_order empty)) : path_connected_space (as_linear_order empty) := sorry --non-trivial
lemma new_lemma_144454 (h0 : has_mem.mem (random_gen linarith.ineq) has_emptyc.emptyc) : @totally_separated_space.{0} (random_gen.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_144455 (h1 : topological_space (semi_normed_ring fun_info)) : t0_space (semi_normed_ring fun_info) := sorry --non-trivial
lemma new_lemma_144456 (h1 : set (add_cancel_monoid enat -> std_gen)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_144457 (h0 : functor.add_const (ordered_add_comm_monoid (cancel_monoid Type)) Type) : @archimedean.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (ordered_add_comm_monoid.{1} (cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_144458 (h0 : semiring (bin_tree (option (option (option (option (option unsigned))))))) : is_noetherian_ring (bin_tree (option (option (option (option (option unsigned)))))) := sorry --non-trivial
lemma new_lemma_144459 (h0 : topological_space (has_inner (option (option empty)) num)) : irreducible_space (has_inner (option (option empty)) num) := sorry --non-trivial
lemma new_lemma_144460 (h0 : topological_space (normed_linear_ordered_group (semiring congr_arg_kind))) : totally_disconnected_space (normed_linear_ordered_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_144461 (h0 : add_group (add_monoid (has_nnnorm fun_info))) : is_add_cyclic (add_monoid (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_144462 (h0 : monoid (random_gen (random_gen (random_gen string_imp)))) : monoid.fg (random_gen (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_144463 (h1 : topological_space (semi_normed_comm_ring std_gen)) : t0_space (semi_normed_comm_ring std_gen) := sorry --non-trivial
lemma new_lemma_144464 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @has_exists_mul_of_le.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ordered_comm_monoid.{0}) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_144465 (h0 : topological_space char) : sigma_compact_space char := sorry --non-trivial
lemma new_lemma_144466 (h0 : topological_space (mul_one_class (mul_one_class enat))) (h1 : set (set (mul_one_class (mul_one_class enat)))) : topological_space.is_topological_basis h1 := sorry --non-trivial
lemma new_lemma_144467 (h0 : function.extfun Type ring) : @is_domain.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_144468 (h0 : topological_space (left_cancel_semigroup (semiring empty))) : normal_space (left_cancel_semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_144469 (h0 : list (comm_ring (has_ssubset string_imp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_144470 (h0 : ring (option ennreal)) : is_domain (option ennreal) := sorry --non-trivial
lemma new_lemma_144471 (h0 : function.extfun (finset Type) (has_mem.mem (has_top fun_info))) : @monoid.fg.{0} (has_top.{0} fun_info) (@finset.pi.empty.{1 0} Type monoid.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_144472 (h0 : group (has_edist unsigned)) : normalizer_condition (has_edist unsigned) := sorry --non-trivial
lemma new_lemma_144473 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_144474 (h0 : functor.add_const (function.extfun (Type 1) ring) Type) : @rank_condition.{1} Type (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) Type h0) Type)  := sorry --non-trivial
lemma new_lemma_144475 (h0 : functor.comp add_monoid has_to_string pos) : @add_monoid.fg.{0} (has_to_string.{0} pos) (@functor.comp.run.{0 0 0} add_monoid.{0} has_to_string.{0} pos (@functor.comp.run.{0 0 0} add_monoid.{0} has_to_string.{0} pos (@functor.comp.run.{0 0 0} add_monoid.{0} has_to_string.{0} pos (@functor.comp.run.{0 0 0} add_monoid.{0} has_to_string.{0} pos (@functor.comp.run.{0 0 0} add_monoid.{0} has_to_string.{0} pos (@functor.comp.run.{0 0 0} add_monoid.{0} has_to_string.{0} pos (@functor.comp.run.{0 0 0} add_monoid.{0} has_to_string.{0} pos (@functor.comp.run.{0 0 0} add_monoid.{0} has_to_string.{0} pos (@functor.comp.run.{0 0 0} add_monoid.{0} has_to_string.{0} pos (@functor.comp.run.{0 0 0} add_monoid.{0} has_to_string.{0} pos (@functor.comp.run.{0 0 0} add_monoid.{0} has_to_string.{0} pos (@functor.comp.run.{0 0 0} add_monoid.{0} has_to_string.{0} pos (@functor.comp.run.{0 0 0} add_monoid.{0} has_to_string.{0} pos (@functor.comp.run.{0 0 0} add_monoid.{0} has_to_string.{0} pos (@functor.comp.run.{0 0 0} add_monoid.{0} has_to_string.{0} pos h0)))))))))))))))  := sorry --non-trivial
lemma new_lemma_144476 (h0 : complete_lattice (add_left_cancel_semigroup (mul_one_class ereal))) : complete_lattice.is_Sup_finite_compact (add_left_cancel_semigroup (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_144477 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_144478 (h0 : topological_space (has_neg_part pos)) : preirreducible_space (has_neg_part pos) := sorry --non-trivial
lemma new_lemma_144479 (h0 : functor.add_const (ring (linear_ordered_cancel_comm_monoid empty)) empty) : @strong_rank_condition.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_144480 (h0 : semiring (has_add (comm_semigroup Type))) : is_noetherian_ring (has_add (comm_semigroup Type)) := sorry --non-trivial
lemma new_lemma_144481 (h0 : functor.add_const (ring (canonically_linear_ordered_monoid name)) name) : @is_principal_ideal_ring.{0} (canonically_linear_ordered_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (canonically_linear_ordered_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_144482 (h0 : ring (normed_lattice_add_comm_group (boolean_algebra real))) : rank_condition (normed_lattice_add_comm_group (boolean_algebra real)) := sorry --non-trivial
lemma new_lemma_144483 (h0 : generalized_boolean_algebra (has_Inf Type) -> generalized_boolean_algebra (has_Inf Type) -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_144484 (h0 : not (topological_space (has_emptyc (has_norm linarith.ineq)) -> false)) : @irreducible_space.{0} (has_emptyc.{0} (has_norm.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} (has_norm.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_144485 (h0 : topological_space (sub_neg_monoid (has_Inf real))) : discrete_topology (sub_neg_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_144486 (h0 : functor.add_const (functor.add_const (group pos) pos) pos) : @group.fg.{0} pos (@functor.add_const.run.{0 0} (group.{0} pos) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (group.{0} pos) pos) pos h0))  := sorry --non-trivial
lemma new_lemma_144487 (h0 : ring (random_gen (random_gen (random_gen linarith.ineq)))) : rank_condition (random_gen (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_144488 (h0 : function.extfun nat fin) : @preirreducible_space.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_144489 (h0 : ring (distrib fun_info)) : strong_rank_condition (distrib fun_info) := sorry --non-trivial
lemma new_lemma_144490 (h0 : filter (with_zero char)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_144491 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_144492 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @strong_rank_condition.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_144493 (h0 : add_group (has_top (random_gen linarith.ineq))) : is_add_cyclic (has_top (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_144494 (h0 : topological_space (has_emptyc (has_top (has_top to_additive.value_type)))) : irreducible_space (has_emptyc (has_top (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_144495 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_144496 (h0 : measurable_space (has_ssubset (add_comm_semigroup environment.projection_info))) (h1 : measure_theory.measure (has_ssubset (add_comm_semigroup environment.projection_info))) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_144497 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_comm_semiring (has_add Type))) : unique_factorization_monoid (canonically_ordered_comm_semiring (has_add Type)) := sorry --non-trivial
lemma new_lemma_144498 (h0 : group (linear_ordered_semiring (random_gen (random_gen (random_gen num))))) : is_cyclic (linear_ordered_semiring (random_gen (random_gen (random_gen num)))) := sorry --non-trivial
lemma new_lemma_144499 (h0 : ordered_comm_monoid (ring (has_Inf Type))) : has_exists_mul_of_le (ring (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_144500 (h1 : complete_lattice (encodable (random_gen string_imp))) : complete_lattice.is_Sup_finite_compact (encodable (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_144501 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_144502 (h0 : topological_space (has_Inf (ring name))) : irreducible_space (has_Inf (ring name)) := sorry --non-trivial
lemma new_lemma_144503 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_add.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_add.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_144504 (h0 : function.extfun (Type 1) topological_space) : @preconnected_space.{1} (normed_lattice_add_comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (normed_lattice_add_comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_144505 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_144506 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (monoid_with_zero.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (monoid_with_zero.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_144507 (h0 : functor.add_const (function.extfun Type complete_lattice) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) linarith.comp h0) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_144508 (h0 : topological_space (complete_distrib_lattice (option (option unsigned)))) : preirreducible_space (complete_distrib_lattice (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_144509 (h0 : uniform_space (has_Inf real)) : separated_space (has_Inf real) := sorry --non-trivial
lemma new_lemma_144510 (h0 : topological_space (generalized_boolean_algebra (has_add linarith.comp))) : discrete_topology (generalized_boolean_algebra (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_144511 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_144512 (h0 : add_group (plift (option unsigned))) : is_add_cyclic (plift (option unsigned)) := sorry --non-trivial
lemma new_lemma_144513 (h0 : functor.add_const (ordered_comm_monoid (has_add Type)) linarith.comp) : @has_exists_mul_of_le.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (has_add.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_144514 (h0 : has_mem.mem (semiring (random_gen linarith.comp_source)) has_emptyc.emptyc) : @strong_rank_condition.{0} (semiring.{0} (random_gen.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} (random_gen.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_144515 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @path_connected_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_144516 (h0 : functor.comp topological_space has_nndist ennreal) : @discrete_topology.{0} (has_nndist.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_144517 (h0 : ring (canonically_linear_ordered_monoid num)) : rank_condition (canonically_linear_ordered_monoid num) := sorry --non-trivial
lemma new_lemma_144518 (h0 : topological_space (has_bot (sub_neg_monoid real))) : regular_space (has_bot (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_144519 (h0 : finset (has_add (option unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_144520 (h1 : function.extfun Type ring) : @rank_condition.{0} (linear_ordered_add_comm_group.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} h1 (linear_ordered_add_comm_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_144521 (h0 : functor.add_const (ordered_add_comm_monoid (has_Sup unsigned)) unsigned) : @archimedean.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_Sup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_144522 (h0 : cancel_monoid (cancel_monoid name) -> cancel_monoid (cancel_monoid name) -> Prop) : is_antisymm (cancel_monoid (cancel_monoid name)) h0 := sorry --non-trivial
lemma new_lemma_144523 (h0 : has_le (mul_one_class (normed_field (normed_field char)))) (h4 : mul_one_class (normed_field (normed_field char))) : is_max h4 := sorry --non-trivial
lemma new_lemma_144524 (h0 : group (distrib_lattice (random_gen (has_inv (random_gen fun_info))))) : group.fg (distrib_lattice (random_gen (has_inv (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_144525 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_144526 (h0 : topological_space (normed_group (semiring (semiring empty)))) : irreducible_space (normed_group (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_144527 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @irreducible_space.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_144528 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_144529 (h0 : functor.add_const (list (boolean_algebra pos)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_144530 (h0 : group (has_inv (has_inv (random_gen linarith.comp_source)))) : group.fg (has_inv (has_inv (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_144531 (h0 : topological_space (semigroup (has_neg Type))) : totally_separated_space (semigroup (has_neg Type)) := sorry --non-trivial
lemma new_lemma_144532 (h1 : not (filter (random_gen char) -> false)) : filter.ne_bot (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_144533 (h0 : complete_lattice (canonically_ordered_comm_semiring (option empty))) : is_compactly_generated (canonically_ordered_comm_semiring (option empty)) := sorry --non-trivial
lemma new_lemma_144534 (h0 : group (has_top (has_norm linarith.comp))) : normalizer_condition (has_top (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_144535 (h0 : functor.add_const (topological_space znum) (option empty)) : @path_connected_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_144536 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_144537 (h0 : ring (boolean_algebra (has_neg environment.implicit_infer_kind))) : is_domain (boolean_algebra (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_144538 (h0 : functor.add_const (finset (ordered_comm_monoid pos)) (ring Type)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_144539 (h0 : uniform_space (canonically_linear_ordered_add_monoid unsigned)) : complete_space (canonically_linear_ordered_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_144540 (h0 : function.extfun (Type 1) topological_space) : @topological_space.separable_space.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_144541 (h0 : functor.add_const (semiring (has_dist congr_arg_kind)) congr_arg_kind) : @is_noetherian_ring.{0} (has_dist.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (semiring.{0} (has_dist.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_144542 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_separated_space.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_144543 (h0 : semiring (add_cancel_monoid (has_add linarith.comp))) : is_noetherian_ring (add_cancel_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_144544 (h0 : list (option (semiring num))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_144545 (h0 : ring (has_Sup num)) : is_principal_ideal_ring (has_Sup num) := sorry --non-trivial
lemma new_lemma_144546 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (linear_ordered_field.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} num))  := sorry --non-trivial
lemma new_lemma_144547 (h0 : functor.add_const (semiring (plift congr_arg_kind)) unsigned) : @is_noetherian_ring.{1} (plift.{1} congr_arg_kind) (@functor.add_const.run.{1 0} (semiring.{1} (plift.{1} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_144548 (h0 : has_coe (add_comm_semigroup (mul_one_class std_gen)) Prop) (h1 : add_comm_semigroup (mul_one_class std_gen)) : @coe_b.{1 1} (add_comm_semigroup.{0} (mul_one_class.{0} std_gen)) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_144549 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @irreducible_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_144550 (h0 : monoid (mul_zero_class empty)) : monoid.fg (mul_zero_class empty) := sorry --non-trivial
lemma new_lemma_144551 (h0 : uniform_space (has_top (has_nnnorm to_additive.value_type))) : complete_space (has_top (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_144552 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (preorder.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} num))  := sorry --non-trivial
lemma new_lemma_144553 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) environment.implicit_infer_kind) : @locally_compact_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_144554 (h0 : topological_space (linear_ordered_semiring linarith.comp)) : normal_space (linear_ordered_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_144555 (h0 : cancel_comm_monoid_with_zero (complete_distrib_lattice (has_neg Type))) : unique_factorization_monoid (complete_distrib_lattice (has_neg Type)) := sorry --non-trivial
lemma new_lemma_144556 (h0 : topological_space (semigroup (canonically_linear_ordered_monoid (option name)))) : path_connected_space (semigroup (canonically_linear_ordered_monoid (option name))) := sorry --non-trivial
lemma new_lemma_144557 (h0 : uniform_space (finset (finset (finset (has_neg (has_neg (finset Type))))))) : complete_space (finset (finset (finset (has_neg (has_neg (finset Type)))))) := sorry --non-trivial
lemma new_lemma_144558 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_144559 (h0 : functor.add_const (topological_space (boolean_algebra.core linarith.comp)) name) : @regular_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_144560 (h0 : ordered_comm_monoid (boolean_algebra pos)) : has_exists_mul_of_le (boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_144561 (h0 : topological_space (has_Inf Type)) : totally_separated_space (has_Inf Type) := sorry --non-trivial
lemma new_lemma_144562 (h0 : topological_space (complete_distrib_lattice (option (option ennreal)))) : discrete_topology (complete_distrib_lattice (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_144563 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_144564 (h0 : ring (has_nndist (finset (has_add (has_add (has_add ennreal)))))) : rank_condition (has_nndist (finset (has_add (has_add (has_add ennreal))))) := sorry --non-trivial
lemma new_lemma_144565 (h0 : topological_space (has_emptyc (random_gen (random_gen num)))) : discrete_topology (has_emptyc (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_144566 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_144567 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} znum (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) znum)  := sorry --non-trivial
lemma new_lemma_144568 (h0 : topological_space (has_sub (semiring empty))) : preirreducible_space (has_sub (semiring empty)) := sorry --non-trivial
lemma new_lemma_144569 (h0 : topological_space (preorder congr_arg_kind)) : irreducible_space (preorder congr_arg_kind) := sorry --non-trivial
lemma new_lemma_144570 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) (has_neg Type)) : @locally_compact_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_144571 (h1 : topological_space (has_nnnorm to_additive.value_type)) : totally_disconnected_space (has_nnnorm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_144572 (h0 : functor.add_const (filter (mul_zero_class num)) num) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_144573 (h0 : measurable_space (mul_one_class (add_comm_semigroup ereal))) (h1 : measure_theory.measure (mul_one_class (add_comm_semigroup ereal))) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_144574 (h0 : functor.comp uniform_space cancel_monoid name) : @complete_space.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} uniform_space.{0} cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_144575 (h0 : group (pseudo_metric_space num)) : is_simple_group (pseudo_metric_space num) := sorry --non-trivial
lemma new_lemma_144576 (h0 : complete_lattice (has_neg_part (option ennreal))) : complete_lattice.is_Sup_finite_compact (has_neg_part (option ennreal)) := sorry --non-trivial
lemma new_lemma_144577 (h0 : pfun string.iterator_imp (fun_info -> char)) : set.separates_points (pfun.ran h0) := sorry --non-trivial
lemma new_lemma_144578 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @normal_space.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_144579 (h0 : topological_space (has_neg_part (has_add (has_neg_part pos)))) : preconnected_space (has_neg_part (has_add (has_neg_part pos))) := sorry --non-trivial
lemma new_lemma_144580 (h0 : add_group (plift congr_arg_kind)) : is_add_cyclic (plift congr_arg_kind) := sorry --non-trivial
lemma new_lemma_144581 (h0 : functor.add_const (add_group (complete_distrib_lattice linarith.comp)) linarith.comp) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (complete_distrib_lattice.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_144582 (h0 : fin has_zero.zero) : @path_connected_space.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_144583 (h0 : has_mem.mem (with_one linarith.comp_source) has_emptyc.emptyc) : @is_cyclic.{0} (with_one.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type group.{0} (with_one.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_144584 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) pos) : @has_exists_mul_of_le.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) pos h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_144585 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_144586 (h0 : group (normed_lattice_add_comm_group (has_neg pos))) : group.fg (normed_lattice_add_comm_group (has_neg pos)) := sorry --non-trivial
lemma new_lemma_144587 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_144588 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (bin_tree.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (bin_tree.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_144589 (h0 : topological_space (has_norm (random_gen (random_gen linarith.comp_source)))) : t0_space (has_norm (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_144590 (h0 : ring (has_nndist (option unsigned))) : is_principal_ideal_ring (has_nndist (option unsigned)) := sorry --non-trivial
lemma new_lemma_144591 (h0 : functor.add_const (function.extfun nat fin) (has_Inf linarith.comp)) : @irreducible_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin (@functor.add_const.run.{0 0} (function.extfun.{1 1} nat fin) (has_Inf.{0} linarith.comp) h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_144592 (h0 : topological_space (has_top (measurable_space (has_norm empty)))) : t0_space (has_top (measurable_space (has_norm empty))) := sorry --non-trivial
lemma new_lemma_144593 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_144594 (h0 : topological_space (finset (has_neg_part name))) : t1_space (finset (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_144595 (h0 : functor.add_const (topological_space (ordered_ring empty)) congr_arg_kind) : @preirreducible_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_144596 (h1 : not (complete_lattice (has_compl string_imp) -> false)) : @is_compactly_generated.{0} (has_compl.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_compl.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_144597 (h0 : monoid (with_one (with_bot linarith.comp_source))) : monoid.fg (with_one (with_bot linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_144598 (h0 : ring (distrib (bin_tree char))) : is_domain (distrib (bin_tree char)) := sorry --non-trivial
lemma new_lemma_144599 (h0 : uniform_space (denumerable (has_inv fun_info))) : complete_space (denumerable (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_144600 (h0 : topological_space (has_add (has_Inf pos))) : preirreducible_space (has_add (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_144601 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (semigroup.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_144602 (h0 : functor.add_const (add_monoid (ordered_ring unsigned)) num) : @add_monoid.fg.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (ordered_ring.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_144603 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_144604 (h0 : function.extfun Type ring) : @is_domain.{0} (has_emptyc.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_emptyc.{0} empty))  := sorry --non-trivial
lemma new_lemma_144605 (h0 : function.extfun (Type 1) topological_space) : @t1_space.{1} (normed_lattice_add_comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (normed_lattice_add_comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_144606 (h0 : topological_space (linear_ordered_field (option ennreal))) : loc_path_connected_space (linear_ordered_field (option ennreal)) := sorry --non-trivial
lemma new_lemma_144607 (h0 : filter (complete_distrib_lattice char)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_144608 (h0 : ordered_add_comm_monoid (comm_group linarith.comp)) : archimedean (comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_144609 (h0 : uniform_space (measurable_space unsigned)) : complete_space (measurable_space unsigned) := sorry --non-trivial
lemma new_lemma_144610 (h0 : topological_space (normed_group (semiring unsigned))) : preirreducible_space (normed_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_144611 (h0 : function.extfun nat fin) : @separated_space.{0} (ordered_comm_ring.{0} linarith.comp) (@matrix.vec_empty.{0} (uniform_space.{0} (ordered_comm_ring.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_144612 (h0 : group (canonically_linear_ordered_monoid (option num))) : is_cyclic (canonically_linear_ordered_monoid (option num)) := sorry --non-trivial
lemma new_lemma_144613 (h0 : function.extfun Type (functor.add_const (functor.add_const Prop Type))) : functor.add_const.run (functor.add_const.run (function.extfun_app h0 linarith.comp)) := sorry --non-trivial
lemma new_lemma_144614 (h0 : functor.add_const (ring (boolean_algebra.core Type)) (has_Inf pos)) : @is_principal_ideal_ring.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.core.{1} Type)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_144615 (h0 : topological_space (semigroup (ring (boolean_algebra.core linarith.comp)))) : preirreducible_space (semigroup (ring (boolean_algebra.core linarith.comp))) := sorry --non-trivial
lemma new_lemma_144616 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_144617 (h0 : topological_space pos) : irreducible_space pos := sorry --non-trivial
lemma new_lemma_144618 (h0 : filter (ring (boolean_algebra.core (has_add Type)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_144619 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @discrete_topology.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_144620 (h0 : with_bot (function.extfun Type topological_space)) (h1 : ne h0 has_bot.bot) : @irreducible_space.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@with_bot.unbot.{1} (function.extfun.{2 1} Type topological_space.{0}) h0 h1) (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_144621 (h0 : not (complete_lattice (linear_ordered_semiring num) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_semiring.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_144622 (h0 : topological_space (has_top (semiring congr_arg_kind))) : totally_disconnected_space (has_top (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_144623 (h0 : function.extfun nat fin) : @is_cyclic.{0} (normed_lattice_add_comm_group.{0} real) (@matrix.vec_empty.{0} (group.{0} (normed_lattice_add_comm_group.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_144624 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_144625 (h0 : ring (has_inter (option (option (option unsigned))))) : rank_condition (has_inter (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_144626 (h1 : set (add_comm_semigroup linarith.ineq)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_144627 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_144628 (h0 : topological_space (non_unital_non_assoc_semiring (mul_one_class (mul_one_class string.iterator_imp)))) : t0_space (non_unital_non_assoc_semiring (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_144629 (h0 : group (canonically_ordered_comm_semiring (finset ennreal))) : group.fg (canonically_ordered_comm_semiring (finset ennreal)) := sorry --non-trivial
lemma new_lemma_144630 (h0 : finset congr_arg_kind -> finset congr_arg_kind -> Prop) : well_founded h0 := sorry --non-trivial
lemma new_lemma_144631 (h0 : cancel_comm_monoid_with_zero (ring (has_neg linarith.comp))) : unique_factorization_monoid (ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_144632 (h0 : monoid pos) : monoid.fg pos := sorry --non-trivial
lemma new_lemma_144633 (h0 : group (ordered_comm_ring (finset Type))) : is_simple_group (ordered_comm_ring (finset Type)) := sorry --non-trivial
lemma new_lemma_144634 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_144635 (h1 : group (uniform_space reducibility_hints)) : is_cyclic (uniform_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_144636 (h0 : fin has_zero.zero) : @rank_condition.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_144637 (h0 : ring (has_norm (comm_ring fun_info))) : rank_condition (has_norm (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_144638 (h0 : functor.add_const (complete_lattice (complete_distrib_lattice name)) (boolean_algebra name)) : @is_atomistic.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (complete_distrib_lattice.{0} name)) (boolean_algebra.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_144639 (h0 : not (topological_space (semiring fun_info) -> false)) : @totally_separated_space.{0} (semiring.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_144640 (h0 : set (add_comm_semigroup fun_info)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_144641 (h0 : functor.add_const (topological_space (partial_order empty)) empty) : @t0_space.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_144642 (h0 : ordered_comm_monoid (has_pos_part (has_neg (has_add Type)))) : has_exists_mul_of_le (has_pos_part (has_neg (has_add Type))) := sorry --non-trivial
lemma new_lemma_144643 (h0 : not (uniform_space (has_inter linarith.comp_source) -> false)) : @complete_space.{0} (has_inter.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_inter.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_144644 (h0 : functor.add_const (topological_space (plift unsigned)) empty) : @loc_path_connected_space.{1} (plift.{1} unsigned) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_144645 (h0 : group (linear_ordered_comm_ring (has_top num))) : is_cyclic (linear_ordered_comm_ring (has_top num)) := sorry --non-trivial
lemma new_lemma_144646 (h0 : fin has_zero.zero) : @group.fg.{1} (has_Inf.{1} Type) (@matrix.vec_empty.{1} (group.{1} (has_Inf.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_144647 (h0 : function.extfun nat fin) : @is_cyclic.{0} (ordered_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (group.{0} (ordered_comm_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_144648 (h0 : topological_space (has_bot Type)) : t0_space (has_bot Type) := sorry --non-trivial
lemma new_lemma_144649 (h0 : group (ring name)) : is_cyclic (ring name) := sorry --non-trivial
lemma new_lemma_144650 (h0 : group (normed_lattice_add_comm_group (has_Inf (has_add pos)))) : is_cyclic (normed_lattice_add_comm_group (has_Inf (has_add pos))) := sorry --non-trivial
lemma new_lemma_144651 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_star.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_star.{0} num))  := sorry --non-trivial
lemma new_lemma_144652 (h0 : group (complete_semilattice_Sup (random_gen (random_gen linarith.comp_source)))) : is_cyclic (complete_semilattice_Sup (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_144653 (h0 : functor.comp filter ring name) : countable_Inter_filter (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_144654 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @rank_condition.{0} (has_bot.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (has_bot.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_144655 (h1 : filter (lex (has_nnnorm (has_nnnorm char)))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_144656 (h0 : ring (has_to_string Type)) : strong_rank_condition (has_to_string Type) := sorry --non-trivial
lemma new_lemma_144657 (h0 : topological_space (normed_comm_ring (has_add name))) : normal_space (normed_comm_ring (has_add name)) := sorry --non-trivial
lemma new_lemma_144658 (h0 : complete_lattice (add_right_cancel_monoid (semiring congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (add_right_cancel_monoid (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_144659 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) linarith.comp) : @normal_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_144660 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (normed_group.{0} (random_gen.{0} (has_top.{0} (has_ssubset.{0} to_additive.value_type)))) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} (random_gen.{0} (has_top.{0} (has_ssubset.{0} to_additive.value_type)))))  := sorry --non-trivial
lemma new_lemma_144661 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_144662 (h0 : group (comm_ring (has_nnnorm reducibility_hints))) : is_cyclic (comm_ring (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_144663 (h0 : functor.add_const (complete_lattice (complete_distrib_lattice environment.implicit_infer_kind)) name) : @is_compactly_generated.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_144664 (h1 : ring (fintype (has_nnnorm (has_nnnorm fun_info)))) : rank_condition (fintype (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_144665 (h0 : semiring (ring (has_to_string (ring pos)))) : is_noetherian_ring (ring (has_to_string (ring pos))) := sorry --non-trivial
lemma new_lemma_144666 (h0 : ring (generalized_boolean_algebra (ring Type))) : rank_condition (generalized_boolean_algebra (ring Type)) := sorry --non-trivial
lemma new_lemma_144667 (h0 : topological_space (boolean_algebra (add_comm_monoid environment.implicit_infer_kind))) : totally_separated_space (boolean_algebra (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_144668 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (@id.{2} Type string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type string_imp))  := sorry --non-trivial
lemma new_lemma_144669 (h0 : ring (canonically_ordered_add_monoid (option empty))) : rank_condition (canonically_ordered_add_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_144670 (h0 : not (uniform_space (canonically_ordered_add_monoid char) -> false)) : @complete_space.{0} (canonically_ordered_add_monoid.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (canonically_ordered_add_monoid.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_144671 (h0 : topological_space (normed_linear_ordered_group empty)) : loc_path_connected_space (normed_linear_ordered_group empty) := sorry --non-trivial
lemma new_lemma_144672 (h0 : uniform_space (canonically_ordered_monoid pos)) : complete_space (canonically_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_144673 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_144674 (h0 : functor.add_const (fin has_zero.zero) (has_neg pos)) : @preirreducible_space.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) (@matrix.vec_empty.{2} (function.extfun.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1))) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (has_neg.{0} pos) h0)) topological_space.{1}) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_144675 (h1 : complete_lattice (semi_normed_ring (normed_field environment.projection_info))) : is_compactly_generated (semi_normed_ring (normed_field environment.projection_info)) := sorry --non-trivial
lemma new_lemma_144676 (h0 : functor.add_const (topological_space (boolean_algebra.core linarith.comp)) pos) : @regular_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_144677 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (add_comm_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_144678 (h0 : functor.add_const (group (ring environment.implicit_infer_kind)) Type) : @is_simple_group.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (group.{0} (ring.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_144679 (h0 : ring (bin_tree (semiring (semiring (semiring (semiring (semiring (semiring num)))))))) : rank_condition (bin_tree (semiring (semiring (semiring (semiring (semiring (semiring num))))))) := sorry --non-trivial
lemma new_lemma_144680 (h0 : topological_space (has_union (with_bot empty))) : normal_space (has_union (with_bot empty)) := sorry --non-trivial
lemma new_lemma_144681 (h0 : functor.add_const (ring (ordered_comm_ring Type)) (has_Inf real)) : @is_domain.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (ordered_comm_ring.{1} Type)) (has_Inf.{0} real) h0)  := sorry --non-trivial
lemma new_lemma_144682 (h0 : semiring (has_to_string (has_Inf name))) : is_noetherian_ring (has_to_string (has_Inf name)) := sorry --non-trivial
lemma new_lemma_144683 (h0 : function.extfun Type (functor.add_const (topological_space auto.case_option))) : @locally_compact_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) ennreal (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} auto.case_option)) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_144684 (h0 : topological_space (has_neg_part (has_add name))) : locally_compact_space (has_neg_part (has_add name)) := sorry --non-trivial
lemma new_lemma_144685 (h0 : ring (group_with_zero num)) : strong_rank_condition (group_with_zero num) := sorry --non-trivial
lemma new_lemma_144686 (h0 : complete_lattice (has_top (random_gen to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (has_top (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_144687 (h0 : ring (has_nndist (add_comm_monoid Type))) : strong_rank_condition (has_nndist (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_144688 (h0 : topological_space (cancel_monoid (has_add name))) : normal_space (cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_144689 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_144690 (h0 : functor.add_const (list (has_to_string stieltjes_function)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_144691 (h0 : functor.add_const (uniform_space (has_zero linarith.comp)) (has_add name)) : @complete_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_zero.{0} linarith.comp)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_144692 (h1 : ring (distrib_lattice (linear_ordered_add_comm_group (has_ssubset fun_info)))) : is_domain (distrib_lattice (linear_ordered_add_comm_group (has_ssubset fun_info))) := sorry --non-trivial
lemma new_lemma_144693 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) unsigned) : @archimedean.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) unsigned h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_144694 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_144695 (h0 : topological_space (has_emptyc (has_top linarith.ineq))) : t0_space (has_emptyc (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_144696 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_144697 (h0 : functor.add_const (topological_space (has_add linarith.comp)) pos) : @loc_path_connected_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_144698 (h0 : measurable_space (nondiscrete_normed_field string.iterator_imp)) (h1 : measure_theory.measure (nondiscrete_normed_field string.iterator_imp)) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_144699 (h0 : topological_space (comm_semigroup (has_add (ordered_comm_monoid Type)))) : t1_space (comm_semigroup (has_add (ordered_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_144700 (h0 : topological_space (has_pos_part (has_neg (has_neg (has_neg (has_neg Type)))))) : sequential_space (has_pos_part (has_neg (has_neg (has_neg (has_neg Type))))) := sorry --non-trivial
lemma new_lemma_144701 (h0 : topological_space (comm_group (finset pos))) : regular_space (comm_group (finset pos)) := sorry --non-trivial
lemma new_lemma_144702 (h0 : function.extfun Type (functor.add_const (group auto.case_option))) : @is_cyclic.{0} auto.case_option (@functor.add_const.run.{0 0} (group.{0} auto.case_option) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} auto.case_option)) h0 num))  := sorry --non-trivial
lemma new_lemma_144703 (h0 : functor.comp ring has_to_string name) : @is_principal_ideal_ring.{0} (has_to_string.{0} name) (@functor.comp.run.{0 0 0} ring.{0} has_to_string.{0} name h0)  := sorry --non-trivial
lemma new_lemma_144704 (h0 : list (has_zero (comm_group name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_144705 (h0 : set (prod empty empty)) (h1 : function.extfun (Type -> Type) (function.extfun Type)) : symmetrize_rel h0 (function.extfun_app (function.extfun_app h1 (prod empty)) empty) := sorry --non-trivial
lemma new_lemma_144706 (h0 : semiring (has_add (has_Inf name))) : is_noetherian_ring (has_add (has_Inf name)) := sorry --non-trivial
lemma new_lemma_144707 (h0 : topological_space (uniform_space fun_info)) (h1 : preorder (uniform_space fun_info)) : order_topology (uniform_space fun_info) := sorry --non-trivial
lemma new_lemma_144708 (h0 : functor.add_const (function.extfun Type finset) unsigned) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (left_cancel_semigroup num)) := sorry --non-trivial
lemma new_lemma_144709 (h0 : ring (has_lt linarith.ineq)) : strong_rank_condition (has_lt linarith.ineq) := sorry --non-trivial
lemma new_lemma_144710 (h0 : function.extfun Type (functor.add_const (complete_lattice (linear_ordered_comm_monoid_with_zero empty)))) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) (option.{0} unsigned) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (linear_ordered_comm_monoid_with_zero.{0} empty))) h0 (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_144711 (h0 : ring (boolean_algebra (has_neg real))) : is_principal_ideal_ring (boolean_algebra (has_neg real)) := sorry --non-trivial
lemma new_lemma_144712 (h0 : fin has_zero.zero) : @monoid.fg.{0} (sub_neg_monoid.{0} real) (@matrix.vec_empty.{0} (monoid.{0} (sub_neg_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_144713 (h0 : list (left_cancel_semigroup (semiring empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_144714 (h0 : topological_space (has_ssubset (has_nnnorm (random_gen (has_nnnorm char))))) : locally_compact_space (has_ssubset (has_nnnorm (random_gen (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_144715 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (add_left_cancel_semigroup empty)) := sorry --non-trivial
lemma new_lemma_144716 (h0 : not (add_group (topological_space string_imp) -> false)) : @is_add_cyclic.{0} (topological_space.{0} string_imp) (@classical.by_contradiction'.{1} (add_group.{0} (topological_space.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_144717 (h3 : ring (comm_ring (denumerable to_additive.value_type))) : strong_rank_condition (comm_ring (denumerable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_144718 (h0 : functor.add_const (ring (is_R_or_C num)) empty) : @strong_rank_condition.{0} (is_R_or_C.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (is_R_or_C.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_144719 (h0 : uniform_space (monoid_with_zero unsigned)) : complete_space (monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_144720 (h0 : group (complete_distrib_lattice (finset linarith.comp))) : is_simple_group (complete_distrib_lattice (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_144721 (h0 : topological_space (semiring (has_norm congr_arg_kind))) : irreducible_space (semiring (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_144722 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_144723 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_144724 (h1 : topological_space (normed_group (random_gen (random_gen (has_ssubset string_imp))))) : t0_space (normed_group (random_gen (random_gen (has_ssubset string_imp)))) := sorry --non-trivial
lemma new_lemma_144725 (h0 : function.extfun Type (functor.add_const (complete_lattice (semiring unsigned)))) : @is_atomistic.{0} (semiring.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semiring.{0} unsigned)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (semiring.{0} unsigned))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_144726 (h0 : add_group (ring (has_pos_part linarith.comp))) : is_add_cyclic (ring (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_144727 (h0 : ring (canonically_ordered_comm_semiring (has_add (has_neg_part Type)))) : rank_condition (canonically_ordered_comm_semiring (has_add (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_144728 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (ordered_ring.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (ordered_ring.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_144729 (h0 : list (measurable_space.dynkin_system (semiring congr_arg_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_144730 (h0 : complete_lattice (measurable_space.dynkin_system (semiring unsigned))) : complete_lattice.is_Sup_finite_compact (measurable_space.dynkin_system (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_144731 (h0 : list (finset (ring unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_144732 (h0 : ring (with_zero (has_inv (has_ssubset linarith.ineq)))) : rank_condition (with_zero (has_inv (has_ssubset linarith.ineq))) := sorry --non-trivial
lemma new_lemma_144733 (h0 : topological_space (add_cancel_monoid (boolean_algebra.core (has_to_string pos)))) : t0_space (add_cancel_monoid (boolean_algebra.core (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_144734 (h0 : functor.comp topological_space canonically_linear_ordered_monoid (option name)) : @sequential_space.{0} (canonically_linear_ordered_monoid.{0} (option.{0} name)) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_linear_ordered_monoid.{0} (option.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_144735 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_144736 (h0 : functor.add_const (complete_lattice (cancel_monoid name)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_144737 (h0 : topological_space (has_bot (has_add (has_neg (has_neg name))))) : sequential_space (has_bot (has_add (has_neg (has_neg name)))) := sorry --non-trivial
lemma new_lemma_144738 (h0 : fin has_zero.zero) : @add_monoid.fg.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type add_monoid.{0}) h0) (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_144739 (h0 : add_monoid (boolean_algebra (add_comm_monoid (has_add name)))) : add_monoid.fg (boolean_algebra (add_comm_monoid (has_add name))) := sorry --non-trivial
lemma new_lemma_144740 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot fun_info))) : @add_monoid.fg.{0} (with_bot.{0} fun_info) (@finset.pi.empty.{1 0} Type add_monoid.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_144741 (h0 : functor.add_const (ring (has_to_string pos)) Type) : @rank_condition.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_to_string.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_144742 (h0 : monoid (measurable_space linarith.ineq)) : monoid.fg (measurable_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_144743 (h0 : topological_space (boolean_algebra (boolean_algebra.core (boolean_algebra.core unsigned)))) : preconnected_space (boolean_algebra (boolean_algebra.core (boolean_algebra.core unsigned))) := sorry --non-trivial
lemma new_lemma_144744 (h0 : has_mem.mem (normed_group empty) has_emptyc.emptyc) : @is_cyclic.{0} (normed_group.{0} empty) (@finset.pi.empty.{1 0} Type group.{0} (normed_group.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_144745 (h0 : functor.add_const (group (has_Sup unsigned)) unsigned) : @normalizer_condition.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_Sup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_144746 (h0 : group (has_pos_part (ordered_comm_ring (has_Inf Type)))) : normalizer_condition (has_pos_part (ordered_comm_ring (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_144747 (h0 : ordered_comm_monoid (has_Inf (has_pos_part linarith.comp))) : has_exists_mul_of_le (has_Inf (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_144748 (h0 : functor.add_const (group (generalized_boolean_algebra pos)) (finset pos)) : @normalizer_condition.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (generalized_boolean_algebra.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_144749 (h0 : not (group (option congr_arg_kind) -> false)) : @is_cyclic.{0} (option.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (option.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_144750 (h2 : set linarith.ineq) : set.finite h2 := sorry --non-trivial
lemma new_lemma_144751 (h0 : not (topological_space (has_norm fun_info) -> false)) : @t0_space.{0} (has_norm.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_144752 (h0 : complete_lattice (normed_group (has_norm (has_norm linarith.comp)))) : is_compactly_generated (normed_group (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_144753 (h0 : topological_space (add_comm_semigroup linarith.ineq)) (h1 : preorder (add_comm_semigroup linarith.ineq)) : order_closed_topology (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_144754 (h0 : add_monoid (has_neg (has_add (boolean_algebra.core unsigned)))) : add_monoid.fg (has_neg (has_add (boolean_algebra.core unsigned))) := sorry --non-trivial
lemma new_lemma_144755 (h0 : functor.add_const (topological_space (has_nndist pos)) linarith.comp) : @preirreducible_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_144756 (h0 : topological_space (generalized_boolean_algebra (ordered_comm_monoid (has_bot (has_Inf real))))) : totally_separated_space (generalized_boolean_algebra (ordered_comm_monoid (has_bot (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_144757 (h1 : topological_space (has_append (has_nnnorm (has_nnnorm (has_nnnorm char))))) : t0_space (has_append (has_nnnorm (has_nnnorm (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_144758 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (linear_ordered_field.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} linear_ordered_field.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} linear_ordered_field.{0}) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.comp.{0 0 0} topological_space.{0} linear_ordered_field.{0})) pos))  := sorry --non-trivial
lemma new_lemma_144759 (h0 : topological_space (has_add (option pos))) : t1_space (has_add (option pos)) := sorry --non-trivial
lemma new_lemma_144760 (h0 : has_mem.mem (has_norm empty) has_emptyc.emptyc) : @irreducible_space.{0} (has_norm.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_144761 (h1 : topological_space (has_div string_imp)) : t0_space (has_div string_imp) := sorry --non-trivial
lemma new_lemma_144762 (h1 : ring (non_unital_non_assoc_semiring string.iterator_imp)) : rank_condition (non_unital_non_assoc_semiring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_144763 (h0 : not (complete_lattice (semigroup empty) -> false)) : @is_compactly_generated.{0} (semigroup.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semigroup.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_144764 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_144765 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_144766 (h0 : ring (linear_ordered_field ennreal)) : is_principal_ideal_ring (linear_ordered_field ennreal) := sorry --non-trivial
lemma new_lemma_144767 (h0 : measurable_space (add_comm_semigroup linarith.ineq)) (h1 : measure_theory.measure (add_comm_semigroup linarith.ineq)) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_144768 (h0 : functor.add_const (complete_lattice (canonically_ordered_monoid real)) pos) : @is_atomistic.{0} (canonically_ordered_monoid.{0} real) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_ordered_monoid.{0} real)) pos h0)  := sorry --non-trivial
lemma new_lemma_144769 (h0 : topological_space (has_le reducibility_hints)) (h1 : preorder (has_le reducibility_hints)) : order_topology (has_le reducibility_hints) := sorry --non-trivial
lemma new_lemma_144770 (h0 : ring (ordered_comm_ring (has_neg (has_neg pos)))) : rank_condition (ordered_comm_ring (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_144771 (h0 : complete_lattice (id (semiring linarith.comp))) : is_compactly_generated (id (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_144772 (h0 : topological_space (has_nndist unsigned)) : totally_separated_space (has_nndist unsigned) := sorry --non-trivial
lemma new_lemma_144773 (h0 : complete_lattice (has_bot (has_neg name))) : is_compactly_generated (has_bot (has_neg name)) := sorry --non-trivial
lemma new_lemma_144774 (h0 : not (topological_space (plift num) -> false)) : @discrete_topology.{1} (plift.{1} num) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} num)) h0)  := sorry --non-trivial
lemma new_lemma_144775 (h0 : uniform_space (distrib (has_ssubset reducibility_hints))) : complete_space (distrib (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_144776 (h0 : functor.comp add_monoid add_cancel_monoid Type) : @add_monoid.fg.{1} (add_cancel_monoid.{1} Type) (@functor.comp.run.{1 1 1} add_monoid.{1} add_cancel_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_144777 (h0 : topological_space (with_zero to_additive.value_type)) : t0_space (with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_144778 (h0 : topological_space (has_nndist (has_add (has_to_string Type)))) : topological_space.separable_space (has_nndist (has_add (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_144779 (h0 : topological_space (ring (option (option empty)))) : discrete_topology (ring (option (option empty))) := sorry --non-trivial
lemma new_lemma_144780 (h0 : add_group (boolean_algebra (finset pos))) : is_add_cyclic (boolean_algebra (finset pos)) := sorry --non-trivial
lemma new_lemma_144781 (h0 : add_group (is_R_or_C (semiring unsigned))) : is_add_cyclic (is_R_or_C (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_144782 (h0 : uniform_space (has_neg_part (option pos))) : complete_space (has_neg_part (option pos)) := sorry --non-trivial
lemma new_lemma_144783 (h0 : topological_space (finset (normed_comm_ring name))) : sequential_space (finset (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_144784 (h0 : ring (has_one empty)) : rank_condition (has_one empty) := sorry --non-trivial
lemma new_lemma_144785 (h0 : add_group (sub_neg_monoid (random_gen (random_gen (random_gen string_imp))))) : is_add_cyclic (sub_neg_monoid (random_gen (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_144786 (h0 : topological_space (has_ssubset (mul_one_class (mul_one_class reducibility_hints)))) : path_connected_space (has_ssubset (mul_one_class (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_144787 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @path_connected_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_144788 (h0 : topological_space (ordered_ring num)) : preirreducible_space (ordered_ring num) := sorry --non-trivial
lemma new_lemma_144789 (h0 : topological_space (add_cancel_monoid (has_Inf linarith.comp))) : locally_compact_space (add_cancel_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_144790 (h1 : ring (has_append string_imp)) : strong_rank_condition (has_append string_imp) := sorry --non-trivial
lemma new_lemma_144791 (h0 : monoid (add_cancel_monoid (has_nndist Type))) : monoid.fg (add_cancel_monoid (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_144792 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_144793 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_144794 (h0 : functor.add_const (uniform_space (ordered_cancel_add_comm_monoid num)) (semiring empty)) : @separated_space.{0} (ordered_cancel_add_comm_monoid.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_cancel_add_comm_monoid.{0} num)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_144795 (h0 : monoid (canonically_ordered_comm_semiring (option congr_arg_kind))) : monoid.fg (canonically_ordered_comm_semiring (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_144796 (h0 : uniform_space (bin_tree congr_arg_kind)) : complete_space (bin_tree congr_arg_kind) := sorry --non-trivial
lemma new_lemma_144797 (h0 : topological_space (simple_graph empty)) : totally_separated_space (simple_graph empty) := sorry --non-trivial
lemma new_lemma_144798 (h0 : topological_space (has_Inf (has_add (has_add pos)))) : topological_space.separable_space (has_Inf (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_144799 (h0 : topological_space (has_dist (option (option congr_arg_kind)))) : path_connected_space (has_dist (option (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_144800 (h0 : functor.add_const (semiring (linear_ordered_field ennreal)) ennreal) : @is_noetherian_ring.{0} (linear_ordered_field.{0} ennreal) (@functor.add_const.run.{0 0} (semiring.{0} (linear_ordered_field.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_144801 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @t0_space.{0} string_imp (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) string_imp)  := sorry --non-trivial
lemma new_lemma_144802 (h0 : topological_space (linear_ordered_semiring (has_norm empty))) : path_connected_space (linear_ordered_semiring (has_norm empty)) := sorry --non-trivial
lemma new_lemma_144803 (h0 : add_group (distrib_lattice linarith.comp_source)) : is_add_cyclic (distrib_lattice linarith.comp_source) := sorry --non-trivial
lemma new_lemma_144804 (h0 : topological_space (measurable_space (semiring num))) : preirreducible_space (measurable_space (semiring num)) := sorry --non-trivial
lemma new_lemma_144805 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_144806 (h0 : group (has_bot real)) : is_simple_group (has_bot real) := sorry --non-trivial
lemma new_lemma_144807 (h1 : uniform_space (has_ssubset (has_ssubset char))) : complete_space (has_ssubset (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_144808 (h0 : topological_space (canonically_linear_ordered_monoid (has_neg (has_Inf name)))) : discrete_topology (canonically_linear_ordered_monoid (has_neg (has_Inf name))) := sorry --non-trivial
lemma new_lemma_144809 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @add_monoid.fg.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_monoid.{1}) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_144810 (h0 : add_group (uniform_space (has_compl to_additive.value_type))) : is_add_cyclic (uniform_space (has_compl to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_144811 (h0 : not (group (id num) -> false)) : @group.fg.{0} (@id.{2} Type num) (@classical.by_contradiction'.{1} (group.{0} (@id.{2} Type num)) h0)  := sorry --non-trivial
lemma new_lemma_144812 (h0 : complete_lattice (has_star (semiring (semiring (semiring (semiring congr_arg_kind)))))) : is_compactly_generated (has_star (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_144813 (h0 : functor.add_const (topological_space (comm_group pos)) name) : @totally_disconnected_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_144814 (h0 : function.extfun (Type 1) complete_lattice) : @complete_lattice.is_Sup_finite_compact.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_144815 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @sequential_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_144816 (h0 : functor.add_const (topological_space (comm_group pos)) pos) : @preconnected_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_144817 (h0 : filter (comm_group (has_add (has_add name)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_144818 (h0 : topological_space (has_add (has_to_string Type))) : irreducible_space (has_add (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_144819 (h0 : semiring (semigroup (option Type))) : is_noetherian_ring (semigroup (option Type)) := sorry --non-trivial
lemma new_lemma_144820 (h0 : topological_space (add_group_with_zero_nhd (option congr_arg_kind))) : t0_space (add_group_with_zero_nhd (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_144821 (h0 : function.extfun Type (functor.add_const (uniform_space Type))) : @separated_space.{1} Type (@functor.add_const.run.{1 0} (uniform_space.{1} Type) (has_neg.{0} linarith.comp) (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (uniform_space.{1} Type)) h0 (has_neg.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_144822 (h0 : ring (add_comm_semigroup linarith.ineq)) : strong_rank_condition (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_144823 (h0 : functor.add_const (topological_space (ring Type)) (ring pos)) : @preconnected_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_144824 (h0 : not (function.extfun (Type 1) topological_space -> false)) : @path_connected_space.{1} (plift.{1} num) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@classical.by_contradiction'.{3} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (plift.{1} num))  := sorry --non-trivial
lemma new_lemma_144825 (h0 : not (ring (complete_semilattice_Sup num) -> false)) : @is_domain.{0} (complete_semilattice_Sup.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (complete_semilattice_Sup.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_144826 (h0 : topological_space (with_one (random_gen (random_gen linarith.ineq)))) : path_connected_space (with_one (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_144827 (h0 : functor.add_const (topological_space (comm_group name)) Type) : @regular_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_144828 (h0 : uniform_space (has_edist unsigned)) : complete_space (has_edist unsigned) := sorry --non-trivial
lemma new_lemma_144829 (h0 : not (topological_space (has_top linarith.comp_source) -> false)) : @discrete_topology.{0} (has_top.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_144830 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (linear_ordered_semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_144831 (h0 : complete_lattice (add_comm_monoid Type)) : complete_lattice.is_Sup_finite_compact (add_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_144832 (h0 : topological_space (comm_group (comm_group Type))) : discrete_topology (comm_group (comm_group Type)) := sorry --non-trivial
lemma new_lemma_144833 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_144834 (h0 : uniform_space (measurable_space (has_top linarith.ineq))) : complete_space (measurable_space (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_144835 (h0 : topological_space (has_emptyc (random_gen (random_gen (random_gen linarith.comp_source))))) : path_connected_space (has_emptyc (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_144836 (h0 : functor.add_const (topological_space (finset linarith.comp)) pos) : @topological_space.separable_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_144837 (h0 : topological_space (complete_distrib_lattice (option num))) : topological_space.separable_space (complete_distrib_lattice (option num)) := sorry --non-trivial
lemma new_lemma_144838 (h0 : topological_space (has_nndist (ring (has_to_string Type)))) : totally_separated_space (has_nndist (ring (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_144839 (h0 : not (topological_space (semi_normed_comm_ring to_additive.value_type) -> false)) : @path_connected_space.{0} (semi_normed_comm_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_comm_ring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_144840 (h0 : preorder (normed_comm_ring unsigned) -> preorder (normed_comm_ring unsigned) -> Prop) : is_equiv (preorder (normed_comm_ring unsigned)) h0 := sorry --non-trivial
lemma new_lemma_144841 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_144842 (h0 : ring (comm_ring (comm_ring (random_gen reducibility_hints)))) : rank_condition (comm_ring (comm_ring (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_144843 (h0 : function.extfun Type (functor.add_const (uniform_space (ordered_ring num)))) : @separated_space.{0} (ordered_ring.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_ring.{0} num)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (ordered_ring.{0} num))) h0 num))  := sorry --non-trivial
lemma new_lemma_144844 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (@id.{2} Type to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_144845 (h0 : has_mem.mem (with_one fun_info) has_emptyc.emptyc) : @is_atomistic.{0} (with_one.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_one.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_144846 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (complete_distrib_lattice name)) := sorry --non-trivial
lemma new_lemma_144847 (h0 : topological_space (has_inter (option unsigned))) : preirreducible_space (has_inter (option unsigned)) := sorry --non-trivial
lemma new_lemma_144848 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (has_pos_part.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_144849 (h0 : functor.add_const (functor.add_const (cancel_comm_monoid_with_zero pos) Type) linarith.comp) : @unique_factorization_monoid.{0} pos (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} pos) Type (@functor.add_const.run.{0 0} (functor.add_const.{0 1} (cancel_comm_monoid_with_zero.{0} pos) Type) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_144850 (h0 : topological_space (has_add (has_add real))) : t0_space (has_add (has_add real)) := sorry --non-trivial
lemma new_lemma_144851 (h0 : functor.add_const Prop (semiring linarith.comp)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_144852 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) Type) : @totally_separated_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_144853 (h0 : uniform_space (linear_ordered_field (option pos))) : complete_space (linear_ordered_field (option pos)) := sorry --non-trivial
lemma new_lemma_144854 (h1 : topological_space (id (with_bot to_additive.value_type))) : t0_space (id (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_144855 (h0 : functor.add_const (group (semiring num)) num) : @normalizer_condition.{0} (semiring.{0} num) (@functor.add_const.run.{0 0} (group.{0} (semiring.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_144856 (h0 : functor.add_const (topological_space (has_pos_part pos)) linarith.comp) : @irreducible_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_144857 (h0 : add_monoid (monoid num)) : add_monoid.fg (monoid num) := sorry --non-trivial
lemma new_lemma_144858 (h0 : topological_space (nondiscrete_normed_field linarith.ineq)) (h1 : set (nondiscrete_normed_field linarith.ineq)) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_144859 (h0 : complete_lattice (ordered_ring (semiring (semiring congr_arg_kind)))) : complete_lattice.is_Sup_finite_compact (ordered_ring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_144860 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_144861 (h0 : functor.add_const (group (generalized_boolean_algebra name)) pos) : @is_simple_group.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (group.{0} (generalized_boolean_algebra.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_144862 (h0 : functor.add_const (group (has_nndist linarith.comp)) linarith.comp) : @normalizer_condition.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_144863 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_disconnected_space.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_144864 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_neg.{0} empty))  := sorry --non-trivial
lemma new_lemma_144865 (h2 : function.extfun Type ring) : @rank_condition.{0} (has_top.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} h2 (has_top.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_144866 (h0 : complete_lattice (ring (option empty))) : complete_lattice.is_Sup_finite_compact (ring (option empty)) := sorry --non-trivial
lemma new_lemma_144867 (h0 : add_group (random_gen (random_gen linarith.ineq))) : is_add_cyclic (random_gen (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_144868 (h0 : cancel_comm_monoid_with_zero (comm_group (has_add Type))) : unique_factorization_monoid (comm_group (has_add Type)) := sorry --non-trivial
lemma new_lemma_144869 (h0 : functor.add_const (uniform_space (semigroup name)) environment.implicit_infer_kind) : @separated_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_144870 (h0 : function.extfun (Type 1) ring) : @strong_rank_condition.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_144871 (h0 : topological_space (add_cancel_monoid (ring (ordered_ring Type)))) : t1_space (add_cancel_monoid (ring (ordered_ring Type))) := sorry --non-trivial
lemma new_lemma_144872 (h0 : functor.add_const (ordered_add_comm_monoid (has_zero pos)) environment.implicit_infer_kind) : @archimedean.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_zero.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_144873 (h0 : functor.add_const (group (has_zero pos)) (ring environment.implicit_infer_kind)) : @is_cyclic.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} pos)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_144874 (h0 : add_monoid (generalized_boolean_algebra (ordered_comm_monoid real))) : add_monoid.fg (generalized_boolean_algebra (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_144875 (h0 : topological_space (has_nndist (finset pos))) : t0_space (has_nndist (finset pos)) := sorry --non-trivial
lemma new_lemma_144876 (h0 : function.extfun Type ring) : @is_domain.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_144877 (h0 : topological_space (linear_ordered_cancel_comm_monoid empty)) : t0_space (linear_ordered_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_144878 (h0 : ordered_add_comm_monoid (cancel_monoid (mul_zero_class pos))) : archimedean (cancel_monoid (mul_zero_class pos)) := sorry --non-trivial
lemma new_lemma_144879 (h0 : complete_lattice (normed_linear_ordered_group unsigned)) : is_compactly_generated (normed_linear_ordered_group unsigned) := sorry --non-trivial
lemma new_lemma_144880 (h0 : functor.add_const (group (comm_monoid congr_arg_kind)) empty) : @normalizer_condition.{0} (comm_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (comm_monoid.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_144881 (h0 : group (has_zero ennreal)) : is_cyclic (has_zero ennreal) := sorry --non-trivial
lemma new_lemma_144882 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system num)) (semiring (semiring num))) : @path_connected_space.{0} (measurable_space.dynkin_system.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} num)) (semiring.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_144883 (h0 : ring (distrib_lattice (random_gen char))) : is_domain (distrib_lattice (random_gen char)) := sorry --non-trivial
lemma new_lemma_144884 (h0 : functor.add_const (list (has_zero pos)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_144885 (h0 : functor.add_const (function.extfun (Type 1) list) (has_pos_part linarith.comp)) : list.nodup (function.extfun_app (functor.add_const.run h0) (ring Type)) := sorry --non-trivial
lemma new_lemma_144886 (h0 : topological_space (with_zero (has_nnnorm linarith.comp_source))) : t0_space (with_zero (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_144887 (h0 : complete_lattice (has_top empty)) : is_compactly_generated (has_top empty) := sorry --non-trivial
lemma new_lemma_144888 (h0 : not (has_mem.mem (with_one congr_arg_kind) has_emptyc.emptyc -> false)) : @irreducible_space.{0} (with_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} congr_arg_kind) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} congr_arg_kind) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_144889 (h0 : not (complete_lattice (normed_group (has_top fun_info)) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} (has_top.{0} fun_info)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_group.{0} (has_top.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_144890 (h0 : ring (boolean_algebra (has_nndist name))) : is_principal_ideal_ring (boolean_algebra (has_nndist name)) := sorry --non-trivial
lemma new_lemma_144891 (h0 : semiring (option (semiring num))) : is_noetherian_ring (option (semiring num)) := sorry --non-trivial
lemma new_lemma_144892 (h0 : not (add_group (distrib linarith.comp_source) -> false)) : @is_add_cyclic.{0} (distrib.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (add_group.{0} (distrib.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_144893 (h0 : functor.add_const (complete_lattice (has_norm congr_arg_kind)) fun_info) : @is_atomistic.{0} (has_norm.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_norm.{0} congr_arg_kind)) fun_info h0)  := sorry --non-trivial
lemma new_lemma_144894 (h0 : topological_space (simple_graph Type)) : t0_space (simple_graph Type) := sorry --non-trivial
lemma new_lemma_144895 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_144896 (h0 : group (distrib_lattice (has_nnnorm fun_info))) : is_cyclic (distrib_lattice (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_144897 (h0 : topological_space (has_add pos)) : path_connected_space (has_add pos) := sorry --non-trivial
lemma new_lemma_144898 (h0 : topological_space (normed_comm_ring (finset ennreal))) : preirreducible_space (normed_comm_ring (finset ennreal)) := sorry --non-trivial
lemma new_lemma_144899 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_144900 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_144901 (h0 : topological_space (ordered_comm_monoid (has_neg (has_neg (has_neg (has_neg name)))))) : sequential_space (ordered_comm_monoid (has_neg (has_neg (has_neg (has_neg name))))) := sorry --non-trivial
lemma new_lemma_144902 (h0 : functor.add_const (function.extfun Type topological_space) unsigned) : @sequential_space.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) unsigned h0) (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_144903 (h4 : not (ring (uniform_space char) -> false)) : @rank_condition.{0} (uniform_space.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (uniform_space.{0} char)) h4)  := sorry --non-trivial
lemma new_lemma_144904 (h0 : ring (has_zero (ring pos))) : is_principal_ideal_ring (has_zero (ring pos)) := sorry --non-trivial
lemma new_lemma_144905 (h0 : function.extfun (Type 1) ring) : @strong_rank_condition.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_144906 (h1 : not (ring (has_emptyc linarith.comp_source) -> false)) : @rank_condition.{0} (has_emptyc.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (has_emptyc.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_144907 (h0 : topological_space (finset environment.implicit_infer_kind)) : totally_separated_space (finset environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_144908 (h0 : uniform_space (non_assoc_semiring (semiring num))) : separated_space (non_assoc_semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_144909 (h0 : not (uniform_space (encodable to_additive.value_type) -> false)) : @complete_space.{0} (encodable.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (uniform_space.{0} (encodable.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_144910 (h0 : topological_space reducibility_hints) : t0_space reducibility_hints := sorry --non-trivial
lemma new_lemma_144911 (h0 : topological_space (add_left_cancel_semigroup empty)) : totally_disconnected_space (add_left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_144912 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_144913 (h0 : ring (has_top (has_norm num))) : rank_condition (has_top (has_norm num)) := sorry --non-trivial
lemma new_lemma_144914 (h0 : complete_lattice (has_nndist (option (option ennreal)))) : is_atomistic (has_nndist (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_144915 (h0 : ring (random_gen fun_info)) : is_domain (random_gen fun_info) := sorry --non-trivial
lemma new_lemma_144916 (h0 : ring (simple_graph (finset pos))) : is_domain (simple_graph (finset pos)) := sorry --non-trivial
lemma new_lemma_144917 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_144918 (h0 : topological_space (add_left_cancel_monoid (random_gen to_additive.value_type))) : totally_disconnected_space (add_left_cancel_monoid (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_144919 (h0 : complete_lattice (normed_comm_ring (comm_group Type))) : is_compactly_generated (normed_comm_ring (comm_group Type)) := sorry --non-trivial
lemma new_lemma_144920 (h0 : list (has_ssubset (with_one string_imp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_144921 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_144922 (h0 : functor.add_const (topological_space (finset linarith.comp)) pos) : @t0_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_144923 (h0 : topological_space (add_comm_monoid (has_neg environment.implicit_infer_kind))) : preconnected_space (add_comm_monoid (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_144924 (h1 : has_lt (normed_field environment.projection_info)) : no_max_order (normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_144925 (h0 : functor.add_const (group (comm_group Type)) environment.implicit_infer_kind) : @is_cyclic.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (comm_group.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_144926 (h0 : topological_space (add_cancel_monoid ennreal)) : irreducible_space (add_cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_144927 (h0 : finset (has_nndist (has_Inf (has_add (has_pos_part Type))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_144928 (h0 : has_mem.mem (normed_group num) has_emptyc.emptyc) : @complete_space.{0} (normed_group.{0} num) (@finset.pi.empty.{1 0} Type uniform_space.{0} (normed_group.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_144929 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_144930 (h1 : add_group (with_bot (with_bot (with_bot (random_gen (with_bot string_imp)))))) : is_add_cyclic (with_bot (with_bot (with_bot (random_gen (with_bot string_imp))))) := sorry --non-trivial
lemma new_lemma_144931 (h0 : function.extfun Type group) : @group.fg.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_144932 (h0 : function.extfun Type (functor.add_const (topological_space (comm_monoid unsigned)))) : @normal_space.{0} (comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_monoid.{0} unsigned)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (comm_monoid.{0} unsigned))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_144933 (h0 : fin has_zero.zero) : @t0_space.{0} (has_Inf.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_Inf.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_144934 (h0 : not (filter (ordered_comm_ring fun_info) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_144935 (h0 : topological_space (has_add (measurable_space (has_neg linarith.comp)))) : totally_separated_space (has_add (measurable_space (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_144936 (h0 : monoid (ordered_ring num)) : monoid.fg (ordered_ring num) := sorry --non-trivial
lemma new_lemma_144937 (h0 h1 : multiset (simple_graph linarith.ineq)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_144938 (h0 : not (semiring (has_union unsigned) -> false)) : @is_noetherian_ring.{0} (has_union.{0} unsigned) (@classical.by_contradiction'.{1} (semiring.{0} (has_union.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_144939 (h0 : list (has_edist (option empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_144940 (h0 : topological_space (encodable (random_gen linarith.comp_source))) : t0_space (encodable (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_144941 (h0 : group (complete_linear_order congr_arg_kind)) : normalizer_condition (complete_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_144942 (h0 : function.extfun Type (functor.add_const (topological_space (left_cancel_monoid congr_arg_kind)))) : @t1_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} congr_arg_kind)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (left_cancel_monoid.{0} congr_arg_kind))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_144943 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot num))) : @is_domain.{0} (with_bot.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (with_bot.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_144944 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_144945 (h0 : uniform_space (has_zero (has_to_string (boolean_algebra linarith.comp)))) : separated_space (has_zero (has_to_string (boolean_algebra linarith.comp))) := sorry --non-trivial
lemma new_lemma_144946 (h0 : functor.add_const (ring (generalized_boolean_algebra pos)) pos) : @strong_rank_condition.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (generalized_boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_144947 (h1 : topological_space (has_add linarith.ineq)) : t0_space (has_add linarith.ineq) := sorry --non-trivial
lemma new_lemma_144948 (h0 : topological_space (comm_group linarith.comp)) : regular_space (comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_144949 (h0 : functor.add_const (finset (has_add pos)) (ordered_ring pos)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_144950 (h0 : list (linear_ordered_field congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_144951 (h0 : not (topological_space (has_top empty) -> false)) : @irreducible_space.{0} (has_top.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_144952 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} h0 (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_144953 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @strong_rank_condition.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_144954 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_144955 (h1 : list (has_emptyc linarith.ineq)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_144956 (h0 : uniform_space (normed_lattice_add_comm_group (has_add (has_add (has_Inf (has_add pos)))))) : separated_space (normed_lattice_add_comm_group (has_add (has_add (has_Inf (has_add pos))))) := sorry --non-trivial
lemma new_lemma_144957 (h1 : set (fun_info -> add_comm_semigroup char)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_144958 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_144959 (h0 : ring (complete_distrib_lattice (has_Inf pos))) : rank_condition (complete_distrib_lattice (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_144960 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_144961 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf Type))) : topological_space.separable_space (canonically_linear_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_144962 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) environment.implicit_infer_kind) : @totally_separated_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_144963 (h0 : not (add_group (has_top unsigned) -> false)) : @is_add_cyclic.{0} (has_top.{0} unsigned) (@classical.by_contradiction'.{1} (add_group.{0} (has_top.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_144964 (h0 : uniform_space (canonically_ordered_monoid (has_bot real))) : complete_space (canonically_ordered_monoid (has_bot real)) := sorry --non-trivial
lemma new_lemma_144965 (h0 : ordered_add_comm_monoid (ring (has_neg name))) : archimedean (ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_144966 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (semi_normed_comm_ring.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (semi_normed_comm_ring.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_144967 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_zero ennreal)) := sorry --non-trivial
lemma new_lemma_144968 (h0 : functor.add_const (function.extfun (Type 1) semiring) pos) : @is_noetherian_ring.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) semiring.{1}) pos h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_144969 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (cancel_monoid.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type ring.{0} h0 (cancel_monoid.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_144970 (h0 : add_monoid (metric_space empty)) (h1 : topological_space (add_units (metric_space empty))) : preirreducible_space (add_units (metric_space empty)) := sorry --non-trivial
lemma new_lemma_144971 (h1 : function.extfun Type group) : @normalizer_condition.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h1 (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_144972 (h0 : functor.add_const (topological_space (partial_order empty)) empty) : @normal_space.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_144973 (h0 : topological_space (sub_neg_monoid (has_Inf linarith.comp))) : totally_disconnected_space (sub_neg_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_144974 (h0 : list (linear_ordered_add_comm_group (dlist to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_144975 (h0 : not (uniform_space (boolean_algebra.core num) -> false)) : @complete_space.{0} (boolean_algebra.core.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (boolean_algebra.core.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_144976 (h0 : ring (semi_normed_comm_ring (has_ssubset fun_info))) : rank_condition (semi_normed_comm_ring (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_144977 (h0 : topological_space (semigroup (semigroup Type))) : totally_disconnected_space (semigroup (semigroup Type)) := sorry --non-trivial
lemma new_lemma_144978 (h0 : ring (linear_ordered_comm_ring (semiring num))) : strong_rank_condition (linear_ordered_comm_ring (semiring num)) := sorry --non-trivial
lemma new_lemma_144979 (h0 : fin has_zero.zero) : @rank_condition.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_144980 (h0 : topological_space (normed_comm_ring (boolean_algebra.core environment.implicit_infer_kind))) : normal_space (normed_comm_ring (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_144981 (h0 : function.extfun Type measurable_space) (h1 : has_div (measure_theory.measure_space unsigned)) : @has_measurable_div₂.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type measurable_space.{0} h0 (measure_theory.measure_space.{0} unsigned)) h1  := sorry --non-trivial
lemma new_lemma_144982 (h0 : ring (distrib_lattice (has_nnnorm fun_info))) : is_domain (distrib_lattice (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_144983 (h0 : ring (canonically_ordered_comm_semiring Type)) : strong_rank_condition (canonically_ordered_comm_semiring Type) := sorry --non-trivial
lemma new_lemma_144984 (h0 : functor.add_const (functor.add_const (topological_space pos) Type) pos) : @t0_space.{0} pos (@functor.add_const.run.{0 1} (topological_space.{0} pos) Type (@functor.add_const.run.{0 0} (functor.add_const.{0 1} (topological_space.{0} pos) Type) pos h0))  := sorry --non-trivial
lemma new_lemma_144985 (h0 : uniform_space (nondiscrete_normed_field (normed_field (normed_field (normed_field linarith.ineq))))) : complete_space (nondiscrete_normed_field (normed_field (normed_field (normed_field linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_144986 (h0 : ring (canonically_linear_ordered_monoid (comm_semigroup name))) : strong_rank_condition (canonically_linear_ordered_monoid (comm_semigroup name)) := sorry --non-trivial
lemma new_lemma_144987 (h0 : list (has_norm linarith.comp_source)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_144988 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : id_rel (function.extfun_app (function.extfun_app h0 (prod (has_inter ennreal))) (has_inter ennreal)) := sorry --non-trivial
lemma new_lemma_144989 (h1 : not (ring (has_append char) -> false)) : @strong_rank_condition.{0} (has_append.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (has_append.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_144990 (h0 : topological_space (has_add (has_Inf pos))) : topological_space.separable_space (has_add (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_144991 (h0 : fin has_zero.zero) : matrix.vec_empty (id (id (id h0))) := sorry --non-trivial
lemma new_lemma_144992 (h0 : topological_space (add_cancel_monoid (has_add (has_add Type)))) : preirreducible_space (add_cancel_monoid (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_144993 (h0 : add_monoid (with_one (has_norm empty))) : add_monoid.fg (with_one (has_norm empty)) := sorry --non-trivial
lemma new_lemma_144994 (h1 : option Type) (h2 : ring (option.get_or_else h1 char)) : strong_rank_condition (option.get_or_else h1 char) := sorry --non-trivial
lemma new_lemma_144995 (h0 : topological_space (has_neg_part environment.implicit_infer_kind)) : preirreducible_space (has_neg_part environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_144996 (h0 : list (lattice num)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_144997 (h0 : functor.add_const (add_monoid (ring Type)) (has_neg (has_neg Type))) : @add_monoid.fg.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (add_monoid.{1} (ring.{1} Type)) (has_neg.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_144998 (h0 : functor.add_const (uniform_space (ordered_comm_monoid linarith.comp)) (has_neg (has_neg Type))) : @complete_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (ordered_comm_monoid.{0} linarith.comp)) (has_neg.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_144999 (h0 : functor.add_const (ordered_comm_monoid (ring Type)) unsigned) : @has_exists_mul_of_le.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (ring.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_145000 (h0 : functor.add_const (functor.add_const (function.extfun Type ordered_comm_monoid) linarith.comp) linarith.comp) : @has_exists_mul_of_le.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) linarith.comp (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) linarith.comp) linarith.comp h0)) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_145001 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_145002 (h0 : functor.add_const (topological_space znum) unsigned) : @discrete_topology.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) unsigned h0)  := sorry --non-trivial
lemma new_lemma_145003 (h0 : functor.add_const (filter (normed_comm_ring Type)) (has_neg Type)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_145004 (h0 : function.extfun Type (functor.add_const (ring (has_Sup (option unsigned))))) : @rank_condition.{0} (has_Sup.{0} (option.{0} unsigned)) (@functor.add_const.run.{0 0} (ring.{0} (has_Sup.{0} (option.{0} unsigned))) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (has_Sup.{0} (option.{0} unsigned)))) h0 empty))  := sorry --non-trivial
lemma new_lemma_145005 (h0 : functor.add_const (complete_lattice (add_left_cancel_semigroup num)) congr_arg_kind) : @is_compactly_generated.{0} (add_left_cancel_semigroup.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_left_cancel_semigroup.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_145006 (h0 : topological_space (has_one congr_arg_kind)) : loc_path_connected_space (has_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_145007 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_145008 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_145009 (h0 : complete_lattice (has_compl (mul_one_class fun_info))) : complete_lattice.is_Sup_finite_compact (has_compl (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_145010 (h0 : function.extfun Type ring) : @rank_condition.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_145011 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (with_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_145012 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_neg_part.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_145013 (h0 : fin has_zero.zero) : @path_connected_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_145014 (h0 : not (topological_space num -> false)) : @path_connected_space.{0} num (@classical.by_contradiction'.{1} (topological_space.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_145015 (h0 : topological_space (complete_distrib_lattice Type)) : preirreducible_space (complete_distrib_lattice Type) := sorry --non-trivial
lemma new_lemma_145016 (h0 : functor.add_const (complete_lattice (boolean_algebra.core environment.implicit_infer_kind)) linarith.comp) : @is_atomistic.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_145017 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_145018 (h0 : add_monoid (linear_ordered_semiring (semiring (semiring empty)))) : add_monoid.fg (linear_ordered_semiring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_145019 (h0 : group (has_inter (has_to_string (has_to_string ennreal)))) : group.fg (has_inter (has_to_string (has_to_string ennreal))) := sorry --non-trivial
lemma new_lemma_145020 (h0 : std_gen -> topological_space (has_Sup string.iterator_imp)) (h1 : unit) (h2 : std_gen) : @totally_disconnected_space.{0} (has_Sup.{0} string.iterator_imp) (@matrix.row.{0 0} std_gen (topological_space.{0} (has_Sup.{0} string.iterator_imp)) h0 h1 h2)  := sorry --non-trivial
lemma new_lemma_145021 (h0 : topological_space (has_zero (option pos))) : normal_space (has_zero (option pos)) := sorry --non-trivial
lemma new_lemma_145022 (h0 : group (group_with_zero linarith.comp)) : group.fg (group_with_zero linarith.comp) := sorry --non-trivial
lemma new_lemma_145023 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_145024 (h0 : functor.add_const (function.extfun (Type 1) filter) environment.implicit_infer_kind) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (semigroup Type)) := sorry --non-trivial
lemma new_lemma_145025 (h0 : function.extfun Type (functor.comp topological_space cancel_monoid)) : @path_connected_space.{0} (cancel_monoid.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} cancel_monoid.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_145026 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (finset pos)) := sorry --non-trivial
lemma new_lemma_145027 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @topological_space.separable_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_145028 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) pos) : @path_connected_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_145029 (h0 : functor.add_const (monoid (has_nndist pos)) (has_neg linarith.comp)) : @monoid.fg.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (has_nndist.{0} pos)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_145030 (h0 : functor.add_const (ordered_add_comm_monoid (has_neg_part unsigned)) (boolean_algebra Type)) : @archimedean.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_neg_part.{0} unsigned)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_145031 (h0 : topological_space (sub_neg_monoid (sub_neg_monoid linarith.comp))) : normal_space (sub_neg_monoid (sub_neg_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_145032 (h0 : functor.add_const (filter (finset pos)) (has_pos_part pos)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_145033 (h0 : functor.add_const (add_group (generalized_boolean_algebra pos)) pos) : @is_add_cyclic.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (generalized_boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_145034 (h0 : not (topological_space (has_norm num) -> false)) : @totally_disconnected_space.{0} (has_norm.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_145035 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @normal_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_145036 (h0 : functor.add_const (group (add_comm_monoid pos)) Type) : @group.fg.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (add_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_145037 (h0 : functor.add_const (ring (ring pos)) Type) : @rank_condition.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_145038 (h0 : functor.add_const (uniform_space Type) (finset Type)) : @complete_space.{1} Type (@functor.add_const.run.{1 1} (uniform_space.{1} Type) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_145039 (h0 : topological_space (cancel_monoid (cancel_monoid (cancel_monoid environment.implicit_infer_kind)))) : preconnected_space (cancel_monoid (cancel_monoid (cancel_monoid environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_145040 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_145041 (h1 : ring (random_gen (metric_space (metric_space linarith.comp_source)))) : is_domain (random_gen (metric_space (metric_space linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_145042 (h0 : cancel_comm_monoid_with_zero (option empty)) : unique_factorization_monoid (option empty) := sorry --non-trivial
lemma new_lemma_145043 (h0 : functor.add_const (topological_space (comm_group pos)) Type) : @irreducible_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_145044 (h0 : add_group (random_gen (random_gen char))) : is_add_cyclic (random_gen (random_gen char)) := sorry --non-trivial
lemma new_lemma_145045 (h0 : not (complete_lattice (simple_graph reducibility_hints) -> false)) : @is_compactly_generated.{0} (simple_graph.{0} reducibility_hints) (@classical.by_contradiction'.{1} (complete_lattice.{0} (simple_graph.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_145046 (h0 : topological_space (has_bot name)) : totally_disconnected_space (has_bot name) := sorry --non-trivial
lemma new_lemma_145047 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc linarith.comp_source))) : @is_cyclic.{0} (has_emptyc.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type group.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_145048 (h0 : topological_space (has_nndist (option unsigned))) : discrete_topology (has_nndist (option unsigned)) := sorry --non-trivial
lemma new_lemma_145049 (h0 : monoid (complete_linear_order (has_top (has_top empty)))) : monoid.fg (complete_linear_order (has_top (has_top empty))) := sorry --non-trivial
lemma new_lemma_145050 (h1 : add_group (linear_ordered_comm_group_with_zero linarith.comp_source)) : is_add_cyclic (linear_ordered_comm_group_with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_145051 (h0 : topological_space (has_inter (option empty))) : preirreducible_space (has_inter (option empty)) := sorry --non-trivial
lemma new_lemma_145052 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @totally_separated_space.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_145053 (h1 : topological_space (comm_ring (random_gen (random_gen (random_gen (random_gen char)))))) : t0_space (comm_ring (random_gen (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_145054 (h0 : functor.add_const (topological_space (has_nndist pos)) (finset pos)) : @preirreducible_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_145055 (h0 : finset (complete_distrib_lattice num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_145056 (h0 : function.extfun (Type 1) uniform_space) : @separated_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_145057 (h0 : ring (has_append (has_ssubset char))) : strong_rank_condition (has_append (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_145058 (h0 : topological_space (partial_order (semiring num))) : irreducible_space (partial_order (semiring num)) := sorry --non-trivial
lemma new_lemma_145059 (h0 : functor.comp ring comm_group name) : @is_principal_ideal_ring.{0} (comm_group.{0} name) (@functor.comp.run.{0 0 0} ring.{0} comm_group.{0} name h0)  := sorry --non-trivial
lemma new_lemma_145060 (h0 : functor.add_const (finset (has_neg unsigned)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_145061 (h0 : function.extfun ((Type 1 -> Type 1) -> Type 2) (function.extfun (Type 1 -> Type 1))) : @is_cyclic.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) (@function.extfun_app.{4 3} ((Type 1 → Type 1) → Type 2) (function.extfun.{3 3} (Type 1 → Type 1)) h0 (function.extfun.{3 2} (Type 1))) group.{1}) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_145062 (h0 : add_monoid (normed_comm_ring (has_add (has_add pos)))) : add_monoid.fg (normed_comm_ring (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_145063 (h0 : list (has_neg (has_add (finset (finset linarith.comp))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_145064 (h0 : not (group (distrib_lattice (has_nnnorm linarith.comp_source)) -> false)) : @group.fg.{0} (distrib_lattice.{0} (has_nnnorm.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (group.{0} (distrib_lattice.{0} (has_nnnorm.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_145065 (h0 : ring (has_pos_part (has_neg (has_neg (has_Inf Type))))) : rank_condition (has_pos_part (has_neg (has_neg (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_145066 (h0 : monoid (comm_semigroup (has_Inf Type))) : monoid.fg (comm_semigroup (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_145067 (h0 : functor.add_const (ring (add_cancel_monoid pos)) Type) : @strong_rank_condition.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (add_cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_145068 (h0 : functor.add_const (topological_space (has_neg Type)) Type) : @totally_separated_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_neg.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_145069 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_145070 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system unsigned)) unsigned) : @discrete_topology.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_145071 (h0 : topological_space (add_cancel_monoid (option name))) : totally_separated_space (add_cancel_monoid (option name)) := sorry --non-trivial
lemma new_lemma_145072 (h0 : functor.add_const (complete_lattice (comm_group pos)) (finset linarith.comp)) : @complete_lattice.is_Sup_finite_compact.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} pos)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_145073 (h0 : filter (has_one (has_norm (has_top (has_norm num))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_145074 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen empty))) : @normal_space.{0} (random_gen.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_145075 (h0 : fin has_zero.zero) : @path_connected_space.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_145076 (h0 : group (comm_ring (denumerable linarith.ineq))) : is_cyclic (comm_ring (denumerable linarith.ineq)) := sorry --non-trivial
lemma new_lemma_145077 (h0 : functor.add_const (monoid (canonically_ordered_comm_semiring Type)) Type) : @monoid.fg.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 1} (monoid.{1} (canonically_ordered_comm_semiring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_145078 (h0 : filter (encodable (encodable char))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_145079 (h0 : topological_space (has_star (semiring (semiring empty)))) : totally_separated_space (has_star (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_145080 (h1 : complete_lattice (topological_space linarith.ineq)) : complete_lattice.is_Sup_finite_compact (topological_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_145081 (h0 : topological_space (canonically_ordered_monoid (has_Inf Type))) : preirreducible_space (canonically_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_145082 (h0 : add_group (complete_distrib_lattice (finset (finset (has_pos_part pos))))) : is_add_cyclic (complete_distrib_lattice (finset (finset (has_pos_part pos)))) := sorry --non-trivial
lemma new_lemma_145083 (h0 : group (comm_ring (has_top to_additive.value_type))) : is_cyclic (comm_ring (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_145084 (h0 : has_lt (simple_graph fun_info)) : no_max_order (simple_graph fun_info) := sorry --non-trivial
lemma new_lemma_145085 (h0 : functor.add_const (ring (finset pos)) Type) : @rank_condition.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (finset.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_145086 (h0 : ring (comm_group (has_nndist pos))) : strong_rank_condition (comm_group (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_145087 (h0 : filter (boolean_algebra (finset linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_145088 (h0 : function.extfun nat fin) : @is_add_cyclic.{0} (ordered_comm_ring.{0} linarith.comp) (@matrix.vec_empty.{0} (add_group.{0} (ordered_comm_ring.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_145089 (h0 : topological_space (complete_semilattice_Sup (has_norm fun_info))) : t0_space (complete_semilattice_Sup (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_145090 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_145091 (h0 : functor.add_const (complete_lattice (has_zero linarith.comp)) environment.implicit_infer_kind) : @is_atomistic.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_145092 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (complete_semilattice_Sup string_imp)) := sorry --non-trivial
lemma new_lemma_145093 (h0 : group (linear_ordered_field congr_arg_kind)) : normalizer_condition (linear_ordered_field congr_arg_kind) := sorry --non-trivial
lemma new_lemma_145094 (h0 : function.extfun nat fin) : @is_cyclic.{0} (canonically_ordered_monoid.{0} name) (@matrix.vec_empty.{0} (group.{0} (canonically_ordered_monoid.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_145095 (h1 : group (semi_normed_ring (has_nnnorm fun_info))) : is_cyclic (semi_normed_ring (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_145096 (h0 : add_monoid (complete_linear_order (has_top (semiring congr_arg_kind)))) : add_monoid.fg (complete_linear_order (has_top (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_145097 (h0 : functor.add_const (topological_space (mul_zero_class environment.implicit_infer_kind)) name) : @normal_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_145098 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_145099 (h1 : not (topological_space (semi_normed_comm_ring char) -> false)) : @t0_space.{0} (semi_normed_comm_ring.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_comm_ring.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_145100 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_145101 (h0 : group (has_nndist (option unsigned))) : is_cyclic (has_nndist (option unsigned)) := sorry --non-trivial
lemma new_lemma_145102 (h0 : cancel_comm_monoid_with_zero (has_sub (semiring (semiring (semiring empty))))) : unique_factorization_monoid (has_sub (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_145103 (h0 : group (with_bot (random_gen (random_gen fun_info)))) : is_cyclic (with_bot (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_145104 (h0 : topological_space (canonically_ordered_comm_semiring empty)) : discrete_topology (canonically_ordered_comm_semiring empty) := sorry --non-trivial
lemma new_lemma_145105 (h0 : topological_space (normed_group string_imp)) : path_connected_space (normed_group string_imp) := sorry --non-trivial
lemma new_lemma_145106 (h0 : filter (has_zero name)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_145107 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) name) : @totally_separated_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_145108 (h0 : filter (with_one (random_gen (random_gen (random_gen linarith.ineq))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_145109 (h0 : functor.add_const (group (mul_zero_class unsigned)) unsigned) : @group.fg.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (mul_zero_class.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_145110 (h0 : uniform_space (has_add (comm_ring string_imp))) : complete_space (has_add (comm_ring string_imp)) := sorry --non-trivial
lemma new_lemma_145111 (h0 : complete_lattice (has_norm linarith.comp)) : complete_lattice.is_Sup_finite_compact (has_norm linarith.comp) := sorry --non-trivial
lemma new_lemma_145112 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_145113 (h0 : ordered_add_comm_monoid (has_add (has_neg Type))) : archimedean (has_add (has_neg Type)) := sorry --non-trivial
lemma new_lemma_145114 (h0 : topological_space (has_Inf (sub_neg_monoid (has_Inf pos)))) : totally_separated_space (has_Inf (sub_neg_monoid (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_145115 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_145116 (h0 : cancel_comm_monoid_with_zero (has_Inf (ring (has_add Type)))) : unique_factorization_monoid (has_Inf (ring (has_add Type))) := sorry --non-trivial
lemma new_lemma_145117 (h0 : add_monoid (complete_distrib_lattice num)) : add_monoid.fg (complete_distrib_lattice num) := sorry --non-trivial
lemma new_lemma_145118 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_145119 (h0 : topological_space (has_top (random_gen (semiring congr_arg_kind)))) : path_connected_space (has_top (random_gen (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_145120 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_nndist name)) := sorry --non-trivial
lemma new_lemma_145121 (h0 : topological_space (complete_linear_order (semiring unsigned))) : totally_disconnected_space (complete_linear_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_145122 (h0 : ring (with_one (has_norm (has_norm unsigned)))) : rank_condition (with_one (has_norm (has_norm unsigned))) := sorry --non-trivial
lemma new_lemma_145123 (h0 : functor.add_const (complete_lattice (has_star congr_arg_kind)) unsigned) : @is_compactly_generated.{0} (has_star.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_star.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_145124 (h0 : group (boolean_algebra (finset (finset linarith.comp)))) : group.fg (boolean_algebra (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_145125 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_compl.{0} char) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_compl.{0} char))  := sorry --non-trivial
lemma new_lemma_145126 (h0 : functor.add_const (ordered_comm_monoid (has_add pos)) (ring (ring Type))) : @has_exists_mul_of_le.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (has_add.{0} pos)) (ring.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_145127 (h0 : uniform_space (ordered_comm_ring (has_Inf pos))) : complete_space (ordered_comm_ring (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_145128 (h0 : list (comm_ring (has_ssubset fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_145129 (h0 : functor.add_const (ring (ring pos)) (has_pos_part pos)) : @is_domain.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} pos)) (has_pos_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_145130 (h0 : functor.add_const (group (has_zero name)) (has_add pos)) : @normalizer_condition.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} name)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_145131 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (add_comm_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_145132 (h0 : list znum) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_145133 (h0 : has_mem.mem (complete_semilattice_Sup empty) has_emptyc.emptyc) : @is_domain.{0} (complete_semilattice_Sup.{0} empty) (@finset.pi.empty.{1 0} Type ring.{0} (complete_semilattice_Sup.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_145134 (h0 : complete_lattice (semi_normed_ring (mul_one_class linarith.ineq))) : is_compactly_generated (semi_normed_ring (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_145135 (h0 : topological_space (boolean_algebra (has_add (has_neg_part pos)))) : preirreducible_space (boolean_algebra (has_add (has_neg_part pos))) := sorry --non-trivial
lemma new_lemma_145136 (h0 : topological_space (semiring (has_norm fun_info))) : discrete_topology (semiring (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_145137 (h0 : topological_space (simple_graph linarith.comp)) : sequential_space (simple_graph linarith.comp) := sorry --non-trivial
lemma new_lemma_145138 (h0 : topological_space (has_neg environment.implicit_infer_kind)) : loc_path_connected_space (has_neg environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_145139 (h0 : fin has_zero.zero) : @topological_space.separable_space.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_145140 (h0 : functor.add_const (function.extfun (Type 1) ring) (has_neg environment.implicit_infer_kind)) : @strong_rank_condition.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) (has_neg.{0} environment.implicit_infer_kind) h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_145141 (h0 : ring (measurable_space.dynkin_system (semiring (has_norm unsigned)))) : is_domain (measurable_space.dynkin_system (semiring (has_norm unsigned))) := sorry --non-trivial
lemma new_lemma_145142 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (cancel_monoid.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_145143 (h0 : complete_lattice (has_to_string (finset environment.implicit_infer_kind))) : is_atomistic (has_to_string (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_145144 (h0 : topological_space (mul_one_class ereal)) : path_connected_space (mul_one_class ereal) := sorry --non-trivial
lemma new_lemma_145145 (h0 : topological_space (ordered_comm_monoid (ring (has_neg Type)))) : irreducible_space (ordered_comm_monoid (ring (has_neg Type))) := sorry --non-trivial
lemma new_lemma_145146 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (linear_ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (linear_ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_145147 (h0 : functor.add_const (ring (has_neg_part unsigned)) linarith.comp) : @strong_rank_condition.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_neg_part.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_145148 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_145149 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_145150 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_neg pos)) := sorry --non-trivial
lemma new_lemma_145151 (h0 : topological_space (partial_order (semiring (semiring congr_arg_kind)))) : irreducible_space (partial_order (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_145152 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_145153 (h0 : uniform_space (add_cancel_monoid (has_add (has_neg_part Type)))) : separated_space (add_cancel_monoid (has_add (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_145154 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (linear_ordered_field ennreal)) := sorry --non-trivial
lemma new_lemma_145155 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (filter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (filter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_145156 (h0 : not (uniform_space (metric_space congr_arg_kind) -> false)) : @complete_space.{0} (metric_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (metric_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_145157 (h0 : uniform_space (comm_monoid empty)) : separated_space (comm_monoid empty) := sorry --non-trivial
lemma new_lemma_145158 (h0 : functor.add_const (ring (left_cancel_monoid num)) empty) : @rank_condition.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_145159 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (semi_normed_comm_ring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (semi_normed_comm_ring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_145160 (h0 : topological_space (has_dist congr_arg_kind)) : discrete_topology (has_dist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_145161 (h0 : functor.add_const (function.extfun (Type 1) group) name) : @is_cyclic.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) name h0) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_145162 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} empty (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) empty)  := sorry --non-trivial
lemma new_lemma_145163 (h0 : topological_space (has_nnnorm (comm_ring (has_compl reducibility_hints)))) : t0_space (has_nnnorm (comm_ring (has_compl reducibility_hints))) := sorry --non-trivial
lemma new_lemma_145164 (h0 : complete_lattice (metric_space linarith.comp)) : is_atomistic (metric_space linarith.comp) := sorry --non-trivial
lemma new_lemma_145165 (h0 : ring (has_pos_part (ordered_comm_ring Type))) : is_principal_ideal_ring (has_pos_part (ordered_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_145166 (h0 : topological_space (distrib_lattice (random_gen (has_nnnorm linarith.comp_source)))) : irreducible_space (distrib_lattice (random_gen (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_145167 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_145168 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_Sup unsigned)) := sorry --non-trivial
lemma new_lemma_145169 (h0 : complete_lattice (random_gen (has_ssubset char))) : is_compactly_generated (random_gen (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_145170 (h0 : topological_space (random_gen fun_info)) : totally_disconnected_space (random_gen fun_info) := sorry --non-trivial
lemma new_lemma_145171 (h0 : has_mem.mem (id congr_arg_kind) has_emptyc.emptyc) : @locally_compact_space.{0} (@id.{2} Type congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (@id.{2} Type congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_145172 (h0 : uniform_space (measurable_space (with_bot linarith.comp_source))) : complete_space (measurable_space (with_bot linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_145173 (h0 : functor.add_const (complete_lattice (normed_comm_ring Type)) Type) : @is_atomistic.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (normed_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_145174 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) (has_add name)) : @topological_space.separable_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_145175 (h0 : filter (canonically_ordered_add_monoid (option empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_145176 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_145177 (h0 : functor.add_const (ring (has_nndist linarith.comp)) pos) : @strong_rank_condition.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_145178 (h0 : functor.add_const (function.extfun Type filter) pos) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_145179 (h0 : functor.add_const (topological_space (preorder empty)) num) : @irreducible_space.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_145180 (h0 : functor.add_const (complete_lattice (has_nndist pos)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_145181 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (linear_order unsigned)) := sorry --non-trivial
lemma new_lemma_145182 (h0 : not (ring (add_monoid fun_info) -> false)) : @is_domain.{0} (add_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (add_monoid.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_145183 (h0 : functor.add_const (monoid (has_neg linarith.comp)) Type) : @monoid.fg.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (monoid.{0} (has_neg.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_145184 (h0 : functor.add_const (add_group (generalized_boolean_algebra Type)) (has_add linarith.comp)) : @is_add_cyclic.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (generalized_boolean_algebra.{1} Type)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_145185 (h0 : topological_space (comm_group (canonically_ordered_comm_semiring ennreal))) : loc_path_connected_space (comm_group (canonically_ordered_comm_semiring ennreal)) := sorry --non-trivial
lemma new_lemma_145186 (h0 : filter (distrib_lattice (has_nnnorm to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_145187 (h0 : functor.add_const (group (normed_comm_ring name)) linarith.comp) : @is_cyclic.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_145188 (h0 : topological_space (has_zero linarith.comp)) : totally_disconnected_space (has_zero linarith.comp) := sorry --non-trivial
lemma new_lemma_145189 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (simple_graph unsigned)) := sorry --non-trivial
lemma new_lemma_145190 (h0 : complete_lattice (comm_group (option (option ennreal)))) : is_compactly_generated (comm_group (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_145191 (h0 : topological_space (semiring unsigned)) : topological_space.separable_space (semiring unsigned) := sorry --non-trivial
lemma new_lemma_145192 (h0 : ring (with_one unsigned)) : strong_rank_condition (with_one unsigned) := sorry --non-trivial
lemma new_lemma_145193 (h0 : uniform_space (mul_one_class (mul_one_class (mul_one_class reducibility_hints)))) : complete_space (mul_one_class (mul_one_class (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_145194 (h1 : has_mem.mem linarith.comp_source has_emptyc.emptyc) : @irreducible_space.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type topological_space.{0} linarith.comp_source h1)  := sorry --non-trivial
lemma new_lemma_145195 (h0 : functor.add_const (add_group (finset name)) (has_add name)) : @is_add_cyclic.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (finset.{0} name)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_145196 (h0 : topological_space (has_add (has_neg_part pos))) : irreducible_space (has_add (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_145197 (h0 : functor.add_const (function.extfun Type complete_lattice) linarith.comp) : @is_compactly_generated.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) linarith.comp h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_145198 (h0 : functor.add_const (finset (left_cancel_monoid unsigned)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_145199 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_145200 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) name) : @totally_separated_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_145201 (h0 : topological_space (complete_semilattice_Sup congr_arg_kind)) : normal_space (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_145202 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (mul_zero_class.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (mul_zero_class.{0} empty))  := sorry --non-trivial
lemma new_lemma_145203 (h0 : functor.add_const (add_monoid (has_star congr_arg_kind)) congr_arg_kind) : @add_monoid.fg.{0} (has_star.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_star.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_145204 (h0 : topological_space (has_append (has_nnnorm (mul_one_class (has_nnnorm fun_info))))) : t0_space (has_append (has_nnnorm (mul_one_class (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_145205 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (normed_linear_ordered_group.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_linear_ordered_group.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_145206 (h0 : uniform_space (semigroup pos)) : complete_space (semigroup pos) := sorry --non-trivial
lemma new_lemma_145207 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_145208 (h0 : ring (has_star (semiring (semiring congr_arg_kind)))) : is_domain (has_star (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_145209 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_145210 (h0 : semiring (option (has_top empty))) : is_noetherian_ring (option (has_top empty)) := sorry --non-trivial
lemma new_lemma_145211 (h0 : not (uniform_space (complete_linear_order empty) -> false)) : @separated_space.{0} (complete_linear_order.{0} empty) (@classical.by_contradiction'.{1} (uniform_space.{0} (complete_linear_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_145212 (h0 : topological_space (encodable (random_gen linarith.ineq))) : locally_compact_space (encodable (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_145213 (h1 : topological_space (measurable_space linarith.comp)) : locally_compact_space (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_145214 (h0 : not (complete_lattice (has_div char) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_div.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_div.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_145215 (h0 : not (topological_space (add_right_cancel_monoid num) -> false)) : @topological_space.separable_space.{0} (add_right_cancel_monoid.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (add_right_cancel_monoid.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_145216 (h0 : functor.add_const (topological_space (cancel_monoid Type)) Type) : @preconnected_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_145217 (h0 : group (has_norm (random_gen (random_gen linarith.comp)))) : normalizer_condition (has_norm (random_gen (random_gen linarith.comp))) := sorry --non-trivial
lemma new_lemma_145218 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (fintype.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (fintype.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_145219 (h0 : functor.add_const (topological_space (sub_neg_monoid name)) real) : @t0_space.{0} (sub_neg_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} name)) real h0)  := sorry --non-trivial
lemma new_lemma_145220 (h0 : function.extfun (Type 1) topological_space) : @t0_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_145221 (h0 : semiring (canonically_ordered_monoid (has_Inf (has_bot linarith.comp)))) : is_noetherian_ring (canonically_ordered_monoid (has_Inf (has_bot linarith.comp))) := sorry --non-trivial
lemma new_lemma_145222 (h0 : topological_space (distrib (random_gen reducibility_hints))) : totally_disconnected_space (distrib (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_145223 (h0 : topological_space (boolean_algebra.core (has_add unsigned))) : loc_path_connected_space (boolean_algebra.core (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_145224 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @multiset.inf.{0} Prop (@lattice.to_semilattice_inf.{0} Prop (@conditionally_complete_lattice.to_lattice.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice))) (@bounded_order.to_order_top.{0} Prop (@preorder.to_has_le.{0} Prop (@partial_order.to_preorder.{0} Prop (@semilattice_inf.to_partial_order.{0} Prop (@lattice.to_semilattice_inf.{0} Prop (@conditionally_complete_lattice.to_lattice.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)))))) Prop.bounded_order) (@function.extfun_app.{2 1} Type multiset.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 multiset.{0}) Prop)  := sorry --non-trivial
lemma new_lemma_145225 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) name) : @loc_path_connected_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_145226 (h0 : topological_space (plift empty)) : loc_path_connected_space (plift empty) := sorry --non-trivial
lemma new_lemma_145227 (h0 : group (as_linear_order (option (option empty)))) : normalizer_condition (as_linear_order (option (option empty))) := sorry --non-trivial
lemma new_lemma_145228 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_inv.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (has_inv.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_145229 (h0 : ring (add_group (has_top (has_norm (semiring linarith.comp))))) : strong_rank_condition (add_group (has_top (has_norm (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_145230 (h0 : topological_space (semigroup (has_add (has_add unsigned)))) : t1_space (semigroup (has_add (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_145231 (h0 : uniform_space (mul_zero_class (has_nndist Type))) : complete_space (mul_zero_class (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_145232 (h0 : functor.add_const (ring (generalized_boolean_algebra pos)) Type) : @is_domain.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (generalized_boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_145233 (h0 : add_group (complete_semilattice_Sup (comm_ring (has_norm (random_gen real))))) : is_add_cyclic (complete_semilattice_Sup (comm_ring (has_norm (random_gen real)))) := sorry --non-trivial
lemma new_lemma_145234 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (sub_neg_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_145235 (h0 : functor.add_const (topological_space (canonically_ordered_monoid pos)) name) : @loc_path_connected_space.{0} (canonically_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_145236 (h0 : filter (non_assoc_semiring (semiring (semiring (semiring empty))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_145237 (h0 : ring (complete_linear_order (semiring congr_arg_kind))) : strong_rank_condition (complete_linear_order (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_145238 (h1 : topological_space (comm_ring to_additive.value_type)) : totally_disconnected_space (comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_145239 (h0 : semiring (canonically_ordered_comm_semiring (has_zero (has_to_string name)))) : is_noetherian_ring (canonically_ordered_comm_semiring (has_zero (has_to_string name))) := sorry --non-trivial
lemma new_lemma_145240 (h0 : topological_space (canonically_ordered_monoid pos)) : t0_space (canonically_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_145241 (h0 : cancel_comm_monoid_with_zero (monoid_with_zero (option ennreal))) : unique_factorization_monoid (monoid_with_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_145242 (h0 : fin has_zero.zero) : @preirreducible_space.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (sub_neg_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_145243 (h1 : add_group enat) : is_add_cyclic enat := sorry --non-trivial
lemma new_lemma_145244 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_145245 (h0 : group (ordered_cancel_add_comm_monoid (has_to_string pos))) : group.fg (ordered_cancel_add_comm_monoid (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_145246 (h0 : has_mem.mem (measurable_space unsigned) has_emptyc.emptyc) : @discrete_topology.{0} (measurable_space.{0} unsigned) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_145247 (h2 : topological_space ordering) : totally_disconnected_space ordering := sorry --non-trivial
lemma new_lemma_145248 (h0 : complete_lattice (linear_ordered_semiring (semiring (semiring linarith.comp)))) : is_compactly_generated (linear_ordered_semiring (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_145249 (h0 : list (semigroup (finset pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_145250 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) linarith.comp) : @locally_compact_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_145251 (h4 : set (ereal -> char)) : set.separates_points h4 := sorry --non-trivial
lemma new_lemma_145252 (h0 : functor.add_const (add_group (has_bot pos)) (has_neg name)) : @is_add_cyclic.{0} (has_bot.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_bot.{0} pos)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_145253 (h0 : ring (complete_semilattice_Sup (has_top (has_top linarith.comp_source)))) : is_domain (complete_semilattice_Sup (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_145254 (h1 : topological_space char) (h2 : set (set char)) : topological_space.is_topological_basis h2 := sorry --non-trivial
lemma new_lemma_145255 (h0 : group (add_cancel_monoid (normed_comm_ring Type))) : is_simple_group (add_cancel_monoid (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_145256 : nonempty (normed_linear_ordered_field ereal) := sorry --non-trivial
lemma new_lemma_145257 (h0 : functor.add_const (topological_space (measure_theory.measure_space empty)) empty) : @totally_separated_space.{0} (measure_theory.measure_space.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (measure_theory.measure_space.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_145258 (h5 : set (add_comm_semigroup enat)) : set.finite h5 := sorry --non-trivial
lemma new_lemma_145259 (h0 : complete_lattice (normed_linear_ordered_group congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (normed_linear_ordered_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_145260 (h0 : group (linear_ordered_comm_ring empty)) : is_simple_group (linear_ordered_comm_ring empty) := sorry --non-trivial
lemma new_lemma_145261 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (dlist.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (dlist.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_145262 (h0 : group (has_Inf (has_add (has_Inf pos)))) : group.fg (has_Inf (has_add (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_145263 (h0 : finset (has_zero (has_to_string (has_to_string unsigned)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_145264 (h0 : functor.add_const (topological_space (add_comm_monoid environment.implicit_infer_kind)) name) : @loc_path_connected_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_145265 (h0 : not (group (linear_ordered_semiring linarith.comp_source) -> false)) : @is_cyclic.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_semiring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_145266 (h0 : functor.add_const (topological_space (mul_zero_class name)) name) : @topological_space.separable_space.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_145267 (h0 : group (canonically_linear_ordered_monoid Type)) : normalizer_condition (canonically_linear_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_145268 (h0 : group (random_gen (has_inv (random_gen fun_info)))) : is_cyclic (random_gen (has_inv (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_145269 (h0 : topological_space (sub_neg_monoid (has_Inf (has_Inf Type)))) : preirreducible_space (sub_neg_monoid (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_145270 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_145271 (h0 : add_group (has_top (semiring (semiring (semiring (semiring empty)))))) : is_add_cyclic (has_top (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_145272 (h0 : filter auto.case_option) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_145273 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_145274 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (has_pos_part.{0} (ring.{0} (ring.{0} linarith.comp))) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_pos_part.{0} (ring.{0} (ring.{0} linarith.comp)))) h0)  := sorry --non-trivial
lemma new_lemma_145275 (h0 : functor.add_const (topological_space (partial_order empty)) unsigned) : @t0_space.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_145276 (h0 : ordered_add_comm_monoid (semigroup (finset ennreal))) : archimedean (semigroup (finset ennreal)) := sorry --non-trivial
lemma new_lemma_145277 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_145278 (h0 : group (dlist (has_nnnorm char))) : group.fg (dlist (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_145279 (h0 : ring (has_nnnorm (mul_one_class ereal))) : is_domain (has_nnnorm (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_145280 (h0 : not (topological_space (add_cancel_monoid congr_arg_kind) -> false)) : @topological_space.separable_space.{0} (add_cancel_monoid.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (add_cancel_monoid.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_145281 (h0 : has_mem.mem (id (has_norm empty)) has_emptyc.emptyc) : @irreducible_space.{0} (@id.{2} Type (has_norm.{0} empty)) (@finset.pi.empty.{1 0} Type topological_space.{0} (@id.{2} Type (has_norm.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_145282 (h0 : functor.add_const (topological_space (has_neg name)) Type) : @t0_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_145283 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_145284 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) name) : @irreducible_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_145285 (h0 : list (has_ssubset string_imp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_145286 (h0 : group (denumerable (has_nnnorm (has_nnnorm linarith.comp_source)))) : is_cyclic (denumerable (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_145287 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @t1_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_145288 (h0 : complete_lattice (add_cancel_monoid (has_nndist linarith.comp))) : complete_lattice.is_Sup_finite_compact (add_cancel_monoid (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_145289 (h0 : topological_space (has_pos_part Type)) : t0_space (has_pos_part Type) := sorry --non-trivial
lemma new_lemma_145290 (h0 : ring (ordered_comm_ring (has_add (has_Inf (sub_neg_monoid (has_add real)))))) : rank_condition (ordered_comm_ring (has_add (has_Inf (sub_neg_monoid (has_add real))))) := sorry --non-trivial
lemma new_lemma_145291 (h0 : function.extfun Type multiset) : multiset.nodup (function.extfun_app h0 (normed_group congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_145292 (h0 : functor.add_const (add_monoid (comm_group unsigned)) (option pos)) : @add_monoid.fg.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (comm_group.{0} unsigned)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_145293 (h0 : topological_space (ordered_cancel_add_comm_monoid (option unsigned))) : preirreducible_space (ordered_cancel_add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_145294 (h0 : topological_space (random_gen (semiring (semiring congr_arg_kind)))) : discrete_topology (random_gen (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_145295 (h0 : functor.add_const (topological_space (cancel_monoid ennreal)) empty) : @locally_compact_space.{0} (cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} ennreal)) empty h0)  := sorry --non-trivial
lemma new_lemma_145296 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @t0_space.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_145297 (h0 : functor.add_const (topological_space (has_norm num)) empty) : @t0_space.{0} (has_norm.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_norm.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_145298 (h0 : functor.add_const (uniform_space (has_neg name)) (option Type)) : @separated_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_neg.{0} name)) (option.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_145299 (h0 : topological_space (add_cancel_monoid (semigroup (ring Type)))) : normal_space (add_cancel_monoid (semigroup (ring Type))) := sorry --non-trivial
lemma new_lemma_145300 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_bot.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_145301 (h0 : functor.add_const (add_group nnreal) (option unsigned)) : @is_add_cyclic.{0} nnreal (@functor.add_const.run.{0 0} (add_group.{0} nnreal) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_145302 (h0 : group (add_left_cancel_monoid linarith.comp_source)) : is_cyclic (add_left_cancel_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_145303 (h0 : topological_space (has_le (mul_one_class reducibility_hints))) : path_connected_space (has_le (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_145304 (h1 : complete_lattice (has_dist string.iterator_imp)) : complete_lattice.is_Sup_finite_compact (has_dist string.iterator_imp) := sorry --non-trivial
lemma new_lemma_145305 (h0 : topological_space (add_group (semiring unsigned))) : topological_space.separable_space (add_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_145306 (h0 : functor.add_const (monoid (has_neg Type)) (finset Type)) : @monoid.fg.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 1} (monoid.{1} (has_neg.{1} Type)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_145307 (h0 h1 : multiset linarith.ineq) : multiset.le h0 h1 := sorry --non-trivial
lemma new_lemma_145308 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_145309 (h0 : topological_space (has_emptyc (random_gen linarith.comp_source))) : irreducible_space (has_emptyc (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_145310 (h0 : topological_space (linear_ordered_add_comm_group string_imp)) : t0_space (linear_ordered_add_comm_group string_imp) := sorry --non-trivial
lemma new_lemma_145311 (h0 : functor.add_const (list (has_to_string environment.implicit_infer_kind)) (has_neg (finset linarith.comp))) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_145312 (h0 : add_group (has_append (random_gen (random_gen (random_gen to_additive.value_type))))) : is_add_cyclic (has_append (random_gen (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_145313 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) environment.implicit_infer_kind) : @t1_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_145314 (h0 : ordered_comm_monoid (normed_comm_ring pos)) : has_exists_mul_of_le (normed_comm_ring pos) := sorry --non-trivial
lemma new_lemma_145315 (h0 : complete_lattice (div_inv_monoid (comm_ring string_imp))) : is_compactly_generated (div_inv_monoid (comm_ring string_imp)) := sorry --non-trivial
lemma new_lemma_145316 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_145317 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) Type) : @regular_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_145318 (h0 : functor.add_const (filter (boolean_algebra.core name)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_145319 (h0 : topological_space (cancel_monoid ennreal)) : irreducible_space (cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_145320 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_145321 (h0 : functor.comp topological_space finset ennreal) : @path_connected_space.{0} (finset.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_145322 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_145323 (h0 : mul_one_class reducibility_hints) (h1 : ring (monoid.End reducibility_hints)) : strong_rank_condition (monoid.End reducibility_hints) := sorry --non-trivial
lemma new_lemma_145324 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_145325 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @discrete_topology.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_add.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_145326 (h0 : ring (normed_lattice_add_comm_group pos)) : strong_rank_condition (normed_lattice_add_comm_group pos) := sorry --non-trivial
lemma new_lemma_145327 (h0 : monoid (ring name)) : monoid.fg (ring name) := sorry --non-trivial
lemma new_lemma_145328 (h0 : has_mem.mem (complete_semilattice_Sup linarith.ineq) has_emptyc.emptyc) : @path_connected_space.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_145329 (h0 : filter (generalized_boolean_algebra (comm_semigroup real))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_145330 (h0 : topological_space (has_norm (random_gen (random_gen (random_gen fun_info))))) : totally_separated_space (has_norm (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_145331 (h0 : functor.add_const (topological_space (option name)) pos) : @preirreducible_space.{0} (option.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_145332 (h1 : list (with_one fun_info)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_145333 (h0 : ring (add_comm_monoid (has_neg (finset (finset name))))) : is_principal_ideal_ring (add_comm_monoid (has_neg (finset (finset name)))) := sorry --non-trivial
lemma new_lemma_145334 (h0 : functor.add_const (topological_space (left_cancel_monoid empty)) congr_arg_kind) : @t1_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_145335 (h0 : function.extfun Type group) : @is_cyclic.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_145336 (h0 : functor.add_const (topological_space (has_zero unsigned)) (has_neg linarith.comp)) : @regular_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_145337 (h0 : function.extfun (Type 1) uniform_space) : @complete_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_145338 (h0 : topological_space (canonically_ordered_comm_semiring Type)) : t0_space (canonically_ordered_comm_semiring Type) := sorry --non-trivial
lemma new_lemma_145339 (h0 : function.extfun Type topological_space) : @normal_space.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_145340 (h0 : ring (semigroup (has_add pos))) : rank_condition (semigroup (has_add pos)) := sorry --non-trivial
lemma new_lemma_145341 (h0 : functor.add_const (topological_space (cancel_monoid name)) name) : @totally_disconnected_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_145342 (h0 : group (has_inter (option (option unsigned)))) : normalizer_condition (has_inter (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_145343 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (linear_ordered_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_145344 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} h0 (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_145345 (h1 : topological_space (distrib (mul_one_class linarith.ineq))) : t0_space (distrib (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_145346 (h0 : ring (finset environment.implicit_infer_kind)) : is_domain (finset environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_145347 (h0 : add_group (denumerable (comm_ring reducibility_hints))) : is_add_cyclic (denumerable (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_145348 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_145349 (h0 : group (add_cancel_monoid (has_add name))) : normalizer_condition (add_cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_145350 (h0 : option (mul_zero_class ennreal) -> option (mul_zero_class ennreal) -> Prop) : is_symm (option (mul_zero_class ennreal)) h0 := sorry --non-trivial
lemma new_lemma_145351 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (boolean_algebra pos)) : @topological_space.separable_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (boolean_algebra.{0} pos) h0) Type)  := sorry --non-trivial
lemma new_lemma_145352 (h0 : topological_space (has_top (has_top linarith.comp_source))) : locally_compact_space (has_top (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_145353 (h0 : functor.add_const (cancel_comm_monoid_with_zero (complete_distrib_lattice name)) (option name)) : @unique_factorization_monoid.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (complete_distrib_lattice.{0} name)) (option.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_145354 (h0 : topological_space (semigroup (option name))) : totally_separated_space (semigroup (option name)) := sorry --non-trivial
lemma new_lemma_145355 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @is_cyclic.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_145356 (h0 : finset (cancel_monoid (boolean_algebra (ring Type)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_145357 (h0 : functor.add_const (function.extfun Type group) Type) : @is_cyclic.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_145358 (h0 : topological_space (has_zero (has_Inf (has_Inf linarith.comp)))) : irreducible_space (has_zero (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_145359 (h0 : set (prod pos pos)) (h1 : prod pos pos) : symmetrize_rel h0 h1 := sorry --non-trivial
lemma new_lemma_145360 (h0 : filter unsigned) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_145361 (h0 : functor.add_const (functor.add_const (function.extfun Type ring) Type) (ring linarith.comp)) : @is_domain.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type (@functor.add_const.run.{1 0} (functor.add_const.{1 1} (function.extfun.{2 1} Type ring.{0}) Type) (ring.{0} linarith.comp) h0)) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_145362 (h0 : group (has_nndist (has_to_string name))) : is_simple_group (has_nndist (has_to_string name)) := sorry --non-trivial
lemma new_lemma_145363 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_145364 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) Type) : @complete_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) uniform_space.{1}) Type h0) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_145365 (h0 : topological_space (canonically_ordered_comm_semiring (cancel_monoid unsigned))) : locally_compact_space (canonically_ordered_comm_semiring (cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_145366 (h0 : ring (add_group (has_top (has_top empty)))) : is_principal_ideal_ring (add_group (has_top (has_top empty))) := sorry --non-trivial
lemma new_lemma_145367 (h0 : list (omega_complete_partial_order num)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_145368 (h0 : add_group (semi_normed_ring reducibility_hints)) : is_add_cyclic (semi_normed_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_145369 (h0 : topological_space (has_norm (comm_ring fun_info))) : irreducible_space (has_norm (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_145370 (h0 : not (cancel_comm_monoid_with_zero (has_union unsigned) -> false)) : @unique_factorization_monoid.{0} (has_union.{0} unsigned) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (has_union.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_145371 (h0 : monoid (preorder (semiring num))) : monoid.fg (preorder (semiring num)) := sorry --non-trivial
lemma new_lemma_145372 (h0 : function.extfun Type (functor.comp topological_space normed_comm_ring)) : @sequential_space.{0} (normed_comm_ring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} normed_comm_ring.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} normed_comm_ring.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_145373 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (ordered_comm_monoid.{0} real) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (ordered_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_145374 (h0 : topological_space (ring (has_Inf Type))) : loc_path_connected_space (ring (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_145375 (h0 : functor.add_const (group (has_neg_part name)) unsigned) : @normalizer_condition.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_neg_part.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_145376 (h0 : functor.add_const (topological_space (left_cancel_monoid unsigned)) (semiring (semiring num))) : @normal_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) (semiring.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_145377 (h0 h1 : multiset (mul_one_class (mul_one_class (mul_one_class char)))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_145378 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_145379 (h0 : topological_space (canonically_linear_ordered_monoid pos)) : normal_space (canonically_linear_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_145380 (h0 : cancel_comm_monoid_with_zero (has_neg_part (comm_group (has_add Type)))) : unique_factorization_monoid (has_neg_part (comm_group (has_add Type))) := sorry --non-trivial
lemma new_lemma_145381 (h0 : topological_space (metric_space congr_arg_kind)) : locally_compact_space (metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_145382 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_145383 (h0 : topological_space (has_le (mul_one_class to_additive.value_type))) : path_connected_space (has_le (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_145384 (h0 : add_monoid (sub_neg_monoid (ordered_comm_monoid (ordered_comm_monoid (has_Inf name))))) : add_monoid.fg (sub_neg_monoid (ordered_comm_monoid (ordered_comm_monoid (has_Inf name)))) := sorry --non-trivial
lemma new_lemma_145385 (h0 : ring string.iterator) : is_domain string.iterator := sorry --non-trivial
lemma new_lemma_145386 (h1 : set ereal) : set.finite h1 := sorry --non-trivial
lemma new_lemma_145387 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_145388 (h0 : random_gen (random_gen char) -> random_gen (random_gen char) -> bool) : is_dec_refl h0 := sorry --non-trivial
lemma new_lemma_145389 (h0 : ring (has_union (has_norm (semiring num)))) : strong_rank_condition (has_union (has_norm (semiring num))) := sorry --non-trivial
lemma new_lemma_145390 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_145391 (h0 : functor.add_const (complete_lattice ennreal) unsigned) : is_atomistic ennreal := sorry --non-trivial
lemma new_lemma_145392 (h0 : has_zero (add_comm_monoid (option pos)) -> has_zero (add_comm_monoid (option pos)) -> Prop) : is_symm (has_zero (add_comm_monoid (option pos))) h0 := sorry --non-trivial
lemma new_lemma_145393 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_neg_part.{0} (has_neg_part.{0} name)) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_neg_part.{0} (has_neg_part.{0} name)))  := sorry --non-trivial
lemma new_lemma_145394 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 pos) := sorry --non-trivial
lemma new_lemma_145395 (h0 : fin has_zero.zero) : @no_max_order.{0} (nondiscrete_normed_field.{0} linarith.ineq) (@matrix.vec_empty.{0} (has_lt.{0} (nondiscrete_normed_field.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_145396 (h0 : functor.add_const (functor.add_const (topological_space pos) pos) linarith.comp) : @locally_compact_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} pos) pos) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_145397 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_145398 (h1 : uniform_space (distrib linarith.comp_source)) : complete_space (distrib linarith.comp_source) := sorry --non-trivial
lemma new_lemma_145399 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (boolean_algebra.core.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (boolean_algebra.core.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_145400 (h0 : topological_space (finset (has_Inf (has_Inf (generalized_boolean_algebra (has_add pos)))))) : preconnected_space (finset (has_Inf (has_Inf (generalized_boolean_algebra (has_add pos))))) := sorry --non-trivial
lemma new_lemma_145401 (h0 : not (topological_space (has_norm num) -> false)) : @totally_separated_space.{0} (has_norm.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_145402 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_145403 (h0 : topological_space (has_add (boolean_algebra.core pos))) : sequential_space (has_add (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_145404 (h0 : ring (generalized_boolean_algebra (has_add pos))) : is_principal_ideal_ring (generalized_boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_145405 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) pos) : @t1_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_145406 (h0 : ring (has_zero (normed_comm_ring (has_add (ring Type))))) : is_domain (has_zero (normed_comm_ring (has_add (ring Type)))) := sorry --non-trivial
lemma new_lemma_145407 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_145408 (h0 : ring (ring (finset linarith.comp))) : is_principal_ideal_ring (ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_145409 (h0 : fin has_zero.zero) : id (matrix.vec_empty (matrix.vec_empty (matrix.vec_empty h0))) := sorry --non-trivial
lemma new_lemma_145410 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_145411 (h0 : function.extfun (Type 1) topological_space) : @path_connected_space.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_145412 (h0 : ring (finset num)) : is_domain (finset num) := sorry --non-trivial
lemma new_lemma_145413 (h0 : topological_space (semi_normed_ring string.iterator_imp)) (h1 : set (topological_space.opens (semi_normed_ring string.iterator_imp))) : set.finite h1 := sorry --non-trivial
lemma new_lemma_145414 (h0 : group (linear_ordered_add_comm_group to_additive.value_type)) : normalizer_condition (linear_ordered_add_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_145415 (h0 : add_group (measurable_space (has_norm (has_norm empty)))) : is_add_cyclic (measurable_space (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_145416 (h0 : add_group (random_gen reducibility_hints)) : is_add_cyclic (random_gen reducibility_hints) := sorry --non-trivial
lemma new_lemma_145417 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_145418 (h0 : complete_lattice (linear_ordered_add_comm_group (has_ssubset (has_ssubset fun_info)))) : is_compactly_generated (linear_ordered_add_comm_group (has_ssubset (has_ssubset fun_info))) := sorry --non-trivial
lemma new_lemma_145419 (h0 : measurable_space char) (h3 : measure_theory.measure char) : measure_theory.is_finite_measure h3 := sorry --non-trivial
lemma new_lemma_145420 (h0 : not (ring (complete_semilattice_Sup num) -> false)) : @strong_rank_condition.{0} (complete_semilattice_Sup.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (complete_semilattice_Sup.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_145421 (h0 : ring (id string_imp)) : is_domain (id string_imp) := sorry --non-trivial
lemma new_lemma_145422 (h0 : ring (dlist (has_nnnorm (random_gen fun_info)))) : is_domain (dlist (has_nnnorm (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_145423 (h0 : group (has_one congr_arg_kind)) : group.fg (has_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_145424 (h0 : topological_space (has_nndist pos)) : locally_compact_space (has_nndist pos) := sorry --non-trivial
lemma new_lemma_145425 (h0 : functor.add_const (complete_lattice (comm_group unsigned)) Type) : @is_atomistic.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 1} (complete_lattice.{0} (comm_group.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_145426 (h0 : functor.add_const (ring (pseudo_metric_space unsigned)) empty) : @is_domain.{0} (pseudo_metric_space.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (pseudo_metric_space.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_145427 (h0 : topological_space (mul_zero_class (semigroup (normed_comm_ring Type)))) : path_connected_space (mul_zero_class (semigroup (normed_comm_ring Type))) := sorry --non-trivial
lemma new_lemma_145428 (h0 : group (has_Inf (has_add (sub_neg_monoid (has_add real))))) : group.fg (has_Inf (has_add (sub_neg_monoid (has_add real)))) := sorry --non-trivial
lemma new_lemma_145429 (h5 : not (complete_lattice (denumerable linarith.comp_source) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (denumerable.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (denumerable.{0} linarith.comp_source)) h5)  := sorry --non-trivial
lemma new_lemma_145430 (h0 : function.extfun nat fin) : @sequential_space.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (normed_lattice_add_comm_group.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_145431 (h0 : function.extfun (Type 1) group) : @is_cyclic.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_145432 (h0 : add_group (add_cancel_monoid (has_pos_part (has_pos_part (ring linarith.comp))))) : is_add_cyclic (add_cancel_monoid (has_pos_part (has_pos_part (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_145433 (h0 : monoid (generalized_boolean_algebra (ring (has_neg (finset pos))))) : monoid.fg (generalized_boolean_algebra (ring (has_neg (finset pos)))) := sorry --non-trivial
lemma new_lemma_145434 (h0 : not (complete_lattice (has_append linarith.comp_source) -> false)) : @is_compactly_generated.{0} (has_append.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_append.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_145435 (h0 : topological_space (measurable_space linarith.comp_source)) : totally_disconnected_space (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_145436 (h0 : ordered_add_comm_monoid (left_cancel_monoid (semiring (semiring empty)))) : archimedean (left_cancel_monoid (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_145437 (h0 : ordered_comm_monoid (finset (add_comm_monoid Type))) : has_exists_mul_of_le (finset (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_145438 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_145439 (h0 : semiring (cancel_monoid congr_arg_kind)) : is_noetherian_ring (cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_145440 (h0 : topological_space (semi_normed_comm_ring char)) : totally_disconnected_space (semi_normed_comm_ring char) := sorry --non-trivial
lemma new_lemma_145441 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (@id.{2} Type linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (@id.{2} Type linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_145442 (h0 : topological_space (linear_ordered_field empty)) : t0_space (linear_ordered_field empty) := sorry --non-trivial
lemma new_lemma_145443 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_145444 (h1 : complete_lattice (linear_ordered_add_comm_group string_imp)) : complete_lattice.is_Sup_finite_compact (linear_ordered_add_comm_group string_imp) := sorry --non-trivial
lemma new_lemma_145445 (h0 : uniform_space (has_nndist (finset ennreal))) : separated_space (has_nndist (finset ennreal)) := sorry --non-trivial
lemma new_lemma_145446 (h0 : set (semi_normed_comm_ring (mul_one_class (mul_one_class to_additive.value_type)))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_145447 (h0 : ring (add_group (semiring (has_norm (semiring congr_arg_kind))))) : is_domain (add_group (semiring (has_norm (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_145448 (h0 : filter (has_nndist (has_add (has_nndist (finset (has_add (has_add ennreal))))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_145449 (h0 : add_monoid (has_Inf (has_add Type))) : add_monoid.fg (has_Inf (has_add Type)) := sorry --non-trivial
lemma new_lemma_145450 (h0 : topological_space (random_gen (has_nnnorm linarith.comp_source))) : path_connected_space (random_gen (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_145451 (h2 : set (fun_info -> linarith.ineq)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_145452 (h0 : add_monoid (random_gen complex)) : add_monoid.fg (random_gen complex) := sorry --non-trivial
lemma new_lemma_145453 (h0 : group (denumerable (comm_ring (random_gen (random_gen (random_gen linarith.comp_source)))))) : group.fg (denumerable (comm_ring (random_gen (random_gen (random_gen linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_145454 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) name) : @sequential_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_145455 (h3 : topological_space (has_div char)) (h4 : preorder (has_div char)) : order_topology (has_div char) := sorry --non-trivial
lemma new_lemma_145456 (h0 : fin has_zero.zero) : @add_monoid.fg.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (add_monoid.{1} (normed_lattice_add_comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_145457 (h3 : topological_space (random_gen (has_nnnorm char))) : totally_disconnected_space (random_gen (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_145458 (h0 : list (comm_group (add_comm_monoid name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_145459 (h1 : ring (has_div std_gen)) : strong_rank_condition (has_div std_gen) := sorry --non-trivial
lemma new_lemma_145460 (h0 : topological_space (measurable_space (has_top (random_gen to_additive.value_type)))) : path_connected_space (measurable_space (has_top (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_145461 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_145462 (h0 : ring (has_neg_part (has_add name))) : strong_rank_condition (has_neg_part (has_add name)) := sorry --non-trivial
lemma new_lemma_145463 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_145464 (h1 : uniform_space (has_inv char)) : complete_space (has_inv char) := sorry --non-trivial
lemma new_lemma_145465 (h0 : uniform_space (semi_normed_comm_ring (has_lt linarith.comp_source))) : complete_space (semi_normed_comm_ring (has_lt linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_145466 (h0 : uniform_space (with_bot (has_top (has_top num)))) : complete_space (with_bot (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_145467 (h0 : not (uniform_space (linear_ordered_add_comm_group fun_info) -> false)) : @complete_space.{0} (linear_ordered_add_comm_group.{0} fun_info) (@classical.by_contradiction'.{1} (uniform_space.{0} (linear_ordered_add_comm_group.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_145468 (h0 : topological_space (ring linarith.comp)) : normal_space (ring linarith.comp) := sorry --non-trivial
lemma new_lemma_145469 (h0 : group (has_add unsigned)) : is_simple_group (has_add unsigned) := sorry --non-trivial
lemma new_lemma_145470 (h0 : add_group (semigroup (has_neg (finset linarith.comp)))) : is_add_cyclic (semigroup (has_neg (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_145471 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (has_dist.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (has_dist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_145472 (h0 : has_mem.mem (id (semiring num)) has_emptyc.emptyc) : @totally_separated_space.{0} (@id.{2} Type (semiring.{0} num)) (@finset.pi.empty.{1 0} Type topological_space.{0} (@id.{2} Type (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_145473 (h0 : functor.add_const (ring (has_add Type)) (has_add name)) : @rank_condition.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_add.{1} Type)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_145474 (h0 : functor.add_const (topological_space (ordered_ring congr_arg_kind)) num) : @topological_space.separable_space.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_145475 (h0 : topological_space (has_add name)) : t1_space (has_add name) := sorry --non-trivial
lemma new_lemma_145476 (h0 : functor.add_const (group (normed_comm_ring name)) name) : @normalizer_condition.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_145477 (h0 : monoid (boolean_algebra (has_add Type))) : monoid.fg (boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_145478 (h0 : topological_space (has_inner unsigned empty)) : path_connected_space (has_inner unsigned empty) := sorry --non-trivial
lemma new_lemma_145479 (h0 : ring (option (semiring (semiring empty)))) : is_domain (option (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_145480 (h0 : add_group (has_to_string (has_add name))) : is_add_cyclic (has_to_string (has_add name)) := sorry --non-trivial
lemma new_lemma_145481 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_bot.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_145482 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (linear_ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_145483 (h0 : list (non_assoc_semiring (option unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_145484 (h0 : topological_space (has_inter (option ennreal))) : t0_space (has_inter (option ennreal)) := sorry --non-trivial
lemma new_lemma_145485 (h0 : add_group (normed_field (has_nnnorm linarith.ineq))) : is_add_cyclic (normed_field (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_145486 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (normed_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_145487 (h0 : function.extfun nat fin) : @preconnected_space.{0} (has_add.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_145488 (h0 : nat) (h1 : vector Prop (nat.succ (id (id (id h0))))) : vector.head h1 := sorry --non-trivial
lemma new_lemma_145489 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @has_exists_mul_of_le.{0} (canonically_linear_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (canonically_linear_ordered_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_145490 (h0 : function.extfun Type (functor.add_const (list (has_nndist num)))) : list.nodup (functor.add_const.run (function.extfun_app h0 unsigned)) := sorry --non-trivial
lemma new_lemma_145491 (h0 : finset (has_neg unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_145492 (h0 : functor.comp topological_space has_nndist ennreal) : @preirreducible_space.{0} (has_nndist.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_145493 (h0 : function.extfun Type group) : @is_cyclic.{0} (simple_graph.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (simple_graph.{0} empty))  := sorry --non-trivial
lemma new_lemma_145494 (h0 : add_group (distrib_lattice unsigned)) : is_add_cyclic (distrib_lattice unsigned) := sorry --non-trivial
lemma new_lemma_145495 (h0 : functor.add_const (uniform_space (boolean_algebra Type)) linarith.comp) : @complete_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_145496 (h0 : fin has_zero.zero) : @path_connected_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_145497 (h0 : function.extfun Type group) : @is_cyclic.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_145498 (h0 : finset (normed_comm_ring (finset (finset environment.implicit_infer_kind)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_145499 (h0 : option unsigned -> option unsigned -> option unsigned) : left_cancelative h0 := sorry --non-trivial
lemma new_lemma_145500 (h0 : fin has_zero.zero) : @rank_condition.{1} (canonically_ordered_comm_semiring.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (canonically_ordered_comm_semiring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_145501 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_145502 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (with_zero.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_zero.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_145503 (h1 : ring (has_norm linarith.comp)) : strong_rank_condition (has_norm linarith.comp) := sorry --non-trivial
lemma new_lemma_145504 (h0 : functor.add_const (topological_space (comm_group unsigned)) unsigned) : @path_connected_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_145505 (h1 : complete_lattice (has_ssubset (normed_field reducibility_hints))) : complete_lattice.is_Sup_finite_compact (has_ssubset (normed_field reducibility_hints)) := sorry --non-trivial
lemma new_lemma_145506 (h0 : topological_space (has_zero (has_neg pos))) : discrete_topology (has_zero (has_neg pos)) := sorry --non-trivial
lemma new_lemma_145507 (h0 : list (conditionally_complete_linear_order (has_ssubset linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_145508 (h0 : topological_space (id num)) : topological_space.separable_space (id num) := sorry --non-trivial
lemma new_lemma_145509 (h0 : function.extfun (Type 1) topological_space) : @locally_compact_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_145510 (h0 : has_mem.mem (with_one linarith.comp_source) has_zero.zero) : @complete_space.{0} (with_one.{0} linarith.comp_source) (@multiset.pi.empty.{1 0} Type uniform_space.{0} (with_one.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_145511 (h0 : topological_space (has_to_string (has_neg Type))) : t0_space (has_to_string (has_neg Type)) := sorry --non-trivial
lemma new_lemma_145512 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_145513 (h0 : functor.add_const (function.extfun Type add_group) Type) : @is_add_cyclic.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_group.{0}) Type h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_145514 (h0 : ring (has_zero (has_add ennreal))) : is_principal_ideal_ring (has_zero (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_145515 (h0 : topological_space (ring environment.implicit_infer_kind)) : normal_space (ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_145516 (h0 : group (has_to_string (ring linarith.comp))) : group.fg (has_to_string (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_145517 (h0 : ring (ring ennreal)) : rank_condition (ring ennreal) := sorry --non-trivial
lemma new_lemma_145518 (h0 : functor.add_const (group (is_R_or_C empty)) unsigned) : @is_cyclic.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (is_R_or_C.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_145519 (h0 : functor.add_const (group (comm_group name)) Type) : @normalizer_condition.{0} (comm_group.{0} name) (@functor.add_const.run.{0 1} (group.{0} (comm_group.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_145520 (h0 : set (std_gen -> add_comm_semigroup string)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_145521 (h0 : group (option name)) : is_simple_group (option name) := sorry --non-trivial
lemma new_lemma_145522 (h0 : functor.add_const (topological_space (finset pos)) (finset pos)) : @topological_space.separable_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_145523 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_145524 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_145525 (h0 : ring (encodable (random_gen linarith.comp_source))) : rank_condition (encodable (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_145526 (h0 : not (functor.comp topological_space semi_normed_ring string_imp -> false)) : @totally_disconnected_space.{0} (semi_normed_ring.{0} string_imp) (@functor.comp.run.{0 0 0} topological_space.{0} semi_normed_ring.{0} string_imp (@classical.by_contradiction'.{1} (functor.comp.{0 0 0} topological_space.{0} semi_normed_ring.{0} string_imp) h0))  := sorry --non-trivial
lemma new_lemma_145527 (h0 : ordered_comm_monoid (has_nndist (option pos))) : has_exists_mul_of_le (has_nndist (option pos)) := sorry --non-trivial
lemma new_lemma_145528 (h0 : ordered_add_comm_monoid (has_zero (ring Type))) : archimedean (has_zero (ring Type)) := sorry --non-trivial
lemma new_lemma_145529 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (boolean_algebra.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_145530 (h0 : topological_space (has_star unsigned)) : loc_path_connected_space (has_star unsigned) := sorry --non-trivial
lemma new_lemma_145531 (h0 : ordered_add_comm_monoid (add_cancel_monoid (has_neg Type))) : archimedean (add_cancel_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_145532 (h0 : topological_space (boolean_algebra.core (has_add environment.implicit_infer_kind))) : normal_space (boolean_algebra.core (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_145533 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_bot.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_145534 (h0 : group (has_Sup (semiring empty))) : is_cyclic (has_Sup (semiring empty)) := sorry --non-trivial
lemma new_lemma_145535 (h0 : add_monoid (has_union (semiring congr_arg_kind))) : add_monoid.fg (has_union (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_145536 (h0 : function.extfun (Type 1) topological_space) : @topological_space.separable_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 Type)  := sorry --non-trivial
lemma new_lemma_145537 (h1 : filter (fintype (has_inv (with_zero char)))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_145538 (h0 : finset (semigroup (has_to_string (has_to_string pos)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_145539 (h0 : complete_lattice (measurable_space (semiring (has_top congr_arg_kind)))) : complete_lattice.is_Sup_finite_compact (measurable_space (semiring (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_145540 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_145541 (h0 : ring (finset (boolean_algebra.core pos))) : is_principal_ideal_ring (finset (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_145542 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (@id.{2} Type linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_145543 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) Type) : @t0_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_145544 (h0 : topological_space (has_nndist (has_nndist (finset linarith.comp)))) : preirreducible_space (has_nndist (has_nndist (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_145545 (h0 : ring (boolean_algebra.core empty)) : is_principal_ideal_ring (boolean_algebra.core empty) := sorry --non-trivial
lemma new_lemma_145546 (h0 : function.extfun Type topological_space) : @normal_space.{0} (preorder.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_145547 (h0 : topological_space (ring (option num))) : t0_space (ring (option num)) := sorry --non-trivial
lemma new_lemma_145548 (h0 : functor.add_const (monoid (has_neg environment.implicit_infer_kind)) (has_to_string name)) : @monoid.fg.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (has_neg.{0} environment.implicit_infer_kind)) (has_to_string.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_145549 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) (ring pos)) : @locally_compact_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_145550 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_145551 (h0 : functor.add_const (group (normed_comm_ring Type)) Type) : @normalizer_condition.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (normed_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_145552 (h0 : monoid (boolean_algebra.core (has_to_string Type))) : monoid.fg (boolean_algebra.core (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_145553 (h0 : topological_space (has_nndist linarith.comp)) : totally_disconnected_space (has_nndist linarith.comp) := sorry --non-trivial
lemma new_lemma_145554 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @t0_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_145555 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) environment.implicit_infer_kind) : @sequential_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_145556 (h0 : ring (mul_one_class ereal)) : is_domain (mul_one_class ereal) := sorry --non-trivial
lemma new_lemma_145557 (h0 : filter (comm_group unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_145558 (h0 : functor.add_const (complete_lattice (has_add linarith.comp)) pos) : @is_compactly_generated.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_add.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_145559 (h0 : not (topological_space (add_cancel_comm_monoid string.iterator_imp) -> false)) : @totally_disconnected_space.{0} (add_cancel_comm_monoid.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (add_cancel_comm_monoid.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_145560 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_145561 (h0 : functor.add_const (group (linear_ordered_cancel_comm_monoid empty)) empty) : @is_cyclic.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_145562 (h1 : group (dlist linarith.comp_source)) : is_cyclic (dlist linarith.comp_source) := sorry --non-trivial
lemma new_lemma_145563 (h0 : add_group (boolean_algebra (has_neg pos))) : is_add_cyclic (boolean_algebra (has_neg pos)) := sorry --non-trivial
lemma new_lemma_145564 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (pseudo_metric_space.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_145565 (h0 : has_mem.mem group has_emptyc.emptyc) : @group.fg.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_145566 (h0 : topological_space (group_with_zero congr_arg_kind)) : irreducible_space (group_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_145567 (h0 : complete_lattice (plift (semiring unsigned))) : complete_lattice.is_Sup_finite_compact (plift (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_145568 (h0 : complete_lattice (measurable_space (has_inv linarith.ineq))) : complete_lattice.is_Sup_finite_compact (measurable_space (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_145569 (h0 : finset (boolean_algebra (has_neg (finset (measurable_space linarith.comp))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_145570 (h0 : group (has_union (with_bot unsigned))) : is_cyclic (has_union (with_bot unsigned)) := sorry --non-trivial
lemma new_lemma_145571 (h0 : functor.add_const (group (canonically_ordered_comm_semiring Type)) pos) : @normalizer_condition.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (canonically_ordered_comm_semiring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_145572 (h0 : functor.add_const (topological_space (canonically_ordered_monoid name)) name) : @totally_separated_space.{0} (canonically_ordered_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_145573 (h0 : functor.add_const (ordered_add_comm_monoid (generalized_boolean_algebra pos)) (has_add Type)) : @archimedean.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (generalized_boolean_algebra.{0} pos)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_145574 (h0 : group (linear_ordered_ring (random_gen num))) : normalizer_condition (linear_ordered_ring (random_gen num)) := sorry --non-trivial
lemma new_lemma_145575 (h0 : topological_space (sub_neg_monoid (has_Inf (has_Inf (has_Inf Type))))) : normal_space (sub_neg_monoid (has_Inf (has_Inf (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_145576 (h0 : has_mem.mem (normed_group linarith.comp_source) has_emptyc.emptyc) : @is_add_cyclic.{0} (normed_group.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type add_group.{0} (normed_group.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_145577 (h0 : not (complete_lattice (complete_semilattice_Sup to_additive.value_type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (complete_semilattice_Sup.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_145578 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_145579 (h0 : topological_space (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))) : path_connected_space (has_nnnorm (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_145580 (h0 : group (has_top (random_gen (has_nnnorm char)))) : group.fg (has_top (random_gen (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_145581 (h0 : prod (has_nndist (has_add (has_add ennreal))) (has_nndist (has_add (has_add ennreal)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_145582 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_145583 (h0 : has_le (with_bot num)) : no_bot_order (with_bot num) := sorry --non-trivial
lemma new_lemma_145584 (h0 : cancel_comm_monoid_with_zero (ordered_comm_monoid (generalized_boolean_algebra pos))) : unique_factorization_monoid (ordered_comm_monoid (generalized_boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_145585 (h0 : topological_space (canonically_linear_ordered_monoid (has_pos_part (has_Inf (has_pos_part Type))))) : discrete_topology (canonically_linear_ordered_monoid (has_pos_part (has_Inf (has_pos_part Type)))) := sorry --non-trivial
lemma new_lemma_145586 (h0 : complete_lattice (semi_normed_ring reducibility_hints)) : is_compactly_generated (semi_normed_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_145587 (h0 : add_monoid (normed_group (semiring (random_gen congr_arg_kind)))) : add_monoid.fg (normed_group (semiring (random_gen congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_145588 (h0 : function.extfun Type (functor.add_const (semiring (plift empty)))) : @is_noetherian_ring.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (semiring.{1} (plift.{1} empty)) (option.{0} (option.{0} (option.{0} unsigned))) (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (semiring.{1} (plift.{1} empty))) h0 (option.{0} (option.{0} (option.{0} unsigned)))))  := sorry --non-trivial
lemma new_lemma_145589 (h0 : topological_space (semigroup (ring (boolean_algebra.core environment.implicit_infer_kind)))) : preconnected_space (semigroup (ring (boolean_algebra.core environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_145590 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_145591 (h0 : topological_space (has_zero (comm_group (has_to_string (has_add unsigned))))) : path_connected_space (has_zero (comm_group (has_to_string (has_add unsigned)))) := sorry --non-trivial
lemma new_lemma_145592 (h0 : function.extfun (finset Type) (has_mem.mem (has_one num))) : @strong_rank_condition.{0} (has_one.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (has_one.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_145593 (h0 : topological_space (has_add (normed_comm_ring environment.implicit_infer_kind))) : t0_space (has_add (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_145594 (h0 : uniform_space (partial_order num)) : complete_space (partial_order num) := sorry --non-trivial
lemma new_lemma_145595 (h0 : topological_space (option (option (option (option name))))) : topological_space.separable_space (option (option (option (option name)))) := sorry --non-trivial
lemma new_lemma_145596 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} empty (@function.extfun_app.{2 1} Type add_monoid.{0} h0 empty)  := sorry --non-trivial
lemma new_lemma_145597 (h0 : not (pseudo_metric_space (fintype linarith.comp_source) -> false)) (h1 : add_monoid (fintype linarith.comp_source)) : @has_lipschitz_add.{0} (fintype.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (pseudo_metric_space.{0} (fintype.{0} linarith.comp_source)) h0) h1  := sorry --non-trivial
lemma new_lemma_145598 (h0 : ring (distrib (has_lt linarith.comp_source))) : is_domain (distrib (has_lt linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_145599 (h0 : functor.add_const (topological_space (ring linarith.comp)) ennreal) : @totally_separated_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_145600 (h0 : topological_space (has_to_string pos)) : t1_space (has_to_string pos) := sorry --non-trivial
lemma new_lemma_145601 (h0 : group (has_inv (has_nnnorm char))) : is_cyclic (has_inv (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_145602 (h0 : topological_space (comm_ring (has_inv (has_inv (denumerable (comm_ring (has_top fun_info))))))) : path_connected_space (comm_ring (has_inv (has_inv (denumerable (comm_ring (has_top fun_info)))))) := sorry --non-trivial
lemma new_lemma_145603 (h1 : group (has_inv num)) (h2 : not (subgroup (has_inv num) -> false)) : subgroup.saturated (classical.by_contradiction' h2) := sorry --non-trivial
lemma new_lemma_145604 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (option.{0} (semiring.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} (semiring.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_145605 (h0 : topological_space (simple_graph (has_add (has_pos_part Type)))) : totally_disconnected_space (simple_graph (has_add (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_145606 (h1 : uniform_space (has_compl (has_ssubset linarith.comp_source))) : complete_space (has_compl (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_145607 (h0 : topological_space (normed_lattice_add_comm_group Type)) : totally_disconnected_space (normed_lattice_add_comm_group Type) := sorry --non-trivial
lemma new_lemma_145608 (h0 : function.extfun Type ring) : @rank_condition.{0} (complete_distrib_lattice.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_distrib_lattice.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_145609 (h0 : add_monoid (ring (semigroup environment.implicit_infer_kind))) : add_monoid.fg (ring (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_145610 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (distrib_lattice.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (distrib_lattice.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_145611 (h0 : ring (comm_group (has_add (finset name)))) : is_principal_ideal_ring (comm_group (has_add (finset name))) := sorry --non-trivial
lemma new_lemma_145612 (h0 : functor.add_const (group (canonically_ordered_comm_semiring ennreal)) pos) : @group.fg.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_comm_semiring.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_145613 (h0 : ring (has_nnnorm (has_nnnorm fun_info))) : strong_rank_condition (has_nnnorm (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_145614 (h0 : not (ring (linear_ordered_semiring empty) -> false)) : @is_principal_ideal_ring.{0} (linear_ordered_semiring.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_145615 (h0 : ring (random_gen (has_top linarith.comp))) : rank_condition (random_gen (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_145616 (h0 : functor.add_const (filter (has_pos_part Type)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_145617 (h0 : set (has_dist (has_ssubset (non_unital_non_assoc_semiring (mul_one_class (mul_one_class linarith.ineq)))))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_145618 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system unsigned)) congr_arg_kind) : @locally_compact_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_145619 (h0 : topological_space (normed_linear_ordered_group (semiring (semiring empty)))) : normal_space (normed_linear_ordered_group (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_145620 (h0 : filter (canonically_ordered_comm_semiring Type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_145621 (h0 : group (with_bot (semiring (has_top empty)))) : group.fg (with_bot (semiring (has_top empty))) := sorry --non-trivial
lemma new_lemma_145622 (h0 : complete_lattice (comm_ring (random_gen linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (comm_ring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_145623 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_145624 (h0 : group (finset (has_nndist name))) : group.fg (finset (has_nndist name)) := sorry --non-trivial
lemma new_lemma_145625 (h0 : functor.add_const (ring (ordered_comm_ring linarith.comp)) Type) : @is_principal_ideal_ring.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (ordered_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_145626 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_145627 (h0 : filter (filter unsigned)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_145628 (h0 : complete_lattice (has_compl (has_nnnorm linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (has_compl (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_145629 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_dist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_145630 (h0 : topological_space (semigroup (has_pos_part (finset linarith.comp)))) : discrete_topology (semigroup (has_pos_part (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_145631 (h0 : topological_space (comm_group name)) : sequential_space (comm_group name) := sorry --non-trivial
lemma new_lemma_145632 (h2 : has_mem.mem topological_space has_emptyc.emptyc) : @irreducible_space.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h2) (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_145633 (h0 : functor.add_const (finset pos) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_145634 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) real.angle) := sorry --non-trivial
lemma new_lemma_145635 (h0 : topological_space (measurable_space (random_gen num))) : totally_disconnected_space (measurable_space (random_gen num)) := sorry --non-trivial
lemma new_lemma_145636 (h0 : functor.add_const (ring (is_R_or_C empty)) empty) : @is_domain.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (is_R_or_C.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_145637 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_145638 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (complete_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_145639 (h1 : filter (has_ssubset (has_ssubset string_imp))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_145640 (h0 : topological_space (linear_ordered_semiring unsigned)) : topological_space.separable_space (linear_ordered_semiring unsigned) := sorry --non-trivial
lemma new_lemma_145641 (h0 : topological_space (ring unsigned)) : sequential_space (ring unsigned) := sorry --non-trivial
lemma new_lemma_145642 (h0 : finset (has_edist congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_145643 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm num))) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_norm.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_145644 (h0 : topological_space (finset (has_nndist ennreal))) : totally_separated_space (finset (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_145645 (h0 : functor.comp monoid complete_distrib_lattice unsigned) : @monoid.fg.{0} (complete_distrib_lattice.{0} unsigned) (@functor.comp.run.{0 0 0} monoid.{0} complete_distrib_lattice.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_145646 (h1 : ring (distrib (random_gen (random_gen (random_gen char))))) : strong_rank_condition (distrib (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_145647 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_neg_part pos)) name) : @unique_factorization_monoid.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_neg_part.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_145648 (h0 : uniform_space (normed_comm_ring unsigned)) : complete_space (normed_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_145649 (h0 : function.extfun Type topological_space) : @regular_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_145650 (h0 : function.extfun Type group) : @normalizer_condition.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_145651 (h0 : not (ring (left_cancel_semigroup empty) -> false)) : @is_principal_ideal_ring.{0} (left_cancel_semigroup.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (left_cancel_semigroup.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_145652 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_145653 (h0 : not (has_mem.mem (with_bot num) has_emptyc.emptyc -> false)) : @strong_rank_condition.{0} (with_bot.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (with_bot.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_145654 (h0 : finset (ordered_comm_ring (has_add Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_145655 (h0 : topological_space (has_neg_part (comm_group name))) : topological_space.separable_space (has_neg_part (comm_group name)) := sorry --non-trivial
lemma new_lemma_145656 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_145657 (h0 : topological_space (has_zero (option ennreal))) : regular_space (has_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_145658 (h1 : set linarith.ineq) : set.finite h1 := sorry --non-trivial
lemma new_lemma_145659 (h0 : topological_space (non_unital_non_assoc_semiring (mul_one_class string.iterator_imp))) : t0_space (non_unital_non_assoc_semiring (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_145660 (h2 : ring (mul_one_class linarith.ineq)) : is_domain (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_145661 (h0 : topological_space (has_inv (random_gen string_imp))) : totally_separated_space (has_inv (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_145662 (h0 : function.extfun Type ring) : @rank_condition.{0} (simple_graph.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (simple_graph.{0} real))  := sorry --non-trivial
lemma new_lemma_145663 (h0 : ring (ordered_comm_ring name)) : is_domain (ordered_comm_ring name) := sorry --non-trivial
lemma new_lemma_145664 (h0 : not (group (metric_space linarith.comp_source) -> false)) : @is_cyclic.{0} (metric_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (metric_space.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_145665 (h0 : has_lt (has_div std_gen)) : no_max_order (has_div std_gen) := sorry --non-trivial
lemma new_lemma_145666 (h0 : monoid (id (semiring congr_arg_kind))) : monoid.fg (id (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_145667 (h0 : group (ring (has_to_string Type))) : is_simple_group (ring (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_145668 (h0 : functor.add_const (topological_space (monoid unsigned)) num) : @path_connected_space.{0} (monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_145669 (h1 : linarith.comp_source -> linarith.comp_source -> Prop) (h2 : set linarith.comp_source) : set.unbounded h1 h2 := sorry --non-trivial
lemma new_lemma_145670 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_145671 (h0 : functor.add_const (ordered_add_comm_monoid (has_Inf linarith.comp)) pos) : @archimedean.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_Inf.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_145672 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (linear_ordered_field.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_field.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_145673 (h0 : topological_space (semigroup (has_add pos))) : preconnected_space (semigroup (has_add pos)) := sorry --non-trivial
lemma new_lemma_145674 (h0 : ring (non_unital_non_assoc_semiring (metric_space reducibility_hints))) : strong_rank_condition (non_unital_non_assoc_semiring (metric_space reducibility_hints)) := sorry --non-trivial
lemma new_lemma_145675 (h0 : set.set_semiring (dlist to_additive.value_type)) (h1 : dlist to_additive.value_type) : set.set_semiring.down h0 h1 := sorry --non-trivial
lemma new_lemma_145676 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_145677 (h1 : function.extfun (finset Type) (has_mem.mem (metric_space linarith.comp))) : @complete_space.{0} (metric_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type uniform_space.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (metric_space.{0} linarith.comp)) h1 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_145678 (h0 : list (canonically_ordered_comm_semiring (option unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_145679 (h0 : topological_space (add_right_cancel_monoid unsigned)) : discrete_topology (add_right_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_145680 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (add_cancel_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_145681 (h0 : topological_space (complete_semilattice_Sup congr_arg_kind)) : totally_disconnected_space (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_145682 (h0 : functor.add_const (finset (normed_comm_ring linarith.comp)) (has_pos_part pos)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_145683 (h0 : topological_space (group_with_zero (option (option (option (option congr_arg_kind)))))) : preirreducible_space (group_with_zero (option (option (option (option congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_145684 (h0 : topological_space (linear_ordered_comm_group (option (option pos)))) : discrete_topology (linear_ordered_comm_group (option (option pos))) := sorry --non-trivial
lemma new_lemma_145685 (h0 : finset (semiring num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_145686 (h0 : topological_space (boolean_algebra (has_pos_part linarith.comp))) : t1_space (boolean_algebra (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_145687 (h0 : ring (ring (semigroup pos))) : rank_condition (ring (semigroup pos)) := sorry --non-trivial
lemma new_lemma_145688 (h0 : topological_space (simple_graph (ring Type))) : t1_space (simple_graph (ring Type)) := sorry --non-trivial
lemma new_lemma_145689 (h0 : functor.add_const (list (boolean_algebra environment.implicit_infer_kind)) (finset linarith.comp)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_145690 (h0 : topological_space (finset (finset (finset (has_to_string (finset linarith.comp)))))) : irreducible_space (finset (finset (finset (has_to_string (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_145691 (h0 : complete_lattice (with_one (topological_space (fintype fun_info)))) : complete_lattice.is_Sup_finite_compact (with_one (topological_space (fintype fun_info))) := sorry --non-trivial
lemma new_lemma_145692 (h0 : topological_space (metric_space (semiring num))) : discrete_topology (metric_space (semiring num)) := sorry --non-trivial
lemma new_lemma_145693 (h0 : ring (with_bot (semiring (semiring linarith.comp)))) : is_domain (with_bot (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_145694 (h0 : topological_space (normed_comm_ring (comm_group (comm_group name)))) : t0_space (normed_comm_ring (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_145695 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preirreducible_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_145696 (h0 : topological_space (has_zero (has_zero name))) : totally_separated_space (has_zero (has_zero name)) := sorry --non-trivial
lemma new_lemma_145697 (h0 : complete_lattice (has_bot (has_add (has_add Type)))) : is_compactly_generated (has_bot (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_145698 (h0 : functor.comp topological_space ordered_cancel_add_comm_monoid (finset pos)) : @topological_space.separable_space.{0} (ordered_cancel_add_comm_monoid.{0} (finset.{0} pos)) (@functor.comp.run.{0 0 0} topological_space.{0} ordered_cancel_add_comm_monoid.{0} (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_145699 (h0 : uniform_space (has_one (has_top num))) : separated_space (has_one (has_top num)) := sorry --non-trivial
lemma new_lemma_145700 (h0 : topological_space (canonically_linear_ordered_monoid (has_neg real))) : path_connected_space (canonically_linear_ordered_monoid (has_neg real)) := sorry --non-trivial
lemma new_lemma_145701 (h0 : topological_space (finset (finset (finset (finset linarith.comp))))) : locally_compact_space (finset (finset (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_145702 (h0 : uniform_space (pseudo_metric_space (has_add (cancel_monoid (has_nndist (option pos)))))) : complete_space (pseudo_metric_space (has_add (cancel_monoid (has_nndist (option pos))))) := sorry --non-trivial
lemma new_lemma_145703 (h0 : fin has_zero.zero) : @t0_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) (@matrix.vec_empty.{2} (function.extfun.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1))) h0) topological_space.{1}) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_145704 (h0 : functor.add_const (complete_lattice (normed_lattice_add_comm_group real)) Type) : @is_atomistic.{0} (normed_lattice_add_comm_group.{0} real) (@functor.add_const.run.{0 1} (complete_lattice.{0} (normed_lattice_add_comm_group.{0} real)) Type h0)  := sorry --non-trivial
lemma new_lemma_145705 (h1 : topological_space (mul_one_class (add_comm_semigroup ereal))) : totally_disconnected_space (mul_one_class (add_comm_semigroup ereal)) := sorry --non-trivial
lemma new_lemma_145706 (h0 : has_mem.mem (linear_ordered_semiring num) has_emptyc.emptyc) : @path_connected_space.{0} (linear_ordered_semiring.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_145707 (h2 : monoid to_additive.value_type) : monoid.fg to_additive.value_type := sorry --non-trivial
lemma new_lemma_145708 (h0 : topological_space (measurable_space (random_gen (random_gen (random_gen linarith.ineq))))) : totally_separated_space (measurable_space (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_145709 (h0 : semiring (non_assoc_semiring (semiring empty))) : is_noetherian_ring (non_assoc_semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_145710 (h0 : topological_space (option num)) : totally_disconnected_space (option num) := sorry --non-trivial
lemma new_lemma_145711 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_145712 (h0 : functor.add_const (topological_space (cancel_monoid pos)) name) : @regular_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_145713 (h0 : topological_space (complete_semilattice_Sup (has_top linarith.ineq))) : path_connected_space (complete_semilattice_Sup (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_145714 (h0 : topological_space (boolean_algebra unsigned)) : path_connected_space (boolean_algebra unsigned) := sorry --non-trivial
lemma new_lemma_145715 (h0 : functor.add_const (group (boolean_algebra.core Type)) linarith.comp) : @is_cyclic.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (boolean_algebra.core.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_145716 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_145717 (h5 : not (complete_lattice (uniform_space to_additive.value_type) -> false)) : is_compactly_generated (uniform_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_145718 (h0 : set (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup linarith.ineq)) -> char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_145719 (h0 : topological_space (finset (has_neg (has_pos_part Type)))) : locally_compact_space (finset (has_neg (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_145720 (h0 : topological_space (linear_ordered_add_comm_group to_additive.value_type)) : path_connected_space (linear_ordered_add_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_145721 (h0 : uniform_space (has_nndist unsigned)) : separated_space (has_nndist unsigned) := sorry --non-trivial
lemma new_lemma_145722 (h0 : topological_space (add_group unsigned)) : totally_separated_space (add_group unsigned) := sorry --non-trivial
lemma new_lemma_145723 (h0 : ring (normed_field string.iterator_imp)) : rank_condition (normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_145724 (h0 : topological_space (simple_graph environment.implicit_infer_kind)) : sequential_space (simple_graph environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_145725 (h0 : uniform_space (linear_ordered_comm_group_with_zero to_additive.value_type)) : complete_space (linear_ordered_comm_group_with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_145726 (h0 : list (boolean_algebra.core linarith.comp)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_145727 (h0 : functor.add_const (ring (plift num)) (semiring empty)) : @rank_condition.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (ring.{1} (plift.{1} num)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_145728 (h0 : filter (has_nndist (complete_distrib_lattice environment.implicit_infer_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_145729 (h0 : complete_lattice (add_semigroup (option empty))) : is_compactly_generated (add_semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_145730 (h0 : group (complete_semilattice_Sup unsigned)) : group.fg (complete_semilattice_Sup unsigned) := sorry --non-trivial
lemma new_lemma_145731 (h0 : function.extfun Type topological_space) : @normal_space.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_145732 (h0 : uniform_space (has_add (has_neg pos))) : complete_space (has_add (has_neg pos)) := sorry --non-trivial
lemma new_lemma_145733 (h0 : complete_lattice (boolean_algebra.core (finset pos))) : is_compactly_generated (boolean_algebra.core (finset pos)) := sorry --non-trivial
lemma new_lemma_145734 (h0 : group (canonically_ordered_comm_semiring (finset pos))) : normalizer_condition (canonically_ordered_comm_semiring (finset pos)) := sorry --non-trivial
lemma new_lemma_145735 (h0 : topological_space (ordered_cancel_add_comm_monoid congr_arg_kind)) : irreducible_space (ordered_cancel_add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_145736 (h0 : semiring (add_comm_monoid (has_neg (has_neg (has_neg linarith.comp))))) : is_noetherian_ring (add_comm_monoid (has_neg (has_neg (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_145737 (h0 : topological_space (add_group (has_norm (semiring congr_arg_kind)))) : locally_compact_space (add_group (has_norm (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_145738 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_145739 (h1 : topological_space (has_nnnorm (comm_ring reducibility_hints))) : t0_space (has_nnnorm (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_145740 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_145741 (h0 : functor.add_const (list (finset Type)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_145742 (h0 : topological_space (canonically_ordered_monoid pos)) : loc_path_connected_space (canonically_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_145743 (h0 : set (normed_field (mul_one_class (mul_one_class string.iterator_imp)))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_145744 (h0 : ring (has_le (mul_one_class char))) : rank_condition (has_le (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_145745 (h0 : functor.add_const (filter (cancel_monoid ennreal)) num) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_145746 (h0 : add_group (non_unital_non_assoc_semiring (metric_space linarith.comp_source))) : is_add_cyclic (non_unital_non_assoc_semiring (metric_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_145747 (h0 : functor.add_const (topological_space (complete_linear_order unsigned)) unsigned) : @t1_space.{0} (complete_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_linear_order.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_145748 (h0 : function.extfun (finset Type) (has_mem.mem (with_one empty))) : @is_compactly_generated.{0} (with_one.{0} empty) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_one.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_145749 (h0 : function.extfun Type ring) : @is_domain.{0} (partial_order.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (partial_order.{0} num))  := sorry --non-trivial
lemma new_lemma_145750 (h0 : topological_space (distrib (has_nnnorm linarith.ineq))) : totally_disconnected_space (distrib (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_145751 (h2 : topological_space (distrib_lattice fun_info)) : totally_disconnected_space (distrib_lattice fun_info) := sorry --non-trivial
lemma new_lemma_145752 (h0 : functor.add_const (uniform_space (ring Type)) pos) : @complete_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_145753 (h0 : group (cancel_monoid ennreal)) : group.fg (cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_145754 (h0 : topological_space (complete_semilattice_Sup empty)) : path_connected_space (complete_semilattice_Sup empty) := sorry --non-trivial
lemma new_lemma_145755 (h0 : add_group (generalized_boolean_algebra name)) : is_add_cyclic (generalized_boolean_algebra name) := sorry --non-trivial
lemma new_lemma_145756 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} h0 (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_145757 (h0 : functor.add_const (complete_lattice (filter empty)) empty) : is_compactly_generated (filter empty) := sorry --non-trivial
lemma new_lemma_145758 (h0 : topological_space (semiring (has_norm linarith.comp))) : totally_disconnected_space (semiring (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_145759 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_145760 (h0 : topological_space (bin_tree empty)) : normal_space (bin_tree empty) := sorry --non-trivial
lemma new_lemma_145761 (h0 : functor.add_const (uniform_space (finset name)) Type) : @complete_space.{0} (finset.{0} name) (@functor.add_const.run.{0 1} (uniform_space.{0} (finset.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_145762 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) linarith.comp) : @topological_space.separable_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_145763 (h0 : ring (complete_semilattice_Sup char)) : is_domain (complete_semilattice_Sup char) := sorry --non-trivial
lemma new_lemma_145764 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_145765 (h2 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h2 (random_gen.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_145766 (h0 : topological_space (ordered_comm_ring (has_pos_part (ring linarith.comp)))) : topological_space.separable_space (ordered_comm_ring (has_pos_part (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_145767 (h0 : has_mem.mem (with_one (has_norm num)) has_emptyc.emptyc) : @is_domain.{0} (with_one.{0} (has_norm.{0} num)) (@finset.pi.empty.{1 0} Type ring.{0} (with_one.{0} (has_norm.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_145768 (h0 : topological_space (has_div linarith.ineq) -> Prop) (h1 : Exists (fun (x : topological_space (has_div linarith.ineq)), h0 x)) : @path_connected_space.{0} (has_div.{0} linarith.ineq) (@classical.some.{1} (topological_space.{0} (has_div.{0} linarith.ineq)) h0 h1)  := sorry --non-trivial
lemma new_lemma_145769 (h1 : not (topological_space (topological_space char) -> false)) : @path_connected_space.{0} (topological_space.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (topological_space.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_145770 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (bin_tree.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (bin_tree.{0} empty))  := sorry --non-trivial
lemma new_lemma_145771 (h0 : complete_lattice (has_div (mul_one_class (mul_one_class linarith.ineq)))) : is_compactly_generated (has_div (mul_one_class (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_145772 (h0 : functor.add_const (topological_space (has_neg_part Type)) name) : @t1_space.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg_part.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_145773 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_145774 (h0 : add_comm_semigroup char -> add_comm_semigroup char -> Prop) (h1 : filter (add_comm_semigroup char)) : filter.is_bounded h0 h1 := sorry --non-trivial
lemma new_lemma_145775 (h0 : group (has_add (sub_neg_monoid real))) : normalizer_condition (has_add (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_145776 (h0 : topological_space (has_add congr_arg_kind)) : preconnected_space (has_add congr_arg_kind) := sorry --non-trivial
lemma new_lemma_145777 (h0 : add_monoid (has_emptyc (has_norm (has_norm empty)))) : add_monoid.fg (has_emptyc (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_145778 (h0 : complete_lattice (preorder (semiring (semiring num)))) : is_compactly_generated (preorder (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_145779 (h0 : topological_space (comm_group (comm_group ennreal))) : normal_space (comm_group (comm_group ennreal)) := sorry --non-trivial
lemma new_lemma_145780 (h0 : topological_space (has_add (comm_group (has_add (has_neg_part name))))) : t0_space (has_add (comm_group (has_add (has_neg_part name)))) := sorry --non-trivial
lemma new_lemma_145781 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_compactly_generated.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_145782 (h0 : complete_lattice (has_top congr_arg_kind)) : is_atomistic (has_top congr_arg_kind) := sorry --non-trivial
lemma new_lemma_145783 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_145784 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @t0_space.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_145785 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) Type) : @discrete_topology.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_145786 (h0 : functor.add_const (functor.add_const (complete_lattice auto.case_option) empty) unsigned) : @is_atomistic.{0} auto.case_option (@functor.add_const.run.{0 0} (complete_lattice.{0} auto.case_option) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (complete_lattice.{0} auto.case_option) empty) unsigned h0))  := sorry --non-trivial
lemma new_lemma_145787 (h0 : topological_space (has_neg (has_add pos))) : locally_compact_space (has_neg (has_add pos)) := sorry --non-trivial
lemma new_lemma_145788 (h0 : ordered_add_comm_monoid (canonically_ordered_comm_semiring (has_Inf (ring linarith.comp)))) : archimedean (canonically_ordered_comm_semiring (has_Inf (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_145789 (h0 : ring (semiring linarith.comp)) : rank_condition (semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_145790 (h0 : functor.add_const (group (has_nndist linarith.comp)) (has_neg (mul_one_class linarith.comp))) : @is_cyclic.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} linarith.comp)) (has_neg.{0} (mul_one_class.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_145791 (h0 : topological_space (pseudo_metric_space (option (option (option unsigned))))) : t1_space (pseudo_metric_space (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_145792 (h0 : topological_space (has_one (semiring (has_norm (has_norm empty))))) : totally_separated_space (has_one (semiring (has_norm (has_norm empty)))) := sorry --non-trivial
lemma new_lemma_145793 (h0 : functor.add_const (topological_space (has_to_string name)) name) : @path_connected_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_145794 (h0 : topological_space (simple_graph (boolean_algebra.core pos))) : sequential_space (simple_graph (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_145795 (h0 : topological_space (has_neg (ring Type))) : discrete_topology (has_neg (ring Type)) := sorry --non-trivial
lemma new_lemma_145796 (h0 : topological_space (measurable_space (semiring num))) : path_connected_space (measurable_space (semiring num)) := sorry --non-trivial
lemma new_lemma_145797 (h0 : topological_space (normed_group (semiring (semiring congr_arg_kind)))) : discrete_topology (normed_group (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_145798 (h0 : topological_space (as_linear_order (option unsigned))) : loc_path_connected_space (as_linear_order (option unsigned)) := sorry --non-trivial
lemma new_lemma_145799 (h0 : functor.comp topological_space add_comm_monoid Type) : @sequential_space.{1} (add_comm_monoid.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} add_comm_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_145800 (h0 : finset (simple_graph (comm_monoid (has_dist (option (option unsigned)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_145801 (h0 : function.extfun Type (functor.add_const (complete_lattice (complete_distrib_lattice ennreal)))) : @complete_lattice.is_Sup_finite_compact.{0} (complete_distrib_lattice.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (complete_distrib_lattice.{0} ennreal)) ennreal (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (complete_distrib_lattice.{0} ennreal))) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_145802 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_145803 (h0 : topological_space (comm_monoid (semiring empty))) : irreducible_space (comm_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_145804 (h0 : functor.add_const (complete_lattice (normed_comm_ring linarith.comp)) linarith.comp) : @is_atomistic.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_145805 (h0 : topological_space (has_zero linarith.comp)) : regular_space (has_zero linarith.comp) := sorry --non-trivial
lemma new_lemma_145806 (h0 : topological_space (has_zero (has_neg Type))) : topological_space.separable_space (has_zero (has_neg Type)) := sorry --non-trivial
lemma new_lemma_145807 (h0 : topological_space (semigroup (boolean_algebra linarith.comp))) : path_connected_space (semigroup (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_145808 (h0 : has_coe (add_comm_semigroup fun_info) Prop) (h1 : add_comm_semigroup fun_info) : @coe_b.{1 1} (add_comm_semigroup.{0} fun_info) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_145809 (h0 : ring (boolean_algebra (has_pos_part name))) : rank_condition (boolean_algebra (has_pos_part name)) := sorry --non-trivial
lemma new_lemma_145810 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (boolean_algebra.core.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_145811 (h0 : functor.add_const (ring (has_inter ennreal)) num) : @is_principal_ideal_ring.{0} (has_inter.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (has_inter.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_145812 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (add_semigroup empty)) := sorry --non-trivial
lemma new_lemma_145813 (h0 : topological_space (fintype (random_gen (random_gen to_additive.value_type)))) : totally_disconnected_space (fintype (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_145814 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem add_group)) : @is_add_cyclic.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_145815 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring linarith.comp)) pos) : @preirreducible_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_145816 (h0 : add_group (add_comm_semigroup (mul_one_class enat))) : is_add_cyclic (add_comm_semigroup (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_145817 (h0 : functor.add_const (topological_space (simple_graph linarith.comp)) linarith.comp) : @sequential_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_145818 (h0 : list (normed_group (random_gen (has_nnnorm linarith.comp_source)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_145819 (h0 : topological_space (canonically_ordered_comm_semiring (cancel_monoid (has_zero name)))) : loc_path_connected_space (canonically_ordered_comm_semiring (cancel_monoid (has_zero name))) := sorry --non-trivial
lemma new_lemma_145820 (h0 : semiring (ring (ring pos))) : is_noetherian_ring (ring (ring pos)) := sorry --non-trivial
lemma new_lemma_145821 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (measure_theory.measure_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measure_theory.measure_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_145822 (h0 : group (finset (ring pos))) : normalizer_condition (finset (ring pos)) := sorry --non-trivial
lemma new_lemma_145823 (h0 : monoid (measurable_space (has_norm fun_info))) : monoid.fg (measurable_space (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_145824 (h0 : fin has_zero.zero) : @monoid.fg.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (monoid.{1} (complete_distrib_lattice.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_145825 (h0 : functor.add_const (topological_space (add_right_cancel_monoid empty)) (semiring (semiring empty))) : @irreducible_space.{0} (add_right_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_right_cancel_monoid.{0} empty)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_145826 (h0 : functor.add_const (add_group (ring Type)) name) : @is_add_cyclic.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_145827 (h0 : topological_space (semigroup (has_add linarith.comp))) : regular_space (semigroup (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_145828 (h0 : topological_space (mul_one_class string.iterator_imp)) : totally_disconnected_space (mul_one_class string.iterator_imp) := sorry --non-trivial
lemma new_lemma_145829 (h0 : topological_space (has_one fun_info)) : t0_space (has_one fun_info) := sorry --non-trivial
lemma new_lemma_145830 (h0 : list (add_group congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_145831 (h0 : fin has_zero.zero) : @normal_space.{0} (normed_lattice_add_comm_group.{0} (has_Inf.{0} pos)) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_lattice_add_comm_group.{0} (has_Inf.{0} pos)))  := sorry --non-trivial
lemma new_lemma_145832 (h0 : add_group (comm_group (has_neg linarith.comp))) : is_add_cyclic (comm_group (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_145833 (h0 : add_monoid (with_one (has_one (semiring (has_norm empty))))) : add_monoid.fg (with_one (has_one (semiring (has_norm empty)))) := sorry --non-trivial
lemma new_lemma_145834 (h0 : complete_lattice (has_ssubset (mul_one_class string.iterator_imp))) : complete_lattice.is_Sup_finite_compact (has_ssubset (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_145835 (h0 : topological_space (option (semiring (semiring (ordered_cancel_comm_monoid (semiring empty)))))) : totally_separated_space (option (semiring (semiring (ordered_cancel_comm_monoid (semiring empty))))) := sorry --non-trivial
lemma new_lemma_145836 (h0 : topological_space (boolean_algebra (finset pos))) : topological_space.separable_space (boolean_algebra (finset pos)) := sorry --non-trivial
lemma new_lemma_145837 (h0 : filter (has_zero (comm_group (comm_group (comm_group environment.implicit_infer_kind))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_145838 (h0 : finset (canonically_ordered_add_monoid num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_145839 (h1 : not (topological_space (complete_linear_order string_imp) -> false)) : @t0_space.{0} (complete_linear_order.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_linear_order.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_145840 (h0 : finset (normed_comm_ring linarith.comp)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_145841 (h0 : topological_space (comm_semigroup linarith.comp)) : preirreducible_space (comm_semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_145842 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_145843 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) (has_add name)) : @preconnected_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_145844 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_145845 (h0 : function.extfun Type (functor.add_const (uniform_space (add_cancel_monoid unsigned)))) : @separated_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} unsigned)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} unsigned))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_145846 (h0 : functor.add_const (function.extfun Type finset) Type) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_145847 (h0 : functor.add_const (topological_space (ring pos)) (has_Inf linarith.comp)) : @regular_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_145848 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (canonically_ordered_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_145849 (h0 : add_group (has_pos_part (sub_neg_monoid real))) : is_add_cyclic (has_pos_part (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_145850 (h0 : measurable_space (simple_graph string.iterator_imp)) (h1 : measure_theory.measure (simple_graph string.iterator_imp)) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_145851 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @discrete_topology.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_145852 (h0 : has_le linarith.comp_source) (h1 : linarith.comp_source) : is_max h1 := sorry --non-trivial
lemma new_lemma_145853 (h0 : ring (has_to_string (ring Type))) : is_domain (has_to_string (ring Type)) := sorry --non-trivial
lemma new_lemma_145854 (h0 : functor.add_const (topological_space (normed_comm_ring name)) environment.implicit_infer_kind) : @irreducible_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_145855 (h0 : ring (has_union (has_union (metric_space unsigned)))) : strong_rank_condition (has_union (has_union (metric_space unsigned))) := sorry --non-trivial
lemma new_lemma_145856 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (canonically_ordered_comm_semiring.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} h0 (canonically_ordered_comm_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_145857 (h0 : has_mem.mem (complete_semilattice_Sup to_additive.value_type) has_emptyc.emptyc) : @is_principal_ideal_ring.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type ring.{0} (complete_semilattice_Sup.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_145858 (h0 : topological_space (random_gen (has_norm (has_norm empty)))) : totally_separated_space (random_gen (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_145859 (h0 : prod (left_cancel_semigroup congr_arg_kind) (left_cancel_semigroup congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_145860 (h0 : group name) : is_cyclic name := sorry --non-trivial
lemma new_lemma_145861 (h0 : functor.add_const (add_monoid (pseudo_metric_space ennreal)) pos) : @add_monoid.fg.{0} (pseudo_metric_space.{0} ennreal) (@functor.add_const.run.{0 0} (add_monoid.{0} (pseudo_metric_space.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_145862 (h0 : ring (bin_tree (partial_order unsigned))) : rank_condition (bin_tree (partial_order unsigned)) := sorry --non-trivial
lemma new_lemma_145863 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (filter.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (filter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_145864 (h0 : uniform_space (boolean_algebra (finset (finset Type)))) : complete_space (boolean_algebra (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_145865 (h0 : functor.add_const Prop (linear_ordered_field ennreal)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_145866 (h0 : add_monoid (semigroup (has_neg (mul_one_class Type)))) : add_monoid.fg (semigroup (has_neg (mul_one_class Type))) := sorry --non-trivial
lemma new_lemma_145867 (h0 : functor.add_const (ring (ordered_comm_monoid Type)) (ring name)) : @is_domain.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (ordered_comm_monoid.{1} Type)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_145868 (h0 : complete_lattice (mul_one_class environment.projection_info)) : complete_lattice.is_Sup_finite_compact (mul_one_class environment.projection_info) := sorry --non-trivial
lemma new_lemma_145869 (h0 : group (semigroup (finset Type))) : normalizer_condition (semigroup (finset Type)) := sorry --non-trivial
lemma new_lemma_145870 (h0 : topological_space (has_top (has_norm (has_top congr_arg_kind)))) : path_connected_space (has_top (has_norm (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_145871 (h0 : function.extfun Type ring) : @is_domain.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_145872 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (measurable_space.dynkin_system.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.dynkin_system.{0} empty))  := sorry --non-trivial
lemma new_lemma_145873 (h0 : add_group (has_lt linarith.comp_source)) : is_add_cyclic (has_lt linarith.comp_source) := sorry --non-trivial
lemma new_lemma_145874 (h0 : topological_space (add_cancel_monoid (has_neg_part (comm_group Type)))) : t1_space (add_cancel_monoid (has_neg_part (comm_group Type))) := sorry --non-trivial
lemma new_lemma_145875 (h0 : group (ordered_ring (semiring empty))) : group.fg (ordered_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_145876 (h0 : functor.comp ring ring name) : @is_principal_ideal_ring.{0} (ring.{0} name) (@functor.comp.run.{0 0 0} ring.{0} ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_145877 (h0 : function.extfun Type ring) : @rank_condition.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_145878 (h0 : functor.add_const (ring (has_pos_part name)) (has_neg linarith.comp)) : @rank_condition.{0} (has_pos_part.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_pos_part.{0} name)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_145879 (h0 : topological_space (has_append fun_info)) : path_connected_space (has_append fun_info) := sorry --non-trivial
lemma new_lemma_145880 (h0 : topological_space (canonically_linear_ordered_monoid unsigned)) : t0_space (canonically_linear_ordered_monoid unsigned) := sorry --non-trivial
lemma new_lemma_145881 (h0 : topological_space (semi_normed_comm_ring (mul_one_class reducibility_hints))) : path_connected_space (semi_normed_comm_ring (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_145882 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (monoid pos)) := sorry --non-trivial
lemma new_lemma_145883 (h0 : ring (div_inv_monoid (has_ssubset linarith.comp_source))) : rank_condition (div_inv_monoid (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_145884 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_145885 (h0 : add_monoid (uniform_space znum)) : add_monoid.fg (uniform_space znum) := sorry --non-trivial
lemma new_lemma_145886 (h0 : ordered_comm_monoid (simple_graph (has_pos_part (finset pos)))) : has_exists_mul_of_le (simple_graph (has_pos_part (finset pos))) := sorry --non-trivial
lemma new_lemma_145887 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (measurable_space unsigned)) := sorry --non-trivial
lemma new_lemma_145888 (h0 : add_monoid (left_cancel_semigroup num)) : add_monoid.fg (left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_145889 (h2 : function.extfun Type topological_space) : @totally_separated_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} h2 congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_145890 (h0 : monoid (add_cancel_monoid (add_cancel_monoid (finset (has_add (has_add pos)))))) : monoid.fg (add_cancel_monoid (add_cancel_monoid (finset (has_add (has_add pos))))) := sorry --non-trivial
lemma new_lemma_145891 (h0 : ordered_add_comm_monoid (canonically_ordered_monoid Type)) : archimedean (canonically_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_145892 (h0 : semiring (has_Inf (has_add Type))) : is_noetherian_ring (has_Inf (has_add Type)) := sorry --non-trivial
lemma new_lemma_145893 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_145894 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_inv.{0} string_imp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_inv.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_145895 (h0 : functor.add_const (ordered_add_comm_monoid (ring Type)) pos) : @archimedean.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_145896 (h0 : add_monoid (comm_semigroup (has_add (has_bot (has_add (has_Inf real)))))) : add_monoid.fg (comm_semigroup (has_add (has_bot (has_add (has_Inf real))))) := sorry --non-trivial
lemma new_lemma_145897 (h0 : complete_lattice (distrib_lattice (random_gen to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (distrib_lattice (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_145898 (h0 : topological_space (has_add (has_Inf (has_Inf (has_add linarith.comp))))) : preirreducible_space (has_add (has_Inf (has_Inf (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_145899 (h0 : functor.add_const (complete_lattice (semigroup ennreal)) ennreal) : @is_compactly_generated.{0} (semigroup.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_145900 (h0 : function.extfun nat fin) : @normal_space.{0} (ordered_comm_monoid.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_145901 (h0 : ring (normed_field environment.projection_info)) : rank_condition (normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_145902 (h0 : has_mem.mem (with_one linarith.comp) has_emptyc.emptyc) : @normal_space.{0} (with_one.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_145903 (h1 : has_mem.mem (random_gen to_additive.value_type) has_emptyc.emptyc) : @is_atomistic.{0} (random_gen.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} to_additive.value_type) h1)  := sorry --non-trivial
lemma new_lemma_145904 (h0 : functor.add_const (topological_space (pseudo_metric_space unsigned)) ennreal) : @preirreducible_space.{0} (pseudo_metric_space.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} unsigned)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_145905 (h0 : ring (has_to_string (add_comm_monoid pos))) : rank_condition (has_to_string (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_145906 (h2 : not (complete_lattice (distrib_lattice fun_info) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (distrib_lattice.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (distrib_lattice.{0} fun_info)) h2)  := sorry --non-trivial
lemma new_lemma_145907 (h0 : has_mul (normed_lattice_add_comm_group pos)) (h1 : normed_lattice_add_comm_group pos) : is_right_regular h1 := sorry --non-trivial
lemma new_lemma_145908 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_bot.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_145909 (h0 : not (ring (mul_zero_class congr_arg_kind) -> false)) : @strong_rank_condition.{0} (mul_zero_class.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (mul_zero_class.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_145910 (h0 : topological_space (has_to_string congr_arg_kind)) : t1_space (has_to_string congr_arg_kind) := sorry --non-trivial
lemma new_lemma_145911 (h0 : has_mem.mem (linear_ordered_semiring linarith.comp) has_emptyc.emptyc) : @normal_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_145912 (h0 : list (with_one (has_nnnorm string_imp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_145913 (h0 : uniform_space (boolean_algebra.core (has_neg_part (ring Type)))) : complete_space (boolean_algebra.core (has_neg_part (ring Type))) := sorry --non-trivial
lemma new_lemma_145914 (h0 : has_mem.mem uniform_space has_emptyc.emptyc) : @complete_space.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} h0) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_145915 (h0 : functor.add_const (list (has_zero environment.implicit_infer_kind)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_145916 (h0 : ring (distrib_lattice (has_norm (distrib_lattice (with_bot to_additive.value_type))))) : rank_condition (distrib_lattice (has_norm (distrib_lattice (with_bot to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_145917 (h0 : function.extfun Type filter) (h1 : has_norm empty -> filter (has_norm (has_top (semiring (semiring (semiring (semiring (has_norm linarith.comp)))))))) : filter.ne_bot (filter.limsup (function.extfun_app h0 (has_norm empty)) h1) := sorry --non-trivial
lemma new_lemma_145918 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (canonically_ordered_comm_semiring.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (canonically_ordered_comm_semiring.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_145919 (h0 : topological_space (monoid empty)) : totally_disconnected_space (monoid empty) := sorry --non-trivial
lemma new_lemma_145920 (h0 : not (topological_space (measure_theory.measure_space unsigned) -> false)) : @preirreducible_space.{0} (measure_theory.measure_space.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (measure_theory.measure_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_145921 (h0 : monoid (random_gen (has_top to_additive.value_type))) : monoid.fg (random_gen (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_145922 (h0 : group (complete_distrib_lattice linarith.comp)) : is_cyclic (complete_distrib_lattice linarith.comp) := sorry --non-trivial
lemma new_lemma_145923 (h0 : has_mem.mem linarith.comp has_emptyc.emptyc) : @path_connected_space.{0} linarith.comp (@finset.pi.empty.{1 0} Type topological_space.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_145924 (h0 : uniform_space (has_append fun_info)) : complete_space (has_append fun_info) := sorry --non-trivial
lemma new_lemma_145925 (h0 : fin has_zero.zero) : @archimedean.{0} (generalized_boolean_algebra.{0} real) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (generalized_boolean_algebra.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_145926 (h0 : topological_space (has_one (semiring (semiring (has_top num))))) : totally_disconnected_space (has_one (semiring (semiring (has_top num)))) := sorry --non-trivial
lemma new_lemma_145927 (h0 : uniform_space (generalized_boolean_algebra (ordered_ring (ring linarith.comp)))) : separated_space (generalized_boolean_algebra (ordered_ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_145928 (h0 : prod (has_zero (option (complete_distrib_lattice pos))) (has_zero (option (complete_distrib_lattice pos)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_145929 (h0 : functor.add_const (add_group (generalized_boolean_algebra pos)) Type) : @is_add_cyclic.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (add_group.{0} (generalized_boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_145930 (h0 : functor.add_const (topological_space (complete_distrib_lattice linarith.comp)) name) : @locally_compact_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_145931 (h0 : functor.add_const (add_group (linear_ordered_cancel_comm_monoid empty)) (option empty)) : @is_add_cyclic.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_145932 (h0 : topological_space (normed_group (random_gen num))) : discrete_topology (normed_group (random_gen num)) := sorry --non-trivial
lemma new_lemma_145933 (h2 : set (fun_info -> add_comm_semigroup environment.projection_info)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_145934 (h0 : functor.add_const (add_monoid (normed_comm_ring pos)) Type) : @add_monoid.fg.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (add_monoid.{0} (normed_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_145935 (h0 : function.extfun Type ring) : @is_domain.{0} (has_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_145936 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_145937 (h0 : topological_space (add_group (normed_group (metric_space empty)))) : normal_space (add_group (normed_group (metric_space empty))) := sorry --non-trivial
lemma new_lemma_145938 (h0 : ring (ordered_comm_group (semiring unsigned))) : is_principal_ideal_ring (ordered_comm_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_145939 (h0 : topological_space (add_comm_semigroup (add_comm_semigroup enat))) : topological_space.first_countable_topology (add_comm_semigroup (add_comm_semigroup enat)) := sorry --non-trivial
lemma new_lemma_145940 (h1 : topological_space (id to_additive.value_type)) : locally_compact_space (id to_additive.value_type) := sorry --non-trivial
lemma new_lemma_145941 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_145942 (h0 : functor.add_const (list (cancel_monoid pos)) (finset name)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_145943 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_145944 (h1 : ring (comm_ring (random_gen (has_nnnorm string_imp)))) : is_domain (comm_ring (random_gen (has_nnnorm string_imp))) := sorry --non-trivial
lemma new_lemma_145945 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @loc_path_connected_space.{0} (group_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (group_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_145946 (h1 : not (group (metric_space string_imp) -> false)) : @is_cyclic.{0} (metric_space.{0} string_imp) (@classical.by_contradiction'.{1} (group.{0} (metric_space.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_145947 (h0 : ordered_add_comm_monoid (ordered_comm_ring (sub_neg_monoid Type))) : archimedean (ordered_comm_ring (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_145948 (h0 : ring (id (semiring (semiring (semiring unsigned))))) : is_domain (id (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_145949 (h0 : topological_space (add_left_cancel_monoid (has_nnnorm linarith.comp_source))) : path_connected_space (add_left_cancel_monoid (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_145950 (h0 : function.extfun Type (functor.comp uniform_space has_zero)) : @complete_space.{0} (has_zero.{0} pos) (@functor.comp.run.{0 0 0} uniform_space.{0} has_zero.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} uniform_space.{0} has_zero.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_145951 (h0 : topological_space (has_Inf (has_neg (has_neg linarith.comp)))) : preirreducible_space (has_Inf (has_neg (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_145952 (h0 : prod (monoid empty) (monoid empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_145953 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_145954 (h0 : functor.add_const (topological_space (partial_order num)) num) : @totally_separated_space.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_145955 (h0 : add_group (non_unital_non_assoc_semiring (has_compl to_additive.value_type))) : is_add_cyclic (non_unital_non_assoc_semiring (has_compl to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_145956 (h0 : group (simple_graph num)) : is_cyclic (simple_graph num) := sorry --non-trivial
lemma new_lemma_145957 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_145958 (h0 : topological_space (has_to_string (has_add environment.implicit_infer_kind))) : preirreducible_space (has_to_string (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_145959 (h0 : ring (comm_ring (has_ssubset (has_nnnorm linarith.comp_source)))) : is_domain (comm_ring (has_ssubset (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_145960 (h0 : functor.add_const (function.extfun Type complete_lattice) Type) : @is_compactly_generated.{0} (canonically_ordered_comm_semiring.{0} (finset.{0} name)) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type complete_lattice.{0}) Type h0) (canonically_ordered_comm_semiring.{0} (finset.{0} name)))  := sorry --non-trivial
lemma new_lemma_145961 (h0 : topological_space (has_inv (random_gen (random_gen to_additive.value_type)))) : t0_space (has_inv (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_145962 (h0 : cancel_comm_monoid_with_zero (simple_graph (option unsigned))) : unique_factorization_monoid (simple_graph (option unsigned)) := sorry --non-trivial
lemma new_lemma_145963 (h0 : functor.add_const (uniform_space (bin_tree empty)) congr_arg_kind) : @separated_space.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (bin_tree.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_145964 (h0 : topological_space (complete_semilattice_Sup (has_norm (random_gen linarith.comp_source)))) : irreducible_space (complete_semilattice_Sup (has_norm (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_145965 (h0 : ring (semi_normed_comm_ring (has_nnnorm linarith.ineq))) : rank_condition (semi_normed_comm_ring (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_145966 (h0 : topological_space (add_comm_semigroup (mul_one_class (add_comm_semigroup ereal)))) : totally_disconnected_space (add_comm_semigroup (mul_one_class (add_comm_semigroup ereal))) := sorry --non-trivial
lemma new_lemma_145967 (h0 : not (topological_space (has_top linarith.ineq) -> false)) : @path_connected_space.{0} (has_top.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_145968 (h0 : topological_space (distrib_lattice string_imp)) : totally_separated_space (distrib_lattice string_imp) := sorry --non-trivial
lemma new_lemma_145969 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_145970 (h0 : ring (semigroup (finset name))) : rank_condition (semigroup (finset name)) := sorry --non-trivial
lemma new_lemma_145971 (h2 : set (uniform_space string.iterator_imp)) : set.finite h2 := sorry --non-trivial
lemma new_lemma_145972 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_145973 (h0 : complete_lattice (has_neg (comm_group (comm_group unsigned)))) : is_atomistic (has_neg (comm_group (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_145974 (h0 : list (has_norm char)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_145975 (h2 : group linarith.ineq) : is_cyclic linarith.ineq := sorry --non-trivial
lemma new_lemma_145976 (h0 : ordered_comm_monoid (cancel_monoid (option (option ennreal)))) : has_exists_mul_of_le (cancel_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_145977 (h0 : functor.add_const (ring (boolean_algebra.core pos)) pos) : @rank_condition.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_145978 (h0 : ring (has_lt (mul_one_class char))) : rank_condition (has_lt (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_145979 (h0 : not (topological_space (has_div std_gen) -> false)) : @path_connected_space.{0} (has_div.{0} std_gen) (@classical.by_contradiction'.{1} (topological_space.{0} (has_div.{0} std_gen)) h0)  := sorry --non-trivial
lemma new_lemma_145980 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_145981 (h0 : topological_space (has_Inf (has_nndist name))) : locally_compact_space (has_Inf (has_nndist name)) := sorry --non-trivial
lemma new_lemma_145982 (h0 : add_monoid (has_add (has_neg linarith.comp))) : add_monoid.fg (has_add (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_145983 (h0 : function.extfun (Type 1) complete_lattice) : @is_compactly_generated.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_145984 (h0 : add_monoid (linear_ordered_comm_monoid_with_zero (option (option empty)))) : add_monoid.fg (linear_ordered_comm_monoid_with_zero (option (option empty))) := sorry --non-trivial
lemma new_lemma_145985 (h0 : functor.add_const (add_monoid (complete_linear_order empty)) empty) : @add_monoid.fg.{0} (complete_linear_order.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (complete_linear_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_145986 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_145987 (h0 : topological_space (boolean_algebra (finset (has_pos_part pos)))) : loc_path_connected_space (boolean_algebra (finset (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_145988 (h0 : ring (add_cancel_comm_monoid (mul_one_class (metric_space (mul_one_class char))))) : is_domain (add_cancel_comm_monoid (mul_one_class (metric_space (mul_one_class char)))) := sorry --non-trivial
lemma new_lemma_145989 (h0 : functor.add_const (uniform_space (semigroup Type)) pos) : @complete_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (semigroup.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_145990 (h0 : functor.comp uniform_space ring environment.implicit_infer_kind) : @complete_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} uniform_space.{0} ring.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_145991 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (semigroup.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_145992 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @irreducible_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_145993 (h0 : topological_space (div_inv_monoid (has_nnnorm linarith.comp_source))) : totally_disconnected_space (div_inv_monoid (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_145994 (h0 : function.extfun (Type 1) group) : @group.fg.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_145995 (h0 : group (has_neg (add_cancel_monoid (finset pos)))) : is_cyclic (has_neg (add_cancel_monoid (finset pos))) := sorry --non-trivial
lemma new_lemma_145996 (h0 : filter (has_add (has_add Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_145997 (h0 : add_group (normed_group (has_top linarith.comp_source))) : is_add_cyclic (normed_group (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_145998 (h0 : topological_space (normed_group (random_gen (has_inv fun_info)))) : totally_separated_space (normed_group (random_gen (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_145999 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_146000 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @preirreducible_space.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_146001 (h0 : list (ring linarith.comp)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_146002 (h0 : topological_space (mul_one_class (mul_one_class (normed_field char)))) : path_connected_space (mul_one_class (mul_one_class (normed_field char))) := sorry --non-trivial
lemma new_lemma_146003 (h0 : filter (add_cancel_monoid (has_add (comm_group unsigned)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_146004 (h0 : function.extfun nat fin) : @loc_path_connected_space.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (comm_semigroup.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_146005 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_cancel_monoid Type)) pos) : @unique_factorization_monoid.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (add_cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_146006 (h0 : functor.add_const (uniform_space (add_cancel_monoid linarith.comp)) (has_Inf linarith.comp)) : @separated_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} linarith.comp)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_146007 (h0 : functor.add_const (finset (semigroup pos)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_146008 (h0 : has_mem.mem real.angle has_emptyc.emptyc) : @group.fg.{0} real.angle (@finset.pi.empty.{1 0} Type group.{0} real.angle h0)  := sorry --non-trivial
lemma new_lemma_146009 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (free_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (free_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_146010 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_146011 (h0 : uniform_space (normed_lattice_add_comm_group (has_neg real))) : separated_space (normed_lattice_add_comm_group (has_neg real)) := sorry --non-trivial
lemma new_lemma_146012 (h3 : topological_space (with_one linarith.comp_source)) : path_connected_space (with_one linarith.comp_source) := sorry --non-trivial
lemma new_lemma_146013 (h0 : functor.add_const (function.extfun Type add_monoid) (ring Type)) : @add_monoid.fg.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_monoid.{0}) (ring.{1} Type) h0) (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_146014 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_146015 (h2 : topological_space (add_comm_semigroup enat)) (h3 : preorder (add_comm_semigroup enat)) : order_topology (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_146016 (h0 : functor.comp complete_lattice add_comm_monoid Type) : @is_compactly_generated.{1} (add_comm_monoid.{1} Type) (@functor.comp.run.{1 1 1} complete_lattice.{1} add_comm_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_146017 (h0 : uniform_space (has_lt string_imp)) : complete_space (has_lt string_imp) := sorry --non-trivial
lemma new_lemma_146018 (h0 : list (semigroup (boolean_algebra (boolean_algebra.core name)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_146019 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @discrete_topology.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_146020 (h0 : cancel_comm_monoid_with_zero (complete_semilattice_Sup (semiring unsigned))) : unique_factorization_monoid (complete_semilattice_Sup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_146021 (h0 : topological_space (random_gen (random_gen (has_nnnorm linarith.ineq)))) : t0_space (random_gen (random_gen (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_146022 (h0 : functor.add_const (function.extfun (Type 1) topological_space) environment.implicit_infer_kind) : @locally_compact_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) environment.implicit_infer_kind h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_146023 (h0 : functor.add_const (filter (ring name)) (boolean_algebra (has_add Type))) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_146024 (h0 : complete_lattice (id (semiring congr_arg_kind))) : is_compactly_generated (id (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_146025 (h0 : functor.add_const (finset (cancel_monoid environment.implicit_infer_kind)) (has_add pos)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_146026 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (comm_semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (comm_semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_146027 (h0 : functor.add_const (topological_space (has_add linarith.comp)) pos) : @sequential_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_146028 (h0 : topological_space (boolean_algebra (finset linarith.comp))) : t0_space (boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_146029 (h0 : fin has_zero.zero) : @path_connected_space.{0} (add_comm_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_146030 (h2 : topological_space reducibility_hints) : totally_disconnected_space reducibility_hints := sorry --non-trivial
lemma new_lemma_146031 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_146032 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (complete_distrib_lattice empty)) := sorry --non-trivial
lemma new_lemma_146033 (h0 : add_monoid (pseudo_metric_space congr_arg_kind)) : add_monoid.fg (pseudo_metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_146034 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_146035 (h0 : complete_lattice (ring (option (option unsigned)))) : is_compactly_generated (ring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_146036 (h0 : ring (div_inv_monoid (random_gen (random_gen real)))) : is_domain (div_inv_monoid (random_gen (random_gen real))) := sorry --non-trivial
lemma new_lemma_146037 (h0 : list (ordered_comm_monoid (boolean_algebra.core linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_146038 (h0 : set (fun_info -> fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_146039 (h0 : topological_space (left_cancel_semigroup (semiring (semiring congr_arg_kind)))) : totally_separated_space (left_cancel_semigroup (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_146040 (h0 : fin has_zero.zero) : @discrete_topology.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_pos_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_146041 (h1 : complete_lattice (non_unital_non_assoc_ring fun_info)) : is_compactly_generated (non_unital_non_assoc_ring fun_info) := sorry --non-trivial
lemma new_lemma_146042 (h0 : topological_space nnreal) : irreducible_space nnreal := sorry --non-trivial
lemma new_lemma_146043 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (add_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_146044 (h0 : topological_space (has_nnnorm enat) -> Prop) (h1 : Exists (fun (x : topological_space (has_nnnorm enat)), h0 x)) : @t0_space.{0} (has_nnnorm.{0} enat) (@classical.some.{1} (topological_space.{0} (has_nnnorm.{0} enat)) h0 h1)  := sorry --non-trivial
lemma new_lemma_146045 (h0 : ring (ordered_comm_ring (finset (finset linarith.comp)))) : is_domain (ordered_comm_ring (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_146046 (h0 : group (linear_ordered_semiring (semiring unsigned))) : group.fg (linear_ordered_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_146047 (h0 : complete_lattice (free_add_monoid (option empty))) : complete_lattice.is_Sup_finite_compact (free_add_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_146048 (h1 : complete_lattice (has_top congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (has_top congr_arg_kind) := sorry --non-trivial
lemma new_lemma_146049 (h0 : has_le (add_comm_semigroup enat)) : no_bot_order (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_146050 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_146051 (h0 : functor.add_const (cancel_comm_monoid_with_zero (monoid empty)) ennreal) : @unique_factorization_monoid.{0} (monoid.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (monoid.{0} empty)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_146052 (h0 : group (ordered_comm_ring (ring pos))) : normalizer_condition (ordered_comm_ring (ring pos)) := sorry --non-trivial
lemma new_lemma_146053 (h0 : prod (semiring (semiring congr_arg_kind)) (semiring (semiring congr_arg_kind))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_146054 (h0 : ring (has_nndist (finset (finset (has_zero linarith.comp))))) : rank_condition (has_nndist (finset (finset (has_zero linarith.comp)))) := sorry --non-trivial
lemma new_lemma_146055 (h0 : complete_lattice (has_norm (semiring unsigned))) : is_compactly_generated (has_norm (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_146056 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_146057 (h1 : complete_lattice (add_left_cancel_monoid char)) : complete_lattice.is_Sup_finite_compact (add_left_cancel_monoid char) := sorry --non-trivial
lemma new_lemma_146058 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_146059 (h0 : prod (has_nndist ennreal) (has_nndist ennreal)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_146060 (h0 : finset (metric_space name)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_146061 (h0 : functor.add_const (add_group (ring Type)) Type) : @is_add_cyclic.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (add_group.{1} (ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_146062 (h0 : list (add_comm_monoid (has_add Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_146063 (h0 : finset (canonically_linear_ordered_monoid real)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_146064 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_disconnected_space.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) num)  := sorry --non-trivial
lemma new_lemma_146065 (h0 : list (list linarith.comp)) (h1 : ne h0 list.nil) : palindrome (list.last h0 h1) := sorry --non-trivial
lemma new_lemma_146066 (h3 : topological_space char) : totally_disconnected_space char := sorry --non-trivial
lemma new_lemma_146067 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_146068 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (canonically_ordered_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_146069 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) (ring linarith.comp)) : @t1_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_146070 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_146071 (h0 : functor.add_const (topological_space (comm_group name)) linarith.comp) : @regular_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_146072 (h1 : complete_lattice (random_gen linarith.comp)) : is_atomistic (random_gen linarith.comp) := sorry --non-trivial
lemma new_lemma_146073 (h0 : functor.add_const (group (normed_comm_ring ennreal)) ennreal) : @normalizer_condition.{0} (normed_comm_ring.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_146074 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_146075 (h1 : ring (has_append to_additive.value_type)) : rank_condition (has_append to_additive.value_type) := sorry --non-trivial
lemma new_lemma_146076 (h0 : ring (add_group unsigned)) : is_domain (add_group unsigned) := sorry --non-trivial
lemma new_lemma_146077 (h0 : functor.add_const (function.extfun Type finset) (has_neg (finset Type))) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_146078 (h0 : list (denumerable fun_info)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_146079 (h0 : topological_space (has_bot (has_add pos))) : totally_disconnected_space (has_bot (has_add pos)) := sorry --non-trivial
lemma new_lemma_146080 (h0 : cancel_comm_monoid_with_zero (has_Inf (has_Inf real))) : unique_factorization_monoid (has_Inf (has_Inf real)) := sorry --non-trivial
lemma new_lemma_146081 (h0 : uniform_space (add_cancel_monoid (has_neg (boolean_algebra linarith.comp)))) : separated_space (add_cancel_monoid (has_neg (boolean_algebra linarith.comp))) := sorry --non-trivial
lemma new_lemma_146082 (h0 : functor.add_const (ring (boolean_algebra.core linarith.comp)) Type) : @rank_condition.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (boolean_algebra.core.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_146083 (h1 : ring (fintype (linear_ordered_add_comm_group linarith.comp_source))) : rank_condition (fintype (linear_ordered_add_comm_group linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_146084 (h0 : add_monoid (boolean_algebra.core linarith.comp)) : add_monoid.fg (boolean_algebra.core linarith.comp) := sorry --non-trivial
lemma new_lemma_146085 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) linarith.comp) : @sequential_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_146086 (h0 : functor.add_const (topological_space (free_add_monoid empty)) empty) : @t0_space.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_146087 (h0 : functor.add_const (ordered_comm_monoid (has_Inf pos)) (has_add (has_neg name))) : @has_exists_mul_of_le.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_Inf.{0} pos)) (has_add.{0} (has_neg.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_146088 (h1 : topological_space (has_norm linarith.comp)) : totally_disconnected_space (has_norm linarith.comp) := sorry --non-trivial
lemma new_lemma_146089 (h0 : functor.add_const (topological_space (finset Type)) Type) : @regular_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (finset.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_146090 (h0 : ring (add_comm_monoid (option (option ennreal)))) : is_domain (add_comm_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_146091 (h0 : functor.add_const (add_group (generalized_boolean_algebra linarith.comp)) Type) : @is_add_cyclic.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_group.{0} (generalized_boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_146092 (h0 : ring (has_nndist (finset (finset (has_pos_part linarith.comp))))) : is_principal_ideal_ring (has_nndist (finset (finset (has_pos_part linarith.comp)))) := sorry --non-trivial
lemma new_lemma_146093 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @normal_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_146094 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) Type) : @discrete_topology.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_146095 (h0 : functor.add_const (ring (ring linarith.comp)) (ring (ring (has_neg environment.implicit_infer_kind)))) : @rank_condition.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} linarith.comp)) (ring.{0} (ring.{0} (has_neg.{0} environment.implicit_infer_kind))) h0)  := sorry --non-trivial
lemma new_lemma_146096 (h0 : add_group (linear_ordered_comm_group unsigned)) : is_add_cyclic (linear_ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_146097 (h0 : has_neg (has_compl std_gen)) (h1 : measurable_space (has_compl std_gen)) : has_measurable_neg (has_compl std_gen) := sorry --non-trivial
lemma new_lemma_146098 (h0 : with_bot (ulower (fin has_zero.zero))) (h1 : ne h0 has_bot.bot) : id (matrix.vec_empty (ulower.up (with_bot.unbot h0 h1))) := sorry --non-trivial
lemma new_lemma_146099 (h0 : functor.add_const Prop (has_top unsigned)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_146100 (h0 : topological_space (boolean_algebra (ordered_ring pos))) : loc_path_connected_space (boolean_algebra (ordered_ring pos)) := sorry --non-trivial
lemma new_lemma_146101 (h0 : functor.add_const (finset (finset pos)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_146102 (h0 : has_mem.mem (with_bot to_additive.value_type) has_emptyc.emptyc) : @totally_separated_space.{0} (with_bot.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_146103 (h0 : functor.add_const (ring (boolean_algebra.core Type)) environment.implicit_infer_kind) : @strong_rank_condition.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.core.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_146104 (h0 : functor.add_const (functor.add_const (ordered_comm_monoid pos) pos) (has_add linarith.comp)) : @has_exists_mul_of_le.{0} pos (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} pos) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ordered_comm_monoid.{0} pos) pos) (has_add.{0} linarith.comp) h0))  := sorry --non-trivial
lemma new_lemma_146105 (h0 : topological_space (has_edist (option unsigned))) : path_connected_space (has_edist (option unsigned)) := sorry --non-trivial
lemma new_lemma_146106 (h0 : functor.add_const (topological_space (plift empty)) (semiring empty)) : @irreducible_space.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_146107 (h0 : ring (has_norm empty)) : strong_rank_condition (has_norm empty) := sorry --non-trivial
lemma new_lemma_146108 (h0 : uniform_space (linear_ordered_field empty)) : complete_space (linear_ordered_field empty) := sorry --non-trivial
lemma new_lemma_146109 (h0 : not (topological_space (denumerable char) -> false)) : @t0_space.{0} (denumerable.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_146110 (h0 : group (has_ssubset (random_gen (random_gen char)))) : is_cyclic (has_ssubset (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_146111 (h0 : topological_space (left_cancel_monoid (option (option empty)))) : loc_path_connected_space (left_cancel_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_146112 (h0 : function.extfun Type group) : @is_cyclic.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_146113 (h0 : list (boolean_algebra (has_neg_part (normed_comm_ring pos)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_146114 (h0 : monoid (linear_ordered_field num)) : monoid.fg (linear_ordered_field num) := sorry --non-trivial
lemma new_lemma_146115 (h3 : add_group (has_ssubset fun_info)) : is_add_cyclic (has_ssubset fun_info) := sorry --non-trivial
lemma new_lemma_146116 (h0 : functor.add_const (group (comm_group name)) pos) : @is_simple_group.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_146117 (h0 : topological_space (ordered_ring (semiring congr_arg_kind))) : irreducible_space (ordered_ring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_146118 (h0 : complete_lattice (simple_graph enat)) : complete_lattice.is_Sup_finite_compact (simple_graph enat) := sorry --non-trivial
lemma new_lemma_146119 (h0 : ring (has_nnnorm (mul_one_class string_imp))) : strong_rank_condition (has_nnnorm (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_146120 (h0 : functor.add_const (list (normed_comm_ring linarith.comp)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_146121 (h0 : functor.add_const (functor.add_const (filter Type) environment.implicit_infer_kind) unsigned) : filter.ne_bot (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_146122 (h0 : topological_space (cancel_monoid linarith.comp)) : totally_disconnected_space (cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_146123 (h0 : not (complete_lattice linarith.comp -> false)) : @is_atomistic.{0} linarith.comp (@classical.by_contradiction'.{1} (complete_lattice.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_146124 (h0 : complete_lattice (ordered_cancel_add_comm_monoid pos)) : is_atomistic (ordered_cancel_add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_146125 (h0 : not (add_group (bin_tree empty) -> false)) : @is_add_cyclic.{0} (bin_tree.{0} empty) (@classical.by_contradiction'.{1} (add_group.{0} (bin_tree.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_146126 (h0 : group (add_cancel_monoid (has_to_string pos))) : group.fg (add_cancel_monoid (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_146127 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_146128 (h0 : topological_space (ordered_comm_ring linarith.comp)) : loc_path_connected_space (ordered_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_146129 (h0 : ordered_add_comm_monoid (add_right_cancel_monoid (option (option unsigned)))) : archimedean (add_right_cancel_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_146130 (h0 : cancel_comm_monoid_with_zero (canonically_linear_ordered_monoid linarith.comp)) : unique_factorization_monoid (canonically_linear_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_146131 (h0 : topological_space (comm_group (has_neg_part (cancel_monoid pos)))) : normal_space (comm_group (has_neg_part (cancel_monoid pos))) := sorry --non-trivial
lemma new_lemma_146132 (h0 : uniform_space (has_compl (metric_space linarith.comp_source))) : complete_space (has_compl (metric_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_146133 (h0 : functor.add_const (topological_space (ring unsigned)) environment.implicit_infer_kind) : @t0_space.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_146134 (h0 : uniform_space (boolean_algebra (comm_group Type))) : separated_space (boolean_algebra (comm_group Type)) := sorry --non-trivial
lemma new_lemma_146135 (h1 : not (ring (semi_normed_comm_ring string_imp) -> false)) : @is_domain.{0} (semi_normed_comm_ring.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_comm_ring.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_146136 (h1 : topological_space (non_unital_non_assoc_semiring linarith.comp_source) -> Prop) (h2 : Exists (fun (x : topological_space (non_unital_non_assoc_semiring linarith.comp_source)), h1 x)) : @path_connected_space.{0} (non_unital_non_assoc_semiring.{0} linarith.comp_source) (@classical.some.{1} (topological_space.{0} (non_unital_non_assoc_semiring.{0} linarith.comp_source)) h1 h2)  := sorry --non-trivial
lemma new_lemma_146137 (h0 : functor.add_const (uniform_space (has_to_string pos)) (finset pos)) : @complete_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_to_string.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_146138 (h0 : cancel_comm_monoid_with_zero (boolean_algebra (add_comm_monoid (has_neg_part pos)))) : unique_factorization_monoid (boolean_algebra (add_comm_monoid (has_neg_part pos))) := sorry --non-trivial
lemma new_lemma_146139 (h0 : group (has_to_string linarith.comp)) : is_cyclic (has_to_string linarith.comp) := sorry --non-trivial
lemma new_lemma_146140 (h0 : topological_space (has_add (has_Inf (has_Inf (sub_neg_monoid real))))) : locally_compact_space (has_add (has_Inf (has_Inf (sub_neg_monoid real)))) := sorry --non-trivial
lemma new_lemma_146141 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_146142 (h0 : semiring (has_neg (finset linarith.comp))) : is_noetherian_ring (has_neg (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_146143 (h0 : filter (add_cancel_monoid (finset name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_146144 (h0 : ring (linear_ordered_semiring (random_gen linarith.ineq))) : is_domain (linear_ordered_semiring (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_146145 (h0 : not (topological_space (uniform_space char) -> false)) : @path_connected_space.{0} (uniform_space.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_146146 (h0 : uniform_space (non_assoc_semiring congr_arg_kind)) : separated_space (non_assoc_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_146147 (h0 : ring (bin_tree unsigned)) : rank_condition (bin_tree unsigned) := sorry --non-trivial
lemma new_lemma_146148 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @irreducible_space.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_146149 (h0 : function.extfun Type topological_space) : @regular_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_146150 (h0 : ring (semiring (has_top congr_arg_kind))) : is_domain (semiring (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_146151 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_146152 (h0 : topological_space (has_Sup (semiring (semiring num)))) : irreducible_space (has_Sup (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_146153 (h0 : topological_space (add_semigroup (option (option (option (option empty)))))) : totally_separated_space (add_semigroup (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_146154 (h0 : ring (generalized_boolean_algebra (has_neg (has_neg (ring (has_Inf linarith.comp)))))) : is_domain (generalized_boolean_algebra (has_neg (has_neg (ring (has_Inf linarith.comp))))) := sorry --non-trivial
lemma new_lemma_146155 (h0 : functor.add_const (topological_space (has_nndist Type)) environment.implicit_infer_kind) : @preirreducible_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_146156 (h0 : complete_lattice (canonically_ordered_comm_semiring num)) : is_atomistic (canonically_ordered_comm_semiring num) := sorry --non-trivial
lemma new_lemma_146157 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h1 list) congr_arg_kind) := sorry --non-trivial
lemma new_lemma_146158 (h0 : function.extfun Type ring) : @rank_condition.{0} (omega_complete_partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (omega_complete_partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_146159 (h0 : functor.add_const Prop (ordered_comm_ring (has_Inf (has_add Type)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_146160 (h1 : function.extfun Type list) : list.nodup (function.extfun_app h1 (measurable_space (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_146161 (h0 : complete_lattice (has_bot (has_add (has_add Type)))) : complete_lattice.is_Sup_finite_compact (has_bot (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_146162 (h0 : topological_space (has_to_string pos)) : locally_compact_space (has_to_string pos) := sorry --non-trivial
lemma new_lemma_146163 (h0 : group (boolean_algebra.core environment.implicit_infer_kind)) : is_simple_group (boolean_algebra.core environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_146164 (h1 : uniform_space empty) : separated_space empty := sorry --non-trivial
lemma new_lemma_146165 (h0 : finset (has_zero (boolean_algebra pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_146166 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_146167 (h0 : topological_space (has_top (has_norm (has_inv fun_info)))) : totally_separated_space (has_top (has_norm (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_146168 (h0 : set (mul_one_class enat -> mul_one_class (mul_one_class fun_info))) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_146169 (h0 : uniform_space (add_right_cancel_monoid unsigned)) : complete_space (add_right_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_146170 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_bot.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_bot.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_146171 (h0 : functor.comp (functor.add_const (add_group (semigroup pos))) finset name) : @is_add_cyclic.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} pos)) (finset.{0} name) (@functor.comp.run.{0 0 0} (functor.add_const.{0 0} (add_group.{0} (semigroup.{0} pos))) finset.{0} name h0))  := sorry --non-trivial
lemma new_lemma_146172 (h0 : set (char -> add_comm_semigroup enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_146173 (h1 : complete_lattice (semi_normed_comm_ring reducibility_hints)) : complete_lattice.is_Sup_finite_compact (semi_normed_comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_146174 (h0 : filter (random_gen char)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_146175 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ordered_comm_monoid linarith.comp)) linarith.comp) : @unique_factorization_monoid.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ordered_comm_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_146176 (h0 : group (has_to_string (option ennreal))) : is_simple_group (has_to_string (option ennreal)) := sorry --non-trivial
lemma new_lemma_146177 (h0 : topological_space (has_neg_part (has_add (mul_zero_class Type)))) : irreducible_space (has_neg_part (has_add (mul_zero_class Type))) := sorry --non-trivial
lemma new_lemma_146178 (h1 : complete_lattice (complete_semilattice_Sup to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (complete_semilattice_Sup to_additive.value_type) := sorry --non-trivial
lemma new_lemma_146179 (h0 : functor.add_const (filter (add_cancel_monoid name)) environment.implicit_infer_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_146180 (h0 : filter (complete_linear_order congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_146181 (h0 : functor.add_const (function.extfun Type ring) name) : @strong_rank_condition.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_146182 (h0 : functor.add_const (topological_space (boolean_algebra name)) pos) : @totally_disconnected_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_146183 (h0 : topological_space (ordered_comm_ring (comm_semigroup (sub_neg_monoid real)))) : normal_space (ordered_comm_ring (comm_semigroup (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_146184 (h0 : set (has_ssubset linarith.comp_source)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_146185 (h0 : not (has_mem.mem (measurable_space congr_arg_kind) has_emptyc.emptyc -> false)) : @rank_condition.{0} (measurable_space.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} congr_arg_kind) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} congr_arg_kind) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_146186 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (semigroup empty)) := sorry --non-trivial
lemma new_lemma_146187 (h0 : semiring (has_pos_part (has_Inf name))) : is_noetherian_ring (has_pos_part (has_Inf name)) := sorry --non-trivial
lemma new_lemma_146188 (h0 : topological_space (canonically_ordered_monoid name)) : discrete_topology (canonically_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_146189 (h0 : ring (pseudo_metric_space congr_arg_kind)) : is_domain (pseudo_metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_146190 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_146191 (h0 : add_group (finset (comm_group (comm_group (semigroup environment.implicit_infer_kind))))) : is_add_cyclic (finset (comm_group (comm_group (semigroup environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_146192 (h0 : topological_space (has_add (has_Inf linarith.comp))) : totally_separated_space (has_add (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_146193 (h0 : add_group (has_ssubset (semi_normed_ring std_gen))) : is_add_cyclic (has_ssubset (semi_normed_ring std_gen)) := sorry --non-trivial
lemma new_lemma_146194 (h0 : fin has_zero.zero) : @regular_space.{0} (ordered_comm_ring.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_146195 (h0 : not (complete_lattice (linear_ordered_semiring congr_arg_kind) -> false)) : @is_compactly_generated.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_146196 (h0 : group (has_top (has_top (has_nnnorm (has_nnnorm (has_nnnorm to_additive.value_type)))))) : group.fg (has_top (has_top (has_nnnorm (has_nnnorm (has_nnnorm to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_146197 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) unsigned) : @t1_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_146198 (h0 : topological_space (has_neg_part (has_neg_part name))) : locally_compact_space (has_neg_part (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_146199 (h0 : functor.add_const (topological_space (finset linarith.comp)) (finset pos)) : @discrete_topology.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_146200 (h0 : functor.add_const (finset (has_neg Type)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_146201 (h0 : topological_space (measurable_space (has_top linarith.comp_source))) : normal_space (measurable_space (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_146202 (h0 : functor.add_const (add_monoid (has_neg name)) pos) : @add_monoid.fg.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_neg.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_146203 (h0 : group (measure_theory.measure_space (semiring empty))) : normalizer_condition (measure_theory.measure_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_146204 (h0 : not (topological_space (semiring unsigned) -> false)) : @t0_space.{0} (semiring.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_146205 (h0 : functor.add_const (topological_space (has_neg pos)) linarith.comp) : @totally_separated_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_146206 (h0 : group (has_inv linarith.ineq)) (h1 : not (subgroup (has_inv linarith.ineq) -> false)) : subgroup.saturated (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_146207 (h0 : ring (ordered_comm_monoid (has_Inf Type))) : is_principal_ideal_ring (ordered_comm_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_146208 (h0 : has_mem.mem (comm_group string_imp) has_emptyc.emptyc) : @path_connected_space.{0} (comm_group.{0} string_imp) (@finset.pi.empty.{1 0} Type topological_space.{0} (comm_group.{0} string_imp) h0)  := sorry --non-trivial
lemma new_lemma_146209 (h0 : topological_space (monoid_with_zero unsigned)) : discrete_topology (monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_146210 (h0 : functor.add_const (group (comm_group pos)) environment.implicit_infer_kind) : @normalizer_condition.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_146211 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_146212 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_146213 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_146214 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @path_connected_space.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_146215 (h0 : functor.add_const (topological_space (boolean_algebra Type)) (normed_comm_ring linarith.comp)) : @totally_separated_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) (normed_comm_ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_146216 (h0 : topological_space (normed_group char)) : path_connected_space (normed_group char) := sorry --non-trivial
lemma new_lemma_146217 (h0 : fin has_zero.zero) : @irreducible_space.{0} (has_add.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_146218 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_146219 (h0 : function.extfun Type ring) : is_domain rat := sorry --non-trivial
lemma new_lemma_146220 (h0 : filter (left_cancel_monoid (option (option unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_146221 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (option.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_146222 (h0 : topological_space (normed_lattice_add_comm_group (sub_neg_monoid (ordered_comm_monoid real)))) : irreducible_space (normed_lattice_add_comm_group (sub_neg_monoid (ordered_comm_monoid real))) := sorry --non-trivial
lemma new_lemma_146223 (h0 : group (ordered_comm_monoid (ring linarith.comp))) : group.fg (ordered_comm_monoid (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_146224 (h0 : string.iterator_imp -> string.iterator_imp) : set.finite (function.periodic_pts h0) := sorry --non-trivial
lemma new_lemma_146225 (h0 : topological_space (has_nnnorm (has_nnnorm (has_nnnorm char)))) : totally_disconnected_space (has_nnnorm (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_146226 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @topological_space.separable_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_146227 (h0 : fin has_zero.zero) : @complete_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_146228 (h0 : uniform_space (mul_zero_class (option (mul_zero_class pos)))) : separated_space (mul_zero_class (option (mul_zero_class pos))) := sorry --non-trivial
lemma new_lemma_146229 (h0 : topological_space (add_cancel_monoid (has_pos_part linarith.comp))) : topological_space.separable_space (add_cancel_monoid (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_146230 (h0 : group (ordered_comm_ring (ring linarith.comp))) : normalizer_condition (ordered_comm_ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_146231 (h0 : monoid (mul_zero_class (semiring congr_arg_kind))) : monoid.fg (mul_zero_class (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_146232 (h0 : topological_space (pseudo_metric_space pos)) : preirreducible_space (pseudo_metric_space pos) := sorry --non-trivial
lemma new_lemma_146233 (h0 : filter (complete_linear_order (semiring num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_146234 (h0 : topological_space (semigroup (add_comm_monoid Type))) : totally_disconnected_space (semigroup (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_146235 (h0 : list (normed_group (has_ssubset (has_norm linarith.ineq)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_146236 (h1 : group (normed_field (denumerable to_additive.value_type))) : is_cyclic (normed_field (denumerable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_146237 (h0 : functor.add_const (monoid (plift unsigned)) unsigned) : @monoid.fg.{1} (plift.{1} unsigned) (@functor.add_const.run.{1 0} (monoid.{1} (plift.{1} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_146238 (h0 : topological_space (measure_theory.measure_space linarith.comp)) : locally_compact_space (measure_theory.measure_space linarith.comp) := sorry --non-trivial
lemma new_lemma_146239 (h0 : topological_space (has_neg ennreal)) : locally_compact_space (has_neg ennreal) := sorry --non-trivial
lemma new_lemma_146240 (h0 : functor.comp topological_space cancel_monoid name) : @sequential_space.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_146241 (h0 : complete_lattice (normed_group (has_norm (random_gen fun_info)))) : complete_lattice.is_Sup_finite_compact (normed_group (has_norm (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_146242 (h0 : semiring (canonically_linear_ordered_monoid (sub_neg_monoid real))) : is_noetherian_ring (canonically_linear_ordered_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_146243 (h0 : set (has_ssubset (mul_one_class (mul_one_class linarith.ineq)) -> ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_146244 (h0 : function.extfun Type topological_space) : @normal_space.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_146245 (h0 : uniform_space (semiring (has_norm (has_norm (semiring empty))))) : separated_space (semiring (has_norm (has_norm (semiring empty)))) := sorry --non-trivial
lemma new_lemma_146246 (h0 : ring (distrib fun_info)) : is_domain (distrib fun_info) := sorry --non-trivial
lemma new_lemma_146247 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_146248 (h0 : ring (has_add (has_Inf (ring pos)))) : is_domain (has_add (has_Inf (ring pos))) := sorry --non-trivial
lemma new_lemma_146249 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (linear_ordered_comm_group num)) := sorry --non-trivial
lemma new_lemma_146250 (h0 : has_mem.mem (has_top to_additive.value_type) has_emptyc.emptyc) : @totally_separated_space.{0} (has_top.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_146251 (h0 : functor.add_const (ring (has_nndist Type)) (boolean_algebra name)) : @strong_rank_condition.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_nndist.{1} Type)) (boolean_algebra.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_146252 (h0 : topological_space (semigroup (boolean_algebra.core ennreal))) : regular_space (semigroup (boolean_algebra.core ennreal)) := sorry --non-trivial
lemma new_lemma_146253 (h1 : not (uniform_space (has_compl fun_info) -> false)) : @complete_space.{0} (has_compl.{0} fun_info) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_compl.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_146254 (h0 : functor.add_const (ring (boolean_algebra unsigned)) name) : @is_domain.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_146255 (h2 : topological_space (denumerable to_additive.value_type)) : path_connected_space (denumerable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_146256 (h0 : functor.add_const (complete_lattice (bin_tree unsigned)) unsigned) : @is_compactly_generated.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (bin_tree.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_146257 (h0 : functor.comp topological_space has_nndist unsigned) : @locally_compact_space.{0} (has_nndist.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} unsigned (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} unsigned h0))  := sorry --non-trivial
lemma new_lemma_146258 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @totally_disconnected_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) Type)  := sorry --non-trivial
lemma new_lemma_146259 (h0 : not (topological_space (has_norm congr_arg_kind) -> false)) : @irreducible_space.{0} (has_norm.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_146260 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_146261 (h0 : functor.add_const (function.extfun Type add_group) ennreal) : @is_add_cyclic.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) ennreal h0) (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_146262 (h0 : ring (linear_ordered_semiring linarith.comp)) : strong_rank_condition (linear_ordered_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_146263 (h0 : monoid (ordered_comm_monoid (has_add (ring Type)))) : monoid.fg (ordered_comm_monoid (has_add (ring Type))) := sorry --non-trivial
lemma new_lemma_146264 (h0 : topological_space (measurable_space.dynkin_system empty)) : discrete_topology (measurable_space.dynkin_system empty) := sorry --non-trivial
lemma new_lemma_146265 (h0 : ring (add_cancel_monoid (has_Inf pos))) : is_domain (add_cancel_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_146266 (h0 : functor.add_const (function.extfun Type topological_space) name) : @normal_space.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_146267 (h0 : ordered_comm_ring (sub_neg_monoid Type) -> ordered_comm_ring (sub_neg_monoid Type) -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_146268 (h0 : finset (has_pos_part (has_add (has_add linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_146269 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_146270 (h0 : ring (has_compl string.iterator_imp)) : rank_condition (has_compl string.iterator_imp) := sorry --non-trivial
lemma new_lemma_146271 (h0 : add_group (has_edist (semiring (semiring (semiring (semiring (semiring empty))))))) : is_add_cyclic (has_edist (semiring (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_146272 (h0 : not (function.extfun (finset Type) (has_mem.mem (metric_space empty)) -> false)) : @is_domain.{0} (metric_space.{0} empty) (@finset.pi.empty.{1 0} Type ring.{0} (metric_space.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (metric_space.{0} empty)) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (metric_space.{0} empty))) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_146273 (h0 : functor.add_const (ring (boolean_algebra.core pos)) (has_neg (has_add (ring pos)))) : @is_principal_ideal_ring.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} pos)) (has_neg.{0} (has_add.{0} (ring.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_146274 (h0 : functor.add_const (group (add_group empty)) empty) : @normalizer_condition.{0} (add_group.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (add_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_146275 (h4 : ring (measurable_space num)) : is_domain (measurable_space num) := sorry --non-trivial
lemma new_lemma_146276 (h0 : topological_space (monoid_with_zero pos)) : irreducible_space (monoid_with_zero pos) := sorry --non-trivial
lemma new_lemma_146277 (h0 : topological_space (measurable_space.dynkin_system congr_arg_kind)) : path_connected_space (measurable_space.dynkin_system congr_arg_kind) := sorry --non-trivial
lemma new_lemma_146278 (h0 : add_group (topological_space (has_nnnorm fun_info))) : is_add_cyclic (topological_space (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_146279 (h0 : group (ring (has_Inf (has_add name)))) : normalizer_condition (ring (has_Inf (has_add name))) := sorry --non-trivial
lemma new_lemma_146280 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_146281 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_146282 (h0 : set (ereal -> add_comm_semigroup fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_146283 (h0 : topological_space (boolean_algebra (finset pos))) : discrete_topology (boolean_algebra (finset pos)) := sorry --non-trivial
lemma new_lemma_146284 (h0 : group (semigroup (option unsigned))) : is_cyclic (semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_146285 (h0 : filter (generalized_boolean_algebra (finset linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_146286 (h0 : functor.add_const (function.extfun (Type 1) cancel_comm_monoid_with_zero) linarith.comp) : @unique_factorization_monoid.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1}) linarith.comp h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_146287 (h0 : topological_space (add_comm_monoid (ring name))) : topological_space.separable_space (add_comm_monoid (ring name)) := sorry --non-trivial
lemma new_lemma_146288 (h0 : add_monoid (mul_zero_class (has_nndist pos))) : add_monoid.fg (mul_zero_class (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_146289 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_star num)) := sorry --non-trivial
lemma new_lemma_146290 (h0 : function.extfun Type group) : @group.fg.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_146291 (h1 : function.extfun Type ring) : @strong_rank_condition.{0} (linear_ordered_add_comm_group.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h1 (linear_ordered_add_comm_group.{0} num))  := sorry --non-trivial
lemma new_lemma_146292 (h0 : topological_space (add_cancel_comm_monoid (random_gen (random_gen (random_gen string_imp))))) : t0_space (add_cancel_comm_monoid (random_gen (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_146293 (h0 : functor.add_const (topological_space (preorder num)) (semiring (semiring (semiring (semiring (semiring num)))))) : @irreducible_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} num))))) h0)  := sorry --non-trivial
lemma new_lemma_146294 (h0 : function.extfun Type ring) : @rank_condition.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_146295 (h0 : functor.add_const (add_group (complete_semilattice_Sup empty)) num) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (complete_semilattice_Sup.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_146296 (h0 : topological_space (comm_group (boolean_algebra.core environment.implicit_infer_kind))) : normal_space (comm_group (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_146297 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_146298 (h1 : filter (comm_ring linarith.ineq)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_146299 (h0 : functor.add_const (uniform_space (add_comm_monoid pos)) pos) : @complete_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_comm_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_146300 (h0 : functor.add_const (ring (comm_group pos)) linarith.comp) : @rank_condition.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_146301 (h0 : ring (boolean_algebra (has_add pos))) : rank_condition (boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_146302 (h0 : not (complete_lattice (linear_ordered_add_comm_group reducibility_hints) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_add_comm_group.{0} reducibility_hints) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_add_comm_group.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_146303 (h0 : group (has_edist (semiring (semiring (semiring (semiring empty)))))) : is_cyclic (has_edist (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_146304 (h0 : function.extfun nat fin) : @is_simple_group.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (group.{1} (has_add.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_146305 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring ennreal)) unsigned) : @rank_condition.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_comm_semiring.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_146306 (h0 : functor.add_const (topological_space (ring pos)) name) : @irreducible_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_146307 (h0 : topological_space (has_to_string environment.implicit_infer_kind)) : locally_compact_space (has_to_string environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_146308 (h0 : group (metric_space unsigned)) : is_cyclic (metric_space unsigned) := sorry --non-trivial
lemma new_lemma_146309 (h0 : list (pseudo_metric_space (finset pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_146310 (h0 : topological_space (non_assoc_semiring congr_arg_kind)) : totally_separated_space (non_assoc_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_146311 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_146312 (h0 : finset (has_Sup congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_146313 (h0 : functor.comp complete_lattice has_add (option (option ennreal))) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} (option.{0} (option.{0} ennreal))) (@functor.comp.run.{0 0 0} complete_lattice.{0} has_add.{0} (option.{0} (option.{0} ennreal)) h0)  := sorry --non-trivial
lemma new_lemma_146314 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) environment.implicit_infer_kind) : @totally_disconnected_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_146315 (h0 : not (add_group (has_nnnorm fun_info) -> false)) : @is_add_cyclic.{0} (has_nnnorm.{0} fun_info) (@classical.by_contradiction'.{1} (add_group.{0} (has_nnnorm.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_146316 (h0 : functor.add_const (topological_space (bin_tree unsigned)) num) : @path_connected_space.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_146317 (h0 : semiring (add_comm_monoid (comm_group Type))) : is_noetherian_ring (add_comm_monoid (comm_group Type)) := sorry --non-trivial
lemma new_lemma_146318 (h0 : semiring (canonically_linear_ordered_monoid (ordered_comm_monoid (has_Inf Type)))) : is_noetherian_ring (canonically_linear_ordered_monoid (ordered_comm_monoid (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_146319 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) pos) : @path_connected_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_146320 (h0 : ring (has_pos_part Type)) : is_principal_ideal_ring (has_pos_part Type) := sorry --non-trivial
lemma new_lemma_146321 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @t1_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_146322 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_146323 (h0 : functor.add_const (uniform_space (linear_ordered_comm_group environment.implicit_infer_kind)) Type) : @separated_space.{0} (linear_ordered_comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (uniform_space.{0} (linear_ordered_comm_group.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_146324 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_146325 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_146326 (h0 : functor.add_const (cancel_comm_monoid_with_zero (boolean_algebra.core environment.implicit_infer_kind)) ennreal) : @unique_factorization_monoid.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_146327 (h0 : group (semigroup (has_to_string name))) : group.fg (semigroup (has_to_string name)) := sorry --non-trivial
lemma new_lemma_146328 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_146329 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) name) : @path_connected_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_146330 (h0 : uniform_space (has_ssubset char)) : complete_space (has_ssubset char) := sorry --non-trivial
lemma new_lemma_146331 (h0 : function.extfun Type ring) : @rank_condition.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_146332 (h0 : topological_space (linear_ordered_comm_monoid_with_zero (option empty))) : irreducible_space (linear_ordered_comm_monoid_with_zero (option empty)) := sorry --non-trivial
lemma new_lemma_146333 (h0 : uniform_space (ordered_comm_monoid Type)) : complete_space (ordered_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_146334 (h0 : add_monoid (has_Inf real)) : add_monoid.fg (has_Inf real) := sorry --non-trivial
lemma new_lemma_146335 (h0 : complete_lattice (complete_semilattice_Sup linarith.comp_source)) : is_compactly_generated (complete_semilattice_Sup linarith.comp_source) := sorry --non-trivial
lemma new_lemma_146336 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_146337 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) pos) : @preconnected_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_146338 (h0 : ring (has_one (has_norm (semiring unsigned)))) : rank_condition (has_one (has_norm (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_146339 (h0 : group (add_group (semiring (semiring num)))) : normalizer_condition (add_group (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_146340 (h0 : uniform_space (ordered_comm_ring (ring (ring (ring pos))))) : separated_space (ordered_comm_ring (ring (ring (ring pos)))) := sorry --non-trivial
lemma new_lemma_146341 (h0 : monoid (id string_imp)) : monoid.fg (id string_imp) := sorry --non-trivial
lemma new_lemma_146342 (h0 : has_nndist (ring unsigned) -> has_nndist (ring unsigned) -> Prop) : is_symm (has_nndist (ring unsigned)) h0 := sorry --non-trivial
lemma new_lemma_146343 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @discrete_topology.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_146344 (h0 : add_group (has_nndist (has_to_string name))) : is_add_cyclic (has_nndist (has_to_string name)) := sorry --non-trivial
lemma new_lemma_146345 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @archimedean.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ordered_add_comm_monoid.{0}) (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_146346 (h0 : topological_space (has_compl (has_nnnorm to_additive.value_type))) : path_connected_space (has_compl (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_146347 (h0 : not (uniform_space (distrib (metric_space to_additive.value_type)) -> false)) : @complete_space.{0} (distrib.{0} (metric_space.{0} to_additive.value_type)) (@classical.by_contradiction'.{1} (uniform_space.{0} (distrib.{0} (metric_space.{0} to_additive.value_type))) h0)  := sorry --non-trivial
lemma new_lemma_146348 (h0 : ring (semigroup (has_neg Type))) : is_domain (semigroup (has_neg Type)) := sorry --non-trivial
lemma new_lemma_146349 (h0 : prod (has_emptyc unsigned) (has_emptyc unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_146350 (h0 : topological_space (finset (finset linarith.comp))) : sequential_space (finset (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_146351 (h0 : topological_space (has_edist (semiring empty))) : path_connected_space (has_edist (semiring empty)) := sorry --non-trivial
lemma new_lemma_146352 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) (has_neg linarith.comp)) : @irreducible_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_146353 (h0 : set (semi_normed_comm_ring linarith.ineq)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_146354 (h0 : topological_space (ordered_comm_monoid (has_bot real))) : t1_space (ordered_comm_monoid (has_bot real)) := sorry --non-trivial
lemma new_lemma_146355 (h0 : functor.add_const (ring (has_pos_part Type)) (has_nndist Type)) : @is_principal_ideal_ring.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (has_pos_part.{1} Type)) (has_nndist.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_146356 (h0 : topological_space (canonically_ordered_monoid Type)) : totally_separated_space (canonically_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_146357 (h0 : functor.add_const (ordered_add_comm_monoid (finset name)) linarith.comp) : @archimedean.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (finset.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_146358 (h2 : group (denumerable char)) : is_cyclic (denumerable char) := sorry --non-trivial
lemma new_lemma_146359 (h0 : topological_space (semigroup Type)) : preirreducible_space (semigroup Type) := sorry --non-trivial
lemma new_lemma_146360 (h0 : has_neg (semi_normed_comm_ring to_additive.value_type)) (h1 : measurable_space (semi_normed_comm_ring to_additive.value_type)) : has_measurable_neg (semi_normed_comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_146361 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_146362 (h0 : topological_space (add_comm_semigroup linarith.ineq)) : path_connected_space (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_146363 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) environment.implicit_infer_kind) : @t1_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_146364 (h0 : add_monoid (semigroup (finset (mul_zero_class name)))) : add_monoid.fg (semigroup (finset (mul_zero_class name))) := sorry --non-trivial
lemma new_lemma_146365 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_146366 (h0 : cancel_comm_monoid_with_zero (bin_tree congr_arg_kind)) : unique_factorization_monoid (bin_tree congr_arg_kind) := sorry --non-trivial
lemma new_lemma_146367 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_146368 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_146369 (h0 : set (set (random_gen (random_gen linarith.ineq)))) : is_countably_spanning h0 := sorry --non-trivial
lemma new_lemma_146370 (h0 : not (has_mem.mem topological_space has_emptyc.emptyc -> false)) : @discrete_topology.{0} to_additive.value_type (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_146371 (h0 : cancel_comm_monoid_with_zero (comm_monoid (semiring empty))) : unique_factorization_monoid (comm_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_146372 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) name) : @totally_disconnected_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_146373 (h0 : not (add_group (semi_normed_ring to_additive.value_type) -> false)) : @is_add_cyclic.{0} (semi_normed_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (add_group.{0} (semi_normed_ring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_146374 (h0 : ordered_comm_monoid (finset pos)) : has_exists_mul_of_le (finset pos) := sorry --non-trivial
lemma new_lemma_146375 (h0 : finset (has_nndist (option name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_146376 (h0 : ring (has_compl linarith.comp_source)) : is_domain (has_compl linarith.comp_source) := sorry --non-trivial
lemma new_lemma_146377 (h0 : ring (has_nndist unsigned)) : is_domain (has_nndist unsigned) := sorry --non-trivial
lemma new_lemma_146378 (h0 : complete_lattice (has_add (has_nnnorm fun_info))) : complete_lattice.is_Sup_finite_compact (has_add (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_146379 (h0 : not (group (random_gen congr_arg_kind) -> false)) : @group.fg.{0} (random_gen.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (random_gen.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_146380 (h0 : functor.comp topological_space has_neg_part name) : @t0_space.{0} (has_neg_part.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} name h0)  := sorry --non-trivial
lemma new_lemma_146381 (h1 : set (semi_normed_comm_ring std_gen)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_146382 (h0 : topological_space (add_group (semiring (semiring congr_arg_kind)))) : t0_space (add_group (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_146383 (h0 : functor.comp group semiring unsigned) : @is_cyclic.{0} (semiring.{0} unsigned) (@functor.comp.run.{0 0 0} group.{0} semiring.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_146384 (h0 : complete_lattice (has_compl (has_nnnorm to_additive.value_type))) : is_compactly_generated (has_compl (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_146385 (h0 : topological_space (cancel_monoid (has_neg_part name))) : regular_space (cancel_monoid (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_146386 (h0 : semiring (finset (has_to_string name))) : is_noetherian_ring (finset (has_to_string name)) := sorry --non-trivial
lemma new_lemma_146387 (h0 : cancel_comm_monoid_with_zero (complete_distrib_lattice linarith.comp)) : unique_factorization_monoid (complete_distrib_lattice linarith.comp) := sorry --non-trivial
lemma new_lemma_146388 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (normed_group to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_146389 (h0 : group (comm_group (finset pos))) : group.fg (comm_group (finset pos)) := sorry --non-trivial
lemma new_lemma_146390 (h0 : complete_lattice (simple_graph (mul_one_class fun_info))) : complete_lattice.is_Sup_finite_compact (simple_graph (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_146391 (h0 : fin has_zero.zero) : @separated_space.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (normed_lattice_add_comm_group.{1} Type)) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_146392 (h0 : functor.comp topological_space has_to_string pos) : @preirreducible_space.{0} (has_to_string.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_146393 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : is_compactly_generated (topological_space fun_info) := sorry --non-trivial
lemma new_lemma_146394 (h0 : partial_order (canonically_ordered_monoid (comm_semigroup name))) (h1 : order_top (canonically_ordered_monoid (comm_semigroup name))) : is_coatomic (canonically_ordered_monoid (comm_semigroup name)) := sorry --non-trivial
lemma new_lemma_146395 (h0 : has_mem.mem (has_one linarith.comp) has_emptyc.emptyc) : @t0_space.{0} (has_one.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_146396 (h0 : function.extfun Type (functor.comp ordered_add_comm_monoid option)) : @archimedean.{0} (option.{0} pos) (@functor.comp.run.{0 0 0} ordered_add_comm_monoid.{0} option.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ordered_add_comm_monoid.{0} option.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_146397 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @regular_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_146398 (h0 : topological_space (emetric_space (random_gen linarith.comp_source))) : path_connected_space (emetric_space (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_146399 (h1 : complete_lattice (has_neg string_imp)) : is_compactly_generated (has_neg string_imp) := sorry --non-trivial
lemma new_lemma_146400 (h0 : group (ordered_comm_ring (finset (has_nndist pos)))) : normalizer_condition (ordered_comm_ring (finset (has_nndist pos))) := sorry --non-trivial
lemma new_lemma_146401 (h0 : topological_space (complete_semilattice_Sup linarith.comp_source)) : totally_separated_space (complete_semilattice_Sup linarith.comp_source) := sorry --non-trivial
lemma new_lemma_146402 (h0 : complete_lattice (left_cancel_monoid (option empty))) : is_compactly_generated (left_cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_146403 (h0 : topological_space (cancel_monoid (has_add environment.implicit_infer_kind))) : t1_space (cancel_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_146404 (h2 : complete_lattice (id string_imp)) : complete_lattice.is_Sup_finite_compact (id string_imp) := sorry --non-trivial
lemma new_lemma_146405 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_146406 (h0 : topological_space (normed_group (has_top linarith.ineq))) : totally_separated_space (normed_group (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_146407 (h0 : functor.add_const (finset (has_pos_part pos)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_146408 (h0 : functor.add_const (topological_space (has_zero pos)) Type) : @t1_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_146409 (h0 : topological_space (generalized_boolean_algebra (has_add (has_Inf Type)))) : locally_compact_space (generalized_boolean_algebra (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_146410 (h0 : topological_space (has_norm linarith.comp_source)) (h1 : preorder (has_norm linarith.comp_source)) : order_topology (has_norm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_146411 (h0 : list pos) : palindrome h0 := sorry --non-trivial
lemma new_lemma_146412 (h0 : finset (boolean_algebra.core name)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_146413 (h0 : not (list (encodable (random_gen string_imp)) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_146414 (h0 : topological_space (normed_group congr_arg_kind)) : locally_compact_space (normed_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_146415 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring name)) pos) : @discrete_topology.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_146416 (h0 : topological_space (metric_space (has_norm congr_arg_kind))) : discrete_topology (metric_space (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_146417 (h0 : functor.add_const (topological_space (comm_group unsigned)) (has_star pos)) : @topological_space.separable_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) (has_star.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_146418 (h0 : topological_space (denumerable string_imp)) : locally_compact_space (denumerable string_imp) := sorry --non-trivial
lemma new_lemma_146419 (h0 : functor.add_const (ring (normed_comm_ring pos)) environment.implicit_infer_kind) : @strong_rank_condition.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_146420 (h0 : add_monoid (generalized_boolean_algebra Type)) : add_monoid.fg (generalized_boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_146421 (h0 : functor.add_const (function.extfun Type group) pos) : @group.fg.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_146422 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) Type) : @path_connected_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_146423 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) ennreal) : @loc_path_connected_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_146424 (h0 : group (has_top empty)) : is_cyclic (has_top empty) := sorry --non-trivial
lemma new_lemma_146425 (h0 : fin has_zero.zero) : @is_atomistic.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_146426 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) (has_neg Type)) : @t0_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_146427 (h0 : topological_space (linear_ordered_comm_group_with_zero string.iterator_imp)) (h1 : preorder (linear_ordered_comm_group_with_zero string.iterator_imp)) : order_closed_topology (linear_ordered_comm_group_with_zero string.iterator_imp) := sorry --non-trivial
lemma new_lemma_146428 (h0 : topological_space (with_bot (has_ssubset (random_gen linarith.ineq)))) : irreducible_space (with_bot (has_ssubset (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_146429 (h0 : uniform_space (has_lt (add_comm_semigroup (mul_one_class char)))) : complete_space (has_lt (add_comm_semigroup (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_146430 (h1 : ring (comm_ring (non_unital_non_assoc_semiring fun_info))) : is_domain (comm_ring (non_unital_non_assoc_semiring fun_info)) := sorry --non-trivial
lemma new_lemma_146431 (h0 : topological_space (linear_ordered_cancel_comm_monoid empty)) : preirreducible_space (linear_ordered_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_146432 (h0 : functor.add_const (group congr_arg_kind) linarith.ineq) : @is_cyclic.{0} congr_arg_kind (@functor.add_const.run.{0 0} (group.{0} congr_arg_kind) linarith.ineq h0)  := sorry --non-trivial
lemma new_lemma_146433 (h0 : functor.add_const (topological_space (comm_group pos)) pos) : @normal_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_146434 (h0 : function.extfun Type group) : @group.fg.{0} (has_star.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (has_star.{0} num))  := sorry --non-trivial
lemma new_lemma_146435 (h0 : complete_lattice (has_neg_part (has_add name))) : complete_lattice.is_Sup_finite_compact (has_neg_part (has_add name)) := sorry --non-trivial
lemma new_lemma_146436 (h0 : functor.add_const (topological_space (comm_group name)) Type) : @preirreducible_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_146437 (h1 : has_lt (add_comm_semigroup linarith.ineq)) : no_max_order (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_146438 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{0} (normed_lattice_add_comm_group.{0} real) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (normed_lattice_add_comm_group.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_146439 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_146440 (h0 : topological_space (distrib (comm_ring linarith.comp_source))) : t0_space (distrib (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_146441 (h0 : topological_space (cancel_monoid (has_neg pos))) : preconnected_space (cancel_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_146442 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (add_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (add_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_146443 (h0 : ring (canonically_linear_ordered_monoid (mul_zero_class name))) : rank_condition (canonically_linear_ordered_monoid (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_146444 (h0 : add_group (ordered_comm_monoid (has_Inf (has_Inf real)))) : is_add_cyclic (ordered_comm_monoid (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_146445 (h0 : functor.add_const (add_monoid (add_cancel_monoid linarith.comp)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (add_cancel_monoid.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_146446 (h3 : topological_space (add_comm_semigroup enat)) : topological_space.first_countable_topology (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_146447 (h0 : add_group (semiring (semiring (semiring unsigned)))) : is_add_cyclic (semiring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_146448 (h0 : ordered_add_comm_monoid (has_zero (has_add pos))) : archimedean (has_zero (has_add pos)) := sorry --non-trivial
lemma new_lemma_146449 (h0 : functor.add_const (topological_space (semigroup name)) linarith.comp) : @locally_compact_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_146450 (h0 : topological_space (has_zero empty)) : path_connected_space (has_zero empty) := sorry --non-trivial
lemma new_lemma_146451 (h3 : topological_space (complete_semilattice_Sup (random_gen linarith.ineq))) : t0_space (complete_semilattice_Sup (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_146452 (h0 : topological_space (mul_zero_class empty)) : locally_compact_space (mul_zero_class empty) := sorry --non-trivial
lemma new_lemma_146453 (h0 : monoid (has_to_string (ring (ring Type)))) : monoid.fg (has_to_string (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_146454 (h1 : group (div_inv_monoid fun_info)) : is_cyclic (div_inv_monoid fun_info) := sorry --non-trivial
lemma new_lemma_146455 (h0 : topological_space (monoid (option empty))) : normal_space (monoid (option empty)) := sorry --non-trivial
lemma new_lemma_146456 (h0 : function.extfun nat fin) : @strong_rank_condition.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (canonically_linear_ordered_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_146457 (h0 : list (canonically_ordered_add_monoid (option empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_146458 (h2 : group (has_ssubset linarith.ineq)) : group.fg (has_ssubset linarith.ineq) := sorry --non-trivial
lemma new_lemma_146459 (h0 : functor.add_const (topological_space (has_zero unsigned)) Type) : @t1_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_146460 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (preorder.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (preorder.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_146461 (h0 : functor.comp list has_neg name) : list.nodup (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_146462 (h0 : functor.add_const (filter auto.case_option) (option (option empty))) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_146463 (h0 : complete_lattice (has_norm (has_norm to_additive.value_type))) : is_atomistic (has_norm (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_146464 (h0 : functor.add_const (topological_space (mul_zero_class unsigned)) pos) : @topological_space.separable_space.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_146465 (h0 : functor.add_const (group (generalized_boolean_algebra linarith.comp)) (add_cancel_monoid name)) : @normalizer_condition.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (generalized_boolean_algebra.{0} linarith.comp)) (add_cancel_monoid.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_146466 (h0 : functor.add_const (add_group (complete_distrib_lattice num)) num) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} num) (@functor.add_const.run.{0 0} (add_group.{0} (complete_distrib_lattice.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_146467 (h0 : filter (measurable_space (has_norm (semiring empty)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_146468 (h0 : functor.add_const (add_group (add_cancel_monoid Type)) name) : @is_add_cyclic.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (add_cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_146469 (h0 : functor.add_const (uniform_space (has_Sup num)) congr_arg_kind) : @separated_space.{0} (has_Sup.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_Sup.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_146470 (h0 : uniform_space (simple_graph std_gen)) : complete_space (simple_graph std_gen) := sorry --non-trivial
lemma new_lemma_146471 (h0 : filter (add_group (semiring congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_146472 (h0 : not (uniform_space (linear_ordered_add_comm_group char) -> false)) : @complete_space.{0} (linear_ordered_add_comm_group.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (linear_ordered_add_comm_group.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_146473 (h0 : complete_lattice (linear_ordered_comm_group num)) : is_compactly_generated (linear_ordered_comm_group num) := sorry --non-trivial
lemma new_lemma_146474 (h2 : complete_lattice (has_div char)) : is_compactly_generated (has_div char) := sorry --non-trivial
lemma new_lemma_146475 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_nndist.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} num))  := sorry --non-trivial
lemma new_lemma_146476 (h0 : topological_space (comm_group (has_add unsigned))) : t1_space (comm_group (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_146477 (h2 : preorder linarith.comp_source) (h3 : set linarith.comp_source) : set.ord_connected h3 := sorry --non-trivial
lemma new_lemma_146478 (h0 : functor.comp topological_space has_nndist pos) : @totally_separated_space.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_146479 (h1 : ring (linear_ordered_add_comm_group (has_add (has_add char)))) : rank_condition (linear_ordered_add_comm_group (has_add (has_add char))) := sorry --non-trivial
lemma new_lemma_146480 (h0 : has_mem.mem (has_union num) has_emptyc.emptyc) : @normal_space.{0} (has_union.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_union.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_146481 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_146482 (h0 : complete_lattice (normed_comm_ring (finset pos))) : is_compactly_generated (normed_comm_ring (finset pos)) := sorry --non-trivial
lemma new_lemma_146483 (h0 : topological_space (has_nndist ennreal)) : topological_space.separable_space (has_nndist ennreal) := sorry --non-trivial
lemma new_lemma_146484 (h0 : topological_space (uniform_space to_additive.value_type)) : path_connected_space (uniform_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_146485 (h1 : add_group (simple_graph reducibility_hints)) : is_add_cyclic (simple_graph reducibility_hints) := sorry --non-trivial
lemma new_lemma_146486 (h0 : semiring (linear_ordered_comm_ring unsigned)) : is_noetherian_ring (linear_ordered_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_146487 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_146488 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) linarith.comp) : @has_exists_mul_of_le.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) linarith.comp h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_146489 (h0 : functor.add_const (topological_space (comm_group Type)) linarith.comp) : @t0_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_146490 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @irreducible_space.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (linear_ordered_add_comm_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_146491 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_146492 (h0 : topological_space (linear_ordered_field unsigned)) : locally_compact_space (linear_ordered_field unsigned) := sorry --non-trivial
lemma new_lemma_146493 (h0 : functor.add_const (add_group (boolean_algebra unsigned)) linarith.comp) : @is_add_cyclic.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (boolean_algebra.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_146494 (h0 : complete_lattice (has_top (semiring (semiring unsigned)))) : complete_lattice.is_Sup_finite_compact (has_top (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_146495 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_146496 (h0 : uniform_space (boolean_algebra (has_Inf Type))) : complete_space (boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_146497 (h2 : topological_space (mul_one_class (mul_one_class (mul_one_class (mul_one_class ereal))))) : path_connected_space (mul_one_class (mul_one_class (mul_one_class (mul_one_class ereal)))) := sorry --non-trivial
lemma new_lemma_146498 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_146499 (h0 : ring (add_semigroup (option empty))) : is_principal_ideal_ring (add_semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_146500 (h0 : finset (has_Inf (has_Inf Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_146501 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (pseudo_metric_space.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (pseudo_metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_146502 (h0 : topological_space (has_Inf (has_zero (ring Type)))) : totally_disconnected_space (has_Inf (has_zero (ring Type))) := sorry --non-trivial
lemma new_lemma_146503 (h0 : complete_lattice (has_norm (has_norm num))) : is_atomistic (has_norm (has_norm num)) := sorry --non-trivial
lemma new_lemma_146504 (h0 : ring (has_one empty)) : is_domain (has_one empty) := sorry --non-trivial
lemma new_lemma_146505 (h0 : functor.add_const (function.extfun Type add_group) (has_neg pos)) : @is_add_cyclic.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) (has_neg.{0} pos) h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_146506 (h0 : cancel_comm_monoid_with_zero (boolean_algebra (has_add unsigned))) : unique_factorization_monoid (boolean_algebra (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_146507 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) pos) : @discrete_topology.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_146508 (h0 : list (cancel_monoid Type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_146509 (h0 : add_monoid (pseudo_metric_space (option unsigned))) : add_monoid.fg (pseudo_metric_space (option unsigned)) := sorry --non-trivial
lemma new_lemma_146510 (h0 : topological_space (has_zero (comm_group unsigned))) : t0_space (has_zero (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_146511 (h0 : complete_lattice (normed_lattice_add_comm_group (has_bot pos))) : is_atomistic (normed_lattice_add_comm_group (has_bot pos)) := sorry --non-trivial
lemma new_lemma_146512 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (boolean_algebra.core unsigned)) := sorry --non-trivial
lemma new_lemma_146513 (h0 : group (has_norm (random_gen fun_info))) : normalizer_condition (has_norm (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_146514 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_146515 (h0 : ordered_add_comm_monoid (canonically_ordered_monoid (has_Inf (has_pos_part (ordered_comm_monoid Type))))) : archimedean (canonically_ordered_monoid (has_Inf (has_pos_part (ordered_comm_monoid Type)))) := sorry --non-trivial
lemma new_lemma_146516 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_separated_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (linear_ordered_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_146517 (h0 : uniform_space (add_cancel_monoid unsigned)) : complete_space (add_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_146518 (h0 : ring (with_bot (semiring linarith.comp))) : strong_rank_condition (with_bot (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_146519 (h0 : functor.add_const (topological_space (ring Type)) (finset pos)) : @discrete_topology.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_146520 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @unique_factorization_monoid.{0} (linear_ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) cancel_comm_monoid_with_zero.{0}) (linear_ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_146521 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_146522 (h0 : topological_space (has_emptyc (random_gen linarith.comp_source))) : discrete_topology (has_emptyc (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_146523 (h0 : ring (add_comm_semigroup reducibility_hints)) : is_domain (add_comm_semigroup reducibility_hints) := sorry --non-trivial
lemma new_lemma_146524 (h0 : functor.add_const (topological_space (has_to_string name)) (semigroup linarith.comp)) : @totally_disconnected_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) (semigroup.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_146525 (h0 : not (ring (complete_linear_order congr_arg_kind) -> false)) : @rank_condition.{0} (complete_linear_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (complete_linear_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_146526 (h0 : functor.add_const (complete_lattice (has_inter unsigned)) unsigned) : @is_compactly_generated.{0} (has_inter.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_inter.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_146527 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (linear_order.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} empty)))))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_order.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} empty)))))))  := sorry --non-trivial
lemma new_lemma_146528 (h0 : topological_space (add_cancel_monoid (has_neg (has_Inf Type)))) : locally_compact_space (add_cancel_monoid (has_neg (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_146529 (h0 : topological_space (simple_graph linarith.ineq)) : t0_space (simple_graph linarith.ineq) := sorry --non-trivial
lemma new_lemma_146530 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_146531 (h0 : topological_space (linear_ordered_field (has_to_string ennreal))) : t1_space (linear_ordered_field (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_146532 (h0 : topological_space (normed_field (has_nnnorm (has_nnnorm (random_gen reducibility_hints))))) : t0_space (normed_field (has_nnnorm (has_nnnorm (random_gen reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_146533 (h0 : monoid (has_pos_part (has_pos_part (has_add pos)))) : monoid.fg (has_pos_part (has_pos_part (has_add pos))) := sorry --non-trivial
lemma new_lemma_146534 (h0 : topological_space (normed_group (semiring empty))) : preirreducible_space (normed_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_146535 (h0 : complete_lattice (has_add (sub_neg_monoid pos))) : complete_lattice.is_Sup_finite_compact (has_add (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_146536 (h0 : cancel_comm_monoid_with_zero (finset (option ennreal))) : unique_factorization_monoid (finset (option ennreal)) := sorry --non-trivial
lemma new_lemma_146537 (h0 : functor.add_const (add_group (comm_group environment.implicit_infer_kind)) environment.implicit_infer_kind) : @is_add_cyclic.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_group.{0} (comm_group.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_146538 (h0 : ring (has_nnnorm (random_gen (has_ssubset to_additive.value_type)))) : is_domain (has_nnnorm (random_gen (has_ssubset to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_146539 (h1 : complete_lattice (distrib string.iterator_imp)) : is_compactly_generated (distrib string.iterator_imp) := sorry --non-trivial
lemma new_lemma_146540 (h0 : not (ring (has_one congr_arg_kind) -> false)) : @rank_condition.{0} (has_one.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (has_one.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_146541 (h0 : finset (ring (has_add (ring linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_146542 (h0 : not (topological_space (random_gen reducibility_hints) -> false)) : @path_connected_space.{0} (random_gen.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_146543 (h0 : topological_space (has_append (encodable (random_gen to_additive.value_type)))) : totally_disconnected_space (has_append (encodable (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_146544 (h0 : ring (random_gen num)) : rank_condition (random_gen num) := sorry --non-trivial
lemma new_lemma_146545 (h0 : topological_space (ordered_comm_ring (has_bot Type))) : totally_disconnected_space (ordered_comm_ring (has_bot Type)) := sorry --non-trivial
lemma new_lemma_146546 (h0 : complete_lattice (add_cancel_monoid empty)) : complete_lattice.is_Sup_finite_compact (add_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_146547 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_dist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_dist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_146548 (h0 : functor.add_const (topological_space (has_add pos)) (finset (finset pos))) : @totally_disconnected_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) (finset.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_146549 (h0 : topological_space fun_info) : totally_separated_space fun_info := sorry --non-trivial
lemma new_lemma_146550 (h0 : functor.add_const (topological_space (has_neg unsigned)) linarith.comp) : @path_connected_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_146551 (h0 : set (mul_one_class (mul_one_class (mul_one_class (mul_one_class (add_comm_semigroup enat)))) -> enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_146552 (h0 : filter (canonically_linear_ordered_monoid (option unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_146553 (h0 : functor.add_const (function.extfun Type list) (has_add (boolean_algebra.core Type))) : list.nodup (function.extfun_app (functor.add_const.run h0) (simple_graph pos)) := sorry --non-trivial
lemma new_lemma_146554 (h0 : char -> char -> Prop) (h1 h2 : char) : eqv_gen h0 h1 h2 := sorry --non-trivial
lemma new_lemma_146555 (h0 : topological_space (comm_group (has_add environment.implicit_infer_kind))) : locally_compact_space (comm_group (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_146556 (h0 : topological_space (comm_group (ring environment.implicit_infer_kind))) : regular_space (comm_group (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_146557 (h0 : group (ring ennreal)) : is_cyclic (ring ennreal) := sorry --non-trivial
lemma new_lemma_146558 (h1 : group string_imp) : normalizer_condition string_imp := sorry --non-trivial
lemma new_lemma_146559 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (boolean_algebra.core.{0} (cancel_monoid.{0} ennreal)) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (boolean_algebra.core.{0} (cancel_monoid.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_146560 (h0 : function.extfun Type group) : @group.fg.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_146561 (h0 : group (with_bot (has_norm to_additive.value_type))) : normalizer_condition (with_bot (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_146562 (h0 : functor.add_const (group (cancel_monoid name)) pos) : @is_cyclic.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_146563 (h0 : uniform_space (normed_group congr_arg_kind)) : separated_space (normed_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_146564 (h0 : functor.add_const (function.extfun Type semiring) Type) : @is_noetherian_ring.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type semiring.{0}) Type h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_146565 (h0 : topological_space (comm_ring (random_gen string.iterator_imp))) : totally_disconnected_space (comm_ring (random_gen string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_146566 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_146567 (h0 : topological_space (has_norm (semiring linarith.comp))) : path_connected_space (has_norm (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_146568 (h0 : cancel_comm_monoid_with_zero (has_to_string (complete_lattice (ring linarith.comp)))) : unique_factorization_monoid (has_to_string (complete_lattice (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_146569 (h0 : functor.add_const (finset (normed_comm_ring linarith.comp)) (has_Inf Type)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_146570 (h0 : complete_lattice (has_pos_part empty)) : complete_lattice.is_Sup_finite_compact (has_pos_part empty) := sorry --non-trivial
lemma new_lemma_146571 (h1 : char -> char -> Prop) : is_trans char h1 := sorry --non-trivial
lemma new_lemma_146572 (h0 : functor.add_const (uniform_space (has_zero pos)) Type) : @complete_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_zero.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_146573 (h0 : add_group (canonically_linear_ordered_monoid (ordered_comm_monoid real))) : is_add_cyclic (canonically_linear_ordered_monoid (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_146574 (h0 : function.extfun (Type 1) add_group) : @is_add_cyclic.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} h0 (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_146575 (h0 : function.extfun Type group) : @normalizer_condition.{0} (ring.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (ring.{0} num))  := sorry --non-trivial
lemma new_lemma_146576 (h0 : add_monoid (simple_graph (has_add (has_add Type)))) : add_monoid.fg (simple_graph (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_146577 (h0 : has_mem.mem (has_emptyc linarith.ineq) has_emptyc.emptyc) : @complete_space.{0} (has_emptyc.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_emptyc.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_146578 (h0 : add_group (has_neg pos)) : is_add_cyclic (has_neg pos) := sorry --non-trivial
lemma new_lemma_146579 (h0 : preorder char) (h1 : has_lt (pred_order char)) : no_max_order (pred_order char) := sorry --non-trivial
lemma new_lemma_146580 (h0 : functor.add_const (list (has_to_string linarith.comp)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_146581 (h0 : ring (has_add (has_nndist linarith.comp))) : is_domain (has_add (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_146582 (h1 h2 : list (mul_one_class (mul_one_class std_gen))) : list.subset h1 h2 := sorry --non-trivial
lemma new_lemma_146583 (h0 : topological_space (has_add (normed_comm_ring environment.implicit_infer_kind))) : locally_compact_space (has_add (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_146584 (h0 : has_mem.mem uniform_space has_emptyc.emptyc) : @separated_space.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} h0) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_146585 (h0 : topological_space (has_to_string num)) : loc_path_connected_space (has_to_string num) := sorry --non-trivial
lemma new_lemma_146586 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (with_one.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_146587 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (has_nnnorm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_nnnorm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_146588 (h0 : semiring (finset (has_neg (has_neg linarith.comp)))) : is_noetherian_ring (finset (has_neg (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_146589 (h0 : topological_space (complete_linear_order unsigned)) : discrete_topology (complete_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_146590 (h0 : functor.add_const (topological_space (mul_zero_class unsigned)) empty) : @t0_space.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_146591 (h0 : topological_space (generalized_boolean_algebra (comm_semigroup (sub_neg_monoid real)))) : preirreducible_space (generalized_boolean_algebra (comm_semigroup (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_146592 (h0 : complete_lattice (random_gen (mul_one_class (mul_one_class char)))) : complete_lattice.is_Sup_finite_compact (random_gen (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_146593 (h0 : function.extfun nat fin) : @preconnected_space.{0} (sub_neg_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_146594 (h0 : functor.add_const (topological_space (finset Type)) (finset Type)) : @path_connected_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (finset.{1} Type)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_146595 (h0 : list (add_cancel_monoid (has_nndist (has_neg_part (finset ennreal))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_146596 (h0 : group (add_cancel_monoid (finset (normed_comm_ring pos)))) : normalizer_condition (add_cancel_monoid (finset (normed_comm_ring pos))) := sorry --non-trivial
lemma new_lemma_146597 (h0 : functor.add_const (complete_lattice (has_Sup unsigned)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_Sup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_146598 (h0 : functor.add_const (ring (comm_group Type)) (has_neg_part Type)) : @rank_condition.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (comm_group.{1} Type)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_146599 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_146600 (h0 : complete_lattice (has_sub (semiring empty))) : is_compactly_generated (has_sub (semiring empty)) := sorry --non-trivial
lemma new_lemma_146601 (h0 : function.extfun Type topological_space) : @t1_space.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_146602 (h0 : ring (bin_tree (semiring (semiring (semiring (semiring num)))))) : rank_condition (bin_tree (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_146603 (h0 : functor.add_const Prop (comm_group (has_add (boolean_algebra name)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_146604 (h0 : complete_lattice (has_norm linarith.comp)) : is_compactly_generated (has_norm linarith.comp) := sorry --non-trivial
lemma new_lemma_146605 (h3 : ring (denumerable (random_gen (random_gen string_imp)))) : is_domain (denumerable (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_146606 (h0 : topological_space (id (with_bot string_imp))) : totally_separated_space (id (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_146607 (h0 : ring (finset (finset (finset (finset pos))))) : is_principal_ideal_ring (finset (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_146608 (h0 : topological_space (add_comm_semigroup (mul_one_class reducibility_hints))) : totally_disconnected_space (add_comm_semigroup (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_146609 (h0 : not (topological_space (linear_ordered_semiring linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_146610 (h0 : function.extfun Type topological_space) : @t0_space.{0} (ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_146611 (h0 : function.extfun Type group) : @group.fg.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_146612 (h1 : complete_lattice (has_emptyc congr_arg_kind)) : is_compactly_generated (has_emptyc congr_arg_kind) := sorry --non-trivial
lemma new_lemma_146613 (h0 : function.extfun nat fin) : @preconnected_space.{0} (generalized_boolean_algebra.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (generalized_boolean_algebra.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_146614 (h0 : topological_space (finset (finset (finset linarith.comp)))) : preconnected_space (finset (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_146615 (h0 : complete_lattice (id unsigned)) : is_compactly_generated (id unsigned) := sorry --non-trivial
lemma new_lemma_146616 (h0 : functor.add_const (uniform_space (has_nndist name)) Type) : @separated_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_nndist.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_146617 (h0 : functor.add_const (ring (has_neg unsigned)) Type) : @rank_condition.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 1} (ring.{0} (has_neg.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_146618 (h0 : functor.add_const (topological_space (has_add Type)) Type) : @regular_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_add.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_146619 (h0 : group (has_compl fun_info)) : is_cyclic (has_compl fun_info) := sorry --non-trivial
lemma new_lemma_146620 (h0 : random_gen string_imp -> random_gen string_imp -> random_gen string_imp) : is_right_cancel (random_gen string_imp) h0 := sorry --non-trivial
lemma new_lemma_146621 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} unsigned (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) unsigned)  := sorry --non-trivial
lemma new_lemma_146622 (h0 : topological_space (semi_normed_ring linarith.comp_source)) : path_connected_space (semi_normed_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_146623 (h0 : topological_space (has_neg_part environment.implicit_infer_kind)) : sequential_space (has_neg_part environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_146624 (h0 : filter (ring (has_neg linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_146625 (h0 : finset (has_add (mul_zero_class unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_146626 (h0 : functor.add_const (ring (has_Inf Type)) Type) : @rank_condition.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (has_Inf.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_146627 (h0 : topological_space (has_emptyc (has_norm (has_norm linarith.comp_source)))) : totally_disconnected_space (has_emptyc (has_norm (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_146628 (h0 : fin has_zero.zero) : @is_cyclic.{1} (has_Inf.{1} Type) (@matrix.vec_empty.{1} (group.{1} (has_Inf.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_146629 (h0 : ordered_comm_monoid (comm_semigroup (has_pos_part (sub_neg_monoid real)))) : has_exists_mul_of_le (comm_semigroup (has_pos_part (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_146630 (h0 : topological_space (ordered_comm_group num)) : irreducible_space (ordered_comm_group num) := sorry --non-trivial
lemma new_lemma_146631 (h0 : uniform_space (with_one (has_norm (has_norm (has_norm (has_norm empty)))))) : complete_space (with_one (has_norm (has_norm (has_norm (has_norm empty))))) := sorry --non-trivial
lemma new_lemma_146632 (h0 : functor.add_const (group (finset linarith.comp)) linarith.comp) : @group.fg.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_146633 (h0 : functor.add_const (topological_space (ring pos)) (has_neg environment.implicit_infer_kind)) : @irreducible_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_146634 (h0 : functor.add_const (filter (has_neg_part unsigned)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_146635 (h0 : not (function.extfun Type list -> false)) : list.nodup (function.extfun_app (classical.by_contradiction' h0) (has_emptyc linarith.ineq)) := sorry --non-trivial
lemma new_lemma_146636 (h0 : uniform_space (has_zero (has_neg linarith.comp))) : complete_space (has_zero (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_146637 (h0 : not (ring (has_top char) -> false)) : @is_domain.{0} (has_top.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (has_top.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_146638 (h0 : complete_lattice (has_inv (has_ssubset linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (has_inv (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_146639 (h0 : monoid (mul_zero_class (finset (finset name)))) : monoid.fg (mul_zero_class (finset (finset name))) := sorry --non-trivial
lemma new_lemma_146640 (h0 : functor.comp topological_space canonically_ordered_comm_semiring name) : @irreducible_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_146641 (h0 : topological_space (ordered_comm_monoid (has_neg name))) : regular_space (ordered_comm_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_146642 (h0 : not (ring (complete_semilattice_Sup to_additive.value_type) -> false)) : @is_domain.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (complete_semilattice_Sup.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_146643 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (linear_order.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (linear_order.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_146644 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) pos) : @totally_separated_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_146645 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) (semigroup linarith.comp)) : @preconnected_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) (semigroup.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_146646 (h0 : group (encodable (linear_ordered_add_comm_group linarith.ineq))) : group.fg (encodable (linear_ordered_add_comm_group linarith.ineq)) := sorry --non-trivial
lemma new_lemma_146647 (h1 : add_group (add_comm_semigroup (add_comm_semigroup (mul_one_class fun_info)))) : is_add_cyclic (add_comm_semigroup (add_comm_semigroup (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_146648 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_146649 (h0 : monoid (ring (has_Inf Type))) : monoid.fg (ring (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_146650 (h0 : functor.add_const (ordered_add_comm_monoid (normed_linear_ordered_group empty)) (ordered_ring (semiring empty))) : @archimedean.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (normed_linear_ordered_group.{0} empty)) (ordered_ring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_146651 (h0 : ring (order_dual unsigned)) : is_principal_ideal_ring (order_dual unsigned) := sorry --non-trivial
lemma new_lemma_146652 (h0 : topological_space (canonically_ordered_comm_semiring (has_add (has_to_string unsigned)))) : totally_disconnected_space (canonically_ordered_comm_semiring (has_add (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_146653 (h0 : has_mul (has_to_string linarith.comp)) (h1 : functor.add_const (function.extfun Type has_to_string) linarith.comp) : is_regular (function.extfun_app (functor.add_const.run h1) linarith.comp) := sorry --non-trivial
lemma new_lemma_146654 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_compl.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_compl.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_146655 (h0 : functor.add_const (topological_space (ordered_ring unsigned)) unsigned) : @locally_compact_space.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_146656 (h0 : ring (normed_comm_ring (ring (finset (has_pos_part pos))))) : is_domain (normed_comm_ring (ring (finset (has_pos_part pos)))) := sorry --non-trivial
lemma new_lemma_146657 (h0 : not (ring (random_gen (metric_space char)) -> false)) : @is_domain.{0} (random_gen.{0} (metric_space.{0} char)) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} (metric_space.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_146658 (h0 : topological_space (has_bot (has_Inf pos))) : locally_compact_space (has_bot (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_146659 (h1 : complete_lattice (denumerable (has_ssubset (has_ssubset (has_ssubset linarith.ineq))))) : is_compactly_generated (denumerable (has_ssubset (has_ssubset (has_ssubset linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_146660 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} name (@function.extfun_app.{2 1} Type ring.{0} h0 name)  := sorry --non-trivial
lemma new_lemma_146661 (h0 : functor.add_const (function.extfun (Type 1) group) (finset name)) : @normalizer_condition.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) (finset.{0} name) h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_146662 (h0 : ring (cancel_monoid (comm_group Type))) : is_principal_ideal_ring (cancel_monoid (comm_group Type)) := sorry --non-trivial
lemma new_lemma_146663 (h0 : ring (has_top (has_top linarith.comp_source))) : is_domain (has_top (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_146664 (h0 : not (has_mul fun_info -> false)) (h1 : not (has_le fun_info -> false)) (h2 : fun_info) : @mul_le_cancellable.{0} fun_info (@classical.by_contradiction'.{1} (has_mul.{0} fun_info) h0) (@classical.by_contradiction'.{1} (has_le.{0} fun_info) h1) h2  := sorry --non-trivial
lemma new_lemma_146665 (h0 : ring (distrib_lattice (has_ssubset to_additive.value_type))) : is_domain (distrib_lattice (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_146666 (h4 : topological_space (topological_space (has_nnnorm char))) : t0_space (topological_space (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_146667 (h0 : not (topological_space (has_top unsigned) -> false)) : @preirreducible_space.{0} (has_top.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_146668 (h0 : complete_lattice (boolean_algebra.core (ring (has_neg_part ennreal)))) : is_compactly_generated (boolean_algebra.core (ring (has_neg_part ennreal))) := sorry --non-trivial
lemma new_lemma_146669 (h0 : functor.add_const (monoid (mul_zero_class pos)) linarith.comp) : @monoid.fg.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (mul_zero_class.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_146670 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_neg_part (cancel_monoid pos))) := sorry --non-trivial
lemma new_lemma_146671 (h0 : not (topological_space (with_one string.iterator_imp) -> false)) : @t0_space.{0} (with_one.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_146672 (h0 : list (has_norm (distrib_lattice to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_146673 (h0 : functor.add_const (function.extfun Type ring) (ring pos)) : @rank_condition.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (ring.{0} pos) h0) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_146674 (h0 : functor.add_const (group (non_assoc_semiring congr_arg_kind)) empty) : @normalizer_condition.{0} (non_assoc_semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (non_assoc_semiring.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_146675 (h0 : function.extfun (Type 1) topological_space) : @t1_space.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_146676 (h0 : ring (has_to_string (finset linarith.comp))) : rank_condition (has_to_string (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_146677 (h0 : fin has_zero.zero) : @archimedean.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (ordered_add_comm_monoid.{1} (normed_lattice_add_comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_146678 (h0 : function.extfun Type group) : @normalizer_condition.{0} (mul_zero_class.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (mul_zero_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_146679 (h1 : set (enat -> fun_info)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_146680 (h3 : group (distrib (has_nnnorm char))) : is_cyclic (distrib (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_146681 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (denumerable fun_info)) := sorry --non-trivial
lemma new_lemma_146682 (h0 : function.extfun Prop (fun (x : Prop), Prop)) : classical.epsilon (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_146683 (h0 : has_mem.mem (has_one unsigned) has_emptyc.emptyc) : filter.ne_bot (finset.pi.empty filter (has_one unsigned) h0) := sorry --non-trivial
lemma new_lemma_146684 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_neg.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} num))  := sorry --non-trivial
lemma new_lemma_146685 (h0 : functor.add_const (complete_lattice (add_cancel_monoid linarith.comp)) name) : @is_atomistic.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_146686 (h0 : monoid (canonically_ordered_comm_semiring (has_pos_part Type))) : monoid.fg (canonically_ordered_comm_semiring (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_146687 (h0 : topological_space (finset (boolean_algebra.core Type))) : preirreducible_space (finset (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_146688 (h3 : topological_space (add_comm_semigroup linarith.ineq)) (h4 : preorder (add_comm_semigroup linarith.ineq)) : order_topology (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_146689 (h0 : add_group (add_cancel_monoid (comm_group name))) : is_add_cyclic (add_cancel_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_146690 (h0 : topological_space (has_star (option (option (option (option (option empty))))))) : t1_space (has_star (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_146691 (h0 : add_group (semiring (random_gen linarith.comp_source))) : is_add_cyclic (semiring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_146692 (h0 : group (with_one (has_nnnorm linarith.ineq))) : group.fg (with_one (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_146693 (h0 : complete_lattice (has_add (ordered_comm_monoid real))) : is_compactly_generated (has_add (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_146694 (h0 : uniform_space (mul_one_class (add_comm_semigroup string.iterator_imp))) : complete_space (mul_one_class (add_comm_semigroup string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_146695 (h0 : functor.add_const (semiring (has_zero environment.implicit_infer_kind)) name) : @is_noetherian_ring.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (semiring.{0} (has_zero.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_146696 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_146697 (h0 : group (ring name)) : is_simple_group (ring name) := sorry --non-trivial
lemma new_lemma_146698 (h0 : uniform_space (has_ssubset (has_nnnorm fun_info))) : complete_space (has_ssubset (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_146699 (h0 : functor.comp complete_lattice boolean_algebra name) : @is_atomistic.{0} (boolean_algebra.{0} name) (@functor.comp.run.{0 0 0} complete_lattice.{0} boolean_algebra.{0} name (@functor.comp.run.{0 0 0} complete_lattice.{0} boolean_algebra.{0} name (@functor.comp.run.{0 0 0} complete_lattice.{0} boolean_algebra.{0} name (@functor.comp.run.{0 0 0} complete_lattice.{0} boolean_algebra.{0} name (@functor.comp.run.{0 0 0} complete_lattice.{0} boolean_algebra.{0} name (@functor.comp.run.{0 0 0} complete_lattice.{0} boolean_algebra.{0} name (@functor.comp.run.{0 0 0} complete_lattice.{0} boolean_algebra.{0} name (@functor.comp.run.{0 0 0} complete_lattice.{0} boolean_algebra.{0} name (@functor.comp.run.{0 0 0} complete_lattice.{0} boolean_algebra.{0} name (@functor.comp.run.{0 0 0} complete_lattice.{0} boolean_algebra.{0} name (@functor.comp.run.{0 0 0} complete_lattice.{0} boolean_algebra.{0} name h0)))))))))))  := sorry --non-trivial
lemma new_lemma_146700 (h0 : functor.add_const (ring (ring empty)) (option empty)) : @is_principal_ideal_ring.{0} (ring.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_146701 (h0 : complete_lattice (topological_space fun_info)) : complete_lattice.is_Sup_finite_compact (topological_space fun_info) := sorry --non-trivial
lemma new_lemma_146702 (h0 : topological_space (left_cancel_monoid (semiring (semiring empty)))) : locally_compact_space (left_cancel_monoid (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_146703 (h0 : multiset (topological_space (normed_group (has_top (has_top (has_top (has_top linarith.ineq))))))) : @totally_disconnected_space.{0} (normed_group.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.ineq))))) (@multiset.inf.{0} (topological_space.{0} (normed_group.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.ineq)))))) (@lattice.to_semilattice_inf.{0} (topological_space.{0} (normed_group.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.ineq)))))) (@conditionally_complete_lattice.to_lattice.{0} (topological_space.{0} (normed_group.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.ineq)))))) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (normed_group.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.ineq)))))) (@topological_space.complete_lattice.{0} (normed_group.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.ineq))))))))) (@bounded_order.to_order_top.{0} (topological_space.{0} (normed_group.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.ineq)))))) (@preorder.to_has_le.{0} (topological_space.{0} (normed_group.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.ineq)))))) (@partial_order.to_preorder.{0} (topological_space.{0} (normed_group.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.ineq)))))) (@semilattice_inf.to_partial_order.{0} (topological_space.{0} (normed_group.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.ineq)))))) (@lattice.to_semilattice_inf.{0} (topological_space.{0} (normed_group.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.ineq)))))) (@conditionally_complete_lattice.to_lattice.{0} (topological_space.{0} (normed_group.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.ineq)))))) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (normed_group.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.ineq)))))) (@topological_space.complete_lattice.{0} (normed_group.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.ineq)))))))))))) (@complete_lattice.to_bounded_order.{0} (topological_space.{0} (normed_group.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.ineq)))))) (@topological_space.complete_lattice.{0} (normed_group.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.ineq)))))))) h0)  := sorry --non-trivial
lemma new_lemma_146704 (h0 : group (complete_distrib_lattice (option num))) : is_simple_group (complete_distrib_lattice (option num)) := sorry --non-trivial
lemma new_lemma_146705 (h0 : topological_space (mul_zero_class num)) : locally_compact_space (mul_zero_class num) := sorry --non-trivial
lemma new_lemma_146706 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_146707 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (linear_ordered_field.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (linear_ordered_field.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_146708 (h0 : cancel_comm_monoid_with_zero (complete_semilattice_Sup congr_arg_kind)) : unique_factorization_monoid (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_146709 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (add_cancel_comm_monoid empty)) := sorry --non-trivial
lemma new_lemma_146710 (h0 : ring (ring empty)) : is_principal_ideal_ring (ring empty) := sorry --non-trivial
lemma new_lemma_146711 (h0 : topological_space (add_group congr_arg_kind)) : discrete_topology (add_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_146712 (h0 : functor.add_const (topological_space (cancel_monoid num)) unsigned) : @preirreducible_space.{0} (cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_146713 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_146714 (h0 : complete_lattice (has_neg reducibility_hints)) : is_compactly_generated (has_neg reducibility_hints) := sorry --non-trivial
lemma new_lemma_146715 (h0 : not (complete_lattice fun_info -> false)) : @is_compactly_generated.{0} fun_info (@classical.by_contradiction'.{1} (complete_lattice.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_146716 (h0 : monoid (ordered_comm_monoid (has_neg name))) : monoid.fg (ordered_comm_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_146717 (h0 : functor.add_const (topological_space (ring linarith.comp)) pos) : @sequential_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_146718 (h0 : functor.add_const (add_monoid (has_neg environment.implicit_infer_kind)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_neg.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_146719 (h1 : group (has_emptyc (has_emptyc to_additive.value_type))) : normalizer_condition (has_emptyc (has_emptyc to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_146720 (h0 : complete_lattice (complete_linear_order num)) : complete_lattice.is_Sup_finite_compact (complete_linear_order num) := sorry --non-trivial
lemma new_lemma_146721 (h0 : group (has_add (has_neg (has_Inf pos)))) : group.fg (has_add (has_neg (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_146722 (h0 : add_monoid (has_to_string (canonically_ordered_comm_semiring Type))) : add_monoid.fg (has_to_string (canonically_ordered_comm_semiring Type)) := sorry --non-trivial
lemma new_lemma_146723 (h0 : topological_space (semigroup (has_neg (ring (has_neg environment.implicit_infer_kind))))) : discrete_topology (semigroup (has_neg (ring (has_neg environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_146724 (h0 : functor.add_const (uniform_space (boolean_algebra linarith.comp)) pos) : @complete_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_146725 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_146726 (h0 : topological_space (normed_linear_ordered_group congr_arg_kind)) : totally_disconnected_space (normed_linear_ordered_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_146727 (h0 : topological_space (has_sub (semiring empty))) : t0_space (has_sub (semiring empty)) := sorry --non-trivial
lemma new_lemma_146728 (h1 : topological_space (has_neg char)) : t0_space (has_neg char) := sorry --non-trivial
lemma new_lemma_146729 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (ordered_comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_146730 (h0 : filter (has_star (semiring unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_146731 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (add_cancel_comm_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_146732 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (add_left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_146733 (h0 : function.extfun Type (prod (monoid_with_zero unsigned))) : id_rel (function.extfun_app h0 (monoid_with_zero unsigned)) := sorry --non-trivial
lemma new_lemma_146734 (h0 : topological_space (normed_field (has_nnnorm (has_ssubset (uniform_space linarith.ineq))))) : t0_space (normed_field (has_nnnorm (has_ssubset (uniform_space linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_146735 (h0 : topological_space (boolean_algebra (ring (ring (ring Type))))) : loc_path_connected_space (boolean_algebra (ring (ring (ring Type)))) := sorry --non-trivial
lemma new_lemma_146736 (h0 : functor.add_const (topological_space (has_Inf name)) Type) : @preconnected_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_146737 (h0 : function.extfun Type group) : @is_simple_group.{0} (linear_ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_146738 (h2 : topological_space (has_lt to_additive.value_type)) : t0_space (has_lt to_additive.value_type) := sorry --non-trivial
lemma new_lemma_146739 (h0 : uniform_space (linear_ordered_semiring (with_one (random_gen num)))) : separated_space (linear_ordered_semiring (with_one (random_gen num))) := sorry --non-trivial
lemma new_lemma_146740 (h0 : topological_space (normed_lattice_add_comm_group (has_bot (ordered_comm_monoid name)))) : preconnected_space (normed_lattice_add_comm_group (has_bot (ordered_comm_monoid name))) := sorry --non-trivial
lemma new_lemma_146741 (h0 : set (set (random_gen fun_info))) : is_countably_spanning h0 := sorry --non-trivial
lemma new_lemma_146742 (h0 : uniform_space (ring (has_add Type))) : separated_space (ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_146743 (h0 : topological_space (has_le (mul_one_class to_additive.value_type))) : totally_disconnected_space (has_le (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_146744 (h0 : functor.add_const (add_group (complete_distrib_lattice Type)) (has_nndist environment.implicit_infer_kind)) : @is_add_cyclic.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (complete_distrib_lattice.{1} Type)) (has_nndist.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_146745 (h0 : uniform_space (semiring (has_norm fun_info))) : separated_space (semiring (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_146746 (h0 : topological_space (finset (add_comm_monoid pos))) : discrete_topology (finset (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_146747 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (canonically_linear_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_146748 (h0 : ring (topological_space (random_gen to_additive.value_type))) : rank_condition (topological_space (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_146749 (h0 : topological_space (ring (finset (has_neg (has_neg linarith.comp))))) : preconnected_space (ring (finset (has_neg (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_146750 (h0 : function.extfun Type ring) : @is_domain.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_146751 (h0 : finset (has_dist (option empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_146752 (h0 : functor.add_const (filter (finset pos)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_146753 (h0 : cancel_comm_monoid_with_zero (boolean_algebra (has_add (has_add environment.implicit_infer_kind)))) : unique_factorization_monoid (boolean_algebra (has_add (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_146754 (h0 : topological_space (cancel_monoid (boolean_algebra (boolean_algebra.core name)))) : totally_separated_space (cancel_monoid (boolean_algebra (boolean_algebra.core name))) := sorry --non-trivial
lemma new_lemma_146755 (h0 : add_group (boolean_algebra (has_add (has_add environment.implicit_infer_kind)))) : is_add_cyclic (boolean_algebra (has_add (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_146756 (h0 : functor.add_const (topological_space (left_cancel_monoid unsigned)) congr_arg_kind) : @locally_compact_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_146757 (h0 : sub_neg_monoid Type -> sub_neg_monoid Type -> Prop) : is_symm (sub_neg_monoid Type) h0 := sorry --non-trivial
lemma new_lemma_146758 (h0 : partial_order (has_sub congr_arg_kind) -> partial_order (has_sub congr_arg_kind) -> Prop) : is_strict_order (partial_order (has_sub congr_arg_kind)) h0 := sorry --non-trivial
lemma new_lemma_146759 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) (has_neg name)) : @locally_compact_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_146760 (h0 : ring (linear_ordered_field (comm_monoid unsigned))) : is_domain (linear_ordered_field (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_146761 (h0 : topological_space (semigroup (has_to_string unsigned))) : sequential_space (semigroup (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_146762 (h0 : function.extfun Type topological_space) : @normal_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_146763 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @irreducible_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_146764 (h0 : ring (add_comm_monoid (add_cancel_monoid Type))) : strong_rank_condition (add_comm_monoid (add_cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_146765 (h0 : topological_space (add_left_cancel_semigroup unsigned)) : irreducible_space (add_left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_146766 (h0 : function.extfun nat fin) : @loc_path_connected_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_146767 (h0 : functor.add_const (add_group (left_cancel_monoid unsigned)) empty) : @is_add_cyclic.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (left_cancel_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_146768 (h0 : group (has_nndist (comm_group unsigned))) : group.fg (has_nndist (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_146769 (h0 : add_group (random_gen (comm_group linarith.ineq))) : is_add_cyclic (random_gen (comm_group linarith.ineq)) := sorry --non-trivial
lemma new_lemma_146770 (h0 : has_le (has_nnnorm fun_info)) (h1 : has_nnnorm fun_info) : is_bot h1 := sorry --non-trivial
lemma new_lemma_146771 (h0 : topological_space (ordered_comm_ring Type)) : loc_path_connected_space (ordered_comm_ring Type) := sorry --non-trivial
lemma new_lemma_146772 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_dist.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_dist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_146773 (h0 : complete_lattice (ordered_comm_ring (has_neg (has_neg name)))) : is_atomistic (ordered_comm_ring (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_146774 (h0 : filter (with_zero linarith.ineq)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_146775 (h0 : functor.add_const (add_group (add_left_cancel_semigroup congr_arg_kind)) congr_arg_kind) : @is_add_cyclic.{0} (add_left_cancel_semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (add_group.{0} (add_left_cancel_semigroup.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_146776 (h0 : set char) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_146777 (h1 : group (linear_ordered_add_comm_group (has_norm string_imp))) : group.fg (linear_ordered_add_comm_group (has_norm string_imp)) := sorry --non-trivial
lemma new_lemma_146778 (h0 : function.extfun nat fin) : @sequential_space.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (comm_semigroup.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_146779 : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@id.{1} (filter.{0} Prop) (@id.{1} (filter.{0} Prop) (@id.{1} (filter.{0} Prop) (@filter.cofinite.{0} Prop))))  := sorry --non-trivial
lemma new_lemma_146780 (h0 : string.iterator_imp) (h1 : multiset string.iterator_imp) : multiset.mem h0 h1 := sorry --non-trivial
lemma new_lemma_146781 (h0 : function.extfun Type ring) : @rank_condition.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_146782 (h0 h1 : not (multiset (non_unital_non_assoc_semiring (has_nnnorm string.iterator_imp)) -> false)) : multiset.disjoint (classical.by_contradiction' h0) (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_146783 (h0 : topological_space (add_group (semiring (has_norm unsigned)))) : path_connected_space (add_group (semiring (has_norm unsigned))) := sorry --non-trivial
lemma new_lemma_146784 (h0 : complete_lattice (option ennreal)) : is_atomistic (option ennreal) := sorry --non-trivial
lemma new_lemma_146785 (h0 : functor.add_const (topological_space (option unsigned)) num) : @topological_space.separable_space.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_146786 (h0 : functor.add_const (add_monoid (has_Inf name)) linarith.comp) : @add_monoid.fg.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_Inf.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_146787 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) (ring pos)) : @separated_space.{1} Type (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) uniform_space.{1}) (ring.{0} pos) h0) Type)  := sorry --non-trivial
lemma new_lemma_146788 (h2 : group (normed_field linarith.comp_source)) : is_cyclic (normed_field linarith.comp_source) := sorry --non-trivial
lemma new_lemma_146789 (h0 : uniform_space (has_nndist (linear_ordered_field (option pos)))) : complete_space (has_nndist (linear_ordered_field (option pos))) := sorry --non-trivial
lemma new_lemma_146790 (h0 : add_monoid (has_pos_part (has_repr (has_add (ring (has_nndist name)))))) : add_monoid.fg (has_pos_part (has_repr (has_add (ring (has_nndist name))))) := sorry --non-trivial
lemma new_lemma_146791 (h0 : functor.add_const (topological_space (has_dist unsigned)) congr_arg_kind) : @irreducible_space.{0} (has_dist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_146792 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_146793 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_146794 (h0 : ring (has_add (option ennreal))) : is_principal_ideal_ring (has_add (option ennreal)) := sorry --non-trivial
lemma new_lemma_146795 (h0 : ring (measurable_space num)) : is_domain (measurable_space num) := sorry --non-trivial
lemma new_lemma_146796 (h0 : uniform_space (canonically_ordered_monoid (sub_neg_monoid linarith.comp))) : separated_space (canonically_ordered_monoid (sub_neg_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_146797 (h0 : topological_space (has_neg_part (has_add (option name)))) : topological_space.separable_space (has_neg_part (has_add (option name))) := sorry --non-trivial
lemma new_lemma_146798 (h0 : functor.comp uniform_space add_comm_monoid Type) : @complete_space.{1} (add_comm_monoid.{1} Type) (@functor.comp.run.{1 1 1} uniform_space.{1} add_comm_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_146799 (h0 : complete_lattice (monoid (option empty))) : is_atomistic (monoid (option empty)) := sorry --non-trivial
lemma new_lemma_146800 (h0 : function.extfun nat fin) : normal_space real := sorry --non-trivial
lemma new_lemma_146801 (h0 : prod (has_sub (semiring unsigned)) (has_sub (semiring unsigned))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_146802 (h0 : not (topological_space (has_one congr_arg_kind) -> false)) : @locally_compact_space.{0} (has_one.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_one.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_146803 (h0 : topological_space (measurable_space (has_norm (random_gen linarith.comp_source)))) : totally_disconnected_space (measurable_space (has_norm (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_146804 (h0 : topological_space (normed_comm_ring (finset (finset (finset (finset environment.implicit_infer_kind)))))) : normal_space (normed_comm_ring (finset (finset (finset (finset environment.implicit_infer_kind))))) := sorry --non-trivial
lemma new_lemma_146805 (h5 : ring (has_lt char)) : is_domain (has_lt char) := sorry --non-trivial
lemma new_lemma_146806 (h1 : not (ring (measurable_space to_additive.value_type) -> false)) : @rank_condition.{0} (measurable_space.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_146807 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_146808 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_146809 (h0 : functor.add_const (topological_space (boolean_algebra.core linarith.comp)) linarith.comp) : @normal_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_146810 (h0 : complete_lattice (has_neg (has_neg_part (has_neg_part Type)))) : is_compactly_generated (has_neg (has_neg_part (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_146811 (h0 : topological_space (has_nndist (mul_zero_class name))) : sequential_space (has_nndist (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_146812 (h0 : functor.add_const (ring (mul_zero_class name)) (add_comm_monoid pos)) : @rank_condition.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} name)) (add_comm_monoid.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_146813 (h0 : topological_space (has_pos_part (has_Inf (has_add Type)))) : normal_space (has_pos_part (has_Inf (has_add Type))) := sorry --non-trivial
lemma new_lemma_146814 (h0 : complete_lattice (linear_ordered_semiring (semiring (semiring (semiring linarith.comp))))) : is_atomistic (linear_ordered_semiring (semiring (semiring (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_146815 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring Type)) linarith.comp) : @regular_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_146816 (h0 : ring (ring (linear_ordered_comm_ring (boolean_algebra name)))) : rank_condition (ring (linear_ordered_comm_ring (boolean_algebra name))) := sorry --non-trivial
lemma new_lemma_146817 (h2 : complete_lattice (mul_one_class (add_comm_semigroup fun_info))) : complete_lattice.is_Sup_finite_compact (mul_one_class (add_comm_semigroup fun_info)) := sorry --non-trivial
lemma new_lemma_146818 (h0 : function.extfun (finset Type) (has_mem.mem linarith.comp_source)) : @path_connected_space.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type topological_space.{0} linarith.comp_source (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp_source) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_146819 (h1 : topological_space enat) : topological_space.first_countable_topology enat := sorry --non-trivial
lemma new_lemma_146820 (h0 : functor.comp topological_space has_neg environment.implicit_infer_kind) : @preconnected_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_146821 (h0 : add_group (has_compl (has_lt (has_lt linarith.comp_source)))) : is_add_cyclic (has_compl (has_lt (has_lt linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_146822 (h0 : ring (has_to_string (option (option (option num))))) : strong_rank_condition (has_to_string (option (option (option num)))) := sorry --non-trivial
lemma new_lemma_146823 (h0 : topological_space (cancel_monoid (comm_group unsigned))) : irreducible_space (cancel_monoid (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_146824 (h0 : add_monoid (complete_linear_order num)) : add_monoid.fg (complete_linear_order num) := sorry --non-trivial
lemma new_lemma_146825 (h1 : topological_space (semi_normed_ring to_additive.value_type)) (h2 : preorder (semi_normed_ring to_additive.value_type)) : order_topology (semi_normed_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_146826 (h0 : functor.add_const (function.extfun Type topological_space) name) : @topological_space.separable_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_146827 (h0 : functor.add_const (topological_space (free_add_monoid num)) empty) : @topological_space.separable_space.{0} (free_add_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_146828 (h0 : uniform_space (cancel_monoid ennreal)) : complete_space (cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_146829 (h0 : group (has_zero (ring (add_left_cancel_monoid environment.implicit_infer_kind)))) : is_cyclic (has_zero (ring (add_left_cancel_monoid environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_146830 (h0 : uniform_space (has_zero (has_add (has_nndist ennreal)))) : separated_space (has_zero (has_add (has_nndist ennreal))) := sorry --non-trivial
lemma new_lemma_146831 (h0 : group (random_gen (semiring linarith.comp))) : normalizer_condition (random_gen (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_146832 (h0 : ring (sub_neg_monoid Type)) : strong_rank_condition (sub_neg_monoid Type) := sorry --non-trivial
lemma new_lemma_146833 (h0 : uniform_space (boolean_algebra.core pos)) : complete_space (boolean_algebra.core pos) := sorry --non-trivial
lemma new_lemma_146834 (h0 : functor.add_const (ring (linear_order empty)) congr_arg_kind) : @is_domain.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (linear_order.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_146835 (h0 : topological_space fun_info) : topological_space.first_countable_topology fun_info := sorry --non-trivial
lemma new_lemma_146836 (h0 : functor.add_const (finset (has_Inf linarith.comp)) (has_neg linarith.comp)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_146837 (h0 : not (uniform_space (simple_graph string_imp) -> false)) : @complete_space.{0} (simple_graph.{0} string_imp) (@classical.by_contradiction'.{1} (uniform_space.{0} (simple_graph.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_146838 (h0 : complete_lattice (complete_distrib_lattice (option (option empty)))) : is_compactly_generated (complete_distrib_lattice (option (option empty))) := sorry --non-trivial
lemma new_lemma_146839 (h0 : ulower (ulower pnat)) (h1 : ulower pnat) : pnat.coprime (ulower.up (ulower.up h0)) (ulower.up h1) := sorry --non-trivial
lemma new_lemma_146840 (h0 : functor.add_const (topological_space (ordered_comm_monoid pos)) Type) : @preirreducible_space.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_146841 (h0 : not (semiring (has_one unsigned) -> false)) : @is_noetherian_ring.{0} (has_one.{0} unsigned) (@classical.by_contradiction'.{1} (semiring.{0} (has_one.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_146842 (h0 : topological_space (add_right_cancel_monoid linarith.comp)) : irreducible_space (add_right_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_146843 (h1 : set (enat -> add_comm_semigroup fun_info)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_146844 (h0 : monoid (semiring (has_top (semiring num)))) : monoid.fg (semiring (has_top (semiring num))) := sorry --non-trivial
lemma new_lemma_146845 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_146846 (h0 : functor.add_const (group (boolean_algebra name)) name) : @group.fg.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_146847 (h0 : group (option (option (option (option (option pos)))))) : is_simple_group (option (option (option (option (option pos))))) := sorry --non-trivial
lemma new_lemma_146848 (h0 : add_group (add_group linarith.comp)) : is_add_cyclic (add_group linarith.comp) := sorry --non-trivial
lemma new_lemma_146849 (h0 : topological_space (add_cancel_comm_monoid unsigned)) : totally_separated_space (add_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_146850 (h0 : filter (boolean_algebra.core (has_add unsigned))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_146851 (h0 : add_group (has_inv (has_ssubset fun_info))) : is_add_cyclic (has_inv (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_146852 (h1 : uniform_space linarith.comp_source) : complete_space linarith.comp_source := sorry --non-trivial
lemma new_lemma_146853 (h0 : functor.comp monoid has_to_string linarith.comp) : @monoid.fg.{0} (has_to_string.{0} linarith.comp) (@functor.comp.run.{0 0 0} monoid.{0} has_to_string.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_146854 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_146855 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) pos) : @locally_compact_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_146856 (h0 : functor.add_const (ring (boolean_algebra pos)) pos) : @rank_condition.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_146857 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_atomistic.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (ordered_comm_ring.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_146858 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (cancel_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_146859 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_146860 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_146861 (h0 : functor.add_const (topological_space (complete_distrib_lattice unsigned)) pos) : @preconnected_space.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_146862 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_146863 (h1 : function.extfun Type topological_space) : @t0_space.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_146864 (h0 : ordered_add_comm_monoid pos) : archimedean pos := sorry --non-trivial
lemma new_lemma_146865 (h0 : functor.add_const (functor.add_const (ordered_comm_monoid string) pos) pos) : @has_exists_mul_of_le.{0} string (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} string) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ordered_comm_monoid.{0} string) pos) pos h0))  := sorry --non-trivial
lemma new_lemma_146866 (h0 : ring (sub_neg_monoid (has_Inf (has_Inf (has_pos_part pos))))) : is_principal_ideal_ring (sub_neg_monoid (has_Inf (has_Inf (has_pos_part pos)))) := sorry --non-trivial
lemma new_lemma_146867 (h0 : topological_space (finset (semigroup Type))) : discrete_topology (finset (semigroup Type)) := sorry --non-trivial
lemma new_lemma_146868 (h0 : topological_space (has_nnnorm (has_ssubset (random_gen to_additive.value_type)))) : locally_compact_space (has_nnnorm (has_ssubset (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_146869 (h0 : function.extfun Type (functor.add_const (filter unsigned))) : filter.ne_bot (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_146870 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_146871 (h1 : uniform_space (random_gen (has_norm to_additive.value_type))) : complete_space (random_gen (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_146872 (h0 : finset (has_add (finset pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_146873 (h0 : monoid (linear_ordered_semiring congr_arg_kind)) : monoid.fg (linear_ordered_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_146874 (h0 : topological_space (normed_group (has_top (has_top linarith.comp_source)))) : locally_compact_space (normed_group (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_146875 (h0 : topological_space (simple_graph (has_neg pos))) : preconnected_space (simple_graph (has_neg pos)) := sorry --non-trivial
lemma new_lemma_146876 (h0 : complete_lattice (normed_linear_ordered_group num)) : is_atomistic (normed_linear_ordered_group num) := sorry --non-trivial
lemma new_lemma_146877 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_146878 (h0 : finset (add_group num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_146879 (h0 : monoid (cancel_monoid (option empty))) : monoid.fg (cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_146880 (h0 : topological_space (mul_zero_class (linear_ordered_comm_monoid_with_zero pos))) : loc_path_connected_space (mul_zero_class (linear_ordered_comm_monoid_with_zero pos)) := sorry --non-trivial
lemma new_lemma_146881 (h0 : topological_space (ring (ring (ordered_ring linarith.comp)))) : path_connected_space (ring (ring (ordered_ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_146882 (h2 : complete_lattice (with_one (random_gen string_imp))) : is_compactly_generated (with_one (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_146883 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (dlist.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (dlist.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_146884 (h0 : topological_space (ring (has_Inf linarith.comp))) : preirreducible_space (ring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_146885 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @separated_space.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) uniform_space.{0}) (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_146886 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (comm_semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_146887 (h0 : topological_space (complete_distrib_lattice (finset ennreal))) : totally_separated_space (complete_distrib_lattice (finset ennreal)) := sorry --non-trivial
lemma new_lemma_146888 (h0 : add_group (complete_distrib_lattice (has_add (sub_neg_monoid pos)))) : is_add_cyclic (complete_distrib_lattice (has_add (sub_neg_monoid pos))) := sorry --non-trivial
lemma new_lemma_146889 (h0 : ring (generalized_boolean_algebra (has_add real))) : rank_condition (generalized_boolean_algebra (has_add real)) := sorry --non-trivial
lemma new_lemma_146890 (h0 : functor.add_const Prop (linear_ordered_field (option unsigned))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_146891 (h0 : has_mem.mem (has_emptyc linarith.comp) has_emptyc.emptyc) : @add_monoid.fg.{0} (has_emptyc.{0} linarith.comp) (@finset.pi.empty.{1 0} Type add_monoid.{0} (has_emptyc.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_146892 (h1 : filter (has_ssubset linarith.ineq)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_146893 (h0 : topological_space (simple_graph congr_arg_kind)) : t0_space (simple_graph congr_arg_kind) := sorry --non-trivial
lemma new_lemma_146894 (h0 : topological_space (pseudo_metric_space (option ennreal))) : totally_separated_space (pseudo_metric_space (option ennreal)) := sorry --non-trivial
lemma new_lemma_146895 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (complete_linear_order.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_146896 (h0 : topological_space (normed_comm_ring (comm_monoid empty))) : normal_space (normed_comm_ring (comm_monoid empty)) := sorry --non-trivial
lemma new_lemma_146897 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @normal_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_146898 (h0 : group (complete_linear_order congr_arg_kind)) : is_cyclic (complete_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_146899 (h0 : uniform_space (option empty)) : complete_space (option empty) := sorry --non-trivial
lemma new_lemma_146900 (h0 : filter (has_norm num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_146901 (h0 : uniform_space (complete_distrib_lattice linarith.comp)) : separated_space (complete_distrib_lattice linarith.comp) := sorry --non-trivial
lemma new_lemma_146902 (h0 : add_monoid (has_top (semiring num))) : add_monoid.fg (has_top (semiring num)) := sorry --non-trivial
lemma new_lemma_146903 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) linarith.comp) : @totally_separated_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_146904 (h1 : filter (comm_ring char)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_146905 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_146906 (h0 : topological_space (add_cancel_monoid (has_add pos))) : path_connected_space (add_cancel_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_146907 (h1 : measurable_space (distrib std_gen)) (h2 : filter (distrib std_gen)) : filter.is_measurably_generated h2 := sorry --non-trivial
lemma new_lemma_146908 (h0 : topological_space (linear_ordered_field (has_add (has_to_string environment.implicit_infer_kind)))) : sequential_space (linear_ordered_field (has_add (has_to_string environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_146909 (h0 : group (has_Inf (ring (has_pos_part linarith.comp)))) : group.fg (has_Inf (ring (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_146910 (h0 : has_mem.mem (has_emptyc fun_info) has_emptyc.emptyc) : @is_add_cyclic.{0} (has_emptyc.{0} fun_info) (@finset.pi.empty.{1 0} Type add_group.{0} (has_emptyc.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_146911 (h0 : functor.add_const (ring (boolean_algebra name)) Type) : @rank_condition.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (boolean_algebra.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_146912 (h0 : functor.add_const (topological_space (semigroup pos)) name) : @normal_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_146913 (h0 : filter (add_comm_monoid pos)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_146914 (h0 : topological_space (pseudo_metric_space congr_arg_kind)) : t1_space (pseudo_metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_146915 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_146916 (h0 : group (complete_linear_order (has_nnnorm char))) : group.fg (complete_linear_order (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_146917 (h0 : topological_space (has_to_string (ordered_comm_monoid pos))) : t1_space (has_to_string (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_146918 (h0 : ordered_comm_monoid (sub_neg_monoid (has_add (finset Type)))) : has_exists_mul_of_le (sub_neg_monoid (has_add (finset Type))) := sorry --non-trivial
lemma new_lemma_146919 (h0 : topological_space (has_zero (has_add linarith.comp))) : loc_path_connected_space (has_zero (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_146920 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (left_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (left_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_146921 (h0 : topological_space (boolean_algebra (has_pos_part (has_pos_part linarith.comp)))) : locally_compact_space (boolean_algebra (has_pos_part (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_146922 (h0 : topological_space (with_one (has_norm (has_norm linarith.comp_source)))) : irreducible_space (with_one (has_norm (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_146923 (h0 : list (has_pos_part (finset pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_146924 (h0 : topological_space (add_cancel_monoid unsigned)) : discrete_topology (add_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_146925 (h0 : finset (ring num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_146926 (h0 : group (is_R_or_C (option (option (option (option unsigned)))))) : normalizer_condition (is_R_or_C (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_146927 (h2 : topological_space (uniform_space string_imp)) : totally_disconnected_space (uniform_space string_imp) := sorry --non-trivial
lemma new_lemma_146928 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_146929 (h0 : functor.add_const (group (plift congr_arg_kind)) congr_arg_kind) : @normalizer_condition.{1} (plift.{1} congr_arg_kind) (@functor.add_const.run.{1 0} (group.{1} (plift.{1} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_146930 (h0 : uniform_space (generalized_boolean_algebra (has_Inf Type))) : separated_space (generalized_boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_146931 (h0 : ring (has_add (has_Inf (has_add Type)))) : strong_rank_condition (has_add (has_Inf (has_add Type))) := sorry --non-trivial
lemma new_lemma_146932 (h0 : functor.add_const (monoid (comm_group unsigned)) Type) : @monoid.fg.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 1} (monoid.{0} (comm_group.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_146933 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_146934 (h0 : add_monoid (has_neg_part pos)) : add_monoid.fg (has_neg_part pos) := sorry --non-trivial
lemma new_lemma_146935 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_146936 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_zero Type)) (has_neg linarith.comp)) : @unique_factorization_monoid.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (has_zero.{1} Type)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_146937 (h0 : monoid (boolean_algebra.core (has_neg_part Type))) : monoid.fg (boolean_algebra.core (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_146938 (h0 : ulower pnat) (h1 : list (ulower pnat)) (h2 : pnat) : id (pnat.coprime (ulower.up (list.ilast' h0 h1)) h2) := sorry --non-trivial
lemma new_lemma_146939 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (semigroup.{0} (option.{0} name)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} (option.{0} name)))  := sorry --non-trivial
lemma new_lemma_146940 (h0 : complete_lattice (measurable_space (semiring (has_norm congr_arg_kind)))) : complete_lattice.is_Sup_finite_compact (measurable_space (semiring (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_146941 (h0 : functor.add_const (semiring (ordered_comm_ring linarith.comp)) linarith.comp) : @is_noetherian_ring.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (ordered_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_146942 (h0 : functor.add_const (semiring (sub_neg_monoid linarith.comp)) pos) : @is_noetherian_ring.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (sub_neg_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_146943 (h0 : ordered_add_comm_monoid (linear_ordered_comm_monoid_with_zero (option unsigned))) : archimedean (linear_ordered_comm_monoid_with_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_146944 (h0 : topological_space (has_Inf (ring (has_add linarith.comp)))) : topological_space.separable_space (has_Inf (ring (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_146945 (h0 : monoid (semiring unsigned)) : monoid.fg (semiring unsigned) := sorry --non-trivial
lemma new_lemma_146946 (h0 : topological_space (linear_order string_imp)) : totally_separated_space (linear_order string_imp) := sorry --non-trivial
lemma new_lemma_146947 (h0 : set (uniform_space (semi_normed_comm_ring string.iterator_imp))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_146948 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (measurable_space.dynkin_system.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_146949 (h0 : group (has_bot real)) : is_cyclic (has_bot real) := sorry --non-trivial
lemma new_lemma_146950 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @sequential_space.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_146951 (h0 : add_group (canonically_ordered_add_monoid unsigned)) : is_add_cyclic (canonically_ordered_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_146952 (h0 : topological_space (comm_ring (metric_space (mul_one_class (mul_one_class linarith.comp_source))))) : t0_space (comm_ring (metric_space (mul_one_class (mul_one_class linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_146953 (h0 : topological_space (semi_normed_ring reducibility_hints)) : path_connected_space (semi_normed_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_146954 (h0 : uniform_space (normed_lattice_add_comm_group (has_bot Type))) : separated_space (normed_lattice_add_comm_group (has_bot Type)) := sorry --non-trivial
lemma new_lemma_146955 (h0 : topological_space (has_star num)) : loc_path_connected_space (has_star num) := sorry --non-trivial
lemma new_lemma_146956 (h0 : topological_space (mul_zero_class (option (option unsigned)))) : t1_space (mul_zero_class (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_146957 (h0 : ring (has_nnnorm (normed_field reducibility_hints))) : rank_condition (has_nnnorm (normed_field reducibility_hints)) := sorry --non-trivial
lemma new_lemma_146958 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_146959 (h0 : functor.add_const (ring name) empty) : @rank_condition.{0} name (@functor.add_const.run.{0 0} (ring.{0} name) empty h0)  := sorry --non-trivial
lemma new_lemma_146960 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_emptyc num)) := sorry --non-trivial
lemma new_lemma_146961 (h0 : functor.add_const (list (has_zero name)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_146962 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_146963 (h0 : ring (distrib (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) : rank_condition (distrib (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_146964 (h1 : ring (has_union (semiring (semiring empty)))) : is_domain (has_union (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_146965 (h0 : topological_space (semigroup (has_pos_part Type))) : loc_path_connected_space (semigroup (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_146966 (h0 : topological_space (normed_comm_ring (has_zero (boolean_algebra linarith.comp)))) : normal_space (normed_comm_ring (has_zero (boolean_algebra linarith.comp))) := sorry --non-trivial
lemma new_lemma_146967 (h0 : function.extfun nat fin) : @preirreducible_space.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_146968 (h0 : topological_space (ring (option ennreal))) : t1_space (ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_146969 (h0 : not (complete_lattice (has_lt char) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_lt.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_lt.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_146970 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_146971 (h0 : functor.add_const (topological_space (mul_zero_class name)) Type) : @regular_space.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (mul_zero_class.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_146972 (h0 : set (has_ssubset (semi_normed_comm_ring to_additive.value_type))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_146973 (h1 : not (uniform_space (semi_normed_ring linarith.comp_source) -> false)) : @complete_space.{0} (semi_normed_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (uniform_space.{0} (semi_normed_ring.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_146974 (h0 : function.extfun (Type 1) group) : @normalizer_condition.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_146975 (h0 : topological_space (has_mul empty)) : t1_space (has_mul empty) := sorry --non-trivial
lemma new_lemma_146976 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) linarith.comp) : @topological_space.separable_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_146977 (h0 : functor.add_const (topological_space (ordered_ring empty)) empty) : @t1_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_146978 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) Type) : @totally_disconnected_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_146979 (h0 : uniform_space empty) : separated_space empty := sorry --non-trivial
lemma new_lemma_146980 (h0 : topological_space (has_zero (has_add unsigned))) : regular_space (has_zero (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_146981 (h0 : functor.add_const (function.extfun (Type 1) cancel_comm_monoid_with_zero) (has_neg linarith.comp)) : @unique_factorization_monoid.{1} Type (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1}) (has_neg.{0} linarith.comp) h0) Type)  := sorry --non-trivial
lemma new_lemma_146982 (h0 : list (has_neg (comm_group unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_146983 (h0 : topological_space (boolean_algebra.core (finset Type))) : loc_path_connected_space (boolean_algebra.core (finset Type)) := sorry --non-trivial
lemma new_lemma_146984 (h0 : topological_space (bin_tree num)) : preirreducible_space (bin_tree num) := sorry --non-trivial
lemma new_lemma_146985 (h0 : topological_space (complete_distrib_lattice (has_add (has_add linarith.comp)))) : regular_space (complete_distrib_lattice (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_146986 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @totally_separated_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_146987 (h0 : function.extfun (Type 1) filter) : countable_Inter_filter (function.extfun_app h0 (has_zero Type)) := sorry --non-trivial
lemma new_lemma_146988 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_146989 (h0 : not (ring (with_one (random_gen fun_info)) -> false)) : @rank_condition.{0} (with_one.{0} (random_gen.{0} fun_info)) (@classical.by_contradiction'.{1} (ring.{0} (with_one.{0} (random_gen.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_146990 (h1 : topological_space (random_gen (comm_ring (has_nnnorm reducibility_hints)))) : totally_disconnected_space (random_gen (comm_ring (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_146991 (h0 : topological_space (boolean_algebra (has_neg_part (has_add (has_add Type))))) : discrete_topology (boolean_algebra (has_neg_part (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_146992 (h0 : complete_lattice (generalized_boolean_algebra Type)) : is_compactly_generated (generalized_boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_146993 (h0 : topological_space (linear_ordered_field (option empty))) : t0_space (linear_ordered_field (option empty)) := sorry --non-trivial
lemma new_lemma_146994 (h0 : has_neg (has_lt (has_one (mul_one_class (mul_one_class enat))))) (h1 : measurable_space (has_lt (has_one (mul_one_class (mul_one_class enat))))) : has_measurable_neg (has_lt (has_one (mul_one_class (mul_one_class enat)))) := sorry --non-trivial
lemma new_lemma_146995 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_146996 (h0 : functor.add_const (complete_lattice (semigroup Type)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (semigroup.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_146997 (h0 : group (mul_zero_class (has_top unsigned))) : is_cyclic (mul_zero_class (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_146998 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (measure_theory.measure_space.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (measure_theory.measure_space.{0} num))  := sorry --non-trivial
lemma new_lemma_146999 (h0 : function.extfun Type topological_space) : @t1_space.{0} (normed_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_147000 (h0 : functor.add_const (add_group (ring name)) Type) : @is_add_cyclic.{0} (ring.{0} name) (@functor.add_const.run.{0 1} (add_group.{0} (ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_147001 (h0 : has_mem.mem (measurable_space (has_norm fun_info)) has_emptyc.emptyc) : @group.fg.{0} (measurable_space.{0} (has_norm.{0} fun_info)) (@finset.pi.empty.{1 0} Type group.{0} (measurable_space.{0} (has_norm.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_147002 (h0 : semiring (has_sub (semiring congr_arg_kind))) : is_noetherian_ring (has_sub (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_147003 (h1 : topological_space (distrib linarith.ineq)) : t0_space (distrib linarith.ineq) := sorry --non-trivial
lemma new_lemma_147004 (h1 : ring (distrib (has_ssubset (has_ssubset char)))) : strong_rank_condition (distrib (has_ssubset (has_ssubset char))) := sorry --non-trivial
lemma new_lemma_147005 (h0 : filter (normed_linear_ordered_group num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_147006 (h0 h1 : multiset (normed_field enat)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_147007 (h0 : complete_lattice (monoid empty)) : complete_lattice.is_Sup_finite_compact (monoid empty) := sorry --non-trivial
lemma new_lemma_147008 (h0 : ring real.angle) : is_domain real.angle := sorry --non-trivial
lemma new_lemma_147009 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_147010 (h1 : has_neg (simple_graph fun_info)) (h2 : measurable_space (simple_graph fun_info)) : has_measurable_neg (simple_graph fun_info) := sorry --non-trivial
lemma new_lemma_147011 (h0 : group (id (has_inv (has_top linarith.comp_source)))) : normalizer_condition (id (has_inv (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_147012 (h0 : Type -> linarith.comp -> Prop) : relator.bi_total h0 := sorry --non-trivial
lemma new_lemma_147013 (h0 : topological_space (complete_distrib_lattice (has_to_string (has_to_string (has_to_string pos))))) : normal_space (complete_distrib_lattice (has_to_string (has_to_string (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_147014 (h0 : functor.add_const (topological_space (semigroup pos)) Type) : @normal_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_147015 (h0 : functor.add_const (topological_space (id empty)) empty) : @locally_compact_space.{0} (@id.{2} Type empty) (@functor.add_const.run.{0 0} (topological_space.{0} (@id.{2} Type empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_147016 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) (finset Type)) : @irreducible_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} linarith.comp)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_147017 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.tfae (function.extfun_app (function.extfun_app h0 list) Prop) := sorry --non-trivial
lemma new_lemma_147018 (h0 : ring (mul_zero_class (finset (finset (finset Type))))) : strong_rank_condition (mul_zero_class (finset (finset (finset Type)))) := sorry --non-trivial
lemma new_lemma_147019 (h0 : complete_lattice (has_append (random_gen linarith.ineq))) : is_compactly_generated (has_append (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_147020 (h0 : topological_space (semiring (has_norm (has_emptyc (has_top fun_info))))) : t0_space (semiring (has_norm (has_emptyc (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_147021 (h0 : uniform_space (ring (has_Inf (has_Inf linarith.comp)))) : complete_space (ring (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_147022 (h0 : not (add_group (has_add linarith.ineq) -> false)) : @is_add_cyclic.{0} (has_add.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (has_add.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_147023 (h0 : fin has_zero.zero) : @preconnected_space.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_147024 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (denumerable linarith.ineq)) := sorry --non-trivial
lemma new_lemma_147025 (h0 : ring (has_ssubset (metric_space char))) : strong_rank_condition (has_ssubset (metric_space char)) := sorry --non-trivial
lemma new_lemma_147026 (h0 : topological_space (has_one (semiring congr_arg_kind))) : normal_space (has_one (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_147027 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_147028 (h0 : fin has_zero.zero) : @t0_space.{0} (simple_graph.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (simple_graph.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_147029 (h0 : not (filter (option num) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_147030 (h0 : uniform_space (non_unital_non_assoc_semiring (mul_one_class fun_info))) : complete_space (non_unital_non_assoc_semiring (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_147031 (h0 : filter (add_comm_monoid (comm_group (comm_group (has_add (comm_group Type)))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_147032 (h1 : topological_space (has_nnnorm (has_pow string.iterator_imp char))) : t0_space (has_nnnorm (has_pow string.iterator_imp char)) := sorry --non-trivial
lemma new_lemma_147033 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_147034 (h0 : function.extfun (finset Type -> Prop) (function.extfun (finset Type))) : @strong_rank_condition.{0} (measurable_space.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} linarith.comp_source)) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) h0 (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} linarith.comp_source))) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_147035 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (mul_zero_class congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_147036 (h0 : topological_space (has_to_string (has_add (has_add linarith.comp)))) : t0_space (has_to_string (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_147037 (h0 : complete_lattice (measure_theory.measure_space (semiring unsigned))) : is_atomistic (measure_theory.measure_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_147038 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @loc_path_connected_space.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_147039 (h0 : functor.add_const (topological_space (option empty)) (semiring (semiring (semiring num)))) : @t1_space.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} empty)) (semiring.{0} (semiring.{0} (semiring.{0} num))) h0)  := sorry --non-trivial
lemma new_lemma_147040 (h0 : function.extfun Type (functor.comp uniform_space cancel_monoid)) : @separated_space.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} uniform_space.{0} cancel_monoid.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} uniform_space.{0} cancel_monoid.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_147041 (h0 : topological_space (has_Inf (has_add Type))) : locally_compact_space (has_Inf (has_add Type)) := sorry --non-trivial
lemma new_lemma_147042 (h0 : topological_space (has_Inf name)) : preirreducible_space (has_Inf name) := sorry --non-trivial
lemma new_lemma_147043 (h0 : uniform_space (complete_linear_order unsigned)) : complete_space (complete_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_147044 (h0 : group (has_neg_part (finset ennreal))) : is_simple_group (has_neg_part (finset ennreal)) := sorry --non-trivial
lemma new_lemma_147045 (h0 : topological_space (has_nndist (finset (finset pos)))) : discrete_topology (has_nndist (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_147046 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : is_atomistic (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_147047 (h0 : uniform_space (has_dist congr_arg_kind)) : separated_space (has_dist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_147048 (h0 : filter (has_Inf (has_pos_part (finset (has_Inf linarith.comp))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_147049 (h0 : functor.add_const (filter (ordered_comm_ring linarith.comp)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_147050 (h0 : functor.add_const (uniform_space (left_cancel_monoid num)) num) : @separated_space.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (left_cancel_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_147051 (h1 : topological_space (has_append reducibility_hints)) : totally_disconnected_space (has_append reducibility_hints) := sorry --non-trivial
lemma new_lemma_147052 (h0 : topological_space (has_le environment.projection_info)) (h1 : add_group (has_le environment.projection_info)) : topological_add_group (has_le environment.projection_info) := sorry --non-trivial
lemma new_lemma_147053 (h0 : ring (ordered_comm_ring (has_nndist (has_nndist (ring linarith.comp))))) : rank_condition (ordered_comm_ring (has_nndist (has_nndist (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_147054 (h0 : functor.add_const (ordered_add_comm_monoid (comm_group name)) environment.implicit_infer_kind) : @archimedean.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (comm_group.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_147055 (h0 : set (add_comm_semigroup ereal -> char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_147056 (h0 : topological_space (has_nndist (finset name))) : t1_space (has_nndist (finset name)) := sorry --non-trivial
lemma new_lemma_147057 (h0 : functor.add_const (ring (ordered_comm_ring Type)) (has_add (has_Inf Type))) : @strong_rank_condition.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (ordered_comm_ring.{1} Type)) (has_add.{1} (has_Inf.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_147058 (h0 : function.extfun Type ring) : @is_domain.{0} char (@function.extfun_app.{2 1} Type ring.{0} h0 char)  := sorry --non-trivial
lemma new_lemma_147059 (h0 : not (add_group (normed_field reducibility_hints) -> false)) : @is_add_cyclic.{0} (normed_field.{0} reducibility_hints) (@classical.by_contradiction'.{1} (add_group.{0} (normed_field.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_147060 (h0 : topological_space (dlist (has_nnnorm fun_info))) : irreducible_space (dlist (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_147061 (h0 : group (plift (semiring unsigned))) : group.fg (plift (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_147062 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @totally_separated_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_147063 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_147064 (h0 : uniform_space (add_group (semiring (semiring (semiring congr_arg_kind))))) : separated_space (add_group (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_147065 (h0 : functor.add_const (list (has_add linarith.comp)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_147066 (h0 : complete_lattice (has_Inf (ring Type))) : complete_lattice.is_Sup_finite_compact (has_Inf (ring Type)) := sorry --non-trivial
lemma new_lemma_147067 (h0 : topological_space (has_add (has_neg (has_add pos)))) : sequential_space (has_add (has_neg (has_add pos))) := sorry --non-trivial
lemma new_lemma_147068 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) (ring name)) : @archimedean.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) (ring.{0} name) h0) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_147069 (h0 : filter (has_zero (has_zero linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_147070 (h0 : list (non_assoc_semiring num)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_147071 (h0 : topological_space (finset congr_arg_kind)) : irreducible_space (finset congr_arg_kind) := sorry --non-trivial
lemma new_lemma_147072 (h0 : cancel_comm_monoid_with_zero (has_nndist (has_nndist unsigned))) : unique_factorization_monoid (has_nndist (has_nndist unsigned)) := sorry --non-trivial
lemma new_lemma_147073 (h0 : functor.add_const (complete_lattice (canonically_ordered_comm_semiring environment.implicit_infer_kind)) pos) : @is_atomistic.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_147074 (h0 : complete_lattice (has_neg_part (has_to_string (has_nndist name)))) : is_atomistic (has_neg_part (has_to_string (has_nndist name))) := sorry --non-trivial
lemma new_lemma_147075 (h0 : ring (finset (has_add linarith.comp))) : is_domain (finset (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_147076 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_147077 (h0 : semiring (boolean_algebra (has_add pos))) : is_noetherian_ring (boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_147078 (h0 : monoid (with_one to_additive.value_type)) : monoid.fg (with_one to_additive.value_type) := sorry --non-trivial
lemma new_lemma_147079 (h0 : functor.add_const (topological_space (add_comm_monoid environment.implicit_infer_kind)) name) : @t1_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_147080 (h0 : uniform_space (linear_ordered_comm_group_with_zero linarith.comp_source)) : complete_space (linear_ordered_comm_group_with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_147081 (h0 : semiring (ring (has_Inf (has_add (ordered_ring linarith.comp))))) : is_noetherian_ring (ring (has_Inf (has_add (ordered_ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_147082 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) linarith.comp) : @sequential_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_147083 (h0 : functor.add_const (topological_space (semigroup unsigned)) name) : @preconnected_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_147084 (h0 : set (add_comm_semigroup string.iterator_imp)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_147085 (h0 : ring (normed_group (with_bot (random_gen (random_gen to_additive.value_type))))) : is_domain (normed_group (with_bot (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_147086 (h0 : ring (canonically_ordered_monoid (has_Inf real))) : is_domain (canonically_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_147087 (h0 : ring (metric_space (semiring (semiring linarith.comp)))) : is_domain (metric_space (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_147088 (h0 : topological_space (boolean_algebra.core (normed_comm_ring Type))) : preirreducible_space (boolean_algebra.core (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_147089 (h0 : uniform_space (add_comm_monoid (has_add (has_Inf Type)))) : complete_space (add_comm_monoid (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_147090 (h0 : filter (add_group (semiring (semiring (semiring congr_arg_kind))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_147091 (h0 : functor.add_const (topological_space (cancel_monoid empty)) ennreal) : @path_connected_space.{0} (cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} empty)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_147092 (h0 : topological_space (cancel_monoid (finset (cancel_monoid (has_to_string name))))) : regular_space (cancel_monoid (finset (cancel_monoid (has_to_string name)))) := sorry --non-trivial
lemma new_lemma_147093 (h0 : complete_lattice (add_cancel_comm_monoid (comm_ring linarith.comp_source))) : is_compactly_generated (add_cancel_comm_monoid (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_147094 (h0 : function.extfun Type group) : @is_cyclic.{0} (ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_147095 (h0 : group (has_add string_imp)) : is_cyclic (has_add string_imp) := sorry --non-trivial
lemma new_lemma_147096 (h0 : functor.comp group has_compl string_imp) : @is_cyclic.{0} (has_compl.{0} string_imp) (@functor.comp.run.{0 0 0} group.{0} has_compl.{0} string_imp h0)  := sorry --non-trivial
lemma new_lemma_147097 (h0 : monoid (complete_semilattice_Sup (semiring num))) : monoid.fg (complete_semilattice_Sup (semiring num)) := sorry --non-trivial
lemma new_lemma_147098 (h0 : not (ring (dlist linarith.comp_source) -> false)) : @is_domain.{0} (dlist.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (dlist.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_147099 (h0 : functor.add_const (add_monoid (complete_distrib_lattice num)) empty) : @add_monoid.fg.{0} (complete_distrib_lattice.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (complete_distrib_lattice.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_147100 (h0 : function.extfun (Type 1) list) : palindrome (function.extfun_app h0 (has_add Type)) := sorry --non-trivial
lemma new_lemma_147101 (h0 : topological_space (complete_distrib_lattice (has_add pos))) : totally_separated_space (complete_distrib_lattice (has_add pos)) := sorry --non-trivial
lemma new_lemma_147102 (h0 : functor.add_const (group (comm_group Type)) linarith.comp) : @group.fg.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (comm_group.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_147103 (h0 : functor.add_const (complete_lattice (has_nndist Type)) Type) : @is_atomistic.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (has_nndist.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_147104 (h0 : add_group (distrib (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) : is_add_cyclic (distrib (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_147105 (h0 : filter (add_comm_monoid (comm_group (comm_group (comm_group (comm_group (comm_group (comm_group name)))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_147106 (h0 : ring (normed_linear_ordered_group (option empty))) : is_domain (normed_linear_ordered_group (option empty)) := sorry --non-trivial
lemma new_lemma_147107 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) pos) : @locally_compact_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_147108 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_147109 (h0 : not (ring (ordered_comm_ring linarith.comp_source) -> false)) : @is_domain.{0} (ordered_comm_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (ordered_comm_ring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_147110 (h0 : ring (simple_graph fun_info)) : rank_condition (simple_graph fun_info) := sorry --non-trivial
lemma new_lemma_147111 (h0 : ring (add_group (semiring num))) : strong_rank_condition (add_group (semiring num)) := sorry --non-trivial
lemma new_lemma_147112 (h0 : topological_space (normed_linear_ordered_group (semiring unsigned))) : totally_separated_space (normed_linear_ordered_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_147113 (h0 : ring (cancel_monoid (has_add linarith.comp))) : strong_rank_condition (cancel_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_147114 (h1 : ring (with_bot (semiring linarith.comp))) : is_domain (with_bot (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_147115 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_147116 (h0 : filter (non_assoc_semiring (semiring congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_147117 (h0 : group (has_Inf (has_pos_part pos))) : is_cyclic (has_Inf (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_147118 (h0 : functor.add_const (function.extfun Type semiring) (normed_comm_ring Type)) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type semiring.{0}) (normed_comm_ring.{1} Type) h0) (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_147119 (h0 : topological_space (has_one empty)) : t0_space (has_one empty) := sorry --non-trivial
lemma new_lemma_147120 (h0 : topological_space (omega_complete_partial_order empty)) : totally_separated_space (omega_complete_partial_order empty) := sorry --non-trivial
lemma new_lemma_147121 (h0 : functor.add_const (semiring (has_dist unsigned)) empty) : @is_noetherian_ring.{0} (has_dist.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (has_dist.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_147122 (h0 : functor.add_const (ring (has_nndist pos)) linarith.comp) : @rank_condition.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_147123 (h0 : prod (partial_order (semiring congr_arg_kind)) (partial_order (semiring congr_arg_kind))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_147124 (h1 : ring (fintype (random_gen (random_gen string_imp)))) : rank_condition (fintype (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_147125 (h0 : topological_space (has_one to_additive.value_type)) : t0_space (has_one to_additive.value_type) := sorry --non-trivial
lemma new_lemma_147126 (h0 : ring (free_add_monoid (option (option unsigned)))) : is_domain (free_add_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_147127 (h0 : topological_space (has_zero (finset (has_add (finset linarith.comp))))) : discrete_topology (has_zero (finset (has_add (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_147128 (h0 : topological_space (add_cancel_monoid (finset Type))) : preirreducible_space (add_cancel_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_147129 (h0 : functor.add_const (ordered_add_comm_monoid (has_pos_part linarith.comp)) pos) : @archimedean.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_pos_part.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_147130 (h0 : topological_space (add_group unsigned)) : preirreducible_space (add_group unsigned) := sorry --non-trivial
lemma new_lemma_147131 (h0 : add_monoid (linear_ordered_semiring (has_norm unsigned))) : add_monoid.fg (linear_ordered_semiring (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_147132 (h0 : topological_space (with_one (random_gen (comm_ring linarith.ineq)))) : irreducible_space (with_one (random_gen (comm_ring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_147133 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_add congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_147134 (h1 : heq environment.projection_info fun_info) (h2 : complete_lattice environment.projection_info) : @complete_lattice.is_Sup_finite_compact.{0} fun_info (@heq.elim.{2 1} Type environment.projection_info complete_lattice.{0} fun_info h1 h2)  := sorry --non-trivial
lemma new_lemma_147135 (h0 : functor.add_const (complete_lattice (has_nndist pos)) linarith.comp) : @is_atomistic.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_147136 (h0 : ring (monoid ennreal)) : is_domain (monoid ennreal) := sorry --non-trivial
lemma new_lemma_147137 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_147138 (h1 : group (topological_space (denumerable (denumerable reducibility_hints)))) : is_cyclic (topological_space (denumerable (denumerable reducibility_hints))) := sorry --non-trivial
lemma new_lemma_147139 (h0 : ring (random_gen (semilattice_inf string_imp))) : strong_rank_condition (random_gen (semilattice_inf string_imp)) := sorry --non-trivial
lemma new_lemma_147140 (h0 : functor.add_const (topological_space (has_zero Type)) (ring name)) : @totally_separated_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_147141 (h0 : functor.add_const (topological_space (add_cancel_comm_monoid empty)) unsigned) : @preirreducible_space.{0} (add_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_comm_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_147142 (h0 : functor.comp ring canonically_ordered_comm_semiring Type) : @rank_condition.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} canonically_ordered_comm_semiring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_147143 (h0 : topological_space (ring (mul_one_class pos))) : locally_compact_space (ring (mul_one_class pos)) := sorry --non-trivial
lemma new_lemma_147144 (h0 : topological_space (add_comm_monoid (has_add ennreal))) : t1_space (add_comm_monoid (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_147145 (h0 : add_group (canonically_ordered_comm_semiring (has_add Type))) : is_add_cyclic (canonically_ordered_comm_semiring (has_add Type)) := sorry --non-trivial
lemma new_lemma_147146 (h0 : cancel_comm_monoid_with_zero (comm_group (has_add name))) : unique_factorization_monoid (comm_group (has_add name)) := sorry --non-trivial
lemma new_lemma_147147 (h0 : complete_lattice (has_lt (metric_space to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (has_lt (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_147148 (h0 : functor.add_const (functor.add_const (ring (add_comm_monoid name)) environment.implicit_infer_kind) Type) : @is_domain.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} name)) environment.implicit_infer_kind (@functor.add_const.run.{0 1} (functor.add_const.{0 0} (ring.{0} (add_comm_monoid.{0} name)) environment.implicit_infer_kind) Type h0))  := sorry --non-trivial
lemma new_lemma_147149 (h0 : functor.add_const (ring (normed_comm_ring Type)) Type) : @is_principal_ideal_ring.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (normed_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_147150 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) pos) : @totally_disconnected_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_147151 (h0 : functor.add_const (complete_lattice (semigroup unsigned)) Type) : @is_atomistic.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 1} (complete_lattice.{0} (semigroup.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_147152 (h0 : functor.add_const (topological_space (cancel_monoid Type)) Type) : @normal_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_147153 (h0 : group (comm_ring (has_norm char))) : group.fg (comm_ring (has_norm char)) := sorry --non-trivial
lemma new_lemma_147154 (h0 : function.extfun Type group) : @is_cyclic.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_147155 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) real) : @topological_space.separable_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_147156 (h0 : group (normed_group (denumerable (denumerable (has_inv (denumerable linarith.ineq)))))) : group.fg (normed_group (denumerable (denumerable (has_inv (denumerable linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_147157 (h0 : filter (add_cancel_monoid (option (option (option (option ennreal)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_147158 (h0 : ordered_add_comm_monoid (boolean_algebra (ring name))) : archimedean (boolean_algebra (ring name)) := sorry --non-trivial
lemma new_lemma_147159 (h0 : functor.comp topological_space has_to_string environment.implicit_infer_kind) : @sequential_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_147160 (h0 : function.extfun nat fin) : @totally_disconnected_space.{0} (generalized_boolean_algebra.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (generalized_boolean_algebra.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_147161 (h0 : semiring (boolean_algebra.core (has_add (has_add (has_add pos))))) : is_noetherian_ring (boolean_algebra.core (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_147162 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_147163 (h0 : monoid (distrib_lattice (random_gen (comm_ring to_additive.value_type)))) : monoid.fg (distrib_lattice (random_gen (comm_ring to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_147164 (h0 : ring (random_gen (has_norm empty))) : is_domain (random_gen (has_norm empty)) := sorry --non-trivial
lemma new_lemma_147165 (h0 : set (prod name name)) (h1 : function.extfun Type (prod name)) : symmetrize_rel h0 (function.extfun_app h1 name) := sorry --non-trivial
lemma new_lemma_147166 (h0 : fin has_zero.zero) : @strong_rank_condition.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (generalized_boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_147167 (h0 : topological_space (add_comm_monoid name)) : totally_separated_space (add_comm_monoid name) := sorry --non-trivial
lemma new_lemma_147168 (h0 : not (has_mem.mem (random_gen fun_info) has_emptyc.emptyc -> false)) : @path_connected_space.{0} (random_gen.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_147169 (h0 : group string_imp) : group.fg string_imp := sorry --non-trivial
lemma new_lemma_147170 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_147171 (h0 : functor.add_const (complete_lattice (mul_zero_class environment.implicit_infer_kind)) name) : @is_atomistic.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (mul_zero_class.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_147172 (h0 : topological_space (canonically_ordered_comm_semiring (has_add (ordered_comm_monoid linarith.comp)))) : t1_space (canonically_ordered_comm_semiring (has_add (ordered_comm_monoid linarith.comp))) := sorry --non-trivial
lemma new_lemma_147173 (h0 h1 : multiset (semi_normed_ring reducibility_hints)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_147174 (h0 : functor.add_const (ordered_comm_monoid (comm_group unsigned)) (has_zero (ring name))) : @has_exists_mul_of_le.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (comm_group.{0} unsigned)) (has_zero.{0} (ring.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_147175 (h0 : group (has_norm linarith.comp)) : is_cyclic (has_norm linarith.comp) := sorry --non-trivial
lemma new_lemma_147176 (h0 : functor.add_const (list (ordered_comm_ring name)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_147177 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) name) : @regular_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_147178 (h0 : uniform_space (normed_comm_ring (comm_monoid unsigned))) : separated_space (normed_comm_ring (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_147179 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_inv.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_inv.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_147180 (h0 : topological_space (cancel_monoid (option (option (option (option (option ennreal))))))) : path_connected_space (cancel_monoid (option (option (option (option (option ennreal)))))) := sorry --non-trivial
lemma new_lemma_147181 (h0 : topological_space (add_comm_monoid num)) : loc_path_connected_space (add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_147182 (h0 : is_empty (option num)) (h1 : option num) : @group.fg.{0} nnreal (@is_empty.elim'.{1 1} (option.{0} num) (group.{0} nnreal) h0 h1)  := sorry --non-trivial
lemma new_lemma_147183 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} name (@function.extfun_app.{2 1} Type ring.{0} h0 name)  := sorry --non-trivial
lemma new_lemma_147184 (h0 : group (has_inv (random_gen string_imp))) : group.fg (has_inv (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_147185 (h0 : functor.add_const (topological_space (finset Type)) name) : @sequential_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_147186 (h0 : functor.comp topological_space canonically_linear_ordered_monoid (option name)) : @t1_space.{0} (canonically_linear_ordered_monoid.{0} (option.{0} name)) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_linear_ordered_monoid.{0} (option.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_147187 (h0 : topological_space (has_ssubset char)) (h1 : preorder (has_ssubset char)) : order_topology (has_ssubset char) := sorry --non-trivial
lemma new_lemma_147188 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_147189 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_to_string.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} empty))  := sorry --non-trivial
lemma new_lemma_147190 (h0 : not (complete_lattice (normed_field linarith.comp_source) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (normed_field.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_field.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_147191 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_147192 (h0 : topological_space fun_info) (h1 : set fun_info) : is_irreducible h1 := sorry --non-trivial
lemma new_lemma_147193 (h0 : linarith.comp_source -> linarith.comp_source -> bool) : is_dec_refl h0 := sorry --non-trivial
lemma new_lemma_147194 (h0 : functor.add_const (topological_space (has_add nnreal)) Type) : @t1_space.{0} (has_add.{0} nnreal) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} nnreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_147195 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (preorder.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (preorder.{0} num))  := sorry --non-trivial
lemma new_lemma_147196 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (finset (has_neg (finset (finset pos))))) : @t1_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (finset.{0} (has_neg.{0} (finset.{0} (finset.{0} pos)))) h0) Type)  := sorry --non-trivial
lemma new_lemma_147197 (h0 : topological_space (canonically_ordered_comm_semiring (add_comm_monoid Type))) : regular_space (canonically_ordered_comm_semiring (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_147198 (h0 : functor.add_const (topological_space (cancel_monoid Type)) pos) : @loc_path_connected_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_147199 (h2 : ring (uniform_space to_additive.value_type)) : is_domain (uniform_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_147200 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_147201 (h0 : topological_space (normed_comm_ring (has_to_string (ring linarith.comp)))) : preirreducible_space (normed_comm_ring (has_to_string (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_147202 (h0 : ring (has_bot unsigned)) : rank_condition (has_bot unsigned) := sorry --non-trivial
lemma new_lemma_147203 (h0 : fin has_zero.zero) : @is_domain.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (has_pos_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_147204 (h2 : not (group (has_nnnorm to_additive.value_type) -> false)) : @is_cyclic.{0} (has_nnnorm.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (has_nnnorm.{0} to_additive.value_type)) h2)  := sorry --non-trivial
lemma new_lemma_147205 (h0 : not (complete_lattice (topological_space to_additive.value_type) -> false)) : is_compactly_generated (topological_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_147206 (h1 : topological_space (distrib (has_compl (semi_normed_ring (comm_ring fun_info))))) : path_connected_space (distrib (has_compl (semi_normed_ring (comm_ring fun_info)))) := sorry --non-trivial
lemma new_lemma_147207 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_ssubset.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_ssubset.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_147208 (h0 : function.extfun Type topological_space) : @t0_space.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_147209 (h0 : complete_lattice (left_cancel_monoid (semiring (semiring num)))) : is_atomistic (left_cancel_monoid (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_147210 (h0 : functor.add_const (topological_space (has_Inf pos)) (ring pos)) : @regular_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_147211 (h0 : ring (distrib (has_nnnorm (has_nnnorm to_additive.value_type)))) : strong_rank_condition (distrib (has_nnnorm (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_147212 (h0 : functor.add_const (topological_space (ring Type)) (finset environment.implicit_infer_kind)) : @topological_space.separable_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_147213 (h0 : topological_space (boolean_algebra (mul_one_class Type))) : preirreducible_space (boolean_algebra (mul_one_class Type)) := sorry --non-trivial
lemma new_lemma_147214 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_147215 (h0 : topological_space (generalized_boolean_algebra (has_add Type))) : totally_separated_space (generalized_boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_147216 (h0 : function.extfun Type (functor.add_const (ring unsigned))) : @strong_rank_condition.{0} unsigned (@functor.add_const.run.{0 0} (ring.{0} unsigned) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} unsigned)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_147217 (h0 : not (topological_space congr_arg_kind -> false)) : @t0_space.{0} congr_arg_kind (@classical.by_contradiction'.{1} (topological_space.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_147218 (h0 : functor.add_const (group (ordered_ring empty)) (semiring empty)) : @group.fg.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (ordered_ring.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_147219 (h0 : topological_space (normed_group (semiring (semiring num)))) : locally_compact_space (normed_group (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_147220 (h0 : cancel_comm_monoid_with_zero (group_with_zero num)) : unique_factorization_monoid (group_with_zero num) := sorry --non-trivial
lemma new_lemma_147221 (h0 : filter (mul_one_class unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_147222 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_147223 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_147224 (h0 : topological_space (add_cancel_monoid (option (option empty)))) : preconnected_space (add_cancel_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_147225 (h1 : Prop) : set.separates_points (id (fun (h0 : linarith.ineq -> enat), h1)) := sorry --non-trivial
lemma new_lemma_147226 (h0 : fin has_zero.zero) : @discrete_topology.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_147227 (h0 : topological_space (has_Inf (has_Inf (ring name)))) : irreducible_space (has_Inf (has_Inf (ring name))) := sorry --non-trivial
lemma new_lemma_147228 (h0 : topological_space (option (semiring empty))) : discrete_topology (option (semiring empty)) := sorry --non-trivial
lemma new_lemma_147229 (h0 : functor.add_const (add_group (canonically_ordered_comm_semiring ennreal)) name) : @is_add_cyclic.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (add_group.{0} (canonically_ordered_comm_semiring.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_147230 (h0 : functor.add_const (ring (finset name)) (finset linarith.comp)) : @is_principal_ideal_ring.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} name)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_147231 (h0 : topological_space (with_one empty)) : normal_space (with_one empty) := sorry --non-trivial
lemma new_lemma_147232 (h0 : add_monoid (has_neg (boolean_algebra.core name))) : add_monoid.fg (has_neg (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_147233 (h0 : functor.add_const (ring (normed_linear_ordered_group unsigned)) empty) : @rank_condition.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (normed_linear_ordered_group.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_147234 (h0 : functor.add_const (complete_lattice (comm_group environment.implicit_infer_kind)) (has_add name)) : @is_atomistic.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} environment.implicit_infer_kind)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_147235 (h0 : group (ordered_cancel_add_comm_monoid (option unsigned))) : is_simple_group (ordered_cancel_add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_147236 (h0 : ring (add_cancel_comm_monoid (has_nnnorm (has_nnnorm reducibility_hints)))) : rank_condition (add_cancel_comm_monoid (has_nnnorm (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_147237 (h0 : group (power_series (has_nnnorm fun_info))) : is_cyclic (power_series (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_147238 (h0 : uniform_space (complete_semilattice_Sup (with_bot string_imp))) : complete_space (complete_semilattice_Sup (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_147239 (h0 : add_group (complete_distrib_lattice unsigned)) : is_add_cyclic (complete_distrib_lattice unsigned) := sorry --non-trivial
lemma new_lemma_147240 (h0 : has_neg std_gen) (h1 : measurable_space std_gen) : has_measurable_neg std_gen := sorry --non-trivial
lemma new_lemma_147241 (h0 : group (add_group (semiring (semiring congr_arg_kind)))) : normalizer_condition (add_group (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_147242 (h0 : functor.add_const (function.extfun Type topological_space) name) : @irreducible_space.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_147243 (h0 : functor.add_const (function.extfun Type uniform_space) Type) : @complete_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) Type h0) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_147244 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_atomistic.{0} (non_assoc_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) complete_lattice.{0}) (non_assoc_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_147245 (h0 : not (topological_space (measurable_space.dynkin_system empty) -> false)) : @totally_disconnected_space.{0} (measurable_space.dynkin_system.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.dynkin_system.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_147246 (h0 : topological_space (boolean_algebra (has_neg_part name))) : preconnected_space (boolean_algebra (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_147247 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (normed_comm_ring (has_neg Type))) : @irreducible_space.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) (normed_comm_ring.{1} (has_neg.{1} Type)) h0) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_147248 (h0 : ring (uniform_space linarith.comp_source)) : strong_rank_condition (uniform_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_147249 (h0 : uniform_space (semigroup (semiring (semiring unsigned)))) : complete_space (semigroup (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_147250 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_147251 (h0 : functor.comp add_monoid has_neg_part name) : @add_monoid.fg.{0} (has_neg_part.{0} name) (@functor.comp.run.{0 0 0} add_monoid.{0} has_neg_part.{0} name (@functor.comp.run.{0 0 0} add_monoid.{0} has_neg_part.{0} name (@functor.comp.run.{0 0 0} add_monoid.{0} has_neg_part.{0} name (@functor.comp.run.{0 0 0} add_monoid.{0} has_neg_part.{0} name (@functor.comp.run.{0 0 0} add_monoid.{0} has_neg_part.{0} name h0)))))  := sorry --non-trivial
lemma new_lemma_147252 (h0 : topological_space (add_comm_monoid (has_add unsigned))) : irreducible_space (add_comm_monoid (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_147253 (h0 : uniform_space (add_cancel_monoid Type)) : complete_space (add_cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_147254 (h0 : uniform_space (add_comm_monoid (option ennreal))) : separated_space (add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_147255 (h0 : fin has_zero.zero) (h1 : fin (has_add.add has_zero.zero has_one.one)) : matrix.vec_empty (id (fin.pred_above h0 h1)) := sorry --non-trivial
lemma new_lemma_147256 (h0 : functor.add_const Prop (boolean_algebra unsigned)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_147257 (h0 : functor.add_const (list (add_cancel_monoid environment.implicit_infer_kind)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_147258 (h0 : topological_space (canonically_ordered_monoid (has_Inf real))) : t0_space (canonically_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_147259 (h0 : finset (cancel_monoid (comm_group name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_147260 (h0 : complete_lattice (has_Sup (option (option unsigned)))) : is_atomistic (has_Sup (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_147261 (h1 : topological_space (has_compl (random_gen (has_ssubset char)))) : t0_space (has_compl (random_gen (has_ssubset char))) := sorry --non-trivial
lemma new_lemma_147262 (h0 : preorder (add_comm_semigroup string.iterator_imp)) (h1 : set (add_comm_semigroup string.iterator_imp)) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_147263 (h0 : uniform_space (add_comm_monoid (comm_group (comm_group Type)))) : complete_space (add_comm_monoid (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_147264 (h0 : functor.add_const (ring (has_neg linarith.comp)) (has_neg name)) : @rank_condition.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} linarith.comp)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_147265 (h0 : group (canonically_ordered_comm_semiring unsigned)) : group.fg (canonically_ordered_comm_semiring unsigned) := sorry --non-trivial
lemma new_lemma_147266 (h1 : ring (random_gen (metric_space to_additive.value_type))) : rank_condition (random_gen (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_147267 (h0 : not (uniform_space (measurable_space empty) -> false)) : @complete_space.{0} (measurable_space.{0} empty) (@classical.by_contradiction'.{1} (uniform_space.{0} (measurable_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_147268 (h0 : functor.add_const (list Type) (has_neg pos)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_147269 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_147270 (h0 : uniform_space (canonically_ordered_monoid (has_Inf name))) : complete_space (canonically_ordered_monoid (has_Inf name)) := sorry --non-trivial
lemma new_lemma_147271 (h0 : complete_lattice (has_emptyc linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (has_emptyc linarith.comp_source) := sorry --non-trivial
lemma new_lemma_147272 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_147273 (h1 : not (ring (has_ssubset linarith.comp_source) -> false)) : @strong_rank_condition.{0} (has_ssubset.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_147274 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (canonically_ordered_comm_semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_147275 (h0 : topological_space (ordered_comm_ring (finset (linear_ordered_cancel_comm_monoid linarith.comp)))) : sequential_space (ordered_comm_ring (finset (linear_ordered_cancel_comm_monoid linarith.comp))) := sorry --non-trivial
lemma new_lemma_147276 (h0 : not (topological_space (measure_theory.measure_space congr_arg_kind) -> false)) : @topological_space.separable_space.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (measure_theory.measure_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_147277 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) linarith.comp) : @separated_space.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) uniform_space.{1}) linarith.comp h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_147278 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_147279 (h0 : complete_lattice (has_norm (has_norm (has_norm empty)))) : complete_lattice.is_Sup_finite_compact (has_norm (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_147280 (h0 : topological_space (distrib (has_nnnorm (has_ssubset linarith.comp_source)))) : path_connected_space (distrib (has_nnnorm (has_ssubset linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_147281 (h0 : monoid (linear_ordered_comm_monoid_with_zero (option (option unsigned)))) : monoid.fg (linear_ordered_comm_monoid_with_zero (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_147282 (h0 : topological_space (mul_zero_class environment.implicit_infer_kind)) : discrete_topology (mul_zero_class environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_147283 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) name) : @irreducible_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_147284 (h0 : not (complete_lattice (distrib_lattice string_imp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (distrib_lattice.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (distrib_lattice.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_147285 (h0 : topological_space (canonically_linear_ordered_monoid empty)) : topological_space.separable_space (canonically_linear_ordered_monoid empty) := sorry --non-trivial
lemma new_lemma_147286 (h0 : function.extfun Type (prod (linear_ordered_comm_group congr_arg_kind))) : id_rel (function.extfun_app h0 (linear_ordered_comm_group congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_147287 (h0 : functor.add_const (complete_lattice (finset ennreal)) ennreal) : @is_atomistic.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_147288 (h0 : ring (ring pos)) : rank_condition (ring pos) := sorry --non-trivial
lemma new_lemma_147289 (h0 : topological_space (random_gen (random_gen (has_inv (random_gen linarith.comp_source))))) : path_connected_space (random_gen (random_gen (has_inv (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_147290 (h0 : group (pseudo_metric_space congr_arg_kind)) : group.fg (pseudo_metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_147291 (h0 : functor.add_const (add_group (comm_group pos)) Type) : @is_add_cyclic.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (add_group.{0} (comm_group.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_147292 (h0 : functor.add_const (list (boolean_algebra linarith.comp)) (has_nndist pos)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_147293 (h0 : complete_lattice (semigroup (option pos))) : is_compactly_generated (semigroup (option pos)) := sorry --non-trivial
lemma new_lemma_147294 (h1 : add_group (has_nnnorm ordering)) : is_add_cyclic (has_nnnorm ordering) := sorry --non-trivial
lemma new_lemma_147295 (h0 : add_group (canonically_ordered_monoid (has_Inf (has_Inf (has_add pos))))) : is_add_cyclic (canonically_ordered_monoid (has_Inf (has_Inf (has_add pos)))) := sorry --non-trivial
lemma new_lemma_147296 (h0 : functor.add_const (functor.add_const Prop empty) (option unsigned)) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_147297 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_147298 (h0 : ring (add_cancel_monoid (comm_group name))) : rank_condition (add_cancel_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_147299 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_147300 (h3 : uniform_space (semi_normed_comm_ring (has_nnnorm fun_info))) : complete_space (semi_normed_comm_ring (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_147301 (h0 : topological_space (option (option pos))) : preirreducible_space (option (option pos)) := sorry --non-trivial
lemma new_lemma_147302 (h0 : functor.add_const (ring (add_cancel_monoid unsigned)) linarith.comp) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_147303 (h0 : uniform_space (linear_ordered_comm_ring (semiring congr_arg_kind))) : separated_space (linear_ordered_comm_ring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_147304 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_147305 (h2 : ring (has_compl string_imp)) : strong_rank_condition (has_compl string_imp) := sorry --non-trivial
lemma new_lemma_147306 (h0 : topological_space (plift (option (semiring num)))) : t1_space (plift (option (semiring num))) := sorry --non-trivial
lemma new_lemma_147307 (h0 : group (random_gen (semiring congr_arg_kind))) : is_cyclic (random_gen (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_147308 (h0 : not (has_mem.mem (normed_group empty) has_emptyc.emptyc -> false)) : @is_domain.{0} (normed_group.{0} empty) (@finset.pi.empty.{1 0} Type ring.{0} (normed_group.{0} empty) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} empty) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_147309 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_147310 (h0 : uniform_space (measure_theory.measure_space (semiring unsigned))) : separated_space (measure_theory.measure_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_147311 (h0 : filter (mul_zero_class (semiring num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_147312 (h0 : functor.add_const (function.extfun Type uniform_space) unsigned) : @separated_space.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) unsigned h0) (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_147313 (h0 : finset (ordered_comm_monoid (ring (has_neg (ring Type))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_147314 (h0 : ring (right_cancel_semigroup name)) : is_domain (right_cancel_semigroup name) := sorry --non-trivial
lemma new_lemma_147315 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_147316 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_147317 (h0 : ring (normed_lattice_add_comm_group Type)) : rank_condition (normed_lattice_add_comm_group Type) := sorry --non-trivial
lemma new_lemma_147318 (h0 : complete_lattice (with_one num)) : is_compactly_generated (with_one num) := sorry --non-trivial
lemma new_lemma_147319 (h0 : topological_space (mul_zero_class name)) : totally_disconnected_space (mul_zero_class name) := sorry --non-trivial
lemma new_lemma_147320 (h0 : group (with_one (semiring unsigned))) : group.fg (with_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_147321 (h0 : not (topological_space (random_gen string.iterator_imp) -> false)) : @path_connected_space.{0} (random_gen.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_147322 (h0 : functor.add_const (group (has_zero linarith.comp)) (ring Type)) : @is_cyclic.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (has_zero.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_147323 (h0 : functor.add_const (filter (pseudo_metric_space unsigned)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_147324 (h0 : topological_space (boolean_algebra (has_nndist linarith.comp))) : preirreducible_space (boolean_algebra (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_147325 (h0 : ring (semigroup (finset (has_add (finset pos))))) : rank_condition (semigroup (finset (has_add (finset pos)))) := sorry --non-trivial
lemma new_lemma_147326 (h0 : functor.add_const (add_group (has_to_string ennreal)) (option (option unsigned))) : @is_add_cyclic.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 0} (add_group.{0} (has_to_string.{0} ennreal)) (option.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_147327 (h0 : function.extfun (finset Type) (has_mem.mem linarith.comp)) : @rank_condition.{0} linarith.comp (@finset.pi.empty.{1 0} Type ring.{0} linarith.comp (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_147328 (h0 : group (complete_semilattice_Sup (has_top (random_gen linarith.comp_source)))) : group.fg (complete_semilattice_Sup (has_top (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_147329 (h0 : topological_space name) : normal_space name := sorry --non-trivial
lemma new_lemma_147330 (h0 : not (topological_space (linear_ordered_semiring linarith.comp) -> false)) : @t0_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_147331 (h0 : semiring (complete_distrib_lattice name)) : is_noetherian_ring (complete_distrib_lattice name) := sorry --non-trivial
lemma new_lemma_147332 (h0 : ordered_add_comm_monoid (has_add real)) : archimedean (has_add real) := sorry --non-trivial
lemma new_lemma_147333 (h0 : functor.add_const (filter (complete_distrib_lattice Type)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_147334 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_147335 (h0 : add_group (semi_normed_ring (has_nnnorm reducibility_hints))) : is_add_cyclic (semi_normed_ring (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_147336 (h0 : uniform_space (linear_ordered_add_comm_group (has_nnnorm to_additive.value_type))) : complete_space (linear_ordered_add_comm_group (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_147337 (h0 : ring (has_top (semiring (has_top linarith.comp)))) : rank_condition (has_top (semiring (has_top linarith.comp))) := sorry --non-trivial
lemma new_lemma_147338 (h0 : uniform_space (finset empty)) : separated_space (finset empty) := sorry --non-trivial
lemma new_lemma_147339 (h0 : filter (linear_ordered_semiring (semiring linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_147340 (h0 : not (topological_space (complete_semilattice_Sup num) -> false)) : @topological_space.separable_space.{0} (complete_semilattice_Sup.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_147341 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @normal_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_147342 (h0 : add_group (simple_graph (comm_ring reducibility_hints))) : is_add_cyclic (simple_graph (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_147343 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_147344 (h0 : topological_space (metric_space num)) : t0_space (metric_space num) := sorry --non-trivial
lemma new_lemma_147345 (h0 : complete_lattice (has_compl (mul_one_class (mul_one_class (mul_one_class fun_info))))) : is_compactly_generated (has_compl (mul_one_class (mul_one_class (mul_one_class fun_info)))) := sorry --non-trivial
lemma new_lemma_147346 (h0 : finset (group_with_zero (option unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_147347 (h0 : list (has_to_string (has_nndist Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_147348 (h0 : functor.add_const (function.extfun Type topological_space) (finset pos)) : @t0_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (finset.{0} pos) h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_147349 (h0 : topological_space (finset (finset (finset name)))) : totally_separated_space (finset (finset (finset name))) := sorry --non-trivial
lemma new_lemma_147350 (h0 : list (preorder (option (option unsigned)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_147351 (h0 : group (comm_semigroup (has_Inf real))) : is_simple_group (comm_semigroup (has_Inf real)) := sorry --non-trivial
lemma new_lemma_147352 (h0 : set (fun_info -> mul_one_class linarith.ineq)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_147353 (h0 : ring (distrib (has_nnnorm (random_gen (random_gen char))))) : strong_rank_condition (distrib (has_nnnorm (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_147354 (h0 : filter (option (option pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_147355 (h0 : ring (has_zero (has_Inf name))) : rank_condition (has_zero (has_Inf name)) := sorry --non-trivial
lemma new_lemma_147356 (h0 : functor.add_const (topological_space (omega_complete_partial_order empty)) unsigned) : @locally_compact_space.{0} (omega_complete_partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (omega_complete_partial_order.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_147357 (h0 : ring (has_bot (has_bot (sub_neg_monoid (has_bot (has_bot real)))))) : rank_condition (has_bot (has_bot (sub_neg_monoid (has_bot (has_bot real))))) := sorry --non-trivial
lemma new_lemma_147358 (h0 : add_group (has_emptyc num)) : is_add_cyclic (has_emptyc num) := sorry --non-trivial
lemma new_lemma_147359 (h0 : functor.add_const (topological_space (with_bot Type)) pos) : @t0_space.{1} (with_bot.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (with_bot.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_147360 (h0 : topological_space (comm_semigroup linarith.comp)) : sequential_space (comm_semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_147361 (h0 : finset (normed_comm_ring (has_neg_part linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_147362 (h0 : function.extfun Type ring) : @rank_condition.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_147363 (h0 : topological_space (canonically_ordered_comm_semiring congr_arg_kind)) : totally_separated_space (canonically_ordered_comm_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_147364 (h0 : functor.add_const (topological_space (complete_linear_order unsigned)) congr_arg_kind) : @locally_compact_space.{0} (complete_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_linear_order.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_147365 (h0 : complete_lattice string.iterator) : complete_lattice.is_Sup_finite_compact string.iterator := sorry --non-trivial
lemma new_lemma_147366 (h0 : function.extfun nat fin) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (complete_distrib_lattice.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_147367 (h0 : ordered_comm_monoid (normed_field std_gen) -> ring environment.projection_info) (h1 : unit) (h2 : ordered_comm_monoid (normed_field std_gen)) : @strong_rank_condition.{0} environment.projection_info (@matrix.row.{0 0} (ordered_comm_monoid.{0} (normed_field.{0} std_gen)) (ring.{0} environment.projection_info) h0 h1 h2)  := sorry --non-trivial
lemma new_lemma_147368 (h0 : function.extfun (Type 1) ring) : @is_principal_ideal_ring.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_147369 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} name (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) name)  := sorry --non-trivial
lemma new_lemma_147370 (h0 : topological_space (semigroup (comm_group Type))) : t1_space (semigroup (comm_group Type)) := sorry --non-trivial
lemma new_lemma_147371 (h0 : functor.add_const (list (has_nndist environment.implicit_infer_kind)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_147372 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} linarith.comp_source (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 monoid.{0}) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_147373 (h0 : has_lt (has_div (mul_one_class (mul_one_class (mul_one_class char))))) : no_max_order (has_div (mul_one_class (mul_one_class (mul_one_class char)))) := sorry --non-trivial
lemma new_lemma_147374 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (has_bot real)) := sorry --non-trivial
lemma new_lemma_147375 (h1 : topological_space (add_comm_semigroup std_gen)) (h3 : Prop) : topological_space.is_topological_basis (id (fun (h2 : set (add_comm_semigroup std_gen)), h3)) := sorry --non-trivial
lemma new_lemma_147376 (h1 : complete_lattice (has_emptyc linarith.comp_source)) : is_atomistic (has_emptyc linarith.comp_source) := sorry --non-trivial
lemma new_lemma_147377 (h0 : functor.add_const (uniform_space (preorder empty)) empty) : @separated_space.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (preorder.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_147378 (h0 : functor.add_const (topological_space (has_add pos)) (has_neg (has_neg (has_neg Type)))) : @totally_disconnected_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} pos)) (has_neg.{1} (has_neg.{1} (has_neg.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_147379 (h0 : cancel_comm_monoid_with_zero (finset congr_arg_kind)) : unique_factorization_monoid (finset congr_arg_kind) := sorry --non-trivial
lemma new_lemma_147380 (h0 : topological_space (finset (option (option (option unsigned))))) : t0_space (finset (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_147381 (h0 : topological_space (partial_order (has_top empty))) : discrete_topology (partial_order (has_top empty)) := sorry --non-trivial
lemma new_lemma_147382 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (canonically_linear_ordered_monoid.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (canonically_linear_ordered_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_147383 (h0 : filter (has_to_string (finset (finset linarith.comp)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_147384 (h0 : uniform_space (topological_space (has_add (random_gen (random_gen linarith.ineq))))) : complete_space (topological_space (has_add (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_147385 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (ring.{0} num) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (ring.{0} num))  := sorry --non-trivial
lemma new_lemma_147386 (h0 : complete_lattice (metric_space congr_arg_kind)) : is_compactly_generated (metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_147387 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_147388 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_147389 (h0 : ordered_comm_ring (finset linarith.comp) -> ordered_comm_ring (finset linarith.comp) -> Prop) : is_refl (ordered_comm_ring (finset linarith.comp)) h0 := sorry --non-trivial
lemma new_lemma_147390 (h0 : add_group (has_zero (option ennreal))) : is_add_cyclic (has_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_147391 (h0 : functor.comp filter has_to_string name) : countable_Inter_filter (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_147392 (h0 : add_monoid (omega_complete_partial_order (semiring empty))) : add_monoid.fg (omega_complete_partial_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_147393 (h0 : ring (has_neg_part (mul_zero_class name))) : rank_condition (has_neg_part (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_147394 (h0 : has_mem.mem num has_emptyc.emptyc) : @locally_compact_space.{0} num (@finset.pi.empty.{1 0} Type topological_space.{0} num h0)  := sorry --non-trivial
lemma new_lemma_147395 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (linear_ordered_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_147396 (h0 : group (has_add (finset Type))) : is_cyclic (has_add (finset Type)) := sorry --non-trivial
lemma new_lemma_147397 (h0 : prod (normed_linear_ordered_group empty) (normed_linear_ordered_group empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_147398 (h0 : functor.add_const (cancel_comm_monoid_with_zero (finset Type)) Type) : @unique_factorization_monoid.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (cancel_comm_monoid_with_zero.{1} (finset.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_147399 (h0 : functor.add_const (function.extfun Type list) linarith.comp) : palindrome (function.extfun_app (functor.add_const.run h0) (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_147400 (h1 : set (normed_field std_gen)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_147401 (h0 : complete_lattice (has_top (semiring (has_union num)))) : is_atomistic (has_top (semiring (has_union num))) := sorry --non-trivial
lemma new_lemma_147402 (h0 : topological_space (has_compl (mul_one_class (mul_one_class char)))) : path_connected_space (has_compl (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_147403 (h0 : functor.add_const (topological_space (add_cancel_comm_monoid empty)) empty) : @path_connected_space.{0} (add_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_147404 (h0 : functor.add_const (topological_space (simple_graph pos)) pos) : @locally_compact_space.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_147405 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_147406 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_ssubset.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_ssubset.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_147407 (h0 : topological_space (has_zero (has_nndist pos))) : t1_space (has_zero (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_147408 (h0 : functor.add_const (topological_space (boolean_algebra.core linarith.comp)) (ring linarith.comp)) : @preirreducible_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} linarith.comp)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_147409 (h0 : not (topological_space (denumerable reducibility_hints) -> false)) : @t0_space.{0} (denumerable.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_147410 (h4 : topological_space environment.projection_info) (h5 : add_group environment.projection_info) : topological_add_group environment.projection_info := sorry --non-trivial
lemma new_lemma_147411 (h0 : filter (has_zero (finset (has_neg pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_147412 (h0 : complete_lattice (simple_graph (option num))) : complete_lattice.is_Sup_finite_compact (simple_graph (option num)) := sorry --non-trivial
lemma new_lemma_147413 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type semiring.{0}) h0) (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_147414 (h0 : has_le (has_norm (random_gen linarith.ineq))) (h1 : bounded_order (has_norm (random_gen linarith.ineq))) : is_simple_order (has_norm (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_147415 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (as_linear_order.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (as_linear_order.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_147416 (h0 : complete_lattice (has_zero (has_add unsigned))) : is_atomistic (has_zero (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_147417 (h0 : topological_space (has_inter (option unsigned))) : locally_compact_space (has_inter (option unsigned)) := sorry --non-trivial
lemma new_lemma_147418 (h0 : empty -> empty -> Prop) (h1 : function.extfun Type filter) : filter.is_cobounded h0 (function.extfun_app h1 empty) := sorry --non-trivial
lemma new_lemma_147419 (h0 : complete_lattice (add_cancel_monoid (has_zero pos))) : complete_lattice.is_Sup_finite_compact (add_cancel_monoid (has_zero pos)) := sorry --non-trivial
lemma new_lemma_147420 (h0 : ring (semi_normed_comm_ring (has_nnnorm fun_info))) : rank_condition (semi_normed_comm_ring (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_147421 (h0 : functor.add_const (topological_space (free_add_monoid empty)) congr_arg_kind) : @normal_space.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_147422 (h0 : add_group (has_pos_part pos)) : is_add_cyclic (has_pos_part pos) := sorry --non-trivial
lemma new_lemma_147423 (h0 : functor.add_const (topological_space (semigroup (has_add pos))) Type) : @path_connected_space.{0} (semigroup.{0} (has_add.{0} pos)) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} (has_add.{0} pos))) Type h0)  := sorry --non-trivial
lemma new_lemma_147424 (h0 : functor.add_const (functor.add_const (ring Type) linarith.comp) linarith.comp) : @is_domain.{1} Type (@functor.add_const.run.{1 0} (ring.{1} Type) linarith.comp (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (ring.{1} Type) linarith.comp) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_147425 (h0 : functor.add_const (ring (add_cancel_monoid linarith.comp)) (boolean_algebra pos)) : @rank_condition.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} linarith.comp)) (boolean_algebra.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_147426 (h0 : group (ordered_comm_ring (ring pos))) : is_simple_group (ordered_comm_ring (ring pos)) := sorry --non-trivial
lemma new_lemma_147427 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_147428 (h1 : group (has_compl string_imp)) : is_cyclic (has_compl string_imp) := sorry --non-trivial
lemma new_lemma_147429 (h1 : preorder (random_gen fun_info)) (h2 : complete_lattice (random_gen (pred_order (random_gen fun_info)))) : is_compactly_generated (random_gen (pred_order (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_147430 (h0 : topological_space (has_neg (has_add name))) : topological_space.separable_space (has_neg (has_add name)) := sorry --non-trivial
lemma new_lemma_147431 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) pos) : @discrete_topology.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_147432 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_147433 (h0 : ring (has_bot (has_Inf (sub_neg_monoid (has_bot pos))))) : is_domain (has_bot (has_Inf (sub_neg_monoid (has_bot pos)))) := sorry --non-trivial
lemma new_lemma_147434 (h0 : function.extfun Type ring) : @is_domain.{0} (add_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_147435 (h0 : topological_space (comm_ring (random_gen fun_info))) : t0_space (comm_ring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_147436 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_147437 (h0 : ordered_add_comm_monoid (canonically_ordered_monoid (ordered_comm_monoid real))) : archimedean (canonically_ordered_monoid (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_147438 (h0 : topological_space (has_one (has_top (semiring num)))) : path_connected_space (has_one (has_top (semiring num))) := sorry --non-trivial
lemma new_lemma_147439 (h0 : functor.add_const (group (has_Sup unsigned)) congr_arg_kind) : @normalizer_condition.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_Sup.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_147440 (h0 : complete_lattice (has_inv (random_gen (random_gen linarith.ineq)))) : complete_lattice.is_Sup_finite_compact (has_inv (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_147441 (h0 : uniform_space empty -> Prop) : separated_space empty := sorry --non-trivial
lemma new_lemma_147442 (h0 : functor.add_const (filter (has_zero pos)) (has_to_string name)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_147443 (h0 : group (measurable_space (has_top linarith.ineq))) : normalizer_condition (measurable_space (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_147444 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_inter ennreal)) := sorry --non-trivial
lemma new_lemma_147445 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_147446 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_147447 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_147448 (h0 : functor.add_const (ring znum) (option (option num))) : @is_domain.{0} znum (@functor.add_const.run.{0 0} (ring.{0} znum) (option.{0} (option.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_147449 (h0 : functor.add_const (topological_space (has_neg name)) linarith.comp) : @t0_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_147450 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_147451 (h0 : topological_space (generalized_boolean_algebra (has_neg pos))) : loc_path_connected_space (generalized_boolean_algebra (has_neg pos)) := sorry --non-trivial
lemma new_lemma_147452 (h0 : add_monoid (boolean_algebra.core (option (option (option (option ennreal)))))) : add_monoid.fg (boolean_algebra.core (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_147453 (h0 : group (add_cancel_monoid (has_neg Type))) : is_cyclic (add_cancel_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_147454 (h0 : ring (has_nndist (has_add environment.implicit_infer_kind))) : rank_condition (has_nndist (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_147455 (h0 : functor.add_const (finset (has_add linarith.comp)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_147456 (h0 : topological_space (add_comm_monoid (has_neg_part (has_to_string Type)))) : totally_separated_space (add_comm_monoid (has_neg_part (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_147457 (h0 : not (has_mem.mem (function.extfun Type) has_emptyc.emptyc -> false)) : @is_compactly_generated.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{0} (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (finset.{2} ((Type → Type) → Type 1)) (@finset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type) (@has_emptyc.emptyc.{2} (finset.{2} ((Type → Type) → Type 1)) (@finset.has_emptyc.{2} ((Type → Type) → Type 1)))) h0)) complete_lattice.{0}) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_147458 (h0 : uniform_space (has_norm (semiring linarith.comp))) : complete_space (has_norm (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_147459 (h0 : function.extfun (finset Type) (has_mem.mem num)) : @is_atomistic.{0} num (@finset.pi.empty.{1 0} Type complete_lattice.{0} num (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_147460 (h0 : list (boolean_algebra (has_pos_part (has_pos_part (finset (finset (has_add pos))))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_147461 (h0 : uniform_space (semiring (has_top linarith.ineq))) : complete_space (semiring (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_147462 (h0 : topological_space (canonically_ordered_comm_semiring (mul_zero_class pos))) : preirreducible_space (canonically_ordered_comm_semiring (mul_zero_class pos)) := sorry --non-trivial
lemma new_lemma_147463 (h0 : group (has_Inf (boolean_algebra.core (has_add pos)))) : group.fg (has_Inf (boolean_algebra.core (has_add pos))) := sorry --non-trivial
lemma new_lemma_147464 (h0 : filter (distrib_lattice (random_gen linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_147465 (h1 : with_bot (group (id num))) (h2 : ne h1 has_bot.bot) : @normalizer_condition.{0} (@id.{2} Type num) (@with_bot.unbot.{0} (group.{0} (@id.{2} Type num)) h1 h2)  := sorry --non-trivial
lemma new_lemma_147466 (h0 : not (ring (normed_group congr_arg_kind) -> false)) : @is_principal_ideal_ring.{0} (normed_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (normed_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_147467 (h0 : complete_lattice (has_compl (mul_one_class (mul_one_class fun_info)))) : is_compactly_generated (has_compl (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_147468 (h0 : functor.add_const (finset (has_zero pos)) (has_neg linarith.comp)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_147469 (h0 : function.extfun Type group) : @group.fg.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_147470 (h0 : topological_space empty) : totally_separated_space empty := sorry --non-trivial
lemma new_lemma_147471 (h0 : functor.add_const (topological_space (has_add linarith.comp)) linarith.comp) : @loc_path_connected_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_147472 (h0 : uniform_space (has_pos_part (finset (has_Inf linarith.comp)))) : separated_space (has_pos_part (finset (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_147473 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_147474 (h0 : topological_space (measurable_space (has_top (has_top (semiring (has_top (semiring congr_arg_kind))))))) : normal_space (measurable_space (has_top (has_top (semiring (has_top (semiring congr_arg_kind)))))) := sorry --non-trivial
lemma new_lemma_147475 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) name) : @loc_path_connected_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_147476 (h0 : topological_space (complete_distrib_lattice (sub_neg_monoid linarith.comp))) : path_connected_space (complete_distrib_lattice (sub_neg_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_147477 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : strong_rank_condition real := sorry --non-trivial
lemma new_lemma_147478 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_147479 (h0 : topological_space (has_dist num)) : loc_path_connected_space (has_dist num) := sorry --non-trivial
lemma new_lemma_147480 (h0 : not (topological_space (distrib to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (distrib.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_147481 (h0 : list (left_cancel_semigroup (semiring (semiring unsigned)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_147482 (h0 : not (ring (has_sub linarith.comp) -> false)) : @is_domain.{0} (has_sub.{0} linarith.comp) (@classical.by_contradiction'.{1} (ring.{0} (has_sub.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_147483 (h0 : ring (with_bot linarith.ineq)) : is_domain (with_bot linarith.ineq) := sorry --non-trivial
lemma new_lemma_147484 (h0 : complete_lattice (boolean_algebra environment.implicit_infer_kind)) : is_compactly_generated (boolean_algebra environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_147485 (h0 : uniform_space (canonically_linear_ordered_monoid (has_add name))) : separated_space (canonically_linear_ordered_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_147486 (h0 : complete_lattice (normed_comm_ring (has_add name))) : is_atomistic (normed_comm_ring (has_add name)) := sorry --non-trivial
lemma new_lemma_147487 (h0 : has_mem.mem (has_norm num) has_emptyc.emptyc) : @path_connected_space.{0} (has_norm.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_147488 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_147489 (h0 : ring (has_add (has_add pos))) : is_principal_ideal_ring (has_add (has_add pos)) := sorry --non-trivial
lemma new_lemma_147490 (h0 : monoid (has_neg (add_cancel_comm_monoid name))) : monoid.fg (has_neg (add_cancel_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_147491 (h0 : topological_space (boolean_algebra.core (finset pos))) : totally_separated_space (boolean_algebra.core (finset pos)) := sorry --non-trivial
lemma new_lemma_147492 (h0 : topological_space (measurable_space (has_norm congr_arg_kind))) : normal_space (measurable_space (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_147493 (h0 : group (has_ssubset (add_left_cancel_monoid fun_info))) : is_cyclic (has_ssubset (add_left_cancel_monoid fun_info)) := sorry --non-trivial
lemma new_lemma_147494 (h0 : topological_space (has_emptyc (random_gen num))) : locally_compact_space (has_emptyc (random_gen num)) := sorry --non-trivial
lemma new_lemma_147495 (h0 : semiring (normed_lattice_add_comm_group real)) : is_noetherian_ring (normed_lattice_add_comm_group real) := sorry --non-trivial
lemma new_lemma_147496 (h0 : functor.add_const (group (comm_group environment.implicit_infer_kind)) name) : @group.fg.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_147497 (h0 : topological_space (has_norm (has_top congr_arg_kind))) : totally_separated_space (has_norm (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_147498 (h0 : functor.add_const (group (has_to_string Type)) Type) : @is_simple_group.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (has_to_string.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_147499 (h0 : topological_space (has_neg unsigned)) : regular_space (has_neg unsigned) := sorry --non-trivial
lemma new_lemma_147500 (h0 : topological_space (finset (has_add ennreal))) : totally_separated_space (finset (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_147501 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_147502 (h0 : list (canonically_linear_ordered_monoid unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_147503 (h0 : not (semiring (left_cancel_semigroup empty) -> false)) : @is_noetherian_ring.{0} (left_cancel_semigroup.{0} empty) (@classical.by_contradiction'.{1} (semiring.{0} (left_cancel_semigroup.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_147504 (h0 : not (topological_space (has_emptyc (has_norm fun_info)) -> false)) : @t0_space.{0} (has_emptyc.{0} (has_norm.{0} fun_info)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} (has_norm.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_147505 (h0 : has_mem.mem (normed_group empty) has_emptyc.emptyc) : @separated_space.{0} (normed_group.{0} empty) (@finset.pi.empty.{1 0} Type uniform_space.{0} (normed_group.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_147506 (h0 : topological_space (denumerable (has_inv fun_info))) : totally_separated_space (denumerable (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_147507 (h0 : topological_space (has_add (has_ssubset linarith.ineq))) : t0_space (has_add (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_147508 (h0 : topological_space (with_one (semiring (linear_ordered_semiring linarith.comp)))) : normal_space (with_one (semiring (linear_ordered_semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_147509 (h0 : group (add_left_cancel_semigroup (semiring empty))) : normalizer_condition (add_left_cancel_semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_147510 (h0 : function.extfun Type topological_space) : loc_path_connected_space bool := sorry --non-trivial
lemma new_lemma_147511 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_147512 (h0 : function.extfun nat fin) : @is_principal_ideal_ring.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_147513 (h0 : function.extfun (finset Type) (has_mem.mem (has_top linarith.comp_source))) : @complete_space.{0} (has_top.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_147514 (h0 : topological_space (has_nndist (finset (finset linarith.comp)))) : totally_disconnected_space (has_nndist (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_147515 (h0 : filter (measurable_space (semiring unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_147516 (h0 : not (filter (bin_tree num) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_147517 (h0 : functor.comp group has_neg pos) : @normalizer_condition.{0} (has_neg.{0} pos) (@functor.comp.run.{0 0 0} group.{0} has_neg.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_147518 (h0 : ring (add_cancel_comm_monoid string_imp)) : strong_rank_condition (add_cancel_comm_monoid string_imp) := sorry --non-trivial
lemma new_lemma_147519 (h0 : ring (linear_ordered_semiring (semiring (semiring unsigned)))) : rank_condition (linear_ordered_semiring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_147520 (h0 : topological_space (ordered_comm_ring (ring (ring linarith.comp)))) : totally_separated_space (ordered_comm_ring (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_147521 (h0 : group (pseudo_metric_space (has_nndist ennreal))) : is_simple_group (pseudo_metric_space (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_147522 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_147523 (h0 : functor.add_const (ordered_comm_monoid (ordered_comm_monoid pos)) linarith.comp) : @has_exists_mul_of_le.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ordered_comm_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_147524 (h0 : list (has_neg (ring name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_147525 (h0 h1 : multiset (has_lt enat)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_147526 (h0 : uniform_space (has_norm (semiring empty))) : complete_space (has_norm (semiring empty)) := sorry --non-trivial
lemma new_lemma_147527 (h1 : function.extfun Prop (fun (x : Prop), Prop)) : classical.epsilon (function.extfun_app h1) := sorry --non-trivial
lemma new_lemma_147528 (h2 : uniform_space (with_one (has_top fun_info))) : complete_space (with_one (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_147529 (h0 : uniform_space (semigroup (normed_comm_ring name))) : separated_space (semigroup (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_147530 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_147531 (h0 : ring (has_pos_part (has_Inf (has_add (has_Inf (has_Inf (has_add (has_Inf real)))))))) : is_domain (has_pos_part (has_Inf (has_add (has_Inf (has_Inf (has_add (has_Inf real))))))) := sorry --non-trivial
lemma new_lemma_147532 (h0 : add_group (left_cancel_semigroup (semiring num))) : is_add_cyclic (left_cancel_semigroup (semiring num)) := sorry --non-trivial
lemma new_lemma_147533 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (add_semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_147534 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_147535 (h0 : functor.add_const (group (has_add pos)) (finset pos)) : @is_simple_group.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_147536 (h0 : functor.add_const (topological_space (has_zero Type)) (comm_group Type)) : @normal_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_zero.{1} Type)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_147537 (h0 : add_monoid (random_gen unsigned)) : add_monoid.fg (random_gen unsigned) := sorry --non-trivial
lemma new_lemma_147538 (h0 : not (complete_lattice (topological_space char) -> false)) : is_compactly_generated (topological_space char) := sorry --non-trivial
lemma new_lemma_147539 (h0 : functor.add_const (group (complete_linear_order num)) num) : @group.fg.{0} (complete_linear_order.{0} num) (@functor.add_const.run.{0 0} (group.{0} (complete_linear_order.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_147540 (h0 : ring (has_neg unsigned)) : strong_rank_condition (has_neg unsigned) := sorry --non-trivial
lemma new_lemma_147541 (h0 : complete_lattice (complete_distrib_lattice environment.implicit_infer_kind)) : is_compactly_generated (complete_distrib_lattice environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_147542 (h0 : function.extfun Type (prod (linear_ordered_comm_monoid_with_zero empty))) : id_rel (function.extfun_app h0 (linear_ordered_comm_monoid_with_zero empty)) := sorry --non-trivial
lemma new_lemma_147543 (h0 : add_group (has_nnnorm (mul_one_class (has_ssubset environment.projection_info)))) : is_add_cyclic (has_nnnorm (mul_one_class (has_ssubset environment.projection_info))) := sorry --non-trivial
lemma new_lemma_147544 (h0 : ring (has_neg (has_add (has_to_string pos)))) : is_principal_ideal_ring (has_neg (has_add (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_147545 (h0 : group (has_bot (has_add (has_add Type)))) : is_cyclic (has_bot (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_147546 (h1 : topological_space char) : t0_space char := sorry --non-trivial
lemma new_lemma_147547 (h0 : topological_space (measurable_space (has_norm congr_arg_kind))) : irreducible_space (measurable_space (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_147548 (h0 : functor.add_const (topological_space (finset unsigned)) linarith.comp) : @topological_space.separable_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_147549 (h0 : uniform_space (canonically_linear_ordered_monoid linarith.comp)) : separated_space (canonically_linear_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_147550 (h0 : complete_lattice (has_norm (has_norm linarith.comp))) : is_atomistic (has_norm (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_147551 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_147552 (h0 : group (has_zero environment.implicit_infer_kind)) : is_cyclic (has_zero environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_147553 (h0 : complete_lattice (add_semigroup (option (option empty)))) : complete_lattice.is_Sup_finite_compact (add_semigroup (option (option empty))) := sorry --non-trivial
lemma new_lemma_147554 (h0 : add_group (ordered_ring (semiring (option empty)))) : is_add_cyclic (ordered_ring (semiring (option empty))) := sorry --non-trivial
lemma new_lemma_147555 (h0 : topological_space (normed_lattice_add_comm_group (has_bot (has_neg name)))) : discrete_topology (normed_lattice_add_comm_group (has_bot (has_neg name))) := sorry --non-trivial
lemma new_lemma_147556 (h0 : fin has_zero.zero) : @is_domain.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_147557 (h0 : topological_space (semigroup pos)) : totally_disconnected_space (semigroup pos) := sorry --non-trivial
lemma new_lemma_147558 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_147559 (h0 : prod (linear_ordered_cancel_comm_monoid (option unsigned)) (linear_ordered_cancel_comm_monoid (option unsigned))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_147560 (h0 : topological_space (has_add (finset linarith.comp))) : irreducible_space (has_add (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_147561 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @t1_space.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_147562 (h0 : finset (normed_linear_ordered_group unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_147563 (h0 : functor.add_const (topological_space (mul_zero_class unsigned)) empty) : @topological_space.separable_space.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_147564 (h0 : ring (finset (finset (finset pos)))) : rank_condition (finset (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_147565 (h0 : cancel_comm_monoid_with_zero (add_cancel_monoid (option (option (option name))))) : unique_factorization_monoid (add_cancel_monoid (option (option (option name)))) := sorry --non-trivial
lemma new_lemma_147566 (h0 : functor.add_const (group (mul_zero_class name)) name) : @is_simple_group.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (group.{0} (mul_zero_class.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_147567 (h0 : not (filter (random_gen fun_info) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_147568 (h0 : not (topological_space (plift empty) -> false)) : @normal_space.{1} (plift.{1} empty) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} empty)) h0)  := sorry --non-trivial
lemma new_lemma_147569 (h0 : ring (random_gen (mul_one_class (mul_one_class linarith.comp_source)))) : strong_rank_condition (random_gen (mul_one_class (mul_one_class linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_147570 (h0 : functor.add_const (topological_space (comm_group name)) unsigned) : @topological_space.separable_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_147571 (h2 : topological_space (simple_graph ereal)) : totally_disconnected_space (simple_graph ereal) := sorry --non-trivial
lemma new_lemma_147572 (h0 : functor.add_const (complete_lattice (has_to_string ennreal)) Type) : @is_compactly_generated.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_to_string.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_147573 (h0 : ring linarith.ineq) : strong_rank_condition linarith.ineq := sorry --non-trivial
lemma new_lemma_147574 (h0 : functor.add_const (group (has_zero Type)) (finset pos)) : @is_simple_group.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_zero.{1} Type)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_147575 (h0 : functor.add_const (complete_lattice (has_zero unsigned)) pos) : @is_compactly_generated.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_147576 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_147577 (h0 : add_group (id (has_top linarith.comp))) : is_add_cyclic (id (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_147578 (h0 : group (has_pos_part name)) : is_cyclic (has_pos_part name) := sorry --non-trivial
lemma new_lemma_147579 (h0 : topological_space (non_assoc_semiring (semiring (semiring congr_arg_kind)))) : totally_disconnected_space (non_assoc_semiring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_147580 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) environment.implicit_infer_kind) : @normal_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_147581 (h0 : topological_space empty -> Prop) : path_connected_space empty := sorry --non-trivial
lemma new_lemma_147582 (h1 : topological_space (with_one linarith.ineq)) : totally_disconnected_space (with_one linarith.ineq) := sorry --non-trivial
lemma new_lemma_147583 (h0 : ring (has_to_string (has_add (has_add (has_add pos))))) : strong_rank_condition (has_to_string (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_147584 (h1 : semiring (add_group congr_arg_kind)) : is_noetherian_ring (add_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_147585 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_147586 (h0 : function.extfun Type ring) : @rank_condition.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_147587 (h1 : ring (has_top string_imp)) : strong_rank_condition (has_top string_imp) := sorry --non-trivial
lemma new_lemma_147588 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @totally_disconnected_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_147589 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_147590 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.core.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (boolean_algebra.core.{0} empty))  := sorry --non-trivial
lemma new_lemma_147591 (h0 : list (has_inter (option empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_147592 (h0 : ordered_comm_monoid (has_to_string (comm_group (comm_group unsigned)))) : has_exists_mul_of_le (has_to_string (comm_group (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_147593 (h0 : functor.add_const (complete_lattice (finset unsigned)) unsigned) : @is_compactly_generated.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_147594 (h0 : functor.add_const (complete_lattice (canonically_linear_ordered_monoid unsigned)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_linear_ordered_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_linear_ordered_monoid.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_147595 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (is_R_or_C.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (is_R_or_C.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_147596 (h0 : cancel_comm_monoid_with_zero (plift unsigned)) : unique_factorization_monoid (plift unsigned) := sorry --non-trivial
lemma new_lemma_147597 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) environment.implicit_infer_kind) : @t1_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_147598 (h0 : functor.add_const (ring (monoid empty)) (option empty)) : @rank_condition.{0} (monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (monoid.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_147599 (h0 : functor.add_const (group znum) (option num)) : @is_cyclic.{0} znum (@functor.add_const.run.{0 0} (group.{0} znum) (option.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_147600 (h0 : topological_space (linear_ordered_field (option (option ennreal)))) : loc_path_connected_space (linear_ordered_field (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_147601 (h0 : ring (ring environment.implicit_infer_kind)) : is_domain (ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_147602 (h0 : function.extfun Type group) : @group.fg.{0} (topological_space.{0} (has_top.{0} linarith.ineq)) (@function.extfun_app.{2 1} Type group.{0} h0 (topological_space.{0} (has_top.{0} linarith.ineq)))  := sorry --non-trivial
lemma new_lemma_147603 (h0 : to_additive.value_type -> to_additive.value_type -> Prop) : is_asymm to_additive.value_type h0 := sorry --non-trivial
lemma new_lemma_147604 (h0 : functor.comp ring has_neg name) : @rank_condition.{0} (has_neg.{0} name) (@functor.comp.run.{0 0 0} ring.{0} has_neg.{0} name (@functor.comp.run.{0 0 0} ring.{0} has_neg.{0} name h0))  := sorry --non-trivial
lemma new_lemma_147605 (h1 : complete_lattice (has_div char)) : is_compactly_generated (has_div char) := sorry --non-trivial
lemma new_lemma_147606 (h0 : topological_space (boolean_algebra.core (has_to_string (has_nndist ennreal)))) : totally_separated_space (boolean_algebra.core (has_to_string (has_nndist ennreal))) := sorry --non-trivial
lemma new_lemma_147607 (h0 : functor.add_const (topological_space (monoid_with_zero pos)) pos) : @preirreducible_space.{0} (monoid_with_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid_with_zero.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_147608 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (add_group.{0} (ordered_comm_ring.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_147609 (h0 : functor.add_const (function.extfun Type list) name) : list.nodup (function.extfun_app (functor.add_const.run h0) (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_147610 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_147611 (h0 : function.extfun (Type 1) topological_space) : @discrete_topology.{1} (plift.{1} num) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (plift.{1} num))  := sorry --non-trivial
lemma new_lemma_147612 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group fun_info))) : @add_monoid.fg.{0} (normed_group.{0} fun_info) (@finset.pi.empty.{1 0} Type add_monoid.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_147613 (h0 : functor.add_const (function.extfun Type topological_space) (has_add (ring (has_to_string (has_neg Type))))) : @regular_space.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (has_add.{1} (ring.{1} (has_to_string.{1} (has_neg.{1} Type)))) h0) (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_147614 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) name) : @archimedean.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) name h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_147615 (h0 : ring (boolean_algebra.core pos)) : is_principal_ideal_ring (boolean_algebra.core pos) := sorry --non-trivial
lemma new_lemma_147616 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_147617 (h0 : complete_lattice (normed_lattice_add_comm_group pos)) : complete_lattice.is_Sup_finite_compact (normed_lattice_add_comm_group pos) := sorry --non-trivial
lemma new_lemma_147618 (h0 : ring (ring (ring Type))) : rank_condition (ring (ring Type)) := sorry --non-trivial
lemma new_lemma_147619 : nonempty fun_info := sorry --simp
lemma new_lemma_147620 (h0 : topological_space (complete_semilattice_Sup (topological_space to_additive.value_type))) : t0_space (complete_semilattice_Sup (topological_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_147621 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_147622 (h0 : not (topological_space (measurable_space.dynkin_system empty) -> false)) : @discrete_topology.{0} (measurable_space.dynkin_system.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.dynkin_system.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_147623 (h2 : set (ereal -> add_comm_semigroup fun_info)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_147624 (h0 : functor.add_const (group (ordered_comm_monoid linarith.comp)) linarith.comp) : @normalizer_condition.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (ordered_comm_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_147625 (h0 : complete_lattice (measurable_space (has_norm linarith.comp))) : is_atomistic (measurable_space (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_147626 (h0 : uniform_space (ordered_ring unsigned)) : complete_space (ordered_ring unsigned) := sorry --non-trivial
lemma new_lemma_147627 (h0 : functor.add_const (ring (canonically_ordered_add_monoid empty)) empty) : @rank_condition.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_147628 (h0 : topological_space (semigroup (option (option pos)))) : irreducible_space (semigroup (option (option pos))) := sorry --non-trivial
lemma new_lemma_147629 (h1 : has_mem.mem ring has_emptyc.emptyc) : @is_domain.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h1) (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_147630 (h0 : topological_space (semiring (has_norm (random_gen linarith.ineq)))) : totally_disconnected_space (semiring (has_norm (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_147631 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} h0 (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_147632 (h0 : ring (mul_zero_class Type)) : is_principal_ideal_ring (mul_zero_class Type) := sorry --non-trivial
lemma new_lemma_147633 (h0 : add_group (canonically_linear_ordered_monoid (option num))) : is_add_cyclic (canonically_linear_ordered_monoid (option num)) := sorry --non-trivial
lemma new_lemma_147634 (h0 : add_group (ordered_comm_ring (sub_neg_monoid real))) : is_add_cyclic (ordered_comm_ring (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_147635 (h0 : add_group (ordered_comm_ring (ring (ring pos)))) : is_add_cyclic (ordered_comm_ring (ring (ring pos))) := sorry --non-trivial
lemma new_lemma_147636 (h0 : set (set num)) : is_countably_spanning h0 := sorry --non-trivial
lemma new_lemma_147637 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) (finset (has_to_string pos))) : @irreducible_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) (finset.{0} (has_to_string.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_147638 (h0 : function.extfun nat fin) : @monoid.fg.{1} (has_Inf.{1} Type) (@matrix.vec_empty.{1} (monoid.{1} (has_Inf.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_147639 (h0 : functor.add_const (topological_space (mul_zero_class pos)) name) : @preirreducible_space.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_147640 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_147641 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (non_assoc_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (non_assoc_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_147642 (h0 : topological_space (comm_ring (random_gen (random_gen (semi_normed_comm_ring string_imp))))) : t0_space (comm_ring (random_gen (random_gen (semi_normed_comm_ring string_imp)))) := sorry --non-trivial
lemma new_lemma_147643 (h0 : functor.add_const (topological_space (bin_tree congr_arg_kind)) empty) : @loc_path_connected_space.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_147644 (h0 : function.extfun Type topological_space) : @t0_space.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_147645 (h0 : functor.add_const (topological_space (monoid ennreal)) num) : @preconnected_space.{0} (monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_147646 (h1 : function.extfun (finset Type) (has_mem.mem empty)) : totally_separated_space empty := sorry --non-trivial
lemma new_lemma_147647 (h0 : functor.add_const (filter (boolean_algebra pos)) environment.implicit_infer_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_147648 (h0 : complete_lattice (boolean_algebra (has_Inf name))) : complete_lattice.is_Sup_finite_compact (boolean_algebra (has_Inf name)) := sorry --non-trivial
lemma new_lemma_147649 (h0 : uniform_space (linear_ordered_comm_group unsigned)) : complete_space (linear_ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_147650 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) pos) : @totally_separated_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_147651 (h0 : topological_space (sub_neg_monoid (has_neg name))) : sequential_space (sub_neg_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_147652 (h0 : topological_space (has_Inf (has_neg Type))) : path_connected_space (has_Inf (has_neg Type)) := sorry --non-trivial
lemma new_lemma_147653 : id (is_empty num) := sorry --nsimp
lemma new_lemma_147654 (h0 : ordered_add_comm_monoid (ordered_comm_ring (has_add (has_add Type)))) : archimedean (ordered_comm_ring (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_147655 (h0 : complete_lattice (has_top (random_gen to_additive.value_type))) : is_compactly_generated (has_top (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_147656 (h0 : functor.add_const (topological_space (has_Inf pos)) Type) : @totally_separated_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_147657 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_147658 (h0 : topological_space (normed_group (has_ssubset to_additive.value_type))) : path_connected_space (normed_group (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_147659 (h1 : complete_lattice (has_ssubset (denumerable to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (has_ssubset (denumerable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_147660 (h0 : topological_space (has_neg (has_add pos))) : totally_disconnected_space (has_neg (has_add pos)) := sorry --non-trivial
lemma new_lemma_147661 (h0 : functor.add_const (list (cancel_monoid name)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_147662 (h0 : topological_space (has_add (has_Inf (ordered_comm_monoid real)))) : loc_path_connected_space (has_add (has_Inf (ordered_comm_monoid real))) := sorry --non-trivial
lemma new_lemma_147663 (h0 : ring (with_one (fintype (has_append linarith.comp_source)))) : rank_condition (with_one (fintype (has_append linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_147664 (h0 : topological_space (has_nndist (mul_zero_class Type))) : t1_space (has_nndist (mul_zero_class Type)) := sorry --non-trivial
lemma new_lemma_147665 (h0 : ring (has_neg (option ennreal))) : strong_rank_condition (has_neg (option ennreal)) := sorry --non-trivial
lemma new_lemma_147666 (h0 : functor.add_const (list (free_add_monoid unsigned)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_147667 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_147668 (h0 : topological_space (has_top (random_gen fun_info))) : irreducible_space (has_top (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_147669 (h0 : topological_space (boolean_algebra (finset linarith.comp))) : loc_path_connected_space (boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_147670 (h0 : functor.add_const (add_monoid (id empty)) empty) : @add_monoid.fg.{0} (@id.{2} Type empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (@id.{2} Type empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_147671 (h1 : topological_space (has_compl (has_nnnorm char))) : path_connected_space (has_compl (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_147672 (h0 : functor.add_const (uniform_space (canonically_ordered_add_monoid empty)) empty) : @complete_space.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (canonically_ordered_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_147673 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_147674 (h0 : function.extfun Type group) : @is_simple_group.{0} (add_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (add_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_147675 (h0 : functor.add_const (topological_space (linear_ordered_comm_monoid_with_zero Type)) name) : @totally_separated_space.{1} (linear_ordered_comm_monoid_with_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (linear_ordered_comm_monoid_with_zero.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_147676 (h0 : list (linear_ordered_comm_group congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_147677 (h0 : add_group (nondiscrete_normed_field (normed_field linarith.ineq))) : is_add_cyclic (nondiscrete_normed_field (normed_field linarith.ineq)) := sorry --non-trivial
lemma new_lemma_147678 (h0 : functor.add_const (uniform_space (ordered_ring congr_arg_kind)) (semiring empty)) : @separated_space.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_ring.{0} congr_arg_kind)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_147679 (h0 : topological_space (with_one (random_gen to_additive.value_type))) : locally_compact_space (with_one (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_147680 (h0 : complete_lattice (has_Sup (semiring unsigned))) : complete_lattice.is_Sup_finite_compact (has_Sup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_147681 (h0 : finset (mul_zero_class (mul_zero_class (mul_zero_class name)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_147682 (h0 : topological_space (canonically_ordered_comm_semiring (option pos))) : preconnected_space (canonically_ordered_comm_semiring (option pos)) := sorry --non-trivial
lemma new_lemma_147683 (h0 : measurable_space (has_le linarith.ineq)) (h1 : filter (has_le linarith.ineq)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_147684 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @t0_space.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_147685 (h0 : topological_space (has_add (ring environment.implicit_infer_kind))) : irreducible_space (has_add (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_147686 (h0 : topological_space (has_pos_part (ordered_ring (has_neg (ordered_ring (finset pos)))))) : t1_space (has_pos_part (ordered_ring (has_neg (ordered_ring (finset pos))))) := sorry --non-trivial
lemma new_lemma_147687 (h0 : not (group (linear_ordered_semiring unsigned) -> false)) : @group.fg.{0} (linear_ordered_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_147688 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @is_cyclic.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_147689 (h0 : finset (finset (has_neg Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_147690 (h0 : fin has_zero.zero) : @strong_rank_condition.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (has_pos_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_147691 (h0 : ring (has_add (finset (has_add (has_add linarith.comp))))) : is_principal_ideal_ring (has_add (finset (has_add (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_147692 (h0 : uniform_space (metric_space (semiring unsigned))) : complete_space (metric_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_147693 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (add_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (add_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_147694 (h0 : topological_space (canonically_ordered_monoid (has_add (has_add linarith.comp)))) : normal_space (canonically_ordered_monoid (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_147695 (h0 : function.extfun Type topological_space) : @t0_space.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_147696 (h0 : topological_space (non_unital_non_assoc_semiring fun_info)) (h1 : preorder (non_unital_non_assoc_semiring fun_info)) : order_topology (non_unital_non_assoc_semiring fun_info) := sorry --non-trivial
lemma new_lemma_147697 (h0 : list (complete_lattice (complete_semilattice_Sup char))) (h1 : function.extfun (eq h0 list.nil) (fun (x : eq h0 list.nil), false)) : @complete_lattice.is_Sup_finite_compact.{0} (complete_semilattice_Sup.{0} char) (@list.last.{0} (complete_lattice.{0} (complete_semilattice_Sup.{0} char)) h0 (@function.extfun_app.{0 0} (@eq.{1} (list.{0} (complete_lattice.{0} (complete_semilattice_Sup.{0} char))) h0 (@list.nil.{0} (complete_lattice.{0} (complete_semilattice_Sup.{0} char)))) (λ (x : @eq.{1} (list.{0} (complete_lattice.{0} (complete_semilattice_Sup.{0} char))) h0 (@list.nil.{0} (complete_lattice.{0} (complete_semilattice_Sup.{0} char)))), false) h1))  := sorry --non-trivial
lemma new_lemma_147698 (h0 : topological_space (complete_distrib_lattice empty)) : totally_separated_space (complete_distrib_lattice empty) := sorry --non-trivial
lemma new_lemma_147699 (h0 : not (complete_lattice (left_cancel_semigroup num) -> false)) : @is_compactly_generated.{0} (left_cancel_semigroup.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (left_cancel_semigroup.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_147700 (h0 : ordered_add_comm_monoid (has_zero (has_nndist Type))) : archimedean (has_zero (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_147701 (h0 : complete_lattice (semi_normed_ring linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (semi_normed_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_147702 (h1 : group fun_info) : normalizer_condition fun_info := sorry --non-trivial
lemma new_lemma_147703 (h0 : uniform_space (complete_distrib_lattice (has_add Type))) : separated_space (complete_distrib_lattice (has_add Type)) := sorry --non-trivial
lemma new_lemma_147704 (h0 : ring (uniform_space (has_well_founded (denumerable char)))) : is_domain (uniform_space (has_well_founded (denumerable char))) := sorry --non-trivial
lemma new_lemma_147705 (h0 : not (add_group (linear_ordered_comm_ring unsigned) -> false)) : @is_add_cyclic.{0} (linear_ordered_comm_ring.{0} unsigned) (@classical.by_contradiction'.{1} (add_group.{0} (linear_ordered_comm_ring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_147706 (h0 : uniform_space (linear_ordered_comm_group (option (option unsigned)))) : separated_space (linear_ordered_comm_group (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_147707 (h0 : ring (add_cancel_monoid pos)) : strong_rank_condition (add_cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_147708 (h0 : complete_lattice (has_top (random_gen (has_inv fun_info)))) : is_compactly_generated (has_top (random_gen (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_147709 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (with_one to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_147710 (h0 : topological_space (has_pos_part char)) : t0_space (has_pos_part char) := sorry --non-trivial
lemma new_lemma_147711 (h0 : functor.add_const (filter (complete_distrib_lattice name)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_147712 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (add_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_147713 (h0 : ring (linear_ordered_comm_group_with_zero (has_nnnorm reducibility_hints))) : rank_condition (linear_ordered_comm_group_with_zero (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_147714 (h0 : functor.add_const (function.extfun Type list) Type) : palindrome (function.extfun_app (functor.add_const.run h0) (add_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_147715 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_147716 (h0 : functor.add_const (list (normed_comm_ring linarith.comp)) environment.implicit_infer_kind) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_147717 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group num))) : @is_cyclic.{0} (normed_group.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (normed_group.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_147718 (h0 : functor.add_const (list (cancel_monoid name)) (has_add Type)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_147719 (h0 : prod (has_dist (option (option empty))) (has_dist (option (option empty)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_147720 (h2 : not (ring (has_ssubset char) -> false)) : @is_domain.{0} (has_ssubset.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} char)) h2)  := sorry --non-trivial
lemma new_lemma_147721 (h0 : group (has_one (semiring unsigned))) : is_cyclic (has_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_147722 (h0 : topological_space (has_top (has_top (has_top (random_gen (has_top (random_gen fun_info))))))) : irreducible_space (has_top (has_top (has_top (random_gen (has_top (random_gen fun_info)))))) := sorry --non-trivial
lemma new_lemma_147723 (h0 : functor.add_const (topological_space (comm_group name)) unsigned) : @path_connected_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_147724 (h0 : topological_space (preorder (semiring empty))) : irreducible_space (preorder (semiring empty)) := sorry --non-trivial
lemma new_lemma_147725 (h0 : list (dlist (random_gen (random_gen fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_147726 (h0 : add_group (id linarith.comp)) : is_add_cyclic (id linarith.comp) := sorry --non-trivial
lemma new_lemma_147727 (h0 : ring (simple_graph (ring (has_pos_part linarith.comp)))) : is_domain (simple_graph (ring (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_147728 (h0 : functor.add_const (topological_space (comm_group ennreal)) pos) : @regular_space.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_147729 (h0 : functor.add_const (topological_space (semigroup name)) name) : @topological_space.separable_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_147730 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (topological_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (topological_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_147731 (h0 : cancel_comm_monoid_with_zero (boolean_algebra.core (finset (ring linarith.comp)))) : unique_factorization_monoid (boolean_algebra.core (finset (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_147732 (h0 : add_group (topological_space (random_gen (has_nnnorm char)))) : is_add_cyclic (topological_space (random_gen (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_147733 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_147734 (h0 : complete_lattice (has_nnnorm (mul_one_class linarith.ineq))) : is_compactly_generated (has_nnnorm (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_147735 (h0 : functor.add_const (group (has_to_string linarith.comp)) linarith.comp) : @group.fg.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_147736 (h0 : functor.add_const (add_group (has_add Type)) linarith.comp) : @is_add_cyclic.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (has_add.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_147737 (h0 : functor.add_const (group (has_neg_part environment.implicit_infer_kind)) Type) : @is_simple_group.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (group.{0} (has_neg_part.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_147738 (h0 : ordered_add_comm_monoid (canonically_ordered_monoid (has_Inf (has_add (has_add Type))))) : archimedean (canonically_ordered_monoid (has_Inf (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_147739 (h0 : group (has_neg congr_arg_kind)) : group.fg (has_neg congr_arg_kind) := sorry --non-trivial
lemma new_lemma_147740 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_147741 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_147742 (h0 : topological_space (has_edist (option (option unsigned)))) : loc_path_connected_space (has_edist (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_147743 (h0 : monoid (add_cancel_monoid (normed_comm_ring Type))) : monoid.fg (add_cancel_monoid (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_147744 (h0 : ordered_add_comm_monoid (has_to_string environment.implicit_infer_kind)) : archimedean (has_to_string environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_147745 (h0 : complete_lattice (topological_space char)) : complete_lattice.is_Sup_finite_compact (topological_space char) := sorry --non-trivial
lemma new_lemma_147746 (h0 : functor.add_const (group (as_linear_order congr_arg_kind)) unsigned) : @normalizer_condition.{0} (as_linear_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (as_linear_order.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_147747 (h0 : topological_space (cancel_monoid name)) : locally_compact_space (cancel_monoid name) := sorry --non-trivial
lemma new_lemma_147748 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_147749 (h1 : topological_space (with_bot num)) : locally_compact_space (with_bot num) := sorry --non-trivial
lemma new_lemma_147750 (h0 : functor.add_const (semiring (has_nndist Type)) pos) : @is_noetherian_ring.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (has_nndist.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_147751 (h0 : functor.add_const (topological_space (comm_monoid num)) unsigned) : @t0_space.{0} (comm_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_monoid.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_147752 (h0 : not (has_mem.mem ring has_emptyc.emptyc -> false)) : @is_domain.{0} string_imp (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) string_imp)  := sorry --non-trivial
lemma new_lemma_147753 (h0 : ring (ring (boolean_algebra (has_neg Type)))) : rank_condition (ring (boolean_algebra (has_neg Type))) := sorry --non-trivial
lemma new_lemma_147754 (h0 : topological_space (add_group num)) : path_connected_space (add_group num) := sorry --non-trivial
lemma new_lemma_147755 (h0 : add_group (semigroup (has_add linarith.comp))) : is_add_cyclic (semigroup (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_147756 (h0 : group (linear_ordered_add_comm_group (random_gen (random_gen (has_top linarith.ineq))))) : is_cyclic (linear_ordered_add_comm_group (random_gen (random_gen (has_top linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_147757 (h0 : has_top (has_top empty) -> has_top (has_top empty) -> Prop) : is_trans (has_top (has_top empty)) h0 := sorry --non-trivial
lemma new_lemma_147758 (h0 : topological_space (has_neg fun_info)) : path_connected_space (has_neg fun_info) := sorry --non-trivial
lemma new_lemma_147759 (h0 : topological_space (has_div (mul_one_class (mul_one_class (mul_one_class fun_info))))) : t0_space (has_div (mul_one_class (mul_one_class (mul_one_class fun_info)))) := sorry --non-trivial
lemma new_lemma_147760 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_147761 (h0 : group (normed_group (random_gen num))) : is_cyclic (normed_group (random_gen num)) := sorry --non-trivial
lemma new_lemma_147762 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_147763 (h0 : functor.comp topological_space pseudo_metric_space ennreal) : @totally_disconnected_space.{0} (pseudo_metric_space.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} pseudo_metric_space.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_147764 (h0 : function.extfun nat fin) : @regular_space.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_pos_part.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_147765 (h0 : topological_space (boolean_algebra.core (has_neg_part Type))) : locally_compact_space (boolean_algebra.core (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_147766 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_147767 (h0 h1 : multiset (has_nnnorm linarith.comp_source)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_147768 (h0 : functor.add_const (complete_lattice (has_zero linarith.comp)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_zero.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_147769 (h0 : filter (has_ssubset (has_inv fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_147770 (h0 : functor.add_const (topological_space (has_zero unsigned)) pos) : @loc_path_connected_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_147771 (h0 : ring (mul_one_class (add_comm_semigroup char))) : strong_rank_condition (mul_one_class (add_comm_semigroup char)) := sorry --non-trivial
lemma new_lemma_147772 (h0 : topological_space (has_neg environment.implicit_infer_kind)) : regular_space (has_neg environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_147773 (h0 : functor.add_const (ring (ordered_ring unsigned)) (semiring unsigned)) : @rank_condition.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (ordered_ring.{0} unsigned)) (semiring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_147774 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_147775 (h1 : topological_space (has_div std_gen)) : t0_space (has_div std_gen) := sorry --non-trivial
lemma new_lemma_147776 (h0 : list (with_bot (random_gen fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_147777 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_147778 (h0 : function.extfun Type ring) : @rank_condition.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_147779 (h0 : topological_space (option (option (semiring (semiring unsigned))))) : topological_space.separable_space (option (option (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_147780 (h0 : topological_space (has_neg (option pos))) : discrete_topology (has_neg (option pos)) := sorry --non-trivial
lemma new_lemma_147781 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @t0_space.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_147782 (h0 : ring (add_comm_semigroup char)) : rank_condition (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_147783 (h0 : topological_space (has_ssubset string.iterator_imp)) (h1 : add_group (has_ssubset string.iterator_imp)) : topological_add_group (has_ssubset string.iterator_imp) := sorry --non-trivial
lemma new_lemma_147784 (h0 : complete_lattice (semi_normed_ring (has_nnnorm fun_info))) : is_compactly_generated (semi_normed_ring (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_147785 (h0 : group (id unsigned)) : normalizer_condition (id unsigned) := sorry --non-trivial
lemma new_lemma_147786 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_147787 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @rank_condition.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_147788 (h0 : group (has_neg environment.implicit_infer_kind)) : is_cyclic (has_neg environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_147789 (h2 : Prop) : set.separates_points (id (fun (h1 : char -> enat), h2)) := sorry --non-trivial
lemma new_lemma_147790 (h0 : function.extfun Type topological_space) : @t0_space.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_147791 (h0 : list (partial_order (semiring empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_147792 (h0 : ring (semigroup (has_neg linarith.comp))) : rank_condition (semigroup (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_147793 (h0 : functor.comp topological_space mul_zero_class ennreal) : @discrete_topology.{0} (mul_zero_class.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_147794 (h1 : not (ring (has_append to_additive.value_type) -> false)) : @rank_condition.{0} (has_append.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (has_append.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_147795 (h0 : list (has_ssubset (comm_ring fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_147796 (h0 : group (linear_ordered_add_comm_group to_additive.value_type)) : group.fg (linear_ordered_add_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_147797 (h0 : functor.add_const (complete_lattice (pseudo_metric_space unsigned)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (pseudo_metric_space.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (pseudo_metric_space.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_147798 (h0 : not (monoid (has_emptyc num) -> false)) : @monoid.fg.{0} (has_emptyc.{0} num) (@classical.by_contradiction'.{1} (monoid.{0} (has_emptyc.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_147799 (h0 : functor.add_const (group (add_cancel_monoid name)) environment.implicit_infer_kind) : @normalizer_condition.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_147800 (h0 : topological_space (uniform_space reducibility_hints)) : t0_space (uniform_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_147801 (h0 : ring (has_pos_part name)) : is_domain (has_pos_part name) := sorry --non-trivial
lemma new_lemma_147802 (h0 : group (semigroup (has_neg pos))) : is_simple_group (semigroup (has_neg pos)) := sorry --non-trivial
lemma new_lemma_147803 (h2 : ring (topological_space char)) : strong_rank_condition (topological_space char) := sorry --non-trivial
lemma new_lemma_147804 (h0 : topological_space (with_bot to_additive.value_type)) : totally_separated_space (with_bot to_additive.value_type) := sorry --non-trivial
lemma new_lemma_147805 (h0 : not (group (has_emptyc fun_info) -> false)) : @normalizer_condition.{0} (has_emptyc.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (has_emptyc.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_147806 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_147807 (h0 : complete_lattice (random_gen (has_top empty))) : is_atomistic (random_gen (has_top empty)) := sorry --non-trivial
lemma new_lemma_147808 (h0 : functor.add_const (uniform_space (add_comm_monoid Type)) Type) : @complete_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (add_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_147809 (h0 : topological_space (id (random_gen linarith.comp))) : irreducible_space (id (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_147810 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (canonically_linear_ordered_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_147811 (h0 : function.extfun nat fin) : @strong_rank_condition.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_147812 (h0 : add_group (comm_ring (has_nnnorm (has_nnnorm linarith.ineq)))) : is_add_cyclic (comm_ring (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_147813 (h0 : ring (has_le enat)) : rank_condition (has_le enat) := sorry --non-trivial
lemma new_lemma_147814 (h0 : functor.add_const (topological_space (comm_monoid empty)) empty) : @path_connected_space.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_147815 (h0 : semiring (finset (finset (finset (finset (has_nndist pos)))))) : is_noetherian_ring (finset (finset (finset (finset (has_nndist pos))))) := sorry --non-trivial
lemma new_lemma_147816 (h0 : function.extfun Type group) : @is_cyclic.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_147817 (h0 : uniform_space (add_comm_monoid (comm_group (measurable_space name)))) : separated_space (add_comm_monoid (comm_group (measurable_space name))) := sorry --non-trivial
lemma new_lemma_147818 (h0 : topological_space (measurable_space (has_norm (has_norm linarith.comp_source)))) : locally_compact_space (measurable_space (has_norm (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_147819 (h0 : functor.add_const (function.extfun Type complete_lattice) name) : @is_compactly_generated.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) name h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_147820 (h0 : topological_space (normed_comm_ring (has_to_string name))) : t0_space (normed_comm_ring (has_to_string name)) := sorry --non-trivial
lemma new_lemma_147821 (h0 : add_group (boolean_algebra.core (option name))) : is_add_cyclic (boolean_algebra.core (option name)) := sorry --non-trivial
lemma new_lemma_147822 (h0 : group (boolean_algebra (ring linarith.comp))) : is_simple_group (boolean_algebra (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_147823 (h0 : complete_lattice (simple_graph (has_pos_part (has_pos_part linarith.comp)))) : is_compactly_generated (simple_graph (has_pos_part (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_147824 (h0 : functor.add_const (topological_space (cancel_monoid pos)) (comm_group Type)) : @discrete_topology.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} pos)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_147825 (h0 : option Prop) (h1 : coe_sort (option.is_some (id h0))) : option.get h1 := sorry --non-trivial
lemma new_lemma_147826 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_147827 (h0 : functor.add_const (topological_space (finset unsigned)) unsigned) : @t0_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_147828 (h3 : semiring (add_comm_semigroup enat)) (h4 : ideal (add_comm_semigroup enat)) : ideal.is_prime h4 := sorry --non-trivial
lemma new_lemma_147829 (h0 : functor.add_const (complete_lattice (has_bot name)) Type) : @is_atomistic.{0} (has_bot.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_bot.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_147830 (h0 : ordered_comm_monoid (has_add (has_add name))) : has_exists_mul_of_le (has_add (has_add name)) := sorry --non-trivial
lemma new_lemma_147831 (h0 : not (topological_space (complete_semilattice_Sup linarith.comp) -> false)) : @discrete_topology.{0} (complete_semilattice_Sup.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_147832 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc to_additive.value_type))) : @t0_space.{0} (has_emptyc.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} to_additive.value_type)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_147833 (h3 : complete_lattice environment.projection_info) : complete_lattice.is_Sup_finite_compact environment.projection_info := sorry --non-trivial
lemma new_lemma_147834 (h0 : monoid (with_bot unsigned)) : monoid.fg (with_bot unsigned) := sorry --non-trivial
lemma new_lemma_147835 (h0 : functor.comp complete_lattice has_neg_part Type) : @is_compactly_generated.{1} (has_neg_part.{1} Type) (@functor.comp.run.{1 1 1} complete_lattice.{1} has_neg_part.{1} Type (@functor.comp.run.{1 1 1} complete_lattice.{1} has_neg_part.{1} Type h0))  := sorry --non-trivial
lemma new_lemma_147836 (h0 : functor.add_const (topological_space (has_nndist Type)) linarith.comp) : @sequential_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_147837 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_147838 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) pos) : @preirreducible_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_147839 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_147840 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_147841 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_147842 (h0 : functor.add_const (list (has_star congr_arg_kind)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_147843 (h0 : group (measurable_space (random_gen (with_bot string_imp)))) : normalizer_condition (measurable_space (random_gen (with_bot string_imp))) := sorry --non-trivial
lemma new_lemma_147844 (h0 h1 : ulower pnat) : pnat.coprime (ulower.up h0) (ulower.up h1) := sorry --non-trivial
lemma new_lemma_147845 (h0 : functor.add_const (topological_space (ordered_comm_monoid Type)) linarith.comp) : @topological_space.separable_space.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_147846 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_147847 (h0 : group (boolean_algebra (has_pos_part real))) : group.fg (boolean_algebra (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_147848 (h2 : complete_lattice (has_lt to_additive.value_type)) : is_compactly_generated (has_lt to_additive.value_type) := sorry --non-trivial
lemma new_lemma_147849 (h0 : topological_space (add_left_cancel_semigroup empty)) : path_connected_space (add_left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_147850 (h1 : ring enat) : strong_rank_condition enat := sorry --non-trivial
lemma new_lemma_147851 (h0 : ring (generalized_boolean_algebra (has_bot (ordered_comm_monoid pos)))) : is_principal_ideal_ring (generalized_boolean_algebra (has_bot (ordered_comm_monoid pos))) := sorry --non-trivial
lemma new_lemma_147852 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (canonically_ordered_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (canonically_ordered_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_147853 (h0 : topological_space (pseudo_metric_space pos)) : discrete_topology (pseudo_metric_space pos) := sorry --non-trivial
lemma new_lemma_147854 (h0 : group (add_comm_monoid (comm_group (comm_group (has_add (has_add Type)))))) : is_cyclic (add_comm_monoid (comm_group (comm_group (has_add (has_add Type))))) := sorry --non-trivial
lemma new_lemma_147855 (h0 : complete_lattice (pseudo_metric_space empty)) : is_compactly_generated (pseudo_metric_space empty) := sorry --non-trivial
lemma new_lemma_147856 (h0 : monoid (has_pos_part (finset Type))) : monoid.fg (has_pos_part (finset Type)) := sorry --non-trivial
lemma new_lemma_147857 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_147858 (h0 : topological_space (boolean_algebra.core (comm_group unsigned))) : irreducible_space (boolean_algebra.core (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_147859 (h0 : function.extfun Type ring) : @is_domain.{0} (left_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (left_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_147860 (h0 : uniform_space (has_pos_part (ordered_comm_semiring name))) : complete_space (has_pos_part (ordered_comm_semiring name)) := sorry --non-trivial
lemma new_lemma_147861 (h0 : topological_space (has_star unsigned)) : irreducible_space (has_star unsigned) := sorry --non-trivial
lemma new_lemma_147862 (h0 : functor.add_const (filter (normed_comm_ring Type)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_147863 (h0 : topological_space (semiring (has_norm congr_arg_kind))) : totally_separated_space (semiring (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_147864 (h0 : topological_space (has_neg (semigroup (has_to_string pos)))) : discrete_topology (has_neg (semigroup (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_147865 (h0 : ring (semi_normed_ring (has_ssubset linarith.ineq))) : is_domain (semi_normed_ring (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_147866 (h0 : not (topological_space (bin_tree empty) -> false)) : @t1_space.{0} (bin_tree.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (bin_tree.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_147867 (h1 : not (complete_lattice (has_compl char) -> false)) : @is_compactly_generated.{0} (has_compl.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_compl.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_147868 (h0 : topological_space (has_emptyc (has_norm (has_norm fun_info)))) : locally_compact_space (has_emptyc (has_norm (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_147869 (h0 : topological_space (has_norm (random_gen (random_gen (random_gen linarith.comp_source))))) : locally_compact_space (has_norm (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_147870 (h0 : topological_space (has_ssubset (has_ssubset environment.projection_info))) : t0_space (has_ssubset (has_ssubset environment.projection_info)) := sorry --non-trivial
lemma new_lemma_147871 (h1 : pnat) : pnat.prime h1 := sorry --non-trivial
lemma new_lemma_147872 (h0 : has_lt (has_ssubset (has_neg (semi_normed_ring char)))) : no_max_order (has_ssubset (has_neg (semi_normed_ring char))) := sorry --non-trivial
lemma new_lemma_147873 (h0 : topological_space (distrib to_additive.value_type)) : locally_compact_space (distrib to_additive.value_type) := sorry --non-trivial
lemma new_lemma_147874 (h0 : semiring (complete_semilattice_Sup (semiring (semiring unsigned)))) : is_noetherian_ring (complete_semilattice_Sup (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_147875 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_147876 (h0 : functor.add_const (topological_space (has_to_string ennreal)) Type) : @totally_separated_space.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_147877 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 real) := sorry --non-trivial
lemma new_lemma_147878 (h0 : functor.add_const (add_group (has_neg pos)) (has_neg pos)) : @is_add_cyclic.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_neg.{0} pos)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_147879 (h0 : topological_space (measure_theory.measure_space (semiring (semiring (semiring empty))))) : totally_separated_space (measure_theory.measure_space (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_147880 (h0 : complete_lattice (measurable_space (random_gen linarith.ineq))) : complete_lattice.is_Sup_finite_compact (measurable_space (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_147881 (h0 : functor.add_const (add_group (has_zero name)) name) : @is_add_cyclic.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (has_zero.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_147882 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) name) : @path_connected_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_147883 (h0 : topological_space (has_scalar Type real)) : loc_path_connected_space (has_scalar Type real) := sorry --non-trivial
lemma new_lemma_147884 (h0 : not (topological_space reducibility_hints -> false)) : @t0_space.{0} reducibility_hints (@classical.by_contradiction'.{1} (topological_space.{0} reducibility_hints) h0)  := sorry --non-trivial
lemma new_lemma_147885 (h1 : group (with_bot to_additive.value_type)) : normalizer_condition (with_bot to_additive.value_type) := sorry --non-trivial
lemma new_lemma_147886 (h0 : finset (linear_ordered_field (option (option ennreal)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_147887 (h0 : functor.add_const (add_group (comm_group linarith.comp)) (has_neg (has_neg (has_neg (has_neg linarith.comp))))) : @is_add_cyclic.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (comm_group.{0} linarith.comp)) (has_neg.{0} (has_neg.{0} (has_neg.{0} (has_neg.{0} linarith.comp)))) h0)  := sorry --non-trivial
lemma new_lemma_147888 (h0 : ring (has_norm fun_info)) : rank_condition (has_norm fun_info) := sorry --non-trivial
lemma new_lemma_147889 (h0 : topological_space (has_one (semiring unsigned))) : path_connected_space (has_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_147890 (h0 : functor.add_const (ordered_add_comm_monoid (has_zero linarith.comp)) (finset Type)) : @archimedean.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_zero.{0} linarith.comp)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_147891 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_147892 (h0 : topological_space (linear_ordered_comm_ring (semiring (semiring num)))) : totally_separated_space (linear_ordered_comm_ring (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_147893 (h0 : uniform_space (cancel_monoid linarith.comp)) : separated_space (cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_147894 (h1 : uniform_space (semi_normed_ring (mul_one_class string_imp))) : complete_space (semi_normed_ring (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_147895 (h0 : uniform_space (has_append (has_nnnorm (has_nnnorm (has_nnnorm (comm_ring (has_nnnorm char))))))) : complete_space (has_append (has_nnnorm (has_nnnorm (has_nnnorm (comm_ring (has_nnnorm char)))))) := sorry --non-trivial
lemma new_lemma_147896 (h0 : functor.add_const (function.extfun Type add_monoid) name) : @add_monoid.fg.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) name h0) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_147897 (h0 : ring (complete_distrib_lattice (add_comm_monoid environment.implicit_infer_kind))) : rank_condition (complete_distrib_lattice (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_147898 (h0 : function.extfun unit (fun (x : unit), Prop)) : @trace_call_stack.{0} Prop (@function.extfun_app.{1 1} unit (λ (x : unit), Prop) h0)  := sorry --non-trivial
lemma new_lemma_147899 (h0 : function.extfun Type ring) : @is_domain.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_147900 (h0 : topological_space (canonically_linear_ordered_monoid (has_add ennreal))) : normal_space (canonically_linear_ordered_monoid (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_147901 (h0 : topological_space (canonically_ordered_comm_semiring unsigned)) : path_connected_space (canonically_ordered_comm_semiring unsigned) := sorry --non-trivial
lemma new_lemma_147902 (h0 : topological_space (boolean_algebra (add_comm_monoid Type))) : totally_disconnected_space (boolean_algebra (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_147903 (h0 : not (ring (linear_ordered_add_comm_group linarith.ineq) -> false)) : @is_domain.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_add_comm_group.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_147904 (h0 : ring (add_right_cancel_monoid (semiring (semiring (semiring num))))) : strong_rank_condition (add_right_cancel_monoid (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_147905 (h0 : function.extfun (finset Type) (has_mem.mem (with_one linarith.comp_source))) : @totally_disconnected_space.{0} (with_one.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_147906 (h0 : functor.add_const (function.extfun (Type 1) group) name) : @group.fg.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) name h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_147907 (h0 : add_monoid (complete_distrib_lattice (ring name))) : add_monoid.fg (complete_distrib_lattice (ring name)) := sorry --non-trivial
lemma new_lemma_147908 (h0 : measurable_space (nondiscrete_normed_field (add_comm_semigroup enat))) (h1 : filter (nondiscrete_normed_field (add_comm_semigroup enat))) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_147909 (h1 : function.extfun Type ring) : @rank_condition.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h1 (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_147910 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_147911 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) Type) : @archimedean.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) Type h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_147912 (h0 : group (distrib (semi_normed_ring (random_gen (random_gen linarith.comp_source))))) : is_cyclic (distrib (semi_normed_ring (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_147913 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_147914 (h0 : functor.add_const (group (mul_zero_class environment.implicit_infer_kind)) (has_add (has_add Type))) : @is_cyclic.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (group.{0} (mul_zero_class.{0} environment.implicit_infer_kind)) (has_add.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_147915 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen linarith.comp_source))) : @is_add_cyclic.{0} (random_gen.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type add_group.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_147916 (h0 : complete_lattice (normed_linear_ordered_group (option (option (semiring num))))) : is_atomistic (normed_linear_ordered_group (option (option (semiring num)))) := sorry --non-trivial
lemma new_lemma_147917 (h0 : functor.add_const (group (ordered_comm_ring pos)) (has_neg name)) : @group.fg.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (ordered_comm_ring.{0} pos)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_147918 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_147919 (h0 : complete_lattice (ordered_comm_monoid (has_Inf name))) : complete_lattice.is_Sup_finite_compact (ordered_comm_monoid (has_Inf name)) := sorry --non-trivial
lemma new_lemma_147920 (h0 : uniform_space (has_Inf (has_add (has_add (has_add (ring name)))))) : complete_space (has_Inf (has_add (has_add (has_add (ring name))))) := sorry --non-trivial
lemma new_lemma_147921 (h0 : topological_space (has_zero (boolean_algebra linarith.comp))) : topological_space.separable_space (has_zero (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_147922 (h0 : group (dlist (random_gen linarith.comp_source))) : group.fg (dlist (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_147923 (h0 : add_monoid (add_cancel_comm_monoid (option empty))) : add_monoid.fg (add_cancel_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_147924 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (add_left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_147925 (h0 : topological_space (has_add (has_neg_part (finset (finset (finset linarith.comp)))))) : loc_path_connected_space (has_add (has_neg_part (finset (finset (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_147926 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) environment.implicit_infer_kind) : @preirreducible_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_147927 (h0 : topological_space (has_pos_part (has_add linarith.comp))) : path_connected_space (has_pos_part (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_147928 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_cancel_monoid linarith.comp)) pos) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_cancel_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_147929 (h0 : uniform_space (normed_lattice_add_comm_group (has_neg linarith.comp))) : separated_space (normed_lattice_add_comm_group (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_147930 (h0 : functor.add_const (topological_space (has_star congr_arg_kind)) empty) : @discrete_topology.{0} (has_star.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_147931 (h0 : topological_space (has_pow linarith.ineq string.iterator_imp)) : totally_disconnected_space (has_pow linarith.ineq string.iterator_imp) := sorry --non-trivial
lemma new_lemma_147932 (h0 : not (complete_lattice (non_unital_non_assoc_semiring linarith.comp_source) -> false)) : @is_compactly_generated.{0} (non_unital_non_assoc_semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (non_unital_non_assoc_semiring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_147933 (h0 : list (add_right_cancel_monoid (option empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_147934 (h0 : fin has_zero.zero) : @normal_space.{0} (add_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_147935 (h0 : topological_space (mul_zero_class num)) : irreducible_space (mul_zero_class num) := sorry --non-trivial
lemma new_lemma_147936 (h0 : group (has_zero (finset environment.implicit_infer_kind))) : is_simple_group (has_zero (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_147937 (h0 : filter (topological_space (normed_field string_imp))) : @t0_space.{0} (normed_field.{0} string_imp) (@filter.Limsup.{0} (topological_space.{0} (normed_field.{0} string_imp)) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (normed_field.{0} string_imp)) (@topological_space.complete_lattice.{0} (normed_field.{0} string_imp))) h0)  := sorry --non-trivial
lemma new_lemma_147938 (h0 : functor.add_const (function.extfun Type complete_lattice) Type) : @complete_lattice.is_Sup_finite_compact.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type complete_lattice.{0}) Type h0) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_147939 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_147940 (h0 : topological_space (option (has_star (semiring (complete_linear_order empty))))) : preirreducible_space (option (has_star (semiring (complete_linear_order empty)))) := sorry --non-trivial
lemma new_lemma_147941 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group congr_arg_kind))) : @is_atomistic.{0} (normed_group.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_147942 (h0 : ring (finset num)) : rank_condition (finset num) := sorry --non-trivial
lemma new_lemma_147943 (h0 : functor.add_const (add_monoid (sub_neg_monoid pos)) (has_add (has_Inf (has_neg pos)))) : @add_monoid.fg.{0} (sub_neg_monoid.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (sub_neg_monoid.{0} pos)) (has_add.{0} (has_Inf.{0} (has_neg.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_147944 (h0 : topological_space (ordered_comm_monoid Type)) : totally_disconnected_space (ordered_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_147945 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) linarith.comp) : @discrete_topology.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_147946 (h0 : not (add_group (add_left_cancel_semigroup unsigned) -> false)) : @is_add_cyclic.{0} (add_left_cancel_semigroup.{0} unsigned) (@classical.by_contradiction'.{1} (add_group.{0} (add_left_cancel_semigroup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_147947 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_147948 (h0 : functor.add_const (ring (has_nndist linarith.comp)) (finset linarith.comp)) : @is_principal_ideal_ring.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} linarith.comp)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_147949 (h0 : topological_space (canonically_ordered_comm_semiring linarith.comp)) : totally_separated_space (canonically_ordered_comm_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_147950 (h0 : functor.add_const (topological_space (has_neg name)) linarith.comp) : @totally_separated_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_147951 (h0 : topological_space (has_union (semiring (semiring num)))) : t0_space (has_union (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_147952 (h0 : functor.add_const (topological_space (has_nndist ennreal)) pos) : @irreducible_space.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_147953 (h0 : complete_lattice (id (semiring (semiring unsigned)))) : is_atomistic (id (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_147954 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_147955 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (linear_ordered_add_comm_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_147956 (h0 : add_group (random_gen (random_gen (random_gen char)))) : is_add_cyclic (random_gen (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_147957 (h0 : prod (linear_ordered_comm_group empty) (linear_ordered_comm_group empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_147958 (h0 : group (left_cancel_semigroup (semiring (semiring (semiring (semiring (semiring empty))))))) : is_cyclic (left_cancel_semigroup (semiring (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_147959 (h0 : functor.add_const (ring (ring environment.implicit_infer_kind)) environment.implicit_infer_kind) : @is_domain.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_147960 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) linarith.comp) : @loc_path_connected_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_147961 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_147962 (h0 : functor.add_const (complete_lattice (has_to_string name)) environment.implicit_infer_kind) : @is_atomistic.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_147963 (h0 : add_group (option (option (option (option pos))))) : is_add_cyclic (option (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_147964 (h0 : add_monoid (has_to_string (has_nndist (has_nndist name)))) : add_monoid.fg (has_to_string (has_nndist (has_nndist name))) := sorry --non-trivial
lemma new_lemma_147965 (h0 : Prop) (h1 : setoid h0) : quotient h1 := sorry --non-trivial
lemma new_lemma_147966 (h1 : complete_lattice (topological_space (comm_ring reducibility_hints))) : complete_lattice.is_Sup_finite_compact (topological_space (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_147967 (h0 : group (semigroup (semiring (semiring empty)))) : is_cyclic (semigroup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_147968 (h0 : uniform_space (has_add (random_gen (random_gen linarith.comp_source)))) : complete_space (has_add (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_147969 (h0 : add_monoid (ring (option (option empty)))) : add_monoid.fg (ring (option (option empty))) := sorry --non-trivial
lemma new_lemma_147970 (h0 : function.extfun Type topological_space) : @normal_space.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_147971 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_147972 (h0 : list (finset (finset name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_147973 (h0 : ring (nondiscrete_normed_field fun_info)) : strong_rank_condition (nondiscrete_normed_field fun_info) := sorry --non-trivial
lemma new_lemma_147974 (h0 : set (linear_ordered_comm_group_with_zero enat)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_147975 (h0 : topological_space (non_assoc_semiring (option (option empty)))) : locally_compact_space (non_assoc_semiring (option (option empty))) := sorry --non-trivial
lemma new_lemma_147976 (h0 : function.extfun Type (functor.add_const (complete_lattice (ordered_ring unsigned)))) : @is_compactly_generated.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_ring.{0} unsigned)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (ordered_ring.{0} unsigned))) h0 num))  := sorry --non-trivial
lemma new_lemma_147977 (h0 : not (complete_lattice (with_one linarith.comp) -> false)) : @is_compactly_generated.{0} (with_one.{0} linarith.comp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_one.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_147978 (h0 : set linarith.ineq) : set.finite h0 := sorry --non-trivial
lemma new_lemma_147979 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring Type)) Type) : @sequential_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_147980 (h0 : list (linear_order empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_147981 (h0 : list (canonically_linear_ordered_monoid (option (option (option unsigned))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_147982 (h0 : filter (linear_ordered_semiring (semiring num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_147983 (h0 : not (topological_space (has_top empty) -> false)) : @preirreducible_space.{0} (has_top.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_147984 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @discrete_topology.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_147985 (h0 : function.extfun nat fin) : @is_noetherian_ring.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type semiring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type semiring.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_147986 (h0 : ring (left_cancel_semigroup (option (option (option (option num)))))) : is_domain (left_cancel_semigroup (option (option (option (option num))))) := sorry --non-trivial
lemma new_lemma_147987 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (group_with_zero.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (group_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_147988 (h0 : functor.add_const (ordered_add_comm_monoid (non_assoc_semiring empty)) (option (semiring empty))) : @archimedean.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (non_assoc_semiring.{0} empty)) (option.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_147989 (h0 : functor.add_const (uniform_space (measure_theory.measure_space congr_arg_kind)) congr_arg_kind) : @complete_space.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (measure_theory.measure_space.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_147990 (h0 : functor.add_const (group (left_cancel_monoid num)) (semiring (semiring num))) : @normalizer_condition.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (group.{0} (left_cancel_monoid.{0} num)) (semiring.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_147991 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @totally_separated_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_147992 (h0 : topological_space (has_add (has_add (has_Inf real)))) : normal_space (has_add (has_add (has_Inf real))) := sorry --non-trivial
lemma new_lemma_147993 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} num (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 num)  := sorry --non-trivial
lemma new_lemma_147994 (h0 : functor.add_const (group (finset name)) Type) : @is_cyclic.{0} (finset.{0} name) (@functor.add_const.run.{0 1} (group.{0} (finset.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_147995 (h0 : topological_space (ordered_cancel_add_comm_monoid pos)) : t0_space (ordered_cancel_add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_147996 (h0 : complete_lattice (normed_group string_imp)) : is_atomistic (normed_group string_imp) := sorry --non-trivial
lemma new_lemma_147997 (h0 : add_group (has_top (denumerable (has_top linarith.ineq)))) : is_add_cyclic (has_top (denumerable (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_147998 (h0 : has_mem.mem (with_bot linarith.comp) has_emptyc.emptyc) : @t0_space.{0} (with_bot.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_147999 (h1 : has_mem.mem num has_emptyc.emptyc) : @is_domain.{0} num (@finset.pi.empty.{1 0} Type ring.{0} num h1)  := sorry --non-trivial
lemma new_lemma_148000 (h0 : not (topological_space (comm_ring linarith.ineq) -> false)) : @t0_space.{0} (comm_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (comm_ring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_148001 (h0 : ring (finset (has_Inf (has_neg (has_neg (has_Inf (has_Inf pos))))))) : strong_rank_condition (finset (has_Inf (has_neg (has_neg (has_Inf (has_Inf pos)))))) := sorry --non-trivial
lemma new_lemma_148002 (h0 : group (semi_normed_ring (has_nnnorm (has_nnnorm linarith.ineq)))) : is_cyclic (semi_normed_ring (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_148003 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (div_inv_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (div_inv_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_148004 (h0 : topological_space (denumerable (random_gen char))) : t0_space (denumerable (random_gen char)) := sorry --non-trivial
lemma new_lemma_148005 (h0 : function.extfun Type (functor.add_const (complete_lattice (preorder num)))) : @complete_lattice.is_Sup_finite_compact.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (preorder.{0} num)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (preorder.{0} num))) h0 num))  := sorry --non-trivial
lemma new_lemma_148006 (h0 : functor.comp topological_space has_zero name) : @path_connected_space.{0} (has_zero.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} name h0)  := sorry --non-trivial
lemma new_lemma_148007 (h1 : topological_space (with_one (has_top linarith.comp_source))) : t0_space (with_one (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_148008 (h0 : congr_arg_kind -> congr_arg_kind -> Prop) : is_irrefl congr_arg_kind h0 := sorry --non-trivial
lemma new_lemma_148009 (h1 : ring (add_group congr_arg_kind)) : rank_condition (add_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_148010 (h0 : group (linear_ordered_field unsigned)) : is_simple_group (linear_ordered_field unsigned) := sorry --non-trivial
lemma new_lemma_148011 (h0 : topological_space environment.implicit_infer_kind) : topological_space.first_countable_topology environment.implicit_infer_kind := sorry --non-trivial
lemma new_lemma_148012 (h0 : monoid (with_bot fun_info)) : monoid.fg (with_bot fun_info) := sorry --non-trivial
lemma new_lemma_148013 (h0 : topological_space (cancel_monoid (normed_comm_ring (boolean_algebra.core (has_add name))))) : path_connected_space (cancel_monoid (normed_comm_ring (boolean_algebra.core (has_add name)))) := sorry --non-trivial
lemma new_lemma_148014 (h1 : not (ring (has_ssubset string_imp) -> false)) : @invariant_basis_number.{0} (has_ssubset.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_148015 (h0 : topological_space (has_ssubset (has_norm (has_norm (has_norm to_additive.value_type))))) : path_connected_space (has_ssubset (has_norm (has_norm (has_norm to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_148016 (h1 : topological_space (div_inv_monoid to_additive.value_type)) : totally_disconnected_space (div_inv_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_148017 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @normal_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_148018 (h1 : topological_space (add_comm_semigroup linarith.ineq)) (h2 : set (add_comm_semigroup linarith.ineq)) : is_path_connected h2 := sorry --non-trivial
lemma new_lemma_148019 (h0 : topological_space (boolean_algebra.core empty)) : totally_disconnected_space (boolean_algebra.core empty) := sorry --non-trivial
lemma new_lemma_148020 (h0 : fin has_zero.zero) : @complete_space.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (has_bot.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_148021 (h0 : filter (semigroup (ring linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_148022 (h0 : functor.add_const (complete_lattice (has_neg linarith.comp)) linarith.comp) : @is_compactly_generated.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_148023 (h0 : topological_space (with_zero (random_gen (random_gen (random_gen string_imp))))) : totally_disconnected_space (with_zero (random_gen (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_148024 (h0 : functor.add_const (topological_space (option ennreal)) ennreal) : @loc_path_connected_space.{0} (option.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_148025 (h0 : topological_space (has_zero (has_to_string (has_to_string (has_to_string name))))) : loc_path_connected_space (has_zero (has_to_string (has_to_string (has_to_string name)))) := sorry --non-trivial
lemma new_lemma_148026 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (@id.{2} Type string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type string_imp))  := sorry --non-trivial
lemma new_lemma_148027 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @archimedean.{0} (has_dist.{0} num) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ordered_add_comm_monoid.{0}) (has_dist.{0} num))  := sorry --non-trivial
lemma new_lemma_148028 (h1 : complete_lattice (has_ssubset reducibility_hints)) : complete_lattice.is_Sup_finite_compact (has_ssubset reducibility_hints) := sorry --non-trivial
lemma new_lemma_148029 (h0 : function.extfun Type group) : @is_cyclic.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_distrib_lattice.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_148030 (h0 : topological_space (id (semiring num))) : normal_space (id (semiring num)) := sorry --non-trivial
lemma new_lemma_148031 (h0 : group (add_group (partial_order congr_arg_kind))) : normalizer_condition (add_group (partial_order congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_148032 (h0 : ring (simple_graph to_additive.value_type)) : rank_condition (simple_graph to_additive.value_type) := sorry --non-trivial
lemma new_lemma_148033 (h0 : topological_space (comm_semigroup (has_bot linarith.comp))) : totally_disconnected_space (comm_semigroup (has_bot linarith.comp)) := sorry --non-trivial
lemma new_lemma_148034 (h2 : ring (distrib (comm_ring (comm_ring char)))) : strong_rank_condition (distrib (comm_ring (comm_ring char))) := sorry --non-trivial
lemma new_lemma_148035 (h0 : function.extfun Type ring) : @is_domain.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_148036 (h0 : topological_space (semi_normed_ring char)) : totally_disconnected_space (semi_normed_ring char) := sorry --non-trivial
lemma new_lemma_148037 (h0 : ring (ordered_comm_ring Type)) : rank_condition (ordered_comm_ring Type) := sorry --non-trivial
lemma new_lemma_148038 (h0 : topological_space (boolean_algebra (ring environment.implicit_infer_kind))) : discrete_topology (boolean_algebra (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_148039 (h0 : topological_space (has_add (has_Inf Type))) : sequential_space (has_add (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_148040 (h0 : functor.add_const (ordered_comm_monoid (has_nndist ennreal)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_nndist.{0} ennreal)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_148041 (h0 : topological_space (has_to_string (has_add (has_add linarith.comp)))) : loc_path_connected_space (has_to_string (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_148042 (h0 : group (has_top linarith.comp)) : normalizer_condition (has_top linarith.comp) := sorry --non-trivial
lemma new_lemma_148043 (h0 : ring (pseudo_metric_space (option (option (option unsigned))))) : is_domain (pseudo_metric_space (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_148044 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_ordered_comm_monoid_with_zero.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_148045 (h0 : topological_space (add_left_cancel_monoid (has_nnnorm (has_nnnorm linarith.comp_source)))) : path_connected_space (add_left_cancel_monoid (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_148046 (h0 : uniform_space (with_bot (random_gen num))) : separated_space (with_bot (random_gen num)) := sorry --non-trivial
lemma new_lemma_148047 (h0 : function.extfun (Type 1) group) : @normalizer_condition.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_148048 (h0 : topological_space (div_inv_monoid unsigned)) : t0_space (div_inv_monoid unsigned) := sorry --non-trivial
lemma new_lemma_148049 (h0 : uniform_space (has_inv char)) : complete_space (has_inv char) := sorry --non-trivial
lemma new_lemma_148050 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (has_sub.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_sub.{0} num))  := sorry --non-trivial
lemma new_lemma_148051 (h0 : functor.add_const (topological_space (as_linear_order unsigned)) unsigned) : @irreducible_space.{0} (as_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (as_linear_order.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_148052 (h0 : add_group (random_gen (random_gen (has_lt (random_gen char))))) : is_add_cyclic (random_gen (random_gen (has_lt (random_gen char)))) := sorry --non-trivial
lemma new_lemma_148053 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_148054 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) name) : @normal_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_148055 (h0 : uniform_space (metric_space (has_top linarith.comp))) : complete_space (metric_space (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_148056 (h0 : functor.add_const (ring (has_star num)) empty) : @rank_condition.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (has_star.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_148057 (h0 : group (distrib (has_nnnorm (denumerable (has_nnnorm (comm_ring reducibility_hints)))))) : is_cyclic (distrib (has_nnnorm (denumerable (has_nnnorm (comm_ring reducibility_hints))))) := sorry --non-trivial
lemma new_lemma_148058 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_148059 (h0 h1 : multiset (non_unital_non_assoc_semiring std_gen)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_148060 (h0 : topological_space (semigroup empty)) : t0_space (semigroup empty) := sorry --non-trivial
lemma new_lemma_148061 (h0 : topological_space (ordered_comm_group (option unsigned))) : totally_separated_space (ordered_comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_148062 (h0 : preorder (dlist (has_inv fun_info))) (h1 : topological_space (dlist (has_inv fun_info))) : Inf_convergence_class (dlist (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_148063 (h0 : topological_space (normed_comm_ring (ring environment.implicit_infer_kind))) : t0_space (normed_comm_ring (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_148064 (h0 : functor.add_const (group (normed_comm_ring Type)) Type) : @is_simple_group.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (normed_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_148065 (h0 : topological_space (comm_ring (has_ssubset string_imp))) : path_connected_space (comm_ring (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_148066 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_148067 (h0 : topological_space (comm_monoid linarith.ineq)) : path_connected_space (comm_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_148068 (h0 : topological_space (ring (option pos))) : path_connected_space (ring (option pos)) := sorry --non-trivial
lemma new_lemma_148069 (h0 : complete_lattice (has_zero (has_neg_part (has_neg_part (has_neg_part unsigned))))) : is_atomistic (has_zero (has_neg_part (has_neg_part (has_neg_part unsigned)))) := sorry --non-trivial
lemma new_lemma_148070 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_148071 (h0 : list (dlist (distrib_lattice (comm_ring (comm_ring (comm_ring (comm_ring linarith.ineq))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_148072 (h0 : group (comm_ring (random_gen (has_nnnorm (random_gen linarith.comp_source))))) : group.fg (comm_ring (random_gen (has_nnnorm (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_148073 (h0 : functor.comp add_group has_top (has_norm (has_norm (has_norm (has_norm (has_norm linarith.comp_source)))))) : @is_add_cyclic.{0} (has_top.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} linarith.comp_source)))))) (@functor.comp.run.{0 0 0} add_group.{0} has_top.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} linarith.comp_source))))) h0)  := sorry --non-trivial
lemma new_lemma_148074 (h0 : complete_lattice (has_pos_part real)) : is_compactly_generated (has_pos_part real) := sorry --non-trivial
lemma new_lemma_148075 (h0 : semiring (canonically_ordered_monoid (sub_neg_monoid (sub_neg_monoid pos)))) : is_noetherian_ring (canonically_ordered_monoid (sub_neg_monoid (sub_neg_monoid pos))) := sorry --non-trivial
lemma new_lemma_148076 (h1 : ring (add_monoid linarith.comp_source)) : rank_condition (add_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_148077 (h0 : complete_lattice (has_top (has_inv (has_inv linarith.comp_source)))) : is_compactly_generated (has_top (has_inv (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_148078 (h0 : ring (comm_ring (normed_field to_additive.value_type))) : rank_condition (comm_ring (normed_field to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_148079 (h0 : topological_space (canonically_ordered_monoid (ordered_comm_monoid Type))) : irreducible_space (canonically_ordered_monoid (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_148080 (h0 : functor.add_const (ring (has_neg num)) ennreal) : @is_principal_ideal_ring.{0} (has_neg.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} num)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_148081 (h0 : topological_space (has_pos_part (has_Inf (has_add (has_neg (has_add linarith.comp)))))) : preconnected_space (has_pos_part (has_Inf (has_add (has_neg (has_add linarith.comp))))) := sorry --non-trivial
lemma new_lemma_148082 (h0 : functor.add_const (topological_space (finset name)) name) : @regular_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_148083 (h0 : ring (canonically_linear_ordered_monoid (has_add Type))) : is_principal_ideal_ring (canonically_linear_ordered_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_148084 (h0 : list (complete_distrib_lattice environment.implicit_infer_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_148085 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} fun_info (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) fun_info)  := sorry --non-trivial
lemma new_lemma_148086 (h0 : functor.add_const (function.extfun Type topological_space) (has_pos_part (has_pos_part linarith.comp))) : @t1_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_pos_part.{0} (has_pos_part.{0} linarith.comp)) h0) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_148087 (h0 : topological_space (with_one (has_emptyc (random_gen (complete_semilattice_Sup empty))))) : t0_space (with_one (has_emptyc (random_gen (complete_semilattice_Sup empty)))) := sorry --non-trivial
lemma new_lemma_148088 (h0 : set (simple_graph (mul_one_class enat))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_148089 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_neg Type)) environment.implicit_infer_kind) : @unique_factorization_monoid.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (has_neg.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_148090 (h0 : ring (semi_normed_comm_ring environment.projection_info)) : strong_rank_condition (semi_normed_comm_ring environment.projection_info) := sorry --non-trivial
lemma new_lemma_148091 (h0 : not (topological_space (partial_order unsigned) -> false)) : @t0_space.{0} (partial_order.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (partial_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_148092 (h0 : function.extfun Type (functor.add_const (topological_space (comm_group unsigned)))) : @t1_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (comm_group.{0} unsigned))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_148093 (h0 : functor.add_const (ordered_comm_monoid (has_zero name)) name) : @has_exists_mul_of_le.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_zero.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_148094 (h0 : uniform_space (has_norm congr_arg_kind)) : separated_space (has_norm congr_arg_kind) := sorry --non-trivial
lemma new_lemma_148095 (h0 : functor.add_const (complete_lattice (has_nndist name)) pos) : @is_compactly_generated.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_148096 (h1 : topological_space linarith.ineq) : totally_disconnected_space linarith.ineq := sorry --non-trivial
lemma new_lemma_148097 (h0 : complete_lattice (has_one (has_norm (has_norm linarith.comp)))) : complete_lattice.is_Sup_finite_compact (has_one (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_148098 (h1 : ring (has_nnnorm (topological_space (normed_field (normed_field reducibility_hints))))) : rank_condition (has_nnnorm (topological_space (normed_field (normed_field reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_148099 (h1 : function.extfun Type topological_space) : @path_connected_space.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_148100 (h1 : ring (semi_normed_ring reducibility_hints)) : is_domain (semi_normed_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_148101 (h0 : uniform_space (with_zero (random_gen (encodable fun_info)))) : complete_space (with_zero (random_gen (encodable fun_info))) := sorry --non-trivial
lemma new_lemma_148102 (h0 : functor.comp topological_space has_zero linarith.comp) : @totally_separated_space.{0} (has_zero.{0} linarith.comp) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_148103 (h0 : topological_space (has_dist num)) : topological_space.separable_space (has_dist num) := sorry --non-trivial
lemma new_lemma_148104 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_edist.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_edist.{0} num))  := sorry --non-trivial
lemma new_lemma_148105 (h0 : not (uniform_space (has_norm num) -> false)) : @separated_space.{0} (has_norm.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_norm.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_148106 (h0 : has_lt (has_lt enat)) : no_max_order (has_lt enat) := sorry --non-trivial
lemma new_lemma_148107 (h0 : uniform_space (simple_graph name)) : complete_space (simple_graph name) := sorry --non-trivial
lemma new_lemma_148108 (h0 : has_mem.mem (linear_ordered_semiring num) has_emptyc.emptyc) : @add_monoid.fg.{0} (linear_ordered_semiring.{0} num) (@finset.pi.empty.{1 0} Type add_monoid.{0} (linear_ordered_semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_148109 (h0 : fin has_zero.zero) : @preconnected_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_148110 (h0 : functor.add_const (complete_lattice (option unsigned)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (option.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_148111 (h0 : ordered_add_comm_monoid (normed_comm_ring (option unsigned))) : archimedean (normed_comm_ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_148112 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_148113 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (semigroup.{0} (has_neg.{0} empty)) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (semigroup.{0} (has_neg.{0} empty)))  := sorry --non-trivial
lemma new_lemma_148114 (h0 : functor.add_const (list (has_nndist linarith.comp)) (has_neg environment.implicit_infer_kind)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_148115 (h0 : functor.add_const (complete_lattice (ring linarith.comp)) Type) : @is_atomistic.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_148116 (h0 : uniform_space (semi_normed_comm_ring (has_nnnorm (linear_ordered_add_comm_group linarith.ineq)))) : complete_space (semi_normed_comm_ring (has_nnnorm (linear_ordered_add_comm_group linarith.ineq))) := sorry --non-trivial
lemma new_lemma_148117 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @t0_space.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_148118 (h1 : topological_space congr_arg_kind) : discrete_topology congr_arg_kind := sorry --non-trivial
lemma new_lemma_148119 (h0 : topological_space (sub_neg_monoid (has_Inf (finset linarith.comp)))) : totally_disconnected_space (sub_neg_monoid (has_Inf (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_148120 (h0 : not (ring (distrib (random_gen (has_ssubset (random_gen (random_gen (random_gen char)))))) -> false)) : @rank_condition.{0} (distrib.{0} (random_gen.{0} (has_ssubset.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} char)))))) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} (random_gen.{0} (has_ssubset.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} char))))))) h0)  := sorry --non-trivial
lemma new_lemma_148121 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @discrete_topology.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_148122 (h0 : functor.add_const (ring (has_zero environment.implicit_infer_kind)) pos) : @strong_rank_condition.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_148123 (h0 : prod (mul_zero_class (semigroup (has_nndist Type))) (mul_zero_class (semigroup (has_nndist Type)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_148124 (h0 : topological_space (boolean_algebra Type)) : totally_disconnected_space (boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_148125 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_148126 (h0 : functor.comp topological_space add_comm_monoid environment.implicit_infer_kind) : @irreducible_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_148127 (h0 : uniform_space (distrib (mul_one_class (mul_one_class (mul_one_class (has_compl fun_info)))))) : complete_space (distrib (mul_one_class (mul_one_class (mul_one_class (has_compl fun_info))))) := sorry --non-trivial
lemma new_lemma_148128 (h2 : topological_space (denumerable to_additive.value_type)) (h3 : preorder (denumerable to_additive.value_type)) : order_topology (denumerable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_148129 (h0 : filter (cancel_monoid (finset (finset (finset name))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_148130 (h0 : functor.add_const (topological_space (bin_tree num)) (semiring num)) : @t1_space.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_148131 (h0 : function.extfun Type topological_space) : @normal_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_148132 (h0 : filter (has_add (has_nnnorm fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_148133 (h0 : not (complete_lattice (partial_order linarith.comp_source) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (partial_order.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (partial_order.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_148134 (h0 : add_group (has_ssubset (random_gen (has_inv (random_gen linarith.comp_source))))) : is_add_cyclic (has_ssubset (random_gen (has_inv (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_148135 (h0 : complete_lattice (has_inv (has_inv fun_info))) : is_atomistic (has_inv (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_148136 (h0 : topological_space (with_one (random_gen linarith.ineq))) : totally_disconnected_space (with_one (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_148137 (h0 : ordered_add_comm_monoid (finset environment.implicit_infer_kind)) : archimedean (finset environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_148138 (h0 : topological_space (has_add (has_add pos))) : loc_path_connected_space (has_add (has_add pos)) := sorry --non-trivial
lemma new_lemma_148139 (h0 : set (has_div std_gen)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_148140 (h0 : set (semi_normed_ring (has_ssubset string_imp))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_148141 (h0 : nat) (h1 : fin (nat.succ h0) -> filter Prop) (h2 : fin h0) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@id.{1} (filter.{0} Prop) (@matrix.vec_tail.{0} (filter.{0} Prop) h0 h1 h2))  := sorry --non-trivial
lemma new_lemma_148142 (h0 : semiring (boolean_algebra (normed_comm_ring pos))) : is_noetherian_ring (boolean_algebra (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_148143 (h0 : nat) (h1 : topological_space (list nat)) (h2 : set (list nat)) : sequential_closure h2 (list.range h0) := sorry --non-trivial
lemma new_lemma_148144 (h0 : topological_space (ring (has_neg_part environment.implicit_infer_kind))) : discrete_topology (ring (has_neg_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_148145 (h0 : filter (bin_tree (semiring empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_148146 (h0 : topological_space (add_group (has_union unsigned))) : locally_compact_space (add_group (has_union unsigned)) := sorry --non-trivial
lemma new_lemma_148147 (h0 : complete_lattice (with_zero char)) : complete_lattice.is_Sup_finite_compact (with_zero char) := sorry --non-trivial
lemma new_lemma_148148 (h0 : topological_space (has_nndist (finset environment.implicit_infer_kind))) : path_connected_space (has_nndist (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_148149 (h0 : has_neg (has_compl (mul_one_class (mul_one_class (mul_one_class linarith.comp_source))))) (h1 : measurable_space (has_compl (mul_one_class (mul_one_class (mul_one_class linarith.comp_source))))) : has_measurable_neg (has_compl (mul_one_class (mul_one_class (mul_one_class linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_148150 (h0 : topological_space (free_add_monoid empty)) : t0_space (free_add_monoid empty) := sorry --non-trivial
lemma new_lemma_148151 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_148152 (h0 : topological_space (normed_comm_ring name)) : irreducible_space (normed_comm_ring name) := sorry --non-trivial
lemma new_lemma_148153 (h0 : functor.comp topological_space has_zero (finset ennreal)) : @totally_disconnected_space.{0} (has_zero.{0} (finset.{0} ennreal)) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} (finset.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_148154 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_148155 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_148156 (h0 : prod (complete_linear_order congr_arg_kind) (complete_linear_order congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_148157 (h0 : topological_space (cancel_monoid (finset linarith.comp))) : preconnected_space (cancel_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_148158 (h0 : topological_space (option (semiring (semiring empty)))) : path_connected_space (option (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_148159 (h0 : functor.add_const (ring (comm_group Type)) environment.implicit_infer_kind) : @rank_condition.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (comm_group.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_148160 (h0 : has_mem.mem group has_emptyc.emptyc) : @normalizer_condition.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_148161 (h0 : uniform_space (is_R_or_C unsigned)) : complete_space (is_R_or_C unsigned) := sorry --non-trivial
lemma new_lemma_148162 (h0 : group (has_inter num)) : is_simple_group (has_inter num) := sorry --non-trivial
lemma new_lemma_148163 (h0 : not (ring to_additive.value_type -> false)) : @rank_condition.{0} to_additive.value_type (@classical.by_contradiction'.{1} (ring.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_148164 (h0 : ring (measurable_space congr_arg_kind)) : is_domain (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_148165 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_pos_part.{0} (has_to_string.{0} linarith.comp)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} (has_to_string.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_148166 (h0 : functor.add_const (topological_space Type) Type) : @topological_space.separable_space.{1} Type (@functor.add_const.run.{1 1} (topological_space.{1} Type) Type h0)  := sorry --non-trivial
lemma new_lemma_148167 (h0 : finset (comm_group (normed_comm_ring Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_148168 (h0 : functor.add_const (ring (comm_group pos)) name) : @rank_condition.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_148169 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) pos) : @topological_space.separable_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_148170 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_148171 (h0 : functor.add_const (topological_space (comm_monoid empty)) empty) : @totally_separated_space.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_148172 (h0 : topological_space (has_add (ring linarith.comp))) : regular_space (has_add (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_148173 (h0 : ordered_comm_monoid (comm_group (has_add Type))) : has_exists_mul_of_le (comm_group (has_add Type)) := sorry --non-trivial
lemma new_lemma_148174 (h0 : filter Prop) : @id.{1} Prop (@Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@id.{1} (filter.{0} Prop) (@id.{1} (filter.{0} Prop) h0)))  := sorry --non-trivial
lemma new_lemma_148175 (h0 : not (function.extfun Type finset -> false)) : finset.nonempty (function.extfun_app (classical.by_contradiction' h0) (complete_linear_order empty)) := sorry --non-trivial
lemma new_lemma_148176 (h2 : uniform_space (encodable string_imp)) : complete_space (encodable string_imp) := sorry --non-trivial
lemma new_lemma_148177 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_148178 (h0 h1 : multiset (has_compl (mul_one_class (random_gen (mul_one_class char))))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_148179 (h0 : topological_space (has_union (has_top linarith.comp))) : t0_space (has_union (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_148180 (h0 : functor.add_const (monoid (has_Inf Type)) (has_neg (has_neg (has_neg (has_neg Type))))) : @monoid.fg.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 1} (monoid.{1} (has_Inf.{1} Type)) (has_neg.{1} (has_neg.{1} (has_neg.{1} (has_neg.{1} Type)))) h0)  := sorry --non-trivial
lemma new_lemma_148181 (h0 : topological_space (ordered_comm_monoid (has_add (has_nndist Type)))) : sequential_space (ordered_comm_monoid (has_add (has_nndist Type))) := sorry --non-trivial
lemma new_lemma_148182 (h0 : topological_space (sub_neg_monoid (has_neg pos))) : normal_space (sub_neg_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_148183 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (ring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_148184 (h0 : fin has_zero.zero) : @normalizer_condition.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (group.{1} (ordered_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_148185 (h0 : topological_space (distrib reducibility_hints)) : t0_space (distrib reducibility_hints) := sorry --non-trivial
lemma new_lemma_148186 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_148187 (h0 : filter (has_add (has_Inf linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_148188 (h1 : uniform_space (complete_semilattice_Sup char)) : complete_space (complete_semilattice_Sup char) := sorry --non-trivial
lemma new_lemma_148189 (h0 : functor.add_const (functor.add_const (finset (has_neg linarith.comp)) unsigned) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_148190 (h0 : topological_space (has_norm (has_norm (semiring empty)))) : normal_space (has_norm (has_norm (semiring empty))) := sorry --non-trivial
lemma new_lemma_148191 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_148192 (h0 : functor.add_const (topological_space (ring name)) (has_Inf name)) : @totally_separated_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) (has_Inf.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_148193 (h0 : ordered_comm_monoid (generalized_boolean_algebra (has_add (has_add (has_add pos))))) : has_exists_mul_of_le (generalized_boolean_algebra (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_148194 (h0 : list (boolean_algebra (finset (boolean_algebra (has_add (has_add linarith.comp)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_148195 (h0 : group (ordered_comm_monoid (has_add pos))) : group.fg (ordered_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_148196 (h0 : group (boolean_algebra (add_comm_monoid Type))) : normalizer_condition (boolean_algebra (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_148197 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @sequential_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_148198 (h0 : topological_space (has_neg_part (ring pos))) : path_connected_space (has_neg_part (ring pos)) := sorry --non-trivial
lemma new_lemma_148199 (h0 : topological_space (id (has_norm (has_norm linarith.comp)))) : irreducible_space (id (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_148200 (h0 : ring (ordered_comm_ring (semi_normed_ring (random_gen string_imp)))) : strong_rank_condition (ordered_comm_ring (semi_normed_ring (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_148201 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) name) : @t1_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_148202 (h0 : add_group (has_norm (has_norm empty))) : is_add_cyclic (has_norm (has_norm empty)) := sorry --non-trivial
lemma new_lemma_148203 (h0 : functor.add_const (topological_space (partial_order congr_arg_kind)) congr_arg_kind) : @locally_compact_space.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_148204 (h1 : group (has_nnnorm string_imp)) : group.fg (has_nnnorm string_imp) := sorry --non-trivial
lemma new_lemma_148205 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @topological_space.separable_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_148206 (h0 : filter (canonically_ordered_comm_semiring environment.implicit_infer_kind)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_148207 (h0 : functor.add_const (topological_space (is_R_or_C unsigned)) empty) : @irreducible_space.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_148208 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_148209 (h0 : functor.comp topological_space add_comm_monoid name) : @t1_space.{0} (add_comm_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_148210 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @irreducible_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_148211 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_148212 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} linarith.ineq (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) linarith.ineq)  := sorry --non-trivial
lemma new_lemma_148213 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @t0_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_148214 (h0 : complete_lattice (normed_group (has_norm congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (normed_group (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_148215 (h0 : topological_space (distrib (mul_one_class ereal))) : t0_space (distrib (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_148216 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_cyclic.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (normed_lattice_add_comm_group.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_148217 (h0 : topological_space (sub_neg_monoid (has_Inf (has_neg Type)))) : path_connected_space (sub_neg_monoid (has_Inf (has_neg Type))) := sorry --non-trivial
lemma new_lemma_148218 (h0 : topological_space (normed_comm_ring (has_zero (comm_group name)))) : totally_separated_space (normed_comm_ring (has_zero (comm_group name))) := sorry --non-trivial
lemma new_lemma_148219 (h1 : add_group (dlist (add_monoid (add_left_cancel_monoid (fintype linarith.ineq))))) : is_add_cyclic (dlist (add_monoid (add_left_cancel_monoid (fintype linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_148220 (h0 : group (has_nnnorm (random_gen reducibility_hints))) : is_cyclic (has_nnnorm (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_148221 (h0 : topological_space (has_top unsigned)) : discrete_topology (has_top unsigned) := sorry --non-trivial
lemma new_lemma_148222 (h0 : functor.add_const (ring (ordered_comm_ring Type)) pos) : @is_principal_ideal_ring.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (ordered_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_148223 (h0 : group (add_group empty)) : normalizer_condition (add_group empty) := sorry --non-trivial
lemma new_lemma_148224 (h0 : semiring (normed_field char)) (h1 : ideal (normed_field char)) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_148225 (h0 h1 : multiset (non_unital_non_assoc_semiring (mul_one_class to_additive.value_type))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_148226 (h0 : topological_space (comm_group (option ennreal))) : topological_space.separable_space (comm_group (option ennreal)) := sorry --non-trivial
lemma new_lemma_148227 (h0 : topological_space (has_Inf (has_Inf pos))) : topological_space.separable_space (has_Inf (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_148228 (h0 : topological_space (has_Inf (sub_neg_monoid Type))) : normal_space (has_Inf (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_148229 (h0 : monoid (has_one (has_norm empty))) : monoid.fg (has_one (has_norm empty)) := sorry --non-trivial
lemma new_lemma_148230 (h0 : ring (has_ssubset (random_gen to_additive.value_type))) : rank_condition (has_ssubset (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_148231 (h0 : group (comm_group (has_nndist Type))) : is_simple_group (comm_group (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_148232 (h0 : not (ring (linear_ordered_comm_ring empty) -> false)) : @strong_rank_condition.{0} (linear_ordered_comm_ring.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_comm_ring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_148233 (h0 : has_le (has_nndist (add_comm_monoid (has_neg_part name)))) (h1 : has_nndist (add_comm_monoid (has_neg_part name))) : is_top h1 := sorry --non-trivial
lemma new_lemma_148234 (h0 : Prop) (h1 : not (punit -> false)) : category_theory.hom_of_element h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_148235 (h0 : topological_space (with_one (has_inv (has_top (has_top (random_gen linarith.comp_source)))))) : totally_separated_space (with_one (has_inv (has_top (has_top (random_gen linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_148236 (h0 : functor.add_const (topological_space (has_Inf pos)) (ring pos)) : @discrete_topology.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_148237 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_148238 (h0 : function.extfun Type group) : @normalizer_condition.{0} (cancel_monoid.{0} (option.{0} (option.{0} ennreal))) (@function.extfun_app.{2 1} Type group.{0} h0 (cancel_monoid.{0} (option.{0} (option.{0} ennreal))))  := sorry --non-trivial
lemma new_lemma_148239 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem monoid)) : @monoid.fg.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) monoid.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_148240 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_148241 (h0 : functor.add_const (ring (comm_group pos)) Type) : @strong_rank_condition.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (comm_group.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_148242 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_148243 (h0 : linarith.comp_source -> Prop) : Exists h0 := sorry --non-trivial
lemma new_lemma_148244 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (semigroup.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_148245 (h0 : ordered_comm_monoid (simple_graph (boolean_algebra.core Type))) : has_exists_mul_of_le (simple_graph (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_148246 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_148247 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @irreducible_space.{0} (has_one.{0} (with_one.{0} empty)) (@matrix.vec_empty.{0} (topological_space.{0} (has_one.{0} (with_one.{0} empty))) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_148248 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (option.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (option.{0} num))  := sorry --non-trivial
lemma new_lemma_148249 (h0 : add_group (with_zero (has_append char))) : is_add_cyclic (with_zero (has_append char)) := sorry --non-trivial
lemma new_lemma_148250 (h0 : topological_space (semigroup (has_zero environment.implicit_infer_kind))) : sequential_space (semigroup (has_zero environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_148251 (h0 : functor.add_const (topological_space (has_nndist unsigned)) pos) : @totally_separated_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_148252 (h0 : group (comm_group (has_nndist Type))) : group.fg (comm_group (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_148253 (h0 : not (monoid (add_right_cancel_monoid congr_arg_kind) -> false)) : @monoid.fg.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (monoid.{0} (add_right_cancel_monoid.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_148254 (h0 : functor.add_const Prop (add_group linarith.comp)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_148255 (h0 : cancel_comm_monoid_with_zero (complete_semilattice_Sup (semiring num))) : unique_factorization_monoid (complete_semilattice_Sup (semiring num)) := sorry --non-trivial
lemma new_lemma_148256 (h0 : topological_space (semigroup empty)) : normal_space (semigroup empty) := sorry --non-trivial
lemma new_lemma_148257 (h0 : topological_space (normed_lattice_add_comm_group (has_add real))) : locally_compact_space (normed_lattice_add_comm_group (has_add real)) := sorry --non-trivial
lemma new_lemma_148258 (h0 : monoid (complete_linear_order (semiring unsigned))) : monoid.fg (complete_linear_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_148259 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_148260 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_148261 (h1 : enat -> char) (h2 : char -> enat) : function.right_inverse h1 h2 := sorry --non-trivial
lemma new_lemma_148262 (h0 : list (boolean_algebra (has_add unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_148263 (h1 : topological_space (has_le ereal)) : path_connected_space (has_le ereal) := sorry --non-trivial
lemma new_lemma_148264 (h0 : ring (finset (has_pos_part Type))) : strong_rank_condition (finset (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_148265 (h0 : topological_space (has_nnnorm ereal)) (h1 : set (has_nnnorm ereal)) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_148266 (h0 : functor.add_const (ring (cancel_monoid pos)) pos) : @strong_rank_condition.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_148267 (h0 : not (has_mem.mem ring has_emptyc.emptyc -> false)) : @strong_rank_condition.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_148268 (h0 : not (group (measurable_space.dynkin_system empty) -> false)) : @is_cyclic.{0} (measurable_space.dynkin_system.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (measurable_space.dynkin_system.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_148269 (h0 : topological_space to_additive.value_type) : discrete_topology to_additive.value_type := sorry --non-trivial
lemma new_lemma_148270 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} fun_info (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) fun_info)  := sorry --non-trivial
lemma new_lemma_148271 (h0 : function.extfun (Type 1) ring) : @rank_condition.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_148272 (h0 : functor.add_const (topological_space (add_cancel_monoid empty)) empty) : @t1_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_148273 (h0 : group (linear_ordered_field ennreal)) : is_cyclic (linear_ordered_field ennreal) := sorry --non-trivial
lemma new_lemma_148274 (h0 : functor.add_const (group (canonically_ordered_comm_semiring ennreal)) name) : @group.fg.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_comm_semiring.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_148275 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_148276 (h0 : function.extfun Type topological_space) : @normal_space.{0} (ordered_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_148277 (h0 : functor.add_const (add_monoid (complete_distrib_lattice pos)) name) : @add_monoid.fg.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (complete_distrib_lattice.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_148278 (h0 : ordered_add_comm_monoid (add_cancel_monoid (option (option (option (option unsigned)))))) : archimedean (add_cancel_monoid (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_148279 (h0 : topological_space (comm_ring (complete_semilattice_Sup (denumerable string_imp)))) : locally_compact_space (comm_ring (complete_semilattice_Sup (denumerable string_imp))) := sorry --non-trivial
lemma new_lemma_148280 (h0 : topological_space (pseudo_metric_space ennreal)) : totally_separated_space (pseudo_metric_space ennreal) := sorry --non-trivial
lemma new_lemma_148281 (h0 : prod string_imp string_imp) : set.diagonal string_imp h0 := sorry --non-trivial
lemma new_lemma_148282 (h0 : functor.add_const Prop (has_norm (has_norm (has_norm unsigned)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_148283 (h0 : topological_space (has_one (has_top fun_info))) : preirreducible_space (has_one (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_148284 (h0 : functor.add_const (topological_space (measure_theory.measure_space empty)) empty) : @irreducible_space.{0} (measure_theory.measure_space.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (measure_theory.measure_space.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_148285 (h0 : topological_space (linear_ordered_add_comm_group (has_top (has_top (has_top linarith.comp_source))))) : irreducible_space (linear_ordered_add_comm_group (has_top (has_top (has_top linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_148286 (h0 : function.extfun (Type 1) monoid) : @monoid.fg.{1} (plift.{1} num) (@function.extfun_app.{3 2} (Type 1) monoid.{1} h0 (plift.{1} num))  := sorry --non-trivial
lemma new_lemma_148287 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_148288 (h0 : functor.add_const (topological_space (has_zero pos)) (finset Type)) : @totally_disconnected_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} pos)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_148289 (h0 : not (ring (with_bot (random_gen num)) -> false)) : @strong_rank_condition.{0} (with_bot.{0} (random_gen.{0} num)) (@classical.by_contradiction'.{1} (ring.{0} (with_bot.{0} (random_gen.{0} num))) h0)  := sorry --non-trivial
lemma new_lemma_148290 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (add_cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_148291 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (complete_distrib_lattice name)) := sorry --non-trivial
lemma new_lemma_148292 (h0 : group (denumerable string_imp)) : is_cyclic (denumerable string_imp) := sorry --non-trivial
lemma new_lemma_148293 (h2 : ring (has_top char)) : is_domain (has_top char) := sorry --non-trivial
lemma new_lemma_148294 (h0 : functor.add_const (topological_space (monoid congr_arg_kind)) congr_arg_kind) : @normal_space.{0} (monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_148295 (h0 : topological_space (sub_neg_monoid (ordered_comm_monoid Type))) : t1_space (sub_neg_monoid (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_148296 (h1 : topological_space (has_compl linarith.ineq)) : totally_disconnected_space (has_compl linarith.ineq) := sorry --non-trivial
lemma new_lemma_148297 (h0 : functor.add_const (topological_space (boolean_algebra name)) Type) : @loc_path_connected_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_148298 (h0 : not (complete_lattice (with_one linarith.comp_source) -> false)) : @is_atomistic.{0} (with_one.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_one.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_148299 (h0 : list (monoid unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_148300 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) Type) : @sequential_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_148301 (h0 : group (ordered_cancel_add_comm_monoid (option (option (option (option ennreal)))))) : normalizer_condition (ordered_cancel_add_comm_monoid (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_148302 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf name))) : normal_space (canonically_linear_ordered_monoid (has_Inf name)) := sorry --non-trivial
lemma new_lemma_148303 (h1 : ring (has_norm congr_arg_kind)) : strong_rank_condition (has_norm congr_arg_kind) := sorry --non-trivial
lemma new_lemma_148304 (h0 : functor.add_const (function.extfun (Type 1) group) pos) : @group.fg.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) pos h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_148305 (h0 : function.extfun (Type 1) topological_space) : @path_connected_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_148306 (h0 : not (has_mem.mem (has_norm fun_info) has_emptyc.emptyc -> false)) : @is_domain.{0} (has_norm.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (has_norm.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_148307 (h0 : ring (linear_ordered_semiring (semiring linarith.comp))) : is_principal_ideal_ring (linear_ordered_semiring (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_148308 (h0 : complete_lattice (measurable_space (with_bot (with_bot to_additive.value_type)))) : is_atomistic (measurable_space (with_bot (with_bot to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_148309 (h0 : semiring (has_neg (finset (has_neg Type)))) : is_noetherian_ring (has_neg (finset (has_neg Type))) := sorry --non-trivial
lemma new_lemma_148310 (h0 : functor.add_const (topological_space (mul_zero_class Type)) Type) : @t1_space.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (mul_zero_class.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_148311 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_148312 (h0 : functor.add_const (topological_space (add_cancel_comm_monoid empty)) empty) : @totally_separated_space.{0} (add_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_148313 (h0 : ring (linear_ordered_semiring unsigned)) : is_principal_ideal_ring (linear_ordered_semiring unsigned) := sorry --non-trivial
lemma new_lemma_148314 (h0 : functor.add_const (topological_space (boolean_algebra Type)) Type) : @sequential_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_148315 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_148316 (h0 : filter (canonically_ordered_add_monoid unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_148317 (h0 : functor.add_const (add_monoid (bin_tree congr_arg_kind)) congr_arg_kind) : @add_monoid.fg.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (bin_tree.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_148318 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_Sup.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_148319 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (sub_neg_monoid.{0} (has_neg.{0} pos)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} (has_neg.{0} pos)))  := sorry --non-trivial
lemma new_lemma_148320 (h0 : functor.add_const (functor.comp ring has_add name) unsigned) : @is_principal_ideal_ring.{0} (has_add.{0} name) (@functor.comp.run.{0 0 0} ring.{0} has_add.{0} name (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} ring.{0} has_add.{0} name) unsigned h0))  := sorry --non-trivial
lemma new_lemma_148321 (h0 : topological_space (generalized_boolean_algebra (has_Inf Type))) : t0_space (generalized_boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_148322 (h0 : functor.add_const (ring (linear_ordered_comm_ring congr_arg_kind)) congr_arg_kind) : @strong_rank_condition.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (linear_ordered_comm_ring.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_148323 (h1 : group (has_ssubset (random_gen (random_gen char)))) : is_cyclic (has_ssubset (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_148324 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) environment.implicit_infer_kind) : @discrete_topology.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_148325 (h0 : fin has_zero.zero) : @is_cyclic.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) h0) (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_148326 (h0 : function.extfun Type (functor.comp filter linear_ordered_field)) : filter.ne_bot (functor.comp.run (function.extfun_app h0 pos)) := sorry --non-trivial
lemma new_lemma_148327 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @totally_separated_space.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) num)  := sorry --non-trivial
lemma new_lemma_148328 (h0 : topological_space (mul_zero_class name)) : preconnected_space (mul_zero_class name) := sorry --non-trivial
lemma new_lemma_148329 (h0 : topological_space (boolean_algebra (has_neg_part (comm_group Type)))) : loc_path_connected_space (boolean_algebra (has_neg_part (comm_group Type))) := sorry --non-trivial
lemma new_lemma_148330 (h1 : measurable_space (normed_field reducibility_hints)) (h2 : filter (normed_field reducibility_hints)) : filter.is_measurably_generated h2 := sorry --non-trivial
lemma new_lemma_148331 (h0 : finset (ordered_comm_ring (ordered_comm_ring linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_148332 (h0 : list (with_bot (has_inv (has_top fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_148333 (h0 : uniform_space (has_compl linarith.ineq)) : complete_space (has_compl linarith.ineq) := sorry --non-trivial
lemma new_lemma_148334 (h0 : uniform_space (has_to_string unsigned)) : separated_space (has_to_string unsigned) := sorry --non-trivial
lemma new_lemma_148335 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_modular_lattice.{0} (denumerable.{0} fun_info) (@function.extfun_app.{2 1} Type lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 lattice.{0}) (denumerable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_148336 (h0 : topological_space (canonically_ordered_comm_semiring Type)) : sequential_space (canonically_ordered_comm_semiring Type) := sorry --non-trivial
lemma new_lemma_148337 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_148338 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (filter.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (filter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_148339 (h0 : monoid (linear_ordered_semiring (random_gen (random_gen (random_gen linarith.comp_source))))) : monoid.fg (linear_ordered_semiring (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_148340 (h0 : function.extfun Type group) : @is_cyclic.{0} (dlist.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (dlist.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_148341 (h0 : topological_space (has_emptyc (has_norm linarith.comp_source))) : totally_separated_space (has_emptyc (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_148342 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_148343 (h0 : fin has_zero.zero) : @regular_space.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_148344 (h0 : functor.add_const (add_group (comm_group linarith.comp)) name) : @is_add_cyclic.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (comm_group.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_148345 (h0 : ring (has_emptyc (has_norm (has_top (random_gen congr_arg_kind))))) : rank_condition (has_emptyc (has_norm (has_top (random_gen congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_148346 (h0 : functor.add_const (semiring (normed_comm_ring pos)) (has_neg pos)) : @is_noetherian_ring.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (normed_comm_ring.{0} pos)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_148347 (h0 : list (monoid_with_zero (option (option pos)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_148348 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) Type) : @irreducible_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_148349 (h0 : complete_lattice (complete_semilattice_Sup (semiring empty))) : complete_lattice.is_Sup_finite_compact (complete_semilattice_Sup (semiring empty)) := sorry --non-trivial
lemma new_lemma_148350 (h0 : function.extfun Type ring) : @rank_condition.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_148351 (h0 : uniform_space (add_cancel_monoid (add_comm_monoid (has_add Type)))) : separated_space (add_cancel_monoid (add_comm_monoid (has_add Type))) := sorry --non-trivial
lemma new_lemma_148352 (h0 : has_mem.mem (with_one empty) has_emptyc.emptyc) : @add_monoid.fg.{0} (with_one.{0} empty) (@finset.pi.empty.{1 0} Type add_monoid.{0} (with_one.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_148353 (h0 : topological_space (metric_space (semiring (semiring unsigned)))) : topological_space.separable_space (metric_space (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_148354 (h0 : functor.add_const (monoid (has_add pos)) linarith.comp) : @monoid.fg.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (has_add.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_148355 (h0 : topological_space (has_add (has_neg (has_neg pos)))) : t1_space (has_add (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_148356 (h0 : topological_space (has_to_string (comm_group pos))) : irreducible_space (has_to_string (comm_group pos)) := sorry --non-trivial
lemma new_lemma_148357 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (pseudo_metric_space ennreal)) := sorry --non-trivial
lemma new_lemma_148358 (h0 : ring (finset empty)) : strong_rank_condition (finset empty) := sorry --non-trivial
lemma new_lemma_148359 (h0 : uniform_space (with_one (semiring (metric_space linarith.comp)))) : separated_space (with_one (semiring (metric_space linarith.comp))) := sorry --non-trivial
lemma new_lemma_148360 (h0 : filter (canonically_ordered_comm_semiring (has_add Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_148361 (h0 : ordered_comm_monoid (mul_zero_class (cancel_monoid (ring Type)))) : has_exists_mul_of_le (mul_zero_class (cancel_monoid (ring Type))) := sorry --non-trivial
lemma new_lemma_148362 (h0 : semiring (measure_theory.measure_space empty)) : is_noetherian_ring (measure_theory.measure_space empty) := sorry --non-trivial
lemma new_lemma_148363 (h0 : functor.add_const (add_group (boolean_algebra.core pos)) rat) : @is_add_cyclic.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (boolean_algebra.core.{0} pos)) rat h0)  := sorry --non-trivial
lemma new_lemma_148364 (h0 : functor.add_const (topological_space nnreal) unsigned) : normal_space nnreal := sorry --non-trivial
lemma new_lemma_148365 (h0 : functor.add_const (add_monoid (simple_graph pos)) Type) : @add_monoid.fg.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 1} (add_monoid.{0} (simple_graph.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_148366 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_148367 (h0 : list (has_norm linarith.ineq)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_148368 (h0 : group (has_inv (has_nnnorm linarith.ineq))) : group.fg (has_inv (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_148369 (h0 : functor.add_const (complete_lattice (linear_ordered_field ennreal)) Type) : @is_atomistic.{0} (linear_ordered_field.{0} ennreal) (@functor.add_const.run.{0 1} (complete_lattice.{0} (linear_ordered_field.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_148370 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_148371 (h0 : ring (distrib_lattice (comm_ring (comm_ring (has_inv fun_info))))) : is_domain (distrib_lattice (comm_ring (comm_ring (has_inv fun_info)))) := sorry --non-trivial
lemma new_lemma_148372 (h0 : functor.add_const (topological_space (simple_graph pos)) (has_add Type)) : @discrete_topology.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (simple_graph.{0} pos)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_148373 (h2 : ring (has_nnnorm (has_ssubset (has_ssubset fun_info)))) : is_domain (has_nnnorm (has_ssubset (has_ssubset fun_info))) := sorry --non-trivial
lemma new_lemma_148374 (h0 : has_mem.mem (with_bot linarith.comp_source) has_zero.zero) (h1 : add_monoid (with_bot linarith.comp_source)) : @has_lipschitz_add.{0} (with_bot.{0} linarith.comp_source) (@multiset.pi.empty.{1 0} Type pseudo_metric_space.{0} (with_bot.{0} linarith.comp_source) h0) h1  := sorry --non-trivial
lemma new_lemma_148375 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_148376 (h0 : topological_space (has_zero (has_to_string environment.implicit_infer_kind))) : t0_space (has_zero (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_148377 (h0 : functor.add_const (group (complete_distrib_lattice Type)) pos) : @is_cyclic.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (complete_distrib_lattice.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_148378 (h1 : ring (with_zero (random_gen (random_gen (has_ssubset string_imp))))) : rank_condition (with_zero (random_gen (random_gen (has_ssubset string_imp)))) := sorry --non-trivial
lemma new_lemma_148379 (h0 : topological_space (metric_space linarith.comp)) : totally_disconnected_space (metric_space linarith.comp) := sorry --non-trivial
lemma new_lemma_148380 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} h0 (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_148381 (h0 : ring (has_ssubset (has_nnnorm fun_info))) : strong_rank_condition (has_ssubset (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_148382 (h0 : functor.add_const (ring (linear_order num)) empty) : @is_principal_ideal_ring.{0} (linear_order.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (linear_order.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_148383 (h0 : topological_space (add_cancel_monoid (comm_group name))) : preirreducible_space (add_cancel_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_148384 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @irreducible_space.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_148385 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_148386 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ring pos)) pos) : @unique_factorization_monoid.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_148387 (h0 : not (has_mem.mem (has_norm (has_top linarith.comp_source)) has_emptyc.emptyc -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} (has_top.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_norm.{0} (has_top.{0} linarith.comp_source)) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} (has_top.{0} linarith.comp_source)) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_148388 (h0 : list (linear_ordered_add_comm_group (has_nnnorm (random_gen (has_norm to_additive.value_type))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_148389 (h0 : function.extfun Type group) : @group.fg.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_148390 (h0 : not (ring (has_top fun_info) -> false)) : @is_domain.{0} (has_top.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (has_top.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_148391 (h0 : function.extfun Type (functor.comp topological_space finset)) : @topological_space.separable_space.{0} (finset.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} finset.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_148392 (h0 : ordered_add_comm_monoid (has_bot num)) : archimedean (has_bot num) := sorry --non-trivial
lemma new_lemma_148393 (h0 : functor.add_const (ring nnreal) unsigned) : @is_principal_ideal_ring.{0} nnreal (@functor.add_const.run.{0 0} (ring.{0} nnreal) unsigned h0)  := sorry --non-trivial
lemma new_lemma_148394 (h3 : ring (distrib string_imp)) : is_domain (distrib string_imp) := sorry --non-trivial
lemma new_lemma_148395 (h0 : complete_lattice (canonically_ordered_comm_semiring linarith.comp)) : is_atomistic (canonically_ordered_comm_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_148396 (h0 : topological_space (has_add (has_to_string congr_arg_kind))) : totally_disconnected_space (has_add (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_148397 (h0 : topological_space (measurable_space.dynkin_system num)) : totally_separated_space (measurable_space.dynkin_system num) := sorry --non-trivial
lemma new_lemma_148398 (h0 : functor.add_const (group (finset unsigned)) pos) : @group.fg.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_148399 (h0 : function.extfun (finset (Type -> Type) -> Prop) (function.extfun (finset (Type -> Type)))) : @path_connected_space.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) (@function.extfun_app.{2 0} (finset.{1} (Type → Type) → Prop) (function.extfun.{2 0} (finset.{1} (Type → Type))) h0 (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0})) (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_148400 (h0 : functor.add_const (group (boolean_algebra name)) Type) : @group.fg.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (group.{0} (boolean_algebra.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_148401 (h0 : functor.add_const (cancel_comm_monoid_with_zero (is_R_or_C unsigned)) empty) : @unique_factorization_monoid.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (is_R_or_C.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_148402 (h0 : filter (add_cancel_monoid (has_add linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_148403 (h0 : not (add_group (topological_space linarith.ineq) -> false)) : @is_add_cyclic.{0} (topological_space.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (topological_space.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_148404 (h0 : not (filter (non_assoc_semiring empty) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_148405 (h0 : ordered_comm_monoid (has_Inf (has_neg (add_cancel_monoid name)))) : has_exists_mul_of_le (has_Inf (has_neg (add_cancel_monoid name))) := sorry --non-trivial
lemma new_lemma_148406 (h0 : functor.add_const (topological_space (has_neg_part Type)) environment.implicit_infer_kind) : @preconnected_space.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg_part.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_148407 (h0 : uniform_space (has_ssubset (has_lt linarith.comp_source))) : complete_space (has_ssubset (has_lt linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_148408 (h0 : not (function.extfun (finset Type) (has_mem.mem congr_arg_kind) -> false)) : @strong_rank_condition.{0} congr_arg_kind (@finset.pi.empty.{1 0} Type ring.{0} congr_arg_kind (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) congr_arg_kind) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) congr_arg_kind)) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_148409 (h0 : fin has_zero.zero) : @is_domain.{1} (has_nndist.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (has_nndist.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_148410 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) pos) : @preconnected_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_148411 (h0 : ring (has_nndist (has_nndist (ring linarith.comp)))) : is_domain (has_nndist (has_nndist (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_148412 (h0 : functor.add_const (ring (ordered_comm_ring pos)) name) : @rank_condition.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_148413 (h0 : not (ring (comm_ring char) -> false)) : @rank_condition.{0} (comm_ring.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (comm_ring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_148414 (h0 : group (pseudo_metric_space (has_to_string congr_arg_kind))) : is_cyclic (pseudo_metric_space (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_148415 (h0 : add_monoid (finset (mul_zero_class name))) : add_monoid.fg (finset (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_148416 (h0 : functor.add_const (function.extfun Type topological_space) (ring Type)) : @totally_separated_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (ring.{1} Type) h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_148417 (h0 : topological_space (has_nndist (boolean_algebra (ring (cancel_monoid (finset (cancel_monoid name))))))) : t0_space (has_nndist (boolean_algebra (ring (cancel_monoid (finset (cancel_monoid name)))))) := sorry --non-trivial
lemma new_lemma_148418 (h0 : group (cancel_monoid (finset (finset environment.implicit_infer_kind)))) : is_simple_group (cancel_monoid (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_148419 (h1 h2 : multiset (non_unital_non_assoc_semiring reducibility_hints)) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_148420 (h0 : semiring (option congr_arg_kind)) (h1 : ideal (option congr_arg_kind)) : ideal.fg h1 := sorry --non-trivial
lemma new_lemma_148421 (h1 : add_group (simple_graph char)) : is_add_cyclic (simple_graph char) := sorry --non-trivial
lemma new_lemma_148422 (h4 : topological_space ereal) : t0_space ereal := sorry --non-trivial
lemma new_lemma_148423 (h0 : complete_lattice (linear_ordered_comm_group (option (option unsigned)))) : is_compactly_generated (linear_ordered_comm_group (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_148424 (h0 : topological_space (sub_neg_monoid (finset pos))) : discrete_topology (sub_neg_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_148425 (h0 : topological_space (has_one empty)) : totally_disconnected_space (has_one empty) := sorry --non-trivial
lemma new_lemma_148426 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) Type) : @preconnected_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_148427 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (simple_graph.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (simple_graph.{0} empty))  := sorry --non-trivial
lemma new_lemma_148428 (h0 : functor.add_const (list (cancel_monoid name)) (has_add pos)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_148429 (h0 : functor.add_const (function.extfun Type topological_space) real) : @preirreducible_space.{0} (comm_semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) real h0) (comm_semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_148430 (h1 : group linarith.ineq) : is_cyclic linarith.ineq := sorry --non-trivial
lemma new_lemma_148431 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_148432 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_star.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_star.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_148433 (h0 : functor.add_const (ring znum) unsigned) : @rank_condition.{0} znum (@functor.add_const.run.{0 0} (ring.{0} znum) unsigned h0)  := sorry --non-trivial
lemma new_lemma_148434 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @totally_disconnected_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_148435 (h0 : functor.add_const (topological_space (left_cancel_monoid unsigned)) (semiring empty)) : @totally_disconnected_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_148436 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_148437 (h0 : add_monoid (finset (has_to_string (has_to_string pos)))) : add_monoid.fg (finset (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_148438 (h0 : function.extfun (Type 1) add_group) : @is_add_cyclic.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} h0 (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_148439 (h0 : group (topological_space (random_gen fun_info))) : group.fg (topological_space (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_148440 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) environment.implicit_infer_kind) : @path_connected_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_148441 (h0 : topological_space (semiring (has_top (has_top fun_info)))) : locally_compact_space (semiring (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_148442 (h0 : functor.add_const (topological_space (add_group congr_arg_kind)) congr_arg_kind) : @totally_disconnected_space.{0} (add_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_148443 (h1 : ring linarith.ineq) : rank_condition linarith.ineq := sorry --non-trivial
lemma new_lemma_148444 (h0 : functor.add_const (topological_space (has_nndist name)) name) : @totally_disconnected_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_148445 (h0 : functor.add_const (topological_space (as_linear_order unsigned)) num) : @t0_space.{0} (as_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (as_linear_order.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_148446 (h0 : topological_space (linear_ordered_comm_monoid_with_zero empty)) : locally_compact_space (linear_ordered_comm_monoid_with_zero empty) := sorry --non-trivial
lemma new_lemma_148447 (h0 : ring (semiring (has_norm num))) : is_domain (semiring (has_norm num)) := sorry --non-trivial
lemma new_lemma_148448 (h0 : ring (measure_theory.measure_space (semiring (semiring empty)))) : is_principal_ideal_ring (measure_theory.measure_space (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_148449 (h0 : function.extfun Type (functor.add_const (filter znum))) : countable_Inter_filter (functor.add_const.run (function.extfun_app h0 unsigned)) := sorry --non-trivial
lemma new_lemma_148450 (h0 : topological_space (has_Inf (has_pos_part (has_add (has_pos_part (has_add linarith.comp)))))) : sequential_space (has_Inf (has_pos_part (has_add (has_pos_part (has_add linarith.comp))))) := sorry --non-trivial
lemma new_lemma_148451 (h0 : topological_space (boolean_algebra (comm_group (comm_group Type)))) : preirreducible_space (boolean_algebra (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_148452 (h0 : filter (comm_group (has_add pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_148453 (h0 : list (boolean_algebra environment.implicit_infer_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_148454 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @discrete_topology.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_148455 (h0 : topological_space (linear_ordered_field pos)) : regular_space (linear_ordered_field pos) := sorry --non-trivial
lemma new_lemma_148456 (h0 : ring (complete_semilattice_Sup linarith.comp)) : strong_rank_condition (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_148457 (h0 : function.extfun Type topological_space) : @t0_space.{0} (topological_space.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (topological_space.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_148458 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @group.fg.{1} Type (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) Type)  := sorry --non-trivial
lemma new_lemma_148459 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_148460 (h0 : functor.add_const (ring (semigroup linarith.comp)) environment.implicit_infer_kind) : @is_domain.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_148461 (h0 : topological_space (distrib reducibility_hints)) : totally_disconnected_space (distrib reducibility_hints) := sorry --non-trivial
lemma new_lemma_148462 (h0 : semiring (sub_neg_monoid (finset linarith.comp))) : is_noetherian_ring (sub_neg_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_148463 (h0 : ultrafilter Prop) : @ultrafilter.Lim.{0} Prop sierpinski_space h0  := sorry --non-trivial
lemma new_lemma_148464 (h0 : monoid (measurable_space (has_norm linarith.ineq))) : monoid.fg (measurable_space (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_148465 (h0 : functor.add_const (ring (has_neg_part Type)) name) : @is_domain.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_neg_part.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_148466 (h0 : not (topological_space name -> false)) : @locally_compact_space.{0} name (@classical.by_contradiction'.{1} (topological_space.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_148467 (h0 : functor.add_const (ring (left_cancel_semigroup unsigned)) empty) : @strong_rank_condition.{0} (left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_148468 (h0 : complete_lattice (has_append (mul_one_class (mul_one_class char)))) : is_compactly_generated (has_append (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_148469 (h0 : complete_lattice (uniform_space char)) : complete_lattice.is_Sup_finite_compact (uniform_space char) := sorry --non-trivial
lemma new_lemma_148470 (h0 : group (normed_comm_ring (has_add (has_add (has_add Type))))) : is_simple_group (normed_comm_ring (has_add (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_148471 (h0 : set (set nat)) (h1 : set nat) : measurable_space.dynkin_system.generate_has h0 h1 := sorry --non-trivial
lemma new_lemma_148472 (h0 : complete_lattice (has_ssubset to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (has_ssubset to_additive.value_type) := sorry --non-trivial
lemma new_lemma_148473 (h0 : functor.comp topological_space has_nndist environment.implicit_infer_kind) : @totally_separated_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} environment.implicit_infer_kind h0)))))))))))))))))))))))))))))))))))))))))))))))))))))))))  := sorry --non-trivial
lemma new_lemma_148474 (h0 : complete_lattice (measurable_space (has_norm congr_arg_kind))) : is_compactly_generated (measurable_space (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_148475 (h0 : prod ennreal ennreal) : id_rel h0 := sorry --non-trivial
lemma new_lemma_148476 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_148477 (h0 : functor.add_const (topological_space (finset Type)) environment.implicit_infer_kind) : @totally_disconnected_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_148478 (h0 : function.extfun Type topological_space) : @normal_space.{0} (linear_ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_148479 (h0 : functor.add_const (group (linear_ordered_comm_monoid_with_zero empty)) congr_arg_kind) : @normalizer_condition.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_148480 (h0 : function.extfun Type ring) : @rank_condition.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_148481 (h0 : ring (normed_field (mul_one_class (mul_one_class char)))) : strong_rank_condition (normed_field (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_148482 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @topological_space.separable_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_148483 (h0 : topological_space (has_to_string (comm_group pos))) : preirreducible_space (has_to_string (comm_group pos)) := sorry --non-trivial
lemma new_lemma_148484 (h0 : complete_lattice (normed_group (has_top (has_top (has_top num))))) : is_atomistic (normed_group (has_top (has_top (has_top num)))) := sorry --non-trivial
lemma new_lemma_148485 (h0 : function.extfun (Type 1) group) : @group.fg.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_148486 (h0 : topological_space (linear_ordered_field (comm_group unsigned))) : t0_space (linear_ordered_field (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_148487 (h2 : topological_space (normed_field char)) : totally_disconnected_space (normed_field char) := sorry --non-trivial
lemma new_lemma_148488 (h0 : topological_space (complete_semilattice_Sup (has_top (has_top linarith.ineq)))) : irreducible_space (complete_semilattice_Sup (has_top (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_148489 (h0 : add_group (has_bot (has_add pos))) : is_add_cyclic (has_bot (has_add pos)) := sorry --non-trivial
lemma new_lemma_148490 (h0 : topological_space (normed_lattice_add_comm_group (has_bot real))) : regular_space (normed_lattice_add_comm_group (has_bot real)) := sorry --non-trivial
lemma new_lemma_148491 (h0 : not (has_mem.mem (linear_ordered_semiring num) has_emptyc.emptyc -> false)) : @irreducible_space.{0} (linear_ordered_semiring.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_148492 (h0 : functor.add_const (ordered_add_comm_monoid (add_semigroup empty)) empty) : @archimedean.{0} (add_semigroup.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_148493 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_148494 (h0 : functor.add_const (ordered_add_comm_monoid (has_nndist linarith.comp)) environment.implicit_infer_kind) : @archimedean.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_nndist.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_148495 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_148496 (h0 : functor.add_const (add_group (add_cancel_monoid pos)) pos) : @is_add_cyclic.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (add_cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_148497 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @add_monoid.fg.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_monoid.{1}) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_148498 (h2 : ring linarith.ineq) : strong_rank_condition linarith.ineq := sorry --non-trivial
lemma new_lemma_148499 (h0 : occurrences -> occurrences -> Prop) : is_total occurrences h0 := sorry --non-trivial
lemma new_lemma_148500 (h0 : functor.add_const (topological_space (has_zero pos)) Type) : @irreducible_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_148501 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_148502 (h1 : group (has_norm (random_gen string_imp))) : group.fg (has_norm (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_148503 (h0 : functor.add_const (functor.add_const (filter pos) pos) Type) : filter.ne_bot (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_148504 (h0 : filter (has_add (ring Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_148505 (h0 : uniform_space (has_nndist (has_neg pos))) : complete_space (has_nndist (has_neg pos)) := sorry --non-trivial
lemma new_lemma_148506 (h0 : functor.add_const (list (has_to_string pos)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_148507 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) environment.implicit_infer_kind) : @regular_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_148508 (h1 : group (has_one linarith.comp)) : group.fg (has_one linarith.comp) := sorry --non-trivial
lemma new_lemma_148509 (h0 : functor.add_const (finset (left_cancel_monoid num)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_148510 (h0 : filter (has_to_string (finset environment.implicit_infer_kind))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_148511 (h0 : topological_space (complete_distrib_lattice (has_Inf linarith.comp))) : loc_path_connected_space (complete_distrib_lattice (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_148512 (h0 : functor.add_const (topological_space (as_linear_order empty)) (option empty)) : @t0_space.{0} (as_linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (as_linear_order.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_148513 (h3 : ring (topological_space char)) : strong_rank_condition (topological_space char) := sorry --non-trivial
lemma new_lemma_148514 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_148515 (h0 : functor.add_const (topological_space (has_star num)) empty) : @preirreducible_space.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_148516 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (semigroup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_148517 (h0 : functor.add_const (ordered_add_comm_monoid (has_star unsigned)) empty) : @archimedean.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_star.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_148518 (h0 : has_mem.mem (has_top empty) has_emptyc.emptyc) : @irreducible_space.{0} (has_top.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_148519 (h0 : measurable_space (nondiscrete_normed_field char)) (h1 : filter (nondiscrete_normed_field char)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_148520 (h0 : add_monoid (non_assoc_semiring (semiring congr_arg_kind))) : add_monoid.fg (non_assoc_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_148521 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (finset.{0} linarith.comp) (@matrix.vec_empty.{0} (semiring.{0} (finset.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_148522 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (has_pos_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_148523 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_148524 (h0 : add_zero_class (normed_group string_imp)) (h1 : topological_space (encodable (has_ssubset (has_ssubset (add_submonoid (normed_group string_imp)))))) : t0_space (encodable (has_ssubset (has_ssubset (add_submonoid (normed_group string_imp))))) := sorry --non-trivial
lemma new_lemma_148525 (h0 : ring (has_bot linarith.comp)) : is_principal_ideal_ring (has_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_148526 (h0 : functor.add_const (topological_space (ordered_comm_monoid pos)) linarith.comp) : @discrete_topology.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_148527 (h0 : not (complete_lattice (option empty) -> false)) : @is_atomistic.{0} (option.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_148528 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_148529 (h0 : complete_lattice (monoid (option (option unsigned)))) : complete_lattice.is_Sup_finite_compact (monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_148530 (h0 : ring (uniform_space (has_lt string_imp))) : rank_condition (uniform_space (has_lt string_imp)) := sorry --non-trivial
lemma new_lemma_148531 (h1 : function.extfun Type add_group) : @is_add_cyclic.{0} fun_info (@function.extfun_app.{2 1} Type add_group.{0} h1 fun_info)  := sorry --non-trivial
lemma new_lemma_148532 (h0 : function.extfun Type ring) : @rank_condition.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_148533 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @topological_space.separable_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_148534 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_148535 (h0 : topological_space (has_Inf (has_neg (has_neg (has_neg name))))) : irreducible_space (has_Inf (has_neg (has_neg (has_neg name)))) := sorry --non-trivial
lemma new_lemma_148536 (h0 : cancel_comm_monoid_with_zero (linear_ordered_comm_monoid_with_zero (option unsigned))) : unique_factorization_monoid (linear_ordered_comm_monoid_with_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_148537 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_148538 (h0 : uniform_space (non_assoc_semiring empty)) : separated_space (non_assoc_semiring empty) := sorry --non-trivial
lemma new_lemma_148539 (h0 : functor.add_const (ring (left_cancel_semigroup unsigned)) empty) : @is_domain.{0} (left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_148540 (h0 : topological_space (has_bot (has_Inf Type))) : t0_space (has_bot (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_148541 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @path_connected_space.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_148542 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (normed_comm_ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_148543 (h0 : topological_space (with_one (has_norm to_additive.value_type))) : irreducible_space (with_one (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_148544 (h0 : function.extfun Type topological_space) : @normal_space.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_148545 (h0 : monoid (sub_neg_monoid (has_neg (has_neg (has_Inf (has_neg name)))))) : monoid.fg (sub_neg_monoid (has_neg (has_neg (has_Inf (has_neg name))))) := sorry --non-trivial
lemma new_lemma_148546 (h0 : monoid (has_neg (finset linarith.comp))) : monoid.fg (has_neg (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_148547 (h0 : functor.add_const (topological_space (comm_group Type)) name) : @sequential_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_148548 (h0 : function.extfun Type uniform_space) : @separated_space.{0} znum (@function.extfun_app.{2 1} Type uniform_space.{0} h0 znum)  := sorry --non-trivial
lemma new_lemma_148549 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (left_cancel_monoid.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_148550 (h0 : functor.add_const (function.extfun (Type 1) semiring) (finset pos)) : @is_noetherian_ring.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) semiring.{1}) (finset.{0} pos) h0) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_148551 (h0 : function.extfun Type ring) : @rank_condition.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_148552 (h0 : semiring (linear_order unsigned)) : is_noetherian_ring (linear_order unsigned) := sorry --non-trivial
lemma new_lemma_148553 (h3 : set (linarith.ineq -> std_gen)) : set.separates_points h3 := sorry --non-trivial
lemma new_lemma_148554 (h0 : fin has_zero.zero) : @path_connected_space.{0} pos (@matrix.vec_empty.{0} (topological_space.{0} pos) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))))  := sorry --non-trivial
lemma new_lemma_148555 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_148556 (h0 : list (has_neg_part pos)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_148557 (h0 : functor.add_const (functor.add_const (topological_space linarith.comp) Type) linarith.comp) : @preconnected_space.{0} linarith.comp (@functor.add_const.run.{0 1} (topological_space.{0} linarith.comp) Type (@functor.add_const.run.{0 0} (functor.add_const.{0 1} (topological_space.{0} linarith.comp) Type) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_148558 (h0 : topological_space (comm_group (comm_group pos))) : locally_compact_space (comm_group (comm_group pos)) := sorry --non-trivial
lemma new_lemma_148559 (h2 : function.extfun Type complete_lattice) : @is_atomistic.{0} linarith.comp_source (@function.extfun_app.{2 1} Type complete_lattice.{0} h2 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_148560 (h0 : cancel_comm_monoid_with_zero (complete_distrib_lattice (has_bot (has_add (has_Inf pos))))) : unique_factorization_monoid (complete_distrib_lattice (has_bot (has_add (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_148561 (h0 : group (left_cancel_monoid congr_arg_kind)) : normalizer_condition (left_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_148562 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} pos (@matrix.vec_empty.{0} (topological_space.{0} pos) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_148563 (h1 : topological_space (with_one fun_info)) : totally_disconnected_space (with_one fun_info) := sorry --non-trivial
lemma new_lemma_148564 (h1 h2 : multiset (normed_field fun_info)) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_148565 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (ordered_ring.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (ordered_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_148566 (h0 : functor.add_const (topological_space nnreal) num) : normal_space nnreal := sorry --non-trivial
lemma new_lemma_148567 (h0 : topological_space (normed_group congr_arg_kind)) : t0_space (normed_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_148568 (h0 : function.extfun nat fin) : @totally_separated_space.{0} (canonically_linear_ordered_add_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_linear_ordered_add_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_148569 (h1 : not (function.extfun Type group -> false)) : @group.fg.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h1) (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_148570 (h0 : functor.add_const (ordered_add_comm_monoid (has_pos_part Type)) pos) : @archimedean.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (has_pos_part.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_148571 (h1 : ring (has_div string_imp)) : is_domain (has_div string_imp) := sorry --non-trivial
lemma new_lemma_148572 (h1 : has_mem.mem (with_one num) has_emptyc.emptyc) : @irreducible_space.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} num) h1)  := sorry --non-trivial
lemma new_lemma_148573 (h0 : topological_space (add_comm_monoid (has_add name))) : loc_path_connected_space (add_comm_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_148574 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_148575 (h0 : topological_space (monoid_with_zero ennreal)) : loc_path_connected_space (monoid_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_148576 (h0 : not (topological_space (has_top congr_arg_kind) -> false)) : @t1_space.{0} (has_top.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_148577 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_add.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} num))  := sorry --non-trivial
lemma new_lemma_148578 (h0 : semiring (has_lt (option (option unsigned)))) : is_noetherian_ring (has_lt (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_148579 (h0 : ring (boolean_algebra (has_add Type))) : is_principal_ideal_ring (boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_148580 (h0 : topological_space (cancel_monoid (boolean_algebra name))) : t1_space (cancel_monoid (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_148581 (h0 : functor.add_const (list (add_comm_monoid unsigned)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_148582 (h0 : not (group (add_cancel_comm_monoid reducibility_hints) -> false)) : @is_cyclic.{0} (add_cancel_comm_monoid.{0} reducibility_hints) (@classical.by_contradiction'.{1} (group.{0} (add_cancel_comm_monoid.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_148583 (h0 : complete_lattice (add_comm_semigroup (mul_one_class ereal))) : complete_lattice.is_Sup_finite_compact (add_comm_semigroup (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_148584 (h0 : monoid (semiring (has_norm num))) : monoid.fg (semiring (has_norm num)) := sorry --non-trivial
lemma new_lemma_148585 (h0 : ordered_add_comm_monoid (group_with_zero (option congr_arg_kind))) : archimedean (group_with_zero (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_148586 (h0 : topological_space (mul_one_class (comm_group_with_zero fun_info))) : t0_space (mul_one_class (comm_group_with_zero fun_info)) := sorry --non-trivial
lemma new_lemma_148587 (h0 : has_mem.mem congr_arg_kind has_emptyc.emptyc) : @is_compactly_generated.{0} congr_arg_kind (@finset.pi.empty.{1 0} Type complete_lattice.{0} congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_148588 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_148589 (h0 : topological_space (has_zero (boolean_algebra Type))) : preconnected_space (has_zero (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_148590 (h0 : list (measure_theory.measure_space num)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_148591 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_separated_space.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_148592 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) linarith.comp) : @loc_path_connected_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_148593 (h0 : list (sub_neg_monoid (has_add (normed_lattice_add_comm_group real)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_148594 (h1 : group (denumerable (has_nnnorm string_imp))) : is_cyclic (denumerable (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_148595 (h0 : functor.add_const (topological_space pos) Type) : @normal_space.{0} pos (@functor.add_const.run.{0 1} (topological_space.{0} pos) Type h0)  := sorry --non-trivial
lemma new_lemma_148596 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_148597 (h0 : function.extfun Type (prod (complete_semilattice_Sup empty))) : id_rel (function.extfun_app h0 (complete_semilattice_Sup empty)) := sorry --non-trivial
lemma new_lemma_148598 (h0 : functor.add_const (complete_lattice (finset unsigned)) (option unsigned)) : @is_compactly_generated.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_148599 (h0 : group (has_Inf (has_neg (has_neg Type)))) : normalizer_condition (has_Inf (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_148600 (h0 : topological_space (semigroup num)) : t1_space (semigroup num) := sorry --non-trivial
lemma new_lemma_148601 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @sequential_space.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_148602 (h0 : ring (metric_space (has_norm unsigned))) : strong_rank_condition (metric_space (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_148603 (h0 : not (add_group (metric_space unsigned) -> false)) : @is_add_cyclic.{0} (metric_space.{0} unsigned) (@classical.by_contradiction'.{1} (add_group.{0} (metric_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_148604 (h0 : functor.add_const (complete_lattice (has_zero environment.implicit_infer_kind)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_zero.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_148605 (h0 : topological_space (has_nnnorm ereal)) : totally_disconnected_space (has_nnnorm ereal) := sorry --non-trivial
lemma new_lemma_148606 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} h0 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_148607 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) name) : @t0_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_148608 (h0 : functor.add_const (uniform_space (add_cancel_monoid name)) linarith.comp) : @complete_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_148609 (h0 : topological_space (has_Inf (finset (has_add linarith.comp)))) : preirreducible_space (has_Inf (finset (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_148610 (h0 : semiring (mul_one_class char)) (h1 : ideal (mul_one_class char)) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_148611 (h0 : fin has_zero.zero) : @path_connected_space.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_148612 (h0 : functor.comp topological_space canonically_ordered_comm_semiring environment.implicit_infer_kind) : @discrete_topology.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_148613 (h0 : topological_space (normed_linear_ordered_group congr_arg_kind)) : preirreducible_space (normed_linear_ordered_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_148614 (h0 : uniform_space (add_cancel_monoid (has_add linarith.comp))) : complete_space (add_cancel_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_148615 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_148616 (h0 : list (has_dist ennreal)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_148617 (h0 : not (topological_space (has_compl linarith.ineq) -> false)) : @totally_disconnected_space.{0} (has_compl.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_compl.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_148618 (h2 : topological_space (has_ssubset char)) : t0_space (has_ssubset char) := sorry --non-trivial
lemma new_lemma_148619 (h0 : ring (has_neg (finset Type))) : strong_rank_condition (has_neg (finset Type)) := sorry --non-trivial
lemma new_lemma_148620 (h0 : simple_graph std_gen) (h1 : std_gen) (h2 : sym2 std_gen) : simple_graph.incidence_set h0 h1 h2 := sorry --non-trivial
lemma new_lemma_148621 (h0 : ring (linear_order unsigned)) : rank_condition (linear_order unsigned) := sorry --non-trivial
lemma new_lemma_148622 (h0 : functor.add_const (ring (cancel_monoid pos)) name) : @rank_condition.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (cancel_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_148623 (h0 : functor.add_const (group (boolean_algebra Type)) environment.implicit_infer_kind) : @group.fg.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (boolean_algebra.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_148624 (h0 : ring (sub_neg_monoid (has_Inf real))) : is_domain (sub_neg_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_148625 (h0 : functor.add_const (group (ordered_comm_ring linarith.comp)) pos) : @is_cyclic.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (ordered_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_148626 (h0 : group (semiring (has_norm unsigned))) : normalizer_condition (semiring (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_148627 (h0 : function.extfun Type group) : @group.fg.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_148628 (h1 : uniform_space (div_inv_monoid to_additive.value_type)) : complete_space (div_inv_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_148629 (h0 : uniform_space (has_inter (option num))) : complete_space (has_inter (option num)) := sorry --non-trivial
lemma new_lemma_148630 (h0 : ring (dlist to_additive.value_type)) : is_domain (dlist to_additive.value_type) := sorry --non-trivial
lemma new_lemma_148631 (h0 : function.extfun Type group) : @normalizer_condition.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.dynkin_system.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_148632 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (semigroup.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_148633 (h0 : functor.add_const (list (cancel_monoid environment.implicit_infer_kind)) (boolean_algebra name)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_148634 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_148635 (h0 : ordered_comm_monoid (group_with_zero pos)) : has_exists_mul_of_le (group_with_zero pos) := sorry --non-trivial
lemma new_lemma_148636 (h0 : complete_lattice (mul_one_class reducibility_hints)) : complete_lattice.is_Sup_finite_compact (mul_one_class reducibility_hints) := sorry --non-trivial
lemma new_lemma_148637 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (semi_normed_comm_ring.{0} (has_nnnorm.{0} to_additive.value_type)) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (semi_normed_comm_ring.{0} (has_nnnorm.{0} to_additive.value_type)))  := sorry --non-trivial
lemma new_lemma_148638 (h0 : functor.add_const (topological_space (boolean_algebra pos)) pos) : @preirreducible_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_148639 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_ordered_add_comm_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_148640 (h0 : has_pos_part (has_add Type) -> has_pos_part (has_add Type) -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_148641 (h0 : has_mem.mem (measurable_space congr_arg_kind) has_emptyc.emptyc) : @rank_condition.{0} (measurable_space.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_148642 (h0 : functor.add_const (add_group (has_add Type)) name) : @is_add_cyclic.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (has_add.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_148643 (h0 : topological_space (has_add (ring environment.implicit_infer_kind))) : sequential_space (has_add (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_148644 (h0 : monoid (normed_group (has_inv linarith.comp_source))) : monoid.fg (normed_group (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_148645 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_148646 (h0 : topological_space (has_pos_part (has_add (has_pos_part linarith.comp)))) : path_connected_space (has_pos_part (has_add (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_148647 (h0 : complete_lattice (omega_complete_partial_order num)) : is_compactly_generated (omega_complete_partial_order num) := sorry --non-trivial
lemma new_lemma_148648 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @loc_path_connected_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_148649 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_148650 (h0 : functor.add_const (topological_space (normed_linear_ordered_group unsigned)) empty) : @locally_compact_space.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_148651 (h0 : fin has_zero.zero) : @monoid.fg.{0} (normed_lattice_add_comm_group.{0} real) (@matrix.vec_empty.{0} (monoid.{0} (normed_lattice_add_comm_group.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_148652 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_dist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_dist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_148653 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (has_inv.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_inv.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_148654 (h0 : functor.add_const (finset (semigroup pos)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_148655 (h0 : measurable_space (nondiscrete_normed_field (add_comm_semigroup ereal))) (h1 : measure_theory.measure (nondiscrete_normed_field (add_comm_semigroup ereal))) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_148656 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_148657 (h0 : group (left_cancel_semigroup (semiring congr_arg_kind))) : normalizer_condition (left_cancel_semigroup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_148658 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_148659 (h0 : functor.add_const (ring (has_pos_part linarith.comp)) name) : @is_domain.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_pos_part.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_148660 (h0 : set (non_unital_non_assoc_semiring (mul_one_class (mul_one_class environment.projection_info)))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_148661 (h0 : to_additive.value_type -> to_additive.value_type -> Prop) : relator.bi_total h0 := sorry --non-trivial
lemma new_lemma_148662 (h0 : function.extfun (Type 1) add_group) : @is_add_cyclic.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} h0 (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_148663 (h0 : add_group (ordered_comm_monoid (has_Inf Type))) : is_add_cyclic (ordered_comm_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_148664 (h0 : semiring (has_neg congr_arg_kind)) : is_noetherian_ring (has_neg congr_arg_kind) := sorry --non-trivial
lemma new_lemma_148665 (h0 : functor.add_const (ordered_add_comm_monoid (pseudo_metric_space name)) (option unsigned)) : @archimedean.{0} (pseudo_metric_space.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (pseudo_metric_space.{0} name)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_148666 (h0 : ring (normed_field (comm_ring string_imp))) : is_domain (normed_field (comm_ring string_imp)) := sorry --non-trivial
lemma new_lemma_148667 (h0 : ordered_add_comm_monoid (add_comm_monoid (normed_comm_ring name))) : archimedean (add_comm_monoid (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_148668 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_148669 (h0 : uniform_space (with_bot (random_gen (random_gen (random_gen fun_info))))) : complete_space (with_bot (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_148670 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_148671 (h0 : functor.add_const (group (has_zero Type)) (semigroup linarith.comp)) : @normalizer_condition.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_zero.{1} Type)) (semigroup.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_148672 (h0 : functor.add_const (list (ring environment.implicit_infer_kind)) (has_to_string environment.implicit_infer_kind)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_148673 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} h0 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_148674 (h0 : add_monoid (has_nndist (has_pos_part pos))) : add_monoid.fg (has_nndist (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_148675 (h0 : ring (has_compl (has_nnnorm string.iterator_imp))) : is_domain (has_compl (has_nnnorm string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_148676 (h0 : functor.add_const (group (has_zero pos)) name) : @is_simple_group.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_148677 (h0 : ring (canonically_ordered_monoid (has_add pos))) : strong_rank_condition (canonically_ordered_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_148678 (h2 : ring (distrib_lattice char)) : is_domain (distrib_lattice char) := sorry --non-trivial
lemma new_lemma_148679 (h0 : not (ring (distrib_lattice reducibility_hints) -> false)) : @is_domain.{0} (distrib_lattice.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (distrib_lattice.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_148680 (h0 : list (has_inv (random_gen (random_gen (random_gen string_imp))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_148681 (h0 : topological_space (has_to_string (has_neg (has_neg (has_neg environment.implicit_infer_kind))))) : regular_space (has_to_string (has_neg (has_neg (has_neg environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_148682 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_148683 (h0 : complete_lattice (denumerable (random_gen char))) : complete_lattice.is_Sup_finite_compact (denumerable (random_gen char)) := sorry --non-trivial
lemma new_lemma_148684 (h0 : add_monoid (option (has_neg_part unsigned))) : add_monoid.fg (option (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_148685 (h1 : not (filter (add_left_cancel_monoid char) -> false)) : filter.ne_bot (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_148686 (h0 : functor.add_const (add_monoid (boolean_algebra.core name)) name) : @add_monoid.fg.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (boolean_algebra.core.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_148687 (h0 : add_monoid (cancel_monoid (option pos))) : add_monoid.fg (cancel_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_148688 (h0 : monoid (with_bot (has_norm fun_info))) : monoid.fg (with_bot (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_148689 (h0 : complete_lattice (semigroup (option (option unsigned)))) : is_atomistic (semigroup (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_148690 (h0 : topological_space (has_neg (finset unsigned))) : locally_compact_space (has_neg (finset unsigned)) := sorry --non-trivial
lemma new_lemma_148691 (h0 : list (measure_theory.measure_space (semiring empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_148692 (h0 : functor.add_const (complete_lattice (has_nndist environment.implicit_infer_kind)) pos) : @is_atomistic.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_148693 (h0 : uniform_space (normed_group linarith.ineq)) : complete_space (normed_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_148694 (h0 : functor.add_const (functor.add_const (topological_space name) congr_arg_kind) congr_arg_kind) : @discrete_topology.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) congr_arg_kind (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} name) congr_arg_kind) congr_arg_kind h0))  := sorry --non-trivial
lemma new_lemma_148695 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_ssubset.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_ssubset.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_148696 (h0 : topological_space (has_bot (has_Inf Type))) : preconnected_space (has_bot (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_148697 (h0 : not (filter (fintype linarith.comp_source) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_148698 (h0 : topological_space (add_cancel_monoid (has_nndist Type))) : totally_disconnected_space (add_cancel_monoid (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_148699 (h0 : complete_lattice (has_compl to_additive.value_type)) : is_compactly_generated (has_compl to_additive.value_type) := sorry --non-trivial
lemma new_lemma_148700 (h0 : complete_lattice (has_one congr_arg_kind)) : is_compactly_generated (has_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_148701 (h0 : topological_space (ordered_comm_ring (has_Inf pos))) : path_connected_space (ordered_comm_ring (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_148702 (h0 : add_monoid (semigroup (boolean_algebra.core Type))) : add_monoid.fg (semigroup (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_148703 (h0 : add_group (linear_ordered_semiring linarith.comp_source)) : is_add_cyclic (linear_ordered_semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_148704 (h0 : complete_lattice (cancel_monoid unsigned)) : complete_lattice.is_Sup_finite_compact (cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_148705 (h0 : functor.add_const (topological_space (has_star congr_arg_kind)) empty) : @path_connected_space.{0} (has_star.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_148706 (h0 : functor.add_const (function.extfun Type list) (has_pos_part linarith.comp)) : palindrome (function.extfun_app (functor.add_const.run h0) (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_148707 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) Type) : @preirreducible_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_148708 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ring Type)) name) : @unique_factorization_monoid.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_148709 (h0 : uniform_space (with_one (semiring (semiring fun_info)))) : complete_space (with_one (semiring (semiring fun_info))) := sorry --non-trivial
lemma new_lemma_148710 (h0 : fin has_zero.zero) : @path_connected_space.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_148711 (h1 : has_mem.mem (measurable_space linarith.comp) has_emptyc.emptyc) : @t0_space.{0} (measurable_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} linarith.comp) h1)  := sorry --non-trivial
lemma new_lemma_148712 (h0 : topological_space (has_nndist (add_comm_monoid environment.implicit_infer_kind))) : path_connected_space (has_nndist (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_148713 (h0 : topological_space (normed_comm_ring (option (option (option (option congr_arg_kind)))))) : locally_compact_space (normed_comm_ring (option (option (option (option congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_148714 (h0 : functor.comp topological_space has_neg pos) : @path_connected_space.{0} (has_neg.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_148715 (h0 : functor.add_const (function.extfun (Type 1) ring) Type) : @strong_rank_condition.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) Type h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_148716 (h0 : topological_space (measurable_space (random_gen linarith.ineq))) : totally_separated_space (measurable_space (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_148717 (h0 : complete_lattice (cancel_monoid (option ennreal))) : is_compactly_generated (cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_148718 (h0 : topological_space (option_t semilattice_inf fun_info)) : locally_compact_space (option_t semilattice_inf fun_info) := sorry --non-trivial
lemma new_lemma_148719 (h0 : group (with_bot (denumerable linarith.ineq))) : normalizer_condition (with_bot (denumerable linarith.ineq)) := sorry --non-trivial
lemma new_lemma_148720 (h0 : add_group (with_one (has_top (random_gen (comm_ring to_additive.value_type))))) : is_add_cyclic (with_one (has_top (random_gen (comm_ring to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_148721 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (encodable.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (encodable.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_148722 (h0 : has_mem.mem group has_emptyc.emptyc) : @normalizer_condition.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (linear_ordered_semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_148723 (h0 : complete_lattice (has_div (mul_one_class ennreal))) : is_compactly_generated (has_div (mul_one_class ennreal)) := sorry --non-trivial
lemma new_lemma_148724 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (topological_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (topological_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_148725 (h1 : uniform_space (metric_space char)) : complete_space (metric_space char) := sorry --non-trivial
lemma new_lemma_148726 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot linarith.comp))) : @add_monoid.fg.{0} (with_bot.{0} linarith.comp) (@finset.pi.empty.{1 0} Type add_monoid.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_148727 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) Type) : @locally_compact_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_148728 (h0 : complete_lattice (has_zero name)) : complete_lattice.is_Sup_finite_compact (has_zero name) := sorry --non-trivial
lemma new_lemma_148729 (h0 : functor.add_const (ring (measurable_space.dynkin_system unsigned)) num) : @strong_rank_condition.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (measurable_space.dynkin_system.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_148730 (h0 : functor.add_const (group (has_nndist name)) linarith.comp) : @normalizer_condition.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_148731 (h0 : fin has_zero.zero) : path_connected_space real := sorry --non-trivial
lemma new_lemma_148732 (h0 : group (comm_group (option unsigned))) : is_simple_group (comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_148733 (h0 : functor.add_const (list (has_pos_part pos)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_148734 (h0 : topological_space (sub_neg_monoid (has_add linarith.comp))) : topological_space.separable_space (sub_neg_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_148735 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (add_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_148736 (h0 : functor.add_const (complete_lattice (left_cancel_monoid congr_arg_kind)) empty) : @is_compactly_generated.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_148737 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_norm.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 complete_lattice.{0}) (has_norm.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_148738 (h0 : functor.add_const (function.extfun Type uniform_space) linarith.comp) : @complete_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) linarith.comp h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_148739 (h0 : function.extfun (Type 1) group) : @group.fg.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_148740 (h0 : ring (semigroup (has_add Type))) : strong_rank_condition (semigroup (has_add Type)) := sorry --non-trivial
lemma new_lemma_148741 (h0 : topological_space (add_cancel_monoid linarith.comp)) : sequential_space (add_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_148742 (h0 : ring (has_neg_part (has_neg_part pos))) : is_domain (has_neg_part (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_148743 (h0 : complete_lattice (complete_distrib_lattice (option unsigned))) : is_atomistic (complete_distrib_lattice (option unsigned)) := sorry --non-trivial
lemma new_lemma_148744 (h0 : functor.add_const (uniform_space (boolean_algebra.core pos)) name) : @separated_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.core.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_148745 (h0 : not (filter (linear_ordered_comm_ring congr_arg_kind) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_148746 (h0 : topological_space (mul_one_class (mul_one_class (mul_one_class ereal)))) : path_connected_space (mul_one_class (mul_one_class (mul_one_class ereal))) := sorry --non-trivial
lemma new_lemma_148747 (h0 : ring (id (semiring (semiring empty)))) : rank_condition (id (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_148748 (h0 : group (has_Inf (has_add (has_add environment.implicit_infer_kind)))) : is_cyclic (has_Inf (has_add (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_148749 (h0 : functor.add_const (topological_space (add_cancel_comm_monoid unsigned)) unsigned) : @preirreducible_space.{0} (add_cancel_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_comm_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_148750 (h0 : not (filter (mul_zero_class num) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_148751 (h0 : add_group (add_cancel_monoid (has_to_string (has_add unsigned)))) : is_add_cyclic (add_cancel_monoid (has_to_string (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_148752 (h0 : not (ring (topological_space char) -> false)) : @strong_rank_condition.{0} (topological_space.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (topological_space.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_148753 (h0 : group (boolean_algebra (finset linarith.comp))) : is_simple_group (boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_148754 (h0 : topological_space (has_add (has_zero name))) : preconnected_space (has_add (has_zero name)) := sorry --non-trivial
lemma new_lemma_148755 (h0 : cancel_comm_monoid_with_zero (has_pos_part (finset Type))) : unique_factorization_monoid (has_pos_part (finset Type)) := sorry --non-trivial
lemma new_lemma_148756 (h0 : topological_space (boolean_algebra (finset environment.implicit_infer_kind))) : regular_space (boolean_algebra (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_148757 (h0 : functor.add_const (add_group (canonically_ordered_comm_semiring linarith.comp)) pos) : @is_add_cyclic.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_148758 (h0 : group (has_bot (has_add pos))) : is_cyclic (has_bot (has_add pos)) := sorry --non-trivial
lemma new_lemma_148759 (h0 : group (semigroup (semigroup (semigroup environment.implicit_infer_kind)))) : is_simple_group (semigroup (semigroup (semigroup environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_148760 (h0 : topological_space (has_Inf (ordered_ring Type))) : totally_separated_space (has_Inf (ordered_ring Type)) := sorry --non-trivial
lemma new_lemma_148761 (h0 : group (plift (semiring (semiring (semiring unsigned))))) : group.fg (plift (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_148762 (h0 : function.extfun (Type 1) topological_space) : @regular_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_148763 (h0 : functor.add_const (ordered_comm_monoid (has_to_string (finset linarith.comp))) environment.implicit_infer_kind) : @has_exists_mul_of_le.{0} (has_to_string.{0} (finset.{0} linarith.comp)) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_to_string.{0} (finset.{0} linarith.comp))) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_148764 (h0 : not (add_group (random_gen char) -> false)) : @is_add_cyclic.{0} (random_gen.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (random_gen.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_148765 (h0 : complete_lattice (ordered_comm_ring (has_neg Type))) : complete_lattice.is_Sup_finite_compact (ordered_comm_ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_148766 (h0 : function.extfun Type group) : @is_cyclic.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_148767 (h0 : group (normed_lattice_add_comm_group real)) : group.fg (normed_lattice_add_comm_group real) := sorry --non-trivial
lemma new_lemma_148768 (h0 : functor.add_const (topological_space (has_inter unsigned)) linarith.comp) : @preconnected_space.{0} (has_inter.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_inter.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_148769 (h0 : ring (complete_semilattice_Sup (has_inv (has_top linarith.ineq)))) : is_domain (complete_semilattice_Sup (has_inv (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_148770 (h0 : function.extfun Type topological_space) : @normal_space.{0} (non_assoc_semiring.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_148771 (h0 : ring (has_append (has_ssubset (has_ssubset string_imp)))) : rank_condition (has_append (has_ssubset (has_ssubset string_imp))) := sorry --non-trivial
lemma new_lemma_148772 (h0 : filter (semigroup (ring (ring (has_add Type))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_148773 (h0 : group (has_nndist real)) : normalizer_condition (has_nndist real) := sorry --non-trivial
lemma new_lemma_148774 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (finset num)) := sorry --non-trivial
lemma new_lemma_148775 (h0 : uniform_space (random_gen to_additive.value_type)) : complete_space (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_148776 (h0 : add_monoid (add_comm_monoid (has_add name))) : add_monoid.fg (add_comm_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_148777 (h0 : has_mem.mem (normed_group linarith.comp_source) has_emptyc.emptyc) : @rank_condition.{0} (normed_group.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (normed_group.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_148778 (h0 : cancel_comm_monoid_with_zero (linear_ordered_cancel_comm_monoid (option empty))) : unique_factorization_monoid (linear_ordered_cancel_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_148779 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_148780 (h0 : not (topological_space (has_union unsigned) -> false)) : @path_connected_space.{0} (has_union.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_148781 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @rank_condition.{0} string_imp (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) string_imp)  := sorry --non-trivial
lemma new_lemma_148782 (h0 : functor.add_const (group (has_neg name)) name) : @is_simple_group.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_148783 (h0 : group (normed_group (semiring (metric_space num)))) : normalizer_condition (normed_group (semiring (metric_space num))) := sorry --non-trivial
lemma new_lemma_148784 (h0 : add_monoid (add_comm_monoid name)) : add_monoid.fg (add_comm_monoid name) := sorry --non-trivial
lemma new_lemma_148785 (h0 : functor.add_const (functor.add_const (complete_lattice name) unsigned) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} name (@functor.add_const.run.{0 0} (complete_lattice.{0} name) unsigned (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (complete_lattice.{0} name) unsigned) unsigned h0))  := sorry --non-trivial
lemma new_lemma_148786 (h0 : ring (metric_space char)) : strong_rank_condition (metric_space char) := sorry --non-trivial
lemma new_lemma_148787 (h0 : uniform_space (has_to_string (add_comm_monoid (has_to_string name)))) : complete_space (has_to_string (add_comm_monoid (has_to_string name))) := sorry --non-trivial
lemma new_lemma_148788 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{0} (has_pos_part.{0} pos) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (has_pos_part.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_148789 (h1 : set (fun_info -> linarith.ineq)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_148790 (h0 : prod (normed_comm_ring num) (normed_comm_ring num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_148791 (h0 : filter (has_to_string (has_pos_part (finset pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_148792 (h0 : functor.add_const (ordered_add_comm_monoid (normed_comm_ring pos)) (has_neg Type)) : @archimedean.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (normed_comm_ring.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_148793 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_148794 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (linear_ordered_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_148795 (h0 : group (complete_distrib_lattice ennreal)) : is_simple_group (complete_distrib_lattice ennreal) := sorry --non-trivial
lemma new_lemma_148796 (h0 : topological_space (has_nnnorm (has_nnnorm (has_nnnorm char)))) : t0_space (has_nnnorm (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_148797 (h0 : uniform_space (has_lt (mul_one_class (mul_one_class linarith.ineq)))) : complete_space (has_lt (mul_one_class (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_148798 (h0 : topological_space (linear_ordered_field pos)) : topological_space.separable_space (linear_ordered_field pos) := sorry --non-trivial
lemma new_lemma_148799 (h1 : complete_lattice (distrib (has_ssubset (comm_ring char)))) : is_compactly_generated (distrib (has_ssubset (comm_ring char))) := sorry --non-trivial
lemma new_lemma_148800 (h0 : function.extfun (Type 1) (functor.comp topological_space finset)) : @preconnected_space.{1} (finset.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} finset.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} finset.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_148801 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_148802 (h0 : add_group (add_group_with_zero_nhd environment.projection_info)) : is_add_cyclic (add_group_with_zero_nhd environment.projection_info) := sorry --non-trivial
lemma new_lemma_148803 (h1 : set (nondiscrete_normed_field char)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_148804 (h0 : functor.add_const Prop (has_neg (semigroup unsigned))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_148805 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@matrix.vec_empty.{0} (semiring.{0} (normed_lattice_add_comm_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_148806 (h0 : add_group (boolean_algebra.core unsigned)) : is_add_cyclic (boolean_algebra.core unsigned) := sorry --non-trivial
lemma new_lemma_148807 (h0 : functor.add_const (ring (has_Inf pos)) (has_Inf name)) : @strong_rank_condition.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_Inf.{0} pos)) (has_Inf.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_148808 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_148809 (h0 : functor.add_const (group (normed_comm_ring empty)) unsigned) : @is_cyclic.{0} (normed_comm_ring.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_148810 (h0 : function.extfun Type (functor.add_const (uniform_space (has_Inf linarith.comp)))) : @separated_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_Inf.{0} linarith.comp)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (has_Inf.{0} linarith.comp))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_148811 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_148812 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_148813 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} pos (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 pos)  := sorry --non-trivial
lemma new_lemma_148814 (h0 : ring (add_comm_monoid (option congr_arg_kind))) : strong_rank_condition (add_comm_monoid (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_148815 (h0 : not (ring (normed_group empty) -> false)) : @is_domain.{0} (normed_group.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (normed_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_148816 (h0 : topological_space (metric_space (has_top (has_top num)))) : discrete_topology (metric_space (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_148817 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_148818 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring name)) linarith.comp) : @preirreducible_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_148819 (h0 : uniform_space (option name)) : separated_space (option name) := sorry --non-trivial
lemma new_lemma_148820 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_148821 (h0 : list (left_cancel_monoid (semiring (semiring empty)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_148822 (h0 : functor.add_const (complete_lattice (boolean_algebra.core unsigned)) name) : @is_compactly_generated.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_148823 (h0 : topological_space (boolean_algebra.core (has_neg name))) : regular_space (boolean_algebra.core (has_neg name)) := sorry --non-trivial
lemma new_lemma_148824 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_148825 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_148826 (h0 : ring (non_unital_non_assoc_semiring (mul_one_class char))) : is_domain (non_unital_non_assoc_semiring (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_148827 (h0 : ring (normed_field (has_nnnorm (mul_one_class reducibility_hints)))) : is_domain (normed_field (has_nnnorm (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_148828 (h0 : ordered_comm_monoid (has_add (add_cancel_monoid (has_neg name)))) : has_exists_mul_of_le (has_add (add_cancel_monoid (has_neg name))) := sorry --non-trivial
lemma new_lemma_148829 (h0 : function.extfun (finset Type) (has_mem.mem (order_dual fun_info))) : @normalizer_condition.{0} (order_dual.{0} fun_info) (@finset.pi.empty.{1 0} Type group.{0} (order_dual.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (order_dual.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_148830 (h0 : semiring (has_add (option name))) : is_noetherian_ring (has_add (option name)) := sorry --non-trivial
lemma new_lemma_148831 (h0 : group (has_norm (random_gen (random_gen (random_gen to_additive.value_type))))) : is_cyclic (has_norm (random_gen (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_148832 (h0 : topological_space (preorder (option unsigned))) : totally_disconnected_space (preorder (option unsigned)) := sorry --non-trivial
lemma new_lemma_148833 (h0 : topological_space (complete_semilattice_Sup (semiring num))) : t0_space (complete_semilattice_Sup (semiring num)) := sorry --non-trivial
lemma new_lemma_148834 (h0 : complete_lattice (partial_order empty)) : complete_lattice.is_Sup_finite_compact (partial_order empty) := sorry --non-trivial
lemma new_lemma_148835 (h0 : topological_space (canonically_ordered_comm_semiring (option unsigned))) : topological_space.separable_space (canonically_ordered_comm_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_148836 (h0 : complete_lattice (mul_zero_class (has_add name))) : complete_lattice.is_Sup_finite_compact (mul_zero_class (has_add name)) := sorry --non-trivial
lemma new_lemma_148837 (h0 : group (has_nndist (finset name))) : group.fg (has_nndist (finset name)) := sorry --non-trivial
lemma new_lemma_148838 (h0 : complete_lattice (ring (ring Type))) : is_atomistic (ring (ring Type)) := sorry --non-trivial
lemma new_lemma_148839 (h0 : functor.add_const (ring (has_inter ennreal)) ennreal) : @rank_condition.{0} (has_inter.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (has_inter.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_148840 (h0 : group (normed_field (mul_one_class fun_info))) : is_cyclic (normed_field (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_148841 (h2 : has_mem.mem topological_space has_emptyc.emptyc) : @locally_compact_space.{0} string_imp (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h2) string_imp)  := sorry --non-trivial
lemma new_lemma_148842 (h0 : has_mem.mem (has_norm congr_arg_kind) has_emptyc.emptyc) : @is_add_cyclic.{0} (has_norm.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type add_group.{0} (has_norm.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_148843 (h0 : topological_space (measure_theory.measure_space empty)) : t1_space (measure_theory.measure_space empty) := sorry --non-trivial
lemma new_lemma_148844 (h0 : function.extfun Type group) : @is_cyclic.{0} (ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_148845 (h0 : functor.add_const (complete_lattice (boolean_algebra unsigned)) pos) : @is_compactly_generated.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_148846 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_148847 (h0 : topological_space (canonically_linear_ordered_monoid real)) : t1_space (canonically_linear_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_148848 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_148849 (h0 : monoid (canonically_ordered_monoid name)) : monoid.fg (canonically_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_148850 (h0 : ring (linear_ordered_comm_monoid_with_zero (option (option unsigned)))) : is_domain (linear_ordered_comm_monoid_with_zero (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_148851 (h0 : uniform_space (has_ssubset fun_info)) : complete_space (has_ssubset fun_info) := sorry --non-trivial
lemma new_lemma_148852 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_148853 (h0 : ring (random_gen (has_nnnorm (has_nnnorm reducibility_hints)))) : strong_rank_condition (random_gen (has_nnnorm (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_148854 (h0 : topological_space (canonically_linear_ordered_monoid pos)) : discrete_topology (canonically_linear_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_148855 (h1 : not (topological_space (non_unital_non_assoc_semiring linarith.comp_source) -> false)) (h2 : set (non_unital_non_assoc_semiring linarith.comp_source)) : @is_seq_compact.{0} (non_unital_non_assoc_semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (non_unital_non_assoc_semiring.{0} linarith.comp_source)) h1) h2  := sorry --non-trivial
lemma new_lemma_148856 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_148857 (h0 : set char) (h1 : char -> char -> Prop) : set.pairwise h0 h1 := sorry --non-trivial
lemma new_lemma_148858 (h0 : functor.add_const (finset linarith.comp) (finset (finset linarith.comp))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_148859 (h0 : functor.add_const (group (has_neg_part environment.implicit_infer_kind)) Type) : @group.fg.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (group.{0} (has_neg_part.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_148860 (h0 : topological_space (ordered_comm_monoid (ring (ring pos)))) : totally_disconnected_space (ordered_comm_monoid (ring (ring pos))) := sorry --non-trivial
lemma new_lemma_148861 (h0 : has_mem.mem (with_one congr_arg_kind) has_emptyc.emptyc) : @is_compactly_generated.{0} (with_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_one.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_148862 (h0 : functor.add_const (list (generalized_boolean_algebra linarith.comp)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_148863 (h0 : has_mem.mem (semiring (semiring (has_norm num))) has_emptyc.emptyc) : @is_domain.{0} (semiring.{0} (semiring.{0} (has_norm.{0} num))) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} (semiring.{0} (has_norm.{0} num))) h0)  := sorry --non-trivial
lemma new_lemma_148864 (h0 : ring (simple_graph (finset pos))) : is_principal_ideal_ring (simple_graph (finset pos)) := sorry --non-trivial
lemma new_lemma_148865 (h0 : ring (canonically_ordered_comm_semiring (add_comm_monoid Type))) : strong_rank_condition (canonically_ordered_comm_semiring (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_148866 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_148867 (h0 : topological_space (semiring (has_norm linarith.ineq))) : totally_disconnected_space (semiring (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_148868 (h0 : topological_space (mul_zero_class (finset ennreal))) : topological_space.separable_space (mul_zero_class (finset ennreal)) := sorry --non-trivial
lemma new_lemma_148869 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (mul_zero_class.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_148870 (h0 : group (complete_distrib_lattice (finset (has_nndist (ring Type))))) : normalizer_condition (complete_distrib_lattice (finset (has_nndist (ring Type)))) := sorry --non-trivial
lemma new_lemma_148871 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf Type))) : loc_path_connected_space (canonically_linear_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_148872 (h0 : functor.add_const (group (has_to_string unsigned)) Type) : @group.fg.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 1} (group.{0} (has_to_string.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_148873 (h0 : topological_space (add_cancel_monoid (option num))) : preconnected_space (add_cancel_monoid (option num)) := sorry --non-trivial
lemma new_lemma_148874 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) environment.implicit_infer_kind) : @sequential_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_148875 (h0 : uniform_space (random_gen (has_nnnorm (has_nnnorm reducibility_hints)))) : complete_space (random_gen (has_nnnorm (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_148876 (h0 : ring (option congr_arg_kind)) : strong_rank_condition (option congr_arg_kind) := sorry --non-trivial
lemma new_lemma_148877 (h0 : monoid (partial_order (semiring (semiring (semiring (semiring unsigned)))))) : monoid.fg (partial_order (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_148878 (h0 : complete_lattice (has_Inf (has_Inf (has_Inf Type)))) : complete_lattice.is_Sup_finite_compact (has_Inf (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_148879 (h0 : uniform_space (has_top num)) : separated_space (has_top num) := sorry --non-trivial
lemma new_lemma_148880 (h0 : group (ordered_comm_ring (sub_neg_monoid real))) : group.fg (ordered_comm_ring (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_148881 (h0 : topological_space (has_norm (semiring congr_arg_kind))) : topological_space.separable_space (has_norm (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_148882 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_148883 (h0 : functor.add_const (topological_space (has_neg_part ennreal)) (option pos)) : @regular_space.{0} (has_neg_part.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} ennreal)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_148884 (h0 : function.extfun Type group) : @is_cyclic.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_distrib_lattice.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_148885 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_dist congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_148886 (h0 : has_coe fun_info Prop) (h1 : fun_info) : @coe_b.{1 1} fun_info Prop h0 h1  := sorry --non-trivial
lemma new_lemma_148887 (h0 : complete_lattice (preorder num) -> Prop) (h1 : Exists (fun (x : complete_lattice (preorder num)), h0 x)) : @is_compactly_generated.{0} (preorder.{0} num) (@classical.some.{1} (complete_lattice.{0} (preorder.{0} num)) h0 h1)  := sorry --non-trivial
lemma new_lemma_148888 (h0 : set (set (topological_space char))) (h1 : topological_space char) : set.sInter h0 h1 := sorry --non-trivial
lemma new_lemma_148889 (h0 : uniform_space (comm_ring reducibility_hints)) : complete_space (comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_148890 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_bot.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_148891 (h1 : topological_space (has_norm (has_inv fun_info))) : locally_compact_space (has_norm (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_148892 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_148893 (h0 : function.extfun Type group) : @normalizer_condition.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_148894 (h0 : functor.add_const (functor.comp uniform_space mul_zero_class pos) pos) : @separated_space.{0} (mul_zero_class.{0} pos) (@functor.comp.run.{0 0 0} uniform_space.{0} mul_zero_class.{0} pos (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} uniform_space.{0} mul_zero_class.{0} pos) pos h0))  := sorry --non-trivial
lemma new_lemma_148895 (h0 : function.extfun Type (functor.comp topological_space ring)) : @t1_space.{0} (ring.{0} linarith.comp) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} linarith.comp (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} ring.{0}) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_148896 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (boolean_algebra.core ennreal)) := sorry --non-trivial
lemma new_lemma_148897 (h0 : functor.add_const Prop (cancel_monoid Type)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_148898 (h1 : topological_space (dlist char)) : locally_compact_space (dlist char) := sorry --non-trivial
lemma new_lemma_148899 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_148900 (h0 : complete_lattice (has_union congr_arg_kind)) : is_atomistic (has_union congr_arg_kind) := sorry --non-trivial
lemma new_lemma_148901 (h0 : functor.comp monoid mul_zero_class Type) : @monoid.fg.{1} (mul_zero_class.{1} Type) (@functor.comp.run.{1 1 1} monoid.{1} mul_zero_class.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_148902 (h1 : complete_lattice (add_cancel_comm_monoid linarith.comp_source)) : is_compactly_generated (add_cancel_comm_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_148903 (h0 : ring (simple_graph linarith.comp_source)) : rank_condition (simple_graph linarith.comp_source) := sorry --non-trivial
lemma new_lemma_148904 (h0 : ring pos) : rank_condition pos := sorry --non-trivial
lemma new_lemma_148905 (h0 : not (monoid (left_cancel_semigroup congr_arg_kind) -> false)) : @monoid.fg.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (monoid.{0} (left_cancel_semigroup.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_148906 (h0 : ring (add_cancel_monoid (boolean_algebra (boolean_algebra.core linarith.comp)))) : strong_rank_condition (add_cancel_monoid (boolean_algebra (boolean_algebra.core linarith.comp))) := sorry --non-trivial
lemma new_lemma_148907 (h0 : topological_space (cancel_monoid empty)) : loc_path_connected_space (cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_148908 (h0 : topological_space (with_bot (random_gen (random_gen (random_gen linarith.ineq))))) : irreducible_space (with_bot (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_148909 (h0 : fin has_zero.zero) : @is_simple_group.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) h0) (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_148910 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (with_one.{0} (semiring.{0} (has_top.{0} (semiring.{0} (semiring.{0} fun_info))))) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (with_one.{0} (semiring.{0} (has_top.{0} (semiring.{0} (semiring.{0} fun_info))))))  := sorry --non-trivial
lemma new_lemma_148911 (h0 : functor.add_const (function.extfun Type uniform_space) pos) : @separated_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) pos h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_148912 (h0 : functor.add_const (topological_space (add_comm_monoid environment.implicit_infer_kind)) pos) : @topological_space.separable_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_148913 (h0 : ring (semigroup (has_add pos))) : is_principal_ideal_ring (semigroup (has_add pos)) := sorry --non-trivial
lemma new_lemma_148914 (h0 : ordered_comm_monoid (has_zero unsigned)) : has_exists_mul_of_le (has_zero unsigned) := sorry --non-trivial
lemma new_lemma_148915 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_148916 (h0 : functor.add_const (filter (ring Type)) (has_neg_part Type)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_148917 (h0 : uniform_space (ordered_comm_ring (ordered_comm_monoid (has_neg (finset (ring (has_neg pos))))))) : separated_space (ordered_comm_ring (ordered_comm_monoid (has_neg (finset (ring (has_neg pos)))))) := sorry --non-trivial
lemma new_lemma_148918 (h0 : list (has_neg_part Type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_148919 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (ordered_cancel_add_comm_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_148920 (h0 : topological_space (canonically_ordered_comm_semiring (has_neg unsigned))) : t1_space (canonically_ordered_comm_semiring (has_neg unsigned)) := sorry --non-trivial
lemma new_lemma_148921 (h0 : group (semiring linarith.ineq)) : group.fg (semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_148922 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_148923 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (boolean_algebra.core.{0} (option.{0} (option.{0} empty))) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} (option.{0} (option.{0} empty))))  := sorry --non-trivial
lemma new_lemma_148924 (h0 : group (has_nndist unsigned)) : normalizer_condition (has_nndist unsigned) := sorry --non-trivial
lemma new_lemma_148925 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (div_inv_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_148926 (h0 : topological_space (comm_ring (has_nnnorm fun_info))) : path_connected_space (comm_ring (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_148927 (h0 : uniform_space (add_cancel_monoid (finset (has_to_string (finset linarith.comp))))) : complete_space (add_cancel_monoid (finset (has_to_string (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_148928 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) (normed_comm_ring name)) : @preconnected_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) (normed_comm_ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_148929 (h0 : topological_space (ring (ring (has_star (has_neg pos))))) : normal_space (ring (ring (has_star (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_148930 (h0 : functor.add_const (group (finset environment.implicit_infer_kind)) environment.implicit_infer_kind) : @normalizer_condition.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_148931 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_ssubset.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_ssubset.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_148932 (h0 : group (div_inv_monoid string_imp)) : is_cyclic (div_inv_monoid string_imp) := sorry --non-trivial
lemma new_lemma_148933 (h1 : ring (comm_ring (has_nnnorm char))) : rank_condition (comm_ring (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_148934 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring ennreal)) pos) : @t1_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_148935 (h0 : topological_space (has_ssubset enat)) : totally_disconnected_space (has_ssubset enat) := sorry --non-trivial
lemma new_lemma_148936 (h0 : topological_space (measurable_space (has_norm (has_norm num)))) : totally_disconnected_space (measurable_space (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_148937 (h0 : ring (with_bot (random_gen linarith.ineq))) : rank_condition (with_bot (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_148938 (h0 : topological_space (finset (has_Inf (has_Inf pos)))) : discrete_topology (finset (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_148939 (h0 : group (distrib_lattice (random_gen linarith.comp_source))) : is_cyclic (distrib_lattice (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_148940 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (linear_ordered_comm_group.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_148941 (h0 : group (ordered_comm_monoid (has_neg linarith.comp))) : is_cyclic (ordered_comm_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_148942 (h0 : filter (add_comm_monoid name)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_148943 (h0 : topological_space (measurable_space.dynkin_system (add_group linarith.comp))) : normal_space (measurable_space.dynkin_system (add_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_148944 (h0 : topological_space (semigroup (has_pos_part environment.implicit_infer_kind))) : irreducible_space (semigroup (has_pos_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_148945 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (normed_lattice_add_comm_group pos)) := sorry --non-trivial
lemma new_lemma_148946 (h0 : topological_space (normed_comm_ring (add_comm_monoid unsigned))) : preirreducible_space (normed_comm_ring (add_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_148947 (h2 : ring (has_ssubset (mul_one_class fun_info))) : rank_condition (has_ssubset (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_148948 (h0 : group (linear_ordered_add_comm_group (has_inv (has_inv fun_info)))) : normalizer_condition (linear_ordered_add_comm_group (has_inv (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_148949 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_inv.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (has_inv.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_148950 (h0 : topological_space (has_neg_part (has_add (group_with_zero (has_neg_part (has_neg_part name)))))) : preirreducible_space (has_neg_part (has_add (group_with_zero (has_neg_part (has_neg_part name))))) := sorry --non-trivial
lemma new_lemma_148951 (h0 : functor.add_const (ring (has_nndist unsigned)) (has_nndist pos)) : @is_domain.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} unsigned)) (has_nndist.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_148952 (h0 : ring (has_Inf (ring name))) : is_domain (has_Inf (ring name)) := sorry --non-trivial
lemma new_lemma_148953 (h0 : complete_lattice (pseudo_metric_space (finset pos))) : is_atomistic (pseudo_metric_space (finset pos)) := sorry --non-trivial
lemma new_lemma_148954 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_148955 (h1 : complete_lattice (measurable_space linarith.comp_source)) : is_compactly_generated (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_148956 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_148957 (h0 : group (metric_space num)) : is_cyclic (metric_space num) := sorry --non-trivial
lemma new_lemma_148958 (h0 : topological_space (finset (has_add (has_add name)))) : irreducible_space (finset (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_148959 (h0 : group (linear_ordered_add_comm_group linarith.comp_source)) : normalizer_condition (linear_ordered_add_comm_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_148960 (h0 : functor.add_const (semiring (add_comm_monoid Type)) Type) : @is_noetherian_ring.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (semiring.{1} (add_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_148961 (h0 : has_mem.mem (has_emptyc linarith.comp) has_emptyc.emptyc) : @discrete_topology.{0} (has_emptyc.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_148962 (h0 : functor.add_const (topological_space (simple_graph Type)) pos) : @sequential_space.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (simple_graph.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_148963 (h0 : functor.add_const (add_monoid (semigroup ennreal)) pos) : @add_monoid.fg.{0} (semigroup.{0} ennreal) (@functor.add_const.run.{0 0} (add_monoid.{0} (semigroup.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_148964 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @regular_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_148965 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) linarith.comp) : @totally_disconnected_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_148966 (h0 : not (group (has_nnnorm (has_nnnorm reducibility_hints)) -> false)) : @is_cyclic.{0} (has_nnnorm.{0} (has_nnnorm.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (group.{0} (has_nnnorm.{0} (has_nnnorm.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_148967 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (pseudo_metric_space.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (pseudo_metric_space.{0} name))  := sorry --non-trivial
lemma new_lemma_148968 (h0 : functor.add_const (ring (finset name)) name) : @rank_condition.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_148969 (h0 : function.extfun Type has_mul) (h1 : function.extfun Type has_le) (h2 : not (linarith.comp_source -> false)) : @mul_le_cancellable.{0} linarith.comp_source (@function.extfun_app.{2 1} Type has_mul.{0} h0 linarith.comp_source) (@function.extfun_app.{2 1} Type has_le.{0} h1 linarith.comp_source) (@classical.by_contradiction'.{1} linarith.comp_source h2)  := sorry --non-trivial
lemma new_lemma_148970 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} auto.case_option (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) auto.case_option)  := sorry --non-trivial
lemma new_lemma_148971 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_148972 (h0 : group (has_to_string environment.implicit_infer_kind)) : is_simple_group (has_to_string environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_148973 (h0 : not (function.extfun Type ring -> false)) : @is_principal_ideal_ring.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_148974 (h0 : has_mem.mem (complete_semilattice_Sup (has_norm unsigned)) has_emptyc.emptyc) : @totally_separated_space.{0} (complete_semilattice_Sup.{0} (has_norm.{0} unsigned)) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} (has_norm.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_148975 (h0 : complete_lattice (omega_complete_partial_order (add_left_cancel_semigroup congr_arg_kind))) : is_atomistic (omega_complete_partial_order (add_left_cancel_semigroup congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_148976 (h0 : add_monoid (omega_complete_partial_order congr_arg_kind)) : add_monoid.fg (omega_complete_partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_148977 (h0 : functor.add_const (functor.add_const (filter pos) Type) (has_neg environment.implicit_infer_kind)) : filter.ne_bot (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_148978 (h0 : not (topological_space (normed_group (has_top linarith.comp_source)) -> false)) : @totally_disconnected_space.{0} (normed_group.{0} (has_top.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} (has_top.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_148979 (h0 : topological_space (add_comm_monoid (finset (finset environment.implicit_infer_kind)))) : totally_disconnected_space (add_comm_monoid (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_148980 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_neg complex)) := sorry --non-trivial
lemma new_lemma_148981 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_148982 (h0 : topological_space (boolean_algebra (cancel_monoid Type))) : preconnected_space (boolean_algebra (cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_148983 (h0 : topological_space (cancel_monoid (has_neg ennreal))) : preconnected_space (cancel_monoid (has_neg ennreal)) := sorry --non-trivial
lemma new_lemma_148984 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} char (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) char)  := sorry --non-trivial
lemma new_lemma_148985 (h0 : function.extfun (Type 1) filter) : filter.ne_bot (function.extfun_app h0 (semigroup Type)) := sorry --non-trivial
lemma new_lemma_148986 (h0 : ring (has_neg Type)) : rank_condition (has_neg Type) := sorry --non-trivial
lemma new_lemma_148987 (h0 : group (id (has_top congr_arg_kind))) : is_cyclic (id (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_148988 (h0 : group (complete_distrib_lattice unsigned)) : group.fg (complete_distrib_lattice unsigned) := sorry --non-trivial
lemma new_lemma_148989 (h0 : topological_space (has_Inf (has_add (finset linarith.comp)))) : locally_compact_space (has_Inf (has_add (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_148990 (h0 : topological_space (boolean_algebra (has_Inf pos))) : regular_space (boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_148991 (h0 : topological_space (has_neg (add_comm_monoid Type))) : topological_space.separable_space (has_neg (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_148992 (h0 : monoid (linear_ordered_field (option (option ennreal)))) : monoid.fg (linear_ordered_field (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_148993 (h0 : functor.add_const (list (has_edist empty)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_148994 (h0 : topological_space (option ennreal)) : totally_separated_space (option ennreal) := sorry --non-trivial
lemma new_lemma_148995 (h0 : list (has_Inf (finset pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_148996 (h0 : not (topological_space (add_cancel_comm_monoid string_imp) -> false)) : @path_connected_space.{0} (add_cancel_comm_monoid.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (add_cancel_comm_monoid.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_148997 (h0 : topological_space (has_nndist (has_neg_part Type))) : path_connected_space (has_nndist (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_148998 (h0 : topological_space (has_neg_part (linear_ordered_field (has_to_string (has_to_string pos))))) : regular_space (has_neg_part (linear_ordered_field (has_to_string (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_148999 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) real) : @preirreducible_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_149000 (h0 : not (complete_lattice (normed_group unsigned) -> false)) : @is_atomistic.{0} (normed_group.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_149001 (h0 : semiring (ring (has_to_string pos))) : is_noetherian_ring (ring (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_149002 (h0 : topological_space (add_cancel_monoid ennreal)) : totally_disconnected_space (add_cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_149003 (h0 : list (has_zero (has_scalar ennreal pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_149004 (h1 : topological_space (add_comm_semigroup (mul_one_class std_gen))) : path_connected_space (add_comm_semigroup (mul_one_class std_gen)) := sorry --non-trivial
lemma new_lemma_149005 (h1 : filter (has_inv (random_gen (with_bot string_imp)))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_149006 (h0 : semiring (has_dist (option empty))) : is_noetherian_ring (has_dist (option empty)) := sorry --non-trivial
lemma new_lemma_149007 (h0 : list (boolean_algebra.core name)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_149008 (h0 : ordered_comm_monoid (add_comm_monoid pos)) : has_exists_mul_of_le (add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_149009 (h0 : function.extfun Type group) : @is_cyclic.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_149010 (h2 h3 : multiset char) : multiset.le h2 h3 := sorry --non-trivial
lemma new_lemma_149011 (h0 : set (distrib linarith.comp_source)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_149012 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} linarith.comp_source (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 group.{0}) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_149013 (h3 : ring (uniform_space string_imp)) : is_domain (uniform_space string_imp) := sorry --non-trivial
lemma new_lemma_149014 (h0 : ring (has_pos_part (ring (has_Inf name)))) : rank_condition (has_pos_part (ring (has_Inf name))) := sorry --non-trivial
lemma new_lemma_149015 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (boolean_algebra.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_149016 (h0 : topological_space (finset (option unsigned))) : irreducible_space (finset (option unsigned)) := sorry --non-trivial
lemma new_lemma_149017 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_149018 (h0 : topological_space (has_neg (finset pos))) : regular_space (has_neg (finset pos)) := sorry --non-trivial
lemma new_lemma_149019 (h0 : functor.add_const (topological_space (finset pos)) environment.implicit_infer_kind) : @regular_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_149020 (h0 : functor.add_const (list (has_pos_part pos)) (finset linarith.comp)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_149021 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen (has_top (has_top (has_top (has_top empty))))))) : @complete_space.{0} (random_gen.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} empty))))) (@finset.pi.empty.{1 0} Type uniform_space.{0} (random_gen.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} empty))))) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} empty)))))) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_149022 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (non_assoc_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_149023 (h0 : functor.add_const (function.extfun Type add_monoid) linarith.comp) : @add_monoid.fg.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) linarith.comp h0) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_149024 (h0 : functor.comp ring distrib_lattice (has_nnnorm to_additive.value_type)) : @is_domain.{0} (distrib_lattice.{0} (has_nnnorm.{0} to_additive.value_type)) (@functor.comp.run.{0 0 0} ring.{0} distrib_lattice.{0} (has_nnnorm.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_149025 (h1 : ring (random_gen (has_top fun_info))) : rank_condition (random_gen (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_149026 (h0 : not (complete_lattice (has_nnnorm string_imp) -> false)) : @is_compactly_generated.{0} (has_nnnorm.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_nnnorm.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_149027 (h0 : topological_space (has_inner empty (option unsigned))) : totally_separated_space (has_inner empty (option unsigned)) := sorry --non-trivial
lemma new_lemma_149028 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_neg.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_neg.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_149029 (h0 : ordered_add_comm_monoid (has_pos_part (has_add (has_add real)))) : archimedean (has_pos_part (has_add (has_add real))) := sorry --non-trivial
lemma new_lemma_149030 (h0 : non_unital_non_assoc_semiring linarith.ineq -> non_unital_non_assoc_semiring linarith.ineq) : set.subsingleton (function.periodic_pts h0) := sorry --non-trivial
lemma new_lemma_149031 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (normed_lattice_add_comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_149032 (h0 : add_group (has_add string_imp)) : is_add_cyclic (has_add string_imp) := sorry --non-trivial
lemma new_lemma_149033 (h1 : group (random_gen (random_gen string_imp))) : normalizer_condition (random_gen (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_149034 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) linarith.comp) : @loc_path_connected_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_149035 (h0 : prod (plift (semiring (semiring unsigned))) (plift (semiring (semiring unsigned)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_149036 (h0 : ring bool) : is_domain bool := sorry --non-trivial
lemma new_lemma_149037 (h0 : functor.add_const (topological_space (has_nndist pos)) pos) : @totally_disconnected_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_149038 (h0 : topological_space (ring (has_add name))) : path_connected_space (ring (has_add name)) := sorry --non-trivial
lemma new_lemma_149039 (h0 : topological_space (metric_space (has_top num))) : totally_separated_space (metric_space (has_top num)) := sorry --non-trivial
lemma new_lemma_149040 (h1 : ring (distrib string_imp)) : rank_condition (distrib string_imp) := sorry --non-trivial
lemma new_lemma_149041 (h0 : topological_space (has_zero (has_add Type))) : topological_space.separable_space (has_zero (has_add Type)) := sorry --non-trivial
lemma new_lemma_149042 (h0 : uniform_space (complete_distrib_lattice (option ennreal))) : separated_space (complete_distrib_lattice (option ennreal)) := sorry --non-trivial
lemma new_lemma_149043 (h0 : topological_space (random_gen linarith.comp)) : path_connected_space (random_gen linarith.comp) := sorry --non-trivial
lemma new_lemma_149044 (h0 : ring (finset (option unsigned))) : strong_rank_condition (finset (option unsigned)) := sorry --non-trivial
lemma new_lemma_149045 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @strong_rank_condition.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_149046 (h0 : ring (random_gen (has_lt char))) : rank_condition (random_gen (has_lt char)) := sorry --non-trivial
lemma new_lemma_149047 (h0 : functor.add_const (ordered_add_comm_monoid (mul_zero_class empty)) unsigned) : @archimedean.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (mul_zero_class.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_149048 (h0 : not (add_monoid (has_norm fun_info) -> false)) : @add_monoid.fg.{0} (has_norm.{0} fun_info) (@classical.by_contradiction'.{1} (add_monoid.{0} (has_norm.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_149049 (h0 : topological_space (linear_ordered_field congr_arg_kind)) : preconnected_space (linear_ordered_field congr_arg_kind) := sorry --non-trivial
lemma new_lemma_149050 (h0 : ordered_comm_monoid (ring (comm_group (add_cancel_monoid ennreal)))) : has_exists_mul_of_le (ring (comm_group (add_cancel_monoid ennreal))) := sorry --non-trivial
lemma new_lemma_149051 (h0 : fin has_zero.zero) : @separated_space.{0} (sub_neg_monoid.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (sub_neg_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_149052 (h0 : ring (boolean_algebra (normed_comm_ring (boolean_algebra.core Type)))) : is_domain (boolean_algebra (normed_comm_ring (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_149053 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) (finset linarith.comp)) : @discrete_topology.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_149054 (h0 : functor.add_const (topological_space (free_add_monoid num)) unsigned) : @normal_space.{0} (free_add_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_149055 (h0 : uniform_space (semiring (random_gen (random_gen linarith.comp_source)))) : complete_space (semiring (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_149056 (h0 : topological_space (boolean_algebra (has_bot pos))) : path_connected_space (boolean_algebra (has_bot pos)) := sorry --non-trivial
lemma new_lemma_149057 (h0 : complete_lattice (has_zero (finset pos))) : is_compactly_generated (has_zero (finset pos)) := sorry --non-trivial
lemma new_lemma_149058 (h0 : functor.add_const (complete_lattice (cancel_monoid ennreal)) ennreal) : @is_compactly_generated.{0} (cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_149059 (h0 : has_lt (semi_normed_comm_ring std_gen)) : no_max_order (semi_normed_comm_ring std_gen) := sorry --non-trivial
lemma new_lemma_149060 (h0 : semiring (linear_ordered_comm_monoid_with_zero unsigned)) : is_noetherian_ring (linear_ordered_comm_monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_149061 (h0 : functor.add_const (ring (finset pos)) (normed_comm_ring linarith.comp)) : @rank_condition.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} pos)) (normed_comm_ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_149062 (h0 : functor.add_const (monoid (comm_group name)) linarith.comp) : @monoid.fg.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (comm_group.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_149063 (h0 : topological_space (add_comm_monoid (finset environment.implicit_infer_kind))) : irreducible_space (add_comm_monoid (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_149064 (h0 : functor.add_const (group (ordered_comm_monoid linarith.comp)) pos) : @normalizer_condition.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (ordered_comm_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_149065 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_edist empty)) := sorry --non-trivial
lemma new_lemma_149066 (h0 : prod (measure_theory.measure_space congr_arg_kind) (measure_theory.measure_space congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_149067 (h0 : topological_space (linear_order congr_arg_kind)) : loc_path_connected_space (linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_149068 (h0 : monoid (measurable_space (has_top unsigned))) : monoid.fg (measurable_space (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_149069 (h0 : not (topological_space (with_bot linarith.comp) -> false)) : @t0_space.{0} (with_bot.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_149070 (h0 : group (cancel_monoid (option ennreal))) : is_simple_group (cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_149071 (h0 : functor.add_const (topological_space (linear_order unsigned)) empty) : @normal_space.{0} (linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_149072 (h0 : functor.add_const (filter (complete_distrib_lattice linarith.comp)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_149073 (h0 : complete_lattice (ordered_comm_ring (has_pos_part Type))) : is_compactly_generated (ordered_comm_ring (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_149074 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (group.{0} (has_add.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_149075 (h0 : add_group (ring (finset Type))) : is_add_cyclic (ring (finset Type)) := sorry --non-trivial
lemma new_lemma_149076 (h0 : topological_space (has_bot (has_add linarith.comp))) : locally_compact_space (has_bot (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_149077 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (is_R_or_C.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (is_R_or_C.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_149078 (h0 : topological_space (normed_group (random_gen linarith.comp_source))) : locally_compact_space (normed_group (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_149079 (h0 : ring (div_inv_monoid fun_info)) : strong_rank_condition (div_inv_monoid fun_info) := sorry --non-trivial
lemma new_lemma_149080 (h0 : topological_space (add_cancel_monoid (has_add pos))) : topological_space.separable_space (add_cancel_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_149081 (h0 : topological_space (option (semiring (semiring unsigned)))) : discrete_topology (option (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_149082 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_149083 (h0 : function.extfun Type topological_space) : @t1_space.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_149084 (h0 : functor.add_const (ring (boolean_algebra.core pos)) name) : @rank_condition.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_149085 (h0 : functor.add_const (topological_space (simple_graph linarith.comp)) (finset linarith.comp)) : @t1_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} linarith.comp)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_149086 (h0 : ring (has_lt to_additive.value_type)) : rank_condition (has_lt to_additive.value_type) := sorry --non-trivial
lemma new_lemma_149087 (h0 : functor.add_const (list (ordered_comm_monoid linarith.comp)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_149088 (h0 : fin has_zero.zero) : @topological_space.separable_space.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (simple_graph.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_149089 (h0 : topological_space (ordered_comm_ring (sub_neg_monoid Type))) : locally_compact_space (ordered_comm_ring (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_149090 (h0 : group (normed_group (has_norm (has_norm num)))) : normalizer_condition (normed_group (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_149091 (h0 : function.extfun (finset Type) (has_mem.mem (has_top linarith.comp_source))) : @normalizer_condition.{0} (has_top.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type group.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_149092 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_149093 (h0 : functor.add_const (group (semigroup unsigned)) name) : @normalizer_condition.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_149094 (h0 : ring (has_bot (has_Inf name))) : rank_condition (has_bot (has_Inf name)) := sorry --non-trivial
lemma new_lemma_149095 (h0 : filter (cancel_monoid congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_149096 (h2 : measurable_space enat) (h3 : set enat) : measurable_set h3 := sorry --non-trivial
lemma new_lemma_149097 (h0 : topological_space (has_add (ordered_ring pos))) : normal_space (has_add (ordered_ring pos)) := sorry --non-trivial
lemma new_lemma_149098 (h2 : function.extfun Type topological_space) : @locally_compact_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} h2 congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_149099 (h0 : complete_lattice (id (with_bot to_additive.value_type))) : is_compactly_generated (id (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_149100 (h0 : topological_space (has_to_string (option empty))) : preirreducible_space (has_to_string (option empty)) := sorry --non-trivial
lemma new_lemma_149101 (h0 : topological_space (id (has_norm (has_norm fun_info)))) : locally_compact_space (id (has_norm (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_149102 (h0 : add_group (as_linear_order (comm_monoid unsigned))) : is_add_cyclic (as_linear_order (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_149103 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) Type) : @totally_separated_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_149104 (h0 : function.extfun Type group) : @is_simple_group.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (boolean_algebra.core.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_149105 (h0 : functor.add_const (topological_space (has_Inf name)) name) : @totally_separated_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_149106 (h0 : uniform_space (with_one (random_gen (random_gen linarith.comp_source)))) : complete_space (with_one (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_149107 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) linarith.comp) : @t0_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_149108 (h0 : topological_space (comm_monoid string_imp)) : path_connected_space (comm_monoid string_imp) := sorry --non-trivial
lemma new_lemma_149109 (h0 : complete_lattice (has_emptyc (has_inv linarith.comp_source))) : is_compactly_generated (has_emptyc (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_149110 (h0 : functor.add_const (uniform_space (has_nndist pos)) Type) : @separated_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_nndist.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_149111 (h0 : filter (has_nndist (comm_group (comm_group Type)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_149112 (h0 : group (add_monoid linarith.ineq)) : is_cyclic (add_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_149113 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_149114 (h0 : function.extfun Type topological_space) : @t0_space.{0} (partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_149115 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra.core pos)) (comm_group Type)) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (boolean_algebra.core.{0} pos)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_149116 (h0 : ring (has_nnnorm (mul_one_class char))) : is_domain (has_nnnorm (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_149117 (h0 : not (uniform_space (has_append reducibility_hints) -> false)) : @complete_space.{0} (has_append.{0} reducibility_hints) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_append.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_149118 (h0 : topological_space (add_cancel_monoid name)) : t0_space (add_cancel_monoid name) := sorry --non-trivial
lemma new_lemma_149119 (h0 : function.extfun Type ring) : @rank_condition.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_149120 (h0 : topological_space (finset (finset (has_Inf Type)))) : discrete_topology (finset (finset (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_149121 (h0 : group (comm_ring char)) : group.fg (comm_ring char) := sorry --non-trivial
lemma new_lemma_149122 (h0 : group (normed_lattice_add_comm_group (has_Inf Type))) : normalizer_condition (normed_lattice_add_comm_group (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_149123 (h0 : topological_space (linear_ordered_comm_group (option congr_arg_kind))) : loc_path_connected_space (linear_ordered_comm_group (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_149124 (h0 : topological_space (ring (option unsigned))) : loc_path_connected_space (ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_149125 (h0 : filter (complete_semilattice_Sup (semiring (has_norm (has_norm (semiring empty)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_149126 (h0 : topological_space (finset (option empty))) : t0_space (finset (option empty)) := sorry --non-trivial
lemma new_lemma_149127 (h0 : functor.add_const (topological_space (complete_linear_order num)) num) : @totally_disconnected_space.{0} (complete_linear_order.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_linear_order.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_149128 (h0 : complete_lattice (uniform_space (mul_one_class to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (uniform_space (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_149129 (h0 : topological_space char) (h1 : uniform_space (topological_space.compacts char)) : complete_space (topological_space.compacts char) := sorry --non-trivial
lemma new_lemma_149130 (h0 h1 : semiring linarith.ineq) (h2 : heq h1 h0) (h3 : ideal linarith.ineq) : @ideal.is_prime.{0} linarith.ineq h0 (@heq.elim.{1 1} (semiring.{0} linarith.ineq) h1 (@ideal.{0} linarith.ineq) h0 h2 h3)  := sorry --non-trivial
lemma new_lemma_149131 (h0 : topological_space (ordered_comm_monoid Type)) : irreducible_space (ordered_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_149132 (h0 : group (linear_ordered_semiring congr_arg_kind)) : is_cyclic (linear_ordered_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_149133 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_149134 (h0 : topological_space (nondiscrete_normed_field (mul_one_class linarith.ineq))) (h1 : add_group (nondiscrete_normed_field (mul_one_class linarith.ineq))) : topological_add_group (nondiscrete_normed_field (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_149135 (h0 : topological_space (dlist string_imp)) (h1 : function.extfun (dlist string_imp) (fun (x : dlist string_imp), Prop)) : is_preirreducible (function.extfun_app h1) := sorry --non-trivial
lemma new_lemma_149136 (h0 : topological_space (has_dist empty)) : loc_path_connected_space (has_dist empty) := sorry --non-trivial
lemma new_lemma_149137 (h0 : group (complete_distrib_lattice (has_to_string congr_arg_kind))) : group.fg (complete_distrib_lattice (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_149138 (h0 : topological_space (has_ssubset (has_inv linarith.comp_source))) : totally_separated_space (has_ssubset (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_149139 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_149140 (h0 : topological_space (comm_monoid unsigned)) : normal_space (comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_149141 (h0 : functor.add_const (semiring (simple_graph pos)) (ring linarith.comp)) : @is_noetherian_ring.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (simple_graph.{0} pos)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_149142 (h0 : topological_space (sub_neg_monoid (has_add (has_Inf (has_add linarith.comp))))) : topological_space.separable_space (sub_neg_monoid (has_add (has_Inf (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_149143 (h0 : topological_space (canonically_linear_ordered_monoid (option (option (option ennreal))))) : discrete_topology (canonically_linear_ordered_monoid (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_149144 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_add.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_149145 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_149146 (h0 : functor.add_const (list (has_neg_part Type)) environment.implicit_infer_kind) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_149147 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} unsigned (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 unsigned)  := sorry --non-trivial
lemma new_lemma_149148 (h0 : fin has_zero.zero) : @loc_path_connected_space.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (sub_neg_monoid.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_149149 (h0 : set (add_comm_semigroup fun_info -> std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_149150 (h0 : ordered_comm_monoid (add_comm_monoid (finset name))) : has_exists_mul_of_le (add_comm_monoid (finset name)) := sorry --non-trivial
lemma new_lemma_149151 (h0 : functor.add_const (topological_space (has_zero name)) Type) : @irreducible_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_149152 (h0 : prod (metric_space (semiring (semiring unsigned))) (metric_space (semiring (semiring unsigned)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_149153 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_149154 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring unsigned)) Type) : @preirreducible_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (canonically_ordered_comm_semiring.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_149155 (h0 : monoid (has_to_string (normed_comm_ring environment.implicit_infer_kind))) : monoid.fg (has_to_string (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_149156 (h0 : monoid (normed_comm_ring (boolean_algebra.core (has_add name)))) : monoid.fg (normed_comm_ring (boolean_algebra.core (has_add name))) := sorry --non-trivial
lemma new_lemma_149157 (h0 : has_neg (has_compl environment.projection_info)) (h1 : measurable_space (has_compl environment.projection_info)) : has_measurable_neg (has_compl environment.projection_info) := sorry --non-trivial
lemma new_lemma_149158 (h0 : semiring (semigroup (ring Type))) : is_noetherian_ring (semigroup (ring Type)) := sorry --non-trivial
lemma new_lemma_149159 (h0 : group (canonically_ordered_comm_semiring (option (option empty)))) : group.fg (canonically_ordered_comm_semiring (option (option empty))) := sorry --non-trivial
lemma new_lemma_149160 (h0 : group (comm_group Type)) : is_simple_group (comm_group Type) := sorry --non-trivial
lemma new_lemma_149161 (h0 : functor.add_const (complete_lattice (complete_semilattice_Sup num)) num) : @is_atomistic.{0} (complete_semilattice_Sup.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (complete_semilattice_Sup.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_149162 (h0 : ordered_add_comm_monoid (pseudo_metric_space num)) : archimedean (pseudo_metric_space num) := sorry --non-trivial
lemma new_lemma_149163 (h0 : not (topological_space (measurable_space.dynkin_system congr_arg_kind) -> false)) : @discrete_topology.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_149164 (h0 : functor.add_const (ordered_comm_monoid (ring name)) name) : @has_exists_mul_of_le.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_149165 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_149166 (h0 : ring (has_ssubset (has_nnnorm char))) : strong_rank_condition (has_ssubset (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_149167 (h0 : uniform_space (topological_space (comm_ring (comm_ring char)))) : complete_space (topological_space (comm_ring (comm_ring char))) := sorry --non-trivial
lemma new_lemma_149168 (h0 : group (has_ssubset (has_nnnorm (mul_one_class reducibility_hints)))) : is_cyclic (has_ssubset (has_nnnorm (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_149169 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_neg_part.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_149170 (h0 : ordered_add_comm_monoid (has_neg (option pos))) : archimedean (has_neg (option pos)) := sorry --non-trivial
lemma new_lemma_149171 (h0 : add_monoid (add_comm_monoid (option (option (option unsigned))))) : add_monoid.fg (add_comm_monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_149172 (h0 : function.extfun (finset Type) (has_mem.mem fun_info)) : @path_connected_space.{0} fun_info (@finset.pi.empty.{1 0} Type topological_space.{0} fun_info (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) fun_info) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_149173 (h0 : list (ring (has_add (normed_comm_ring (has_add name))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_149174 (h0 : ring (filter (semiring empty))) : is_principal_ideal_ring (filter (semiring empty)) := sorry --non-trivial
lemma new_lemma_149175 (h0 : topological_space (finset (finset (finset (finset name))))) : regular_space (finset (finset (finset (finset name)))) := sorry --non-trivial
lemma new_lemma_149176 (h0 : list (semi_normed_comm_ring (has_ssubset (distrib_lattice (with_one string_imp))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_149177 (h0 : ordered_comm_monoid (pseudo_metric_space name)) : has_exists_mul_of_le (pseudo_metric_space name) := sorry --non-trivial
lemma new_lemma_149178 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_149179 (h0 : ring (comm_ring (power_series char))) : rank_condition (comm_ring (power_series char)) := sorry --non-trivial
lemma new_lemma_149180 (h0 : set (std_gen -> add_comm_semigroup std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_149181 (h0 : has_mem.mem (metric_space empty) has_emptyc.emptyc) : @totally_disconnected_space.{0} (metric_space.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (metric_space.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_149182 (h0 : list (finset num)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_149183 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_149184 (h0 : functor.add_const (uniform_space (mul_zero_class Type)) Type) : @complete_space.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (mul_zero_class.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_149185 (h1 : group (distrib (has_nnnorm (has_inv linarith.comp_source)))) : is_cyclic (distrib (has_nnnorm (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_149186 (h0 : group (has_mul to_additive.value_type)) : is_cyclic (has_mul to_additive.value_type) := sorry --non-trivial
lemma new_lemma_149187 (h0 : functor.comp complete_lattice add_cancel_monoid Type) : @complete_lattice.is_Sup_finite_compact.{1} (add_cancel_monoid.{1} Type) (@functor.comp.run.{1 1 1} complete_lattice.{1} add_cancel_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_149188 (h0 : ordered_comm_monoid (is_R_or_C pos)) : has_exists_mul_of_le (is_R_or_C pos) := sorry --non-trivial
lemma new_lemma_149189 (h0 : functor.add_const (function.extfun Type group) Type) : @is_simple_group.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_149190 (h0 : topological_space (simple_graph (has_neg name))) : preirreducible_space (simple_graph (has_neg name)) := sorry --non-trivial
lemma new_lemma_149191 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_149192 (h0 : filter (random_gen (random_gen linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_149193 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_149194 (h6 : not (complete_lattice (denumerable linarith.ineq) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (denumerable.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (denumerable.{0} linarith.ineq)) h6)  := sorry --non-trivial
lemma new_lemma_149195 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (mul_zero_class ennreal)) := sorry --non-trivial
lemma new_lemma_149196 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_nndist Type)) pos) : @unique_factorization_monoid.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (has_nndist.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_149197 (h0 : group (cancel_monoid num)) : is_cyclic (cancel_monoid num) := sorry --non-trivial
lemma new_lemma_149198 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) linarith.comp) : @preconnected_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_149199 (h0 : functor.add_const (ring (has_to_string pos)) name) : @rank_condition.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_149200 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @normal_space.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_149201 (h0 : cancel_comm_monoid_with_zero (ordered_cancel_add_comm_monoid congr_arg_kind)) : unique_factorization_monoid (ordered_cancel_add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_149202 (h0 : ulower (fin has_zero.zero)) : @ulower.up.{0} Prop encodable.Prop (@matrix.vec_empty.{0} (@ulower.{0} Prop encodable.Prop) (@id.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@id.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@ulower.up.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (encodable.fin (@has_zero.zero.{0} nat nat.has_zero)) h0))))))  := sorry --non-trivial
lemma new_lemma_149203 (h0 : complete_lattice (measurable_space (with_bot string_imp))) : complete_lattice.is_Sup_finite_compact (measurable_space (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_149204 (h0 : ring (normed_lattice_add_comm_group (has_neg real))) : strong_rank_condition (normed_lattice_add_comm_group (has_neg real)) := sorry --non-trivial
lemma new_lemma_149205 (h0 : functor.add_const (list (add_cancel_monoid pos)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_149206 (h0 : semiring (preorder empty)) : is_noetherian_ring (preorder empty) := sorry --non-trivial
lemma new_lemma_149207 (h0 : group (normed_field (random_gen reducibility_hints))) : is_cyclic (normed_field (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_149208 (h0 : ring (has_neg (normed_comm_ring environment.implicit_infer_kind))) : is_domain (has_neg (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_149209 (h0 : ring (has_add (finset (add_comm_monoid name)))) : is_principal_ideal_ring (has_add (finset (add_comm_monoid name))) := sorry --non-trivial
lemma new_lemma_149210 (h0 : topological_space (finset (has_zero pos))) : discrete_topology (finset (has_zero pos)) := sorry --non-trivial
lemma new_lemma_149211 (h0 : group (has_top to_additive.value_type)) : is_cyclic (has_top to_additive.value_type) := sorry --non-trivial
lemma new_lemma_149212 (h1 : topological_space (has_emptyc linarith.comp)) : t0_space (has_emptyc linarith.comp) := sorry --non-trivial
lemma new_lemma_149213 (h0 : has_lt (semi_normed_ring (normed_field std_gen))) : no_max_order (semi_normed_ring (normed_field std_gen)) := sorry --non-trivial
lemma new_lemma_149214 (h0 : add_monoid (linear_ordered_semiring (has_norm (has_norm empty)))) : add_monoid.fg (linear_ordered_semiring (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_149215 (h0 : functor.add_const Prop (finset (has_add name))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_149216 (h0 : functor.add_const (ordered_comm_monoid (add_cancel_monoid Type)) linarith.comp) : @has_exists_mul_of_le.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (add_cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_149217 (h0 : uniform_space (has_zero (has_neg_part Type))) : complete_space (has_zero (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_149218 (h0 : ring (comm_group (cancel_monoid (has_to_string (option ennreal))))) : rank_condition (comm_group (cancel_monoid (has_to_string (option ennreal)))) := sorry --non-trivial
lemma new_lemma_149219 (h0 : topological_space (has_norm (semiring (semiring congr_arg_kind)))) : totally_disconnected_space (has_norm (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_149220 (h0 : topological_space (has_union num)) : normal_space (has_union num) := sorry --non-trivial
lemma new_lemma_149221 (h0 : ring (add_left_cancel_monoid (random_gen to_additive.value_type))) : is_domain (add_left_cancel_monoid (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_149222 (h0 : ring (denumerable (random_gen fun_info))) : rank_condition (denumerable (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_149223 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) (has_neg environment.implicit_infer_kind)) : @totally_separated_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_149224 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (linear_ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_149225 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (linear_ordered_field.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_field.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_149226 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (left_cancel_semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_149227 (h0 : functor.add_const (uniform_space (complete_distrib_lattice Type)) pos) : @separated_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (complete_distrib_lattice.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_149228 (h1 : preorder environment.implicit_infer_kind) (h2 : set environment.implicit_infer_kind) : set.is_pwo h2 := sorry --non-trivial
lemma new_lemma_149229 (h0 : group (ring linarith.comp)) : is_cyclic (ring linarith.comp) := sorry --non-trivial
lemma new_lemma_149230 (h0 : functor.add_const (ordered_add_comm_monoid (normed_comm_ring linarith.comp)) Type) : @archimedean.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (normed_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_149231 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @rank_condition.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_149232 (h0 : group (has_add (sub_neg_monoid (has_add (has_bot pos))))) : group.fg (has_add (sub_neg_monoid (has_add (has_bot pos)))) := sorry --non-trivial
lemma new_lemma_149233 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @normalizer_condition.{0} (with_bot.{0} (comm_ring.{0} (has_top.{0} (random_gen.{0} (has_inv.{0} linarith.ineq))))) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (with_bot.{0} (comm_ring.{0} (has_top.{0} (random_gen.{0} (has_inv.{0} linarith.ineq))))))  := sorry --non-trivial
lemma new_lemma_149234 (h0 : function.extfun Type group) : @normalizer_condition.{0} (linear_ordered_comm_monoid_with_zero.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_149235 (h0 : ring (add_monoid linarith.comp_source)) : strong_rank_condition (add_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_149236 (h0 : group (has_norm (has_norm (has_norm linarith.comp_source)))) : is_cyclic (has_norm (has_norm (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_149237 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preirreducible_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_149238 (h0 : uniform_space (boolean_algebra.core name)) : separated_space (boolean_algebra.core name) := sorry --non-trivial
lemma new_lemma_149239 (h0 : functor.add_const (topological_space (boolean_algebra.core linarith.comp)) linarith.comp) : @path_connected_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_149240 (h0 : prod (has_add congr_arg_kind) (has_add congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_149241 (h0 : topological_space (has_nndist (has_add (has_add pos)))) : preconnected_space (has_nndist (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_149242 (h0 : topological_space (has_inv linarith.ineq)) : irreducible_space (has_inv linarith.ineq) := sorry --non-trivial
lemma new_lemma_149243 (h0 : functor.add_const (topological_space (add_comm_monoid name)) Type) : @normal_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_149244 (h0 : monoid (id (semiring (semiring unsigned)))) : monoid.fg (id (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_149245 (h0 : topological_space (normed_comm_ring (add_cancel_monoid (has_to_string pos)))) : totally_disconnected_space (normed_comm_ring (add_cancel_monoid (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_149246 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (measurable_space.{0} (has_top.{0} (has_inv.{0} (has_top.{0} (has_inv.{0} linarith.comp_source))))) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (measurable_space.{0} (has_top.{0} (has_inv.{0} (has_top.{0} (has_inv.{0} linarith.comp_source))))))  := sorry --non-trivial
lemma new_lemma_149247 (h0 : group (comm_monoid (option unsigned))) : is_cyclic (comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_149248 (h0 : uniform_space (generalized_boolean_algebra (has_neg real))) : separated_space (generalized_boolean_algebra (has_neg real)) := sorry --non-trivial
lemma new_lemma_149249 (h0 : cancel_comm_monoid_with_zero (option (option unsigned))) : unique_factorization_monoid (option (option unsigned)) := sorry --non-trivial
lemma new_lemma_149250 (h0 : functor.add_const (complete_lattice (has_zero name)) Type) : @is_atomistic.{0} (has_zero.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_zero.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_149251 (h0 : uniform_space (has_neg (semiring empty))) : separated_space (has_neg (semiring empty)) := sorry --non-trivial
lemma new_lemma_149252 (h0 : functor.add_const Prop (ring pos)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_149253 (h0 : functor.add_const (ordered_add_comm_monoid (add_comm_monoid linarith.comp)) pos) : @archimedean.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_comm_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_149254 (h0 : function.extfun Type ring) : @is_domain.{0} (has_inv.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_inv.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_149255 (h0 : functor.add_const (monoid (as_linear_order unsigned)) empty) : @monoid.fg.{0} (as_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (as_linear_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_149256 (h0 : complete_lattice (has_append (metric_space (metric_space to_additive.value_type)))) : is_compactly_generated (has_append (metric_space (metric_space to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_149257 (h0 : functor.add_const (topological_space znum) num) : @topological_space.separable_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) num h0)  := sorry --non-trivial
lemma new_lemma_149258 (h0 : group (complete_distrib_lattice (finset (finset environment.implicit_infer_kind)))) : is_cyclic (complete_distrib_lattice (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_149259 (h0 : topological_space (has_bot (sub_neg_monoid real))) : sequential_space (has_bot (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_149260 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) Type) : @totally_disconnected_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_149261 (h0 : topological_space (semiring linarith.comp)) : topological_space.separable_space (semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_149262 (h0 : topological_space (complete_semilattice_Sup char)) : totally_disconnected_space (complete_semilattice_Sup char) := sorry --non-trivial
lemma new_lemma_149263 (h0 : functor.add_const (topological_space (cancel_monoid environment.implicit_infer_kind)) linarith.comp) : @preirreducible_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_149264 (h0 : topological_space (has_sub linarith.comp)) : t0_space (has_sub linarith.comp) := sorry --non-trivial
lemma new_lemma_149265 (h0 : string_imp -> string_imp -> Prop) : is_extensional string_imp h0 := sorry --non-trivial
lemma new_lemma_149266 (h1 : complete_lattice (metric_space linarith.comp)) : is_atomistic (metric_space linarith.comp) := sorry --non-trivial
lemma new_lemma_149267 (h1 : ring (option (comm_group char))) : rank_condition (option (comm_group char)) := sorry --non-trivial
lemma new_lemma_149268 (h0 : add_group (has_nnnorm (mul_one_class (has_to_string environment.projection_info)))) : is_add_cyclic (has_nnnorm (mul_one_class (has_to_string environment.projection_info))) := sorry --non-trivial
lemma new_lemma_149269 (h0 : not (ring (complete_semilattice_Sup fun_info) -> false)) : @rank_condition.{0} (complete_semilattice_Sup.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (complete_semilattice_Sup.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_149270 (h0 : functor.add_const (cancel_comm_monoid_with_zero (semigroup pos)) pos) : @unique_factorization_monoid.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (semigroup.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_149271 (h0 : topological_space (distrib_lattice (random_gen (random_gen (random_gen linarith.ineq))))) : locally_compact_space (distrib_lattice (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_149272 (h0 : not (topological_space (semi_normed_comm_ring string_imp) -> false)) : @totally_disconnected_space.{0} (semi_normed_comm_ring.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_comm_ring.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_149273 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra.core pos)) Type) : @archimedean.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (boolean_algebra.core.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_149274 (h0 : topological_space (boolean_algebra (has_add name))) : t0_space (boolean_algebra (has_add name)) := sorry --non-trivial
lemma new_lemma_149275 (h0 : topological_space (has_bot name)) : preconnected_space (has_bot name) := sorry --non-trivial
lemma new_lemma_149276 (h0 : topological_space (has_div fun_info)) (h1 : not (add_group (has_div fun_info) -> false)) : @topological_add_group.{0} (has_div.{0} fun_info) h0 (@classical.by_contradiction'.{1} (add_group.{0} (has_div.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_149277 (h0 : add_monoid (complete_semilattice_Sup (semiring empty))) : add_monoid.fg (complete_semilattice_Sup (semiring empty)) := sorry --non-trivial
lemma new_lemma_149278 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (complete_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (complete_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_149279 (h0 : ring (has_le (mul_one_class fun_info))) : is_domain (has_le (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_149280 (h0 : functor.add_const (uniform_space (ordered_comm_ring pos)) name) : @separated_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_comm_ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_149281 (h0 : monoid (finset (finset linarith.comp))) : monoid.fg (finset (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_149282 (h0 : monoid (boolean_algebra.core (has_add environment.implicit_infer_kind))) : monoid.fg (boolean_algebra.core (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_149283 (h0 : complete_lattice (monoid (option (option congr_arg_kind)))) : is_atomistic (monoid (option (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_149284 (h0 : topological_space (boolean_algebra (has_neg_part name))) : t1_space (boolean_algebra (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_149285 (h0 : monoid (has_inv fun_info)) : monoid.fg (has_inv fun_info) := sorry --non-trivial
lemma new_lemma_149286 (h0 : uniform_space (boolean_algebra.core congr_arg_kind)) : complete_space (boolean_algebra.core congr_arg_kind) := sorry --non-trivial
lemma new_lemma_149287 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_149288 (h0 : topological_space (boolean_algebra (has_to_string pos))) : irreducible_space (boolean_algebra (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_149289 (h0 : topological_space (sub_neg_monoid (boolean_algebra.core pos))) : topological_space.separable_space (sub_neg_monoid (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_149290 (h0 : ring (linear_ordered_semiring (semiring (semiring (has_top (semiring congr_arg_kind)))))) : rank_condition (linear_ordered_semiring (semiring (semiring (has_top (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_149291 (h0 : functor.comp topological_space canonically_ordered_comm_semiring name) : @normal_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_149292 (h0 : not (topological_space (linear_ordered_comm_ring congr_arg_kind) -> false)) : @irreducible_space.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_ring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_149293 (h0 : group (denumerable (has_nnnorm (has_nnnorm char)))) : group.fg (denumerable (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_149294 (h0 : not (add_monoid (non_assoc_semiring congr_arg_kind) -> false)) : @add_monoid.fg.{0} (non_assoc_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_monoid.{0} (non_assoc_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_149295 (h0 : semiring (has_bot (has_add (has_add real)))) : is_noetherian_ring (has_bot (has_add (has_add real))) := sorry --non-trivial
lemma new_lemma_149296 (h0 : ring (has_nnnorm (random_gen to_additive.value_type))) : rank_condition (has_nnnorm (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_149297 (h0 : functor.add_const (topological_space (normed_comm_ring name)) Type) : @path_connected_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_149298 (h0 : fin has_zero.zero) : @complete_space.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (simple_graph.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_149299 (h0 : add_group (free_add_monoid (option (option unsigned)))) : is_add_cyclic (free_add_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_149300 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_inv.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inv.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_149301 (h0 : topological_space (simple_graph (canonically_linear_ordered_monoid (has_Inf real)))) : normal_space (simple_graph (canonically_linear_ordered_monoid (has_Inf real))) := sorry --non-trivial
lemma new_lemma_149302 (h0 : function.extfun nat fin) : @monoid.fg.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (monoid.{1} (ordered_comm_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_149303 (h0 : topological_space (has_top (random_gen (random_gen linarith.comp_source)))) : t0_space (has_top (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_149304 (h0 : ordered_comm_monoid (cancel_monoid unsigned)) : has_exists_mul_of_le (cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_149305 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (linear_ordered_cancel_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_cancel_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_149306 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_149307 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_Sup.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_149308 (h0 : cancel_comm_monoid_with_zero (normed_comm_ring (finset (finset linarith.comp)))) : unique_factorization_monoid (normed_comm_ring (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_149309 (h0 : group (with_one fun_info)) : is_cyclic (with_one fun_info) := sorry --non-trivial
lemma new_lemma_149310 (h0 : topological_space (has_to_string (cancel_monoid pos))) : loc_path_connected_space (has_to_string (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_149311 (h0 : topological_space (add_comm_monoid (comm_semigroup real))) : locally_compact_space (add_comm_monoid (comm_semigroup real)) := sorry --non-trivial
lemma new_lemma_149312 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (finset unsigned)) := sorry --non-trivial
lemma new_lemma_149313 (h0 : topological_space (comm_semigroup Type)) : sequential_space (comm_semigroup Type) := sorry --non-trivial
lemma new_lemma_149314 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (simple_graph.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_149315 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring name)) pos) : @totally_disconnected_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_149316 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_149317 (h0 : topological_space (has_nndist (has_nndist (complete_distrib_lattice name)))) : path_connected_space (has_nndist (has_nndist (complete_distrib_lattice name))) := sorry --non-trivial
lemma new_lemma_149318 (h0 : functor.add_const (topological_space (has_Inf name)) (ordered_ring name)) : @normal_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} name)) (ordered_ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_149319 (h0 : functor.add_const (filter (has_to_string linarith.comp)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_149320 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (as_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (as_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_149321 (h0 : add_group (free_add_monoid unsigned)) : is_add_cyclic (free_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_149322 (h0 : topological_space (has_bot (has_bot real))) : path_connected_space (has_bot (has_bot real)) := sorry --non-trivial
lemma new_lemma_149323 (h0 : functor.add_const (ordered_add_comm_monoid (canonically_ordered_comm_semiring linarith.comp)) linarith.comp) : @archimedean.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_149324 (h0 : functor.add_const (add_monoid (has_Sup unsigned)) unsigned) : @add_monoid.fg.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_Sup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_149325 (h1 : ring (distrib_lattice char)) : is_domain (distrib_lattice char) := sorry --non-trivial
lemma new_lemma_149326 (h0 : topological_space (has_nndist pos)) : irreducible_space (has_nndist pos) := sorry --non-trivial
lemma new_lemma_149327 (h0 : topological_space (with_bot (random_gen string_imp))) : locally_compact_space (with_bot (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_149328 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (boolean_algebra.core.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_149329 (h0 : prod (has_star empty) (has_star empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_149330 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_149331 (h0 : list (linear_ordered_comm_ring (semiring (semiring num)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_149332 (h0 : group (add_semigroup empty)) : group.fg (add_semigroup empty) := sorry --non-trivial
lemma new_lemma_149333 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) pos) : @loc_path_connected_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_149334 (h0 : finset (has_Inf (has_nndist (has_neg name)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_149335 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) Type) : @t1_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_149336 (h0 : functor.add_const (complete_lattice (normed_lattice_add_comm_group name)) (has_add pos)) : @is_compactly_generated.{0} (normed_lattice_add_comm_group.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_lattice_add_comm_group.{0} name)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_149337 (h0 : group (has_to_string linarith.comp)) : normalizer_condition (has_to_string linarith.comp) := sorry --non-trivial
lemma new_lemma_149338 (h0 : group (semigroup (normed_comm_ring pos))) : normalizer_condition (semigroup (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_149339 (h0 : function.extfun Type (prod (simple_graph empty))) : id_rel (function.extfun_app h0 (simple_graph empty)) := sorry --non-trivial
lemma new_lemma_149340 (h0 : not (topological_space (option empty) -> false)) : @path_connected_space.{0} (option.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_149341 (h0 : function.extfun Type ring) : @is_domain.{0} (normed_linear_ordered_group.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_linear_ordered_group.{0} num))  := sorry --non-trivial
lemma new_lemma_149342 (h0 : finset (ring (boolean_algebra Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_149343 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_edist unsigned)) := sorry --non-trivial
lemma new_lemma_149344 (h0 : group (has_add environment.implicit_infer_kind)) : is_cyclic (has_add environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_149345 (h0 : topological_space (denumerable (topological_space (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))))) : t0_space (denumerable (topological_space (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_149346 (h0 : functor.add_const (list (semigroup pos)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_149347 (h0 : topological_space (has_append (has_nnnorm (mul_one_class char)))) : path_connected_space (has_append (has_nnnorm (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_149348 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @has_exists_mul_of_le.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ordered_comm_monoid.{1}) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_149349 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @strong_rank_condition.{0} congr_arg_kind (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_149350 (h0 : functor.add_const (function.extfun Type filter) pos) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_149351 (h0 : functor.comp topological_space boolean_algebra.core (finset environment.implicit_infer_kind)) : @t1_space.{0} (boolean_algebra.core.{0} (finset.{0} environment.implicit_infer_kind)) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_149352 (h0 : functor.add_const (ordered_comm_monoid (has_pos_part name)) (finset (has_pos_part pos))) : @has_exists_mul_of_le.{0} (has_pos_part.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_pos_part.{0} name)) (finset.{0} (has_pos_part.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_149353 (h0 : filter (semigroup (finset name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_149354 (h1 : uniform_space (distrib_lattice (with_bot (with_bot linarith.comp_source)))) : complete_space (distrib_lattice (with_bot (with_bot linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_149355 (h0 : ordered_add_comm_monoid (has_neg (option ennreal))) : archimedean (has_neg (option ennreal)) := sorry --non-trivial
lemma new_lemma_149356 (h0 : topological_space ereal) (h2 : preorder ereal) : order_closed_topology ereal := sorry --non-trivial
lemma new_lemma_149357 (h0 : ring (finset (finset pos))) : strong_rank_condition (finset (finset pos)) := sorry --non-trivial
lemma new_lemma_149358 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (boolean_algebra.core.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} num))  := sorry --non-trivial
lemma new_lemma_149359 (h0 : add_group (nondiscrete_normed_field fun_info)) : is_add_cyclic (nondiscrete_normed_field fun_info) := sorry --non-trivial
lemma new_lemma_149360 (h0 : functor.add_const (topological_space (add_cancel_monoid empty)) empty) : @preirreducible_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_149361 (h0 : list (dlist (has_nnnorm (random_gen fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_149362 (h0 : add_group (semigroup (measurable_space.dynkin_system name))) : is_add_cyclic (semigroup (measurable_space.dynkin_system name)) := sorry --non-trivial
lemma new_lemma_149363 (h1 : uniform_space (add_monoid (has_nnnorm linarith.comp_source))) : complete_space (add_monoid (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_149364 (h0 : ordered_comm_monoid (has_add (has_neg_part Type))) : has_exists_mul_of_le (has_add (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_149365 (h0 : group (comm_group (has_add Type))) : group.fg (comm_group (has_add Type)) := sorry --non-trivial
lemma new_lemma_149366 (h0 : uniform_space (with_one (has_norm (has_inv (random_gen linarith.comp_source))))) : complete_space (with_one (has_norm (has_inv (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_149367 (h0 : add_monoid (complete_distrib_lattice pos)) : add_monoid.fg (complete_distrib_lattice pos) := sorry --non-trivial
lemma new_lemma_149368 (h0 : ring (has_union (semiring (has_norm empty)))) : rank_condition (has_union (semiring (has_norm empty))) := sorry --non-trivial
lemma new_lemma_149369 (h0 : functor.comp group has_to_string Type) : @is_cyclic.{1} (has_to_string.{1} Type) (@functor.comp.run.{1 1 1} group.{1} has_to_string.{1} Type (@functor.comp.run.{1 1 1} group.{1} has_to_string.{1} Type h0))  := sorry --non-trivial
lemma new_lemma_149370 (h0 : functor.add_const (topological_space (partial_order (option unsigned))) empty) : @topological_space.separable_space.{0} (partial_order.{0} (option.{0} unsigned)) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} (option.{0} unsigned))) empty h0)  := sorry --non-trivial
lemma new_lemma_149371 (h0 : ring (partial_order (semiring (semiring (semiring empty))))) : rank_condition (partial_order (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_149372 (h0 : uniform_space (has_Inf (has_neg pos))) : separated_space (has_Inf (has_neg pos)) := sorry --non-trivial
lemma new_lemma_149373 (h0 : topological_space (normed_comm_ring (boolean_algebra unsigned))) : totally_separated_space (normed_comm_ring (boolean_algebra unsigned)) := sorry --non-trivial
lemma new_lemma_149374 (h0 : ring (generalized_boolean_algebra (sub_neg_monoid (has_Inf real)))) : is_domain (generalized_boolean_algebra (sub_neg_monoid (has_Inf real))) := sorry --non-trivial
lemma new_lemma_149375 (h0 : functor.add_const (topological_space (has_pos_part pos)) Type) : @totally_separated_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_pos_part.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_149376 (h0 : not (uniform_space (add_group congr_arg_kind) -> false)) : @separated_space.{0} (add_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (add_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_149377 (h0 : functor.add_const (list (has_zero linarith.comp)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_149378 (h0 : topological_space (canonically_linear_ordered_monoid (mul_zero_class ennreal))) : t0_space (canonically_linear_ordered_monoid (mul_zero_class ennreal)) := sorry --non-trivial
lemma new_lemma_149379 (h0 : complete_lattice (with_bot (semiring (has_top (semiring linarith.comp))))) : is_compactly_generated (with_bot (semiring (has_top (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_149380 (h0 : group (with_bot (random_gen linarith.ineq))) : is_cyclic (with_bot (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_149381 (h0 : functor.add_const (ring (add_comm_monoid name)) linarith.comp) : @rank_condition.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_149382 (h0 : ring (normed_lattice_add_comm_group real)) : is_domain (normed_lattice_add_comm_group real) := sorry --non-trivial
lemma new_lemma_149383 (h0 : functor.add_const (topological_space (has_neg_part Type)) name) : @regular_space.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg_part.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_149384 (h0 : group (generalized_boolean_algebra (has_add pos))) : is_simple_group (generalized_boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_149385 (h0 : complete_lattice (denumerable (random_gen num))) : complete_lattice.is_Sup_finite_compact (denumerable (random_gen num)) := sorry --non-trivial
lemma new_lemma_149386 (h0 : functor.add_const (complete_lattice (ring linarith.comp)) environment.implicit_infer_kind) : @is_compactly_generated.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_149387 (h0 : complete_lattice (ordered_comm_ring (has_add Type))) : is_compactly_generated (ordered_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_149388 (h0 : ordered_add_comm_monoid (cancel_monoid (normed_comm_ring unsigned))) : archimedean (cancel_monoid (normed_comm_ring unsigned)) := sorry --non-trivial
lemma new_lemma_149389 (h0 : uniform_space (complete_semilattice_Sup (random_gen (random_gen string_imp)))) : complete_space (complete_semilattice_Sup (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_149390 (h0 : uniform_space (cancel_monoid (option empty))) : complete_space (cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_149391 (h0 : functor.add_const (topological_space (add_comm_monoid name)) name) : @irreducible_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_149392 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_149393 (h0 : topological_space (has_union (semiring num))) : t0_space (has_union (semiring num)) := sorry --non-trivial
lemma new_lemma_149394 (h1 : group (measurable_space linarith.comp)) : normalizer_condition (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_149395 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @t1_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_149396 (h0 : ring (canonically_ordered_comm_semiring (comm_group Type))) : strong_rank_condition (canonically_ordered_comm_semiring (comm_group Type)) := sorry --non-trivial
lemma new_lemma_149397 (h0 : group (linear_ordered_field num)) : is_cyclic (linear_ordered_field num) := sorry --non-trivial
lemma new_lemma_149398 (h1 : set (has_compl linarith.comp_source)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_149399 (h0 : fin has_zero.zero) : @preconnected_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_149400 (h0 : finset (has_to_string (option Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_149401 (h0 : functor.add_const (topological_space (has_to_string name)) pos) : @sequential_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_149402 (h0 : complete_lattice (uniform_space reducibility_hints)) : is_compactly_generated (uniform_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_149403 (h0 : semiring (has_inv congr_arg_kind) -> semiring (has_inv congr_arg_kind) -> Prop) (h1 : set (semiring (has_inv congr_arg_kind))) : set.unbounded h0 h1 := sorry --non-trivial
lemma new_lemma_149404 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} to_additive.value_type (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_149405 (h0 : topological_space (has_add ennreal)) : preconnected_space (has_add ennreal) := sorry --non-trivial
lemma new_lemma_149406 (h0 : functor.add_const (group (has_neg pos)) (has_to_string (has_to_string (has_to_string (has_to_string Type))))) : @group.fg.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (has_neg.{0} pos)) (has_to_string.{1} (has_to_string.{1} (has_to_string.{1} (has_to_string.{1} Type)))) h0)  := sorry --non-trivial
lemma new_lemma_149407 (h0 : ordered_add_comm_monoid (ordered_comm_ring (finset (finset (has_add pos))))) : archimedean (ordered_comm_ring (finset (finset (has_add pos)))) := sorry --non-trivial
lemma new_lemma_149408 (h0 : topological_space (add_cancel_monoid (has_to_string unsigned))) : t0_space (add_cancel_monoid (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_149409 (h0 : add_group (has_top empty)) : is_add_cyclic (has_top empty) := sorry --non-trivial
lemma new_lemma_149410 (h0 : ring (left_cancel_semigroup (semiring (left_cancel_semigroup congr_arg_kind)))) : is_domain (left_cancel_semigroup (semiring (left_cancel_semigroup congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_149411 (h0 : topological_space (semigroup congr_arg_kind)) : t1_space (semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_149412 (h0 : topological_space (preorder num)) : irreducible_space (preorder num) := sorry --non-trivial
lemma new_lemma_149413 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @preconnected_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero))) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_149414 (h0 h1 : char -> char) : function.right_inverse h0 h1 := sorry --non-trivial
lemma new_lemma_149415 (h0 : not (ring (comm_ring linarith.comp_source) -> false)) : @rank_condition.{0} (comm_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (comm_ring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_149416 (h0 : has_mem.mem (with_one to_additive.value_type) has_emptyc.emptyc) : @totally_separated_space.{0} (with_one.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_149417 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : path_connected_space empty := sorry --non-trivial
lemma new_lemma_149418 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} h0 (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_149419 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @sequential_space.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_149420 (h0 : topological_space (add_cancel_monoid empty) -> Prop) (h1 : Exists (fun (x : topological_space (add_cancel_monoid empty)), h0 x)) : @totally_separated_space.{0} (add_cancel_monoid.{0} empty) (@classical.some.{1} (topological_space.{0} (add_cancel_monoid.{0} empty)) h0 h1)  := sorry --non-trivial
lemma new_lemma_149421 (h0 : topological_space (has_nndist (mul_zero_class pos))) : totally_separated_space (has_nndist (mul_zero_class pos)) := sorry --non-trivial
lemma new_lemma_149422 (h0 : functor.add_const (list (add_cancel_monoid pos)) (option unsigned)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_149423 (h0 : ring (mul_one_class (add_comm_semigroup ereal))) : strong_rank_condition (mul_one_class (add_comm_semigroup ereal)) := sorry --non-trivial
lemma new_lemma_149424 (h0 : topological_space (has_zero (has_to_string (has_add pos)))) : regular_space (has_zero (has_to_string (has_add pos))) := sorry --non-trivial
lemma new_lemma_149425 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_separated_space.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_149426 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (option.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (option.{0} num))  := sorry --non-trivial
lemma new_lemma_149427 (h0 : functor.add_const (add_monoid (add_cancel_monoid name)) pos) : @add_monoid.fg.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (add_cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_149428 (h0 : filter (cancel_monoid (option name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_149429 (h0 : complete_lattice (nondiscrete_normed_field enat)) : complete_lattice.is_Sup_finite_compact (nondiscrete_normed_field enat) := sorry --non-trivial
lemma new_lemma_149430 (h0 : add_comm_semigroup char -> add_comm_semigroup char) (h3 : add_comm_semigroup char) : function.is_fixed_pt h0 h3 := sorry --non-trivial
lemma new_lemma_149431 (h0 : not (has_mem.mem (measurable_space num) has_emptyc.emptyc -> false)) : @irreducible_space.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_149432 (h0 : group (has_nnnorm (topological_space (has_nnnorm reducibility_hints)))) : is_cyclic (has_nnnorm (topological_space (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_149433 (h0 : topological_space (has_emptyc (random_gen (random_gen (random_gen fun_info))))) : irreducible_space (has_emptyc (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_149434 (h0 : filter (encodable linarith.comp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_149435 (h0 : functor.add_const (topological_space (comm_group unsigned)) (option pos)) : @topological_space.separable_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_149436 (h0 : not (cancel_comm_monoid_with_zero (plift num) -> false)) : @unique_factorization_monoid.{1} (plift.{1} num) (@classical.by_contradiction'.{2} (cancel_comm_monoid_with_zero.{1} (plift.{1} num)) h0)  := sorry --non-trivial
lemma new_lemma_149437 (h0 : monoid (has_add (has_neg Type))) : monoid.fg (has_add (has_neg Type)) := sorry --non-trivial
lemma new_lemma_149438 (h0 : ring (semiring (has_top (has_top (has_top (has_top to_additive.value_type)))))) : rank_condition (semiring (has_top (has_top (has_top (has_top to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_149439 (h0 : add_monoid (has_union empty)) : add_monoid.fg (has_union empty) := sorry --non-trivial
lemma new_lemma_149440 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_149441 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_norm string_imp)) := sorry --non-trivial
lemma new_lemma_149442 (h0 : uniform_space (add_cancel_comm_monoid (option empty))) : complete_space (add_cancel_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_149443 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_149444 (h0 : ring (comm_group (finset name))) : is_principal_ideal_ring (comm_group (finset name)) := sorry --non-trivial
lemma new_lemma_149445 (h0 : ring (ordered_comm_monoid (has_Inf (has_add Type)))) : strong_rank_condition (ordered_comm_monoid (has_Inf (has_add Type))) := sorry --non-trivial
lemma new_lemma_149446 (h0 : not (topological_space (complete_linear_order unsigned) -> false)) : @discrete_topology.{0} (complete_linear_order.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_linear_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_149447 (h0 : filter (left_cancel_semigroup (semiring (semiring (semiring congr_arg_kind))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_149448 (h0 : functor.add_const (topological_space (comm_group name)) unsigned) : @normal_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_149449 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_149450 (h0 : fin has_zero.zero) : @is_cyclic.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) h0) (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_149451 (h0 : cancel_comm_monoid_with_zero (ring (add_cancel_monoid pos))) : unique_factorization_monoid (ring (add_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_149452 (h3 : topological_space (linear_ordered_add_comm_group fun_info)) : totally_disconnected_space (linear_ordered_add_comm_group fun_info) := sorry --non-trivial
lemma new_lemma_149453 (h0 : functor.add_const (ring (semigroup empty)) empty) : @is_principal_ideal_ring.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_149454 (h0 : functor.add_const (uniform_space (free_add_monoid num)) num) : @separated_space.{0} (free_add_monoid.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (free_add_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_149455 (h0 : ring (partial_order (semiring (semiring (semiring (semiring (semiring empty))))))) : rank_condition (partial_order (semiring (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_149456 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (group_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_149457 (h0 : fin has_zero.zero) : @is_domain.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_149458 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (with_one linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_149459 (h0 : topological_space (canonically_ordered_monoid (sub_neg_monoid pos))) : locally_compact_space (canonically_ordered_monoid (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_149460 (h0 : topological_space (non_unital_non_assoc_semiring (mul_one_class enat))) : path_connected_space (non_unital_non_assoc_semiring (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_149461 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (normed_comm_ring.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (normed_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_149462 (h0 : ring (id unsigned)) : is_principal_ideal_ring (id unsigned) := sorry --non-trivial
lemma new_lemma_149463 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_149464 (h0 : ring (boolean_algebra (ring (has_to_string Type)))) : is_domain (boolean_algebra (ring (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_149465 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @path_connected_space.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_149466 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_149467 (h0 : not (topological_space (has_compl linarith.ineq) -> false)) : @path_connected_space.{0} (has_compl.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_compl.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_149468 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (group_with_zero.{0} (option.{0} (option.{0} ennreal))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} (option.{0} (option.{0} ennreal))))  := sorry --non-trivial
lemma new_lemma_149469 (h0 : semiring (has_add (mul_one_class linarith.comp))) : is_noetherian_ring (has_add (mul_one_class linarith.comp)) := sorry --non-trivial
lemma new_lemma_149470 (h0 : ring (semiring (has_norm (measurable_space (has_norm num))))) : is_domain (semiring (has_norm (measurable_space (has_norm num)))) := sorry --non-trivial
lemma new_lemma_149471 (h1 : function.extfun Type topological_space) : @t0_space.{0} (with_bot.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (with_bot.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_149472 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_star.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_star.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_149473 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) pos) : @preirreducible_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_149474 (h0 : uniform_space (has_top (has_top congr_arg_kind))) : complete_space (has_top (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_149475 (h0 : ring (has_sub empty)) : is_domain (has_sub empty) := sorry --non-trivial
lemma new_lemma_149476 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) Type) : @locally_compact_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_149477 (h0 : functor.add_const (topological_space (sub_neg_monoid name)) name) : @topological_space.separable_space.{0} (sub_neg_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_149478 (h0 : group (cancel_monoid (option (finset unsigned)))) : is_cyclic (cancel_monoid (option (finset unsigned))) := sorry --non-trivial
lemma new_lemma_149479 (h0 : functor.add_const (function.extfun Type uniform_space) (option (option (option (option (option pos)))))) : @separated_space.{0} (has_neg_part.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} pos))))) h0) (has_neg_part.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_149480 (h0 : monoid (has_add pos)) : monoid.fg (has_add pos) := sorry --non-trivial
lemma new_lemma_149481 (h0 : topological_space (complete_distrib_lattice (has_nndist pos))) : normal_space (complete_distrib_lattice (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_149482 (h0 : list (mul_zero_class (add_comm_monoid (semigroup Type)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_149483 (h0 : topological_space (normed_comm_ring (semigroup Type))) : loc_path_connected_space (normed_comm_ring (semigroup Type)) := sorry --non-trivial
lemma new_lemma_149484 (h0 : functor.add_const (topological_space (has_neg_part Type)) name) : @loc_path_connected_space.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg_part.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_149485 (h2 : add_group (has_lt linarith.comp_source)) : is_add_cyclic (has_lt linarith.comp_source) := sorry --non-trivial
lemma new_lemma_149486 (h0 : ring (has_nnnorm reducibility_hints)) : rank_condition (has_nnnorm reducibility_hints) := sorry --non-trivial
lemma new_lemma_149487 (h0 : topological_space (normed_lattice_add_comm_group (canonically_ordered_monoid real))) : totally_disconnected_space (normed_lattice_add_comm_group (canonically_ordered_monoid real)) := sorry --non-trivial
lemma new_lemma_149488 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_149489 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @irreducible_space.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_149490 (h0 : complete_lattice (add_left_cancel_monoid to_additive.value_type)) : is_compactly_generated (add_left_cancel_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_149491 (h0 : finset (metric_space (semiring empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_149492 (h0 h1 : multiset (nondiscrete_normed_field reducibility_hints)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_149493 (h0 : functor.add_const (topological_space (has_nndist unsigned)) Type) : @preconnected_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_149494 (h0 : ring (add_cancel_comm_monoid empty)) : is_principal_ideal_ring (add_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_149495 (h0 : list (has_add ennreal)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_149496 (h0 : function.extfun (Type 1) topological_space) : @t0_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_149497 (h0 : semiring (comm_group (has_add (has_add Type)))) : is_noetherian_ring (comm_group (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_149498 (h3 : ring (random_gen string_imp)) : is_domain (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_149499 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (@id.{2} Type to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (@id.{2} Type to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_149500 (h0 : topological_space (has_zero (has_neg_part name))) : normal_space (has_zero (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_149501 (h0 : complete_lattice (linear_ordered_add_comm_group (has_top linarith.comp_source))) : is_atomistic (linear_ordered_add_comm_group (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_149502 (h0 : functor.add_const (topological_space (has_add linarith.comp)) (mul_one_class (has_pos_part linarith.comp))) : @locally_compact_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) (mul_one_class.{0} (has_pos_part.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_149503 (h0 : has_lt (mul_one_class (add_comm_semigroup std_gen))) : no_max_order (mul_one_class (add_comm_semigroup std_gen)) := sorry --non-trivial
lemma new_lemma_149504 (h0 : ring (linear_ordered_semiring (has_norm (has_norm empty)))) : strong_rank_condition (linear_ordered_semiring (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_149505 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_149506 (h0 : topological_space (finset (has_add environment.implicit_infer_kind))) : preirreducible_space (finset (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_149507 (h0 : not (filter (comm_ring to_additive.value_type) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_149508 (h0 : topological_space (add_comm_monoid (has_add name))) : preconnected_space (add_comm_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_149509 (h1 : ring (non_unital_non_assoc_semiring (comm_ring linarith.comp_source))) : is_domain (non_unital_non_assoc_semiring (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_149510 (h0 : topological_space (has_pos_part pos)) : discrete_topology (has_pos_part pos) := sorry --non-trivial
lemma new_lemma_149511 (h0 : add_monoid (has_add (ring environment.implicit_infer_kind))) : add_monoid.fg (has_add (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_149512 (h0 : ordered_add_comm_monoid (option empty)) : archimedean (option empty) := sorry --non-trivial
lemma new_lemma_149513 (h0 : functor.add_const (monoid (finset unsigned)) unsigned -> Prop) (h1 : Exists (fun (x : functor.add_const (monoid (finset unsigned)) unsigned), h0 x)) : @monoid.fg.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (finset.{0} unsigned)) unsigned (@classical.some.{1} (functor.add_const.{0 0} (monoid.{0} (finset.{0} unsigned)) unsigned) h0 h1))  := sorry --non-trivial
lemma new_lemma_149514 (h0 : topological_space (nondiscrete_normed_field (normed_field fun_info))) : totally_disconnected_space (nondiscrete_normed_field (normed_field fun_info)) := sorry --non-trivial
lemma new_lemma_149515 (h0 : topological_space (normed_group num)) : normal_space (normed_group num) := sorry --non-trivial
lemma new_lemma_149516 (h0 : functor.add_const (topological_space (has_zero Type)) (finset pos)) : @t1_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_149517 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_149518 (h0 : topological_space (sub_neg_monoid real)) : preconnected_space (sub_neg_monoid real) := sorry --non-trivial
lemma new_lemma_149519 (h0 : topological_space (non_assoc_semiring empty)) : irreducible_space (non_assoc_semiring empty) := sorry --non-trivial
lemma new_lemma_149520 (h0 : functor.add_const (monoid (has_pos_part pos)) linarith.comp) : @monoid.fg.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (has_pos_part.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_149521 (h0 : functor.add_const (topological_space znum) (option (option unsigned))) : @path_connected_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) (option.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_149522 (h0 : functor.add_const (topological_space (left_cancel_monoid unsigned)) congr_arg_kind) : @t0_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_149523 (h0 : ring (linear_ordered_add_comm_group (random_gen (random_gen char)))) : is_domain (linear_ordered_add_comm_group (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_149524 (h0 : functor.add_const (list (cancel_monoid pos)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_149525 (h0 : group (has_union (has_top num))) : normalizer_condition (has_union (has_top num)) := sorry --non-trivial
lemma new_lemma_149526 (h0 : ring (metric_space num)) : strong_rank_condition (metric_space num) := sorry --non-trivial
lemma new_lemma_149527 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_neg unsigned)) (has_neg_part (boolean_algebra pos))) : @unique_factorization_monoid.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_neg.{0} unsigned)) (has_neg_part.{0} (boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_149528 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_149529 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_149530 (h0 : complete_lattice (add_cancel_comm_monoid (semiring unsigned))) : is_compactly_generated (add_cancel_comm_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_149531 (h0 : functor.add_const (functor.add_const (topological_space nnreal) congr_arg_kind) congr_arg_kind) : discrete_topology nnreal := sorry --non-trivial
lemma new_lemma_149532 (h0 : ring (has_inner (option (option empty)) congr_arg_kind)) : is_principal_ideal_ring (has_inner (option (option empty)) congr_arg_kind) := sorry --non-trivial
lemma new_lemma_149533 (h0 : list (has_neg ennreal)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_149534 (h0 : uniform_space (normed_lattice_add_comm_group (has_add Type))) : complete_space (normed_lattice_add_comm_group (has_add Type)) := sorry --non-trivial
lemma new_lemma_149535 (h0 : functor.comp ring add_cancel_monoid Type) : @rank_condition.{1} (add_cancel_monoid.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} add_cancel_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_149536 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} to_additive.value_type (@function.extfun_app.{2 1} Type topological_space.{0} h0 to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_149537 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (preorder.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (preorder.{0} num))  := sorry --non-trivial
lemma new_lemma_149538 (h0 : monoid (random_gen (has_inv fun_info))) : monoid.fg (random_gen (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_149539 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_149540 (h0 : topological_space (has_nnnorm (mul_one_class environment.projection_info))) : path_connected_space (has_nnnorm (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_149541 (h0 : functor.add_const (list (has_nndist pos)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_149542 (h0 : fin has_zero.zero) : @is_domain.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_149543 (h0 : functor.add_const (ordered_comm_monoid (has_neg pos)) pos) : @has_exists_mul_of_le.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_neg.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_149544 (h0 : has_add reducibility_hints) (h1 : has_lt (has_nnnorm (mul_one_class (add_con reducibility_hints)))) : no_max_order (has_nnnorm (mul_one_class (add_con reducibility_hints))) := sorry --non-trivial
lemma new_lemma_149545 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) Type) : @path_connected_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (boolean_algebra.core.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_149546 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @locally_compact_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_149547 (h0 : function.extfun Type (functor.comp ordered_comm_monoid comm_group)) : @has_exists_mul_of_le.{0} (comm_group.{0} pos) (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} comm_group.{0} pos (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} comm_group.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ordered_comm_monoid.{0} comm_group.{0}) h0 pos)))  := sorry --non-trivial
lemma new_lemma_149548 (h0 : monoid (boolean_algebra.core (ring linarith.comp))) : monoid.fg (boolean_algebra.core (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_149549 (h0 : ring (has_neg (finset (has_add (has_add (has_add name)))))) : is_principal_ideal_ring (has_neg (finset (has_add (has_add (has_add name))))) := sorry --non-trivial
lemma new_lemma_149550 (h0 h1 : multiset (semi_normed_comm_ring (mul_one_class string.iterator_imp))) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_149551 (h0 : ring (partial_order (semiring (semiring unsigned)))) : is_principal_ideal_ring (partial_order (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_149552 (h0 : add_group (has_ssubset linarith.ineq)) : is_add_cyclic (has_ssubset linarith.ineq) := sorry --non-trivial
lemma new_lemma_149553 (h0 : cancel_comm_monoid_with_zero (linear_ordered_comm_monoid_with_zero unsigned)) : unique_factorization_monoid (linear_ordered_comm_monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_149554 (h3 : topological_space (has_add string_imp)) : t0_space (has_add string_imp) := sorry --non-trivial
lemma new_lemma_149555 (h0 : group (has_Inf (has_pos_part linarith.comp))) : normalizer_condition (has_Inf (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_149556 (h2 : filter (linear_ordered_add_comm_group (random_gen char))) : filter.ne_bot h2 := sorry --non-trivial
lemma new_lemma_149557 (h0 : fin has_zero.zero) : @is_cyclic.{0} (has_bot.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (has_bot.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_149558 (h0 : functor.add_const (finset (linear_order unsigned)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_149559 (h1 : list (with_one string_imp)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_149560 (h0 : topological_space (comm_monoid real)) : loc_path_connected_space (comm_monoid real) := sorry --non-trivial
lemma new_lemma_149561 (h0 : complete_lattice (finset (mul_zero_class (option pos)))) : is_compactly_generated (finset (mul_zero_class (option pos))) := sorry --non-trivial
lemma new_lemma_149562 (h0 : topological_space (partial_order congr_arg_kind)) : normal_space (partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_149563 (h0 : topological_space (has_neg (boolean_algebra (ring environment.implicit_infer_kind)))) : t1_space (has_neg (boolean_algebra (ring environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_149564 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (bin_tree.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (bin_tree.{0} num))  := sorry --non-trivial
lemma new_lemma_149565 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (ring.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (ring.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_149566 (h0 : not (topological_space (normed_field string.iterator_imp) -> false)) : @totally_disconnected_space.{0} (normed_field.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_field.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_149567 (h0 : group (generalized_boolean_algebra (has_Inf (has_bot name)))) : is_simple_group (generalized_boolean_algebra (has_Inf (has_bot name))) := sorry --non-trivial
lemma new_lemma_149568 (h0 : functor.add_const (topological_space (add_group congr_arg_kind)) num) : @discrete_topology.{0} (add_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_149569 (h0 : function.extfun Type (functor.add_const (group znum))) : @group.fg.{0} znum (@functor.add_const.run.{0 0} (group.{0} znum) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} znum)) h0 num))  := sorry --non-trivial
lemma new_lemma_149570 (h0 : function.extfun Type (functor.comp topological_space boolean_algebra.core)) : @sequential_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} boolean_algebra.core.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_149571 (h0 : add_group (has_nnnorm (denumerable (encodable (has_ssubset (has_nnnorm string_imp)))))) : is_add_cyclic (has_nnnorm (denumerable (encodable (has_ssubset (has_nnnorm string_imp))))) := sorry --non-trivial
lemma new_lemma_149572 (h0 : add_group (distrib_lattice (has_nnnorm linarith.comp_source))) : is_add_cyclic (distrib_lattice (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_149573 (h0 : functor.add_const (complete_lattice (cancel_monoid environment.implicit_infer_kind)) Type) : @is_atomistic.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (complete_lattice.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_149574 (h1 : function.extfun Type group) : @is_cyclic.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h1 (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_149575 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot fun_info))) : @locally_compact_space.{0} (with_bot.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_149576 (h0 : ring (has_add (has_inv (has_inv linarith.ineq)))) : is_domain (has_add (has_inv (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_149577 (h0 : uniform_space (add_cancel_monoid (has_neg (semigroup Type)))) : complete_space (add_cancel_monoid (has_neg (semigroup Type))) := sorry --non-trivial
lemma new_lemma_149578 (h0 : ring (boolean_algebra.core (has_neg_part Type))) : strong_rank_condition (boolean_algebra.core (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_149579 (h0 : topological_space (comm_semigroup (has_bot (has_neg name)))) : regular_space (comm_semigroup (has_bot (has_neg name))) := sorry --non-trivial
lemma new_lemma_149580 (h0 : functor.add_const (uniform_space (has_nndist linarith.comp)) pos) : @complete_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_nndist.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_149581 (h0 : ring (random_gen congr_arg_kind)) : is_domain (random_gen congr_arg_kind) := sorry --non-trivial
lemma new_lemma_149582 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_149583 (h0 : ring (ring (has_neg (has_Inf Type)))) : rank_condition (ring (has_neg (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_149584 (h0 : ordered_comm_monoid (boolean_algebra (finset linarith.comp))) : has_exists_mul_of_le (boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_149585 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_149586 (h0 : function.extfun Type ring) : @is_domain.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_149587 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_149588 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_149589 (h0 : complete_lattice (has_pos_part (ordered_comm_monoid real))) : is_atomistic (has_pos_part (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_149590 (h0 : not (topological_space (has_emptyc linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (has_emptyc.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_149591 (h0 : not (topological_space (topological_space linarith.comp_source) -> false)) : @path_connected_space.{0} (topological_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (topological_space.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_149592 (h1 : topological_space (has_emptyc linarith.ineq)) : irreducible_space (has_emptyc linarith.ineq) := sorry --non-trivial
lemma new_lemma_149593 (h0 : functor.add_const (topological_space (has_Sup empty)) empty) : @irreducible_space.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_149594 (h0 : has_mem.mem ring has_emptyc.emptyc) : @rank_condition.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_149595 (h0 : cancel_comm_monoid_with_zero (id unsigned)) : unique_factorization_monoid (id unsigned) := sorry --non-trivial
lemma new_lemma_149596 (h0 : list (option (option (option congr_arg_kind)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_149597 (h0 : function.extfun Type topological_space) : @t1_space.{0} (linear_ordered_field.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_149598 (h0 : group linarith.comp) : normalizer_condition linarith.comp := sorry --non-trivial
lemma new_lemma_149599 (h0 : ring (has_nnnorm (mul_one_class string_imp))) : is_domain (has_nnnorm (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_149600 (h0 : ring (boolean_algebra (sub_neg_monoid (sub_neg_monoid (has_pos_part real))))) : rank_condition (boolean_algebra (sub_neg_monoid (sub_neg_monoid (has_pos_part real)))) := sorry --non-trivial
lemma new_lemma_149601 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_149602 (h0 : fin has_zero.zero) : @monoid.fg.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type monoid.{0}) h0) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_149603 (h0 : list (has_dist congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_149604 (h0 : topological_space (canonically_ordered_comm_semiring char)) (h1 : preorder (canonically_ordered_comm_semiring char)) : order_topology (canonically_ordered_comm_semiring char) := sorry --non-trivial
lemma new_lemma_149605 (h0 : name -> Prop) : zzz_forall h0 := sorry --non-trivial
lemma new_lemma_149606 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) linarith.comp) : @loc_path_connected_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_149607 (h0 : topological_space (cancel_monoid (finset ennreal))) : t1_space (cancel_monoid (finset ennreal)) := sorry --non-trivial
lemma new_lemma_149608 (h0 : add_monoid (has_zero (has_neg pos))) : add_monoid.fg (has_zero (has_neg pos)) := sorry --non-trivial
lemma new_lemma_149609 (h1 : add_group (dlist string_imp)) : is_add_cyclic (dlist string_imp) := sorry --non-trivial
lemma new_lemma_149610 (h0 : function.extfun (finset ((Type -> Type) -> Type 1)) (has_mem.mem (function.extfun Type))) : @complete_space.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@function.extfun_app.{3 0} (finset.{2} ((Type → Type) → Type 1)) (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (finset.{2} ((Type → Type) → Type 1)) (@finset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type)) h0 (@has_emptyc.emptyc.{2} (finset.{2} ((Type → Type) → Type 1)) (@finset.has_emptyc.{2} ((Type → Type) → Type 1))))) uniform_space.{0}) (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_149611 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (div_inv_monoid linarith.ineq)) := sorry --non-trivial
lemma new_lemma_149612 (h0 : functor.add_const (topological_space (normed_comm_ring ennreal)) name) : @path_connected_space.{0} (normed_comm_ring.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_149613 (h2 : group linarith.ineq) : group.fg linarith.ineq := sorry --non-trivial
lemma new_lemma_149614 (h0 : topological_space (boolean_algebra.core ennreal)) : preconnected_space (boolean_algebra.core ennreal) := sorry --non-trivial
lemma new_lemma_149615 (h0 : topological_space (has_zero (has_nndist (has_neg_part Type)))) : preconnected_space (has_zero (has_nndist (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_149616 (h1 : topological_space (has_ssubset string_imp)) : path_connected_space (has_ssubset string_imp) := sorry --non-trivial
lemma new_lemma_149617 (h0 : ordered_comm_monoid (has_add ennreal)) : has_exists_mul_of_le (has_add ennreal) := sorry --non-trivial
lemma new_lemma_149618 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @discrete_topology.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_149619 (h0 : topological_space (ordered_comm_ring (has_add (has_add Type)))) : irreducible_space (ordered_comm_ring (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_149620 (h0 : ring (simple_graph environment.projection_info)) : strong_rank_condition (simple_graph environment.projection_info) := sorry --non-trivial
lemma new_lemma_149621 (h0 : list (preorder congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_149622 (h0 : functor.add_const (add_group (semigroup linarith.comp)) (has_neg Type)) : @is_add_cyclic.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_group.{0} (semigroup.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_149623 (h0 : add_group (has_ssubset (random_gen linarith.ineq))) : is_add_cyclic (has_ssubset (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_149624 (h0 : function.extfun Type (functor.add_const (semiring pos))) : @is_noetherian_ring.{0} pos (@functor.add_const.run.{0 0} (semiring.{0} pos) ennreal (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (semiring.{0} pos)) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_149625 (h0 : function.extfun Type (functor.add_const (topological_space (ring Type)))) : @totally_disconnected_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) linarith.comp (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (topological_space.{1} (ring.{1} Type))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_149626 (h0 : topological_space (has_zero (has_add (has_add Type)))) : loc_path_connected_space (has_zero (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_149627 (h0 : topological_space (measurable_space (has_top fun_info))) : t0_space (measurable_space (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_149628 (h0 : std_gen -> std_gen -> Prop) (h1 : set std_gen) : directed_on h0 h1 := sorry --non-trivial
lemma new_lemma_149629 (h0 : filter (has_top (random_gen (random_gen (random_gen linarith.ineq))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_149630 (h0 : group (measurable_space.dynkin_system congr_arg_kind)) : group.fg (measurable_space.dynkin_system congr_arg_kind) := sorry --non-trivial
lemma new_lemma_149631 (h0 : functor.add_const (semiring (add_cancel_monoid pos)) (has_nndist (has_to_string Type))) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (semiring.{0} (add_cancel_monoid.{0} pos)) (has_nndist.{1} (has_to_string.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_149632 (h0 : topological_space (add_comm_monoid (option empty))) : t1_space (add_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_149633 (h0 : not (has_mem.mem (semiring (random_gen linarith.comp_source)) has_emptyc.emptyc -> false)) : @is_add_cyclic.{0} (semiring.{0} (random_gen.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type add_group.{0} (semiring.{0} (random_gen.{0} linarith.comp_source)) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} (random_gen.{0} linarith.comp_source)) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_149634 (h0 : has_mem.mem (with_one (random_gen congr_arg_kind)) has_emptyc.emptyc) : @t0_space.{0} (with_one.{0} (random_gen.{0} congr_arg_kind)) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} (random_gen.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_149635 (h0 : not (topological_space (with_zero linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (with_zero.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (with_zero.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_149636 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) (has_to_string linarith.comp)) : @normal_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) (has_to_string.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_149637 (h0 : topological_space (semigroup (has_to_string (add_comm_monoid Type)))) : preconnected_space (semigroup (has_to_string (add_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_149638 (h1 : topological_space (has_add char) -> Prop) : @totally_disconnected_space.{0} (has_add.{0} char) (@classical.epsilon.{1} (topological_space.{0} (has_add.{0} char)) (@nonempty_of_inhabited.{1} (topological_space.{0} (has_add.{0} char)) (@inhabited_topological_space.{0} (has_add.{0} char))) h1)  := sorry --non-trivial
lemma new_lemma_149639 (h0 : filter (has_nndist (finset (finset linarith.comp)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_149640 (h0 : topological_space (ring pos)) : path_connected_space (ring pos) := sorry --non-trivial
lemma new_lemma_149641 (h0 : topological_space (add_cancel_comm_monoid (mul_one_class (random_gen char)))) : t0_space (add_cancel_comm_monoid (mul_one_class (random_gen char))) := sorry --non-trivial
lemma new_lemma_149642 (h0 : uniform_space (has_inv (random_gen linarith.ineq))) : complete_space (has_inv (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_149643 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) (has_neg Type)) : @has_exists_mul_of_le.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) (has_neg.{1} Type) h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_149644 (h0 : complete_lattice (add_comm_monoid (finset (finset (finset pos))))) : is_compactly_generated (add_comm_monoid (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_149645 (h0 : topological_space (boolean_algebra (finset (ring (has_Inf (boolean_algebra Type)))))) : t0_space (boolean_algebra (finset (ring (has_Inf (boolean_algebra Type))))) := sorry --non-trivial
lemma new_lemma_149646 (h0 : topological_space (add_comm_monoid (has_to_string pos))) : totally_disconnected_space (add_comm_monoid (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_149647 (h1 : function.extfun Type topological_space) : @path_connected_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_149648 (h0 : ring (has_emptyc linarith.comp_source)) : strong_rank_condition (has_emptyc linarith.comp_source) := sorry --non-trivial
lemma new_lemma_149649 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} auto.case_option (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 auto.case_option)  := sorry --non-trivial
lemma new_lemma_149650 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_149651 (h0 : function.extfun Type complete_lattice) : complete_lattice.is_Sup_finite_compact (measurable_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_149652 (h0 : functor.add_const (topological_space (filter unsigned)) empty) : @path_connected_space.{0} (filter.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (filter.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_149653 (h0 : functor.add_const Prop (has_pos_part linarith.comp)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_149654 (h1 : topological_space (has_lt string_imp)) : path_connected_space (has_lt string_imp) := sorry --non-trivial
lemma new_lemma_149655 (h0 : functor.add_const (semiring (semigroup pos)) pos) : @is_noetherian_ring.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (semigroup.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_149656 (h0 : topological_space (simple_graph num)) : t1_space (simple_graph num) := sorry --non-trivial
lemma new_lemma_149657 (h0 : functor.add_const (topological_space (has_Inf pos)) name) : @irreducible_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_149658 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_149659 (h0 : not (filter (add_right_cancel_monoid congr_arg_kind) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_149660 (h0 : functor.add_const (filter (finset pos)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_149661 (h0 : has_neg (normed_field to_additive.value_type)) (h1 : measurable_space (normed_field to_additive.value_type)) : has_measurable_neg (normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_149662 (h0 : not (complete_lattice (random_gen (has_nnnorm reducibility_hints)) -> false)) : @is_compactly_generated.{0} (random_gen.{0} (has_nnnorm.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} (has_nnnorm.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_149663 (h0 : topological_space (has_pos_part (has_add pos))) : totally_disconnected_space (has_pos_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_149664 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (linear_ordered_field.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type monoid.{0} h0 (linear_ordered_field.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_149665 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_149666 (h0 : functor.comp topological_space boolean_algebra.core environment.implicit_infer_kind) : @regular_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_149667 (h0 : functor.add_const (topological_space (cancel_monoid environment.implicit_infer_kind)) name) : @irreducible_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_149668 (h0 : ring (add_comm_semigroup std_gen)) : is_domain (add_comm_semigroup std_gen) := sorry --non-trivial
lemma new_lemma_149669 (h0 : list (dlist (random_gen (random_gen linarith.comp_source)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_149670 (h0 : group (add_comm_monoid (option pos))) : normalizer_condition (add_comm_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_149671 (h0 : uniform_space (normed_comm_ring (has_add linarith.comp))) : separated_space (normed_comm_ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_149672 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (ordered_cancel_add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_149673 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_149674 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) pos) : @preconnected_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_149675 (h0 : not (add_monoid (add_right_cancel_monoid empty) -> false)) : @add_monoid.fg.{0} (add_right_cancel_monoid.{0} empty) (@classical.by_contradiction'.{1} (add_monoid.{0} (add_right_cancel_monoid.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_149676 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_149677 (h0 : function.extfun nat fin) : @separated_space.{0} (sub_neg_monoid.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (sub_neg_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_149678 (h0 : ring (mul_zero_class (semiring empty))) : is_principal_ideal_ring (mul_zero_class (semiring empty)) := sorry --non-trivial
lemma new_lemma_149679 (h0 : ring (has_add (finset environment.implicit_infer_kind))) : is_domain (has_add (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_149680 (h0 : ring (semigroup (finset name))) : strong_rank_condition (semigroup (finset name)) := sorry --non-trivial
lemma new_lemma_149681 (h0 : topological_space (boolean_algebra.core (has_add (has_pos_part linarith.comp)))) : totally_disconnected_space (boolean_algebra.core (has_add (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_149682 (h1 : topological_space (mul_one_class (normed_field (mul_one_class enat)))) : t0_space (mul_one_class (normed_field (mul_one_class enat))) := sorry --non-trivial
lemma new_lemma_149683 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_149684 (h0 : add_group (add_comm_monoid (has_nndist environment.implicit_infer_kind))) : is_add_cyclic (add_comm_monoid (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_149685 (h0 : add_monoid (has_emptyc (has_norm linarith.comp))) : add_monoid.fg (has_emptyc (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_149686 (h0 : functor.add_const (complete_lattice (add_cancel_monoid environment.implicit_infer_kind)) name) : @is_compactly_generated.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_149687 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) linarith.comp) : @locally_compact_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_149688 (h2 : group (fintype char)) : group.fg (fintype char) := sorry --non-trivial
lemma new_lemma_149689 (h0 : ring (normed_comm_ring (comm_group (comm_group (comm_group (comm_group name)))))) : is_domain (normed_comm_ring (comm_group (comm_group (comm_group (comm_group name))))) := sorry --non-trivial
lemma new_lemma_149690 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (free_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (free_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_149691 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_149692 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (linear_ordered_field.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_149693 (h0 : add_group (canonically_ordered_monoid (has_Inf (has_Inf linarith.comp)))) : is_add_cyclic (canonically_ordered_monoid (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_149694 (h0 : functor.add_const (topological_space (semigroup pos)) Type) : @regular_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_149695 (h0 : ring (topological_space (random_gen linarith.ineq))) : rank_condition (topological_space (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_149696 (h0 : ring (normed_comm_ring unsigned)) : is_domain (normed_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_149697 (h0 : functor.add_const (topological_space (has_zero pos)) environment.implicit_infer_kind) : @preconnected_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_149698 (h0 : complete_lattice (has_to_string unsigned)) : is_atomistic (has_to_string unsigned) := sorry --non-trivial
lemma new_lemma_149699 (h0 : topological_space (normed_comm_ring (add_comm_monoid pos))) : normal_space (normed_comm_ring (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_149700 (h0 : group (has_neg_part (add_cancel_monoid (boolean_algebra.core environment.implicit_infer_kind)))) : group.fg (has_neg_part (add_cancel_monoid (boolean_algebra.core environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_149701 (h0 : topological_space (encodable (has_ssubset fun_info)) -> Prop) : @path_connected_space.{0} (encodable.{0} (has_ssubset.{0} fun_info)) (@classical.epsilon.{1} (topological_space.{0} (encodable.{0} (has_ssubset.{0} fun_info))) (@nonempty_of_inhabited.{1} (topological_space.{0} (encodable.{0} (has_ssubset.{0} fun_info))) (@inhabited_topological_space.{0} (encodable.{0} (has_ssubset.{0} fun_info)))) h0)  := sorry --non-trivial
lemma new_lemma_149702 (h0 : topological_space (complete_semilattice_Sup (has_nnnorm fun_info))) : totally_disconnected_space (complete_semilattice_Sup (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_149703 (h0 : group (add_comm_monoid (ring linarith.comp))) : group.fg (add_comm_monoid (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_149704 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (add_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (add_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_149705 (h2 : group (random_gen reducibility_hints)) : is_cyclic (random_gen reducibility_hints) := sorry --non-trivial
lemma new_lemma_149706 (h0 : topological_space (has_add (sub_neg_monoid pos))) : t0_space (has_add (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_149707 (h0 : group (bin_tree unsigned)) : normalizer_condition (bin_tree unsigned) := sorry --non-trivial
lemma new_lemma_149708 (h0 : ring (semigroup (add_comm_monoid linarith.comp))) : strong_rank_condition (semigroup (add_comm_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_149709 (h1 : topological_space (fintype to_additive.value_type)) : totally_disconnected_space (fintype to_additive.value_type) := sorry --non-trivial
lemma new_lemma_149710 (h0 : filter (canonically_ordered_monoid Type)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_149711 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (left_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_149712 (h1 : not (add_group (has_ssubset linarith.comp_source) -> false)) : @is_add_cyclic.{0} (has_ssubset.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (add_group.{0} (has_ssubset.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_149713 (h0 : semiring (generalized_boolean_algebra (ordered_comm_monoid (ordered_comm_monoid pos)))) : is_noetherian_ring (generalized_boolean_algebra (ordered_comm_monoid (ordered_comm_monoid pos))) := sorry --non-trivial
lemma new_lemma_149714 (h0 : topological_space real) : regular_space real := sorry --non-trivial
lemma new_lemma_149715 (h0 : topological_space (has_add (ring pos))) : preirreducible_space (has_add (ring pos)) := sorry --non-trivial
lemma new_lemma_149716 (h0 : topological_space (uniform_space fun_info)) : totally_disconnected_space (uniform_space fun_info) := sorry --non-trivial
lemma new_lemma_149717 (h0 : prod (boolean_algebra.core Type) (boolean_algebra.core Type)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_149718 (h0 : complete_lattice (linear_ordered_field unsigned)) : is_compactly_generated (linear_ordered_field unsigned) := sorry --non-trivial
lemma new_lemma_149719 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @loc_path_connected_space.{0} (has_dist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (has_dist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_149720 (h0 : monoid (has_bot (sub_neg_monoid (has_Inf name)))) : monoid.fg (has_bot (sub_neg_monoid (has_Inf name))) := sorry --non-trivial
lemma new_lemma_149721 (h0 : filter (boolean_algebra.core (option (option ennreal)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_149722 (h0 : functor.add_const (group (normed_comm_ring name)) (option (option (option pos)))) : @is_cyclic.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} name)) (option.{0} (option.{0} (option.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_149723 (h0 : functor.add_const (add_group (comm_group environment.implicit_infer_kind)) name) : @is_add_cyclic.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_group.{0} (comm_group.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_149724 (h0 : monoid (denumerable (has_top fun_info))) : monoid.fg (denumerable (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_149725 (h0 : topological_space (has_top (has_norm (has_norm congr_arg_kind)))) : path_connected_space (has_top (has_norm (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_149726 (h0 : semiring (is_R_or_C (option (option (option empty))))) : is_noetherian_ring (is_R_or_C (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_149727 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_comm_semiring (finset (finset ennreal)))) : unique_factorization_monoid (canonically_ordered_comm_semiring (finset (finset ennreal))) := sorry --non-trivial
lemma new_lemma_149728 (h0 : group (semigroup (mul_zero_class name))) : group.fg (semigroup (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_149729 (h0 : ring (has_norm (has_norm to_additive.value_type))) : is_domain (has_norm (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_149730 (h0 : not (ring (has_repr num) -> false)) : @is_domain.{0} (has_repr.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (has_repr.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_149731 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_union.{0} (has_top.{0} (has_top.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned)))))) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_union.{0} (has_top.{0} (has_top.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned)))))))  := sorry --non-trivial
lemma new_lemma_149732 (h0 : functor.add_const (add_monoid (has_neg_part unsigned)) pos) : @add_monoid.fg.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_neg_part.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_149733 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (has_one.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_one.{0} num))  := sorry --non-trivial
lemma new_lemma_149734 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_149735 (h0 : topological_space (has_pos_part (has_add (ring pos)))) : irreducible_space (has_pos_part (has_add (ring pos))) := sorry --non-trivial
lemma new_lemma_149736 (h0 : topological_space (has_emptyc (random_gen (random_gen linarith.comp_source)))) : path_connected_space (has_emptyc (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_149737 (h0 : functor.add_const (complete_lattice (has_pos_part Type)) (boolean_algebra.core linarith.comp)) : @complete_lattice.is_Sup_finite_compact.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_pos_part.{1} Type)) (boolean_algebra.core.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_149738 (h0 : not (add_group (encodable linarith.ineq) -> false)) : @is_add_cyclic.{0} (encodable.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (encodable.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_149739 (h1 : add_group string.iterator) : is_add_cyclic string.iterator := sorry --non-trivial
lemma new_lemma_149740 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_149741 (h1 : ring (has_top char)) : rank_condition (has_top char) := sorry --non-trivial
lemma new_lemma_149742 (h0 : semiring (add_cancel_monoid Type)) : is_noetherian_ring (add_cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_149743 (h0 : topological_space (metric_space (semiring (semiring empty)))) : discrete_topology (metric_space (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_149744 (h0 : fin has_zero.zero) : @preconnected_space.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_149745 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_149746 (h0 : fin has_zero.zero) : @is_cyclic.{0} real (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) h0) real)  := sorry --non-trivial
lemma new_lemma_149747 (h0 : functor.add_const (topological_space (finset unsigned)) empty) : @normal_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_149748 (h0 : group (metric_space (semiring (semiring empty)))) : group.fg (metric_space (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_149749 (h0 : group (comm_semigroup (comm_semigroup (has_bot (comm_semigroup pos))))) : is_simple_group (comm_semigroup (comm_semigroup (has_bot (comm_semigroup pos)))) := sorry --non-trivial
lemma new_lemma_149750 (h0 : prod (add_right_cancel_monoid (has_top empty)) (add_right_cancel_monoid (has_top empty))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_149751 (h0 : topological_space (boolean_algebra (has_Inf Type))) : loc_path_connected_space (boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_149752 (h0 : topological_space (has_add (has_bot Type))) : preconnected_space (has_add (has_bot Type)) := sorry --non-trivial
lemma new_lemma_149753 (h0 : ring (has_neg (ring (has_neg Type)))) : is_principal_ideal_ring (has_neg (ring (has_neg Type))) := sorry --non-trivial
lemma new_lemma_149754 (h0 : group (complete_semilattice_Sup num)) : group.fg (complete_semilattice_Sup num) := sorry --non-trivial
lemma new_lemma_149755 (h0 : has_mem.mem (measurable_space (random_gen linarith.comp_source)) has_emptyc.emptyc) : @discrete_topology.{0} (measurable_space.{0} (random_gen.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} (random_gen.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_149756 (h0 : topological_space (normed_group fun_info)) : irreducible_space (normed_group fun_info) := sorry --non-trivial
lemma new_lemma_149757 (h0 : topological_space (comm_group unsigned)) : locally_compact_space (comm_group unsigned) := sorry --non-trivial
lemma new_lemma_149758 (h0 : topological_space (canonically_ordered_monoid (has_add linarith.comp))) : discrete_topology (canonically_ordered_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_149759 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_149760 (h0 : topological_space (normed_comm_ring congr_arg_kind)) : totally_disconnected_space (normed_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_149761 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_149762 (h0 : function.extfun Type (prod (add_right_cancel_monoid num))) : id_rel (function.extfun_app h0 (add_right_cancel_monoid num)) := sorry --non-trivial
lemma new_lemma_149763 (h0 : ring (filter congr_arg_kind)) : is_domain (filter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_149764 (h0 : ordered_add_comm_monoid (semigroup (semiring empty))) : archimedean (semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_149765 (h1 : topological_space (random_gen string_imp)) : totally_separated_space (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_149766 (h2 : has_neg (nondiscrete_normed_field fun_info)) (h3 : measurable_space (nondiscrete_normed_field fun_info)) : has_measurable_neg (nondiscrete_normed_field fun_info) := sorry --non-trivial
lemma new_lemma_149767 (h0 : topological_space (has_to_string name)) : totally_disconnected_space (has_to_string name) := sorry --non-trivial
lemma new_lemma_149768 (h0 : functor.add_const (uniform_space (complete_distrib_lattice pos)) Type) : @complete_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (complete_distrib_lattice.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_149769 (h0 : functor.add_const (monoid (normed_comm_ring unsigned)) environment.implicit_infer_kind) : @monoid.fg.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (normed_comm_ring.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_149770 (h0 : topological_space (mul_one_class (has_ssubset linarith.ineq))) : totally_disconnected_space (mul_one_class (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_149771 (h0 : functor.add_const (monoid (has_nndist name)) (has_neg_part pos)) : @monoid.fg.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (has_nndist.{0} name)) (has_neg_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_149772 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_149773 (h0 : topological_space (boolean_algebra (has_neg (has_Inf environment.implicit_infer_kind)))) : t1_space (boolean_algebra (has_neg (has_Inf environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_149774 (h0 : function.extfun nat fin) : @is_simple_group.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (group.{1} (complete_distrib_lattice.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_149775 (h0 : group (random_gen (has_compl reducibility_hints))) : is_cyclic (random_gen (has_compl reducibility_hints)) := sorry --non-trivial
lemma new_lemma_149776 (h1 : not (add_group (distrib_lattice linarith.ineq) -> false)) : @is_add_cyclic.{0} (distrib_lattice.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (distrib_lattice.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_149777 (h0 : add_monoid (with_bot (semiring num))) : add_monoid.fg (with_bot (semiring num)) := sorry --non-trivial
lemma new_lemma_149778 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.core.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_149779 (h0 : not (ring (simple_graph linarith.comp_source) -> false)) : @is_domain.{0} (simple_graph.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (simple_graph.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_149780 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (@id.{2} Type to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (@id.{2} Type to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_149781 (h0 : complete_lattice (ordered_comm_ring (ring (has_pos_part (has_neg (finset linarith.comp)))))) : is_compactly_generated (ordered_comm_ring (ring (has_pos_part (has_neg (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_149782 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space num))) : @t0_space.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_149783 (h0 : topological_space (has_add (has_pos_part linarith.comp))) : t1_space (has_add (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_149784 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_149785 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_one.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_one.{0} num))  := sorry --non-trivial
lemma new_lemma_149786 (h0 : monoid (simple_graph unsigned)) : monoid.fg (simple_graph unsigned) := sorry --non-trivial
lemma new_lemma_149787 (h0 : not (group unsigned -> false)) : @is_cyclic.{0} unsigned (@classical.by_contradiction'.{1} (group.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_149788 (h0 : functor.add_const (topological_space (has_add linarith.comp)) name) : @preirreducible_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_149789 (h0 : function.extfun (finset Type) (has_mem.mem (semiring num))) : @is_add_cyclic.{0} (semiring.{0} num) (@finset.pi.empty.{1 0} Type add_group.{0} (semiring.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_149790 (h0 : topological_space (left_cancel_semigroup (mul_zero_class unsigned))) : normal_space (left_cancel_semigroup (mul_zero_class unsigned)) := sorry --non-trivial
lemma new_lemma_149791 (h0 : topological_space (comm_semigroup (sub_neg_monoid pos))) : topological_space.separable_space (comm_semigroup (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_149792 (h0 : monoid (add_cancel_monoid (has_add (semigroup (boolean_algebra.core pos))))) : monoid.fg (add_cancel_monoid (has_add (semigroup (boolean_algebra.core pos)))) := sorry --non-trivial
lemma new_lemma_149793 (h0 : not (complete_lattice (has_top congr_arg_kind) -> false)) : @is_atomistic.{0} (has_top.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_top.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_149794 (h0 : uniform_space (normed_group (has_inv (has_inv linarith.comp_source)))) : complete_space (normed_group (has_inv (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_149795 (h0 : topological_space (add_comm_monoid (has_add unsigned))) : normal_space (add_comm_monoid (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_149796 (h0 : topological_space (has_pos_part (finset (ring linarith.comp)))) : sequential_space (has_pos_part (finset (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_149797 (h0 : ring (has_ssubset string.iterator_imp)) : rank_condition (has_ssubset string.iterator_imp) := sorry --non-trivial
lemma new_lemma_149798 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @path_connected_space.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_149799 (h0 : not (ring (has_compl linarith.ineq) -> false)) : @strong_rank_condition.{0} (has_compl.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_149800 (h0 : topological_space (has_to_string (option (option (option ennreal))))) : preconnected_space (has_to_string (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_149801 (h0 : ring (add_semigroup (random_gen fun_info))) : strong_rank_condition (add_semigroup (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_149802 (h1 : topological_space (measurable_space (random_gen string_imp))) : totally_separated_space (measurable_space (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_149803 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_149804 (h0 : filter (has_zero (comm_group unsigned))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_149805 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_149806 (h0 : with_bot (ulower Prop)) (h1 : ne h0 has_bot.bot) : @ulower.up.{0} Prop encodable.Prop (@id.{1} (@ulower.{0} Prop encodable.Prop) (@with_bot.unbot.{0} (@ulower.{0} Prop encodable.Prop) h0 h1))  := sorry --non-trivial
lemma new_lemma_149807 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_top.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_top.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_149808 (h0 : topological_space (finset Type)) : locally_compact_space (finset Type) := sorry --non-trivial
lemma new_lemma_149809 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_149810 (h0 : group (ring linarith.comp)) : normalizer_condition (ring linarith.comp) := sorry --non-trivial
lemma new_lemma_149811 (h0 : functor.add_const (ring (has_pos_part Type)) Type) : @strong_rank_condition.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (has_pos_part.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_149812 (h0 : functor.add_const (topological_space (comm_group Type)) unsigned) : @irreducible_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_149813 (h0 : ring (has_add (has_add real))) : is_principal_ideal_ring (has_add (has_add real)) := sorry --non-trivial
lemma new_lemma_149814 (h0 : topological_space (mul_zero_class num)) : totally_separated_space (mul_zero_class num) := sorry --non-trivial
lemma new_lemma_149815 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @discrete_topology.{0} (canonically_ordered_add_monoid.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (canonically_ordered_add_monoid.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_149816 (h0 : functor.add_const (add_monoid (boolean_algebra environment.implicit_infer_kind)) pos) : @add_monoid.fg.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_149817 (h0 : ring (boolean_algebra (has_to_string linarith.comp))) : rank_condition (boolean_algebra (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_149818 (h0 : function.extfun Type topological_space) : @normal_space.{0} (complete_distrib_lattice.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} num))  := sorry --non-trivial
lemma new_lemma_149819 (h0 : group (measurable_space.dynkin_system congr_arg_kind)) : is_cyclic (measurable_space.dynkin_system congr_arg_kind) := sorry --non-trivial
lemma new_lemma_149820 (h0 : functor.add_const (ordered_comm_monoid (comm_group pos)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (comm_group.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_149821 (h0 : not (topological_space (has_one empty) -> false)) : @path_connected_space.{0} (has_one.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_one.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_149822 (h0 : topological_space (add_group linarith.comp)) : normal_space (add_group linarith.comp) := sorry --non-trivial
lemma new_lemma_149823 (h0 : not (topological_space (linear_ordered_add_comm_group (has_nnnorm linarith.comp_source)) -> false)) : @totally_disconnected_space.{0} (linear_ordered_add_comm_group.{0} (has_nnnorm.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_add_comm_group.{0} (has_nnnorm.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_149824 (h0 : functor.add_const (finset (has_neg pos)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_149825 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_149826 (h0 : topological_space (semigroup (has_pos_part linarith.comp))) : regular_space (semigroup (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_149827 (h0 : function.extfun (Type 1) filter) : countable_Inter_filter (function.extfun_app h0 (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_149828 (h0 : function.extfun Type topological_space) : @t1_space.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_149829 (h0 : functor.add_const (function.extfun Type group) (has_add (has_add Type))) : @is_simple_group.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) (has_add.{1} (has_add.{1} Type)) h0) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_149830 (h0 : topological_space (generalized_boolean_algebra (has_add pos))) : irreducible_space (generalized_boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_149831 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_149832 (h0 : ring (semi_normed_ring string.iterator_imp)) : rank_condition (semi_normed_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_149833 (h1 : complete_lattice environment.projection_info) : complete_lattice.is_Sup_finite_compact environment.projection_info := sorry --non-trivial
lemma new_lemma_149834 (h2 : ring (has_nnnorm linarith.comp_source)) : strong_rank_condition (has_nnnorm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_149835 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_149836 (h0 : random_gen (add_group unsigned) -> random_gen (add_group unsigned) -> Prop) : is_strict_order (random_gen (add_group unsigned)) h0 := sorry --non-trivial
lemma new_lemma_149837 (h0 : uniform_space (distrib (mul_one_class (mul_one_class Type)))) : complete_space (distrib (mul_one_class (mul_one_class Type))) := sorry --non-trivial
lemma new_lemma_149838 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (dlist.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (dlist.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_149839 (h0 : not (ring (pseudo_emetric_space char) -> false)) : @is_domain.{0} (pseudo_emetric_space.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (pseudo_emetric_space.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_149840 (h0 : topological_space (uniform_space (has_compl linarith.comp_source))) : t0_space (uniform_space (has_compl linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_149841 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_to_string unsigned)) Type) : @unique_factorization_monoid.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (has_to_string.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_149842 (h0 : add_group (has_add ennreal)) : is_add_cyclic (has_add ennreal) := sorry --non-trivial
lemma new_lemma_149843 (h0 : cancel_comm_monoid_with_zero (has_neg (option num))) : unique_factorization_monoid (has_neg (option num)) := sorry --non-trivial
lemma new_lemma_149844 (h0 : char -> Prop) : function.sometimes h0 := sorry --non-trivial
lemma new_lemma_149845 (h0 : topological_space (has_norm congr_arg_kind)) : irreducible_space (has_norm congr_arg_kind) := sorry --non-trivial
lemma new_lemma_149846 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_149847 (h1 : function.extfun Type uniform_space) : @complete_space.{0} (@id.{2} Type string_imp) (@function.extfun_app.{2 1} Type uniform_space.{0} h1 (@id.{2} Type string_imp))  := sorry --non-trivial
lemma new_lemma_149848 (h0 : not (filter (has_sub congr_arg_kind) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_149849 (h2 : topological_space (semi_normed_ring string.iterator_imp)) : t0_space (semi_normed_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_149850 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) (ring Type)) : @complete_lattice.is_Sup_finite_compact.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) (ring.{1} Type) h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_149851 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_149852 (h0 : functor.add_const (uniform_space (add_cancel_monoid linarith.comp)) Type) : @separated_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (add_cancel_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_149853 (h0 : semiring (free_add_monoid (option unsigned))) : is_noetherian_ring (free_add_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_149854 (h0 : complete_lattice (add_cancel_monoid (boolean_algebra name))) : is_compactly_generated (add_cancel_monoid (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_149855 (h1 : function.extfun Type topological_space) : path_connected_space empty := sorry --non-trivial
lemma new_lemma_149856 (h0 : topological_space (canonically_ordered_comm_semiring pos)) : path_connected_space (canonically_ordered_comm_semiring pos) := sorry --non-trivial
lemma new_lemma_149857 (h0 : list (semiring (semiring (semiring (semiring empty))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_149858 (h0 : finset (has_pos_part (has_Inf (ordered_comm_monoid real)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_149859 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_149860 (h0 : topological_space (has_union (semiring congr_arg_kind))) : normal_space (has_union (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_149861 (h0 : topological_space (has_neg (has_neg linarith.comp))) : totally_separated_space (has_neg (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_149862 (h0 : list (add_cancel_monoid (boolean_algebra.core (semigroup unsigned)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_149863 (h0 : topological_space (has_emptyc (has_norm (has_norm (has_norm (has_norm to_additive.value_type)))))) : discrete_topology (has_emptyc (has_norm (has_norm (has_norm (has_norm to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_149864 (h0 : ring (has_neg_part (normed_comm_ring Type))) : strong_rank_condition (has_neg_part (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_149865 (h0 : group (mul_zero_class pos)) : is_simple_group (mul_zero_class pos) := sorry --non-trivial
lemma new_lemma_149866 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (ordered_cancel_add_comm_monoid empty)) := sorry --non-trivial
lemma new_lemma_149867 (h0 : monoid (cancel_monoid (has_add environment.implicit_infer_kind))) : monoid.fg (cancel_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_149868 (h0 : not (group (has_sub unsigned) -> false)) : @group.fg.{0} (has_sub.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (has_sub.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_149869 (h0 : functor.add_const (topological_space (has_star empty)) (semiring (semiring (semiring empty)))) : @discrete_topology.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} empty)) (semiring.{0} (semiring.{0} (semiring.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_149870 (h0 : has_mem.mem (has_top unsigned) has_emptyc.emptyc) : @preirreducible_space.{0} (has_top.{0} unsigned) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_149871 (h0 : topological_space (random_gen (comm_ring (comm_ring (has_nnnorm reducibility_hints))))) : t0_space (random_gen (comm_ring (comm_ring (has_nnnorm reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_149872 (h0 : complete_lattice (boolean_algebra (cancel_monoid (cancel_monoid pos)))) : is_atomistic (boolean_algebra (cancel_monoid (cancel_monoid pos))) := sorry --non-trivial
lemma new_lemma_149873 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_149874 (h0 : functor.add_const (topological_space (cancel_monoid pos)) (comm_group name)) : @totally_separated_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} pos)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_149875 (h0 : semiring (non_assoc_semiring (semiring unsigned))) : is_noetherian_ring (non_assoc_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_149876 (h1 : ring (normed_field linarith.ineq)) : rank_condition (normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_149877 (h1 : uniform_space (has_compl (comm_ring string_imp))) : complete_space (has_compl (comm_ring string_imp)) := sorry --non-trivial
lemma new_lemma_149878 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_ordered_add_comm_group_with_top.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_add_comm_group_with_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_149879 (h0 : functor.add_const (function.extfun Type ring) Type) : @is_principal_ideal_ring.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_149880 (h0 : functor.add_const (function.extfun (Type 1) cancel_comm_monoid_with_zero) Type) : @unique_factorization_monoid.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1}) Type h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_149881 (h0 : functor.add_const (function.extfun Type finset) pos) : finset.nonempty (function.extfun_app (functor.add_const.run h0) linarith.comp) := sorry --non-trivial
lemma new_lemma_149882 (h0 : ring (uniform_space std_gen)) : rank_condition (uniform_space std_gen) := sorry --non-trivial
lemma new_lemma_149883 (h0 : topological_space (canonically_ordered_comm_semiring (option empty))) : normal_space (canonically_ordered_comm_semiring (option empty)) := sorry --non-trivial
lemma new_lemma_149884 (h0 : functor.add_const (uniform_space (add_cancel_monoid Type)) linarith.comp) : @separated_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (add_cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_149885 (h0 : complete_lattice (measurable_space (random_gen (random_gen to_additive.value_type)))) : is_atomistic (measurable_space (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_149886 (h0 : not (add_monoid (non_assoc_semiring num) -> false)) : @add_monoid.fg.{0} (non_assoc_semiring.{0} num) (@classical.by_contradiction'.{1} (add_monoid.{0} (non_assoc_semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_149887 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_neg.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_neg.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_149888 (h0 : functor.add_const (group (cancel_monoid pos)) Type) : @is_cyclic.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_149889 (h0 : functor.add_const (topological_space (linear_ordered_field empty)) num) : @totally_disconnected_space.{0} (linear_ordered_field.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_149890 (h2 : complete_lattice (has_add to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (has_add to_additive.value_type) := sorry --non-trivial
lemma new_lemma_149891 (h0 : cancel_comm_monoid_with_zero (ring (has_add name))) : unique_factorization_monoid (ring (has_add name)) := sorry --non-trivial
lemma new_lemma_149892 (h0 : ring (bin_tree (semiring (semiring congr_arg_kind)))) : is_domain (bin_tree (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_149893 (h0 : add_group (measure_theory.measure_space (semiring (semiring empty)))) : is_add_cyclic (measure_theory.measure_space (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_149894 (h0 : has_mem.mem (has_emptyc (has_inv (random_gen (has_inv (has_top linarith.ineq))))) has_emptyc.emptyc) : @is_atomistic.{0} (has_emptyc.{0} (has_inv.{0} (random_gen.{0} (has_inv.{0} (has_top.{0} linarith.ineq))))) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_emptyc.{0} (has_inv.{0} (random_gen.{0} (has_inv.{0} (has_top.{0} linarith.ineq))))) h0)  := sorry --non-trivial
lemma new_lemma_149895 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (finset.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} h0 (finset.{0} num))  := sorry --non-trivial
lemma new_lemma_149896 (h0 : not (finset (option congr_arg_kind) -> false)) : finset.nonempty (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_149897 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_149898 (h0 : group (finset (finset (finset (finset ennreal))))) : is_simple_group (finset (finset (finset (finset ennreal)))) := sorry --non-trivial
lemma new_lemma_149899 (h0 : topological_space (boolean_algebra real)) : sequential_space (boolean_algebra real) := sorry --non-trivial
lemma new_lemma_149900 (h0 : topological_space (finset Type)) : preconnected_space (finset Type) := sorry --non-trivial
lemma new_lemma_149901 (h0 : functor.add_const (topological_space (cancel_monoid Type)) Type) : @loc_path_connected_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_149902 (h0 : function.extfun (prod linarith.comp linarith.comp) (fun (x : prod linarith.comp linarith.comp), Prop)) (h1 : prod linarith.comp linarith.comp) : symmetrize_rel (function.extfun_app h0) h1 := sorry --non-trivial
lemma new_lemma_149903 (h0 : complete_lattice (semiring unsigned)) : is_atomistic (semiring unsigned) := sorry --non-trivial
lemma new_lemma_149904 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_149905 (h0 : functor.add_const (complete_lattice (linear_ordered_comm_group empty)) empty) : @is_compactly_generated.{0} (linear_ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_ordered_comm_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_149906 (h0 : ring (has_compl (random_gen (random_gen linarith.ineq)))) : is_domain (has_compl (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_149907 (h0 : topological_space (boolean_algebra (has_add (normed_comm_ring name)))) : regular_space (boolean_algebra (has_add (normed_comm_ring name))) := sorry --non-trivial
lemma new_lemma_149908 (h0 : not (topological_space (semi_normed_comm_ring (has_nnnorm fun_info)) -> false)) : @path_connected_space.{0} (semi_normed_comm_ring.{0} (has_nnnorm.{0} fun_info)) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_comm_ring.{0} (has_nnnorm.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_149909 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem add_monoid)) : @add_monoid.fg.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_monoid.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_monoid.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (linear_ordered_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_149910 (h0 : functor.add_const (uniform_space (add_cancel_monoid Type)) (has_nndist linarith.comp)) : @separated_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (add_cancel_monoid.{1} Type)) (has_nndist.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_149911 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_149912 (h0 : group (has_add (has_nnnorm fun_info))) : is_cyclic (has_add (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_149913 (h0 : topological_space (ordered_comm_monoid (ring pos))) : topological_space.separable_space (ordered_comm_monoid (ring pos)) := sorry --non-trivial
lemma new_lemma_149914 (h0 : filter (linear_ordered_field (has_to_string congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_149915 (h0 : ring (semiring (random_gen (random_gen (random_gen fun_info))))) : strong_rank_condition (semiring (random_gen (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_149916 (h0 : group (topological_space (metric_space (mul_one_class char)))) : is_cyclic (topological_space (metric_space (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_149917 (h0 : semiring (option (ordered_cancel_comm_monoid unsigned))) : is_noetherian_ring (option (ordered_cancel_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_149918 (h0 : group (id (has_top (has_top linarith.ineq)))) : normalizer_condition (id (has_top (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_149919 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_149920 (h0 : add_monoid (has_add (ordered_comm_monoid (sub_neg_monoid real)))) : add_monoid.fg (has_add (ordered_comm_monoid (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_149921 (h0 : topological_space (comm_ring (random_gen (random_gen linarith.ineq)))) : irreducible_space (comm_ring (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_149922 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_149923 (h0 : function.extfun Type (functor.add_const (topological_space (boolean_algebra linarith.comp)))) : @totally_separated_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_149924 (h0 : ring (has_inter (option empty))) : is_domain (has_inter (option empty)) := sorry --non-trivial
lemma new_lemma_149925 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_149926 (h0 : function.extfun Type topological_space) : @t0_space.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_149927 (h0 : not (ring (div_inv_monoid linarith.ineq) -> false)) : @is_domain.{0} (div_inv_monoid.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (div_inv_monoid.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_149928 (h0 : complete_lattice (canonically_linear_ordered_monoid name)) : is_atomistic (canonically_linear_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_149929 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_149930 (h0 : function.extfun Type topological_space) : @t0_space.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_149931 (h0 : function.extfun Type topological_space) : totally_separated_space real := sorry --non-trivial
lemma new_lemma_149932 (h0 : not (ring (linear_ordered_comm_ring unsigned) -> false)) : @is_principal_ideal_ring.{0} (linear_ordered_comm_ring.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_comm_ring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_149933 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_149934 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_149935 (h0 : topological_space (has_to_string (has_nndist (complete_distrib_lattice unsigned)))) : locally_compact_space (has_to_string (has_nndist (complete_distrib_lattice unsigned))) := sorry --non-trivial
lemma new_lemma_149936 (h0 : topological_space (has_zero (has_add pos))) : totally_disconnected_space (has_zero (has_add pos)) := sorry --non-trivial
lemma new_lemma_149937 (h0 : functor.add_const (topological_space (has_bot unsigned)) unsigned) : @totally_separated_space.{0} (has_bot.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_149938 (h0 : thunk pnat) (h1 : fin has_zero.zero) : @id.{1} Prop (pnat.coprime (@trace_call_stack.{0} pnat h0) (@matrix.vec_empty.{0} pnat h1))  := sorry --non-trivial
lemma new_lemma_149939 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) (add_comm_monoid pos)) : @sequential_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) (add_comm_monoid.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_149940 (h0 : has_mem.mem (has_norm congr_arg_kind) has_emptyc.emptyc) : @t0_space.{0} (has_norm.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_149941 (h1 : ring (comm_ring (has_nnnorm string_imp))) : rank_condition (comm_ring (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_149942 (h0 : functor.add_const (functor.add_const (ordered_add_comm_monoid Type) pos) Type) : @archimedean.{1} Type (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} Type) pos (@functor.add_const.run.{1 1} (functor.add_const.{1 0} (ordered_add_comm_monoid.{1} Type) pos) Type h0))  := sorry --non-trivial
lemma new_lemma_149943 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 complete_lattice.{0}) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_149944 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (@id.{2} Type fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (@id.{2} Type fun_info))  := sorry --non-trivial
lemma new_lemma_149945 (h0 : topological_space (partial_order (semiring empty))) : path_connected_space (partial_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_149946 (h0 : cancel_comm_monoid_with_zero (has_dist (option unsigned))) : unique_factorization_monoid (has_dist (option unsigned)) := sorry --non-trivial
lemma new_lemma_149947 (h0 : add_monoid (boolean_algebra.core (ring pos))) : add_monoid.fg (boolean_algebra.core (ring pos)) := sorry --non-trivial
lemma new_lemma_149948 (h0 : topological_space (encodable (random_gen (has_ssubset (random_gen (comm_ring linarith.ineq)))))) : t0_space (encodable (random_gen (has_ssubset (random_gen (comm_ring linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_149949 (h0 : topological_space (linear_ordered_comm_group congr_arg_kind)) : preirreducible_space (linear_ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_149950 (h0 : function.extfun Type topological_space) (h1 : set linarith.comp_source) : @is_totally_separated.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} h0 linarith.comp_source) h1  := sorry --non-trivial
lemma new_lemma_149951 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preirreducible_space.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_149952 (h0 : add_monoid (add_comm_monoid (sub_neg_monoid real))) : add_monoid.fg (add_comm_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_149953 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (option.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (option.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_149954 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (simple_graph.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (simple_graph.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_149955 (h0 : topological_space (boolean_algebra.core (has_add (has_Inf (ring linarith.comp))))) : sequential_space (boolean_algebra.core (has_add (has_Inf (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_149956 (h0 : false) : false := sorry --assumption
lemma new_lemma_149957 (h0 : topological_space (has_zero (ring unsigned))) : t0_space (has_zero (ring unsigned)) := sorry --non-trivial
lemma new_lemma_149958 (h0 : list (add_cancel_monoid (comm_group name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_149959 (h0 : topological_space (as_linear_order pos)) : path_connected_space (as_linear_order pos) := sorry --non-trivial
lemma new_lemma_149960 (h0 : functor.add_const (ring (has_pos_part linarith.comp)) (has_add (ring (has_Inf (ring linarith.comp))))) : @rank_condition.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_pos_part.{0} linarith.comp)) (has_add.{0} (ring.{0} (has_Inf.{0} (ring.{0} linarith.comp)))) h0)  := sorry --non-trivial
lemma new_lemma_149961 (h0 : functor.add_const (ring (comm_group unsigned)) linarith.comp) : @is_domain.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_149962 (h0 : monoid (complete_semilattice_Sup (has_inv (random_gen (has_inv to_additive.value_type))))) : monoid.fg (complete_semilattice_Sup (has_inv (random_gen (has_inv to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_149963 (h1 : ring (has_compl linarith.ineq)) : strong_rank_condition (has_compl linarith.ineq) := sorry --non-trivial
lemma new_lemma_149964 (h0 : complete_lattice (add_monoid linarith.ineq)) : is_compactly_generated (add_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_149965 (h0 : complete_lattice (add_right_cancel_monoid (semiring unsigned))) : is_atomistic (add_right_cancel_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_149966 (h0 : ring (add_cancel_comm_monoid (random_gen string_imp))) : rank_condition (add_cancel_comm_monoid (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_149967 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_149968 (h0 : uniform_space (semiring (semiring num))) : separated_space (semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_149969 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (has_Inf Type)) : @t1_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} pos)) (has_Inf.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_149970 (h0 : topological_space (has_compl char)) : locally_compact_space (has_compl char) := sorry --non-trivial
lemma new_lemma_149971 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_149972 (h0 : functor.add_const (function.extfun (Type 1) add_monoid) linarith.comp) : @add_monoid.fg.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_monoid.{1}) linarith.comp h0) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_149973 (h0 : ring (normed_comm_ring name)) : is_domain (normed_comm_ring name) := sorry --non-trivial
lemma new_lemma_149974 (h1 : uniform_space (has_add (div_inv_monoid char))) : complete_space (has_add (div_inv_monoid char)) := sorry --non-trivial
lemma new_lemma_149975 (h0 : filter (has_to_string (has_add environment.implicit_infer_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_149976 (h0 : topological_space (has_zero environment.implicit_infer_kind)) : t1_space (has_zero environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_149977 (h0 : function.extfun Type topological_space) : @t1_space.{0} (normed_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_149978 (h2 : not (topological_space (topological_space fun_info) -> false)) : @totally_disconnected_space.{0} (topological_space.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (topological_space.{0} fun_info)) h2)  := sorry --non-trivial
lemma new_lemma_149979 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_149980 (h0 : not (complete_lattice (simple_graph enat) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (simple_graph.{0} enat) (@classical.by_contradiction'.{1} (complete_lattice.{0} (simple_graph.{0} enat)) h0)  := sorry --non-trivial
lemma new_lemma_149981 (h0 : add_group (normed_comm_ring (finset (has_zero (semigroup Type))))) : is_add_cyclic (normed_comm_ring (finset (has_zero (semigroup Type)))) := sorry --non-trivial
lemma new_lemma_149982 (h0 : topological_space (comm_semigroup (has_bot real))) : discrete_topology (comm_semigroup (has_bot real)) := sorry --non-trivial
lemma new_lemma_149983 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf (has_Inf (has_Inf pos))))) : t0_space (normed_lattice_add_comm_group (has_Inf (has_Inf (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_149984 (h0 : topological_space (semiring (has_top (has_top (has_top (has_top fun_info))))) -> num) (h1 : coe_sort (set.range h0)) : @irreducible_space.{0} (semiring.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} fun_info))))) (@set.range_splitting.{0 0} (topological_space.{0} (semiring.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} fun_info)))))) num h0 h1)  := sorry --non-trivial
lemma new_lemma_149985 (h0 : functor.add_const (monoid (has_neg name)) Type) : @monoid.fg.{0} (has_neg.{0} name) (@functor.add_const.run.{0 1} (monoid.{0} (has_neg.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_149986 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) linarith.comp) : @t0_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_149987 (h0 : uniform_space (random_gen (has_nnnorm fun_info))) : complete_space (random_gen (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_149988 (h0 : has_mem.mem (linear_ordered_semiring empty) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_semiring.{0} empty) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (linear_ordered_semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_149989 (h0 : set (semi_normed_comm_ring ereal)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_149990 (h0 : uniform_space (bin_tree num)) : separated_space (bin_tree num) := sorry --non-trivial
lemma new_lemma_149991 (h0 : functor.add_const (group (plift empty)) num) : @normalizer_condition.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (group.{1} (plift.{1} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_149992 (h0 : add_monoid (has_dist num)) : add_monoid.fg (has_dist num) := sorry --non-trivial
lemma new_lemma_149993 (h0 : function.extfun (Type 1) topological_space) : @loc_path_connected_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_149994 (h0 : ring (has_add (option (option (option (option (option ennreal))))))) : is_domain (has_add (option (option (option (option (option ennreal)))))) := sorry --non-trivial
lemma new_lemma_149995 (h0 : group (canonically_ordered_comm_semiring name)) : is_simple_group (canonically_ordered_comm_semiring name) := sorry --non-trivial
lemma new_lemma_149996 (h0 : functor.add_const (filter (has_neg Type)) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_149997 (h0 : ring (has_compl fun_info)) : rank_condition (has_compl fun_info) := sorry --non-trivial
lemma new_lemma_149998 (h1 : complete_lattice (has_lt to_additive.value_type)) : is_compactly_generated (has_lt to_additive.value_type) := sorry --non-trivial
lemma new_lemma_149999 (h0 : functor.add_const (complete_lattice (add_cancel_monoid pos)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_150000 (h1 : not (group (with_one num) -> false)) : @is_cyclic.{0} (with_one.{0} num) (@classical.by_contradiction'.{1} (group.{0} (with_one.{0} num)) h1)  := sorry --non-trivial
lemma new_lemma_150001 (h0 : topological_space (has_Sup unsigned)) : preirreducible_space (has_Sup unsigned) := sorry --non-trivial
lemma new_lemma_150002 (h0 : group (has_neg pos)) : normalizer_condition (has_neg pos) := sorry --non-trivial
lemma new_lemma_150003 (h0 : function.extfun Type group) : @normalizer_condition.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_150004 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_150005 (h0 : functor.comp group option pos) : @is_cyclic.{0} (option.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (option.{0} pos)) pos (@functor.comp.run.{0 0 0} group.{0} option.{0} pos h0))  := sorry --non-trivial
lemma new_lemma_150006 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_noetherian_ring.{0} (simple_graph.{0} linarith.comp) (@matrix.vec_empty.{0} (semiring.{0} (simple_graph.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_150007 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_150008 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @locally_compact_space.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_150009 (h0 : not (uniform_space (has_emptyc num) -> false)) : @separated_space.{0} (has_emptyc.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_emptyc.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_150010 (h0 : topological_space (has_to_string (add_cancel_monoid name))) : regular_space (has_to_string (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_150011 (h0 : functor.add_const (ring (linear_order num)) empty) : @is_domain.{0} (linear_order.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (linear_order.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_150012 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_star.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_star.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_150013 (h0 : functor.add_const (finset (has_to_string pos)) (has_neg Type)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_150014 (h0 : complete_lattice (pseudo_metric_space (option pos))) : is_atomistic (pseudo_metric_space (option pos)) := sorry --non-trivial
lemma new_lemma_150015 (h0 : ring (linear_ordered_cancel_comm_monoid (semiring empty))) : rank_condition (linear_ordered_cancel_comm_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_150016 (h0 : topological_space (id (has_norm (has_norm (has_norm (has_norm (has_norm congr_arg_kind))))))) : locally_compact_space (id (has_norm (has_norm (has_norm (has_norm (has_norm congr_arg_kind)))))) := sorry --non-trivial
lemma new_lemma_150017 (h0 : filter (has_to_string (option congr_arg_kind))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_150018 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_150019 (h0 : ordered_comm_monoid (has_neg (option ennreal))) : has_exists_mul_of_le (has_neg (option ennreal)) := sorry --non-trivial
lemma new_lemma_150020 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) linarith.comp) : @has_exists_mul_of_le.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) linarith.comp h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_150021 (h0 : function.extfun (Type 1) filter) : filter.ne_bot (function.extfun_app h0 Type) := sorry --non-trivial
lemma new_lemma_150022 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_150023 (h0 : function.extfun nat fin) : @group.fg.{0} (has_Inf.{0} name) (@matrix.vec_empty.{0} (group.{0} (has_Inf.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_150024 (h0 : not (complete_lattice unsigned -> false)) : @is_compactly_generated.{0} unsigned (@classical.by_contradiction'.{1} (complete_lattice.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_150025 (h0 : ring (has_union num)) : is_principal_ideal_ring (has_union num) := sorry --non-trivial
lemma new_lemma_150026 (h0 : complete_lattice (normed_group (random_gen string_imp))) : is_atomistic (normed_group (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_150027 (h0 : function.extfun Type (functor.add_const (topological_space (ring pos)))) : @totally_disconnected_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (ring.{0} pos))) h0 (finset.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_150028 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) linarith.comp) : @path_connected_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_150029 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_150030 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_150031 (h0 : functor.add_const (topological_space (has_Inf pos)) (has_neg pos)) : @preconnected_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_150032 (h0 : add_group (has_nndist empty)) : is_add_cyclic (has_nndist empty) := sorry --non-trivial
lemma new_lemma_150033 (h0 : group (uniform_space (denumerable (topological_space enat)))) : is_cyclic (uniform_space (denumerable (topological_space enat))) := sorry --non-trivial
lemma new_lemma_150034 (h0 : complete_lattice (with_bot (semiring empty))) : is_compactly_generated (with_bot (semiring empty)) := sorry --non-trivial
lemma new_lemma_150035 (h0 : ring (omega_complete_partial_order empty)) : rank_condition (omega_complete_partial_order empty) := sorry --non-trivial
lemma new_lemma_150036 (h0 : ring (cancel_monoid ennreal)) : strong_rank_condition (cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_150037 (h0 : complete_lattice (with_one (has_inv to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (with_one (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_150038 (h1 : topological_space (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup fun_info)))) : path_connected_space (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup fun_info))) := sorry --non-trivial
lemma new_lemma_150039 (h0 : topological_space (has_one (semiring congr_arg_kind))) : path_connected_space (has_one (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_150040 (h0 : functor.comp (functor.comp ring cancel_monoid) with_top nnreal) : @is_principal_ideal_ring.{0} (cancel_monoid.{0} ennreal) (@functor.comp.run.{0 0 0} ring.{0} cancel_monoid.{0} ennreal (@functor.comp.run.{0 0 0} (functor.comp.{0 0 0} ring.{0} cancel_monoid.{0}) with_top.{0} nnreal h0))  := sorry --non-trivial
lemma new_lemma_150041 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_150042 (h0 : functor.add_const (ordered_comm_monoid environment.implicit_infer_kind) (has_nndist (has_nndist pos))) : @has_exists_mul_of_le.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} environment.implicit_infer_kind) (has_nndist.{0} (has_nndist.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_150043 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) Type) : @sequential_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_150044 (h0 : add_group (boolean_algebra (has_add (has_add Type)))) : is_add_cyclic (boolean_algebra (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_150045 (h0 : functor.add_const (function.extfun (Type 1) ring) Type) : @is_domain.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) Type h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_150046 (h0 : topological_space (has_add (mul_one_class linarith.comp))) : preirreducible_space (has_add (mul_one_class linarith.comp)) := sorry --non-trivial
lemma new_lemma_150047 (h0 : topological_space (has_norm (random_gen (random_gen linarith.ineq)))) : path_connected_space (has_norm (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_150048 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring Type)) Type) : @is_principal_ideal_ring.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (canonically_ordered_comm_semiring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_150049 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_150050 (h0 : add_group (simple_graph (has_pos_part linarith.comp))) : is_add_cyclic (simple_graph (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_150051 (h0 : finset (ordered_comm_ring pos)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_150052 (h0 : cancel_comm_monoid_with_zero (add_cancel_monoid ennreal)) : unique_factorization_monoid (add_cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_150053 (h0 : topological_space (canonically_linear_ordered_monoid (has_add linarith.comp))) : irreducible_space (canonically_linear_ordered_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_150054 (h0 : topological_space (normed_field to_additive.value_type)) (h1 : preorder (normed_field to_additive.value_type)) : order_topology (normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_150055 (h0 : not (group (has_nnnorm to_additive.value_type) -> false)) : @is_cyclic.{0} (has_nnnorm.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (has_nnnorm.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_150056 (h0 : function.extfun Type ring) : @is_domain.{0} (normed_group.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_150057 (h0 : topological_space (metric_space (has_top num))) : topological_space.separable_space (metric_space (has_top num)) := sorry --non-trivial
lemma new_lemma_150058 (h0 : topological_space (has_add (complete_distrib_lattice (has_add pos)))) : totally_separated_space (has_add (complete_distrib_lattice (has_add pos))) := sorry --non-trivial
lemma new_lemma_150059 (h0 : topological_space (normed_field linarith.ineq)) (h1 : preorder (normed_field linarith.ineq)) : order_topology (normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_150060 (h0 : ring (linear_ordered_field (option unsigned))) : rank_condition (linear_ordered_field (option unsigned)) := sorry --non-trivial
lemma new_lemma_150061 (h0 : filter (add_comm_monoid (comm_group (comm_group (has_add name))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_150062 (h0 : functor.add_const (topological_space (option num)) (semiring (semiring (semiring empty)))) : @discrete_topology.{0} (option.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} num)) (semiring.{0} (semiring.{0} (semiring.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_150063 (h0 : ring (linear_ordered_add_comm_group (has_inv linarith.comp_source))) : is_domain (linear_ordered_add_comm_group (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_150064 (h0 : functor.add_const (list (has_neg_part pos)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_150065 (h0 : topological_space (has_top (random_gen (random_gen linarith.ineq)))) : totally_disconnected_space (has_top (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_150066 (h0 : function.extfun Type group) : @normalizer_condition.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_150067 (h0 : topological_space (generalized_boolean_algebra (has_Inf linarith.comp))) : irreducible_space (generalized_boolean_algebra (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_150068 (h0 : ring (has_compl (has_nnnorm (has_nnnorm fun_info)))) : is_domain (has_compl (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_150069 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_150070 (h0 : complete_lattice (complete_distrib_lattice (has_add name))) : complete_lattice.is_Sup_finite_compact (complete_distrib_lattice (has_add name)) := sorry --non-trivial
lemma new_lemma_150071 (h0 : topological_space (has_one (semiring unsigned))) : normal_space (has_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_150072 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_bot (option unsigned))) := sorry --non-trivial
lemma new_lemma_150073 (h0 : functor.add_const (filter (partial_order unsigned)) congr_arg_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_150074 (h0 : topological_space (ordered_ring (option (option (option unsigned))))) : irreducible_space (ordered_ring (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_150075 (h0 : topological_space (canonically_ordered_monoid (has_Inf Type))) : totally_separated_space (canonically_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_150076 (h0 : ring (has_zero Type)) : is_domain (has_zero Type) := sorry --non-trivial
lemma new_lemma_150077 (h0 : topological_space (filter unsigned)) : totally_separated_space (filter unsigned) := sorry --non-trivial
lemma new_lemma_150078 (h0 : function.extfun Type ring) : @is_domain.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_150079 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_150080 (h0 : complete_lattice (random_gen (has_norm (has_norm linarith.comp)))) : complete_lattice.is_Sup_finite_compact (random_gen (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_150081 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_150082 (h0 : uniform_space (has_nndist (has_zero linarith.comp))) : complete_space (has_nndist (has_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_150083 (h0 : uniform_space (with_zero linarith.comp_source)) : complete_space (with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_150084 (h0 : functor.add_const (complete_lattice (boolean_algebra.core Type)) name) : @is_compactly_generated.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (boolean_algebra.core.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_150085 (h0 : functor.add_const (topological_space (ring name)) linarith.comp) : @t1_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_150086 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (ordered_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_150087 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_neg.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_150088 (h0 : topological_space (has_nndist congr_arg_kind)) : t0_space (has_nndist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_150089 (h0 : ring (non_unital_non_assoc_semiring (has_nnnorm string_imp))) : is_domain (non_unital_non_assoc_semiring (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_150090 (h0 : filter (linear_ordered_semiring empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_150091 (h0 : topological_space (has_norm (comm_ring (has_norm to_additive.value_type)))) : irreducible_space (has_norm (comm_ring (has_norm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_150092 (h0 : functor.add_const (uniform_space (add_comm_monoid linarith.comp)) linarith.comp) : @complete_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_comm_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_150093 (h0 : functor.add_const (topological_space (simple_graph unsigned)) (option (option empty))) : @preirreducible_space.{0} (simple_graph.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} unsigned)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_150094 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_150095 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) pos) : @loc_path_connected_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_150096 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_150097 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (linear_ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_150098 (h0 : list (preorder (option unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_150099 (h0 : fin has_zero.zero) : @separated_space.{0} (has_Inf.{0} name) (@matrix.vec_empty.{0} (uniform_space.{0} (has_Inf.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_150100 (h0 : ring (has_nndist (has_neg (has_add (ring linarith.comp))))) : strong_rank_condition (has_nndist (has_neg (has_add (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_150101 (h0 : monoid (has_union (has_norm (has_norm (add_group empty))))) : monoid.fg (has_union (has_norm (has_norm (add_group empty)))) := sorry --non-trivial
lemma new_lemma_150102 (h0 : has_mem.mem (boolean_algebra.core num) has_zero.zero) : @group.fg.{0} (boolean_algebra.core.{0} num) (@multiset.pi.empty.{1 0} Type group.{0} (boolean_algebra.core.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_150103 (h0 : ring (add_cancel_monoid unsigned)) : strong_rank_condition (add_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_150104 (h0 : topological_space (has_zero num)) : normal_space (has_zero num) := sorry --non-trivial
lemma new_lemma_150105 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_zero name)) := sorry --non-trivial
lemma new_lemma_150106 (h0 : list (has_to_string environment.implicit_infer_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_150107 (h0 : complete_lattice (filter (option empty))) : is_compactly_generated (filter (option empty)) := sorry --non-trivial
lemma new_lemma_150108 (h0 : topological_space (ordered_comm_monoid (has_neg Type))) : t1_space (ordered_comm_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_150109 (h0 : functor.add_const (ring (has_dist unsigned)) (option empty)) : @is_principal_ideal_ring.{0} (has_dist.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_dist.{0} unsigned)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_150110 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_150111 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_150112 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (linear_ordered_comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_150113 (h0 : fin has_zero.zero) : @regular_space.{0} (add_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))))  := sorry --non-trivial
lemma new_lemma_150114 (h0 : ring (with_one (semiring num))) : is_domain (with_one (semiring num)) := sorry --non-trivial
lemma new_lemma_150115 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (with_bot empty)) := sorry --non-trivial
lemma new_lemma_150116 (h0 : functor.add_const (group (finset name)) (mul_zero_class (add_cancel_monoid (finset Type)))) : @group.fg.{0} (finset.{0} name) (@functor.add_const.run.{0 1} (group.{0} (finset.{0} name)) (mul_zero_class.{1} (add_cancel_monoid.{1} (finset.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_150117 (h0 : cancel_comm_monoid_with_zero (ordered_comm_monoid (finset Type))) : unique_factorization_monoid (ordered_comm_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_150118 (h0 : uniform_space (has_add (has_ssubset string_imp))) : complete_space (has_add (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_150119 (h0 : not (ring (has_div enat) -> false)) : @is_domain.{0} (has_div.{0} enat) (@classical.by_contradiction'.{1} (ring.{0} (has_div.{0} enat)) h0)  := sorry --non-trivial
lemma new_lemma_150120 (h0 : uniform_space (simple_graph (mul_one_class to_additive.value_type))) : complete_space (simple_graph (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_150121 (h0 : topological_space (ordered_comm_ring (has_add (has_Inf Type)))) : locally_compact_space (ordered_comm_ring (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_150122 (h0 : not (monoid (measurable_space linarith.ineq) -> false)) : @monoid.fg.{0} (measurable_space.{0} linarith.ineq) (@classical.by_contradiction'.{1} (monoid.{0} (measurable_space.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_150123 (h0 : topological_space (normed_comm_ring (has_add environment.implicit_infer_kind))) : t1_space (normed_comm_ring (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_150124 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (sub_neg_monoid.{0} (has_Inf.{0} linarith.comp)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} (has_Inf.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_150125 (h0 : complete_lattice (distrib_lattice to_additive.value_type) -> to_additive.value_type) (h1 : coe_sort (set.range h0)) : @is_compactly_generated.{0} (distrib_lattice.{0} to_additive.value_type) (@set.range_splitting.{0 0} (complete_lattice.{0} (distrib_lattice.{0} to_additive.value_type)) to_additive.value_type h0 h1)  := sorry --non-trivial
lemma new_lemma_150126 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} real.angle (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) real.angle)  := sorry --non-trivial
lemma new_lemma_150127 (h0 : functor.add_const (topological_space (semigroup name)) environment.implicit_infer_kind) : @totally_separated_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_150128 (h0 : add_group (normed_field environment.projection_info)) : is_add_cyclic (normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_150129 (h0 : group (has_norm (semiring fun_info))) : group.fg (has_norm (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_150130 (h0 : ring (random_gen reducibility_hints)) : is_domain (random_gen reducibility_hints) := sorry --non-trivial
lemma new_lemma_150131 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} num))  := sorry --non-trivial
lemma new_lemma_150132 (h0 : topological_space (has_add (finset Type))) : totally_disconnected_space (has_add (finset Type)) := sorry --non-trivial
lemma new_lemma_150133 (h0 : semiring (complete_distrib_lattice (has_Inf real))) : is_noetherian_ring (complete_distrib_lattice (has_Inf real)) := sorry --non-trivial
lemma new_lemma_150134 (h0 : ring (has_union (semiring linarith.comp))) : rank_condition (has_union (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_150135 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @unique_factorization_monoid.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (cancel_comm_monoid_with_zero.{1} (normed_lattice_add_comm_group.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_150136 (h0 : functor.add_const (topological_space (has_nndist Type)) name) : @normal_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_150137 (h0 : functor.add_const (uniform_space pos) (has_Inf pos)) : @complete_space.{0} pos (@functor.add_const.run.{0 0} (uniform_space.{0} pos) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_150138 (h0 : filter (linear_ordered_comm_group (option num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_150139 (h0 : set (distrib linarith.ineq)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_150140 (h0 : pnat) (h1 : fin has_zero.zero) : pnat.coprime h0 (matrix.vec_empty (matrix.vec_empty (matrix.vec_empty h1))) := sorry --non-trivial
lemma new_lemma_150141 (h2 : complete_lattice (has_compl to_additive.value_type)) : is_compactly_generated (has_compl to_additive.value_type) := sorry --non-trivial
lemma new_lemma_150142 (h0 : function.extfun Type topological_space) : @t0_space.{0} (monoid_with_zero.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid_with_zero.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_150143 (h0 : ring (has_nnnorm (has_append (has_nnnorm linarith.comp_source)))) : rank_condition (has_nnnorm (has_append (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_150144 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) pos) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_150145 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_150146 (h0 : semiring (has_union (has_norm (semiring (semiring unsigned))))) : is_noetherian_ring (has_union (has_norm (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_150147 (h0 : complete_lattice (with_bot (semiring (semiring congr_arg_kind)))) : is_atomistic (with_bot (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_150148 (h0 : group (partial_order (semiring (semiring congr_arg_kind)))) : group.fg (partial_order (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_150149 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (measurable_space.dynkin_system.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (measurable_space.dynkin_system.{0} empty))  := sorry --non-trivial
lemma new_lemma_150150 (h0 : functor.add_const (add_monoid (free_add_monoid empty)) empty) : add_monoid.fg (free_add_monoid empty) := sorry --non-trivial
lemma new_lemma_150151 (h0 : fin has_zero.zero) : @is_compactly_generated.{1} (finset.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (finset.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_150152 (h0 : functor.add_const (list (semiring num)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_150153 (h1 : monoid num) : monoid.fg num := sorry --non-trivial
lemma new_lemma_150154 (h0 : group (monoid unsigned)) : is_simple_group (monoid unsigned) := sorry --non-trivial
lemma new_lemma_150155 (h0 : topological_space (add_comm_monoid (has_bot (has_add (has_Inf real))))) : topological_space.separable_space (add_comm_monoid (has_bot (has_add (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_150156 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (filter.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (filter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_150157 (h0 : add_monoid (bin_tree (semiring empty))) : add_monoid.fg (bin_tree (semiring empty)) := sorry --non-trivial
lemma new_lemma_150158 (h0 : topological_space (has_neg unsigned)) : preirreducible_space (has_neg unsigned) := sorry --non-trivial
lemma new_lemma_150159 (h0 : list (distrib_lattice (random_gen fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_150160 (h0 : topological_space (has_to_string (has_norm num))) : discrete_topology (has_to_string (has_norm num)) := sorry --non-trivial
lemma new_lemma_150161 (h0 : functor.add_const (topological_space (bin_tree congr_arg_kind)) num) : @normal_space.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_150162 (h0 : functor.add_const (ring (finset pos)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_150163 (h0 : semiring (linear_ordered_comm_ring num)) : is_noetherian_ring (linear_ordered_comm_ring num) := sorry --non-trivial
lemma new_lemma_150164 (h0 : topological_space (distrib (has_nnnorm reducibility_hints))) : t0_space (distrib (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_150165 (h0 : group (denumerable (has_nnnorm (has_nnnorm linarith.ineq)))) : is_cyclic (denumerable (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_150166 (h0 : topological_space (has_to_string environment.implicit_infer_kind)) : totally_separated_space (has_to_string environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_150167 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) (has_add linarith.comp)) : @preirreducible_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_150168 (h0 : ring (has_zero (has_to_string Type))) : is_domain (has_zero (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_150169 (h0 : functor.add_const (group (has_to_string name)) name) : @is_simple_group.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_150170 (h0 : topological_space (boolean_algebra (has_add name))) : totally_disconnected_space (boolean_algebra (has_add name)) := sorry --non-trivial
lemma new_lemma_150171 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_150172 (h0 : not (uniform_space (denumerable linarith.comp_source) -> false)) : @complete_space.{0} (denumerable.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (uniform_space.{0} (denumerable.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_150173 (h0 : has_mem.mem congr_arg_kind has_emptyc.emptyc) : @totally_disconnected_space.{0} congr_arg_kind (@finset.pi.empty.{1 0} Type topological_space.{0} congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_150174 (h1 : ring (random_gen linarith.comp_source)) : rank_condition (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_150175 (h0 : group (has_append fun_info)) : is_cyclic (has_append fun_info) := sorry --non-trivial
lemma new_lemma_150176 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @sequential_space.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_150177 (h0 : has_mem.mem (ordered_semiring to_additive.value_type) has_emptyc.emptyc) : @t0_space.{0} (ordered_semiring.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (ordered_semiring.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_150178 (h0 : set (set string.iterator_imp)) (h1 : set string.iterator_imp) : measurable_space.dynkin_system.generate_has h0 h1 := sorry --non-trivial
lemma new_lemma_150179 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_150180 (h0 : topological_space (with_one (random_gen (random_gen (random_gen linarith.comp))))) : t0_space (with_one (random_gen (random_gen (random_gen linarith.comp)))) := sorry --non-trivial
lemma new_lemma_150181 (h0 : ring (with_bot (id to_additive.value_type))) : is_domain (with_bot (id to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_150182 (h0 : function.extfun (Type 1) uniform_space) : @complete_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_150183 (h0 : functor.add_const (ring (has_pos_part name)) (ordered_ring (has_Inf (ring name)))) : @strong_rank_condition.{0} (has_pos_part.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_pos_part.{0} name)) (ordered_ring.{0} (has_Inf.{0} (ring.{0} name))) h0)  := sorry --non-trivial
lemma new_lemma_150184 (h0 : ring (semiring (has_top (random_gen (random_gen fun_info))))) : strong_rank_condition (semiring (has_top (random_gen (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_150185 (h0 : add_group empty -> add_group empty -> Prop) : is_strict_order (add_group empty) h0 := sorry --non-trivial
lemma new_lemma_150186 (h4 : complete_lattice (fintype fun_info)) : complete_lattice.is_Sup_finite_compact (fintype fun_info) := sorry --non-trivial
lemma new_lemma_150187 (h1 : complete_lattice fun_info) : is_compactly_generated fun_info := sorry --non-trivial
lemma new_lemma_150188 (h0 : complete_lattice (has_ssubset (metric_space to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (has_ssubset (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_150189 (h0 : ordered_comm_monoid (has_neg (option (option (option ennreal))))) : has_exists_mul_of_le (has_neg (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_150190 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_star empty)) num) : @unique_factorization_monoid.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_star.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_150191 (h0 : topological_space (left_cancel_monoid unsigned)) : preirreducible_space (left_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_150192 (h0 : ring (add_cancel_monoid ennreal)) : rank_condition (add_cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_150193 (h0 : uniform_space (normed_lattice_add_comm_group real)) : complete_space (normed_lattice_add_comm_group real) := sorry --non-trivial
lemma new_lemma_150194 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf (has_neg Type)))) : t1_space (canonically_linear_ordered_monoid (has_Inf (has_neg Type))) := sorry --non-trivial
lemma new_lemma_150195 (h0 : topological_space (semiring linarith.comp)) : totally_disconnected_space (semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_150196 (h0 : cancel_comm_monoid_with_zero (id (semiring (semiring unsigned)))) : unique_factorization_monoid (id (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_150197 (h0 : topological_space (with_bot (semiring (semiring (semiring (semiring congr_arg_kind)))))) : t1_space (with_bot (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_150198 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (group_with_zero ennreal)) := sorry --non-trivial
lemma new_lemma_150199 (h0 : topological_space (has_add (has_add (has_add (has_bot (has_Inf (has_add real))))))) : totally_disconnected_space (has_add (has_add (has_add (has_bot (has_Inf (has_add real)))))) := sorry --non-trivial
lemma new_lemma_150200 (h0 : ring (has_neg (option ennreal))) : is_principal_ideal_ring (has_neg (option ennreal)) := sorry --non-trivial
lemma new_lemma_150201 (h0 : functor.add_const (semiring (complete_distrib_lattice empty)) unsigned) : @is_noetherian_ring.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (complete_distrib_lattice.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_150202 (h0 : functor.add_const (monoid (boolean_algebra.core Type)) (has_add Type)) : @monoid.fg.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 1} (monoid.{1} (boolean_algebra.core.{1} Type)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_150203 (h0 : finset (has_Inf (ordered_ring pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_150204 (h0 : functor.add_const (topological_space (left_cancel_semigroup num)) (semiring (semiring num))) : @discrete_topology.{0} (left_cancel_semigroup.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} num)) (semiring.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_150205 (h0 : finset (boolean_algebra.core congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_150206 (h0 : function.extfun Type topological_space) : @normal_space.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_150207 (h0 : topological_space (has_to_string name)) : t1_space (has_to_string name) := sorry --non-trivial
lemma new_lemma_150208 (h0 : complete_lattice (with_one (has_top num))) : complete_lattice.is_Sup_finite_compact (with_one (has_top num)) := sorry --non-trivial
lemma new_lemma_150209 (h0 : functor.add_const (topological_space (has_add name)) name) : @loc_path_connected_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_150210 (h0 : ring (metric_space char)) : is_field (metric_space char) := sorry --non-trivial
lemma new_lemma_150211 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) linarith.comp) : @preirreducible_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_150212 (h0 : finset (add_cancel_monoid environment.implicit_infer_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_150213 (h0 : group (distrib_lattice (has_top linarith.comp_source))) : group.fg (distrib_lattice (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_150214 (h0 : complete_lattice (boolean_algebra.core (semigroup environment.implicit_infer_kind))) : is_compactly_generated (boolean_algebra.core (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_150215 (h0 : functor.add_const (group (add_cancel_monoid Type)) Type) : @normalizer_condition.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (add_cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_150216 (h0 : group (add_comm_monoid (sub_neg_monoid real))) : is_cyclic (add_comm_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_150217 (h0 : functor.add_const (list (linear_order unsigned)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_150218 (h0 : ring (has_star empty)) : is_principal_ideal_ring (has_star empty) := sorry --non-trivial
lemma new_lemma_150219 (h0 : uniform_space (has_bot (has_Inf linarith.comp))) : complete_space (has_bot (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_150220 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) (has_to_string pos)) : @t0_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) (has_to_string.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_150221 (h0 : not (complete_lattice (encodable char) -> false)) : @is_compactly_generated.{0} (encodable.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (encodable.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_150222 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) (finset pos)) : @t1_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_150223 (h0 : function.extfun Type (functor.comp cancel_comm_monoid_with_zero has_zero)) : @unique_factorization_monoid.{0} (has_zero.{0} pos) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_zero.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} cancel_comm_monoid_with_zero.{0} has_zero.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_150224 (h0 : ring (ordered_comm_ring (ring (ring Type)))) : rank_condition (ordered_comm_ring (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_150225 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (non_assoc_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_150226 (h0 : group (dlist (random_gen (random_gen (random_gen (random_gen linarith.comp_source)))))) : is_cyclic (dlist (random_gen (random_gen (random_gen (random_gen linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_150227 (h0 : topological_space (has_Inf (has_add name))) : discrete_topology (has_Inf (has_add name)) := sorry --non-trivial
lemma new_lemma_150228 (h0 : functor.add_const (filter (has_zero pos)) (boolean_algebra Type)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_150229 (h0 : has_mem.mem (with_one linarith.comp) has_emptyc.emptyc) : @rank_condition.{0} (with_one.{0} linarith.comp) (@finset.pi.empty.{1 0} Type ring.{0} (with_one.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_150230 (h0 : has_mem.mem monoid has_emptyc.emptyc) : @monoid.fg.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} h0) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_150231 (h0 : topological_space (linear_ordered_field (has_neg num))) : preconnected_space (linear_ordered_field (has_neg num)) := sorry --non-trivial
lemma new_lemma_150232 (h0 : functor.add_const (uniform_space (cancel_monoid name)) (has_add environment.implicit_infer_kind)) : @separated_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (cancel_monoid.{0} name)) (has_add.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_150233 (h0 : functor.add_const (uniform_space (semigroup empty)) (semiring unsigned)) : @separated_space.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} empty)) (semiring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_150234 (h0 : ring char) : strong_rank_condition char := sorry --non-trivial
lemma new_lemma_150235 (h0 : ring (mul_one_class environment.projection_info)) : rank_condition (mul_one_class environment.projection_info) := sorry --non-trivial
lemma new_lemma_150236 (h0 : function.extfun Type topological_space) : @t0_space.{0} (partial_order.{0} (semiring.{0} (semiring.{0} (option.{0} congr_arg_kind)))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (partial_order.{0} (semiring.{0} (semiring.{0} (option.{0} congr_arg_kind)))))  := sorry --non-trivial
lemma new_lemma_150237 (h0 : topological_space (semiring (has_norm (random_gen (has_norm congr_arg_kind))))) : t0_space (semiring (has_norm (random_gen (has_norm congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_150238 (h0 : topological_space (linear_ordered_comm_ring (semiring congr_arg_kind))) : t0_space (linear_ordered_comm_ring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_150239 (h1 : complete_lattice (with_bot linarith.comp)) : complete_lattice.is_Sup_finite_compact (with_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_150240 (h0 : semiring (add_cancel_monoid (comm_group (comm_group pos)))) : is_noetherian_ring (add_cancel_monoid (comm_group (comm_group pos))) := sorry --non-trivial
lemma new_lemma_150241 (h1 : complete_lattice (has_le (distrib (distrib linarith.comp_source)))) : complete_lattice.is_Sup_finite_compact (has_le (distrib (distrib linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_150242 (h0 : function.extfun (Type 1) complete_lattice) : @is_atomistic.{1} Type (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 Type)  := sorry --non-trivial
lemma new_lemma_150243 (h0 : has_mem.mem (with_bot empty) has_emptyc.emptyc) : @is_compactly_generated.{0} (with_bot.{0} empty) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_bot.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_150244 (h0 : ring (has_sub unsigned)) : rank_condition (has_sub unsigned) := sorry --non-trivial
lemma new_lemma_150245 (h0 : ring (bin_tree congr_arg_kind)) : rank_condition (bin_tree congr_arg_kind) := sorry --non-trivial
lemma new_lemma_150246 (h0 : topological_space (ring (has_add (has_add Type)))) : loc_path_connected_space (ring (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_150247 (h0 : topological_space (with_bot (has_top (has_top (has_top (has_top num)))))) : totally_disconnected_space (with_bot (has_top (has_top (has_top (has_top num))))) := sorry --non-trivial
lemma new_lemma_150248 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_atomistic.{0} fun_info (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) fun_info)  := sorry --non-trivial
lemma new_lemma_150249 (h0 : not (topological_space (has_sub congr_arg_kind) -> false)) : @path_connected_space.{0} (has_sub.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_150250 (h0 : functor.add_const (uniform_space (ordered_comm_ring linarith.comp)) pos) : @separated_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_150251 (h1 : complete_lattice (measurable_space linarith.comp)) : complete_lattice.is_Sup_finite_compact (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_150252 (h1 : function.extfun Type ring) : @strong_rank_condition.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h1 (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_150253 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_150254 (h0 : topological_space (pseudo_metric_space (random_gen string_imp))) : path_connected_space (pseudo_metric_space (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_150255 (h0 : complete_lattice (uniform_space (mul_one_class reducibility_hints))) : is_compactly_generated (uniform_space (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_150256 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup environment.implicit_infer_kind)) linarith.comp) : @archimedean.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semigroup.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_150257 (h0 : function.extfun Type group) : @group.fg.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_150258 (h0 : list (finset (has_nndist linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_150259 (h0 : topological_space (normed_comm_ring (comm_group ennreal))) : sequential_space (normed_comm_ring (comm_group ennreal)) := sorry --non-trivial
lemma new_lemma_150260 (h0 : function.extfun nat fin) : @t0_space.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_bot.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_150261 (h0 : topological_space (filter unsigned)) : path_connected_space (filter unsigned) := sorry --non-trivial
lemma new_lemma_150262 (h0 : topological_space (complete_distrib_lattice (normed_comm_ring Type))) : preirreducible_space (complete_distrib_lattice (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_150263 (h0 : topological_space (has_neg (option (option pos)))) : t0_space (has_neg (option (option pos))) := sorry --non-trivial
lemma new_lemma_150264 (h0 : functor.add_const (topological_space (ring linarith.comp)) name) : @loc_path_connected_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_150265 (h0 : ring (add_semigroup empty)) : rank_condition (add_semigroup empty) := sorry --non-trivial
lemma new_lemma_150266 (h0 : topological_space (boolean_algebra (finset (ring (ring Type))))) : discrete_topology (boolean_algebra (finset (ring (ring Type)))) := sorry --non-trivial
lemma new_lemma_150267 (h0 : complete_lattice (normed_field (mul_one_class (mul_one_class fun_info)))) : is_compactly_generated (normed_field (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_150268 (h0 : functor.add_const (topological_space (partial_order congr_arg_kind)) (semiring (semiring empty))) : @t1_space.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} congr_arg_kind)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_150269 (h0 : uniform_space (has_bot Type)) : separated_space (has_bot Type) := sorry --non-trivial
lemma new_lemma_150270 (h0 : function.extfun nat fin) : @is_add_cyclic.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (add_group.{1} (complete_distrib_lattice.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_150271 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (normed_comm_ring.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_150272 (h0 : has_mem.mem (has_norm num) has_emptyc.emptyc) : @t0_space.{0} (has_norm.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_150273 (h0 : group (normed_comm_ring (option (option (option empty))))) : normalizer_condition (normed_comm_ring (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_150274 (h0 : function.extfun (Type 1) semiring) : @is_noetherian_ring.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} h0 (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_150275 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_150276 (h0 : complete_lattice (has_pos_part Type)) : complete_lattice.is_Sup_finite_compact (has_pos_part Type) := sorry --non-trivial
lemma new_lemma_150277 (h0 : function.extfun Type monoid) : @monoid.fg.{0} auto.case_option (@function.extfun_app.{2 1} Type monoid.{0} h0 auto.case_option)  := sorry --non-trivial
lemma new_lemma_150278 (h0 : function.extfun Type topological_space) : @t0_space.{0} (comm_group.{0} (has_add.{0} name)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} (has_add.{0} name)))  := sorry --non-trivial
lemma new_lemma_150279 (h0 : ring (distrib (has_ssubset reducibility_hints))) : strong_rank_condition (distrib (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_150280 (h0 : monoid (mul_one_class fun_info)) (h1 : mul_one_class fun_info) : squarefree h1 := sorry --non-trivial
lemma new_lemma_150281 (h0 : topological_space (semi_normed_comm_ring (has_nnnorm (has_nnnorm char)))) : totally_disconnected_space (semi_normed_comm_ring (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_150282 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (complete_semilattice_Sup.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_semilattice_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_150283 (h0 : topological_space (complete_semilattice_Sup (has_top congr_arg_kind))) : path_connected_space (complete_semilattice_Sup (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_150284 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) pos) : @complete_lattice.is_Sup_finite_compact.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) pos h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_150285 (h0 : ring (group to_additive.value_type)) : is_domain (group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_150286 (h0 : fin has_zero.zero) : @is_simple_group.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (group.{1} (has_bot.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_150287 (h0 : complete_lattice (as_linear_order (option (option empty)))) : complete_lattice.is_Sup_finite_compact (as_linear_order (option (option empty))) := sorry --non-trivial
lemma new_lemma_150288 (h0 : function.extfun Type group) : @normalizer_condition.{0} (cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_150289 (h0 : ring (ordered_comm_ring linarith.comp)) : is_principal_ideal_ring (ordered_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_150290 (h0 : prod (has_one (semiring empty)) (has_one (semiring empty))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_150291 (h0 : ring (has_nnnorm (mul_one_class bool))) : strong_rank_condition (has_nnnorm (mul_one_class bool)) := sorry --non-trivial
lemma new_lemma_150292 (h0 : functor.add_const (topological_space (has_neg name)) name) : @t1_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_150293 (h0 : add_monoid (has_emptyc empty)) : add_monoid.fg (has_emptyc empty) := sorry --non-trivial
lemma new_lemma_150294 (h0 : semiring (has_union congr_arg_kind)) : is_noetherian_ring (has_union congr_arg_kind) := sorry --non-trivial
lemma new_lemma_150295 (h0 : complete_lattice (boolean_algebra.core (option (option (option unsigned))))) : complete_lattice.is_Sup_finite_compact (boolean_algebra.core (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_150296 (h0 : group linarith.comp_source -> Prop) (h1 : Exists (fun (x : group linarith.comp_source), h0 x)) : @is_cyclic.{0} linarith.comp_source (@classical.some.{1} (group.{0} linarith.comp_source) h0 h1)  := sorry --non-trivial
lemma new_lemma_150297 (h0 : prod (simple_graph (option unsigned)) (simple_graph (option unsigned))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_150298 (h0 : functor.comp ring complete_distrib_lattice environment.implicit_infer_kind) : @strong_rank_condition.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} ring.{0} complete_distrib_lattice.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_150299 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_add_cyclic.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) add_group.{0}) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_150300 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_150301 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_150302 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @normal_space.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_150303 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preirreducible_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_150304 (h0 : functor.add_const (complete_lattice (boolean_algebra.core environment.implicit_infer_kind)) name) : @is_compactly_generated.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_150305 (h0 : functor.add_const (function.extfun (Type 1) ring) Type) : @is_domain.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) Type h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_150306 (h1 : topological_space (denumerable (set string_imp))) : totally_disconnected_space (denumerable (set string_imp)) := sorry --non-trivial
lemma new_lemma_150307 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_150308 (h0 : list pnat) (h1 : with_bot (fin has_zero.zero)) (h2 : ne h1 has_bot.bot) : pnat.coprime (list.head h0) (matrix.vec_empty (with_bot.unbot h1 h2)) := sorry --non-trivial
lemma new_lemma_150309 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_150310 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_150311 (h0 : ring (has_append char)) : is_domain (has_append char) := sorry --non-trivial
lemma new_lemma_150312 (h0 : topological_space (cancel_monoid (add_cancel_monoid unsigned))) : preirreducible_space (cancel_monoid (add_cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_150313 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_150314 (h0 : group (normed_lattice_add_comm_group real)) : is_cyclic (normed_lattice_add_comm_group real) := sorry --non-trivial
lemma new_lemma_150315 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normal_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_150316 (h0 : functor.add_const (topological_space (has_neg pos)) (ring name)) : @t0_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_150317 (h0 : topological_space (boolean_algebra Type)) : normal_space (boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_150318 (h0 : group (group_with_zero (option (option ennreal)))) : group.fg (group_with_zero (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_150319 (h0 : monoid (linear_ordered_field (option empty))) : monoid.fg (linear_ordered_field (option empty)) := sorry --non-trivial
lemma new_lemma_150320 (h0 : monoid (has_Inf (has_bot (has_bot pos)))) : monoid.fg (has_Inf (has_bot (has_bot pos))) := sorry --non-trivial
lemma new_lemma_150321 (h0 : group (has_top congr_arg_kind)) : is_cyclic (has_top congr_arg_kind) := sorry --non-trivial
lemma new_lemma_150322 (h0 : ring (normed_field (mul_one_class reducibility_hints))) : rank_condition (normed_field (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_150323 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (with_bot.{0} (random_gen.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (with_bot.{0} (random_gen.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_150324 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @archimedean.{0} (boolean_algebra.{0} real) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (boolean_algebra.{0} real)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_150325 (h0 : topological_space auto.case_option) : t0_space auto.case_option := sorry --non-trivial
lemma new_lemma_150326 (h0 : add_comm_monoid (option pos) -> add_comm_monoid (option pos) -> Prop) : is_symm (add_comm_monoid (option pos)) h0 := sorry --non-trivial
lemma new_lemma_150327 (h4 : topological_space (add_comm_semigroup char)) (h5 : set (add_comm_semigroup char)) : is_path_connected h5 := sorry --non-trivial
lemma new_lemma_150328 (h0 : ring (finset (has_add name))) : is_principal_ideal_ring (finset (has_add name)) := sorry --non-trivial
lemma new_lemma_150329 (h1 : ring (dlist (has_ssubset linarith.comp_source))) : strong_rank_condition (dlist (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_150330 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_150331 (h0 : has_mem.mem (id linarith.ineq) has_emptyc.emptyc) : @is_compactly_generated.{0} (@id.{2} Type linarith.ineq) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (@id.{2} Type linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_150332 (h0 h1 : multiset (normed_field std_gen)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_150333 (h0 : ring (add_comm_monoid (has_nndist name))) : is_domain (add_comm_monoid (has_nndist name)) := sorry --non-trivial
lemma new_lemma_150334 (h0 : not (topological_space (mul_zero_class unsigned) -> false)) : @normal_space.{0} (mul_zero_class.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (mul_zero_class.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_150335 (h0 : topological_space (semiring fun_info)) : irreducible_space (semiring fun_info) := sorry --non-trivial
lemma new_lemma_150336 (h0 : topological_space (semigroup (has_add (complete_distrib_lattice Type)))) : t1_space (semigroup (has_add (complete_distrib_lattice Type))) := sorry --non-trivial
lemma new_lemma_150337 (h0 : pnat) (h1 : fin has_zero.zero) : pnat.coprime h0 (id (matrix.vec_empty h1)) := sorry --non-trivial
lemma new_lemma_150338 (h2 : uniform_space (has_lt string_imp)) : complete_space (has_lt string_imp) := sorry --non-trivial
lemma new_lemma_150339 (h0 : topological_space (sub_neg_monoid (finset (has_to_string (finset (has_Inf pos)))))) : totally_separated_space (sub_neg_monoid (finset (has_to_string (finset (has_Inf pos))))) := sorry --non-trivial
lemma new_lemma_150340 (h0 : group (boolean_algebra.core (monoid ennreal))) : is_simple_group (boolean_algebra.core (monoid ennreal)) := sorry --non-trivial
lemma new_lemma_150341 (h0 : monoid (bin_tree num)) : monoid.fg (bin_tree num) := sorry --non-trivial
lemma new_lemma_150342 (h3 : topological_space (simple_graph reducibility_hints)) : path_connected_space (simple_graph reducibility_hints) := sorry --non-trivial
lemma new_lemma_150343 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (normed_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_150344 (h0 : group (boolean_algebra (has_neg environment.implicit_infer_kind))) : group.fg (boolean_algebra (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_150345 (h0 : group (has_zero Type)) : group.fg (has_zero Type) := sorry --non-trivial
lemma new_lemma_150346 (h0 : cancel_comm_monoid_with_zero (left_cancel_monoid (semiring num))) : unique_factorization_monoid (left_cancel_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_150347 (h0 : functor.add_const (filter (boolean_algebra linarith.comp)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_150348 (h0 : ring (pseudo_metric_space ennreal)) : is_domain (pseudo_metric_space ennreal) := sorry --non-trivial
lemma new_lemma_150349 (h0 : topological_space (normed_comm_ring pos)) : sequential_space (normed_comm_ring pos) := sorry --non-trivial
lemma new_lemma_150350 (h0 : semiring (normed_linear_ordered_group (semiring unsigned))) : is_noetherian_ring (normed_linear_ordered_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_150351 (h0 : topological_space (pseudo_metric_space (option (option (option ennreal))))) : regular_space (pseudo_metric_space (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_150352 (h0 : group (linear_ordered_semiring (has_top (has_norm num)))) : is_cyclic (linear_ordered_semiring (has_top (has_norm num))) := sorry --non-trivial
lemma new_lemma_150353 (h0 : not (topological_space (bin_tree num) -> false)) : @locally_compact_space.{0} (bin_tree.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (bin_tree.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_150354 (h0 : monoid (complete_distrib_lattice (option ennreal))) : monoid.fg (complete_distrib_lattice (option ennreal)) := sorry --non-trivial
lemma new_lemma_150355 (h1 : topological_space (has_ssubset std_gen)) : path_connected_space (has_ssubset std_gen) := sorry --non-trivial
lemma new_lemma_150356 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (normed_group.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_150357 (h0 : pnat) (h1 : fin has_zero.zero) : pnat.coprime h0 (matrix.vec_empty h1) := sorry --non-trivial
lemma new_lemma_150358 (h0 : function.extfun Type (functor.add_const (complete_lattice (mul_zero_class empty)))) : @is_compactly_generated.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (mul_zero_class.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (mul_zero_class.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_150359 (h1 : group (has_append string_imp)) : is_cyclic (has_append string_imp) := sorry --non-trivial
lemma new_lemma_150360 (h0 : group (boolean_algebra (has_neg pos))) : is_simple_group (boolean_algebra (has_neg pos)) := sorry --non-trivial
lemma new_lemma_150361 (h1 : topological_space (has_ssubset ereal)) : totally_disconnected_space (has_ssubset ereal) := sorry --non-trivial
lemma new_lemma_150362 (h0 : function.extfun (Type 1) topological_space) : @totally_separated_space.{1} (canonically_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (canonically_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_150363 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra.core unsigned)) (boolean_algebra linarith.comp)) : @archimedean.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (boolean_algebra.core.{0} unsigned)) (boolean_algebra.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_150364 (h0 : cancel_comm_monoid_with_zero (id congr_arg_kind)) : unique_factorization_monoid (id congr_arg_kind) := sorry --non-trivial
lemma new_lemma_150365 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @totally_separated_space.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_pos_part.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_150366 (h0 : topological_space (has_neg_part (comm_group name))) : irreducible_space (has_neg_part (comm_group name)) := sorry --non-trivial
lemma new_lemma_150367 (h0 : functor.comp group add_group num) : @group.fg.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (group.{0} (add_group.{0} num)) num (@functor.comp.run.{0 0 0} group.{0} add_group.{0} num h0))  := sorry --non-trivial
lemma new_lemma_150368 (h0 : group (boolean_algebra (comm_group pos))) : is_simple_group (boolean_algebra (comm_group pos)) := sorry --non-trivial
lemma new_lemma_150369 (h0 : functor.add_const (group (finset Type)) (finset pos)) : @is_cyclic.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (finset.{1} Type)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_150370 (h0 : topological_space (has_zero (ring (finset (has_to_string linarith.comp))))) : topological_space.separable_space (has_zero (ring (finset (has_to_string linarith.comp)))) := sorry --non-trivial
lemma new_lemma_150371 (h0 : topological_space (finset Type)) : sequential_space (finset Type) := sorry --non-trivial
lemma new_lemma_150372 (h0 : uniform_space (has_norm to_additive.value_type)) : separated_space (has_norm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_150373 (h0 : topological_space (has_to_string (finset (has_add pos)))) : regular_space (has_to_string (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_150374 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (normed_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_150375 (h0 : group (has_nndist unsigned)) : group.fg (has_nndist unsigned) := sorry --non-trivial
lemma new_lemma_150376 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_150377 (h0 : functor.add_const (uniform_space (id unsigned)) (semiring (semiring (semiring unsigned)))) : @separated_space.{0} (@id.{2} Type unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (@id.{2} Type unsigned)) (semiring.{0} (semiring.{0} (semiring.{0} unsigned))) h0)  := sorry --non-trivial
lemma new_lemma_150378 (h0 : measurable_space char) (h1 : topological_space char) (h2 : measure_theory.measure char) : measure_theory.measure.regular h2 := sorry --non-trivial
lemma new_lemma_150379 (h0 : functor.add_const (ring (has_Sup unsigned)) (add_group empty)) : @rank_condition.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_Sup.{0} unsigned)) (add_group.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_150380 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} congr_arg_kind (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_150381 (h0 : functor.add_const (function.extfun Type monoid) pos) : @monoid.fg.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) pos h0) (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_150382 (h0 : functor.add_const (function.extfun Type topological_space) (has_nndist pos)) : @t0_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_nndist.{0} pos) h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_150383 (h0 : group (metric_space to_additive.value_type)) : is_cyclic (metric_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_150384 (h0 : ring (add_group (has_top linarith.comp))) : rank_condition (add_group (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_150385 (h0 : topological_space (filter empty)) : normal_space (filter empty) := sorry --non-trivial
lemma new_lemma_150386 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_150387 (h0 : ring (has_Inf (has_nndist pos))) : rank_condition (has_Inf (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_150388 (h0 : function.extfun Type ring) : @is_domain.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_150389 (h0 : uniform_space (has_zero (add_comm_monoid environment.implicit_infer_kind))) : separated_space (has_zero (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_150390 (h0 : ring (has_edist (semiring unsigned))) : is_principal_ideal_ring (has_edist (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_150391 (h0 : complete_lattice (has_one (has_norm linarith.comp))) : complete_lattice.is_Sup_finite_compact (has_one (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_150392 (h0 : functor.add_const (topological_space (sub_neg_monoid linarith.comp)) linarith.comp) : @locally_compact_space.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_150393 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (metric_space.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_150394 (h0 : ring (with_one (measurable_space to_additive.value_type))) : is_domain (with_one (measurable_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_150395 (h0 : ring (ordered_comm_ring (has_Inf (ring linarith.comp)))) : is_domain (ordered_comm_ring (has_Inf (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_150396 (h0 : topological_space (distrib char)) (h1 : preorder (distrib char)) : order_topology (distrib char) := sorry --non-trivial
lemma new_lemma_150397 (h0 : uniform_space (simple_graph (has_ssubset (has_ssubset (uniform_space char))))) : complete_space (simple_graph (has_ssubset (has_ssubset (uniform_space char)))) := sorry --non-trivial
lemma new_lemma_150398 (h0 : functor.add_const (finset (canonically_ordered_comm_semiring Type)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_150399 (h0 : uniform_space (linear_ordered_comm_ring congr_arg_kind)) : complete_space (linear_ordered_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_150400 (h0 : not (topological_space (option num) -> false)) : @path_connected_space.{0} (option.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (option.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_150401 (h1 : group (normed_field string.iterator_imp)) : is_cyclic (normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_150402 (h0 : list (ordered_comm_monoid (ring linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_150403 (h0 : topological_space (finset ennreal)) : discrete_topology (finset ennreal) := sorry --non-trivial
lemma new_lemma_150404 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_150405 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} fun_info (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) fun_info)  := sorry --non-trivial
lemma new_lemma_150406 (h0 : uniform_space (pseudo_metric_space unsigned)) : separated_space (pseudo_metric_space unsigned) := sorry --non-trivial
lemma new_lemma_150407 (h0 : functor.add_const (function.extfun Type group) pos) : @group.fg.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_150408 (h1 : has_coe (normed_field (normed_field (normed_field char))) Prop) (h2 : normed_field (normed_field (normed_field char))) : @coe_b.{1 1} (normed_field.{0} (normed_field.{0} (normed_field.{0} char))) Prop h1 h2  := sorry --non-trivial
lemma new_lemma_150409 (h0 : add_monoid (canonically_linear_ordered_monoid (option name))) : add_monoid.fg (canonically_linear_ordered_monoid (option name)) := sorry --non-trivial
lemma new_lemma_150410 (h0 : group (has_neg_part ennreal)) : group.fg (has_neg_part ennreal) := sorry --non-trivial
lemma new_lemma_150411 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_150412 (h0 : topological_space (finset environment.implicit_infer_kind)) : topological_space.separable_space (finset environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_150413 (h0 : topological_space (complete_distrib_lattice (ring pos))) : totally_separated_space (complete_distrib_lattice (ring pos)) := sorry --non-trivial
lemma new_lemma_150414 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_150415 (h0 : complete_lattice (normed_comm_ring (has_add Type))) : is_atomistic (normed_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_150416 (h1 : function.extfun Type group) : @is_cyclic.{0} (div_inv_monoid.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h1 (div_inv_monoid.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_150417 (h0 : set (has_le (mul_one_class (mul_one_class linarith.ineq)))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_150418 (h0 : ring (semi_normed_ring (comm_ring char))) : is_domain (semi_normed_ring (comm_ring char)) := sorry --non-trivial
lemma new_lemma_150419 (h0 : random_gen num -> random_gen num -> Prop) : is_per (random_gen num) h0 := sorry --non-trivial
lemma new_lemma_150420 (h0 : uniform_space (has_add num)) : complete_space (has_add num) := sorry --non-trivial
lemma new_lemma_150421 (h0 : add_group (option empty)) : is_add_cyclic (option empty) := sorry --non-trivial
lemma new_lemma_150422 (h0 : add_comm_group (denumerable linarith.comp_source)) (h1 : has_norm (denumerable linarith.comp_source)) : normed_group.core (denumerable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_150423 (h0 : topological_space (comm_group (normed_comm_ring (normed_comm_ring name)))) : path_connected_space (comm_group (normed_comm_ring (normed_comm_ring name))) := sorry --non-trivial
lemma new_lemma_150424 (h0 : complete_lattice (has_union (semiring (semiring num)))) : complete_lattice.is_Sup_finite_compact (has_union (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_150425 (h0 : topological_space (has_to_string (finset (has_Inf pos)))) : discrete_topology (has_to_string (finset (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_150426 (h0 : topological_space (linear_ordered_comm_group_with_zero environment.projection_info)) : t0_space (linear_ordered_comm_group_with_zero environment.projection_info) := sorry --non-trivial
lemma new_lemma_150427 (h0 : topological_space (has_compl (has_div linarith.comp_source))) : totally_disconnected_space (has_compl (has_div linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_150428 (h0 : uniform_space (has_edist (semiring unsigned))) : complete_space (has_edist (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_150429 (h0 : topological_space (linear_ordered_add_comm_group (has_top fun_info))) : irreducible_space (linear_ordered_add_comm_group (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_150430 (h0 : fin has_zero.zero) : @is_simple_group.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (group.{1} (boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_150431 (h0 : functor.add_const (add_group (add_comm_monoid empty)) empty) : @is_add_cyclic.{0} (add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (add_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_150432 (h0 : functor.add_const (semiring (finset Type)) (finset (has_neg pos))) : @is_noetherian_ring.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (finset.{1} Type)) (finset.{0} (has_neg.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_150433 (h0 : ring (measurable_space.dynkin_system (semiring (semiring (semiring congr_arg_kind))))) : is_domain (measurable_space.dynkin_system (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_150434 (h0 : filter (ordered_comm_monoid Type)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_150435 (h0 : not (monoid (has_one unsigned) -> false)) : @monoid.fg.{0} (has_one.{0} unsigned) (@classical.by_contradiction'.{1} (monoid.{0} (has_one.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_150436 (h0 : functor.add_const (topological_space (has_dist num)) unsigned -> Prop) (h1 : Exists (fun (x : functor.add_const (topological_space (has_dist num)) unsigned), h0 x)) : @totally_separated_space.{0} (has_dist.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} num)) unsigned (@classical.some.{1} (functor.add_const.{0 0} (topological_space.{0} (has_dist.{0} num)) unsigned) h0 h1))  := sorry --non-trivial
lemma new_lemma_150437 (h0 : topological_space (ordered_comm_group unsigned)) : t1_space (ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_150438 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_150439 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_150440 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (finset ennreal)) := sorry --non-trivial
lemma new_lemma_150441 (h0 : group (comm_group unsigned)) : is_cyclic (comm_group unsigned) := sorry --non-trivial
lemma new_lemma_150442 (h0 : topological_space (has_le enat)) : t0_space (has_le enat) := sorry --non-trivial
lemma new_lemma_150443 (h0 : ordered_add_comm_monoid (complete_distrib_lattice (has_Inf linarith.comp))) : archimedean (complete_distrib_lattice (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_150444 (h0 : functor.add_const (list (has_nndist linarith.comp)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_150445 (h0 : topological_space (semigroup (add_cancel_monoid (has_zero Type)))) : t1_space (semigroup (add_cancel_monoid (has_zero Type))) := sorry --non-trivial
lemma new_lemma_150446 (h0 : topological_space (add_cancel_monoid (has_neg (has_neg linarith.comp)))) : sequential_space (add_cancel_monoid (has_neg (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_150447 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_bot.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_150448 (h0 : ordered_add_comm_monoid (semigroup (ring environment.implicit_infer_kind))) : archimedean (semigroup (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_150449 (h1 : ring (has_nnnorm (uniform_space reducibility_hints))) : rank_condition (has_nnnorm (uniform_space reducibility_hints)) := sorry --non-trivial
lemma new_lemma_150450 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (ordered_cancel_add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_150451 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_150452 (h0 : functor.add_const (complete_lattice (has_pos_part pos)) (has_neg linarith.comp)) : @complete_lattice.is_Sup_finite_compact.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_pos_part.{0} pos)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_150453 (h0 : topological_space (has_Inf (has_add (finset linarith.comp)))) : irreducible_space (has_Inf (has_add (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_150454 (h0 : function.extfun Type group) : @group.fg.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_150455 (h0 : functor.add_const (topological_space (left_cancel_monoid empty)) num) : @loc_path_connected_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_150456 (h0 : topological_space (normed_group (semiring congr_arg_kind))) : totally_separated_space (normed_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_150457 (h0 : group (boolean_algebra (finset (boolean_algebra.core pos)))) : normalizer_condition (boolean_algebra (finset (boolean_algebra.core pos))) := sorry --non-trivial
lemma new_lemma_150458 (h0 : topological_space char) (h3 : preorder char) : order_topology char := sorry --non-trivial
lemma new_lemma_150459 (h0 : functor.add_const (topological_space (has_to_string Type)) environment.implicit_infer_kind) : @regular_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_150460 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (comm_ring.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_ring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_150461 (h0 : topological_space (measurable_space (semiring (id empty)))) : normal_space (measurable_space (semiring (id empty))) := sorry --non-trivial
lemma new_lemma_150462 (h0 : not (topological_space (random_gen linarith.ineq) -> false)) : @t0_space.{0} (random_gen.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_150463 (h0 : functor.add_const (topological_space (cancel_monoid Type)) name) : @loc_path_connected_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_150464 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_150465 (h0 : not (topological_space (mul_one_class string_imp) -> false)) : @path_connected_space.{0} (mul_one_class.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (mul_one_class.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_150466 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (has_compl.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_compl.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_150467 (h0 : filter (has_sub unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_150468 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (complete_semilattice_Sup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (complete_semilattice_Sup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_150469 (h0 : function.extfun Type group) : @normalizer_condition.{0} (denumerable.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (denumerable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_150470 (h0 : functor.comp ordered_comm_monoid option pos) : @has_exists_mul_of_le.{0} (option.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (option.{0} pos)) pos (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} option.{0} pos h0))  := sorry --non-trivial
lemma new_lemma_150471 (h0 : topological_space (has_div to_additive.value_type)) : path_connected_space (has_div to_additive.value_type) := sorry --non-trivial
lemma new_lemma_150472 (h0 : functor.add_const (cancel_comm_monoid_with_zero (comm_group ennreal)) pos) : @unique_factorization_monoid.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (comm_group.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_150473 (h0 : topological_space (semigroup (option ennreal))) : totally_disconnected_space (semigroup (option ennreal)) := sorry --non-trivial
lemma new_lemma_150474 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_150475 (h0 : ordered_add_comm_monoid (ring (has_add Type))) : archimedean (ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_150476 (h0 : ring (option (semiring (semiring (semiring unsigned))))) : strong_rank_condition (option (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_150477 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_150478 (h0 : topological_space (nondiscrete_normed_field environment.projection_info)) (h1 : add_group (nondiscrete_normed_field environment.projection_info)) : topological_add_group (nondiscrete_normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_150479 (h0 : topological_space (boolean_algebra (has_add (has_zero pos)))) : totally_separated_space (boolean_algebra (has_add (has_zero pos))) := sorry --non-trivial
lemma new_lemma_150480 (h0 : measurable_space (nondiscrete_normed_field fun_info)) (h1 : filter (nondiscrete_normed_field fun_info)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_150481 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem uniform_space)) : @separated_space.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) uniform_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_150482 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (left_cancel_semigroup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_150483 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem add_group)) : @is_add_cyclic.{0} num (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) num)  := sorry --non-trivial
lemma new_lemma_150484 (h0 : filter (add_cancel_monoid (finset environment.implicit_infer_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_150485 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (comm_group.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (comm_group.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_150486 (h0 : not (topological_space (add_monoid linarith.comp_source) -> false)) : @path_connected_space.{0} (add_monoid.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (add_monoid.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_150487 (h0 : functor.comp topological_space finset name) : @normal_space.{0} (finset.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} name h0)  := sorry --non-trivial
lemma new_lemma_150488 (h0 h2 : multiset fun_info) : multiset.le h0 h2 := sorry --non-trivial
lemma new_lemma_150489 (h0 : list (ordered_cancel_add_comm_monoid (option (option unsigned)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_150490 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semigroup.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_150491 (h0 : functor.add_const (topological_space (semigroup ennreal)) unsigned) : @loc_path_connected_space.{0} (semigroup.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_150492 (h0 : function.extfun Type (functor.comp topological_space canonically_ordered_comm_semiring)) : @discrete_topology.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_150493 (h0 : add_monoid (has_add linarith.comp)) : add_monoid.fg (has_add linarith.comp) := sorry --non-trivial
lemma new_lemma_150494 (h0 : functor.add_const (ring (normed_comm_ring linarith.comp)) pos) : @is_principal_ideal_ring.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_150495 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @t0_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_150496 (h0 : ring (option (semiring unsigned))) : strong_rank_condition (option (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_150497 (h0 : list (left_cancel_semigroup empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_150498 (h0 : topological_space (boolean_algebra (has_pos_part (has_pos_part pos)))) : regular_space (boolean_algebra (has_pos_part (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_150499 (h0 : group (random_gen (semiring empty))) : group.fg (random_gen (semiring empty)) := sorry --non-trivial
lemma new_lemma_150500 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_150501 (h0 : topological_space (nondiscrete_normed_field (add_comm_semigroup string.iterator_imp))) : t0_space (nondiscrete_normed_field (add_comm_semigroup string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_150502 (h0 : not (function.extfun (Type 1) complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@classical.by_contradiction'.{3} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) h0) (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_150503 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} h0 (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_150504 (h0 : topological_space (measure_theory.measure_space empty)) : discrete_topology (measure_theory.measure_space empty) := sorry --non-trivial
lemma new_lemma_150505 (h2 : char) (h5 : coe_sort (set.range (fun (h0 : ordered_add_comm_monoid enat), h2))) : archimedean enat := sorry --non-trivial
lemma new_lemma_150506 (h0 : set (nondiscrete_normed_field (mul_one_class (mul_one_class (add_comm_semigroup string.iterator_imp))) -> ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_150507 (h0 : ring (has_Inf (has_add (has_add (has_add (has_add linarith.comp)))))) : strong_rank_condition (has_Inf (has_add (has_add (has_add (has_add linarith.comp))))) := sorry --non-trivial
lemma new_lemma_150508 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) (boolean_algebra name)) : @totally_separated_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) (boolean_algebra.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_150509 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_150510 (h0 : topological_space (has_ssubset (normed_comm_ring (mul_one_class to_additive.value_type)))) (h1 : add_group (has_ssubset (normed_comm_ring (mul_one_class to_additive.value_type)))) : topological_add_group (has_ssubset (normed_comm_ring (mul_one_class to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_150511 (h0 : functor.add_const (filter (semigroup Type)) (cancel_monoid pos)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_150512 (h0 : complete_lattice (measure_theory.measure_space (semiring num))) : is_atomistic (measure_theory.measure_space (semiring num)) := sorry --non-trivial
lemma new_lemma_150513 (h0 : group (linear_ordered_comm_group (option ennreal))) : normalizer_condition (linear_ordered_comm_group (option ennreal)) := sorry --non-trivial
lemma new_lemma_150514 (h1 : not (ring (has_nnnorm linarith.comp_source) -> false)) : @is_domain.{0} (has_nnnorm.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (has_nnnorm.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_150515 (h0 : function.extfun (Type 1) topological_space) : @locally_compact_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_150516 (h0 : group (has_bot (has_add (has_Inf (has_Inf real))))) : is_simple_group (has_bot (has_add (has_Inf (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_150517 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_150518 (h0 : functor.add_const (ring (lattice (option num))) empty) : @strong_rank_condition.{0} (lattice.{0} (option.{0} num)) (@functor.add_const.run.{0 0} (ring.{0} (lattice.{0} (option.{0} num))) empty h0)  := sorry --non-trivial
lemma new_lemma_150519 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) (h1 : option (function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type)))) : @rank_condition.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (@option.lhoare.{2} (function.extfun.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type))) h0 h1) (function.extfun.{2 1} Type)) ring.{0}) (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_150520 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_Sup unsigned)) := sorry --non-trivial
lemma new_lemma_150521 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_150522 (h0 : function.extfun (Type 1) uniform_space) : @separated_space.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_150523 (h0 : functor.add_const (semiring (boolean_algebra environment.implicit_infer_kind)) linarith.comp) : @is_noetherian_ring.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (semiring.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_150524 (h0 : measurable_space (denumerable (random_gen (random_gen fun_info)))) (h1 : measure_theory.measure (denumerable (random_gen (random_gen fun_info)))) : measure_theory.has_no_atoms h1 := sorry --non-trivial
lemma new_lemma_150525 (h0 : function.extfun Type (functor.add_const (add_group pos))) : @is_add_cyclic.{0} pos (@functor.add_const.run.{0 0} (add_group.{0} pos) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_group.{0} pos)) h0 pos))  := sorry --non-trivial
lemma new_lemma_150526 (h0 : topological_space (cancel_monoid (cancel_monoid name))) : t1_space (cancel_monoid (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_150527 (h0 : functor.add_const (group (mul_zero_class ennreal)) unsigned) : @is_simple_group.{0} (mul_zero_class.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (mul_zero_class.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_150528 (h0 : complete_lattice (distrib_lattice (random_gen (has_inv fun_info)))) : is_compactly_generated (distrib_lattice (random_gen (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_150529 (h0 : group (semi_normed_comm_ring (random_gen to_additive.value_type))) : group.fg (semi_normed_comm_ring (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_150530 (h0 : not (topological_space (measurable_space.dynkin_system num) -> false)) : @discrete_topology.{0} (measurable_space.dynkin_system.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.dynkin_system.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_150531 (h0 : topological_space (ordered_comm_semiring (add_comm_monoid environment.implicit_infer_kind))) : sequential_space (ordered_comm_semiring (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_150532 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_150533 (h0 : topological_space (has_nnnorm linarith.ineq)) : t0_space (has_nnnorm linarith.ineq) := sorry --non-trivial
lemma new_lemma_150534 (h0 : ordered_comm_monoid (semigroup (boolean_algebra linarith.comp))) : has_exists_mul_of_le (semigroup (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_150535 (h0 : topological_space (semigroup (has_Inf (has_pos_part pos)))) : locally_compact_space (semigroup (has_Inf (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_150536 (h0 : ring (has_to_string (has_add name))) : strong_rank_condition (has_to_string (has_add name)) := sorry --non-trivial
lemma new_lemma_150537 (h0 : ordered_add_comm_monoid (ring (option (option (option unsigned))))) : archimedean (ring (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_150538 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_bot.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_150539 (h0 : functor.add_const (ring (ring Type)) pos) : @is_principal_ideal_ring.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_150540 (h0 : set (distrib fun_info)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_150541 (h0 : functor.add_const (filter (add_comm_monoid Type)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_150542 (h0 : function.extfun Type topological_space) : @t0_space.{0} (linear_ordered_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_150543 (h0 : add_monoid (has_one (semiring congr_arg_kind))) : add_monoid.fg (has_one (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_150544 (h0 : ring (random_gen (has_top (has_top to_additive.value_type)))) : strong_rank_condition (random_gen (has_top (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_150545 (h0 : ring (linear_ordered_add_comm_group string_imp)) : is_domain (linear_ordered_add_comm_group string_imp) := sorry --non-trivial
lemma new_lemma_150546 (h0 : add_group (option (semiring (semiring congr_arg_kind)))) : is_add_cyclic (option (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_150547 (h0 : not (monoid (has_div linarith.ineq) -> false)) : @monoid.fg.{0} (has_div.{0} linarith.ineq) (@classical.by_contradiction'.{1} (monoid.{0} (has_div.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_150548 (h0 : topological_space (add_comm_semigroup (mul_one_class fun_info))) (h1 : preorder (add_comm_semigroup (mul_one_class fun_info))) : order_topology (add_comm_semigroup (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_150549 (h0 : topological_space (add_cancel_comm_monoid linarith.comp_source)) : totally_disconnected_space (add_cancel_comm_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_150550 (h0 : topological_space Type) : topological_space.separable_space Type := sorry --non-trivial
lemma new_lemma_150551 (h0 : functor.add_const (group (complete_distrib_lattice pos)) name) : @group.fg.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_150552 (h1 : ring (has_emptyc to_additive.value_type)) : rank_condition (has_emptyc to_additive.value_type) := sorry --non-trivial
lemma new_lemma_150553 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (has_neg pos)) := sorry --non-trivial
lemma new_lemma_150554 (h0 : set (normed_field linarith.comp_source)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_150555 (h0 : functor.add_const (complete_lattice (linear_ordered_cancel_comm_monoid empty)) (semiring unsigned)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) (semiring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_150556 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_150557 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_150558 (h0 : has_neg (has_ssubset string.iterator_imp)) (h1 : measurable_space (has_ssubset string.iterator_imp)) : has_measurable_neg (has_ssubset string.iterator_imp) := sorry --non-trivial
lemma new_lemma_150559 (h0 : function.extfun Type (functor.comp filter has_add)) : countable_Inter_filter (functor.comp.run (function.extfun_app h0 environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_150560 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_150561 (h0 : not (topological_space (has_compl reducibility_hints) -> false)) : @t0_space.{0} (has_compl.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (has_compl.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_150562 (h0 : add_monoid (normed_lattice_add_comm_group (has_Inf Type))) : add_monoid.fg (normed_lattice_add_comm_group (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_150563 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (has_add.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} linarith.comp)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_150564 (h0 : function.extfun (Type 1) topological_space) : @regular_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 Type)  := sorry --non-trivial
lemma new_lemma_150565 (h0 : topological_space (generalized_boolean_algebra (has_neg (has_neg Type)))) : path_connected_space (generalized_boolean_algebra (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_150566 (h0 : add_group (has_norm (has_inv (random_gen (has_inv fun_info))))) : add_group.fg (has_norm (has_inv (random_gen (has_inv fun_info)))) := sorry --non-trivial
lemma new_lemma_150567 (h0 : topological_space (canonically_linear_ordered_monoid (has_add (has_Inf (sub_neg_monoid Type))))) : t1_space (canonically_linear_ordered_monoid (has_add (has_Inf (sub_neg_monoid Type)))) := sorry --non-trivial
lemma new_lemma_150568 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_150569 (h0 : function.extfun (finset Type) (has_mem.mem linarith.ineq)) : @complete_lattice.is_Sup_finite_compact.{0} linarith.ineq (@finset.pi.empty.{1 0} Type complete_lattice.{0} linarith.ineq (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.ineq) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_150570 (h0 : topological_space (has_Inf (has_add (has_Inf name)))) : normal_space (has_Inf (has_add (has_Inf name))) := sorry --non-trivial
lemma new_lemma_150571 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (comm_semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_150572 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (filter.{0} num) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (filter.{0} num))  := sorry --non-trivial
lemma new_lemma_150573 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (measure_theory.measure_space.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (measure_theory.measure_space.{0} num))  := sorry --non-trivial
lemma new_lemma_150574 (h0 : has_lift (random_gen (random_gen linarith.ineq)) Prop) (h1 : random_gen (random_gen linarith.ineq)) : @lift.{1 1} (random_gen.{0} (random_gen.{0} linarith.ineq)) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_150575 (h0 : functor.add_const (topological_space (pseudo_metric_space pos)) pos) : @preconnected_space.{0} (pseudo_metric_space.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_150576 (h0 : function.extfun (Type 1) (functor.add_const (topological_space Type))) : @t0_space.{1} Type (@functor.add_const.run.{1 1} (topological_space.{1} Type) Type (@function.extfun_app.{3 2} (Type 1) (functor.add_const.{1 1} (topological_space.{1} Type)) h0 Type))  := sorry --non-trivial
lemma new_lemma_150577 (h0 : measurable_space (has_div linarith.comp_source)) (h1 : filter (has_div linarith.comp_source)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_150578 (h0 : add_monoid (has_sub (semiring (has_top (has_top empty))))) : add_monoid.fg (has_sub (semiring (has_top (has_top empty)))) := sorry --non-trivial
lemma new_lemma_150579 (h0 : topological_space (comm_ring (has_ssubset (has_top (random_gen linarith.ineq))))) : totally_disconnected_space (comm_ring (has_ssubset (has_top (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_150580 (h1 : topological_space (has_norm num)) : totally_disconnected_space (has_norm num) := sorry --non-trivial
lemma new_lemma_150581 (h0 : filter (has_add (comm_group (has_to_string (has_add name))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_150582 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra Type)) (has_neg pos)) : @has_exists_mul_of_le.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (boolean_algebra.{1} Type)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_150583 (h0 : functor.add_const (group (semigroup name)) linarith.comp) : @is_simple_group.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_150584 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) name) : @regular_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_150585 (h0 : functor.comp ordered_add_comm_monoid normed_comm_ring name) : @archimedean.{0} (normed_comm_ring.{0} name) (@functor.comp.run.{0 0 0} ordered_add_comm_monoid.{0} normed_comm_ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_150586 (h0 : group (add_cancel_monoid (has_add (has_add (has_nndist (has_add (has_add pos))))))) : is_simple_group (add_cancel_monoid (has_add (has_add (has_nndist (has_add (has_add pos)))))) := sorry --non-trivial
lemma new_lemma_150587 (h0 : monoid (bin_tree (semiring (semiring (semiring empty))))) : monoid.fg (bin_tree (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_150588 (h0 : group (has_neg (has_Inf pos))) : group.fg (has_neg (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_150589 (h0 : set (has_lt (distrib linarith.comp_source))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_150590 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_disconnected_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_150591 (h0 : functor.add_const (ordered_add_comm_monoid (complete_distrib_lattice pos)) pos) : @archimedean.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (complete_distrib_lattice.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_150592 (h0 : function.extfun Type group) : @group.fg.{0} (canonically_ordered_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_150593 (h0 : ring (distrib (has_ssubset to_additive.value_type))) : is_domain (distrib (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_150594 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_150595 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_neg.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_neg.{0} empty))  := sorry --non-trivial
lemma new_lemma_150596 (h0 : topological_space (with_one empty)) : totally_disconnected_space (with_one empty) := sorry --non-trivial
lemma new_lemma_150597 (h4 : not (uniform_space (has_nnnorm reducibility_hints) -> false)) : @complete_space.{0} (has_nnnorm.{0} reducibility_hints) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_nnnorm.{0} reducibility_hints)) h4)  := sorry --non-trivial
lemma new_lemma_150598 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_150599 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_150600 (h0 : topological_space (semiring (has_norm unsigned))) : totally_disconnected_space (semiring (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_150601 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app (id h0) (complete_semilattice_Sup to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_150602 (h0 : ring (measurable_space.dynkin_system (semiring num))) : is_domain (measurable_space.dynkin_system (semiring num)) := sorry --non-trivial
lemma new_lemma_150603 (h0 : functor.comp finset add_cancel_monoid name) : finset.nonempty (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_150604 (h0 : function.extfun nat fin) : @path_connected_space.{0} (canonically_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_150605 (h0 : functor.add_const (topological_space (has_neg pos)) Type) : @preirreducible_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_150606 (h0 : topological_space (semigroup (finset (finset environment.implicit_infer_kind)))) : locally_compact_space (semigroup (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_150607 (h0 : functor.add_const (topological_space (has_add name)) linarith.comp) : @topological_space.separable_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_150608 (h0 : ordered_comm_monoid (has_zero (has_nndist (finset (finset linarith.comp))))) : has_exists_mul_of_le (has_zero (has_nndist (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_150609 (h0 : functor.add_const (add_group (has_add name)) (option name)) : @is_add_cyclic.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (has_add.{0} name)) (option.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_150610 (h0 : function.extfun Type group) : @is_cyclic.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_150611 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_150612 (h0 : uniform_space (random_gen (denumerable (denumerable reducibility_hints)))) : complete_space (random_gen (denumerable (denumerable reducibility_hints))) := sorry --non-trivial
lemma new_lemma_150613 (h0 : topological_space (has_pos_part (has_add Type))) : totally_disconnected_space (has_pos_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_150614 (h0 : filter (non_assoc_semiring (semiring (semiring unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_150615 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @group.fg.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_150616 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) (ordered_ring (has_neg Type))) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) (ordered_ring.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_150617 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_150618 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_150619 (h0 : functor.add_const (list (semigroup name)) (has_neg linarith.comp)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_150620 (h0 : ring (semigroup (has_neg_part Type))) : is_principal_ideal_ring (semigroup (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_150621 (h0 : functor.add_const (function.extfun Type group) (has_neg linarith.comp)) : @is_cyclic.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) (has_neg.{0} linarith.comp) h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_150622 (h0 : topological_space (canonically_ordered_comm_semiring (finset ennreal))) : sequential_space (canonically_ordered_comm_semiring (finset ennreal)) := sorry --non-trivial
lemma new_lemma_150623 (h0 : group (has_neg_part (option name))) : normalizer_condition (has_neg_part (option name)) := sorry --non-trivial
lemma new_lemma_150624 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_150625 (h0 : functor.add_const (ring environment.implicit_infer_kind) linarith.comp) : @is_principal_ideal_ring.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (ring.{0} environment.implicit_infer_kind) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_150626 (h0 : functor.add_const Prop linarith.ineq) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_150627 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (normed_linear_ordered_group.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (normed_linear_ordered_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_150628 (h0 : group (complete_distrib_lattice (option unsigned))) : normalizer_condition (complete_distrib_lattice (option unsigned)) := sorry --non-trivial
lemma new_lemma_150629 (h0 : functor.add_const (topological_space environment.implicit_infer_kind) environment.implicit_infer_kind) : @t0_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (topological_space.{0} environment.implicit_infer_kind) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_150630 (h0 : group (has_to_string (has_add (has_add (has_pos_part pos))))) : is_cyclic (has_to_string (has_add (has_add (has_pos_part pos)))) := sorry --non-trivial
lemma new_lemma_150631 (h0 : list (canonically_linear_ordered_monoid (option ennreal))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_150632 (h0 : list congr_arg_kind) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_150633 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_150634 (h0 : topological_space (has_star congr_arg_kind)) : topological_space.separable_space (has_star congr_arg_kind) := sorry --non-trivial
lemma new_lemma_150635 (h0 : not (monoid (has_top linarith.comp) -> false)) : @monoid.fg.{0} (has_top.{0} linarith.comp) (@classical.by_contradiction'.{1} (monoid.{0} (has_top.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_150636 (h0 : fin has_zero.zero) : @path_connected_space.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_150637 (h0 : add_group (nondiscrete_normed_field (add_comm_semigroup string.iterator_imp))) : is_add_cyclic (nondiscrete_normed_field (add_comm_semigroup string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_150638 (h0 : topological_space (ring (finset linarith.comp))) : normal_space (ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_150639 (h1 : ring (add_monoid string_imp)) : strong_rank_condition (add_monoid string_imp) := sorry --non-trivial
lemma new_lemma_150640 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_150641 (h0 : add_group (bin_tree (semiring empty))) : is_add_cyclic (bin_tree (semiring empty)) := sorry --non-trivial
lemma new_lemma_150642 (h0 : group (has_norm (has_top (has_nnnorm (has_nnnorm (random_gen to_additive.value_type)))))) : group.fg (has_norm (has_top (has_nnnorm (has_nnnorm (random_gen to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_150643 (h0 : functor.add_const (add_group (add_comm_monoid Type)) (finset environment.implicit_infer_kind)) : @is_add_cyclic.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (add_comm_monoid.{1} Type)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_150644 (h0 : topological_space (has_top (has_top unsigned))) : totally_disconnected_space (has_top (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_150645 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @irreducible_space.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_150646 (h0 : not (group (semi_normed_comm_ring fun_info) -> false)) : @group.fg.{0} (semi_normed_comm_ring.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (semi_normed_comm_ring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_150647 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (mul_zero_class.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_150648 (h0 : add_group (with_one (has_nnnorm char))) : is_add_cyclic (with_one (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_150649 (h0 : topological_space (boolean_algebra (ring (has_zero linarith.comp)))) : discrete_topology (boolean_algebra (ring (has_zero linarith.comp))) := sorry --non-trivial
lemma new_lemma_150650 (h0 : topological_space (has_Sup (ordered_ring (partial_order empty)))) : irreducible_space (has_Sup (ordered_ring (partial_order empty))) := sorry --non-trivial
lemma new_lemma_150651 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @t0_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_150652 (h0 : functor.add_const (topological_space auto.case_option) (option (option empty))) : @t0_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_150653 (h0 : filter (ring (option pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_150654 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (add_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} h0 (add_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_150655 (h0 : false) : false.elim h0 := sorry --trivial
lemma new_lemma_150656 (h0 : functor.add_const (topological_space (boolean_algebra pos)) Type) : @locally_compact_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_150657 (h0 : list (ring (cancel_monoid linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_150658 (h0 : functor.add_const (group (complete_distrib_lattice pos)) linarith.comp) : @group.fg.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_150659 (h1 : not (topological_space (id empty) -> false)) : @normal_space.{0} (@id.{2} Type empty) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type empty)) h1)  := sorry --non-trivial
lemma new_lemma_150660 (h0 : functor.add_const (add_group (ring unsigned)) pos) : @is_add_cyclic.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (ring.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_150661 (h0 : topological_space (has_inner (option (option empty)) unsigned)) : topological_space.separable_space (has_inner (option (option empty)) unsigned) := sorry --non-trivial
lemma new_lemma_150662 (h0 : functor.comp group has_neg_part Type) : @is_simple_group.{1} (has_neg_part.{1} Type) (@functor.comp.run.{1 1 1} group.{1} has_neg_part.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_150663 (h0 : topological_space (complete_distrib_lattice environment.implicit_infer_kind)) : preirreducible_space (complete_distrib_lattice environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_150664 (h0 : filter (semigroup (comm_group (comm_group (has_add (has_add name)))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_150665 (h0 : topological_space (add_cancel_monoid (has_to_string linarith.comp))) : irreducible_space (add_cancel_monoid (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_150666 (h0 : ring (generalized_boolean_algebra (has_neg pos))) : is_principal_ideal_ring (generalized_boolean_algebra (has_neg pos)) := sorry --non-trivial
lemma new_lemma_150667 (h0 : add_group (metric_space congr_arg_kind)) : is_add_cyclic (metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_150668 (h5 : ring (nondiscrete_normed_field reducibility_hints)) : is_domain (nondiscrete_normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_150669 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_150670 (h0 : add_monoid (pseudo_emetric_space (option empty))) : add_monoid.fg (pseudo_emetric_space (option empty)) := sorry --non-trivial
lemma new_lemma_150671 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_150672 (h3 : not (topological_space (has_ssubset (random_gen char)) -> false)) : @path_connected_space.{0} (has_ssubset.{0} (random_gen.{0} char)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} (random_gen.{0} char))) h3)  := sorry --non-trivial
lemma new_lemma_150673 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf real))) : totally_separated_space (normed_lattice_add_comm_group (has_Inf real)) := sorry --non-trivial
lemma new_lemma_150674 (h0 : topological_space std_gen) (h1 : topological_space (compact_exhaustion std_gen)) : topological_space.first_countable_topology (compact_exhaustion std_gen) := sorry --non-trivial
lemma new_lemma_150675 (h0 : add_monoid (measurable_space num)) : add_monoid.fg (measurable_space num) := sorry --non-trivial
lemma new_lemma_150676 (h0 : add_monoid (ordered_comm_group congr_arg_kind)) : add_monoid.fg (ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_150677 (h0 : add_comm_group fun_info) (h1 : has_norm fun_info) : normed_group.core fun_info := sorry --non-trivial
lemma new_lemma_150678 (h0 : add_group (complete_distrib_lattice (has_Inf Type))) : is_add_cyclic (complete_distrib_lattice (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_150679 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem uniform_space)) : @separated_space.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) uniform_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_150680 (h0 : function.extfun (Type 1) (functor.add_const (ring Type))) : @is_domain.{1} Type (@functor.add_const.run.{1 1} (ring.{1} Type) Type (@function.extfun_app.{3 2} (Type 1) (functor.add_const.{1 1} (ring.{1} Type)) h0 Type))  := sorry --non-trivial
lemma new_lemma_150681 (h3 : topological_space (has_compl (random_gen char))) : path_connected_space (has_compl (random_gen char)) := sorry --non-trivial
lemma new_lemma_150682 (h0 : group (measurable_space (add_right_cancel_monoid empty))) : normalizer_condition (measurable_space (add_right_cancel_monoid empty)) := sorry --non-trivial
lemma new_lemma_150683 (h0 : fin has_zero.zero) : @topological_space.separable_space.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_150684 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_inter ennreal)) := sorry --non-trivial
lemma new_lemma_150685 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_150686 (h0 : to_additive.value_type -> to_additive.value_type -> Prop) : is_partial_order to_additive.value_type h0 := sorry --non-trivial
lemma new_lemma_150687 (h0 : topological_space (with_bot (has_top (has_top (has_top fun_info))))) : path_connected_space (with_bot (has_top (has_top (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_150688 (h0 : set (non_unital_non_assoc_semiring (has_nnnorm linarith.comp_source))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_150689 (h0 : functor.add_const (add_group znum) (option (option unsigned))) : @is_add_cyclic.{0} znum (@functor.add_const.run.{0 0} (add_group.{0} znum) (option.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_150690 (h0 : ring (random_gen (comm_ring reducibility_hints))) : rank_condition (random_gen (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_150691 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (comm_group.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (comm_group.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_150692 (h0 : topological_space (has_to_string (finset (finset environment.implicit_infer_kind)))) : irreducible_space (has_to_string (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_150693 (h0 : functor.add_const Prop (boolean_algebra.core name)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_150694 (h0 : functor.add_const (group (complete_distrib_lattice congr_arg_kind)) unsigned) : @is_cyclic.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_150695 (h0 : uniform_space (semigroup (comm_group (comm_group Type)))) : separated_space (semigroup (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_150696 (h0 : group (boolean_algebra (has_to_string (finset (finset (ring (finset name))))))) : normalizer_condition (boolean_algebra (has_to_string (finset (finset (ring (finset name)))))) := sorry --non-trivial
lemma new_lemma_150697 (h0 : complete_lattice (metric_space (metric_space num))) : is_atomistic (metric_space (metric_space num)) := sorry --non-trivial
lemma new_lemma_150698 (h1 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} to_additive.value_type (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h1) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_150699 (h0 : not (group (id unsigned) -> false)) : @is_cyclic.{0} (@id.{2} Type unsigned) (@classical.by_contradiction'.{1} (group.{0} (@id.{2} Type unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_150700 (h0 : has_mem.mem nnreal has_zero.zero) : @is_cyclic.{0} nnreal (@multiset.pi.empty.{1 0} Type group.{0} nnreal h0)  := sorry --non-trivial
lemma new_lemma_150701 (h0 : functor.add_const (monoid (finset linarith.comp)) Type) : @monoid.fg.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (monoid.{0} (finset.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_150702 (h0 : ring (has_pos_part (has_neg pos))) : rank_condition (has_pos_part (has_neg pos)) := sorry --non-trivial
lemma new_lemma_150703 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_150704 (h0 : functor.add_const (functor.add_const (uniform_space Type) linarith.comp) environment.implicit_infer_kind) : @separated_space.{1} Type (@functor.add_const.run.{1 0} (uniform_space.{1} Type) linarith.comp (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (uniform_space.{1} Type) linarith.comp) environment.implicit_infer_kind h0))  := sorry --non-trivial
lemma new_lemma_150705 (h0 : ring (mul_zero_class (semiring (semiring (semiring (semiring unsigned)))))) : strong_rank_condition (mul_zero_class (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_150706 (h0 : topological_space (ring num)) : irreducible_space (ring num) := sorry --non-trivial
lemma new_lemma_150707 (h0 : function.extfun Type (functor.comp topological_space boolean_algebra.core)) : @t1_space.{0} (boolean_algebra.core.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} boolean_algebra.core.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_150708 (h1 : ring (semi_normed_ring (has_nnnorm (mul_one_class reducibility_hints)))) : rank_condition (semi_normed_ring (has_nnnorm (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_150709 (h0 : function.extfun Type group) : @is_simple_group.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_150710 (h0 : uniform_space (add_cancel_monoid (ring environment.implicit_infer_kind))) : complete_space (add_cancel_monoid (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_150711 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_150712 (h0 : ring (add_cancel_monoid (has_add (ring name)))) : rank_condition (add_cancel_monoid (has_add (ring name))) := sorry --non-trivial
lemma new_lemma_150713 (h0 : not (function.extfun Type list -> false)) : list.nodup (function.extfun_app (classical.by_contradiction' h0) (encodable fun_info)) := sorry --non-trivial
lemma new_lemma_150714 (h0 : not (uniform_space (add_right_cancel_monoid unsigned) -> false)) : @complete_space.{0} (add_right_cancel_monoid.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (add_right_cancel_monoid.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_150715 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_150716 (h0 : group (simple_graph (has_add linarith.comp))) : is_cyclic (simple_graph (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_150717 (h0 : topological_space (has_Inf real)) : preirreducible_space (has_Inf real) := sorry --non-trivial
lemma new_lemma_150718 (h0 : functor.add_const (topological_space (option empty)) num) : @t1_space.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_150719 (h0 : topological_space (ordered_comm_monoid (ring pos))) : sequential_space (ordered_comm_monoid (ring pos)) := sorry --non-trivial
lemma new_lemma_150720 (h0 : ring (uniform_space (add_cancel_comm_monoid string_imp))) : strong_rank_condition (uniform_space (add_cancel_comm_monoid string_imp)) := sorry --non-trivial
lemma new_lemma_150721 (h0 : uniform_space (has_nndist (option num))) : separated_space (has_nndist (option num)) := sorry --non-trivial
lemma new_lemma_150722 (h0 : uniform_space (has_top (semiring (semiring (has_norm linarith.comp))))) : separated_space (has_top (semiring (semiring (has_norm linarith.comp)))) := sorry --non-trivial
lemma new_lemma_150723 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_sub.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_sub.{0} empty))  := sorry --non-trivial
lemma new_lemma_150724 (h0 : ring (measurable_space.dynkin_system (semiring num))) : is_principal_ideal_ring (measurable_space.dynkin_system (semiring num)) := sorry --non-trivial
lemma new_lemma_150725 (h0 : topological_space (with_bot (comm_ring linarith.ineq))) : irreducible_space (with_bot (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_150726 (h0 : not (uniform_space (semi_normed_ring (mul_one_class string_imp)) -> false)) : @complete_space.{0} (semi_normed_ring.{0} (mul_one_class.{0} string_imp)) (@classical.by_contradiction'.{1} (uniform_space.{0} (semi_normed_ring.{0} (mul_one_class.{0} string_imp))) h0)  := sorry --non-trivial
lemma new_lemma_150727 (h0 : group (uniform_space (ring pos))) : normalizer_condition (uniform_space (ring pos)) := sorry --non-trivial
lemma new_lemma_150728 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (semiring.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} linarith.comp)))) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (semiring.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} linarith.comp)))))  := sorry --non-trivial
lemma new_lemma_150729 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @group.fg.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_150730 (h0 : functor.add_const (function.extfun (Type 1) finset) (finset Type)) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_150731 (h0 : functor.add_const (add_group (ordered_comm_monoid pos)) Type) : @is_add_cyclic.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (add_group.{0} (ordered_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_150732 (h0 : functor.comp add_group semigroup Type) : @is_add_cyclic.{1} (semigroup.{1} Type) (@functor.comp.run.{1 1 1} add_group.{1} semigroup.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_150733 (h0 : ring (has_pos_part (finset linarith.comp))) : rank_condition (has_pos_part (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_150734 (h0 : list (semigroup (finset (finset environment.implicit_infer_kind)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_150735 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) linarith.comp) : @totally_separated_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_150736 (h0 : function.extfun Type ring) : @is_domain.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_150737 (h0 : complete_lattice (has_emptyc (has_top (has_top fun_info)))) : is_compactly_generated (has_emptyc (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_150738 (h2 : add_group (complete_semilattice_Sup string_imp)) : is_add_cyclic (complete_semilattice_Sup string_imp) := sorry --non-trivial
lemma new_lemma_150739 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @t0_space.{0} (@id.{2} Type (has_norm.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} unsigned)))))) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (@id.{2} Type (has_norm.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} unsigned)))))))  := sorry --non-trivial
lemma new_lemma_150740 (h0 : ring (has_neg (add_comm_monoid Type))) : is_principal_ideal_ring (has_neg (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_150741 (h0 : topological_space (normed_comm_ring congr_arg_kind)) : discrete_topology (normed_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_150742 (h1 : ring (has_emptyc (has_norm (has_norm linarith.ineq)))) : rank_condition (has_emptyc (has_norm (has_norm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_150743 (h0 : not (topological_space (left_cancel_semigroup unsigned) -> false)) : @totally_disconnected_space.{0} (left_cancel_semigroup.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_semigroup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_150744 (h0 : not (topological_space (has_top linarith.comp_source) -> false)) : @irreducible_space.{0} (has_top.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_150745 (h0 : add_group (semigroup (finset (has_to_string name)))) : is_add_cyclic (semigroup (finset (has_to_string name))) := sorry --non-trivial
lemma new_lemma_150746 (h0 : not (group (linear_ordered_semiring (has_inner empty (semiring empty))) -> false)) : @normalizer_condition.{0} (linear_ordered_semiring.{0} (has_inner.{0 0} empty (semiring.{0} empty))) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_semiring.{0} (has_inner.{0 0} empty (semiring.{0} empty)))) h0)  := sorry --non-trivial
lemma new_lemma_150747 (h0 : functor.add_const (topological_space (has_zero pos)) (has_to_string (finset (has_to_string pos)))) : @t1_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) (has_to_string.{0} (finset.{0} (has_to_string.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_150748 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_150749 (h0 : group (linear_ordered_add_comm_group fun_info)) : normalizer_condition (linear_ordered_add_comm_group fun_info) := sorry --non-trivial
lemma new_lemma_150750 (h1 : uniform_space (canonically_ordered_monoid linarith.comp_source)) : complete_space (canonically_ordered_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_150751 (h0 : ring (has_top (has_top (has_top (has_top linarith.ineq))))) : rank_condition (has_top (has_top (has_top (has_top linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_150752 (h0 : functor.add_const (ring (has_to_string name)) linarith.comp) : @strong_rank_condition.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_150753 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} real.angle (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) real.angle)  := sorry --non-trivial
lemma new_lemma_150754 (h0 : has_star num -> has_star num -> Prop) : is_equiv (has_star num) h0 := sorry --non-trivial
lemma new_lemma_150755 (h0 : not (uniform_space (semi_normed_ring (mul_one_class string.iterator_imp)) -> false)) : @complete_space.{0} (semi_normed_ring.{0} (mul_one_class.{0} string.iterator_imp)) (@classical.by_contradiction'.{1} (uniform_space.{0} (semi_normed_ring.{0} (mul_one_class.{0} string.iterator_imp))) h0)  := sorry --non-trivial
lemma new_lemma_150756 (h0 : group (ordered_comm_ring (ring (has_add (ring (ring Type)))))) : is_cyclic (ordered_comm_ring (ring (has_add (ring (ring Type))))) := sorry --non-trivial
lemma new_lemma_150757 (h0 : ring (ring (has_add (finset linarith.comp)))) : strong_rank_condition (ring (has_add (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_150758 (h0 : group (add_comm_monoid (has_nndist linarith.comp))) : normalizer_condition (add_comm_monoid (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_150759 (h0 : functor.add_const (topological_space (canonically_ordered_add_monoid unsigned)) unsigned) : @t1_space.{0} (canonically_ordered_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_add_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_150760 (h0 : group (has_nndist (finset environment.implicit_infer_kind))) : group.fg (has_nndist (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_150761 (h0 : group (has_norm (has_top to_additive.value_type))) : normalizer_condition (has_norm (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_150762 (h0 : not (topological_space (linear_ordered_add_comm_group to_additive.value_type) -> false)) : @t0_space.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_150763 (h0 : functor.comp ring has_add name) : @rank_condition.{0} (has_add.{0} name) (@functor.comp.run.{0 0 0} ring.{0} has_add.{0} name h0)  := sorry --non-trivial
lemma new_lemma_150764 (h0 : ring (finset (option (option empty)))) : rank_condition (finset (option (option empty))) := sorry --non-trivial
lemma new_lemma_150765 (h0 : topological_space (monoid_with_zero unsigned)) : topological_space.separable_space (monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_150766 (h0 : ring (denumerable (has_nnnorm (has_nnnorm linarith.ineq)))) : rank_condition (denumerable (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_150767 (h0 : filter (complete_linear_order (semiring congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_150768 (h0 : ring (add_cancel_monoid (option (option unsigned)))) : is_principal_ideal_ring (add_cancel_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_150769 (h0 : ordered_add_comm_monoid (generalized_boolean_algebra (has_neg Type))) : archimedean (generalized_boolean_algebra (has_neg Type)) := sorry --non-trivial
lemma new_lemma_150770 (h0 : topological_space (has_ssubset (random_gen char))) : t0_space (has_ssubset (random_gen char)) := sorry --non-trivial
lemma new_lemma_150771 (h1 : topological_space (normed_field enat)) : totally_disconnected_space (normed_field enat) := sorry --non-trivial
lemma new_lemma_150772 (h0 : functor.comp topological_space canonically_ordered_comm_semiring pos) : @irreducible_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_150773 (h0 : topological_space (measurable_space (semiring empty))) : discrete_topology (measurable_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_150774 (h0 : functor.add_const (ring (ring environment.implicit_infer_kind)) environment.implicit_infer_kind) : @rank_condition.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_150775 (h0 : multiset (has_compl (mul_one_class linarith.comp_source))) (h1 : not (multiset (has_compl (mul_one_class linarith.comp_source)) -> false)) : multiset.disjoint h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_150776 (h0 : not (topological_space (semi_normed_ring reducibility_hints) -> false)) : @t0_space.{0} (semi_normed_ring.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_ring.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_150777 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) environment.implicit_infer_kind) : @normal_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_150778 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_150779 (h0 : topological_space (canonically_linear_ordered_monoid unsigned)) : totally_disconnected_space (canonically_linear_ordered_monoid unsigned) := sorry --non-trivial
lemma new_lemma_150780 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) linarith.comp) : @path_connected_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_150781 (h0 : topological_space (dlist string_imp)) : t0_space (dlist string_imp) := sorry --non-trivial
lemma new_lemma_150782 (h0 : filter (with_bot (semiring empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_150783 (h0 : function.extfun Type (functor.comp ring boolean_algebra)) : @strong_rank_condition.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} ring.{0} boolean_algebra.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} boolean_algebra.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_150784 (h0 : group (ordered_comm_group unsigned)) : normalizer_condition (ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_150785 (h0 : topological_space (comm_monoid (option (option unsigned)))) : locally_compact_space (comm_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_150786 (h0 : complete_lattice (add_cancel_monoid (ordered_ring Type))) : complete_lattice.is_Sup_finite_compact (add_cancel_monoid (ordered_ring Type)) := sorry --non-trivial
lemma new_lemma_150787 (h0 : functor.add_const (list (boolean_algebra.core environment.implicit_infer_kind)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_150788 (h0 : topological_space (canonically_linear_ordered_monoid (has_bot pos))) : t1_space (canonically_linear_ordered_monoid (has_bot pos)) := sorry --non-trivial
lemma new_lemma_150789 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @group.fg.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_150790 (h0 : complete_lattice (id (semiring (semiring unsigned)))) : complete_lattice.is_Sup_finite_compact (id (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_150791 (h0 : functor.add_const (ring (finset pos)) (finset name)) : @is_domain.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} pos)) (finset.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_150792 (h0 : topological_space (has_norm (random_gen (has_top fun_info)))) : totally_separated_space (has_norm (random_gen (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_150793 (h1 : complete_lattice (non_unital_non_assoc_semiring ennreal)) : is_compactly_generated (non_unital_non_assoc_semiring ennreal) := sorry --non-trivial
lemma new_lemma_150794 (h0 : functor.add_const (topological_space (add_semigroup empty)) empty) : @loc_path_connected_space.{0} (add_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_150795 (h0 : functor.add_const (topological_space (add_comm_monoid unsigned)) name) : @totally_disconnected_space.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_150796 (h0 : ring (cancel_monoid (option (option ennreal)))) : is_domain (cancel_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_150797 (h0 : functor.add_const (add_monoid (semiring num)) (semiring num)) : @add_monoid.fg.{0} (semiring.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (semiring.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_150798 (h0 : topological_space (ordered_comm_ring (has_add real))) : sequential_space (ordered_comm_ring (has_add real)) := sorry --non-trivial
lemma new_lemma_150799 (h0 : topological_space (semi_normed_ring (mul_one_class (random_gen linarith.ineq)))) : totally_disconnected_space (semi_normed_ring (mul_one_class (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_150800 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (monoid_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_150801 (h0 : topological_space (canonically_ordered_comm_semiring (has_add linarith.comp))) : irreducible_space (canonically_ordered_comm_semiring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_150802 (h0 : uniform_space (has_emptyc (semiring linarith.comp))) : complete_space (has_emptyc (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_150803 (h0 : ring (has_lt environment.projection_info)) : is_domain (has_lt environment.projection_info) := sorry --non-trivial
lemma new_lemma_150804 (h0 : topological_space (semigroup (semiring (semiring (semiring num))))) : t0_space (semigroup (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_150805 (h0 : topological_space (ordered_comm_group (option (option empty)))) : loc_path_connected_space (ordered_comm_group (option (option empty))) := sorry --non-trivial
lemma new_lemma_150806 (h0 : ring (add_cancel_monoid ennreal)) : strong_rank_condition (add_cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_150807 (h0 : complete_lattice (random_gen (random_gen (random_gen char)))) : is_compactly_generated (random_gen (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_150808 (h0 : topological_space (with_zero (has_nnnorm linarith.ineq))) : totally_disconnected_space (with_zero (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_150809 (h0 : topological_space (pseudo_metric_space name)) : discrete_topology (pseudo_metric_space name) := sorry --non-trivial
lemma new_lemma_150810 (h0 : topological_space (has_lt enat)) : t0_space (has_lt enat) := sorry --non-trivial
lemma new_lemma_150811 (h0 : functor.add_const (semiring (option num)) (semiring empty)) : @is_noetherian_ring.{0} (option.{0} num) (@functor.add_const.run.{0 0} (semiring.{0} (option.{0} num)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_150812 (h0 : uniform_space (left_cancel_monoid (option empty))) : complete_space (left_cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_150813 (h0 : topological_space (has_bot Type)) : totally_separated_space (has_bot Type) := sorry --non-trivial
lemma new_lemma_150814 (h0 : complete_lattice (comm_ring (random_gen (has_nnnorm linarith.comp_source)))) : complete_lattice.is_Sup_finite_compact (comm_ring (random_gen (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_150815 (h0 : uniform_space (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup enat)))) : complete_space (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup enat))) := sorry --non-trivial
lemma new_lemma_150816 (h0 : uniform_space (option num)) : complete_space (option num) := sorry --non-trivial
lemma new_lemma_150817 (h0 : monoid (has_top (semiring congr_arg_kind))) : monoid.fg (has_top (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_150818 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_150819 (h0 : add_monoid (linear_ordered_field (option (option (option (option pos)))))) : add_monoid.fg (linear_ordered_field (option (option (option (option pos))))) := sorry --non-trivial
lemma new_lemma_150820 (h0 : ring (has_ssubset (has_ssubset string_imp))) : rank_condition (has_ssubset (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_150821 (h0 : ordered_add_comm_monoid (ordered_cancel_add_comm_monoid pos)) : archimedean (ordered_cancel_add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_150822 (h0 : function.extfun Type group) : @group.fg.{0} (linear_ordered_add_comm_group.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_add_comm_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_150823 (h0 : topological_space (random_gen (has_nnnorm (comm_ring (has_lt reducibility_hints))))) : t0_space (random_gen (has_nnnorm (comm_ring (has_lt reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_150824 (h0 : functor.add_const (group (semigroup linarith.comp)) Type) : @is_cyclic.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (semigroup.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_150825 (h0 : functor.add_const (topological_space (has_neg_part name)) unsigned) : @t1_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_150826 (h0 : ordered_add_comm_monoid (has_Inf (has_neg name))) : archimedean (has_Inf (has_neg name)) := sorry --non-trivial
lemma new_lemma_150827 (h0 : group (has_to_string (has_add environment.implicit_infer_kind))) : group.fg (has_to_string (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_150828 (h0 : functor.comp ring comm_group Type) : @is_principal_ideal_ring.{1} (comm_group.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} comm_group.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_150829 (h0 : group (has_zero (boolean_algebra Type))) : is_simple_group (has_zero (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_150830 (h1 : function.extfun Type topological_space) : @path_connected_space.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_150831 (h0 : group (complete_distrib_lattice (option ennreal))) : normalizer_condition (complete_distrib_lattice (option ennreal)) := sorry --non-trivial
lemma new_lemma_150832 (h0 : topological_space (has_bot Type)) : irreducible_space (has_bot Type) := sorry --non-trivial
lemma new_lemma_150833 (h0 : list (complete_distrib_lattice (semiring empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_150834 (h0 : functor.add_const (ring (simple_graph linarith.comp)) (has_add (ring (has_add name)))) : @strong_rank_condition.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (simple_graph.{0} linarith.comp)) (has_add.{0} (ring.{0} (has_add.{0} name))) h0)  := sorry --non-trivial
lemma new_lemma_150835 (h0 : topological_space (has_compl (random_gen to_additive.value_type))) : totally_disconnected_space (has_compl (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_150836 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @totally_separated_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_150837 (h0 : topological_space (has_neg (finset pos))) : totally_disconnected_space (has_neg (finset pos)) := sorry --non-trivial
lemma new_lemma_150838 (h0 : prod (has_add name) (has_add name)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_150839 (h0 : functor.add_const (functor.add_const (complete_lattice pos) Type) Type) : @complete_lattice.is_Sup_finite_compact.{0} pos (@functor.add_const.run.{0 1} (complete_lattice.{0} pos) Type (@functor.add_const.run.{0 1} (functor.add_const.{0 1} (complete_lattice.{0} pos) Type) Type h0))  := sorry --non-trivial
lemma new_lemma_150840 (h0 : topological_space (has_add (has_add unsigned))) : totally_disconnected_space (has_add (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_150841 (h0 : has_mem.mem (with_bot fun_info) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_bot.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_150842 (h0 : functor.add_const (complete_lattice (has_zero unsigned)) linarith.comp) : @is_compactly_generated.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_150843 (h0 : topological_space (has_to_string (has_pos_part Type))) : topological_space.separable_space (has_to_string (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_150844 (h0 : not (add_group (has_nnnorm string_imp) -> false)) : @is_add_cyclic.{0} (has_nnnorm.{0} string_imp) (@classical.by_contradiction'.{1} (add_group.{0} (has_nnnorm.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_150845 (h0 : topological_space (sub_neg_monoid (finset (has_Inf (has_add (has_Inf (has_add linarith.comp))))))) : discrete_topology (sub_neg_monoid (finset (has_Inf (has_add (has_Inf (has_add linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_150846 (h0 : ring (has_neg (has_add (ring (ring pos))))) : is_domain (has_neg (has_add (ring (ring pos)))) := sorry --non-trivial
lemma new_lemma_150847 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_150848 (h1 : ring (add_comm_semigroup linarith.ineq)) : is_domain (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_150849 (h0 : not (ring (lattice reducibility_hints) -> false)) : @rank_condition.{0} (lattice.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (lattice.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_150850 (h1 : ring (uniform_space std_gen)) : rank_condition (uniform_space std_gen) := sorry --non-trivial
lemma new_lemma_150851 (h0 : group (ring (has_add (add_comm_monoid (add_comm_monoid (has_add Type)))))) : is_simple_group (ring (has_add (add_comm_monoid (add_comm_monoid (has_add Type))))) := sorry --non-trivial
lemma new_lemma_150852 (h0 : finset (has_dist (option (option empty)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_150853 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_150854 (h0 : topological_space (non_assoc_semiring congr_arg_kind)) : topological_space.separable_space (non_assoc_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_150855 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_add linarith.comp)) (has_neg Type)) : @unique_factorization_monoid.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (has_add.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_150856 (h0 : ring (linear_ordered_field pos)) : is_domain (linear_ordered_field pos) := sorry --non-trivial
lemma new_lemma_150857 (h0 : has_mem.mem (id num) has_emptyc.emptyc) : @strong_rank_condition.{0} (@id.{2} Type num) (@finset.pi.empty.{1 0} Type ring.{0} (@id.{2} Type num) h0)  := sorry --non-trivial
lemma new_lemma_150858 (h0 : topological_space (monoid (option ennreal))) : totally_disconnected_space (monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_150859 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) (has_neg (has_neg (finset Type)))) : @locally_compact_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) (has_neg.{1} (has_neg.{1} (finset.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_150860 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_150861 (h0 : semiring (linear_ordered_semiring (has_norm empty))) : is_noetherian_ring (linear_ordered_semiring (has_norm empty)) := sorry --non-trivial
lemma new_lemma_150862 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_150863 (h0 : ring (boolean_algebra (boolean_algebra pos))) : is_domain (boolean_algebra (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_150864 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} h0 (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_150865 (h0 : topological_space (simple_graph (has_Inf pos))) : preconnected_space (simple_graph (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_150866 (h0 : functor.add_const (ring (normed_linear_ordered_group empty)) num) : @is_domain.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (normed_linear_ordered_group.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_150867 (h0 : not (add_group (add_semigroup string_imp) -> false)) : @is_add_cyclic.{0} (add_semigroup.{0} string_imp) (@classical.by_contradiction'.{1} (add_group.{0} (add_semigroup.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_150868 (h0 : group (has_nndist environment.implicit_infer_kind)) : is_cyclic (has_nndist environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_150869 (h0 : topological_space (has_to_string (has_add ennreal))) : regular_space (has_to_string (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_150870 (h0 : topological_space (has_to_string (has_add (has_Inf linarith.comp)))) : locally_compact_space (has_to_string (has_add (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_150871 (h0 : topological_space (simple_graph (ring pos))) : discrete_topology (simple_graph (ring pos)) := sorry --non-trivial
lemma new_lemma_150872 (h0 : group (comm_group (has_nndist name))) : normalizer_condition (comm_group (has_nndist name)) := sorry --non-trivial
lemma new_lemma_150873 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_150874 (h0 : function.extfun nat fin) : @topological_space.separable_space.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_150875 (h0 : uniform_space (has_zero congr_arg_kind)) : complete_space (has_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_150876 (h0 : has_top (complete_linear_order congr_arg_kind) -> has_top (complete_linear_order congr_arg_kind) -> Prop) : is_strict_order (has_top (complete_linear_order congr_arg_kind)) h0 := sorry --non-trivial
lemma new_lemma_150877 (h0 : topological_space (has_Inf (has_pos_part pos))) : preconnected_space (has_Inf (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_150878 (h0 : uniform_space (mul_zero_class (finset pos))) : complete_space (mul_zero_class (finset pos)) := sorry --non-trivial
lemma new_lemma_150879 (h0 : group (denumerable (random_gen linarith.comp_source))) : is_cyclic (denumerable (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_150880 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) h0) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_150881 (h0 : functor.add_const (topological_space pos) unsigned) : @totally_separated_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) unsigned h0)  := sorry --non-trivial
lemma new_lemma_150882 (h0 : uniform_space (add_comm_monoid (has_neg (canonically_linear_ordered_add_monoid linarith.comp)))) : complete_space (add_comm_monoid (has_neg (canonically_linear_ordered_add_monoid linarith.comp))) := sorry --non-trivial
lemma new_lemma_150883 (h0 : ring (has_nnnorm (denumerable (normed_field string_imp)))) : strong_rank_condition (has_nnnorm (denumerable (normed_field string_imp))) := sorry --non-trivial
lemma new_lemma_150884 (h0 : functor.add_const (filter (has_neg unsigned)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_150885 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (linear_ordered_comm_group.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (linear_ordered_comm_group.{0} num))  := sorry --non-trivial
lemma new_lemma_150886 (h0 : functor.add_const (functor.add_const (ring Type) name) (has_add (has_pos_part linarith.comp))) : @rank_condition.{1} Type (@functor.add_const.run.{1 0} (ring.{1} Type) name (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (ring.{1} Type) name) (has_add.{0} (has_pos_part.{0} linarith.comp)) h0))  := sorry --non-trivial
lemma new_lemma_150887 (h0 : functor.add_const (list (has_Sup num)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_150888 (h0 : group (add_group to_additive.value_type)) : is_cyclic (add_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_150889 (h1 : ring (comm_ring fun_info)) : is_domain (comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_150890 (h0 : group (generalized_boolean_algebra (ordered_ring name))) : is_cyclic (generalized_boolean_algebra (ordered_ring name)) := sorry --non-trivial
lemma new_lemma_150891 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_150892 (h0 : topological_space (canonically_linear_ordered_monoid pos)) : sequential_space (canonically_linear_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_150893 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_150894 (h1 : ring (uniform_space to_additive.value_type)) : rank_condition (uniform_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_150895 (h0 : uniform_space (has_emptyc num)) : complete_space (has_emptyc num) := sorry --non-trivial
lemma new_lemma_150896 (h0 : ring (normed_group (semiring unsigned))) : rank_condition (normed_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_150897 (h0 : functor.add_const (ordered_comm_monoid (comm_group Type)) Type) : @has_exists_mul_of_le.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 1} (ordered_comm_monoid.{1} (comm_group.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_150898 (h0 : topological_space (complete_linear_order (semiring unsigned))) : topological_space.separable_space (complete_linear_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_150899 (h0 : ring (dlist (has_nnnorm to_additive.value_type))) : strong_rank_condition (dlist (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_150900 (h0 : ring (has_to_string (has_add (has_add (has_add (boolean_algebra (has_add Type))))))) : rank_condition (has_to_string (has_add (has_add (has_add (boolean_algebra (has_add Type)))))) := sorry --non-trivial
lemma new_lemma_150901 (h0 : ring (has_top (has_ssubset fun_info))) : rank_condition (has_top (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_150902 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_150903 (h0 : set (environment.implicit_infer_kind -> string.iterator_imp)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_150904 (h0 : ring (normed_comm_ring name)) : rank_condition (normed_comm_ring name) := sorry --non-trivial
lemma new_lemma_150905 (h0 : functor.add_const (monoid (ordered_comm_group unsigned)) empty) : @monoid.fg.{0} (ordered_comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (ordered_comm_group.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_150906 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) (has_add linarith.comp)) : @loc_path_connected_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_150907 (h0 : group (generalized_boolean_algebra (finset pos))) : is_simple_group (generalized_boolean_algebra (finset pos)) := sorry --non-trivial
lemma new_lemma_150908 (h0 : topological_space (has_top (id (id linarith.comp)))) : totally_separated_space (has_top (id (id linarith.comp))) := sorry --non-trivial
lemma new_lemma_150909 (h1 : add_group (has_nnnorm enat)) : is_add_cyclic (has_nnnorm enat) := sorry --non-trivial
lemma new_lemma_150910 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_150911 (h0 : group (has_add name)) : group.fg (has_add name) := sorry --non-trivial
lemma new_lemma_150912 (h0 : functor.add_const (ring (semigroup Type)) name) : @is_principal_ideal_ring.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (semigroup.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_150913 (h0 : group (distrib_lattice (has_top fun_info))) : group.fg (distrib_lattice (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_150914 (h1 : topological_space (has_lt linarith.ineq)) (h2 : preorder (has_lt linarith.ineq)) : order_topology (has_lt linarith.ineq) := sorry --non-trivial
lemma new_lemma_150915 (h0 : complete_lattice (measurable_space.dynkin_system unsigned)) : is_atomistic (measurable_space.dynkin_system unsigned) := sorry --non-trivial
lemma new_lemma_150916 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_150917 (h0 : group (add_cancel_monoid (add_comm_monoid pos))) : is_simple_group (add_cancel_monoid (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_150918 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) pos) : @path_connected_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_150919 (h0 : topological_space (has_nndist (has_neg_part Type))) : totally_separated_space (has_nndist (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_150920 (h0 : ring (has_top (random_gen (random_gen linarith.ineq)))) : is_domain (has_top (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_150921 (h0 : filter (finset (has_pos_part (has_to_string pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_150922 (h0 : finset (add_comm_monoid (has_neg linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_150923 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) Type) : @loc_path_connected_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_150924 (h0 : functor.add_const (topological_space (has_nndist name)) (comm_group Type)) : @sequential_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} name)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_150925 (h0 : topological_space (has_neg (finset (has_add pos)))) : normal_space (has_neg (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_150926 (h0 : functor.add_const (add_monoid (generalized_boolean_algebra linarith.comp)) pos) : @add_monoid.fg.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (generalized_boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_150927 (h0 : topological_space (has_Inf (boolean_algebra linarith.comp))) : preirreducible_space (has_Inf (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_150928 (h0 : topological_space (normed_group (semiring unsigned))) : totally_disconnected_space (normed_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_150929 (h0 : functor.add_const (topological_space (ring pos)) (ordered_ring pos)) : @locally_compact_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) (ordered_ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_150930 (h0 : uniform_space (has_Inf Type)) : separated_space (has_Inf Type) := sorry --non-trivial
lemma new_lemma_150931 (h0 : functor.add_const (complete_lattice (has_nndist ennreal)) unsigned) : @is_atomistic.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_150932 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_150933 (h0 : not (add_group (normed_group linarith.ineq) -> false)) : @is_add_cyclic.{0} (normed_group.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (normed_group.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_150934 (h0 : functor.add_const (topological_space (linear_ordered_field Type)) name) : @t1_space.{1} (linear_ordered_field.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (linear_ordered_field.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_150935 (h0 : complete_lattice (id (semiring (has_norm linarith.comp)))) : complete_lattice.is_Sup_finite_compact (id (semiring (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_150936 (h0 : functor.add_const (topological_space (finset pos)) (finset pos)) : @discrete_topology.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_150937 (h0 : topological_space (ordered_comm_ring (has_add Type))) : normal_space (ordered_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_150938 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @archimedean.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ordered_add_comm_monoid.{1}) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_150939 (h0 : complete_lattice (add_right_cancel_monoid congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (add_right_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_150940 (h0 : add_group (add_comm_monoid (has_to_string pos))) : is_add_cyclic (add_comm_monoid (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_150941 (h0 : topological_space (simple_graph (has_add pos))) : t0_space (simple_graph (has_add pos)) := sorry --non-trivial
lemma new_lemma_150942 (h0 h1 : multiset (semi_normed_comm_ring char)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_150943 (h0 : topological_space (semigroup (has_add ennreal))) : totally_separated_space (semigroup (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_150944 (h0 : uniform_space (measurable_space (random_gen (random_gen linarith.ineq)))) : complete_space (measurable_space (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_150945 (h0 : list (complete_distrib_lattice (has_nndist pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_150946 (h0 : functor.add_const (ring (option congr_arg_kind)) unsigned) : @strong_rank_condition.{0} (option.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (option.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_150947 (h0 : function.extfun Type measurable_space) (h1 : has_mul (option_t linear_ordered_comm_group empty)) : @has_measurable_mul₂.{0} (option_t.{0 0} linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type measurable_space.{0} h0 (option_t.{0 0} linear_ordered_comm_group.{0} empty)) h1  := sorry --non-trivial
lemma new_lemma_150948 (h0 : functor.add_const (uniform_space (complete_distrib_lattice unsigned)) (option (option empty))) : @complete_space.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (complete_distrib_lattice.{0} unsigned)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_150949 (h0 h1 : multiset (simple_graph (mul_one_class linarith.ineq))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_150950 (h0 : not (ring unsigned -> false)) : @is_domain.{0} unsigned (@classical.by_contradiction'.{1} (ring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_150951 (h0 : functor.add_const (ring (non_assoc_semiring num)) (semiring (semiring num))) : @is_principal_ideal_ring.{0} (non_assoc_semiring.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (non_assoc_semiring.{0} num)) (semiring.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_150952 (h0 : ring (with_one (has_norm num))) : strong_rank_condition (with_one (has_norm num)) := sorry --non-trivial
lemma new_lemma_150953 (h0 : topological_space (semigroup (has_nndist environment.implicit_infer_kind))) : sequential_space (semigroup (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_150954 (h0 : ring (has_compl string_imp)) : strong_rank_condition (has_compl string_imp) := sorry --non-trivial
lemma new_lemma_150955 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_150956 (h0 : topological_space (mul_one_class string.iterator_imp)) : topological_space.first_countable_topology (mul_one_class string.iterator_imp) := sorry --non-trivial
lemma new_lemma_150957 (h0 : topological_space (add_cancel_monoid (has_add environment.implicit_infer_kind))) : t1_space (add_cancel_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_150958 (h0 : functor.add_const (uniform_space (ordered_comm_ring real)) (has_add (has_Inf Type))) : @complete_space.{0} (ordered_comm_ring.{0} real) (@functor.add_const.run.{0 1} (uniform_space.{0} (ordered_comm_ring.{0} real)) (has_add.{1} (has_Inf.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_150959 (h0 : complete_lattice (has_neg unsigned)) : complete_lattice.is_Sup_finite_compact (has_neg unsigned) := sorry --non-trivial
lemma new_lemma_150960 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_to_string.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_to_string.{0} empty))  := sorry --non-trivial
lemma new_lemma_150961 (h0 : finset (ordered_cancel_add_comm_monoid (option (option num)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_150962 (h0 : not (add_group (with_one to_additive.value_type) -> false)) : @is_add_cyclic.{0} (with_one.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (add_group.{0} (with_one.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_150963 (h1 : topological_space (has_lt linarith.comp_source)) : path_connected_space (has_lt linarith.comp_source) := sorry --non-trivial
lemma new_lemma_150964 (h0 : not (function.extfun Type list -> false)) : list.nodup (function.extfun_app (classical.by_contradiction' h0) (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_150965 (h0 : group (has_Inf (has_neg (has_Inf (ordered_ring Type))))) : normalizer_condition (has_Inf (has_neg (has_Inf (ordered_ring Type)))) := sorry --non-trivial
lemma new_lemma_150966 (h0 : group (has_bot (has_add (has_add (has_add (has_add linarith.comp)))))) : is_simple_group (has_bot (has_add (has_add (has_add (has_add linarith.comp))))) := sorry --non-trivial
lemma new_lemma_150967 (h0 : complete_lattice (normed_field (has_nnnorm enat))) : complete_lattice.is_Sup_finite_compact (normed_field (has_nnnorm enat)) := sorry --non-trivial
lemma new_lemma_150968 (h0 : topological_space (preorder (option (option empty)))) : totally_disconnected_space (preorder (option (option empty))) := sorry --non-trivial
lemma new_lemma_150969 (h0 : functor.add_const (topological_space (cancel_monoid unsigned)) congr_arg_kind) : @normal_space.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_150970 (h0 : list (linear_ordered_comm_ring (semiring (semiring (semiring (semiring (semiring num))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_150971 (h0 : uniform_space (linear_ordered_add_comm_group linarith.ineq)) : complete_space (linear_ordered_add_comm_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_150972 (h1 : function.extfun Type add_group) : @is_add_cyclic.{0} (@id.{2} Type linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} h1 (@id.{2} Type linarith.ineq))  := sorry --non-trivial
lemma new_lemma_150973 (h0 : complete_lattice (normed_comm_ring (has_nndist pos))) : is_atomistic (normed_comm_ring (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_150974 (h0 : function.extfun Type group) : @is_cyclic.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_150975 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @loc_path_connected_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_150976 (h0 : ring (has_to_string (finset ennreal))) : is_domain (has_to_string (finset ennreal)) := sorry --non-trivial
lemma new_lemma_150977 (h0 : topological_space (is_R_or_C (semiring empty))) : t1_space (is_R_or_C (semiring empty)) := sorry --non-trivial
lemma new_lemma_150978 (h0 : not (monoid (normed_group congr_arg_kind) -> false)) : @monoid.fg.{0} (normed_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (monoid.{0} (normed_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_150979 (h0 : topological_space (measurable_space linarith.comp)) : normal_space (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_150980 (h0 : topological_space (simple_graph (has_nndist Type))) : preirreducible_space (simple_graph (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_150981 (h0 : has_mem.mem (with_bot empty) has_emptyc.emptyc) : @discrete_topology.{0} (with_bot.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_150982 (h0 : ordered_add_comm_monoid (preorder num)) : archimedean (preorder num) := sorry --non-trivial
lemma new_lemma_150983 (h0 : function.extfun Type (functor.add_const (ordered_add_comm_monoid (metric_space num)))) : @archimedean.{0} (metric_space.{0} num) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (metric_space.{0} num)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} (metric_space.{0} num))) h0 empty))  := sorry --non-trivial
lemma new_lemma_150984 (h0 : functor.add_const (topological_space (preorder unsigned)) (semiring empty)) : @irreducible_space.{0} (preorder.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} unsigned)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_150985 (h0 : topological_space (has_neg_part (semigroup unsigned))) : discrete_topology (has_neg_part (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_150986 (h0 : functor.add_const (functor.add_const (ring environment.implicit_infer_kind) name) environment.implicit_infer_kind) : @strong_rank_condition.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (ring.{0} environment.implicit_infer_kind) name (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ring.{0} environment.implicit_infer_kind) name) environment.implicit_infer_kind h0))  := sorry --non-trivial
lemma new_lemma_150987 (h0 : topological_space (boolean_algebra (has_Inf pos))) : topological_space.separable_space (boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_150988 (h1 : filter (semi_normed_comm_ring linarith.comp_source)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_150989 (h0 : group (has_bot (has_neg name))) : is_cyclic (has_bot (has_neg name)) := sorry --non-trivial
lemma new_lemma_150990 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) (has_neg Type)) : @irreducible_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_150991 (h0 : functor.add_const (topological_space ordering) pos) : @loc_path_connected_space.{0} ordering (@functor.add_const.run.{0 0} (topological_space.{0} ordering) pos h0)  := sorry --non-trivial
lemma new_lemma_150992 (h0 : filter (has_top (has_ssubset to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_150993 (h0 : function.extfun nat fin) : @totally_separated_space.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_150994 (h0 : topological_space (add_left_cancel_semigroup unsigned)) : normal_space (add_left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_150995 (h0 : filter (random_gen linarith.comp_source)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_150996 (h0 : add_group (cancel_monoid (semigroup name))) : is_add_cyclic (cancel_monoid (semigroup name)) := sorry --non-trivial
lemma new_lemma_150997 (h0 : functor.add_const (complete_lattice (has_nndist environment.implicit_infer_kind)) linarith.comp) : @is_compactly_generated.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_150998 (h0 : functor.add_const (semiring (boolean_algebra Type)) pos) : @is_noetherian_ring.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_150999 (h0 : functor.comp topological_space boolean_algebra.core name) : @sequential_space.{0} (boolean_algebra.core.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} name h0)  := sorry --non-trivial
lemma new_lemma_151000 (h0 : functor.add_const (group (ordered_comm_monoid pos)) Type) : @group.fg.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (ordered_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_151001 (h0 : uniform_space (linear_ordered_semiring (has_top empty))) : separated_space (linear_ordered_semiring (has_top empty)) := sorry --non-trivial
lemma new_lemma_151002 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_151003 (h0 : functor.add_const (complete_lattice (ring linarith.comp)) (has_neg linarith.comp)) : @is_compactly_generated.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} linarith.comp)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_151004 (h0 : topological_space (boolean_algebra (boolean_algebra (has_add pos)))) : normal_space (boolean_algebra (boolean_algebra (has_add pos))) := sorry --non-trivial
lemma new_lemma_151005 (h0 : functor.comp finset add_cancel_monoid Type) : finset.nonempty (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_151006 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_151007 (h0 : complete_lattice (ring (option ennreal))) : is_compactly_generated (ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_151008 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) linarith.comp) : @loc_path_connected_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_151009 (h0 : function.extfun Type (functor.add_const (functor.add_const (topological_space (linear_order empty)) num))) : @discrete_topology.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_order.{0} empty)) num (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} (linear_order.{0} empty)) num) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (functor.add_const.{0 0} (topological_space.{0} (linear_order.{0} empty)) num)) h0 num)))  := sorry --non-trivial
lemma new_lemma_151010 (h0 : ring (has_add linarith.comp_source)) : rank_condition (has_add linarith.comp_source) := sorry --non-trivial
lemma new_lemma_151011 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_cancel_add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_151012 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (bin_tree.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (bin_tree.{0} empty))  := sorry --non-trivial
lemma new_lemma_151013 (h0 : functor.add_const (ring (has_edist unsigned)) empty) : @is_principal_ideal_ring.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_edist.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_151014 (h0 : topological_space (canonically_ordered_comm_semiring (has_add Type))) : locally_compact_space (canonically_ordered_comm_semiring (has_add Type)) := sorry --non-trivial
lemma new_lemma_151015 (h0 : fin has_zero.zero) : @discrete_topology.{0} (ordered_comm_ring.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_151016 (h0 : measurable_space std_gen) (h1 : measure_theory.measure std_gen -> fun_info) (h2 : coe_sort (set.range h1)) : measure_theory.is_finite_measure (set.range_splitting h1 h2) := sorry --non-trivial
lemma new_lemma_151017 (h0 : topological_space (canonically_linear_ordered_monoid (finset (finset linarith.comp)))) : path_connected_space (canonically_linear_ordered_monoid (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_151018 (h0 : group (boolean_algebra.core (has_Inf pos))) : is_cyclic (boolean_algebra.core (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_151019 (h0 : list (has_to_string (has_pos_part (finset (has_add (normed_comm_ring (finset linarith.comp))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_151020 (h0 : topological_space (has_edist congr_arg_kind)) : normal_space (has_edist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_151021 (h0 : topological_space (linear_ordered_comm_monoid_with_zero empty)) : irreducible_space (linear_ordered_comm_monoid_with_zero empty) := sorry --non-trivial
lemma new_lemma_151022 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_151023 (h0 : topological_space (finset (has_neg (has_neg Type)))) : irreducible_space (finset (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_151024 (h0 : topological_space (normed_field ereal)) (h1 : preorder (normed_field ereal)) : order_closed_topology (normed_field ereal) := sorry --non-trivial
lemma new_lemma_151025 (h0 : group (has_compl (has_ssubset char))) : is_cyclic (has_compl (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_151026 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra.core name)) linarith.comp) : @archimedean.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (boolean_algebra.core.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_151027 (h0 : fin has_zero.zero) : @strong_rank_condition.{1} (has_nndist.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (has_nndist.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_151028 (h0 : functor.add_const (topological_space (comm_group name)) name) : @totally_separated_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_151029 (h0 : not (topological_space (has_lt to_additive.value_type) -> false)) : @path_connected_space.{0} (has_lt.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_lt.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_151030 (h0 : topological_space (normed_group empty)) : locally_compact_space (normed_group empty) := sorry --non-trivial
lemma new_lemma_151031 (h0 : complete_lattice (has_add (ring (mul_one_class (ring (has_neg Type)))))) : complete_lattice.is_Sup_finite_compact (has_add (ring (mul_one_class (ring (has_neg Type))))) := sorry --non-trivial
lemma new_lemma_151032 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_151033 (h0 : functor.comp topological_space add_cancel_monoid unsigned) : @preconnected_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_151034 (h0 : topological_space (ordered_comm_monoid (has_Inf (has_add pos)))) : path_connected_space (ordered_comm_monoid (has_Inf (has_add pos))) := sorry --non-trivial
lemma new_lemma_151035 (h0 : has_zero (monoid ennreal) -> has_zero (monoid ennreal) -> Prop) : is_symm (has_zero (monoid ennreal)) h0 := sorry --non-trivial
lemma new_lemma_151036 (h0 : ring (has_add (ordered_ring (ring name)))) : strong_rank_condition (has_add (ordered_ring (ring name))) := sorry --non-trivial
lemma new_lemma_151037 (h0 : functor.add_const (finset (complete_distrib_lattice name)) (has_to_string pos)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_151038 (h0 : functor.add_const (function.extfun Type uniform_space) Type) : @separated_space.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) Type h0) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_151039 (h0 : function.extfun nat fin) : @add_monoid.fg.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (add_monoid.{0} (ordered_comm_ring.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_151040 (h0 : monoid (semigroup (ring (has_neg Type)))) : monoid.fg (semigroup (ring (has_neg Type))) := sorry --non-trivial
lemma new_lemma_151041 (h0 : topological_space (has_to_string congr_arg_kind)) : locally_compact_space (has_to_string congr_arg_kind) := sorry --non-trivial
lemma new_lemma_151042 (h0 : add_monoid (mul_zero_class (has_add (has_add name)))) : add_monoid.fg (mul_zero_class (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_151043 (h0 : ring (random_gen (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))))) : strong_rank_condition (random_gen (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_151044 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_151045 (h0 : functor.add_const (monoid (boolean_algebra linarith.comp)) (finset environment.implicit_infer_kind)) : @monoid.fg.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (boolean_algebra.{0} linarith.comp)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_151046 (h0 : functor.add_const (topological_space (has_to_string Type)) linarith.comp) : @loc_path_connected_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_151047 (h0 : add_group (comm_group (finset pos))) : is_add_cyclic (comm_group (finset pos)) := sorry --non-trivial
lemma new_lemma_151048 (h0 : function.extfun Type (functor.comp monoid has_neg)) : @monoid.fg.{0} (has_neg.{0} pos) (@functor.comp.run.{0 0 0} monoid.{0} has_neg.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} monoid.{0} has_neg.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_151049 (h0 : uniform_space (measurable_space.dynkin_system empty)) : complete_space (measurable_space.dynkin_system empty) := sorry --non-trivial
lemma new_lemma_151050 (h0 : functor.add_const (fin has_zero.zero) (has_Inf Type)) : @locally_compact_space.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (complete_distrib_lattice.{1} Type)) (@functor.add_const.run.{0 1} (fin (@has_zero.zero.{0} nat nat.has_zero)) (has_Inf.{1} Type) h0))  := sorry --non-trivial
lemma new_lemma_151051 (h0 : uniform_space (canonically_ordered_comm_semiring (option empty))) : separated_space (canonically_ordered_comm_semiring (option empty)) := sorry --non-trivial
lemma new_lemma_151052 (h0 : topological_space (boolean_algebra (has_to_string (has_to_string unsigned)))) : loc_path_connected_space (boolean_algebra (has_to_string (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_151053 (h0 : topological_space (non_assoc_semiring (option (option (option empty))))) : discrete_topology (non_assoc_semiring (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_151054 (h0 : cancel_comm_monoid_with_zero (linear_ordered_field (option num))) : unique_factorization_monoid (linear_ordered_field (option num)) := sorry --non-trivial
lemma new_lemma_151055 (h0 : functor.add_const (complete_lattice (normed_comm_ring Type)) name) : @is_atomistic.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (normed_comm_ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_151056 (h0 : complete_lattice (generalized_boolean_algebra (has_pos_part linarith.comp))) : is_compactly_generated (generalized_boolean_algebra (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_151057 (h0 : add_group (fintype linarith.comp_source)) : is_add_cyclic (fintype linarith.comp_source) := sorry --non-trivial
lemma new_lemma_151058 (h0 : set (std_gen -> mul_one_class ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_151059 (h2 : group linarith.ineq) : normalizer_condition linarith.ineq := sorry --non-trivial
lemma new_lemma_151060 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (with_one.{0} (with_bot.{0} to_additive.value_type)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (with_one.{0} (with_bot.{0} to_additive.value_type)))  := sorry --non-trivial
lemma new_lemma_151061 (h0 : not (group (has_top empty) -> false)) : @is_cyclic.{0} (has_top.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (has_top.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_151062 (h0 : functor.add_const (topological_space (has_Sup unsigned)) unsigned) : @totally_separated_space.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_151063 (h0 : topological_space (normed_comm_ring (has_add unsigned))) : sequential_space (normed_comm_ring (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_151064 (h0 : function.extfun Type (functor.add_const (add_monoid (comm_group pos)))) : @add_monoid.fg.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (comm_group.{0} pos)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_monoid.{0} (comm_group.{0} pos))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_151065 (h0 : function.extfun Type (functor.add_const (complete_lattice (has_nndist ennreal)))) : @is_atomistic.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} ennreal)) ennreal (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (has_nndist.{0} ennreal))) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_151066 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_151067 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_151068 (h0 : ordered_comm_monoid (ring (has_neg (has_neg (has_neg (has_neg (has_neg pos))))))) : has_exists_mul_of_le (ring (has_neg (has_neg (has_neg (has_neg (has_neg pos)))))) := sorry --non-trivial
lemma new_lemma_151069 (h0 : topological_space (canonically_linear_ordered_monoid pos)) : loc_path_connected_space (canonically_linear_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_151070 (h0 : topological_space (linear_ordered_comm_group ennreal)) : preconnected_space (linear_ordered_comm_group ennreal) := sorry --non-trivial
lemma new_lemma_151071 (h0 : uniform_space (ring (has_Inf Type))) : complete_space (ring (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_151072 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_151073 (h0 : has_mem.mem (uniform_space linarith.comp_source) has_emptyc.emptyc) : @complete_space.{0} linarith.comp_source (@multiset.inf.{0} (uniform_space.{0} linarith.comp_source) (@lattice.to_semilattice_inf.{0} (uniform_space.{0} linarith.comp_source) (@conditionally_complete_lattice.to_lattice.{0} (uniform_space.{0} linarith.comp_source) (@complete_lattice.to_conditionally_complete_lattice.{0} (uniform_space.{0} linarith.comp_source) (@uniform_space.complete_lattice.{0} linarith.comp_source)))) (@bounded_order.to_order_top.{0} (uniform_space.{0} linarith.comp_source) (@preorder.to_has_le.{0} (uniform_space.{0} linarith.comp_source) (@partial_order.to_preorder.{0} (uniform_space.{0} linarith.comp_source) (@semilattice_inf.to_partial_order.{0} (uniform_space.{0} linarith.comp_source) (@lattice.to_semilattice_inf.{0} (uniform_space.{0} linarith.comp_source) (@conditionally_complete_lattice.to_lattice.{0} (uniform_space.{0} linarith.comp_source) (@complete_lattice.to_conditionally_complete_lattice.{0} (uniform_space.{0} linarith.comp_source) (@uniform_space.complete_lattice.{0} linarith.comp_source))))))) (@complete_lattice.to_bounded_order.{0} (uniform_space.{0} linarith.comp_source) (@uniform_space.complete_lattice.{0} linarith.comp_source))) (@finset.pi.empty.{1 0} Type multiset.{0} (uniform_space.{0} linarith.comp_source) h0))  := sorry --non-trivial
lemma new_lemma_151074 (h0 : ring (random_gen (linear_ordered_add_comm_group linarith.ineq))) : strong_rank_condition (random_gen (linear_ordered_add_comm_group linarith.ineq)) := sorry --non-trivial
lemma new_lemma_151075 (h0 : topological_space (option (option pos))) : path_connected_space (option (option pos)) := sorry --non-trivial
lemma new_lemma_151076 (h0 : topological_space (normed_lattice_add_comm_group pos)) : normal_space (normed_lattice_add_comm_group pos) := sorry --non-trivial
lemma new_lemma_151077 (h0 : group (semiring (semiring num))) : group.fg (semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_151078 (h0 : function.extfun nat fin) : @normal_space.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_151079 (h0 : functor.add_const (ring (finset linarith.comp)) (has_zero Type)) : @is_principal_ideal_ring.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (finset.{0} linarith.comp)) (has_zero.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_151080 (h0 : functor.add_const (complete_lattice (canonically_ordered_comm_semiring ennreal)) unsigned) : @is_compactly_generated.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_ordered_comm_semiring.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_151081 (h0 : Type) (h1 : heq h0 (mul_zero_class unsigned)) (h2 : group h0) : @is_cyclic.{0} (mul_zero_class.{0} unsigned) (@heq.elim.{2 1} Type h0 group.{0} (mul_zero_class.{0} unsigned) h1 h2)  := sorry --non-trivial
lemma new_lemma_151082 (h0 : ring (with_bot (semiring unsigned))) : strong_rank_condition (with_bot (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_151083 (h0 : preorder (has_norm linarith.comp_source)) (h1 : set (has_norm linarith.comp_source)) : bdd_below h1 := sorry --non-trivial
lemma new_lemma_151084 (h0 : group (pseudo_metric_space (option (option congr_arg_kind)))) : normalizer_condition (pseudo_metric_space (option (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_151085 (h1 : uniform_space (semi_normed_ring (comm_ring char))) : complete_space (semi_normed_ring (comm_ring char)) := sorry --non-trivial
lemma new_lemma_151086 (h0 : topological_space (normed_group (has_norm (has_norm linarith.comp)))) : irreducible_space (normed_group (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_151087 (h0 : ring (has_neg (has_add pos))) : rank_condition (has_neg (has_add pos)) := sorry --non-trivial
lemma new_lemma_151088 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (complete_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (complete_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_151089 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_151090 (h0 : complete_lattice (fintype linarith.ineq)) : complete_lattice.is_Sup_finite_compact (fintype linarith.ineq) := sorry --non-trivial
lemma new_lemma_151091 (h0 : not (ring (denumerable string.iterator_imp) -> false)) : @is_domain.{0} (denumerable.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (ring.{0} (denumerable.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_151092 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_151093 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (preorder.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (preorder.{0} num))  := sorry --non-trivial
lemma new_lemma_151094 (h0 : fin has_zero.zero) : @path_connected_space.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_151095 (h0 : topological_space (has_nndist (has_to_string pos))) : normal_space (has_nndist (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_151096 (h0 : function.extfun Type group) : @is_cyclic.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_151097 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @rank_condition.{0} (has_Inf.{0} real) (@matrix.vec_empty.{0} (ring.{0} (has_Inf.{0} real)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_151098 (h0 : topological_space (has_top (random_gen to_additive.value_type))) : irreducible_space (has_top (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_151099 (h0 : filter (finset (has_add linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_151100 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @t1_space.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_151101 (h0 : functor.add_const (topological_space (has_nndist ennreal)) unsigned) : @t0_space.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_151102 (h0 : group (has_norm (semiring empty))) : group.fg (has_norm (semiring empty)) := sorry --non-trivial
lemma new_lemma_151103 (h0 : semiring (add_comm_semigroup ereal)) (h2 : add_comm_semigroup ereal) : even h2 := sorry --non-trivial
lemma new_lemma_151104 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_151105 (h0 : topological_space (normed_group (has_inv (denumerable linarith.comp_source)))) : irreducible_space (normed_group (has_inv (denumerable linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_151106 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_151107 (h0 : functor.add_const (complete_lattice (has_nndist linarith.comp)) (ring linarith.comp)) : @is_atomistic.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} linarith.comp)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_151108 (h0 : functor.add_const (topological_space (has_add pos)) (ring pos)) : @irreducible_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_151109 (h0 : topological_space (distrib (random_gen (mul_one_class (random_gen reducibility_hints))))) : t0_space (distrib (random_gen (mul_one_class (random_gen reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_151110 (h0 : functor.add_const (prod (semigroup empty) (semigroup empty)) num) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_151111 (h0 : functor.add_const (complete_lattice (has_to_string Type)) name) : @is_compactly_generated.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_to_string.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_151112 (h0 : has_mem.mem group has_emptyc.emptyc) : @normalizer_condition.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_151113 (h0 h2 : simple_graph enat) : simple_graph.is_subgraph h0 h2 := sorry --non-trivial
lemma new_lemma_151114 (h0 : ring (add_cancel_monoid (has_neg (finset Type)))) : is_principal_ideal_ring (add_cancel_monoid (has_neg (finset Type))) := sorry --non-trivial
lemma new_lemma_151115 (h0 : topological_space (add_comm_monoid (option (option congr_arg_kind)))) : locally_compact_space (add_comm_monoid (option (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_151116 (h0 : ring (nondiscrete_normed_field to_additive.value_type)) : is_domain (nondiscrete_normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_151117 (h0 : not (ring (normed_field reducibility_hints) -> false)) : @is_domain.{0} (normed_field.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (normed_field.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_151118 (h0 : filter (non_assoc_semiring (semiring (semiring congr_arg_kind)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_151119 (h0 : functor.add_const (group (comm_group name)) unsigned) : @group.fg.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_151120 (h0 : functor.add_const (functor.add_const (topological_space Type) name) linarith.comp) : @preconnected_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) name (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (topological_space.{1} Type) name) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_151121 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_151122 (h0 : functor.add_const (group (normed_linear_ordered_group empty)) unsigned) : @group.fg.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (normed_linear_ordered_group.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_151123 (h0 : filter (boolean_algebra.core (comm_group name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_151124 (h1 : list (normed_group fun_info)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_151125 (h0 : functor.comp topological_space complete_distrib_lattice Type) : @normal_space.{1} (complete_distrib_lattice.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} complete_distrib_lattice.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_151126 (h0 : functor.add_const (monoid (canonically_ordered_comm_semiring pos)) name) : @monoid.fg.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (canonically_ordered_comm_semiring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_151127 (h0 : complete_lattice (bin_tree (semiring empty))) : is_atomistic (bin_tree (semiring empty)) := sorry --non-trivial
lemma new_lemma_151128 (h0 : ordered_add_comm_monoid (free_add_monoid (option unsigned))) : archimedean (free_add_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_151129 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_151130 (h0 : semiring (left_cancel_monoid congr_arg_kind)) : is_noetherian_ring (left_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_151131 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @path_connected_space.{0} (comm_ring.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (comm_ring.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_151132 (h0 : topological_space (ordered_comm_ring pos)) : discrete_topology (ordered_comm_ring pos) := sorry --non-trivial
lemma new_lemma_151133 (h0 : fin has_zero.zero) : @t1_space.{0} pos (@matrix.vec_empty.{0} (topological_space.{0} pos) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_151134 (h0 : topological_space (add_cancel_monoid (finset linarith.comp))) : path_connected_space (add_cancel_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_151135 (h1 : set string.iterator_imp) : set.finite h1 := sorry --non-trivial
lemma new_lemma_151136 (h0 : not (group (plift congr_arg_kind) -> false)) : @is_cyclic.{1} (plift.{1} congr_arg_kind) (@classical.by_contradiction'.{2} (group.{1} (plift.{1} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_151137 (h0 : topological_space (mul_zero_class (finset ennreal))) : regular_space (mul_zero_class (finset ennreal)) := sorry --non-trivial
lemma new_lemma_151138 (h0 : not (topological_space (distrib fun_info) -> false)) : @totally_disconnected_space.{0} (distrib.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_151139 (h0 : functor.add_const (ring (option unsigned)) num) : @rank_condition.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (option.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_151140 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_151141 (h1 : ring (dlist to_additive.value_type)) : rank_condition (dlist to_additive.value_type) := sorry --non-trivial
lemma new_lemma_151142 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_151143 (h0 : not (has_mem.mem (measurable_space empty) has_emptyc.emptyc -> false)) : @add_group.fg.{0} (measurable_space.{0} empty) (@finset.pi.empty.{1 0} Type add_group.{0} (measurable_space.{0} empty) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} empty) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_151144 (h0 : topological_space (mul_zero_class (has_add ennreal))) : path_connected_space (mul_zero_class (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_151145 (h0 : ring (cancel_monoid (semigroup name))) : strong_rank_condition (cancel_monoid (semigroup name)) := sorry --non-trivial
lemma new_lemma_151146 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) Type) : @loc_path_connected_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (boolean_algebra.core.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_151147 (h0 : complete_lattice (has_div (has_lt (has_lt enat)))) : is_compactly_generated (has_div (has_lt (has_lt enat))) := sorry --non-trivial
lemma new_lemma_151148 (h0 : uniform_space (boolean_algebra (comm_semigroup (sub_neg_monoid real)))) : complete_space (boolean_algebra (comm_semigroup (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_151149 (h0 : topological_space (add_group (linear_ordered_semiring empty))) : totally_separated_space (add_group (linear_ordered_semiring empty)) := sorry --non-trivial
lemma new_lemma_151150 (h0 : function.extfun Type list) : list.nodup (id (function.extfun_app h0 (distrib_lattice to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_151151 (h0 : list (has_add (has_neg Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_151152 (h0 : fin has_zero.zero) : @preconnected_space.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_151153 (h0 : add_monoid (has_add (has_add name))) : add_monoid.fg (has_add (has_add name)) := sorry --non-trivial
lemma new_lemma_151154 (h0 : ordered_add_comm_monoid (option (option (option ennreal)))) : archimedean (option (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_151155 (h0 : not (uniform_space (comm_ring to_additive.value_type) -> false)) : @complete_space.{0} (comm_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (uniform_space.{0} (comm_ring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_151156 (h0 : topological_space (has_pos_part (boolean_algebra pos))) : totally_disconnected_space (has_pos_part (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_151157 (h0 : prod (has_neg linarith.ineq) (has_neg linarith.ineq)) : set.diagonal (has_neg linarith.ineq) h0 := sorry --non-trivial
lemma new_lemma_151158 (h0 : topological_space (semi_normed_comm_ring (has_ssubset (has_ssubset (has_ssubset linarith.ineq))))) : t0_space (semi_normed_comm_ring (has_ssubset (has_ssubset (has_ssubset linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_151159 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_151160 (h0 : ordered_comm_monoid (boolean_algebra.core (has_Inf (has_Inf (has_pos_part (has_pos_part pos)))))) : has_exists_mul_of_le (boolean_algebra.core (has_Inf (has_Inf (has_pos_part (has_pos_part pos))))) := sorry --non-trivial
lemma new_lemma_151161 (h0 : uniform_space (has_top (metric_space (random_gen num)))) : separated_space (has_top (metric_space (random_gen num))) := sorry --non-trivial
lemma new_lemma_151162 (h0 : functor.add_const (uniform_space (has_zero Type)) name) : @complete_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_zero.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_151163 (h0 : topological_space (ordered_ring num)) : topological_space.separable_space (ordered_ring num) := sorry --non-trivial
lemma new_lemma_151164 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) Type) : @discrete_topology.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_151165 (h0 : functor.add_const (topological_space (ring linarith.comp)) Type) : @loc_path_connected_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_151166 (h0 : functor.add_const Prop empty) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_151167 (h0 : topological_space (has_to_string (boolean_algebra name))) : topological_space.separable_space (has_to_string (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_151168 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (linear_ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_151169 (h1 : ring (has_ssubset (random_gen (random_gen reducibility_hints)))) : rank_condition (has_ssubset (random_gen (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_151170 (h0 : functor.add_const (ring (has_pos_part linarith.comp)) Type) : @strong_rank_condition.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (has_pos_part.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_151171 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (add_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (add_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_151172 (h0 : topological_space (is_R_or_C (option unsigned))) : t1_space (is_R_or_C (option unsigned)) := sorry --non-trivial
lemma new_lemma_151173 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_151174 (h0 : has_neg (has_nnnorm (mul_one_class fun_info))) (h1 : measurable_space (has_nnnorm (mul_one_class fun_info))) : has_measurable_neg (has_nnnorm (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_151175 (h0 : function.extfun nat fin) : @totally_separated_space.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (complete_distrib_lattice.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_151176 (h0 : complete_lattice (has_to_string (finset (has_neg (has_neg linarith.comp))))) : complete_lattice.is_Sup_finite_compact (has_to_string (finset (has_neg (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_151177 (h0 : topological_space (boolean_algebra (has_Inf (has_pos_part linarith.comp)))) : totally_separated_space (boolean_algebra (has_Inf (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_151178 (h0 : functor.add_const (ring (generalized_boolean_algebra pos)) linarith.comp) : @is_principal_ideal_ring.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (generalized_boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_151179 (h0 : uniform_space (has_union (semiring unsigned))) : separated_space (has_union (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_151180 (h0 : not (ring (has_ssubset string_imp) -> false)) : @rank_condition.{0} (has_ssubset.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_151181 (h0 : functor.add_const (topological_space (has_neg Type)) Type) : @topological_space.separable_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_neg.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_151182 (h4 : add_group (nondiscrete_normed_field reducibility_hints)) : is_add_cyclic (nondiscrete_normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_151183 (h0 : topological_space (semigroup (has_nndist name))) : t1_space (semigroup (has_nndist name)) := sorry --non-trivial
lemma new_lemma_151184 (h0 : ring (option (option (option (option ennreal))))) : rank_condition (option (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_151185 (h0 : has_mem.mem (with_bot (has_norm linarith.comp)) has_emptyc.emptyc) : @irreducible_space.{0} (with_bot.{0} (has_norm.{0} linarith.comp)) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} (has_norm.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_151186 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra.core linarith.comp)) Type) : @archimedean.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (boolean_algebra.core.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_151187 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) (has_add pos)) : @topological_space.separable_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_151188 (h0 : functor.add_const (topological_space (mul_zero_class unsigned)) num) : @locally_compact_space.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_151189 (h0 : fin has_zero.zero) : @topological_space.separable_space.{0} (complete_distrib_lattice.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_151190 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @loc_path_connected_space.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_151191 (h0 : filter (div_inv_monoid (comm_ring (has_ssubset linarith.ineq)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_151192 (h1 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_151193 (h0 : functor.add_const (ring (finset linarith.comp)) (has_neg linarith.comp)) : @is_principal_ideal_ring.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} linarith.comp)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_151194 (h0 : complete_lattice (canonically_ordered_comm_semiring (has_add (has_add Type)))) : is_compactly_generated (canonically_ordered_comm_semiring (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_151195 (h0 : ring (has_compl (has_nnnorm (has_nnnorm linarith.ineq)))) : strong_rank_condition (has_compl (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_151196 (h0 : add_group (random_gen (has_top unsigned))) : is_add_cyclic (random_gen (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_151197 (h0 : topological_space (mul_zero_class (finset pos))) : normal_space (mul_zero_class (finset pos)) := sorry --non-trivial
lemma new_lemma_151198 (h0 : function.extfun (Type 1) ordered_comm_monoid) : @has_exists_mul_of_le.{1} (plift.{1} linarith.comp) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} h0 (plift.{1} linarith.comp))  := sorry --non-trivial
lemma new_lemma_151199 (h0 : add_group (canonically_ordered_comm_semiring ennreal)) : is_add_cyclic (canonically_ordered_comm_semiring ennreal) := sorry --non-trivial
lemma new_lemma_151200 (h0 : measurable_space (add_comm_semigroup nnreal)) (h2 : measure_theory.measure (add_comm_semigroup nnreal)) : measure_theory.is_finite_measure h2 := sorry --non-trivial
lemma new_lemma_151201 (h0 : topological_space (add_cancel_monoid (has_add pos))) : t1_space (add_cancel_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_151202 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (linear_ordered_add_comm_group.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_ordered_add_comm_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_151203 (h0 : function.extfun Type group) : @is_cyclic.{0} (encodable.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (encodable.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_151204 (h0 : functor.add_const (group (generalized_boolean_algebra linarith.comp)) name) : @group.fg.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (generalized_boolean_algebra.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_151205 (h0 : set (has_neg environment.projection_info)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_151206 (h0 : topological_space (has_Sup (sub_neg_monoid (sub_neg_monoid pos)))) : preirreducible_space (has_Sup (sub_neg_monoid (sub_neg_monoid pos))) := sorry --non-trivial
lemma new_lemma_151207 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_151208 (h0 : functor.add_const (cancel_comm_monoid_with_zero ennreal) ennreal) : @unique_factorization_monoid.{0} ennreal (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} ennreal) ennreal h0)  := sorry --non-trivial
lemma new_lemma_151209 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) (has_add Type)) : @regular_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} unsigned)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_151210 (h0 : ring (distrib (has_nnnorm fun_info))) : rank_condition (distrib (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_151211 (h1 : ring (metric_space (denumerable to_additive.value_type))) : strong_rank_condition (metric_space (denumerable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_151212 (h0 : group (has_zero (has_add ennreal))) : is_simple_group (has_zero (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_151213 (h1 : ring (fintype to_additive.value_type)) : rank_condition (fintype to_additive.value_type) := sorry --non-trivial
lemma new_lemma_151214 (h0 : topological_space (normed_lattice_add_comm_group (has_add (sub_neg_monoid pos)))) : regular_space (normed_lattice_add_comm_group (has_add (sub_neg_monoid pos))) := sorry --non-trivial
lemma new_lemma_151215 (h0 : functor.add_const (topological_space (has_star num)) unsigned) : @totally_disconnected_space.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_151216 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @complete_lattice.is_Sup_finite_compact.{0} to_additive.value_type (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_151217 (h0 : functor.add_const (topological_space (complete_distrib_lattice linarith.comp)) Type) : @sequential_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_151218 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (with_zero.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} h0 (with_zero.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_151219 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) environment.implicit_infer_kind) : @irreducible_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_151220 (h0 : ring (distrib (measure_theory.measure_space name))) : is_domain (distrib (measure_theory.measure_space name)) := sorry --non-trivial
lemma new_lemma_151221 (h1 : ring (distrib_lattice (random_gen (random_gen char)))) : is_domain (distrib_lattice (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_151222 (h0 : topological_space (canonically_linear_ordered_monoid (finset name))) : totally_disconnected_space (canonically_linear_ordered_monoid (finset name)) := sorry --non-trivial
lemma new_lemma_151223 (h0 : topological_space (add_comm_monoid (has_neg_part (has_neg_part (has_add Type))))) : regular_space (add_comm_monoid (has_neg_part (has_neg_part (has_add Type)))) := sorry --non-trivial
lemma new_lemma_151224 (h0 : not (filter (partial_order congr_arg_kind) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_151225 (h0 : has_mem.mem (function.extfun Type) has_emptyc.emptyc) : @is_compactly_generated.{0} fun_info (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) h0) complete_lattice.{0}) fun_info)  := sorry --non-trivial
lemma new_lemma_151226 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system empty)) congr_arg_kind) : @t1_space.{0} (measurable_space.dynkin_system.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_151227 (h5 : complete_lattice (nondiscrete_normed_field environment.projection_info)) : complete_lattice.is_Sup_finite_compact (nondiscrete_normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_151228 (h0 : cancel_comm_monoid_with_zero (generalized_boolean_algebra (ring (ordered_ring linarith.comp)))) : unique_factorization_monoid (generalized_boolean_algebra (ring (ordered_ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_151229 (h0 : topological_space (add_cancel_monoid (ring (has_add (ring (finset linarith.comp)))))) : t0_space (add_cancel_monoid (ring (has_add (ring (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_151230 (h3 : topological_space (comm_ring to_additive.value_type)) : t0_space (comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_151231 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_151232 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (normed_group.{0} string_imp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (normed_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_151233 (h0 : ring (ring (has_add Type))) : strong_rank_condition (ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_151234 (h0 : complete_lattice (normed_comm_ring environment.implicit_infer_kind)) : is_atomistic (normed_comm_ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_151235 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (comm_semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (comm_semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_151236 (h0 : not (filter (add_monoid fun_info) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_151237 (h0 : topological_space (has_one (semiring (semiring (semiring (has_norm empty)))))) : discrete_topology (has_one (semiring (semiring (semiring (has_norm empty))))) := sorry --non-trivial
lemma new_lemma_151238 (h1 : function.extfun Type ring) : @is_domain.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h1 (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_151239 (h1 : complete_lattice (linear_ordered_add_comm_group (has_ssubset linarith.ineq))) : is_compactly_generated (linear_ordered_add_comm_group (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_151240 (h0 : ring (boolean_algebra (ring (ring Type)))) : is_domain (boolean_algebra (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_151241 (h0 : function.extfun Type topological_space) : @normal_space.{0} (ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} num))  := sorry --non-trivial
lemma new_lemma_151242 (h0 : topological_space (has_add pos)) : loc_path_connected_space (has_add pos) := sorry --non-trivial
lemma new_lemma_151243 (h0 : add_group (has_norm (has_top fun_info))) : is_add_cyclic (has_norm (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_151244 (h0 : topological_space (has_bot linarith.comp)) : totally_disconnected_space (has_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_151245 (h0 : functor.add_const (finset (has_zero Type)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_151246 (h0 : topological_space (has_neg_part (option ennreal))) : totally_separated_space (has_neg_part (option ennreal)) := sorry --non-trivial
lemma new_lemma_151247 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (add_right_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (add_right_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_151248 (h0 : functor.add_const (topological_space (has_neg name)) name) : @preirreducible_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_151249 (h1 : complete_lattice (distrib (mul_one_class char))) : is_compactly_generated (distrib (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_151250 (h0 : group (generalized_boolean_algebra (sub_neg_monoid (has_neg Type)))) : is_cyclic (generalized_boolean_algebra (sub_neg_monoid (has_neg Type))) := sorry --non-trivial
lemma new_lemma_151251 (h0 : add_monoid (ordered_ring (semiring congr_arg_kind))) : add_monoid.fg (ordered_ring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_151252 (h0 : topological_space (comm_group (has_to_string ennreal))) : loc_path_connected_space (comm_group (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_151253 (h0 : topological_space (encodable (has_ssubset (has_ssubset string_imp)))) : path_connected_space (encodable (has_ssubset (has_ssubset string_imp))) := sorry --non-trivial
lemma new_lemma_151254 (h0 : function.extfun (Type 1) ring) : @is_principal_ideal_ring.{1} (normed_lattice_add_comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (normed_lattice_add_comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_151255 (h1 : topological_space (has_nnnorm std_gen)) : totally_disconnected_space (has_nnnorm std_gen) := sorry --non-trivial
lemma new_lemma_151256 (h0 : topological_space (normed_lattice_add_comm_group (has_add real))) : t1_space (normed_lattice_add_comm_group (has_add real)) := sorry --non-trivial
lemma new_lemma_151257 (h0 : topological_space (ordered_comm_monoid (has_Inf name))) : sequential_space (ordered_comm_monoid (has_Inf name)) := sorry --non-trivial
lemma new_lemma_151258 (h0 : functor.add_const (topological_space (mul_zero_class empty)) num) : @t0_space.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_151259 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (as_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (as_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_151260 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @group.fg.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_151261 (h0 : topological_space (boolean_algebra (has_pos_part pos))) : totally_disconnected_space (boolean_algebra (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_151262 (h0 : monoid (semigroup (has_pos_part (has_pos_part linarith.comp)))) : monoid.fg (semigroup (has_pos_part (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_151263 (h0 : filter (add_comm_monoid environment.implicit_infer_kind)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_151264 (h0 : topological_space (normed_field string.iterator_imp)) : path_connected_space (normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_151265 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @path_connected_space.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero))) (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_151266 (h0 : topological_space (add_comm_monoid Type)) : loc_path_connected_space (add_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_151267 (h0 : functor.add_const (group (has_neg_part environment.implicit_infer_kind)) linarith.comp) : @is_simple_group.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_neg_part.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_151268 (h0 : functor.add_const (topological_space (has_zero unsigned)) environment.implicit_infer_kind) : @topological_space.separable_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_151269 (h0 : not (topological_space (filter.countable_filter_basis to_additive.value_type) -> false)) : @locally_compact_space.{0} (filter.countable_filter_basis.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (filter.countable_filter_basis.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_151270 (h1 : ring (nondiscrete_normed_field ereal)) : is_domain (nondiscrete_normed_field ereal) := sorry --non-trivial
lemma new_lemma_151271 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_151272 (h0 : topological_space (has_norm empty)) : totally_separated_space (has_norm empty) := sorry --non-trivial
lemma new_lemma_151273 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_Inf.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_Inf.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_151274 (h0 : functor.add_const (ring (as_linear_order empty)) empty) : @rank_condition.{0} (as_linear_order.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (as_linear_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_151275 (h0 : option (function.extfun Type uniform_space)) (h1 : function.extfun Type uniform_space) : @complete_space.{0} (left_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@option.get_or_else.{1} (function.extfun.{2 1} Type uniform_space.{0}) h0 h1) (left_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_151276 (h0 : functor.add_const (function.extfun (Type 1) group) environment.implicit_infer_kind) : @normalizer_condition.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) environment.implicit_infer_kind h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_151277 (h0 : functor.add_const (function.extfun Type ring) pos) : @strong_rank_condition.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_151278 (h0 : add_group (has_nnnorm (normed_field linarith.ineq))) : is_add_cyclic (has_nnnorm (normed_field linarith.ineq)) := sorry --non-trivial
lemma new_lemma_151279 (h1 : uniform_space (has_norm (random_gen (random_gen to_additive.value_type)))) : complete_space (has_norm (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_151280 (h1 : uniform_space (random_gen string_imp)) : complete_space (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_151281 (h3 : preorder ereal) (h4 : set ereal) : set.is_pwo h4 := sorry --non-trivial
lemma new_lemma_151282 (h0 : empty -> empty -> Prop) : is_strict_order empty h0 := sorry --non-trivial
lemma new_lemma_151283 (h0 : group (metric_space (has_norm linarith.comp))) : group.fg (metric_space (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_151284 (h0 : ring (denumerable (has_nnnorm linarith.ineq))) : rank_condition (denumerable (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_151285 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (comm_semigroup.{0} (sub_neg_monoid.{0} linarith.comp)) (@matrix.vec_empty.{0} (add_group.{0} (comm_semigroup.{0} (sub_neg_monoid.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_151286 (h0 : topological_space (simple_graph (option (option empty)))) : totally_disconnected_space (simple_graph (option (option empty))) := sorry --non-trivial
lemma new_lemma_151287 (h0 : topological_space (generalized_boolean_algebra (finset pos))) : t0_space (generalized_boolean_algebra (finset pos)) := sorry --non-trivial
lemma new_lemma_151288 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) linarith.comp) : @t1_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_151289 (h0 : not (complete_lattice (distrib_lattice fun_info) -> false)) : @is_compactly_generated.{0} (distrib_lattice.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (distrib_lattice.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_151290 (h0 : topological_space (semigroup (option unsigned))) : regular_space (semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_151291 (h0 : ring (add_right_cancel_monoid congr_arg_kind)) : is_domain (add_right_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_151292 (h0 : group (metric_space (semiring (semiring num)))) : is_cyclic (metric_space (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_151293 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_151294 (h0 : add_monoid (has_nndist (ring (finset (mul_one_class (finset (has_neg Type))))))) : add_monoid.fg (has_nndist (ring (finset (mul_one_class (finset (has_neg Type)))))) := sorry --non-trivial
lemma new_lemma_151295 (h0 : list (has_to_string unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_151296 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @loc_path_connected_space.{1} (sub_neg_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (sub_neg_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_151297 (h0 : complete_lattice (has_nndist (has_neg ennreal))) : is_atomistic (has_nndist (has_neg ennreal)) := sorry --non-trivial
lemma new_lemma_151298 (h0 : topological_space (linear_ordered_field ennreal)) : locally_compact_space (linear_ordered_field ennreal) := sorry --non-trivial
lemma new_lemma_151299 (h0 : functor.add_const (topological_space (bin_tree num)) num) : @totally_separated_space.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_151300 (h0 : add_group (topological_space fun_info)) : is_add_cyclic (topological_space fun_info) := sorry --non-trivial
lemma new_lemma_151301 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) pos) : @topological_space.separable_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_151302 (h0 : ring (linear_ordered_comm_group_with_zero (mul_one_class char))) : strong_rank_condition (linear_ordered_comm_group_with_zero (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_151303 (h0 : topological_space (metric_space (has_nnnorm to_additive.value_type))) : path_connected_space (metric_space (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_151304 (h0 : filter (finset num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_151305 (h0 : topological_space (monoid congr_arg_kind)) : normal_space (monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_151306 (h0 : functor.add_const (finset (has_to_string Type)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_151307 (h0 : functor.add_const (ring (mul_zero_class num)) (semiring (semiring num))) : @rank_condition.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} num)) (semiring.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_151308 (h0 : list (has_Sup empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_151309 (h0 : filter (filter (semiring (semiring (semiring (semiring (semiring (semiring num)))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_151310 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_inv.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_inv.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_151311 (h0 : monoid (has_union congr_arg_kind)) : monoid.fg (has_union congr_arg_kind) := sorry --non-trivial
lemma new_lemma_151312 (h0 : set (semi_normed_ring char)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_151313 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_151314 (h0 : not (add_group (normed_field to_additive.value_type) -> false)) : @is_add_cyclic.{0} (normed_field.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (add_group.{0} (normed_field.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_151315 (h0 : group (ordered_comm_group (option empty))) : group.fg (ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_151316 (h0 : ring (has_nnnorm (mul_one_class char))) : strong_rank_condition (has_nnnorm (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_151317 (h0 : uniform_space (add_monoid enat)) : complete_space (add_monoid enat) := sorry --non-trivial
lemma new_lemma_151318 (h0 : functor.add_const (filter (add_cancel_monoid linarith.comp)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_151319 (h0 : functor.add_const (ring (has_nndist environment.implicit_infer_kind)) environment.implicit_infer_kind) : @is_domain.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_151320 (h0 : functor.add_const (uniform_space (boolean_algebra.core name)) name) : @separated_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.core.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_151321 (h0 : functor.add_const (topological_space (has_neg_part name)) unsigned) : @regular_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_151322 (h0 : functor.add_const (complete_lattice (has_zero name)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_zero.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_151323 (h0 : function.extfun nat fin) : @rank_condition.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (has_bot.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_151324 (h0 : function.extfun Type (functor.add_const (complete_lattice (left_cancel_monoid unsigned)))) : @is_compactly_generated.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_151325 (h0 : topological_space (nondiscrete_normed_field (add_comm_semigroup enat))) (h1 : set (nondiscrete_normed_field (add_comm_semigroup enat))) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_151326 (h0 : ordered_comm_monoid (add_comm_monoid (ring (finset (finset (has_nndist linarith.comp)))))) : has_exists_mul_of_le (add_comm_monoid (ring (finset (finset (has_nndist linarith.comp))))) := sorry --non-trivial
lemma new_lemma_151327 (h0 : topological_space (complete_distrib_lattice (finset linarith.comp))) : loc_path_connected_space (complete_distrib_lattice (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_151328 (h0 : topological_space (has_dist (comm_monoid (comm_monoid unsigned)))) : preirreducible_space (has_dist (comm_monoid (comm_monoid unsigned))) := sorry --non-trivial
lemma new_lemma_151329 (h0 : group (has_Inf (finset pos))) : is_cyclic (has_Inf (finset pos)) := sorry --non-trivial
lemma new_lemma_151330 (h0 : ring (linear_ordered_comm_group_with_zero linarith.ineq)) : rank_condition (linear_ordered_comm_group_with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_151331 (h0 : functor.add_const (ordered_comm_monoid (mul_zero_class name)) (has_neg_part name)) : @has_exists_mul_of_le.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (mul_zero_class.{0} name)) (has_neg_part.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_151332 (h0 : not (ring congr_arg_kind -> false)) : @strong_rank_condition.{0} congr_arg_kind (@classical.by_contradiction'.{1} (ring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_151333 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_151334 (h0 : functor.add_const (uniform_space (simple_graph linarith.comp)) pos) : @complete_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (simple_graph.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_151335 (h1 : topological_space (semi_normed_ring reducibility_hints)) : path_connected_space (semi_normed_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_151336 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_151337 (h0 : function.extfun Type group) : @is_cyclic.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_151338 (h0 : ring (with_bot num)) : is_domain (with_bot num) := sorry --non-trivial
lemma new_lemma_151339 (h0 : uniform_space (ordered_comm_ring (has_neg (has_neg (has_neg pos))))) : separated_space (ordered_comm_ring (has_neg (has_neg (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_151340 (h0 : not (ring (has_compl char) -> false)) : @is_domain.{0} (has_compl.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_151341 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_151342 (h0 : functor.add_const (ordered_comm_monoid (complete_distrib_lattice Type)) pos) : @has_exists_mul_of_le.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (complete_distrib_lattice.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_151343 (h0 : functor.add_const (filter (linear_order empty)) empty) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_151344 (h0 : functor.add_const (group (finset real)) Type) : @group.fg.{0} (finset.{0} real) (@functor.add_const.run.{0 1} (group.{0} (finset.{0} real)) Type h0)  := sorry --non-trivial
lemma new_lemma_151345 (h0 : topological_space (has_top (has_top (random_gen linarith.comp_source)))) : t0_space (has_top (has_top (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_151346 (h0 : list (filter Prop)) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@id.{1} (filter.{0} Prop) (@id.{1} (filter.{0} Prop) (@id.{1} (filter.{0} Prop) (@list.head.{0} (filter.{0} Prop) (@filter.inhabited.{0} Prop) h0))))  := sorry --non-trivial
lemma new_lemma_151347 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (complete_distrib_lattice.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_distrib_lattice.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_151348 (h0 : function.extfun Type group) : @group.fg.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_151349 (h0 : add_monoid (ordered_ring congr_arg_kind)) : add_monoid.fg (ordered_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_151350 (h0 : not (ring (left_cancel_semigroup unsigned) -> false)) : @strong_rank_condition.{0} (left_cancel_semigroup.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (left_cancel_semigroup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_151351 (h0 : has_mem.mem linarith.comp_source has_emptyc.emptyc) : @discrete_topology.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type topological_space.{0} linarith.comp_source h0)  := sorry --non-trivial
lemma new_lemma_151352 (h0 : not (uniform_space unsigned -> false)) : @complete_space.{0} unsigned (@classical.by_contradiction'.{1} (uniform_space.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_151353 (h0 : functor.add_const (filter (add_comm_monoid pos)) (has_to_string environment.implicit_infer_kind)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_151354 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (option.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (option.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_151355 (h0 : topological_space (complete_distrib_lattice Type)) : topological_space.separable_space (complete_distrib_lattice Type) := sorry --non-trivial
lemma new_lemma_151356 (h0 h1 : multiset (has_lt enat)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_151357 (h0 : functor.add_const (uniform_space (has_add linarith.comp)) (finset linarith.comp)) : @complete_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_add.{0} linarith.comp)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_151358 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_151359 (h0 : fin has_zero.zero) : @t0_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_151360 (h0 : function.extfun Type (functor.comp topological_space has_neg_part)) : @sequential_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_neg_part.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_151361 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) (ring pos)) : @unique_factorization_monoid.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) (ring.{0} pos) h0) (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_151362 (h0 : complete_lattice (has_to_string (has_add Type))) : complete_lattice.is_Sup_finite_compact (has_to_string (has_add Type)) := sorry --non-trivial
lemma new_lemma_151363 (h0 : topological_space (has_neg_part (has_add ennreal))) : regular_space (has_neg_part (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_151364 (h0 : ring (has_append (has_nnnorm (has_nnnorm char)))) : rank_condition (has_append (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_151365 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (filter.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (filter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_151366 (h1 : uniform_space (denumerable to_additive.value_type)) : complete_space (denumerable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_151367 (h0 : not (add_group (measurable_space linarith.comp) -> false)) : @is_add_cyclic.{0} (measurable_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (add_group.{0} (measurable_space.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_151368 (h0 : functor.add_const (topological_space (add_comm_monoid name)) pos) : @t1_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_151369 (h0 : fin has_zero.zero) : @t1_space.{0} (has_pos_part.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_pos_part.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_151370 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @normal_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_151371 (h0 : topological_space (preorder linarith.ineq)) : t0_space (preorder linarith.ineq) := sorry --non-trivial
lemma new_lemma_151372 (h0 : topological_space (with_bot empty)) : preirreducible_space (with_bot empty) := sorry --non-trivial
lemma new_lemma_151373 (h0 : ring (random_gen (ordered_cancel_add_comm_monoid to_additive.value_type))) : is_domain (random_gen (ordered_cancel_add_comm_monoid to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_151374 (h0 : topological_space (ring (has_add ordering))) : discrete_topology (ring (has_add ordering)) := sorry --non-trivial
lemma new_lemma_151375 (h0 : ring (denumerable (has_inv linarith.ineq))) : is_domain (denumerable (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_151376 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_151377 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_151378 (h0 : topological_space (add_group num)) : normal_space (add_group num) := sorry --non-trivial
lemma new_lemma_151379 (h0 : functor.add_const (monoid (boolean_algebra linarith.comp)) name) : @monoid.fg.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (boolean_algebra.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_151380 (h0 : filter (has_one (has_norm (semiring linarith.comp)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_151381 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_151382 (h1 : topological_space (distrib to_additive.value_type)) : t0_space (distrib to_additive.value_type) := sorry --non-trivial
lemma new_lemma_151383 (h0 : topological_space (comm_monoid empty)) : locally_compact_space (comm_monoid empty) := sorry --non-trivial
lemma new_lemma_151384 (h0 : topological_space name) : totally_separated_space name := sorry --non-trivial
lemma new_lemma_151385 (h0 : group (boolean_algebra (comm_group unsigned))) : normalizer_condition (boolean_algebra (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_151386 (h0 : topological_space (comm_semigroup (has_pos_part real))) : sequential_space (comm_semigroup (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_151387 (h0 : group (boolean_algebra (has_add (has_to_string linarith.comp)))) : is_simple_group (boolean_algebra (has_add (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_151388 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_151389 (h0 : not (add_group (non_unital_non_assoc_semiring string_imp) -> false)) : @is_add_cyclic.{0} (non_unital_non_assoc_semiring.{0} string_imp) (@classical.by_contradiction'.{1} (add_group.{0} (non_unital_non_assoc_semiring.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_151390 (h0 : topological_space (complete_distrib_lattice (option (option empty)))) : totally_disconnected_space (complete_distrib_lattice (option (option empty))) := sorry --non-trivial
lemma new_lemma_151391 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @irreducible_space.{0} (boolean_algebra.{0} (ring.{0} linarith.comp)) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.{0} (ring.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_151392 (h0 : functor.add_const (function.extfun (Type 1) group) name) : @is_simple_group.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) name h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_151393 (h0 : function.extfun Type (functor.add_const (fin has_zero.zero))) : matrix.vec_empty (functor.add_const.run (function.extfun_app h0 congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_151394 (h0 : uniform_space (measurable_space (has_top congr_arg_kind))) : separated_space (measurable_space (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_151395 (h0 : function.extfun (finset Type) (has_mem.mem empty)) : separated_space empty := sorry --non-trivial
lemma new_lemma_151396 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_151397 (h1 : function.extfun (finset Type) (has_mem.mem (with_bot num))) : @locally_compact_space.{0} (with_bot.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} num)) h1 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_151398 (h0 : complete_lattice (linear_ordered_semiring congr_arg_kind)) : is_compactly_generated (linear_ordered_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_151399 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} h0 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_151400 (h0 : function.extfun Type ring) : @rank_condition.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_151401 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) pos) : @preconnected_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_151402 (h0 : group (mul_zero_class unsigned)) : group.fg (mul_zero_class unsigned) := sorry --non-trivial
lemma new_lemma_151403 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) pos) : @discrete_topology.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_151404 (h0 : topological_space (ordered_comm_monoid (has_Inf (sub_neg_monoid real)))) : irreducible_space (ordered_comm_monoid (has_Inf (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_151405 (h0 : topological_space (with_one (has_ssubset linarith.comp_source))) : totally_disconnected_space (with_one (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_151406 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_ordered_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_151407 (h0 : fin has_zero.zero) : @complete_space.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (canonically_ordered_monoid.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_151408 (h0 : monoid (add_comm_monoid (has_neg pos))) : monoid.fg (add_comm_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_151409 (h0 : functor.add_const (group (add_cancel_monoid name)) environment.implicit_infer_kind) : @is_cyclic.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_151410 (h0 : topological_space (add_comm_monoid (finset environment.implicit_infer_kind))) : discrete_topology (add_comm_monoid (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_151411 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (bin_tree.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_151412 (h0 : functor.add_const (functor.add_const (list (free_add_monoid empty)) num) congr_arg_kind) : list.nodup (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_151413 (h0 : ring (has_mul char)) : is_domain (has_mul char) := sorry --non-trivial
lemma new_lemma_151414 (h1 : ring (div_inv_monoid char)) : is_domain (div_inv_monoid char) := sorry --non-trivial
lemma new_lemma_151415 (h0 : complete_lattice (dlist (random_gen to_additive.value_type))) : is_compactly_generated (dlist (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_151416 (h0 : monoid (sub_neg_monoid real)) : monoid.fg (sub_neg_monoid real) := sorry --non-trivial
lemma new_lemma_151417 (h0 : function.extfun Type group) : @group.fg.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_151418 (h1 : not (ring (semi_normed_ring char) -> false)) : @strong_rank_condition.{0} (semi_normed_ring.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_ring.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_151419 (h0 : functor.add_const (list (ordered_comm_ring linarith.comp)) (finset Type)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_151420 (h0 : function.extfun nat fin) : @group.fg.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (group.{1} (canonically_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_151421 (h0 : topological_space (dlist (has_nnnorm (random_gen linarith.ineq)))) : t0_space (dlist (has_nnnorm (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_151422 (h0 : not (add_group (non_unital_non_assoc_semiring char) -> false)) : @is_add_cyclic.{0} (non_unital_non_assoc_semiring.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (non_unital_non_assoc_semiring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_151423 (h0 : has_mem.mem (linear_ordered_semiring (random_gen num)) has_emptyc.emptyc) : @separated_space.{0} (linear_ordered_semiring.{0} (random_gen.{0} num)) (@finset.pi.empty.{1 0} Type uniform_space.{0} (linear_ordered_semiring.{0} (random_gen.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_151424 (h0 : ring (simple_graph (mul_one_class std_gen))) : rank_condition (simple_graph (mul_one_class std_gen)) := sorry --non-trivial
lemma new_lemma_151425 (h0 : complete_lattice (distrib (mul_one_class linarith.comp_source))) : is_compactly_generated (distrib (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_151426 (h0 : list (option (semiring empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_151427 (h0 : topological_space (ordered_comm_ring real)) : discrete_topology (ordered_comm_ring real) := sorry --non-trivial
lemma new_lemma_151428 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_neg.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_151429 (h0 : list (mul_zero_class (has_add name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_151430 (h0 : ring (measure_theory.measure_space (semiring congr_arg_kind))) : is_principal_ideal_ring (measure_theory.measure_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_151431 (h0 : functor.add_const (topological_space (option ennreal)) pos) : @regular_space.{0} (option.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_151432 (h0 : not (complete_lattice (linear_ordered_comm_ring congr_arg_kind) -> false)) : @is_atomistic.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_comm_ring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_151433 (h0 : functor.add_const (topological_space (generalized_boolean_algebra Type)) linarith.comp) : @totally_separated_space.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_151434 (h0 : functor.add_const (topological_space (has_zero name)) Type) : @loc_path_connected_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_151435 (h0 : ring string) : rank_condition string := sorry --non-trivial
lemma new_lemma_151436 (h0 : ring (uniform_space (mul_one_class (mul_one_class reducibility_hints)))) : rank_condition (uniform_space (mul_one_class (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_151437 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_151438 (h0 : list (measurable_space (has_top linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_151439 (h0 : not (has_mem.mem (semiring linarith.comp_source) has_emptyc.emptyc -> false)) : @is_domain.{0} (semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_151440 (h0 : topological_space (has_top empty)) : topological_space.separable_space (has_top empty) := sorry --non-trivial
lemma new_lemma_151441 (h0 : ring (has_Inf (ring (ring (has_Inf linarith.comp))))) : strong_rank_condition (has_Inf (ring (ring (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_151442 (h0 : topological_space (measurable_space.dynkin_system (semiring (semiring empty)))) : discrete_topology (measurable_space.dynkin_system (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_151443 (h0 : functor.add_const (add_monoid (ordered_comm_monoid Type)) Type) : @add_monoid.fg.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (add_monoid.{1} (ordered_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_151444 (h0 : topological_space (has_nndist (finset environment.implicit_infer_kind))) : irreducible_space (has_nndist (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_151445 (h0 : function.extfun (Type 1) topological_space) : @irreducible_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_151446 (h0 : functor.add_const (semiring (bin_tree empty)) congr_arg_kind) : @is_noetherian_ring.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (bin_tree.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_151447 (h0 : monoid (complete_semilattice_Sup (random_gen congr_arg_kind))) : monoid.fg (complete_semilattice_Sup (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_151448 (h0 : group (has_Sup (option empty))) : normalizer_condition (has_Sup (option empty)) := sorry --non-trivial
lemma new_lemma_151449 (h0 : topological_space (ring (ring environment.implicit_infer_kind))) : t0_space (ring (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_151450 (h0 : functor.add_const (complete_lattice (semigroup environment.implicit_infer_kind)) linarith.comp) : @is_atomistic.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_151451 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} unsigned (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) unsigned)  := sorry --non-trivial
lemma new_lemma_151452 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_151453 (h0 : semiring (normed_comm_ring (option (cancel_monoid unsigned)))) : is_noetherian_ring (normed_comm_ring (option (cancel_monoid unsigned))) := sorry --non-trivial
lemma new_lemma_151454 (h2 : topological_space (has_lt to_additive.value_type)) : path_connected_space (has_lt to_additive.value_type) := sorry --non-trivial
lemma new_lemma_151455 (h0 : has_neg (option pos) -> has_neg (option pos) -> Prop) : is_symm (has_neg (option pos)) h0 := sorry --non-trivial
lemma new_lemma_151456 (h1 h2 : multiset (has_div linarith.comp_source)) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_151457 (h0 : complete_lattice (denumerable (random_gen to_additive.value_type))) : is_compactly_generated (denumerable (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_151458 (h0 : functor.comp topological_space add_cancel_monoid ennreal) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_151459 (h0 : list (measurable_space (random_gen (random_gen linarith.comp_source)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_151460 (h0 : ring (has_norm (random_gen string_imp))) : is_domain (has_norm (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_151461 (h0 : topological_space (complete_distrib_lattice (has_add pos))) : discrete_topology (complete_distrib_lattice (has_add pos)) := sorry --non-trivial
lemma new_lemma_151462 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_151463 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_151464 (h0 : topological_space (has_bot real)) : loc_path_connected_space (has_bot real) := sorry --non-trivial
lemma new_lemma_151465 (h0 : add_group (has_lt string.iterator_imp)) : is_add_cyclic (has_lt string.iterator_imp) := sorry --non-trivial
lemma new_lemma_151466 (h0 : functor.add_const (monoid (ring linarith.comp)) linarith.comp) : @monoid.fg.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_151467 (h0 : functor.add_const (topological_space (has_star num)) num) : @t0_space.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_151468 (h0 : ring (has_vadd fun_info ereal)) : strong_rank_condition (has_vadd fun_info ereal) := sorry --non-trivial
lemma new_lemma_151469 (h0 : has_mem.mem (has_emptyc num) has_emptyc.emptyc) : @strong_rank_condition.{0} (has_emptyc.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (has_emptyc.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_151470 (h0 : functor.add_const (topological_space (left_cancel_semigroup empty)) empty) : @topological_space.separable_space.{0} (left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_151471 (h0 : filter (has_nndist congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_151472 (h0 : complete_lattice (mul_zero_class (has_neg_part (finset (finset ennreal))))) : is_atomistic (mul_zero_class (has_neg_part (finset (finset ennreal)))) := sorry --non-trivial
lemma new_lemma_151473 (h0 : functor.add_const (add_monoid (ordered_ring num)) num) : @add_monoid.fg.{0} (ordered_ring.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (ordered_ring.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_151474 (h0 : topological_space (finset (finset Type))) : path_connected_space (finset (finset Type)) := sorry --non-trivial
lemma new_lemma_151475 (h0 : topological_space (linear_ordered_comm_ring (semiring congr_arg_kind))) : topological_space.separable_space (linear_ordered_comm_ring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_151476 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_151477 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (comm_semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_151478 (h0 : ring (has_sdiff environment.projection_info)) : strong_rank_condition (has_sdiff environment.projection_info) := sorry --non-trivial
lemma new_lemma_151479 (h2 : group linarith.comp_source) : group.fg linarith.comp_source := sorry --non-trivial
lemma new_lemma_151480 (h0 : topological_space (add_comm_monoid (option (option (option (option ennreal)))))) : totally_separated_space (add_comm_monoid (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_151481 (h0 : complete_lattice (left_cancel_semigroup empty)) : is_atomistic (left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_151482 (h0 : uniform_space (has_Inf real)) : complete_space (has_Inf real) := sorry --non-trivial
lemma new_lemma_151483 (h0 : uniform_space (has_sub (semiring unsigned))) : complete_space (has_sub (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_151484 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (simple_graph.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} empty))  := sorry --non-trivial
lemma new_lemma_151485 (h0 : add_group (distrib (has_ssubset (has_ssubset char)))) : is_add_cyclic (distrib (has_ssubset (has_ssubset char))) := sorry --non-trivial
lemma new_lemma_151486 (h0 : functor.add_const (ring (has_Inf pos)) (has_neg name)) : @is_domain.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_Inf.{0} pos)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_151487 (h0 : ordered_add_comm_monoid (finset ennreal)) : archimedean (finset ennreal) := sorry --non-trivial
lemma new_lemma_151488 (h0 : functor.add_const (topological_space (boolean_algebra pos)) name) : @irreducible_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_151489 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_151490 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (semigroup.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_151491 (h0 : ring (boolean_algebra (comm_group (comm_group Type)))) : is_domain (boolean_algebra (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_151492 (h0 : function.extfun (finset Type) (has_mem.mem (semiring num))) : @rank_condition.{0} (semiring.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_151493 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (is_R_or_C.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (is_R_or_C.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_151494 (h0 : topological_space (has_lt environment.projection_info)) : t0_space (has_lt environment.projection_info) := sorry --non-trivial
lemma new_lemma_151495 (h1 : topological_space (denumerable (random_gen char))) : path_connected_space (denumerable (random_gen char)) := sorry --non-trivial
lemma new_lemma_151496 (h0 : topological_space (normed_group (add_left_cancel_monoid (has_ssubset fun_info)))) : path_connected_space (normed_group (add_left_cancel_monoid (has_ssubset fun_info))) := sorry --non-trivial
lemma new_lemma_151497 (h2 : ring (linear_ordered_comm_group_with_zero to_additive.value_type)) : strong_rank_condition (linear_ordered_comm_group_with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_151498 (h0 : topological_space (mul_zero_class (has_add name))) : regular_space (mul_zero_class (has_add name)) := sorry --non-trivial
lemma new_lemma_151499 (h0 : topological_space (finset (has_add pos))) : preirreducible_space (finset (has_add pos)) := sorry --non-trivial
lemma new_lemma_151500 (h0 : add_group (comm_ring to_additive.value_type)) : is_add_cyclic (comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_151501 (h0 : set (has_top (mul_one_class char))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_151502 (h0 : function.extfun Type topological_space) : @t0_space.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_151503 (h0 : topological_space (finset (has_neg (finset pos)))) : loc_path_connected_space (finset (has_neg (finset pos))) := sorry --non-trivial
lemma new_lemma_151504 (h0 : complete_lattice (left_cancel_semigroup (semiring num))) : is_atomistic (left_cancel_semigroup (semiring num)) := sorry --non-trivial
lemma new_lemma_151505 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_151506 (h0 : functor.add_const (filter (add_cancel_monoid environment.implicit_infer_kind)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_151507 (h0 : functor.add_const (topological_space (finset Type)) (ring name)) : @sequential_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_151508 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_151509 (h0 : add_group (has_add linarith.comp_source)) : is_add_cyclic (has_add linarith.comp_source) := sorry --non-trivial
lemma new_lemma_151510 (h1 : not (ring (topological_space to_additive.value_type) -> false)) : @rank_condition.{0} (topological_space.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (topological_space.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_151511 (h0 : not (monoid (add_group empty) -> false)) : @monoid.fg.{0} (add_group.{0} empty) (@classical.by_contradiction'.{1} (monoid.{0} (add_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_151512 (h0 : group (comm_group ennreal)) : normalizer_condition (comm_group ennreal) := sorry --non-trivial
lemma new_lemma_151513 (h0 : ring (has_lt string_imp)) : is_domain (has_lt string_imp) := sorry --non-trivial
lemma new_lemma_151514 (h0 : functor.add_const (add_monoid (plift unsigned)) unsigned) : @add_monoid.fg.{1} (plift.{1} unsigned) (@functor.add_const.run.{1 0} (add_monoid.{1} (plift.{1} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_151515 (h1 : ring (distrib linarith.comp_source)) : is_domain (distrib linarith.comp_source) := sorry --non-trivial
lemma new_lemma_151516 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) pos) : @has_exists_mul_of_le.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) pos h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_151517 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_151518 (h0 : topological_space (add_right_cancel_monoid (semiring (semiring num)))) : irreducible_space (add_right_cancel_monoid (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_151519 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_151520 (h0 : finset (option (complete_linear_order (ordered_cancel_comm_monoid num)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_151521 (h0 : topological_space (ring (has_zero (semigroup pos)))) : topological_space.separable_space (ring (has_zero (semigroup pos))) := sorry --non-trivial
lemma new_lemma_151522 (h0 : functor.add_const (function.extfun Type add_group) Type) : @is_add_cyclic.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_group.{0}) Type h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_151523 (h0 : uniform_space (semiring (has_norm congr_arg_kind))) : separated_space (semiring (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_151524 (h0 : finset (monoid (option pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_151525 (h0 : nat) (h1 h2 : fin (id h0)) : fin.lt h1 h2 := sorry --non-trivial
lemma new_lemma_151526 (h0 : topological_space (has_Sup (option (option unsigned)))) : t0_space (has_Sup (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_151527 (h1 : not (complete_lattice (random_gen fun_info) -> false)) : @is_compactly_generated.{0} (random_gen.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_151528 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) Type) : @topological_space.separable_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_151529 (h0 : topological_space (canonically_ordered_add_monoid (option unsigned))) : totally_disconnected_space (canonically_ordered_add_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_151530 (h0 : monoid (has_norm (with_bot to_additive.value_type))) : monoid.fg (has_norm (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_151531 (h3 : add_group (dlist char)) : is_add_cyclic (dlist char) := sorry --non-trivial
lemma new_lemma_151532 (h0 : functor.add_const (add_group (has_nndist ennreal)) (finset Type)) : @is_add_cyclic.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 1} (add_group.{0} (has_nndist.{0} ennreal)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_151533 (h0 : ring (has_ssubset (mul_one_class (mul_one_class std_gen)))) : is_domain (has_ssubset (mul_one_class (mul_one_class std_gen))) := sorry --non-trivial
lemma new_lemma_151534 (h0 : uniform_space (monoid (option ennreal))) : complete_space (monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_151535 (h0 : uniform_space (semi_normed_comm_ring (random_gen char))) : complete_space (semi_normed_comm_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_151536 (h0 : ordered_comm_monoid (has_ssubset real)) : has_exists_mul_of_le (has_ssubset real) := sorry --non-trivial
lemma new_lemma_151537 (h0 : not (group (with_one linarith.comp_source) -> false)) : @normalizer_condition.{0} (with_one.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (with_one.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_151538 (h0 : topological_space (plift (option (semiring unsigned)))) : topological_space.separable_space (plift (option (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_151539 (h1 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h1) (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_151540 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (normed_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_151541 (h0 : measurable_space (has_nnnorm string.iterator_imp)) (h1 : measure_theory.measure (has_nnnorm string.iterator_imp)) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_151542 (h0 : cancel_comm_monoid_with_zero (add_cancel_monoid environment.implicit_infer_kind)) : unique_factorization_monoid (add_cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_151543 (h0 : function.extfun nat fin) : @totally_disconnected_space.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_add.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_151544 (h0 : group (option (partial_order (group_with_zero (preorder empty))))) : is_cyclic (option (partial_order (group_with_zero (preorder empty)))) := sorry --non-trivial
lemma new_lemma_151545 (h0 : add_group (plift (normed_linear_ordered_group unsigned))) : is_add_cyclic (plift (normed_linear_ordered_group unsigned)) := sorry --non-trivial
lemma new_lemma_151546 (h0 : functor.add_const (ring (normed_comm_ring name)) Type) : @rank_condition.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (normed_comm_ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_151547 (h0 : functor.add_const (ring (add_cancel_monoid linarith.comp)) Type) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (add_cancel_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_151548 (h0 : group (add_cancel_monoid (cancel_monoid pos))) : normalizer_condition (add_cancel_monoid (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_151549 (h0 : multiset (random_gen string_imp)) (h1 : not (multiset (random_gen string_imp) -> false)) : multiset.disjoint h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_151550 (h0 : functor.add_const Prop (add_cancel_monoid (has_zero Type))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_151551 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_151552 (h0 : functor.add_const (filter (comm_group name)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_151553 (h0 : has_mem.mem (has_emptyc congr_arg_kind) has_emptyc.emptyc) : @is_domain.{0} (has_emptyc.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type ring.{0} (has_emptyc.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_151554 (h0 : topological_space (normed_field (mul_one_class (mul_one_class linarith.comp_source)))) : totally_disconnected_space (normed_field (mul_one_class (mul_one_class linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_151555 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_nndist empty)) := sorry --non-trivial
lemma new_lemma_151556 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_151557 (h0 : group (measurable_space (random_gen (random_gen (random_gen to_additive.value_type))))) : is_cyclic (measurable_space (random_gen (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_151558 (h0 : uniform_space (ordered_comm_monoid (has_neg name))) : separated_space (ordered_comm_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_151559 (h0 : functor.add_const (group (has_zero name)) environment.implicit_infer_kind) : @is_simple_group.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_151560 (h1 : filter (div_inv_monoid (has_nnnorm fun_info))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_151561 (h0 : group (with_bot (semiring (has_norm unsigned)))) : is_cyclic (with_bot (semiring (has_norm unsigned))) := sorry --non-trivial
lemma new_lemma_151562 (h0 : has_lt (semi_normed_comm_ring linarith.comp_source)) : no_max_order (semi_normed_comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_151563 (h0 : functor.add_const (ring (boolean_algebra name)) name) : @strong_rank_condition.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_151564 (h0 : not (complete_lattice (linear_ordered_add_comm_group linarith.comp_source) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_151565 (h0 : list (ring (has_neg pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_151566 (h0 : complete_lattice (has_nndist (has_add unsigned))) : complete_lattice.is_Sup_finite_compact (has_nndist (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_151567 (h0 : functor.add_const (topological_space (has_neg unsigned)) environment.implicit_infer_kind) : @preconnected_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_151568 (h0 : monoid (has_zero (finset (has_add Type)))) : monoid.fg (has_zero (finset (has_add Type))) := sorry --non-trivial
lemma new_lemma_151569 (h0 : functor.add_const (topological_space (has_nndist real)) linarith.comp) : @irreducible_space.{0} (has_nndist.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} real)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_151570 (h0 : functor.add_const (topological_space (has_add pos)) pos) : @t1_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_151571 (h0 : ring (linear_ordered_add_comm_group (random_gen (random_gen to_additive.value_type)))) : is_domain (linear_ordered_add_comm_group (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_151572 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_151573 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (simple_graph.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_151574 (h0 : semiring (ring (finset (boolean_algebra (has_Inf pos))))) : is_noetherian_ring (ring (finset (boolean_algebra (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_151575 (h0 : functor.add_const (group (ring linarith.comp)) name) : @is_cyclic.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_151576 (h0 : topological_space (complete_linear_order (semiring (semiring (semiring empty))))) : t1_space (complete_linear_order (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_151577 (h1 : add_group (mul_one_class to_additive.value_type)) : is_add_cyclic (mul_one_class to_additive.value_type) := sorry --non-trivial
lemma new_lemma_151578 (h2 : filter (comm_ring to_additive.value_type)) : filter.ne_bot h2 := sorry --non-trivial
lemma new_lemma_151579 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_add.{0} nnreal) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_add.{0} nnreal))  := sorry --non-trivial
lemma new_lemma_151580 (h0 : monoid (denumerable (has_inv fun_info))) : monoid.fg (denumerable (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_151581 (h0 : ring (dlist (has_top (comm_ring linarith.ineq)))) : rank_condition (dlist (has_top (comm_ring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_151582 (h0 : monoid (denumerable (has_inv string_imp))) : monoid.fg (denumerable (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_151583 (h0 : finset (boolean_algebra (has_Inf name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_151584 (h0 : functor.add_const (group (has_add linarith.comp)) Type) : @is_cyclic.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (has_add.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_151585 (h0 : ring (semigroup (finset (finset pos)))) : is_domain (semigroup (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_151586 (h0 : topological_space (linear_ordered_add_comm_monoid_with_top empty)) : totally_disconnected_space (linear_ordered_add_comm_monoid_with_top empty) := sorry --non-trivial
lemma new_lemma_151587 (h0 : functor.add_const (topological_space (has_Sup empty)) (semiring (semiring congr_arg_kind))) : @preirreducible_space.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} empty)) (semiring.{0} (semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_151588 (h0 : functor.add_const (complete_lattice (has_zero name)) (has_to_string (has_to_string pos))) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} name)) (has_to_string.{0} (has_to_string.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_151589 (h0 : group (has_star (semiring (semiring (semiring num))))) : is_cyclic (has_star (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_151590 (h0 : functor.add_const (ordered_add_comm_monoid (linear_ordered_comm_monoid_with_zero unsigned)) (option unsigned)) : @archimedean.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_151591 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg Type)) : @preirreducible_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{1} Type) h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_151592 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) unsigned) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) unsigned h0) (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_151593 (h0 : topological_space (ordered_cancel_add_comm_monoid (option (option pos)))) : t1_space (ordered_cancel_add_comm_monoid (option (option pos))) := sorry --non-trivial
lemma new_lemma_151594 (h0 : not (ring (has_div linarith.ineq) -> false)) : @rank_condition.{0} (has_div.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (has_div.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_151595 (h0 : ring (has_nndist (finset Type))) : strong_rank_condition (has_nndist (finset Type)) := sorry --non-trivial
lemma new_lemma_151596 (h0 : functor.add_const (list (has_Inf pos)) (has_neg (has_add name))) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_151597 (h0 : topological_space (has_Inf (has_add (ring name)))) : locally_compact_space (has_Inf (has_add (ring name))) := sorry --non-trivial
lemma new_lemma_151598 (h0 : function.extfun Type (functor.add_const (topological_space (ring linarith.comp)))) : @t1_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (ring.{0} linarith.comp))) h0 (has_neg.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_151599 (h0 : topological_space (add_comm_semigroup (normed_field (normed_field std_gen)))) : totally_disconnected_space (add_comm_semigroup (normed_field (normed_field std_gen))) := sorry --non-trivial
lemma new_lemma_151600 (h1 : ring (measurable_space congr_arg_kind)) : is_domain (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_151601 (h0 : complete_lattice (linear_ordered_add_comm_group (has_lt linarith.ineq))) : is_compactly_generated (linear_ordered_add_comm_group (has_lt linarith.ineq)) := sorry --non-trivial
lemma new_lemma_151602 (h0 : group (with_one char)) : is_cyclic (with_one char) := sorry --non-trivial
lemma new_lemma_151603 (h0 : topological_space (has_star (semiring unsigned))) : discrete_topology (has_star (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_151604 (h0 : functor.add_const (group (boolean_algebra environment.implicit_infer_kind)) name) : @group.fg.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_151605 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) linarith.comp) : @has_exists_mul_of_le.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) linarith.comp h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_151606 (h0 : not (add_group (denumerable to_additive.value_type) -> false)) : @is_add_cyclic.{0} (denumerable.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (add_group.{0} (denumerable.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_151607 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_151608 (h0 : ordered_comm_monoid (option (canonically_linear_ordered_monoid ennreal))) : has_exists_mul_of_le (option (canonically_linear_ordered_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_151609 (h0 : topological_space (ordered_cancel_add_comm_monoid unsigned)) : locally_compact_space (ordered_cancel_add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_151610 (h0 : add_monoid (normed_linear_ordered_group empty)) : add_monoid.fg (normed_linear_ordered_group empty) := sorry --non-trivial
lemma new_lemma_151611 (h0 : topological_space (has_star empty)) : t1_space (has_star empty) := sorry --non-trivial
lemma new_lemma_151612 (h0 : function.extfun Type group) : @is_cyclic.{0} (uniform_space.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (uniform_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_151613 (h0 : functor.add_const (function.extfun Type group) (has_neg_part Type)) : @is_simple_group.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) (has_neg_part.{1} Type) h0) (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_151614 (h0 : topological_space (with_one (has_inv to_additive.value_type))) : locally_compact_space (with_one (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_151615 (h0 : functor.add_const (filter (has_to_string ennreal)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_151616 (h0 : filter (complete_distrib_lattice (comm_group (comm_group (comm_group (comm_group ennreal)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_151617 (h0 : uniform_space (has_div (mul_one_class (mul_one_class string.iterator_imp)))) : complete_space (has_div (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_151618 (h0 : topological_space (boolean_algebra (has_neg_part (has_add name)))) : discrete_topology (boolean_algebra (has_neg_part (has_add name))) := sorry --non-trivial
lemma new_lemma_151619 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_ssubset.{0} linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_ssubset.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_151620 (h0 : functor.add_const (topological_space (semigroup pos)) (ring Type)) : @topological_space.separable_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} pos)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_151621 (h0 : topological_space (boolean_algebra.core (option unsigned))) : preirreducible_space (boolean_algebra.core (option unsigned)) := sorry --non-trivial
lemma new_lemma_151622 (h0 : complete_lattice (has_pos_part linarith.comp)) : is_compactly_generated (has_pos_part linarith.comp) := sorry --non-trivial
lemma new_lemma_151623 (h0 : functor.add_const (ring (finset name)) name) : @is_domain.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_151624 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (is_R_or_C.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (is_R_or_C.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_151625 (h0 : topological_space (semigroup (option (option ennreal)))) : t1_space (semigroup (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_151626 (h0 : topological_space (ordered_comm_ring (has_neg name))) : topological_space.separable_space (ordered_comm_ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_151627 (h0 : topological_space (boolean_algebra.core (has_add (has_neg (ring Type))))) : preirreducible_space (boolean_algebra.core (has_add (has_neg (ring Type)))) := sorry --non-trivial
lemma new_lemma_151628 (h0 : functor.add_const (topological_space (cancel_monoid Type)) environment.implicit_infer_kind) : @t1_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (cancel_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_151629 (h0 : complete_lattice (ordered_comm_monoid (ordered_comm_monoid Type))) : is_compactly_generated (ordered_comm_monoid (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_151630 (h0 : functor.add_const (topological_space (cancel_monoid environment.implicit_infer_kind)) name) : @path_connected_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_151631 (h0 : topological_space (denumerable (has_nnnorm char))) : t0_space (denumerable (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_151632 (h0 : not (group (normed_group unsigned) -> false)) : @normalizer_condition.{0} (normed_group.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (normed_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_151633 (h0 : complete_lattice (comm_semigroup (has_neg (has_neg (has_neg (has_Inf (has_neg (has_neg name)))))))) : is_atomistic (comm_semigroup (has_neg (has_neg (has_neg (has_Inf (has_neg (has_neg name))))))) := sorry --non-trivial
lemma new_lemma_151634 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) pos) : @loc_path_connected_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_151635 (h0 : fin has_zero.zero) : @sequential_space.{0} (add_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_151636 (h0 : ring (div_inv_monoid (random_gen (random_gen char)))) : strong_rank_condition (div_inv_monoid (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_151637 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_151638 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_151639 (h0 : functor.add_const (ring (ring environment.implicit_infer_kind)) (has_add (boolean_algebra pos))) : @is_domain.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} environment.implicit_infer_kind)) (has_add.{0} (boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_151640 (h0 : topological_space (has_neg (option (option ennreal)))) : totally_disconnected_space (has_neg (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_151641 (h0 : uniform_space (has_to_string (option (option (option ennreal))))) : separated_space (has_to_string (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_151642 (h0 : function.extfun Type group) : @is_simple_group.{0} (finset.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (finset.{0} num))  := sorry --non-trivial
lemma new_lemma_151643 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) linarith.comp) : @locally_compact_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_151644 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_151645 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : list.nodup (function.extfun_app (function.extfun_app h0 list) (mul_zero_class Type)) := sorry --non-trivial
lemma new_lemma_151646 (h1 : pfun enat Prop) (h2 : coe_sort (pfun.dom h1)) : pfun.as_subtype h1 h2 := sorry --non-trivial
lemma new_lemma_151647 (h0 : uniform_space (has_emptyc (has_emptyc to_additive.value_type))) : complete_space (has_emptyc (has_emptyc to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_151648 (h0 : complete_lattice (non_unital_non_assoc_semiring (random_gen linarith.comp_source))) : is_compactly_generated (non_unital_non_assoc_semiring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_151649 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_151650 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (option.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} h0 (option.{0} num))  := sorry --non-trivial
lemma new_lemma_151651 (h0 : functor.add_const (list (ordered_cancel_add_comm_monoid ennreal)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_151652 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_151653 (h0 : ring (dlist (random_gen linarith.ineq))) : rank_condition (dlist (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_151654 (h0 : topological_space (boolean_algebra (has_pos_part (has_Inf Type)))) : totally_disconnected_space (boolean_algebra (has_pos_part (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_151655 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (partial_order.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_151656 (h1 : complete_lattice (encodable (has_nnnorm char))) : complete_lattice.is_Sup_finite_compact (encodable (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_151657 (h0 : topological_space (has_top (metric_space unsigned))) : normal_space (has_top (metric_space unsigned)) := sorry --non-trivial
lemma new_lemma_151658 (h0 : functor.add_const (fin has_zero.zero) pos) : @preconnected_space.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (normed_lattice_add_comm_group.{1} Type)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) pos h0))  := sorry --non-trivial
lemma new_lemma_151659 (h0 : topological_space (monoid ennreal)) : preconnected_space (monoid ennreal) := sorry --non-trivial
lemma new_lemma_151660 (h0 : functor.add_const (topological_space (generalized_boolean_algebra Type)) pos) : @preirreducible_space.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_151661 (h3 : ring (canonically_ordered_comm_semiring char)) : rank_condition (canonically_ordered_comm_semiring char) := sorry --non-trivial
lemma new_lemma_151662 (h0 : uniform_space (has_neg (has_neg_part (add_cancel_monoid pos)))) : complete_space (has_neg (has_neg_part (add_cancel_monoid pos))) := sorry --non-trivial
lemma new_lemma_151663 (h0 : topological_space (semigroup name)) : regular_space (semigroup name) := sorry --non-trivial
lemma new_lemma_151664 (h0 : functor.add_const (topological_space (finset pos)) (has_nndist pos)) : @loc_path_connected_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) (has_nndist.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_151665 (h0 : topological_space (linear_ordered_comm_monoid_with_zero (option unsigned))) : loc_path_connected_space (linear_ordered_comm_monoid_with_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_151666 (h0 : semiring (has_add (has_to_string (has_to_string (has_to_string linarith.comp))))) : is_noetherian_ring (has_add (has_to_string (has_to_string (has_to_string linarith.comp)))) := sorry --non-trivial
lemma new_lemma_151667 (h0 : fin has_zero.zero) : @sequential_space.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_151668 (h0 : group (sub_neg_monoid (has_neg (has_Inf Type)))) : normalizer_condition (sub_neg_monoid (has_neg (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_151669 (h0 : topological_space (has_nndist (finset environment.implicit_infer_kind))) : t0_space (has_nndist (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_151670 (h0 : not (ring (has_compl (random_gen linarith.ineq)) -> false)) : @rank_condition.{0} (has_compl.{0} (random_gen.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} (random_gen.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_151671 (h0 : has_mem.mem (semiring fun_info) has_emptyc.emptyc) : @complete_space.{0} (semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type uniform_space.{0} (semiring.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_151672 (h0 : topological_space (has_lt to_additive.value_type)) (h1 : add_group (has_lt to_additive.value_type)) : topological_add_group (has_lt to_additive.value_type) := sorry --non-trivial
lemma new_lemma_151673 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_151674 (h0 : complete_lattice (random_gen (has_compl reducibility_hints))) : complete_lattice.is_Sup_finite_compact (random_gen (has_compl reducibility_hints)) := sorry --non-trivial
lemma new_lemma_151675 (h0 : group (denumerable (has_ssubset (random_gen (has_nnnorm linarith.comp_source))))) : group.fg (denumerable (has_ssubset (random_gen (has_nnnorm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_151676 (h0 : ring (dlist (comm_ring to_additive.value_type))) : strong_rank_condition (dlist (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_151677 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_151678 (h0 : topological_space (ordered_comm_monoid name)) : t0_space (ordered_comm_monoid name) := sorry --non-trivial
lemma new_lemma_151679 (h0 : has_mem.mem (id linarith.comp) has_emptyc.emptyc) : @group.fg.{0} (@id.{2} Type linarith.comp) (@finset.pi.empty.{1 0} Type group.{0} (@id.{2} Type linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_151680 (h0 : function.extfun Type topological_space) : @t0_space.{0} (bin_tree.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_151681 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring name)) linarith.comp) : @totally_separated_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_151682 (h0 : function.extfun nat fin) : @is_principal_ideal_ring.{0} (ordered_comm_monoid.{0} name) (@matrix.vec_empty.{0} (ring.{0} (ordered_comm_monoid.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_151683 (h0 : function.extfun (finset (Type -> Type) -> Prop) (function.extfun (finset (Type -> Type)))) : @t0_space.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) (@function.extfun_app.{2 0} (finset.{1} (Type → Type) → Prop) (function.extfun.{2 0} (finset.{1} (Type → Type))) h0 (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0})) (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_151684 (h0 : topological_space (left_cancel_semigroup num)) : discrete_topology (left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_151685 (h0 : functor.add_const (topological_space (semigroup name)) name) : @locally_compact_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_151686 (h0 : functor.add_const (topological_space (has_add linarith.comp)) (ring pos)) : @sequential_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_151687 (h0 : functor.add_const (add_group (boolean_algebra Type)) name) : @is_add_cyclic.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (boolean_algebra.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_151688 (h0 : topological_space (semigroup (ring (has_nndist (has_add (ring Type)))))) : regular_space (semigroup (ring (has_nndist (has_add (ring Type))))) := sorry --non-trivial
lemma new_lemma_151689 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf pos))) : topological_space.separable_space (normed_lattice_add_comm_group (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_151690 (h0 : functor.add_const (functor.comp uniform_space ring pos) name) : @complete_space.{0} (ring.{0} pos) (@functor.comp.run.{0 0 0} uniform_space.{0} ring.{0} pos (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} uniform_space.{0} ring.{0} pos) name h0))  := sorry --non-trivial
lemma new_lemma_151691 (h0 : measurable_space (mul_one_class ereal)) (h1 : measure_theory.measure (mul_one_class ereal)) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_151692 (h0 : function.extfun Type topological_space) : totally_separated_space empty := sorry --non-trivial
lemma new_lemma_151693 (h0 : functor.add_const (topological_space (has_neg Type)) pos) : @preirreducible_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_151694 (h1 : set (uniform_space string_imp)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_151695 (h0 : finset (omega_complete_partial_order empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_151696 (h0 : functor.add_const (ordered_add_comm_monoid (has_to_string linarith.comp)) Type) : @archimedean.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_to_string.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_151697 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_151698 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_151699 (h0 : group (complete_distrib_lattice (sub_neg_monoid (has_add (has_Inf pos))))) : normalizer_condition (complete_distrib_lattice (sub_neg_monoid (has_add (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_151700 (h0 : has_mem.mem (has_one unsigned) has_emptyc.emptyc) : @discrete_topology.{0} (has_one.{0} unsigned) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_151701 (h1 : uniform_space (semiring (has_norm fun_info))) : complete_space (semiring (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_151702 (h1 : eq (ring reducibility_hints) char) (h2 : char) : @rank_condition.{0} reducibility_hints (@eq.mpr.{1} (ring.{0} reducibility_hints) char h1 h2)  := sorry --non-trivial
lemma new_lemma_151703 (h0 : ring (ring (option num))) : is_principal_ideal_ring (ring (option num)) := sorry --non-trivial
lemma new_lemma_151704 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (linear_ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (linear_ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_151705 (h1 : topological_space (comm_ring (random_gen (random_gen char)))) : path_connected_space (comm_ring (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_151706 (h0 : topological_space (has_add (ring linarith.comp))) : t1_space (has_add (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_151707 (h0 : function.extfun Type (functor.add_const (cancel_comm_monoid_with_zero ennreal))) : @unique_factorization_monoid.{0} ennreal (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} ennreal) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} ennreal)) h0 num))  := sorry --non-trivial
lemma new_lemma_151708 (h0 : semiring (pseudo_metric_space (option empty))) : is_noetherian_ring (pseudo_metric_space (option empty)) := sorry --non-trivial
lemma new_lemma_151709 (h0 : ring (has_neg (ring (ring (has_add (has_add linarith.comp)))))) : is_principal_ideal_ring (has_neg (ring (ring (has_add (has_add linarith.comp))))) := sorry --non-trivial
lemma new_lemma_151710 (h0 : function.extfun Type group) : @group.fg.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_151711 (h0 : uniform_space (ordered_comm_monoid (has_neg pos))) : separated_space (ordered_comm_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_151712 (h0 : functor.add_const (topological_space (ordered_comm_monoid Type)) Type) : @totally_separated_space.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_151713 (h0 : topological_space (ordered_comm_ring (has_Inf name))) : totally_disconnected_space (ordered_comm_ring (has_Inf name)) := sorry --non-trivial
lemma new_lemma_151714 (h0 : ring (random_gen complex)) : is_domain (random_gen complex) := sorry --non-trivial
lemma new_lemma_151715 (h0 : not (group (semiring congr_arg_kind) -> false)) : @normalizer_condition.{0} (semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_151716 (h0 : not (uniform_space (plift empty) -> false)) : @separated_space.{1} (plift.{1} empty) (@classical.by_contradiction'.{2} (uniform_space.{1} (plift.{1} empty)) h0)  := sorry --non-trivial
lemma new_lemma_151717 (h0 : functor.add_const (monoid (comm_group environment.implicit_infer_kind)) name) : @monoid.fg.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (comm_group.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_151718 (h1 : function.extfun (set fun_info) (fun (x : set fun_info), Prop)) : is_countably_spanning (function.extfun_app h1) := sorry --non-trivial
lemma new_lemma_151719 (h0 : topological_space (mul_zero_class environment.implicit_infer_kind)) : path_connected_space (mul_zero_class environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_151720 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_151721 (h0 : complete_lattice (has_neg_part (comm_group name))) : is_compactly_generated (has_neg_part (comm_group name)) := sorry --non-trivial
lemma new_lemma_151722 (h0 : topological_space (linear_ordered_add_comm_group (random_gen (has_inv string_imp)))) : path_connected_space (linear_ordered_add_comm_group (random_gen (has_inv string_imp))) := sorry --non-trivial
lemma new_lemma_151723 (h0 : ring (has_inv (random_gen (random_gen char)))) : rank_condition (has_inv (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_151724 (h0 : topological_space (is_R_or_C num)) : normal_space (is_R_or_C num) := sorry --non-trivial
lemma new_lemma_151725 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_151726 (h0 : not (topological_space (add_group num) -> false)) : @normal_space.{0} (add_group.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_151727 (h0 : functor.add_const (list (has_neg name)) (mul_zero_class name)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_151728 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @preconnected_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_151729 (h0 : group (with_zero (has_nnnorm linarith.comp_source))) : is_cyclic (with_zero (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_151730 (h0 : functor.add_const Prop (has_to_string congr_arg_kind)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_151731 (h0 : ring (add_cancel_comm_monoid linarith.comp_source)) : is_domain (add_cancel_comm_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_151732 (h0 : topological_space (has_union (linear_ordered_semiring linarith.comp))) : discrete_topology (has_union (linear_ordered_semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_151733 (h0 : functor.add_const (topological_space (has_neg_part name)) (option name)) : @t0_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} name)) (option.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_151734 (h0 : ordered_add_comm_monoid (has_pos_part (ordered_ring (has_Inf (ring linarith.comp))))) : archimedean (has_pos_part (ordered_ring (has_Inf (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_151735 (h0 : functor.add_const (topological_space (has_to_string ennreal)) name) : @loc_path_connected_space.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_151736 (h0 : topological_space (has_star unsigned)) : totally_separated_space (has_star unsigned) := sorry --non-trivial
lemma new_lemma_151737 (h0 : fin has_zero.zero) : @separated_space.{0} (boolean_algebra.core.{0} name) (@matrix.vec_empty.{0} (uniform_space.{0} (boolean_algebra.core.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_151738 (h0 : function.extfun nat fin) : @is_domain.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) ring.{1}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_151739 (h0 : topological_space (add_comm_monoid Type)) : t0_space (add_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_151740 (h0 : complete_lattice (has_neg (has_add (has_add Type)))) : is_atomistic (has_neg (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_151741 (h0 : functor.add_const (topological_space (semigroup pos)) pos) : @loc_path_connected_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_151742 (h1 : filter (distrib linarith.ineq)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_151743 (h0 : functor.add_const (add_monoid (measure_theory.measure_space empty)) num) : @add_monoid.fg.{0} (measure_theory.measure_space.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (measure_theory.measure_space.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_151744 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (denumerable.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (denumerable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_151745 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @discrete_topology.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_151746 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (linear_ordered_add_comm_group.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (linear_ordered_add_comm_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_151747 (h0 : topological_space (ordered_comm_group empty)) : t0_space (ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_151748 (h1 : ring (has_compl char)) : strong_rank_condition (has_compl char) := sorry --non-trivial
lemma new_lemma_151749 (h0 : group (boolean_algebra (has_to_string environment.implicit_infer_kind))) : is_cyclic (boolean_algebra (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_151750 (h0 : function.extfun Type topological_space) : @t0_space.{0} (normed_group.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} num))))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} num))))))  := sorry --non-trivial
lemma new_lemma_151751 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_Sup congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_151752 (h0 : not (topological_space (normed_group linarith.comp) -> false)) : @normal_space.{0} (normed_group.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_151753 (h0 : ring (has_nndist (has_neg_part name))) : strong_rank_condition (has_nndist (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_151754 (h0 : functor.add_const (topological_space (ring empty)) num) : @t0_space.{0} (ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_151755 (h0 : functor.add_const (topological_space (has_zero ennreal)) name) : @normal_space.{0} (has_zero.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_151756 (h0 : functor.add_const (uniform_space (preorder empty)) (semiring (semiring num))) : @separated_space.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (preorder.{0} empty)) (semiring.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_151757 (h0 : measurable_space (has_compl char)) (h1 : filter (has_compl char)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_151758 (h0 : topological_space (ordered_comm_monoid (has_pos_part (has_Inf (has_Inf (has_Inf Type)))))) : loc_path_connected_space (ordered_comm_monoid (has_pos_part (has_Inf (has_Inf (has_Inf Type))))) := sorry --non-trivial
lemma new_lemma_151759 (h0 : functor.add_const (fin has_zero.zero) Type) : @separated_space.{0} (generalized_boolean_algebra.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (generalized_boolean_algebra.{0} real)) (@functor.add_const.run.{0 1} (fin (@has_zero.zero.{0} nat nat.has_zero)) Type h0))  := sorry --non-trivial
lemma new_lemma_151760 (h0 : functor.add_const (function.extfun Type group) environment.implicit_infer_kind) : @group.fg.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) environment.implicit_infer_kind h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_151761 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_151762 (h0 : ring (add_group (has_top unsigned))) : strong_rank_condition (add_group (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_151763 (h0 : topological_space (finset (has_to_string pos))) : sequential_space (finset (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_151764 (h0 : not (add_group (semiring linarith.comp) -> false)) : @is_add_cyclic.{0} (semiring.{0} linarith.comp) (@classical.by_contradiction'.{1} (add_group.{0} (semiring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_151765 (h0 : functor.add_const (functor.add_const (list nnreal) num) empty) : list.nodup (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_151766 (h0 : functor.add_const (semiring (add_group num)) empty) : @is_noetherian_ring.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (semiring.{0} (add_group.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_151767 (h0 : topological_space (add_cancel_monoid ennreal)) : t0_space (add_cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_151768 (h0 : ordered_comm_monoid (mul_zero_class (has_add (has_neg_part environment.implicit_infer_kind)))) : has_exists_mul_of_le (mul_zero_class (has_add (has_neg_part environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_151769 (h0 : ring (has_star (semiring num))) : strong_rank_condition (has_star (semiring num)) := sorry --non-trivial
lemma new_lemma_151770 (h0 : ring (encodable (random_gen to_additive.value_type))) : strong_rank_condition (encodable (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_151771 (h0 : topological_space (normed_group (semiring (semiring (semiring congr_arg_kind))))) : totally_disconnected_space (normed_group (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_151772 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_151773 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (left_cancel_monoid (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_151774 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) (has_neg_part Type)) : @separated_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) uniform_space.{1}) (has_neg_part.{1} Type) h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_151775 (h0 : topological_space (bin_tree (semiring (semiring num)))) : t0_space (bin_tree (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_151776 (h0 : functor.add_const (topological_space (has_Inf name)) name) : @normal_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_151777 (h0 : topological_space (generalized_boolean_algebra (has_pos_part Type))) : t0_space (generalized_boolean_algebra (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_151778 (h0 : group (has_ssubset (has_nnnorm fun_info))) : group.fg (has_ssubset (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_151779 (h0 : functor.add_const (topological_space (comm_group ennreal)) (option name)) : @irreducible_space.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} ennreal)) (option.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_151780 (h0 : topological_space (semigroup (has_to_string (has_add (boolean_algebra.core pos))))) : t1_space (semigroup (has_to_string (has_add (boolean_algebra.core pos)))) := sorry --non-trivial
lemma new_lemma_151781 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_151782 (h0 : functor.add_const (uniform_space (has_neg linarith.comp)) (has_nndist Type)) : @complete_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_neg.{0} linarith.comp)) (has_nndist.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_151783 (h0 h4 : Prop) : or h0 h4 := sorry --non-trivial
lemma new_lemma_151784 (h0 : functor.add_const (topological_space (has_zero unsigned)) (has_zero name)) : @locally_compact_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) (has_zero.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_151785 (h0 h1 : pnat) (h2 : list pnat) (h3 : punit) : pnat.coprime h0 (list.ilast' h1 (category_theory.hom_of_element h2 (id h3))) := sorry --non-trivial
lemma new_lemma_151786 (h0 : functor.add_const (function.extfun (Type 1) ring) Type) : @is_principal_ideal_ring.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) Type h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_151787 (h0 : topological_space (has_top (metric_space (semiring (metric_space unsigned))))) : totally_disconnected_space (has_top (metric_space (semiring (metric_space unsigned)))) := sorry --non-trivial
lemma new_lemma_151788 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (comm_semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (comm_semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_151789 (h1 : ring (linear_ordered_comm_group_with_zero string_imp)) : strong_rank_condition (linear_ordered_comm_group_with_zero string_imp) := sorry --non-trivial
lemma new_lemma_151790 (h0 : topological_space (has_zero (boolean_algebra linarith.comp))) : totally_separated_space (has_zero (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_151791 (h0 : topological_space (normed_comm_ring (has_neg_part unsigned))) : loc_path_connected_space (normed_comm_ring (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_151792 (h0 : list (ring (option (option ennreal)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_151793 (h0 : ulower (fin has_zero.zero)) : matrix.vec_empty (matrix.vec_empty (ulower.up (matrix.vec_empty (matrix.vec_empty (ulower.up h0))))) := sorry --non-trivial
lemma new_lemma_151794 (h0 : ring (topological_space (has_nnnorm linarith.comp_source))) : strong_rank_condition (topological_space (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_151795 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (linear_ordered_add_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_add_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_151796 (h0 : ring (add_left_cancel_monoid (random_gen string_imp))) : is_domain (add_left_cancel_monoid (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_151797 (h0 : not (group (with_bot empty) -> false)) : @is_cyclic.{0} (with_bot.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (with_bot.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_151798 (h0 : functor.add_const (list (boolean_algebra name)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_151799 (h0 : not (complete_lattice (with_zero linarith.comp_source) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_zero.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_zero.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_151800 (h0 : topological_space (has_add (ring (has_neg (ring environment.implicit_infer_kind))))) : regular_space (has_add (ring (has_neg (ring environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_151801 (h0 : complete_lattice (simple_graph (ring (ring Type)))) : complete_lattice.is_Sup_finite_compact (simple_graph (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_151802 (h0 : uniform_space (has_div to_additive.value_type)) : complete_space (has_div to_additive.value_type) := sorry --non-trivial
lemma new_lemma_151803 (h0 : set (uniform_space string_imp)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_151804 (h0 : filter (has_neg (option (has_to_string unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_151805 (h0 : functor.add_const (function.extfun Type uniform_space) (finset linarith.comp)) : @separated_space.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) (finset.{0} linarith.comp) h0) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_151806 (h0 : complete_lattice (has_compl linarith.ineq)) : complete_lattice.is_Sup_finite_compact (has_compl linarith.ineq) := sorry --non-trivial
lemma new_lemma_151807 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_151808 (h0 : ring (has_ssubset (mul_one_class linarith.ineq))) : rank_condition (has_ssubset (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_151809 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (has_dist unsigned)) := sorry --non-trivial
lemma new_lemma_151810 (h0 : functor.add_const (complete_lattice (cancel_monoid name)) name) : @is_compactly_generated.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_151811 (h0 : functor.add_const (uniform_space (add_cancel_monoid empty)) empty) : @separated_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_151812 (h0 : fin has_zero.zero) : @rank_condition.{1} (has_neg.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_151813 (h0 : topological_space (boolean_algebra (finset pos))) : normal_space (boolean_algebra (finset pos)) := sorry --non-trivial
lemma new_lemma_151814 (h0 : function.extfun nat fin) : rank_condition real := sorry --non-trivial
lemma new_lemma_151815 (h0 : semiring (has_one (semiring (semiring (semiring congr_arg_kind))))) : is_noetherian_ring (has_one (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_151816 (h0 : topological_space (has_neg_part (has_add (has_add (option ennreal))))) : t1_space (has_neg_part (has_add (has_add (option ennreal)))) := sorry --non-trivial
lemma new_lemma_151817 (h0 : group (normed_field (has_nnnorm (random_gen (random_gen string.iterator_imp))))) : is_cyclic (normed_field (has_nnnorm (random_gen (random_gen string.iterator_imp)))) := sorry --non-trivial
lemma new_lemma_151818 (h0 : functor.add_const (ordered_add_comm_monoid (mul_zero_class Type)) pos) : @archimedean.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (mul_zero_class.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_151819 (h0 : group (mul_zero_class (cancel_monoid pos))) : normalizer_condition (mul_zero_class (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_151820 (h0 : filter (has_neg (has_add (has_add (has_neg (has_Inf linarith.comp)))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_151821 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} h0 (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_151822 (h0 : complete_lattice real.angle) : is_atomistic real.angle := sorry --non-trivial
lemma new_lemma_151823 (h0 : functor.add_const (group (cancel_monoid Type)) name) : @group.fg.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_151824 (h0 : monoid (has_zero (has_to_string (has_to_string (has_to_string (ring pos)))))) : monoid.fg (has_zero (has_to_string (has_to_string (has_to_string (ring pos))))) := sorry --non-trivial
lemma new_lemma_151825 (h0 : finset (boolean_algebra (has_Inf pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_151826 (h0 : functor.add_const (monoid (normed_comm_ring pos)) linarith.comp) : @monoid.fg.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (normed_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_151827 (h0 : functor.add_const (function.extfun Type group) (mul_zero_class Type)) : @is_cyclic.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) (mul_zero_class.{1} Type) h0) (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_151828 (h0 : functor.add_const (topological_space (ordered_cancel_add_comm_monoid empty)) ennreal) : @discrete_topology.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_cancel_add_comm_monoid.{0} empty)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_151829 (h0 : functor.add_const (topological_space (add_group unsigned)) num) : @normal_space.{0} (add_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_151830 (h0 : functor.add_const (topological_space (has_nndist pos)) unsigned) : @preconnected_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_151831 (h0 : topological_space (add_group (semiring congr_arg_kind))) : preirreducible_space (add_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_151832 (h0 : topological_space (has_neg (has_neg_part Type))) : irreducible_space (has_neg (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_151833 (h0 : ring (bin_tree num)) : rank_condition (bin_tree num) := sorry --non-trivial
lemma new_lemma_151834 (h0 : ordered_comm_monoid (complete_distrib_lattice (has_nndist pos))) : has_exists_mul_of_le (complete_distrib_lattice (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_151835 (h0 : not (complete_lattice (topological_space (has_lt char)) -> false)) : is_compactly_generated (topological_space (has_lt char)) := sorry --non-trivial
lemma new_lemma_151836 (h0 : topological_space (boolean_algebra linarith.comp)) : totally_separated_space (boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_151837 (h0 : complete_lattice (simple_graph enat)) : is_compactly_generated (simple_graph enat) := sorry --non-trivial
lemma new_lemma_151838 (h0 : topological_space (has_compl (has_add fun_info))) : totally_disconnected_space (has_compl (has_add fun_info)) := sorry --non-trivial
lemma new_lemma_151839 (h0 : function.extfun Type ring) : @rank_condition.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_151840 (h0 : ordered_comm_monoid (semigroup (has_to_string Type))) : has_exists_mul_of_le (semigroup (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_151841 (h0 : topological_space (ordered_comm_ring (has_add (finset pos)))) : preirreducible_space (ordered_comm_ring (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_151842 (h0 : filter (fintype (comm_ring linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_151843 (h0 : uniform_space (measurable_space (has_top (has_top fun_info)))) : complete_space (measurable_space (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_151844 (h0 : group (has_Inf (has_Inf real))) : is_cyclic (has_Inf (has_Inf real)) := sorry --non-trivial
lemma new_lemma_151845 (h0 : functor.comp ordered_comm_monoid boolean_algebra unsigned) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} unsigned) (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} boolean_algebra.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_151846 (h0 : add_group (has_pos_part (ring (has_add Type)))) : is_add_cyclic (has_pos_part (ring (has_add Type))) := sorry --non-trivial
lemma new_lemma_151847 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_dist.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_dist.{0} num))  := sorry --non-trivial
lemma new_lemma_151848 (h0 : topological_space (with_one (semiring congr_arg_kind))) : totally_disconnected_space (with_one (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_151849 (h0 : complete_lattice linarith.comp_source) : is_compactly_generated linarith.comp_source := sorry --non-trivial
lemma new_lemma_151850 (h0 : filter (complete_semilattice_Sup (has_norm string_imp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_151851 (h0 : ring (random_gen (has_top (has_top empty)))) : is_domain (random_gen (has_top (has_top empty))) := sorry --non-trivial
lemma new_lemma_151852 (h0 : not (topological_space (with_bot unsigned) -> false)) : @normal_space.{0} (with_bot.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_151853 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (pseudo_metric_space.{0} (option.{0} (option.{0} (option.{0} (has_to_string.{0} (option.{0} ennreal)))))) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (pseudo_metric_space.{0} (option.{0} (option.{0} (option.{0} (has_to_string.{0} (option.{0} ennreal)))))))  := sorry --non-trivial
lemma new_lemma_151854 (h0 : functor.add_const (topological_space (mul_zero_class congr_arg_kind)) congr_arg_kind) : @locally_compact_space.{0} (mul_zero_class.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_151855 (h0 : list (random_gen fun_info)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_151856 (h0 : add_monoid (complete_distrib_lattice (has_neg Type))) : add_monoid.fg (complete_distrib_lattice (has_neg Type)) := sorry --non-trivial
lemma new_lemma_151857 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_151858 (h0 : topological_space (linear_ordered_add_comm_group_with_top (random_gen linarith.ineq))) : totally_disconnected_space (linear_ordered_add_comm_group_with_top (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_151859 (h0 : add_group (bin_tree (semiring (semiring num)))) : is_add_cyclic (bin_tree (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_151860 (h0 : group (add_comm_monoid (has_Inf linarith.comp))) : group.fg (add_comm_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_151861 (h0 : list (bin_tree (option empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_151862 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (boolean_algebra.{0} empty))  := sorry --non-trivial
lemma new_lemma_151863 (h0 : group (fintype linarith.ineq)) : group.fg (fintype linarith.ineq) := sorry --non-trivial
lemma new_lemma_151864 (h0 : functor.add_const (add_monoid (add_group congr_arg_kind)) congr_arg_kind) : @add_monoid.fg.{0} (add_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (add_group.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_151865 (h0 : group (complete_distrib_lattice (has_add environment.implicit_infer_kind))) : group.fg (complete_distrib_lattice (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_151866 (h0 : functor.add_const (topological_space (ring unsigned)) environment.implicit_infer_kind) : @totally_separated_space.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_151867 (h0 : fin has_zero.zero) : @separated_space.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (comm_semigroup.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_151868 (h3 : add_group (has_ssubset linarith.comp_source)) : is_add_cyclic (has_ssubset linarith.comp_source) := sorry --non-trivial
lemma new_lemma_151869 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_151870 (h0 : list (bin_tree (option (option empty)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_151871 (h0 : filter (pseudo_emetric_space linarith.comp_source)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_151872 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_to_string.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} empty))  := sorry --non-trivial
lemma new_lemma_151873 (h0 : topological_space (canonically_ordered_comm_semiring (has_Inf (has_Inf (has_Inf linarith.comp))))) : irreducible_space (canonically_ordered_comm_semiring (has_Inf (has_Inf (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_151874 (h0 : topological_space (left_cancel_semigroup unsigned)) : irreducible_space (left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_151875 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @locally_compact_space.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (linear_ordered_add_comm_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_151876 (h0 : ring (has_add (has_nnnorm char))) : is_domain (has_add (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_151877 (h0 : group (add_semigroup (option unsigned))) : is_cyclic (add_semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_151878 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_Sup.{0} (semiring.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Sup.{0} (semiring.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_151879 (h0 : group (sub_neg_monoid (has_add linarith.comp))) : group.fg (sub_neg_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_151880 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_151881 (h0 : ring (semigroup (has_pos_part (finset linarith.comp)))) : is_principal_ideal_ring (semigroup (has_pos_part (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_151882 (h0 : finset (has_inf pos)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_151883 (h0 : functor.add_const (ordered_add_comm_monoid (comm_group pos)) pos) : @archimedean.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (comm_group.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_151884 (h0 : functor.add_const (ring (add_cancel_monoid name)) name) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_151885 (h0 : prod (mul_zero_class empty) (mul_zero_class empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_151886 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (denumerable.{0} (has_nnnorm.{0} (has_nnnorm.{0} fun_info))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (denumerable.{0} (has_nnnorm.{0} (has_nnnorm.{0} fun_info))))  := sorry --non-trivial
lemma new_lemma_151887 (h0 : topological_space (canonically_ordered_comm_semiring (ring linarith.comp))) : preirreducible_space (canonically_ordered_comm_semiring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_151888 (h0 : not (topological_space (complete_linear_order unsigned) -> false)) : @loc_path_connected_space.{0} (complete_linear_order.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_linear_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_151889 (h0 : topological_space (boolean_algebra (finset (finset pos)))) : loc_path_connected_space (boolean_algebra (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_151890 (h0 : topological_space (mul_one_class (add_comm_semigroup fun_info))) : path_connected_space (mul_one_class (add_comm_semigroup fun_info)) := sorry --non-trivial
lemma new_lemma_151891 (h0 : topological_space (has_Inf (boolean_algebra.core pos))) : sequential_space (has_Inf (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_151892 (h0 : ring (semi_normed_comm_ring (mul_one_class reducibility_hints))) : rank_condition (semi_normed_comm_ring (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_151893 (h1 : complete_lattice (random_gen (has_nnnorm char))) : complete_lattice.is_Sup_finite_compact (random_gen (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_151894 (h0 : functor.add_const (ring (has_Sup empty)) congr_arg_kind) : @strong_rank_condition.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (has_Sup.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_151895 (h0 : topological_space (generalized_boolean_algebra (has_pos_part (sub_neg_monoid Type)))) : sequential_space (generalized_boolean_algebra (has_pos_part (sub_neg_monoid Type))) := sorry --non-trivial
lemma new_lemma_151896 (h0 : function.extfun Type (functor.add_const (topological_space pos))) : @normal_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} pos)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_151897 (h0 : function.extfun Type group) : @group.fg.{0} (partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_151898 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_151899 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_151900 (h0 : group (linear_ordered_add_comm_group (linear_ordered_add_comm_group fun_info))) : group.fg (linear_ordered_add_comm_group (linear_ordered_add_comm_group fun_info)) := sorry --non-trivial
lemma new_lemma_151901 (h0 : topological_space (generalized_boolean_algebra (has_pos_part (has_Inf Type)))) : sequential_space (generalized_boolean_algebra (has_pos_part (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_151902 (h0 : topological_space (add_left_cancel_semigroup num)) : locally_compact_space (add_left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_151903 (h0 : functor.add_const (topological_space (cancel_monoid linarith.comp)) linarith.comp) : @t0_space.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_151904 (h0 : topological_space (mul_zero_class (has_neg_part unsigned))) : preirreducible_space (mul_zero_class (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_151905 (h0 : ring (has_union (has_top linarith.comp))) : is_domain (has_union (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_151906 (h0 : topological_space (has_add (has_add name))) : preirreducible_space (has_add (has_add name)) := sorry --non-trivial
lemma new_lemma_151907 (h0 : functor.add_const (semiring (comm_group unsigned)) Type) : @is_noetherian_ring.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 1} (semiring.{0} (comm_group.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_151908 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_151909 (h0 : list (with_one (linear_ordered_add_comm_group fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_151910 (h0 : ring (finset (finset linarith.comp))) : is_principal_ideal_ring (finset (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_151911 (h0 : functor.add_const (finset (finset linarith.comp)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_151912 (h0 : topological_space (has_add (comm_semigroup real))) : t0_space (has_add (comm_semigroup real)) := sorry --non-trivial
lemma new_lemma_151913 (h0 : functor.add_const (uniform_space (boolean_algebra Type)) name) : @separated_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (boolean_algebra.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_151914 (h0 : topological_space (has_to_string (has_add name))) : t0_space (has_to_string (has_add name)) := sorry --non-trivial
lemma new_lemma_151915 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} real.angle (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 real.angle)  := sorry --non-trivial
lemma new_lemma_151916 (h0 : add_group (ordered_comm_ring (has_add (ring (ring Type))))) : is_add_cyclic (ordered_comm_ring (has_add (ring (ring Type)))) := sorry --non-trivial
lemma new_lemma_151917 (h0 : uniform_space (ring pos)) : separated_space (ring pos) := sorry --non-trivial
lemma new_lemma_151918 (h0 : has_lt (simple_graph ereal)) : no_max_order (simple_graph ereal) := sorry --non-trivial
lemma new_lemma_151919 (h0 : topological_space (complete_linear_order (semiring empty))) : totally_separated_space (complete_linear_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_151920 (h0 : topological_space (metric_space (semiring (has_top linarith.comp)))) : preirreducible_space (metric_space (semiring (has_top linarith.comp))) := sorry --non-trivial
lemma new_lemma_151921 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (pseudo_metric_space pos)) := sorry --non-trivial
lemma new_lemma_151922 (h0 : topological_space (has_zero (comm_group (has_add Type)))) : locally_compact_space (has_zero (comm_group (has_add Type))) := sorry --non-trivial
lemma new_lemma_151923 (h0 : functor.add_const (ring (has_add environment.implicit_infer_kind)) pos) : @rank_condition.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_151924 (h0 : ring (ordered_comm_group congr_arg_kind)) : is_principal_ideal_ring (ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_151925 (h1 : ring (has_inv linarith.ineq)) : is_domain (has_inv linarith.ineq) := sorry --non-trivial
lemma new_lemma_151926 (h2 : group (metric_space char)) : is_cyclic (metric_space char) := sorry --non-trivial
lemma new_lemma_151927 (h0 : not (has_mem.mem (linear_ordered_semiring num) has_emptyc.emptyc -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_semiring.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (linear_ordered_semiring.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_151928 (h0 : topological_space (ordered_cancel_add_comm_monoid empty)) : path_connected_space (ordered_cancel_add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_151929 (h0 : not (ring (option string_imp) -> false)) : @is_domain.{0} (option.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (option.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_151930 (h0 : topological_space (has_emptyc (random_gen linarith.comp_source))) : t0_space (has_emptyc (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_151931 (h0 : pfun std_gen (topological_space ereal)) (h1 : coe_sort (pfun.dom h0)) : path_connected_space ereal := sorry --non-trivial
lemma new_lemma_151932 (h0 : functor.add_const (ring (complete_distrib_lattice Type)) pos) : @strong_rank_condition.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (complete_distrib_lattice.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_151933 (h0 : function.extfun Type (functor.add_const (add_group auto.case_option))) : @is_add_cyclic.{0} auto.case_option (@functor.add_const.run.{0 0} (add_group.{0} auto.case_option) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_group.{0} auto.case_option)) h0 num))  := sorry --non-trivial
lemma new_lemma_151934 (h0 : topological_space (has_zero (has_add (has_add linarith.comp)))) : discrete_topology (has_zero (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_151935 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) pos) : @separated_space.{1} Type (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) uniform_space.{1}) pos h0) Type)  := sorry --non-trivial
lemma new_lemma_151936 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (semigroup num)) := sorry --non-trivial
lemma new_lemma_151937 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (linear_ordered_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_151938 (h0 : filter (option name)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_151939 (h0 : ring (linear_order (option unsigned))) : rank_condition (linear_order (option unsigned)) := sorry --non-trivial
lemma new_lemma_151940 (h1 h2 : list char) : list.is_infix h1 h2 := sorry --non-trivial
lemma new_lemma_151941 (h0 : add_group (denumerable (has_nnnorm to_additive.value_type))) : is_add_cyclic (denumerable (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_151942 (h0 : topological_space (sub_neg_monoid (sub_neg_monoid (has_Inf pos)))) : totally_separated_space (sub_neg_monoid (sub_neg_monoid (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_151943 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (ordered_cancel_add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_151944 (h0 : set (string.iterator_imp -> add_comm_semigroup (add_comm_semigroup (mul_one_class string.iterator_imp)))) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_151945 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_neg_part.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (has_neg_part.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_151946 (h0 : function.extfun nat fin) : @normal_space.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_linear_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_151947 (h0 : ring (comm_ring (has_ssubset to_additive.value_type))) : is_domain (comm_ring (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_151948 (h0 : topological_space (ordered_comm_ring (has_Inf (finset (has_add (has_Inf (has_Inf pos))))))) : preconnected_space (ordered_comm_ring (has_Inf (finset (has_add (has_Inf (has_Inf pos)))))) := sorry --non-trivial
lemma new_lemma_151949 (h0 : ring (non_assoc_semiring (semiring congr_arg_kind))) : is_domain (non_assoc_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_151950 (h0 : finset (ring (has_Inf (finset Type)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_151951 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg (has_neg Type))) : @irreducible_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{1} (has_neg.{1} Type)) h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_151952 (h0 : ring (canonically_ordered_comm_semiring (option (option empty)))) : rank_condition (canonically_ordered_comm_semiring (option (option empty))) := sorry --non-trivial
lemma new_lemma_151953 (h0 : monoid (has_inv string_imp)) : monoid.fg (has_inv string_imp) := sorry --non-trivial
lemma new_lemma_151954 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_151955 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (random_gen.{0} (has_nnnorm.{0} to_additive.value_type)) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (random_gen.{0} (has_nnnorm.{0} to_additive.value_type)))  := sorry --non-trivial
lemma new_lemma_151956 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_151957 (h0 : functor.add_const (group (add_cancel_monoid pos)) Type) : @is_simple_group.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (add_cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_151958 (h0 : topological_space (mul_zero_class empty)) : irreducible_space (mul_zero_class empty) := sorry --non-trivial
lemma new_lemma_151959 (h5 : complete_lattice (denumerable char)) : is_compactly_generated (denumerable char) := sorry --non-trivial
lemma new_lemma_151960 (h0 : ring (boolean_algebra.core unsigned)) : strong_rank_condition (boolean_algebra.core unsigned) := sorry --non-trivial
lemma new_lemma_151961 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) Type) : @regular_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_pos_part.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_151962 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_151963 (h0 : function.extfun nat fin) : @rank_condition.{0} (ordered_comm_ring.{0} name) (@matrix.vec_empty.{0} (ring.{0} (ordered_comm_ring.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_151964 (h0 : functor.add_const (topological_space (left_cancel_semigroup congr_arg_kind)) empty) : @t1_space.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_151965 (h0 : topological_space (add_cancel_monoid (comm_group Type))) : loc_path_connected_space (add_cancel_monoid (comm_group Type)) := sorry --non-trivial
lemma new_lemma_151966 (h0 : filter (has_bot (has_bot (sub_neg_monoid real)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_151967 (h0 : functor.add_const (topological_space (is_R_or_C empty)) empty) : @topological_space.separable_space.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_151968 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) pos) : @t1_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_151969 (h0 : group (has_emptyc num)) : normalizer_condition (has_emptyc num) := sorry --non-trivial
lemma new_lemma_151970 (h0 : ring (has_le to_additive.value_type)) : rank_condition (has_le to_additive.value_type) := sorry --non-trivial
lemma new_lemma_151971 (h0 : functor.add_const (add_group (bin_tree (option (option (option (option (option (option unsigned)))))))) num) : @is_add_cyclic.{0} (bin_tree.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} unsigned))))))) (@functor.add_const.run.{0 0} (add_group.{0} (bin_tree.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} unsigned)))))))) num h0)  := sorry --non-trivial
lemma new_lemma_151972 (h0 : topological_space (has_pos_part (has_pos_part (has_neg linarith.comp)))) : preirreducible_space (has_pos_part (has_pos_part (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_151973 (h1 : group (semi_normed_ring char)) : is_cyclic (semi_normed_ring char) := sorry --non-trivial
lemma new_lemma_151974 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_151975 (h2 : complete_lattice (has_nnnorm linarith.comp_source)) : is_compactly_generated (has_nnnorm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_151976 (h0 : functor.add_const (topological_space (has_nndist Type)) pos) : @loc_path_connected_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_151977 (h0 : function.extfun nat fin) : @regular_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_151978 (h1 : group (normed_field (has_nnnorm (has_ssubset (random_gen char))))) : is_cyclic (normed_field (has_nnnorm (has_ssubset (random_gen char)))) := sorry --non-trivial
lemma new_lemma_151979 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_dist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_151980 (h0 : topological_space (normed_comm_ring (has_to_string congr_arg_kind))) : topological_space.separable_space (normed_comm_ring (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_151981 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) name) : @path_connected_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_151982 (h0 : function.extfun Type complete_lattice) : is_compactly_generated (measurable_space num) := sorry --non-trivial
lemma new_lemma_151983 (h0 : list (add_cancel_comm_monoid (option unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_151984 (h0 : add_group (linear_ordered_comm_group_with_zero linarith.comp_source)) : is_add_cyclic (linear_ordered_comm_group_with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_151985 (h0 : function.extfun (Type 1) topological_space) : @discrete_topology.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_151986 (h0 : topological_space (has_to_string (option (option (option ennreal))))) : totally_disconnected_space (has_to_string (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_151987 (h0 : functor.add_const (list (cancel_monoid unsigned)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_151988 (h0 : has_mem.mem (normed_group empty) has_emptyc.emptyc) : @is_compactly_generated.{0} (normed_group.{0} empty) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (normed_group.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_151989 (h0 : not (topological_space (complete_semilattice_Sup unsigned) -> false)) : @t1_space.{0} (complete_semilattice_Sup.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_151990 (h0 : functor.add_const (group (has_nndist linarith.comp)) pos) : @is_simple_group.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_151991 (h0 : functor.add_const (function.extfun (Type 1) group) (finset Type)) : @group.fg.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) (finset.{1} Type) h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_151992 (h0 : functor.add_const (add_monoid (normed_comm_ring unsigned)) empty) : @add_monoid.fg.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (normed_comm_ring.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_151993 (h0 : uniform_space (generalized_boolean_algebra (has_Inf (has_add (has_Inf Type))))) : separated_space (generalized_boolean_algebra (has_Inf (has_add (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_151994 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_star.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_star.{0} num))  := sorry --non-trivial
lemma new_lemma_151995 (h0 : not (ring (has_ssubset string.iterator_imp) -> false)) : @rank_condition.{0} (has_ssubset.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_151996 (h0 : functor.add_const (group (has_star empty)) empty) : @is_cyclic.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (has_star.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_151997 (h0 : not (topological_space (with_one linarith.comp) -> false)) : @path_connected_space.{0} (with_one.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_151998 (h0 : not (topological_space (comm_ring (has_inv string.iterator_imp)) -> false)) : @t0_space.{0} (comm_ring.{0} (has_inv.{0} string.iterator_imp)) (@classical.by_contradiction'.{1} (topological_space.{0} (comm_ring.{0} (has_inv.{0} string.iterator_imp))) h0)  := sorry --non-trivial
lemma new_lemma_151999 (h0 : topological_space (has_add linarith.comp)) : normal_space (has_add linarith.comp) := sorry --non-trivial
