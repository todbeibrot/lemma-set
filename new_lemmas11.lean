import imports
lemma new_lemma_88000 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_88001 (h0 : function.extfun Type group) : @is_cyclic.{0} (is_R_or_C.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type group.{0} h0 (is_R_or_C.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_88002 (h0 : not (has_mem.mem (has_emptyc to_additive.value_type) has_emptyc.emptyc -> false)) : @rank_condition.{0} (has_emptyc.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type ring.{0} (has_emptyc.{0} to_additive.value_type) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} to_additive.value_type) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_88003 (h0 : topological_space (has_neg (boolean_algebra.core Type))) : t1_space (has_neg (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_88004 (h0 : complete_lattice (has_nndist (boolean_algebra unsigned))) : is_atomistic (has_nndist (boolean_algebra unsigned)) := sorry --non-trivial
lemma new_lemma_88005 (h0 : function.extfun Type (functor.add_const (uniform_space (semigroup empty)))) : @separated_space.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (semigroup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_88006 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_88007 (h0 : not (topological_space (has_star num) -> false)) : @discrete_topology.{0} (has_star.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_star.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_88008 (h0 : topological_space (ring (has_neg_part pos))) : totally_disconnected_space (ring (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_88009 (h0 : ring pos) : is_domain pos := sorry --non-trivial
lemma new_lemma_88010 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_88011 (h0 : ring (has_ssubset (mul_zero_class char))) : is_domain (has_ssubset (mul_zero_class char)) := sorry --non-trivial
lemma new_lemma_88012 (h1 : has_lt (mul_one_class linarith.ineq)) : no_max_order (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_88013 (h0 : group (has_norm (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))))) : group.fg (has_norm (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))))) := sorry --non-trivial
lemma new_lemma_88014 (h0 : semiring (has_union (semiring (has_top (has_norm num))))) : is_noetherian_ring (has_union (semiring (has_top (has_norm num)))) := sorry --non-trivial
lemma new_lemma_88015 (h0 : functor.add_const (ordered_comm_monoid (has_nndist ennreal)) (option (option (option pos)))) : @has_exists_mul_of_le.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_nndist.{0} ennreal)) (option.{0} (option.{0} (option.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_88016 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @t0_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_88017 (h0 : fin has_zero.zero) : @t0_space.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_88018 (h0 : functor.add_const (topological_space (non_assoc_semiring empty)) (option empty)) : @t0_space.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_88019 (h0 : add_group (has_to_string (has_Inf (has_Inf (has_Inf pos))))) : is_add_cyclic (has_to_string (has_Inf (has_Inf (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_88020 (h0 : group (has_top congr_arg_kind)) : group.fg (has_top congr_arg_kind) := sorry --non-trivial
lemma new_lemma_88021 (h1 : ring (distrib (topological_space char))) : rank_condition (distrib (topological_space char)) := sorry --non-trivial
lemma new_lemma_88022 (h0 : linarith.comp_source -> linarith.comp_source -> Prop) : irreflexive h0 := sorry --non-trivial
lemma new_lemma_88023 (h0 : ring (add_cancel_comm_monoid (random_gen char))) : strong_rank_condition (add_cancel_comm_monoid (random_gen char)) := sorry --non-trivial
lemma new_lemma_88024 (h0 : function.extfun nat fin) : @is_domain.{0} (ordered_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (ordered_comm_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_88025 (h0 h1 : multiset (normed_field (mul_one_class fun_info))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_88026 (h0 : filter (dlist (has_inv linarith.comp_source))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_88027 (h0 : topological_space (mul_zero_class (semiring empty))) : t1_space (mul_zero_class (semiring empty)) := sorry --non-trivial
lemma new_lemma_88028 (h0 : list (pseudo_metric_space (option pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_88029 (h0 : functor.add_const (group (has_Inf Type)) (has_add (has_add linarith.comp))) : @is_simple_group.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_Inf.{1} Type)) (has_add.{0} (has_add.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_88030 (h0 : function.extfun Type group) : @group.fg.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_88031 (h0 : functor.add_const (group (boolean_algebra pos)) (has_neg pos)) : @is_simple_group.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} pos)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_88032 (h0 : not (complete_lattice (comm_ring to_additive.value_type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (comm_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (comm_ring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_88033 (h1 : group (normed_group string_imp)) : normalizer_condition (normed_group string_imp) := sorry --non-trivial
lemma new_lemma_88034 (h0 : add_monoid (complete_distrib_lattice congr_arg_kind)) : add_monoid.fg (complete_distrib_lattice congr_arg_kind) := sorry --non-trivial
lemma new_lemma_88035 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_dist unsigned)) := sorry --non-trivial
lemma new_lemma_88036 (h0 : topological_space (comm_group (has_to_string (has_neg_part unsigned)))) : sequential_space (comm_group (has_to_string (has_neg_part unsigned))) := sorry --non-trivial
lemma new_lemma_88037 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) (has_add Type)) : @sequential_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} pos)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_88038 (h0 : functor.add_const (topological_space (ordered_comm_monoid linarith.comp)) Type) : @totally_disconnected_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_88039 (h0 : topological_space (ring (has_add (ring pos)))) : preconnected_space (ring (has_add (ring pos))) := sorry --non-trivial
lemma new_lemma_88040 (h0 : field (topological_space (has_nnnorm (has_nnnorm fun_info)))) : is_alg_closed (topological_space (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_88041 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen linarith.comp_source))) : @totally_disconnected_space.{0} (random_gen.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_88042 (h0 : complete_lattice (linear_ordered_comm_group (option empty))) : complete_lattice.is_Sup_finite_compact (linear_ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_88043 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} to_additive.value_type (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 monoid.{0}) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_88044 (h0 : functor.add_const (list (boolean_algebra.core Type)) (ring Type)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_88045 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_88046 (h1 : group (has_emptyc (random_gen to_additive.value_type))) : normalizer_condition (has_emptyc (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_88047 (h0 : topological_space (complete_distrib_lattice (has_bot (has_Inf Type)))) : preirreducible_space (complete_distrib_lattice (has_bot (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_88048 (h0 : topological_space (linear_ordered_semiring (linear_ordered_semiring unsigned))) : preirreducible_space (linear_ordered_semiring (linear_ordered_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_88049 (h0 : ring (semigroup (option (option pos)))) : is_principal_ideal_ring (semigroup (option (option pos))) := sorry --non-trivial
lemma new_lemma_88050 (h0 : functor.comp group complete_distrib_lattice name) : @normalizer_condition.{0} (complete_distrib_lattice.{0} name) (@functor.comp.run.{0 0 0} group.{0} complete_distrib_lattice.{0} name h0)  := sorry --non-trivial
lemma new_lemma_88051 (h0 : functor.add_const (ring (has_to_string environment.implicit_infer_kind)) Type) : @is_principal_ideal_ring.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ring.{0} (has_to_string.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_88052 (h0 : monoid (preorder num)) : monoid.fg (preorder num) := sorry --non-trivial
lemma new_lemma_88053 (h0 : topological_space (add_right_cancel_monoid (semiring (semiring (semiring empty))))) : discrete_topology (add_right_cancel_monoid (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_88054 (h1 : ring (fintype string_imp)) : strong_rank_condition (fintype string_imp) := sorry --non-trivial
lemma new_lemma_88055 (h0 : list (filter Prop)) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@id.{1} (filter.{0} Prop) (@list.head.{0} (filter.{0} Prop) (@filter.inhabited.{0} Prop) h0))  := sorry --non-trivial
lemma new_lemma_88056 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_nndist congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_88057 (h0 : functor.add_const (complete_lattice (has_zero Type)) (has_to_string (has_to_string Type))) : @complete_lattice.is_Sup_finite_compact.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (has_zero.{1} Type)) (has_to_string.{1} (has_to_string.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_88058 (h0 : add_group (with_zero (has_inv fun_info))) : is_add_cyclic (with_zero (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_88059 (h0 : group (finset (ring Type))) : group.fg (finset (ring Type)) := sorry --non-trivial
lemma new_lemma_88060 (h0 : topological_space (id (has_top empty))) : discrete_topology (id (has_top empty)) := sorry --non-trivial
lemma new_lemma_88061 (h0 : canonically_linear_ordered_monoid (option num) -> canonically_linear_ordered_monoid (option num) -> Prop) : is_symm (canonically_linear_ordered_monoid (option num)) h0 := sorry --non-trivial
lemma new_lemma_88062 (h0 : ring (mul_zero_class Type)) : rank_condition (mul_zero_class Type) := sorry --non-trivial
lemma new_lemma_88063 (h0 : topological_space (semigroup (semiring (semiring congr_arg_kind)))) : t0_space (semigroup (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_88064 (h1 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h1) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_88065 (h0 : topological_space (ordered_comm_semiring fun_info)) : totally_separated_space (ordered_comm_semiring fun_info) := sorry --non-trivial
lemma new_lemma_88066 (h0 : complete_lattice (finset (has_bot Type))) : is_atomistic (finset (has_bot Type)) := sorry --non-trivial
lemma new_lemma_88067 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) name) : @discrete_topology.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_88068 (h0 : topological_space (simple_graph (has_Inf (has_Inf (has_nndist pos))))) : locally_compact_space (simple_graph (has_Inf (has_Inf (has_nndist pos)))) := sorry --non-trivial
lemma new_lemma_88069 (h0 : topological_space (comm_semigroup (has_bot (sub_neg_monoid pos)))) : path_connected_space (comm_semigroup (has_bot (sub_neg_monoid pos))) := sorry --non-trivial
lemma new_lemma_88070 (h0 : topological_space (boolean_algebra.core ennreal)) : path_connected_space (boolean_algebra.core ennreal) := sorry --non-trivial
lemma new_lemma_88071 (h0 : pos -> pos -> Prop) : is_symm pos h0 := sorry --non-trivial
lemma new_lemma_88072 (h0 : not (complete_lattice (measurable_space.dynkin_system num) -> false)) : @is_compactly_generated.{0} (measurable_space.dynkin_system.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (measurable_space.dynkin_system.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_88073 (h0 : functor.add_const (topological_space (pseudo_metric_space pos)) pos) : @normal_space.{0} (pseudo_metric_space.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_88074 (h0 : topological_space (monoid ennreal)) : topological_space.separable_space (monoid ennreal) := sorry --non-trivial
lemma new_lemma_88075 (h0 : uniform_space (has_compl (linear_ordered_add_comm_monoid_with_top (random_gen linarith.ineq)))) : complete_space (has_compl (linear_ordered_add_comm_monoid_with_top (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_88076 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_88077 (h0 : topological_space (boolean_algebra.core num)) : topological_space.separable_space (boolean_algebra.core num) := sorry --non-trivial
lemma new_lemma_88078 (h0 : functor.add_const (add_monoid (mul_zero_class num)) (semiring num)) : @add_monoid.fg.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (mul_zero_class.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_88079 (h0 : topological_space (has_Inf pos)) : discrete_topology (has_Inf pos) := sorry --non-trivial
lemma new_lemma_88080 (h0 : group (with_bot (with_bot string_imp))) : normalizer_condition (with_bot (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_88081 (h1 : complete_lattice string.iterator_imp) : is_compactly_generated string.iterator_imp := sorry --non-trivial
lemma new_lemma_88082 (h0 : ring (has_Inf (complete_distrib_lattice (has_Inf (has_neg Type))))) : is_domain (has_Inf (complete_distrib_lattice (has_Inf (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_88083 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_union.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_union.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_88084 (h0 : topological_space (has_one (has_top unsigned))) : t0_space (has_one (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_88085 (h0 : filter (division_ring linarith.comp_source)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_88086 (h0 : topological_space (semigroup (has_neg environment.implicit_infer_kind))) : sequential_space (semigroup (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_88087 (h0 : add_group (comm_ring (linear_ordered_add_comm_group linarith.ineq))) : is_add_cyclic (comm_ring (linear_ordered_add_comm_group linarith.ineq)) := sorry --non-trivial
lemma new_lemma_88088 (h0 : fin has_zero.zero) : @t0_space.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_88089 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @monoid.fg.{0} congr_arg_kind (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) monoid.{0}) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_88090 (h0 : ring (has_neg (option unsigned))) : is_domain (has_neg (option unsigned)) := sorry --non-trivial
lemma new_lemma_88091 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (measurable_space.dynkin_system.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_88092 (h0 : fin has_zero.zero) : @preconnected_space.{0} (add_comm_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_88093 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_ssubset.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_ssubset.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_88094 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_one.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} num))  := sorry --non-trivial
lemma new_lemma_88095 (h0 : function.extfun Type topological_space) : @normal_space.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_88096 (h2 : not (ring (random_gen fun_info) -> false)) : @strong_rank_condition.{0} (random_gen.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} fun_info)) h2)  := sorry --non-trivial
lemma new_lemma_88097 (h0 : functor.add_const (topological_space (has_nndist ennreal)) name) : @t1_space.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_88098 (h0 : topological_space (has_ssubset (random_gen (random_gen linarith.ineq)))) : locally_compact_space (has_ssubset (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_88099 (h0 : functor.add_const (topological_space (has_to_string Type)) linarith.comp) : @t1_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_88100 (h0 : functor.add_const (monoid (monoid unsigned)) unsigned -> Prop) (h1 : Exists (fun (x : functor.add_const (monoid (monoid unsigned)) unsigned), h0 x)) : @monoid.fg.{0} (monoid.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (monoid.{0} unsigned)) unsigned (@classical.some.{1} (functor.add_const.{0 0} (monoid.{0} (monoid.{0} unsigned)) unsigned) h0 h1))  := sorry --non-trivial
lemma new_lemma_88101 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_88102 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (ordered_ring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_88103 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_88104 (h0 : has_lt (nondiscrete_normed_field (normed_field (mul_one_class fun_info)))) : no_max_order (nondiscrete_normed_field (normed_field (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_88105 (h0 : topological_space (comm_ring string_imp)) (h1 : set (comm_ring string_imp)) : is_preirreducible h1 := sorry --non-trivial
lemma new_lemma_88106 (h0 : functor.add_const (semiring (has_Inf name)) name) : @is_noetherian_ring.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (has_Inf.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_88107 (h1 : group (with_one congr_arg_kind)) : normalizer_condition (with_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_88108 (h0 : function.extfun Type topological_space) : @regular_space.{0} (semilattice_inf.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semilattice_inf.{0} name))  := sorry --non-trivial
lemma new_lemma_88109 (h0 : add_group (non_assoc_semiring (semiring empty))) : is_add_cyclic (non_assoc_semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_88110 (h0 : semiring (measure_theory.measure_space (semiring (semiring num)))) : is_noetherian_ring (measure_theory.measure_space (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_88111 (h0 : monoid (with_bot (has_inv (random_gen linarith.comp_source)))) : monoid.fg (with_bot (has_inv (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_88112 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) pos) : @sequential_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_88113 (h0 : ordered_comm_monoid (sub_neg_monoid name)) : has_exists_mul_of_le (sub_neg_monoid name) := sorry --non-trivial
lemma new_lemma_88114 (h2 : prod std_gen std_gen) : set.diagonal std_gen h2 := sorry --non-trivial
lemma new_lemma_88115 (h0 : functor.const Prop enat) : functor.const.run h0 := sorry --non-trivial
lemma new_lemma_88116 (h0 : list (comm_group (has_to_string (has_neg_part unsigned)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_88117 (h0 : functor.add_const (topological_space (bin_tree num)) (semiring num)) : @totally_disconnected_space.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_88118 (h0 : set (non_unital_non_assoc_semiring (mul_one_class char))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_88119 (h0 : topological_space (has_zero (mul_zero_class ennreal))) : t0_space (has_zero (mul_zero_class ennreal)) := sorry --non-trivial
lemma new_lemma_88120 (h0 : functor.add_const (ring (has_to_string name)) (has_to_string pos)) : @rank_condition.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} name)) (has_to_string.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_88121 (h0 : measurable_space (mul_one_class fun_info)) (h1 : measure_theory.measure (mul_one_class fun_info)) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_88122 (h0 : finset (normed_comm_ring (finset Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_88123 (h0 : not (cancel_comm_monoid_with_zero (normed_comm_ring num) -> false)) : @unique_factorization_monoid.{0} (normed_comm_ring.{0} num) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (normed_comm_ring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_88124 (h0 : list (with_one (random_gen (has_inv (has_inv (has_inv linarith.comp_source)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_88125 (h0 : list (non_assoc_semiring num)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_88126 (h0 : functor.add_const (topological_space (add_group empty)) empty) : @path_connected_space.{0} (add_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_88127 (h0 : topological_space (pseudo_metric_space unsigned)) : t0_space (pseudo_metric_space unsigned) := sorry --non-trivial
lemma new_lemma_88128 (h0 : topological_space (preorder num)) : discrete_topology (preorder num) := sorry --non-trivial
lemma new_lemma_88129 (h0 : complete_lattice (complete_distrib_lattice unsigned)) : is_compactly_generated (complete_distrib_lattice unsigned) := sorry --non-trivial
lemma new_lemma_88130 (h0 : list (dlist (has_ssubset to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_88131 (h0 : functor.add_const (complete_lattice (has_to_string Type)) linarith.comp) : @is_compactly_generated.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_to_string.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_88132 (h0 : list (boolean_algebra.core (has_add pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_88133 (h0 : function.extfun nat fin) : @t1_space.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_ring.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_88134 (h0 : function.extfun Type (functor.add_const (ordered_add_comm_monoid (option empty)))) : @archimedean.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (option.{0} empty)) (semiring.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} (option.{0} empty))) h0 (semiring.{0} (option.{0} empty))))  := sorry --non-trivial
lemma new_lemma_88135 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_88136 (h0 : functor.add_const (uniform_space (add_right_cancel_monoid empty)) num) : @complete_space.{0} (add_right_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_right_cancel_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_88137 (h0 : function.extfun Type group) : @is_cyclic.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_88138 (h0 : functor.add_const (topological_space (has_nndist Type)) Type) : @path_connected_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_nndist.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_88139 (h0 : functor.comp ordered_comm_monoid has_nndist name) : @has_exists_mul_of_le.{0} (has_nndist.{0} name) (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} has_nndist.{0} name h0)  := sorry --non-trivial
lemma new_lemma_88140 (h0 : finset (semigroup (has_add (cancel_monoid pos)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_88141 (h3 : complete_lattice (has_nnnorm to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (has_nnnorm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_88142 (h0 : ring (has_Inf (has_pos_part pos))) : is_principal_ideal_ring (has_Inf (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_88143 (h1 : function.extfun Type complete_lattice) : is_compactly_generated (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_88144 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @archimedean.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ordered_add_comm_monoid.{1}) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_88145 (h0 : topological_space (has_to_string (has_add (finset linarith.comp)))) : preconnected_space (has_to_string (has_add (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_88146 (h0 : topological_space (boolean_algebra (has_Inf (normed_comm_ring linarith.comp)))) : loc_path_connected_space (boolean_algebra (has_Inf (normed_comm_ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_88147 (h2 : uniform_space (measurable_space (has_norm (has_norm (has_norm congr_arg_kind))))) : separated_space (measurable_space (has_norm (has_norm (has_norm congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_88148 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (partial_order.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (partial_order.{0} num))  := sorry --non-trivial
lemma new_lemma_88149 (h1 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_disconnected_space.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h1) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_88150 (h0 : group (measurable_space.dynkin_system congr_arg_kind)) : normalizer_condition (measurable_space.dynkin_system congr_arg_kind) := sorry --non-trivial
lemma new_lemma_88151 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} unsigned (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) unsigned)  := sorry --non-trivial
lemma new_lemma_88152 (h0 : add_group (finset empty)) : is_add_cyclic (finset empty) := sorry --non-trivial
lemma new_lemma_88153 (h0 : group (generalized_boolean_algebra (has_add linarith.comp))) : normalizer_condition (generalized_boolean_algebra (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_88154 (h0 : uniform_space (complete_distrib_lattice num)) : separated_space (complete_distrib_lattice num) := sorry --non-trivial
lemma new_lemma_88155 (h0 : function.extfun Type group) : @normalizer_condition.{0} (normed_group.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_88156 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (measurable_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (measurable_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_88157 (h0 : functor.add_const (topological_space (has_Inf pos)) (ordered_ring linarith.comp)) : @sequential_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) (ordered_ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_88158 (h0 : topological_space (has_neg (has_add (finset pos)))) : t1_space (has_neg (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_88159 (h0 : group (has_bot pos)) : is_cyclic (has_bot pos) := sorry --non-trivial
lemma new_lemma_88160 (h0 : topological_space (with_bot linarith.comp)) : path_connected_space (with_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_88161 (h0 : functor.add_const (cancel_comm_monoid_with_zero (is_R_or_C empty)) unsigned) : @unique_factorization_monoid.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (is_R_or_C.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_88162 (h0 : filter (add_group name)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_88163 (h0 : complete_lattice (mul_zero_class (has_add unsigned))) : complete_lattice.is_Sup_finite_compact (mul_zero_class (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_88164 (h0 : functor.add_const (function.extfun Type topological_space) (has_pos_part linarith.comp)) : @t1_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_pos_part.{0} linarith.comp) h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_88165 (h0 : uniform_space (has_add (has_neg Type))) : separated_space (has_add (has_neg Type)) := sorry --non-trivial
lemma new_lemma_88166 (h0 : ring (has_ssubset (has_nnnorm string_imp))) : is_domain (has_ssubset (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_88167 (h0 : complete_lattice (ordered_comm_ring (finset pos))) : is_compactly_generated (ordered_comm_ring (finset pos)) := sorry --non-trivial
lemma new_lemma_88168 (h0 : functor.add_const (function.extfun Type list) pos) : palindrome (function.extfun_app (functor.add_const.run h0) (ordered_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_88169 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_dist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_dist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_88170 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (cancel_comm_monoid_with_zero.{1} (complete_distrib_lattice.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_88171 (h0 : set (has_nnnorm linarith.comp_source)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_88172 (h0 : topological_space (with_one (has_top fun_info))) : locally_compact_space (with_one (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_88173 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_88174 (h0 : std_gen -> enat) : function.bijective h0 := sorry --non-trivial
lemma new_lemma_88175 (h0 : list (has_neg_part (has_nndist environment.implicit_infer_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_88176 (h0 : complete_lattice (distrib (has_top linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (distrib (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_88177 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (option.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (option.{0} num))  := sorry --non-trivial
lemma new_lemma_88178 (h0 : functor.add_const (functor.add_const (function.extfun Type ring) Type) pos) : @is_principal_ideal_ring.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type (@functor.add_const.run.{1 0} (functor.add_const.{1 1} (function.extfun.{2 1} Type ring.{0}) Type) pos h0)) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_88179 (h0 : functor.add_const (functor.comp uniform_space has_neg_part environment.implicit_infer_kind) (finset Type)) : @complete_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} uniform_space.{0} has_neg_part.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 1} (functor.comp.{0 0 0} uniform_space.{0} has_neg_part.{0} environment.implicit_infer_kind) (finset.{1} Type) h0))  := sorry --non-trivial
lemma new_lemma_88180 (h0 : topological_space (has_bot (has_Inf (has_Inf real)))) : irreducible_space (has_bot (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_88181 (h0 : topological_space (group_with_zero (option (option (option (option (option empty))))))) : t0_space (group_with_zero (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_88182 (h0 : prod (bin_tree (semiring unsigned)) (bin_tree (semiring unsigned))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_88183 (h0 : group (comm_ring (mul_one_class (has_nnnorm reducibility_hints)))) : is_cyclic (comm_ring (mul_one_class (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_88184 (h0 h1 : multiset reducibility_hints) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_88185 (h0 : functor.add_const (ring (has_edist unsigned)) num) : @rank_condition.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_edist.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_88186 (h0 : functor.add_const (ordered_comm_monoid (has_to_string name)) Type) : @has_exists_mul_of_le.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (has_to_string.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_88187 (h0 : topological_space (ordered_comm_monoid pos)) : discrete_topology (ordered_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_88188 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_88189 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_88190 (h0 : functor.add_const (semiring (has_Inf Type)) pos) : @is_noetherian_ring.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (has_Inf.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_88191 (h0 : list (has_pos_part (has_nndist Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_88192 (h0 : group (id (has_inv (has_inv (has_inv linarith.comp_source))))) : normalizer_condition (id (has_inv (has_inv (has_inv linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_88193 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra name)) pos) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_88194 (h0 : ring (as_linear_order (option unsigned))) : rank_condition (as_linear_order (option unsigned)) := sorry --non-trivial
lemma new_lemma_88195 (h0 : complete_lattice (with_one (random_gen to_additive.value_type))) : is_compactly_generated (with_one (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_88196 (h0 : functor.add_const (ring (is_R_or_C unsigned)) num) : @is_principal_ideal_ring.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (is_R_or_C.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_88197 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_88198 (h0 : topological_space (add_comm_monoid real)) : sequential_space (add_comm_monoid real) := sorry --non-trivial
lemma new_lemma_88199 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_88200 (h0 : functor.add_const (list (complete_distrib_lattice linarith.comp)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_88201 (h0 : topological_space (ring (has_neg (ring name)))) : preconnected_space (ring (has_neg (ring name))) := sorry --non-trivial
lemma new_lemma_88202 (h0 : group (complete_distrib_lattice linarith.comp)) : is_simple_group (complete_distrib_lattice linarith.comp) := sorry --non-trivial
lemma new_lemma_88203 (h0 : not (topological_space (with_bot congr_arg_kind) -> false)) : @irreducible_space.{0} (with_bot.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_88204 (h0 : function.extfun Type ring) : @is_domain.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_88205 (h0 : functor.add_const (cancel_comm_monoid_with_zero (normed_comm_ring linarith.comp)) Type) : @unique_factorization_monoid.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (normed_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_88206 (h0 : ring (has_zero (has_add (has_add (boolean_algebra Type))))) : is_domain (has_zero (has_add (has_add (boolean_algebra Type)))) := sorry --non-trivial
lemma new_lemma_88207 (h0 : semiring (boolean_algebra.core linarith.comp)) : is_noetherian_ring (boolean_algebra.core linarith.comp) := sorry --non-trivial
lemma new_lemma_88208 (h0 : not (list (left_cancel_semigroup congr_arg_kind) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_88209 (h0 : topological_space (has_one (has_top congr_arg_kind))) : t0_space (has_one (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_88210 (h0 : functor.add_const (group (canonically_ordered_add_monoid congr_arg_kind)) empty) : @normalizer_condition.{0} (canonically_ordered_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_add_monoid.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_88211 (h0 : function.extfun Type ring) : @is_domain.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_88212 (h0 : topological_space (id (has_top num))) : totally_separated_space (id (has_top num)) := sorry --non-trivial
lemma new_lemma_88213 (h0 : group (distrib_lattice (has_top linarith.ineq))) : normalizer_condition (distrib_lattice (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_88214 (h2 : list subsingleton_info) : list.nodup h2 := sorry --non-trivial
lemma new_lemma_88215 (h0 : functor.add_const (add_monoid (has_neg_part name)) Type) : @add_monoid.fg.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 1} (add_monoid.{0} (has_neg_part.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_88216 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} nnreal (@function.extfun_app.{2 1} Type ring.{0} h0 nnreal)  := sorry --non-trivial
lemma new_lemma_88217 (h0 : topological_space (finset (has_neg (finset (finset linarith.comp))))) : totally_disconnected_space (finset (has_neg (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_88218 (h0 : topological_space (add_cancel_monoid (has_neg (has_neg Type)))) : totally_separated_space (add_cancel_monoid (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_88219 (h0 : functor.add_const (topological_space (has_nndist name)) pos) : @path_connected_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_88220 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_88221 (h0 : has_mem.mem group has_emptyc.emptyc) : @normalizer_condition.{0} (measurable_space.{0} (random_gen.{0} linarith.ineq)) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (measurable_space.{0} (random_gen.{0} linarith.ineq)))  := sorry --non-trivial
lemma new_lemma_88222 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_add_cyclic.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) add_group.{0}) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_88223 (h0 : functor.comp ordered_comm_monoid normed_comm_ring name) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} name) (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} normed_comm_ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_88224 (h0 : fin has_zero.zero) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@matrix.vec_empty.{0} (filter.{0} Prop) (@id.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_88225 (h0 : topological_space (ring (ring name))) : loc_path_connected_space (ring (ring name)) := sorry --non-trivial
lemma new_lemma_88226 (h0 : functor.add_const (group (ring pos)) Type) : @group.fg.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_88227 (h0 : functor.add_const (topological_space (has_Inf name)) (ring name)) : @locally_compact_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} name)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_88228 (h0 : functor.add_const (topological_space (ordered_ring congr_arg_kind)) unsigned) : @totally_disconnected_space.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_88229 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf (has_add pos)))) : loc_path_connected_space (normed_lattice_add_comm_group (has_Inf (has_add pos))) := sorry --non-trivial
lemma new_lemma_88230 (h0 : functor.comp topological_space has_zero pos) : @t0_space.{0} (has_zero.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_88231 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (has_ssubset.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_ssubset.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_88232 (h0 : functor.add_const (finset (boolean_algebra.core linarith.comp)) (ring pos)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_88233 (h0 : filter (ordered_comm_ring pos)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_88234 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_88235 (h0 : ring (has_zero (finset Type))) : rank_condition (has_zero (finset Type)) := sorry --non-trivial
lemma new_lemma_88236 (h0 : group (has_to_string (ring (has_neg linarith.comp)))) : is_simple_group (has_to_string (ring (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_88237 (h0 : topological_space (has_compl environment.projection_info)) : t0_space (has_compl environment.projection_info) := sorry --non-trivial
lemma new_lemma_88238 (h0 : functor.add_const (group (complete_distrib_lattice Type)) linarith.comp) : @is_cyclic.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (complete_distrib_lattice.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_88239 (h0 : functor.add_const (topological_space (has_add real)) real) : @topological_space.separable_space.{0} (has_add.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_88240 (h0 : ring (add_monoid linarith.ineq)) : is_domain (add_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_88241 (h0 : functor.add_const (filter (option num)) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_88242 (h0 : not (uniform_space (with_bot unsigned) -> false)) : @separated_space.{0} (with_bot.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (with_bot.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_88243 (h0 : topological_space (linear_ordered_comm_monoid_with_zero (semiring unsigned))) : discrete_topology (linear_ordered_comm_monoid_with_zero (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_88244 (h0 : group (ordered_comm_ring (has_add (canonically_linear_ordered_monoid real)))) : is_simple_group (ordered_comm_ring (has_add (canonically_linear_ordered_monoid real))) := sorry --non-trivial
lemma new_lemma_88245 (h0 : topological_space (uniform_space string.iterator_imp)) (h1 : preorder (uniform_space string.iterator_imp)) : order_topology (uniform_space string.iterator_imp) := sorry --non-trivial
lemma new_lemma_88246 (h0 : topological_space (has_Inf (has_sdiff Type))) : sequential_space (has_Inf (has_sdiff Type)) := sorry --non-trivial
lemma new_lemma_88247 (h0 : ring (has_to_string (has_neg_part (has_to_string (comm_group unsigned))))) : is_domain (has_to_string (has_neg_part (has_to_string (comm_group unsigned)))) := sorry --non-trivial
lemma new_lemma_88248 (h0 : prod (has_zero pos) (has_zero pos)) : set.diagonal (has_zero pos) h0 := sorry --non-trivial
lemma new_lemma_88249 (h1 : ring (semi_normed_comm_ring (has_nnnorm (has_nnnorm (random_gen char))))) : is_domain (semi_normed_comm_ring (has_nnnorm (has_nnnorm (random_gen char)))) := sorry --non-trivial
lemma new_lemma_88250 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) linarith.comp) : @t0_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_88251 (h0 : functor.add_const (ring (has_add ennreal)) ennreal) : @strong_rank_condition.{0} (has_add.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_88252 (h0 : topological_space (simple_graph (has_add (has_pos_part pos)))) : regular_space (simple_graph (has_add (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_88253 (h0 : topological_space (random_gen (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))))) : t0_space (random_gen (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_88254 (h0 : complete_lattice (preorder (option unsigned))) : complete_lattice.is_Sup_finite_compact (preorder (option unsigned)) := sorry --non-trivial
lemma new_lemma_88255 (h0 : topological_space (has_compl (random_gen (random_gen linarith.ineq)))) : locally_compact_space (has_compl (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_88256 (h0 : filter (has_zero (finset linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_88257 (h0 : topological_space (mul_zero_class (finset (has_add name)))) : totally_disconnected_space (mul_zero_class (finset (has_add name))) := sorry --non-trivial
lemma new_lemma_88258 (h0 : filter (comm_group Type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_88259 (h1 : ring (simple_graph (mul_one_class linarith.ineq))) : rank_condition (simple_graph (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_88260 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_88261 (h0 : topological_space (ring (ring (has_neg (has_neg (ring (has_add pos))))))) : discrete_topology (ring (ring (has_neg (has_neg (ring (has_add pos)))))) := sorry --non-trivial
lemma new_lemma_88262 (h0 : ring (has_nndist (has_to_string (add_cancel_monoid pos)))) : rank_condition (has_nndist (has_to_string (add_cancel_monoid pos))) := sorry --non-trivial
lemma new_lemma_88263 (h1 : topological_space linarith.comp_source) (h2 : preorder linarith.comp_source) : order_closed_topology linarith.comp_source := sorry --non-trivial
lemma new_lemma_88264 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group num))) : @normalizer_condition.{0} (normed_group.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (normed_group.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_88265 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_edist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_edist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_88266 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (linear_ordered_field.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} num))  := sorry --non-trivial
lemma new_lemma_88267 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_88268 (h0 : semiring (measurable_space.dynkin_system empty)) : is_noetherian_ring (measurable_space.dynkin_system empty) := sorry --non-trivial
lemma new_lemma_88269 (h0 : add_comm_monoid (option ennreal) -> add_comm_monoid (option ennreal) -> Prop) : is_symm (add_comm_monoid (option ennreal)) h0 := sorry --non-trivial
lemma new_lemma_88270 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) environment.implicit_infer_kind) : @t1_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_88271 (h0 : functor.add_const (function.extfun Type ring) name) : @is_domain.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name h0) (has_neg_part.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_88272 (h0 : ring (has_nndist empty)) : is_domain (has_nndist empty) := sorry --non-trivial
lemma new_lemma_88273 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (partial_order.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_88274 (h0 : unsigned -> unsigned -> Prop) : is_per unsigned h0 := sorry --non-trivial
lemma new_lemma_88275 (h0 : fin has_zero.zero) : @group.fg.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) h0) (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_88276 (h0 : group (linear_order congr_arg_kind)) : group.fg (linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_88277 (h0 : add_group (has_neg congr_arg_kind)) : is_add_cyclic (has_neg congr_arg_kind) := sorry --non-trivial
lemma new_lemma_88278 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_88279 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_88280 (h0 : uniform_space (has_add real)) : separated_space (has_add real) := sorry --non-trivial
lemma new_lemma_88281 (h0 : ring (comm_group name)) : strong_rank_condition (comm_group name) := sorry --non-trivial
lemma new_lemma_88282 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) linarith.comp) : @totally_disconnected_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_88283 (h0 : functor.add_const (list (has_nndist Type)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_88284 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_88285 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @regular_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_88286 (h0 : functor.comp topological_space has_nndist ennreal) : @totally_separated_space.{0} (has_nndist.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_88287 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_88288 (h0 : not (monoid (linear_ordered_semiring congr_arg_kind) -> false)) : @monoid.fg.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (monoid.{0} (linear_ordered_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_88289 (h0 : uniform_space (ordered_ring (semiring empty))) : complete_space (ordered_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_88290 (h0 : topological_space (has_to_string (has_to_string (has_add ennreal)))) : preirreducible_space (has_to_string (has_to_string (has_add ennreal))) := sorry --non-trivial
lemma new_lemma_88291 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_88292 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_88293 (h0 : add_monoid (plift (semiring congr_arg_kind))) : add_monoid.fg (plift (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_88294 (h0 : topological_space (complete_semilattice_Sup unsigned)) : irreducible_space (complete_semilattice_Sup unsigned) := sorry --non-trivial
lemma new_lemma_88295 (h0 : ring (has_pos_part (finset (has_Inf (has_Inf (has_Inf Type)))))) : rank_condition (has_pos_part (finset (has_Inf (has_Inf (has_Inf Type))))) := sorry --non-trivial
lemma new_lemma_88296 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (monoid_with_zero ennreal)) := sorry --non-trivial
lemma new_lemma_88297 (h1 : complete_lattice (normed_field reducibility_hints)) : is_compactly_generated (normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_88298 (h0 : complete_lattice (has_emptyc (has_norm to_additive.value_type))) : is_atomistic (has_emptyc (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_88299 (h0 : complete_lattice (has_lt (non_unital_non_assoc_semiring enat))) : complete_lattice.is_Sup_finite_compact (has_lt (non_unital_non_assoc_semiring enat)) := sorry --non-trivial
lemma new_lemma_88300 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_88301 (h0 : add_group (monoid_with_zero ennreal)) : is_add_cyclic (monoid_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_88302 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_88303 (h0 : ring (has_union (semiring (semiring num)))) : strong_rank_condition (has_union (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_88304 (h0 : not (function.extfun Type ring -> false)) : @is_principal_ideal_ring.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_88305 (h0 : functor.add_const (functor.add_const (ring Type) environment.implicit_infer_kind) Type) : @rank_condition.{1} Type (@functor.add_const.run.{1 0} (ring.{1} Type) environment.implicit_infer_kind (@functor.add_const.run.{1 1} (functor.add_const.{1 0} (ring.{1} Type) environment.implicit_infer_kind) Type h0))  := sorry --non-trivial
lemma new_lemma_88306 (h0 : complete_lattice (simple_graph (mul_one_class linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (simple_graph (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_88307 (h0 : topological_space (has_nnnorm (has_top to_additive.value_type))) : locally_compact_space (has_nnnorm (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_88308 (h0 : fin has_zero.zero) : countable_Inter_filter (function.extfun_app (matrix.vec_empty h0) (ordered_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_88309 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (group_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (group_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_88310 (h0 : topological_space (has_norm (has_norm linarith.comp))) : locally_compact_space (has_norm (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_88311 (h1 : group (semi_normed_comm_ring fun_info)) : group.fg (semi_normed_comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_88312 (h0 : functor.add_const (topological_space (cancel_monoid environment.implicit_infer_kind)) name) : @totally_disconnected_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_88313 (h0 : functor.add_const (ring (normed_comm_ring environment.implicit_infer_kind)) (mul_one_class linarith.comp)) : @is_domain.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) (mul_one_class.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_88314 (h0 : list (complete_semilattice_Sup to_additive.value_type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_88315 (h0 : list (plift (semiring congr_arg_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_88316 (h1 h2 : multiset (normed_field linarith.comp_source)) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_88317 (h0 : functor.add_const (function.extfun (Type 1) ring) pos) : @strong_rank_condition.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) pos h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_88318 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @group.fg.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) group.{0}) (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_88319 (h0 : topological_space (semigroup (finset (finset (has_add linarith.comp))))) : sequential_space (semigroup (finset (finset (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_88320 (h2 : function.extfun Type topological_space) : @irreducible_space.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h2 (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_88321 (h0 : topological_space (bin_tree (semiring (semiring (semiring (semiring (semiring (semiring (semiring num))))))))) : t1_space (bin_tree (semiring (semiring (semiring (semiring (semiring (semiring (semiring num)))))))) := sorry --non-trivial
lemma new_lemma_88322 (h0 : complete_lattice (simple_graph (ring (ring linarith.comp)))) : is_compactly_generated (simple_graph (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_88323 (h0 : complete_lattice (id (has_norm empty))) : complete_lattice.is_Sup_finite_compact (id (has_norm empty)) := sorry --non-trivial
lemma new_lemma_88324 (h0 : topological_space (boolean_algebra (add_cancel_monoid environment.implicit_infer_kind))) : path_connected_space (boolean_algebra (add_cancel_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_88325 (h1 : ring (has_div (mul_one_class string.iterator_imp))) : strong_rank_condition (has_div (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_88326 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (left_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_88327 (h0 : not (ring (metric_space unsigned) -> false)) : @rank_condition.{0} (metric_space.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (metric_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_88328 (h0 : functor.add_const (topological_space (has_nndist name)) (has_neg linarith.comp)) : @irreducible_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_88329 (h0 : uniform_space (has_inv (random_gen (has_ssubset (has_inv (has_inv fun_info)))))) : complete_space (has_inv (random_gen (has_ssubset (has_inv (has_inv fun_info))))) := sorry --non-trivial
lemma new_lemma_88330 (h0 : ordered_comm_monoid (semigroup (has_pos_part (has_Inf (finset Type))))) : has_exists_mul_of_le (semigroup (has_pos_part (has_Inf (finset Type)))) := sorry --non-trivial
lemma new_lemma_88331 (h0 : has_star char) (h1 : not (complete_lattice (has_trivial_star char) -> false)) : @is_compactly_generated.{0} (@has_trivial_star.{0} char h0) (@classical.by_contradiction'.{1} (complete_lattice.{0} (@has_trivial_star.{0} char h0)) h1)  := sorry --non-trivial
lemma new_lemma_88332 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) (has_neg Type)) : @totally_disconnected_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_88333 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_Sup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_88334 (h0 : has_mem.mem add_group has_zero.zero) : @is_add_cyclic.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@multiset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} h0) (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_88335 (h7 : uniform_space (topological_space to_additive.value_type)) : complete_space (topological_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_88336 (h0 : functor.comp topological_space boolean_algebra name) : @preirreducible_space.{0} (boolean_algebra.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.{0} name h0)  := sorry --non-trivial
lemma new_lemma_88337 (h0 : functor.add_const (complete_lattice (canonically_ordered_comm_semiring name)) pos) : @is_compactly_generated.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_ordered_comm_semiring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_88338 (h0 : uniform_space (ordered_comm_ring (ring linarith.comp))) : separated_space (ordered_comm_ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_88339 (h0 : add_group (ordered_comm_ring (ring (ring linarith.comp)))) : is_add_cyclic (ordered_comm_ring (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_88340 (h0 : group (sub_neg_monoid (has_add real))) : is_simple_group (sub_neg_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_88341 (h0 : topological_space (as_linear_order (option (option empty)))) : t0_space (as_linear_order (option (option empty))) := sorry --non-trivial
lemma new_lemma_88342 (h0 : function.extfun nat fin) : @totally_disconnected_space.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (complete_distrib_lattice.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_88343 (h0 : ring (metric_space (semiring empty))) : is_domain (metric_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_88344 (h0 : linarith.comp -> Prop) : zzz_forall h0 := sorry --non-trivial
lemma new_lemma_88345 (h0 : group (has_nndist (comm_group name))) : is_simple_group (has_nndist (comm_group name)) := sorry --non-trivial
lemma new_lemma_88346 (h0 : monoid (finset (has_to_string linarith.comp))) : monoid.fg (finset (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_88347 (h0 : function.extfun Type (functor.add_const (list name))) : palindrome (functor.add_const.run (function.extfun_app h0 (semiring empty))) := sorry --non-trivial
lemma new_lemma_88348 (h0 : function.extfun Type (functor.add_const (topological_space (boolean_algebra pos)))) : @totally_separated_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (boolean_algebra.{0} pos))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_88349 (h0 : functor.add_const (complete_lattice (has_zero (has_add linarith.comp))) pos) : @is_compactly_generated.{0} (has_zero.{0} (has_add.{0} linarith.comp)) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} (has_add.{0} linarith.comp))) pos h0)  := sorry --non-trivial
lemma new_lemma_88350 (h3 : topological_space reducibility_hints) : path_connected_space reducibility_hints := sorry --non-trivial
lemma new_lemma_88351 (h1 : ring (has_top (has_inv (has_inv (random_gen (random_gen string_imp)))))) : is_domain (has_top (has_inv (has_inv (random_gen (random_gen string_imp))))) := sorry --non-trivial
lemma new_lemma_88352 (h0 : filter (comm_group ennreal)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_88353 (h0 : uniform_space (measurable_space (random_gen congr_arg_kind))) : separated_space (measurable_space (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_88354 (h1 : has_mem.mem (has_norm congr_arg_kind) has_emptyc.emptyc) : @strong_rank_condition.{0} (has_norm.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type ring.{0} (has_norm.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_88355 (h0 : functor.add_const (functor.add_const Prop unsigned) num) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_88356 (h0 : functor.comp topological_space has_to_string Type) : @totally_disconnected_space.{1} (has_to_string.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_to_string.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_88357 (h0 : topological_space (ring (cancel_monoid name))) : t0_space (ring (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_88358 (h0 : function.extfun nat fin) : @complete_lattice.is_Sup_finite_compact.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (boolean_algebra.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_88359 (h0 : cancel_comm_monoid_with_zero (add_semigroup num)) : unique_factorization_monoid (add_semigroup num) := sorry --non-trivial
lemma new_lemma_88360 (h0 : topological_space (complete_semilattice_Sup unsigned)) : locally_compact_space (complete_semilattice_Sup unsigned) := sorry --non-trivial
lemma new_lemma_88361 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot fun_info))) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_88362 (h0 : topological_space (left_cancel_monoid congr_arg_kind)) : t1_space (left_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_88363 (h1 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_domain.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h1 (function.extfun.{2 1} Type)) ring.{0}) (linear_ordered_add_comm_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_88364 (h0 : complete_lattice (has_neg environment.implicit_infer_kind)) : is_atomistic (has_neg environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_88365 (h0 : topological_space (sub_neg_monoid (has_add (sub_neg_monoid (sub_neg_monoid Type))))) : sequential_space (sub_neg_monoid (has_add (sub_neg_monoid (sub_neg_monoid Type)))) := sorry --non-trivial
lemma new_lemma_88366 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) linarith.comp) : @irreducible_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_88367 (h0 : functor.comp filter has_to_string pos) : filter.ne_bot (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_88368 (h0 : ring (add_left_cancel_semigroup (option unsigned))) : rank_condition (add_left_cancel_semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_88369 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_88370 (h0 : add_group (ordered_comm_ring (has_pos_part real))) : is_add_cyclic (ordered_comm_ring (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_88371 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type topological_space.{0} h0 environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_88372 (h0 : ordered_add_comm_monoid (boolean_algebra (has_add unsigned))) : archimedean (boolean_algebra (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_88373 (h0 : topological_space (normed_linear_ordered_group (has_norm unsigned))) : irreducible_space (normed_linear_ordered_group (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_88374 (h0 : with_bot (ring ordering)) (h1 : ne h0 has_bot.bot) : @is_domain.{0} ordering (@with_bot.unbot.{0} (ring.{0} ordering) h0 h1)  := sorry --non-trivial
lemma new_lemma_88375 (h0 : topological_space (has_emptyc (random_gen linarith.comp))) : t0_space (has_emptyc (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_88376 (h0 : topological_space (with_bot linarith.ineq)) : totally_disconnected_space (with_bot linarith.ineq) := sorry --non-trivial
lemma new_lemma_88377 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) environment.implicit_infer_kind) : @topological_space.separable_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_88378 (h1 : topological_space (has_lt std_gen)) : totally_disconnected_space (has_lt std_gen) := sorry --non-trivial
lemma new_lemma_88379 (h2 : add_group string.iterator) : is_add_cyclic string.iterator := sorry --non-trivial
lemma new_lemma_88380 (h0 : uniform_space fun_info) : separated_space fun_info := sorry --non-trivial
lemma new_lemma_88381 (h0 : topological_space (canonically_ordered_comm_semiring (has_add Type))) : t0_space (canonically_ordered_comm_semiring (has_add Type)) := sorry --non-trivial
lemma new_lemma_88382 (h0 : ring (ordered_ring (ring Type))) : is_principal_ideal_ring (ordered_ring (ring Type)) := sorry --non-trivial
lemma new_lemma_88383 (h0 : function.extfun Type ring) : @is_domain.{0} (ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_88384 (h0 : semiring (has_neg_part (finset name))) : is_noetherian_ring (has_neg_part (finset name)) := sorry --non-trivial
lemma new_lemma_88385 (h0 : uniform_space (random_gen (random_gen (has_nnnorm linarith.comp_source)))) : complete_space (random_gen (random_gen (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_88386 (h0 : functor.comp topological_space add_comm_monoid unsigned) : @irreducible_space.{0} (add_comm_monoid.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_88387 (h0 : filter (cancel_monoid (has_add name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_88388 (h0 : group (generalized_boolean_algebra (has_pos_part (has_add Type)))) : is_cyclic (generalized_boolean_algebra (has_pos_part (has_add Type))) := sorry --non-trivial
lemma new_lemma_88389 (h0 : functor.add_const (functor.add_const (complete_lattice linarith.comp) pos) (ring environment.implicit_infer_kind)) : @complete_lattice.is_Sup_finite_compact.{0} linarith.comp (@functor.add_const.run.{0 0} (complete_lattice.{0} linarith.comp) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (complete_lattice.{0} linarith.comp) pos) (ring.{0} environment.implicit_infer_kind) h0))  := sorry --non-trivial
lemma new_lemma_88390 (h0 : add_group (has_compl (has_nnnorm to_additive.value_type))) : is_add_cyclic (has_compl (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_88391 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} znum (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) znum)  := sorry --non-trivial
lemma new_lemma_88392 (h0 : filter (ring (option (option unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_88393 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_88394 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_88395 (h0 : topological_space (boolean_algebra.core (boolean_algebra (cancel_monoid name)))) : path_connected_space (boolean_algebra.core (boolean_algebra (cancel_monoid name))) := sorry --non-trivial
lemma new_lemma_88396 (h0 : group (has_neg_part (boolean_algebra Type))) : normalizer_condition (has_neg_part (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_88397 (h0 : functor.add_const (topological_space unsigned) empty) : @t0_space.{0} unsigned (@functor.add_const.run.{0 0} (topological_space.{0} unsigned) empty h0)  := sorry --non-trivial
lemma new_lemma_88398 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) (finset pos)) : @t1_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_88399 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (canonically_ordered_comm_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_comm_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_88400 (h0 : group (normed_comm_ring num)) : group.fg (normed_comm_ring num) := sorry --non-trivial
lemma new_lemma_88401 (h0 : cancel_comm_monoid_with_zero (ring (has_neg Type))) : unique_factorization_monoid (ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_88402 (h0 : topological_space (ring (has_add (has_pos_part pos)))) : locally_compact_space (ring (has_add (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_88403 (h0 : topological_space (ring (ring Type))) : preirreducible_space (ring (ring Type)) := sorry --non-trivial
lemma new_lemma_88404 (h0 : topological_space (measure_theory.measure_space (semiring congr_arg_kind))) : path_connected_space (measure_theory.measure_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_88405 (h0 : functor.add_const (finset (simple_graph pos)) (has_neg Type)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_88406 (h0 : list (comm_group (finset name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_88407 (h0 : not (group (has_emptyc congr_arg_kind) -> false)) : @normalizer_condition.{0} (has_emptyc.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (has_emptyc.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_88408 (h0 : functor.add_const (ring (normed_comm_ring name)) name) : @rank_condition.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_88409 (h0 : functor.add_const (list (has_star empty)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_88410 (h0 : functor.add_const (uniform_space (cancel_monoid empty)) num) : @complete_space.{0} (cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (cancel_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_88411 (h1 : function.extfun (measurable_space string_imp) (fun (x : measurable_space string_imp), Prop)) : Exists (function.extfun_app h1) := sorry --non-trivial
lemma new_lemma_88412 (h0 : ring (has_append (random_gen string_imp))) : is_domain (has_append (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_88413 (h0 : topological_space (has_neg (comm_group (comm_group (has_to_string Type))))) : sequential_space (has_neg (comm_group (comm_group (has_to_string Type)))) := sorry --non-trivial
lemma new_lemma_88414 (h0 : functor.add_const (uniform_space (semigroup linarith.comp)) pos) : @complete_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_88415 (h0 : functor.add_const (finset (normed_comm_ring Type)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_88416 (h0 : functor.add_const (monoid (has_neg pos)) Type) : @monoid.fg.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (monoid.{0} (has_neg.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_88417 (h0 : functor.add_const (uniform_space (has_add linarith.comp)) pos) : @separated_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_add.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_88418 (h0 : add_monoid (has_nndist (finset linarith.comp))) : add_monoid.fg (has_nndist (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_88419 (h0 : topological_space (linear_ordered_comm_group congr_arg_kind)) : normal_space (linear_ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_88420 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_88421 (h0 : functor.add_const (group (add_semigroup unsigned)) congr_arg_kind) : @normalizer_condition.{0} (add_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (add_semigroup.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_88422 (h0 : cancel_comm_monoid_with_zero (has_neg (has_nndist (finset (finset Type))))) : unique_factorization_monoid (has_neg (has_nndist (finset (finset Type)))) := sorry --non-trivial
lemma new_lemma_88423 (h0 : functor.add_const (group (ring pos)) pos) : @group.fg.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_88424 (h1 : filter (semi_normed_comm_ring char)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_88425 (h0 : functor.add_const (topological_space pos) Type) : @discrete_topology.{0} pos (@functor.add_const.run.{0 1} (topological_space.{0} pos) Type h0)  := sorry --non-trivial
lemma new_lemma_88426 (h0 : complete_lattice (with_bot string_imp)) : is_atomistic (with_bot string_imp) := sorry --non-trivial
lemma new_lemma_88427 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_88428 (h0 : unsigned -> unsigned -> Prop) : total h0 := sorry --non-trivial
lemma new_lemma_88429 (h0 : functor.add_const (function.extfun Type uniform_space) Type) : @separated_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) Type h0) (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_88430 (h0 : not (ring (normed_group linarith.comp_source) -> false)) : @rank_condition.{0} (normed_group.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (normed_group.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_88431 (h0 : function.extfun nat fin) : @monoid.fg.{0} (complete_distrib_lattice.{0} pos) (@matrix.vec_empty.{0} (monoid.{0} (complete_distrib_lattice.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_88432 (h0 : ring (linear_ordered_field congr_arg_kind) -> ring (linear_ordered_field congr_arg_kind) -> Prop) : is_symm (ring (linear_ordered_field congr_arg_kind)) h0 := sorry --non-trivial
lemma new_lemma_88433 (h0 : functor.add_const (list (left_cancel_monoid unsigned)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_88434 (h0 : functor.add_const (function.extfun Type topological_space) name) : @preirreducible_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_88435 (h0 : topological_space (boolean_algebra.core (has_add (boolean_algebra Type)))) : preirreducible_space (boolean_algebra.core (has_add (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_88436 (h0 : filter (comm_group (cancel_monoid pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_88437 (h0 : functor.add_const (group (add_cancel_monoid Type)) (has_add (has_add pos))) : @is_simple_group.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (add_cancel_monoid.{1} Type)) (has_add.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_88438 (h0 : group (monoid ennreal)) : normalizer_condition (monoid ennreal) := sorry --non-trivial
lemma new_lemma_88439 (h6 : topological_space linarith.ineq) : t0_space linarith.ineq := sorry --non-trivial
lemma new_lemma_88440 (h0 : ring (mul_zero_class (semigroup Type))) : is_principal_ideal_ring (mul_zero_class (semigroup Type)) := sorry --non-trivial
lemma new_lemma_88441 (h0 : not (complete_lattice (partial_order empty) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (partial_order.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (partial_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_88442 (h0 : topological_space (has_Inf (has_Inf Type))) : discrete_topology (has_Inf (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_88443 (h0 : complete_lattice (has_append linarith.comp_source)) : is_compactly_generated (has_append linarith.comp_source) := sorry --non-trivial
lemma new_lemma_88444 (h2 : ring (semi_normed_ring string_imp)) : strong_rank_condition (semi_normed_ring string_imp) := sorry --non-trivial
lemma new_lemma_88445 (h0 : topological_space (measurable_space (has_inv linarith.comp_source))) : totally_separated_space (measurable_space (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_88446 (h0 : group (complete_distrib_lattice (comm_group pos))) : is_simple_group (complete_distrib_lattice (comm_group pos)) := sorry --non-trivial
lemma new_lemma_88447 (h0 : topological_space (finset (finset (finset Type)))) : locally_compact_space (finset (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_88448 (h0 : functor.add_const (complete_lattice (free_add_monoid empty)) congr_arg_kind) : @is_compactly_generated.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (free_add_monoid.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_88449 (h0 : ulower (fin has_zero.zero)) (h1 : pnat) : pnat.coprime (matrix.vec_empty (ulower.up h0)) h1 := sorry --non-trivial
lemma new_lemma_88450 (h0 : functor.add_const (list (has_add name)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_88451 (h0 : ring (random_gen (metric_space to_additive.value_type))) : strong_rank_condition (random_gen (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_88452 (h0 : functor.add_const (topological_space (complete_distrib_lattice environment.implicit_infer_kind)) linarith.comp) : @t1_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_88453 (h0 : ordered_comm_monoid (has_add (has_to_string pos))) : has_exists_mul_of_le (has_add (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_88454 (h1 : add_group (with_zero char)) : is_add_cyclic (with_zero char) := sorry --non-trivial
lemma new_lemma_88455 (h0 : topological_space (with_one (semiring unsigned))) : locally_compact_space (with_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_88456 (h0 : topological_space (mul_zero_class (has_neg (has_neg pos)))) : t1_space (mul_zero_class (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_88457 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_88458 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_88459 (h0 : ordered_comm_monoid (complete_distrib_lattice (finset linarith.comp))) : has_exists_mul_of_le (complete_distrib_lattice (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_88460 (h0 : functor.add_const (filter (boolean_algebra linarith.comp)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_88461 (h0 : topological_space (has_to_string (has_add environment.implicit_infer_kind))) : sequential_space (has_to_string (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_88462 (h0 : uniform_space (semigroup (mul_one_class pos))) : complete_space (semigroup (mul_one_class pos)) := sorry --non-trivial
lemma new_lemma_88463 (h0 : topological_space (linear_ordered_semiring (semiring linarith.comp))) : locally_compact_space (linear_ordered_semiring (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_88464 (h0 : semiring (finset (boolean_algebra Type))) : is_noetherian_ring (finset (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_88465 (h0 : function.extfun Type ring) : @rank_condition.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_88466 (h0 : functor.add_const (function.extfun Type topological_space) (has_to_string pos)) : @regular_space.{0} (has_nndist.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_to_string.{0} pos) h0) (has_nndist.{0} real))  := sorry --non-trivial
lemma new_lemma_88467 (h0 : topological_space (has_compl fun_info)) (h1 : preorder (has_compl fun_info)) : order_closed_topology (has_compl fun_info) := sorry --non-trivial
lemma new_lemma_88468 (h0 : topological_space (normed_linear_ordered_group (semiring empty))) : totally_separated_space (normed_linear_ordered_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_88469 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_88470 (h0 : complete_lattice (add_left_cancel_semigroup unsigned)) : is_atomistic (add_left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_88471 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_88472 (h0 : not (complete_lattice (has_star unsigned) -> false)) : @is_atomistic.{0} (has_star.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_star.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_88473 (h0 : topological_space (non_assoc_semiring (semiring empty))) : irreducible_space (non_assoc_semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_88474 (h0 : has_mem.mem (with_bot linarith.comp) has_emptyc.emptyc) : @totally_disconnected_space.{0} (with_bot.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_88475 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_88476 (h0 : function.extfun nat fin) : @archimedean.{0} (ordered_comm_ring.{0} linarith.comp) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (ordered_comm_ring.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_88477 (h0 : uniform_space (add_cancel_comm_monoid (semiring (semiring empty)))) : complete_space (add_cancel_comm_monoid (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_88478 (h0 : functor.add_const (topological_space (finset unsigned)) name) : @preconnected_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_88479 (h0 : functor.add_const (topological_space (comm_group unsigned)) name) : @totally_separated_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_88480 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @t0_space.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_88481 (h0 : topological_space (normed_comm_ring (ring unsigned))) : t0_space (normed_comm_ring (ring unsigned)) := sorry --non-trivial
lemma new_lemma_88482 (h0 : functor.add_const (group (normed_comm_ring name)) (has_add Type)) : @is_cyclic.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 1} (group.{0} (normed_comm_ring.{0} name)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_88483 (h0 : semiring (has_to_string (comm_group Type))) : is_noetherian_ring (has_to_string (comm_group Type)) := sorry --non-trivial
lemma new_lemma_88484 (h1 : topological_space (distrib (random_gen char))) : path_connected_space (distrib (random_gen char)) := sorry --non-trivial
lemma new_lemma_88485 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) environment.implicit_infer_kind) : @preconnected_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_88486 (h0 : topological_space (dlist to_additive.value_type)) : t0_space (dlist to_additive.value_type) := sorry --non-trivial
lemma new_lemma_88487 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_88488 (h0 : topological_space (has_nndist (option num))) : t0_space (has_nndist (option num)) := sorry --non-trivial
lemma new_lemma_88489 (h0 : group (has_zero (has_to_string (comm_group pos)))) : normalizer_condition (has_zero (has_to_string (comm_group pos))) := sorry --non-trivial
lemma new_lemma_88490 (h1 : has_mem.mem (complete_semilattice_Sup congr_arg_kind) has_emptyc.emptyc) : @strong_rank_condition.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type ring.{0} (complete_semilattice_Sup.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_88491 (h0 : functor.add_const (ring (linear_order unsigned)) empty) : @is_principal_ideal_ring.{0} (linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (linear_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_88492 (h0 : function.extfun Type group) : @group.fg.{0} (has_ssubset.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (has_ssubset.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_88493 (h0 : ring (ordered_comm_ring real)) : rank_condition (ordered_comm_ring real) := sorry --non-trivial
lemma new_lemma_88494 (h0 : cancel_comm_monoid_with_zero (free_add_monoid (semiring num))) : unique_factorization_monoid (free_add_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_88495 (h0 : topological_space (cancel_monoid (has_to_string pos))) : totally_disconnected_space (cancel_monoid (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_88496 (h0 : functor.add_const (topological_space (cancel_monoid pos)) (semigroup (comm_group Type))) : @t1_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} pos)) (semigroup.{1} (comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_88497 (h0 : function.extfun Type (functor.comp topological_space semigroup)) : @preirreducible_space.{0} (semigroup.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} semigroup.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_88498 (h1 : complete_lattice (fintype (comm_ring (random_gen char)))) : complete_lattice.is_Sup_finite_compact (fintype (comm_ring (random_gen char))) := sorry --non-trivial
lemma new_lemma_88499 (h0 : functor.add_const (group pos) unsigned) : @is_simple_group.{0} pos (@functor.add_const.run.{0 0} (group.{0} pos) unsigned h0)  := sorry --non-trivial
lemma new_lemma_88500 (h0 : functor.add_const (topological_space (has_pos_part name)) pos) : @locally_compact_space.{0} (has_pos_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_88501 (h1 : topological_space linarith.ineq) : totally_separated_space linarith.ineq := sorry --non-trivial
lemma new_lemma_88502 (h0 : complete_lattice (has_union (semiring linarith.comp))) : is_atomistic (has_union (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_88503 (h0 : add_group (normed_group (has_top linarith.comp))) : is_add_cyclic (normed_group (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_88504 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_88505 (h0 : function.extfun (Type 1) monoid) : @monoid.fg.{1} (has_bot.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} h0 (has_bot.{1} Type))  := sorry --non-trivial
lemma new_lemma_88506 (h0 : topological_space (semigroup (semiring (semiring empty)))) : locally_compact_space (semigroup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_88507 (h0 : ring (cancel_monoid (option unsigned))) : is_domain (cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_88508 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring Type)) (has_to_string name)) : @normal_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) (has_to_string.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_88509 (h0 : topological_space (has_nndist (has_add (has_add ennreal)))) : locally_compact_space (has_nndist (has_add (has_add ennreal))) := sorry --non-trivial
lemma new_lemma_88510 (h0 : monoid (has_norm (semiring empty))) : monoid.fg (has_norm (semiring empty)) := sorry --non-trivial
lemma new_lemma_88511 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_88512 (h0 : function.extfun (Type 1) cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} h0 (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_88513 (h0 : functor.add_const (semiring (has_neg name)) pos) : @is_noetherian_ring.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (has_neg.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_88514 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (as_linear_order.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (as_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_88515 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_88516 (h1 : measurable_space char) (h2 : topological_space char) (h3 : measure_theory.measure char) : measure_theory.measure.regular h3 := sorry --non-trivial
lemma new_lemma_88517 (h0 : functor.comp topological_space has_neg pos) : @irreducible_space.{0} (has_neg.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_88518 (h0 : uniform_space (add_cancel_comm_monoid congr_arg_kind)) : separated_space (add_cancel_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_88519 (h0 : complete_lattice (boolean_algebra (comm_group name))) : complete_lattice.is_Sup_finite_compact (boolean_algebra (comm_group name)) := sorry --non-trivial
lemma new_lemma_88520 (h0 : functor.add_const (topological_space (finset ennreal)) num) : @irreducible_space.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_88521 (h0 : cancel_monoid ennreal -> cancel_monoid ennreal -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_88522 (h0 : topological_space (has_ssubset char)) : totally_disconnected_space (has_ssubset char) := sorry --non-trivial
lemma new_lemma_88523 (h0 : topological_space (has_nndist (has_neg_part pos))) : totally_disconnected_space (has_nndist (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_88524 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normalizer_condition.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_88525 (h0 : ordered_comm_monoid (comm_group (cancel_monoid pos))) : has_exists_mul_of_le (comm_group (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_88526 (h0 : topological_space (with_one (complete_semilattice_Sup (measurable_space empty)))) : irreducible_space (with_one (complete_semilattice_Sup (measurable_space empty))) := sorry --non-trivial
lemma new_lemma_88527 (h1 : topological_space (comm_ring to_additive.value_type)) : path_connected_space (comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_88528 (h0 : finset (finset (has_Inf (finset linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_88529 (h0 : ring (has_div (uniform_space (mul_one_class enat)))) : strong_rank_condition (has_div (uniform_space (mul_one_class enat))) := sorry --non-trivial
lemma new_lemma_88530 (h0 : functor.add_const (function.extfun Type semiring) environment.implicit_infer_kind) : @is_noetherian_ring.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) environment.implicit_infer_kind h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_88531 (h0 : functor.add_const (function.extfun (Type 1) cancel_comm_monoid_with_zero) (ring Type)) : @unique_factorization_monoid.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1}) (ring.{1} Type) h0) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_88532 (h0 : topological_space (nondiscrete_normed_field (add_comm_semigroup linarith.ineq))) (h1 : set (nondiscrete_normed_field (add_comm_semigroup linarith.ineq))) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_88533 (h0 : functor.add_const (complete_lattice (add_cancel_monoid unsigned)) pos) : @is_compactly_generated.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_88534 (h0 : topological_space (add_right_cancel_monoid (semiring empty))) : irreducible_space (add_right_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_88535 (h0 : complete_lattice (distrib_lattice (random_gen (random_gen (random_gen char))))) : complete_lattice.is_Sup_finite_compact (distrib_lattice (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_88536 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @regular_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_88537 (h0 : group (option (partial_order (complete_linear_order empty)))) : group.fg (option (partial_order (complete_linear_order empty))) := sorry --non-trivial
lemma new_lemma_88538 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_88539 (h0 : not (group (random_gen linarith.comp_source) -> false)) : @group.fg.{0} (random_gen.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (random_gen.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_88540 (h0 : topological_space (random_gen (has_inv fun_info))) : locally_compact_space (random_gen (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_88541 (h0 : group (semiring (random_gen num))) : normalizer_condition (semiring (random_gen num)) := sorry --non-trivial
lemma new_lemma_88542 (h0 : topological_space (has_nndist (finset pos))) : path_connected_space (has_nndist (finset pos)) := sorry --non-trivial
lemma new_lemma_88543 (h0 : add_group (uniform_space (mul_one_class char))) : is_add_cyclic (uniform_space (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_88544 (h0 : function.extfun Type ring) : @is_domain.{0} (distrib_lattice.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (distrib_lattice.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_88545 (h0 : finset (semigroup (has_neg (has_zero linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_88546 (h0 : topological_space (semiring linarith.comp_source)) : path_connected_space (semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_88547 (h0 : complete_lattice (normed_group (random_gen string_imp))) : is_compactly_generated (normed_group (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_88548 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_88549 (h0 : filter (id (has_norm (has_norm congr_arg_kind)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_88550 (h0 : add_monoid (has_to_string (option pos))) : add_monoid.fg (has_to_string (option pos)) := sorry --non-trivial
lemma new_lemma_88551 (h0 : add_group (add_semigroup (option empty))) : is_add_cyclic (add_semigroup (option empty)) := sorry --non-trivial
lemma new_lemma_88552 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (add_right_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_right_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_88553 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_88554 (h0 : functor.add_const (topological_space (has_to_string environment.implicit_infer_kind)) pos) : @irreducible_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_88555 (h0 : function.extfun Type group) : @group.fg.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_88556 (h0 : uniform_space (has_emptyc (has_top (has_top num)))) : complete_space (has_emptyc (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_88557 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (semigroup ennreal)) := sorry --non-trivial
lemma new_lemma_88558 (h0 : functor.add_const (group (normed_comm_ring unsigned)) Type) : @group.fg.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 1} (group.{0} (normed_comm_ring.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_88559 (h0 : functor.add_const (topological_space (comm_group unsigned)) pos) : @discrete_topology.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_88560 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_88561 (h0 : function.extfun (finset Type) (has_mem.mem (complete_semilattice_Sup linarith.comp))) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} linarith.comp) (@finset.pi.empty.{1 0} Type add_group.{0} (complete_semilattice_Sup.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_88562 (h0 : has_mem.mem (normed_group num) has_emptyc.emptyc) : @normalizer_condition.{0} (normed_group.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (normed_group.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_88563 (h0 : functor.add_const (fin has_zero.zero) (has_Inf Type)) : @separated_space.{0} (canonically_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (canonically_ordered_monoid.{0} real)) (@functor.add_const.run.{0 1} (fin (@has_zero.zero.{0} nat nat.has_zero)) (has_Inf.{1} Type) h0))  := sorry --non-trivial
lemma new_lemma_88564 (h0 : topological_space (add_cancel_monoid (has_add (comm_group (comm_group name))))) : preirreducible_space (add_cancel_monoid (has_add (comm_group (comm_group name)))) := sorry --non-trivial
lemma new_lemma_88565 (h0 : uniform_space (normed_comm_ring (ring (finset linarith.comp)))) : complete_space (normed_comm_ring (ring (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_88566 (h0 : has_zero (has_zero (has_to_string ennreal)) -> has_zero (has_zero (has_to_string ennreal)) -> Prop) : is_per (has_zero (has_zero (has_to_string ennreal))) h0 := sorry --non-trivial
lemma new_lemma_88567 (h0 : ring (has_add (has_neg_part linarith.comp))) : rank_condition (has_add (has_neg_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_88568 (h0 : ordered_comm_monoid (add_cancel_monoid (has_add (add_comm_monoid Type)))) : has_exists_mul_of_le (add_cancel_monoid (has_add (add_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_88569 (h0 : uniform_space (has_ssubset environment.projection_info)) : complete_space (has_ssubset environment.projection_info) := sorry --non-trivial
lemma new_lemma_88570 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (left_cancel_monoid.{0} (semiring.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} (semiring.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_88571 (h0 : topological_space (has_nndist (has_add (has_add pos)))) : t0_space (has_nndist (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_88572 (h0 : function.extfun Type topological_space) : @t1_space.{0} (linear_ordered_cancel_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_88573 (h0 : not (filter (non_assoc_semiring num) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_88574 (h0 : ordered_comm_monoid (has_to_string Type)) : has_exists_mul_of_le (has_to_string Type) := sorry --non-trivial
lemma new_lemma_88575 (h0 : topological_space (add_group (has_norm empty))) : t0_space (add_group (has_norm empty)) := sorry --non-trivial
lemma new_lemma_88576 (h0 : add_group (topological_space (random_gen (random_gen string_imp)))) : is_add_cyclic (topological_space (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_88577 (h1 : topological_space (comm_ring (random_gen (random_gen char)))) : t0_space (comm_ring (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_88578 (h0 : ring (has_top (has_norm empty))) : rank_condition (has_top (has_norm empty)) := sorry --non-trivial
lemma new_lemma_88579 (h0 : functor.add_const (topological_space (ordered_ring empty)) congr_arg_kind) : @irreducible_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_88580 (h1 : group (id fun_info)) : group.fg (id fun_info) := sorry --non-trivial
lemma new_lemma_88581 (h0 : functor.add_const (functor.add_const (topological_space nnreal) num) empty) : t0_space nnreal := sorry --non-trivial
lemma new_lemma_88582 (h0 : not (semiring (add_right_cancel_monoid congr_arg_kind) -> false)) : @is_noetherian_ring.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (semiring.{0} (add_right_cancel_monoid.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_88583 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra linarith.comp)) (has_Inf linarith.comp)) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.{0} linarith.comp)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_88584 (h0 : function.extfun (Type 1) filter) : filter.ne_bot (function.extfun_app h0 (canonically_ordered_comm_semiring Type)) := sorry --non-trivial
lemma new_lemma_88585 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (ring num)) := sorry --non-trivial
lemma new_lemma_88586 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_88587 (h0 : topological_space (ring (has_add environment.implicit_infer_kind))) : normal_space (ring (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_88588 (h0 : add_monoid (canonically_ordered_monoid (has_add pos))) : add_monoid.fg (canonically_ordered_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_88589 (h0 : functor.add_const (ring (has_star empty)) num) : @rank_condition.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (has_star.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_88590 (h0 : add_group (with_bot (semiring (semiring num)))) : is_add_cyclic (with_bot (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_88591 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} pos (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) pos)  := sorry --non-trivial
lemma new_lemma_88592 (h0 : functor.add_const (topological_space (complete_distrib_lattice unsigned)) Type) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_88593 (h1 : not (ring (add_monoid fun_info) -> false)) : @strong_rank_condition.{0} (add_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (add_monoid.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_88594 (h0 : group (boolean_algebra (has_neg Type))) : is_cyclic (boolean_algebra (has_neg Type)) := sorry --non-trivial
lemma new_lemma_88595 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) linarith.comp) : @sequential_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_88596 (h0 : functor.add_const (ring (has_neg_part Type)) pos) : @strong_rank_condition.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_neg_part.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_88597 (h0 : topological_space (measurable_space.dynkin_system empty)) : path_connected_space (measurable_space.dynkin_system empty) := sorry --non-trivial
lemma new_lemma_88598 (h0 : uniform_space (canonically_ordered_monoid (has_bot (has_bot pos)))) : complete_space (canonically_ordered_monoid (has_bot (has_bot pos))) := sorry --non-trivial
lemma new_lemma_88599 (h0 : topological_space (semi_normed_ring (mul_one_class (mul_one_class linarith.ineq)))) : t0_space (semi_normed_ring (mul_one_class (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_88600 (h0 : functor.add_const (ordered_add_comm_monoid (has_nndist linarith.comp)) (has_neg Type)) : @archimedean.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_nndist.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_88601 (h1 : filter (has_add (has_inv linarith.ineq))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_88602 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @regular_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_88603 (h0 : topological_space (linear_ordered_comm_group_with_zero (mul_one_class linarith.ineq))) : path_connected_space (linear_ordered_comm_group_with_zero (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_88604 (h0 : functor.add_const (semiring (sub_neg_monoid pos)) pos) : @is_noetherian_ring.{0} (sub_neg_monoid.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (sub_neg_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_88605 (h0 : topological_space (has_nndist (normed_comm_ring Type))) : loc_path_connected_space (has_nndist (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_88606 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (bin_tree.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_88607 (h0 : topological_space (has_zero (finset (has_neg pos)))) : sequential_space (has_zero (finset (has_neg pos))) := sorry --non-trivial
lemma new_lemma_88608 (h0 : group (pseudo_metric_space name)) : group.fg (pseudo_metric_space name) := sorry --non-trivial
lemma new_lemma_88609 (h0 : topological_space (linear_ordered_comm_group (option pos))) : locally_compact_space (linear_ordered_comm_group (option pos)) := sorry --non-trivial
lemma new_lemma_88610 (h0 : topological_space (add_comm_semigroup enat)) (h1 : set (add_comm_semigroup enat)) : is_closed h1 := sorry --non-trivial
lemma new_lemma_88611 (h0 : list (has_add (has_add (has_neg pos)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_88612 (h0 : functor.add_const (uniform_space (cancel_monoid pos)) linarith.comp) : @separated_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (cancel_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_88613 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @locally_compact_space.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_88614 (h0 : topological_space (as_linear_order unsigned)) : path_connected_space (as_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_88615 (h0 : topological_space (ordered_comm_monoid (has_add real))) : sequential_space (ordered_comm_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_88616 (h0 : add_monoid (semiring num)) : add_monoid.fg (semiring num) := sorry --non-trivial
lemma new_lemma_88617 (h0 : monoid (ordered_comm_ring linarith.comp)) : monoid.fg (ordered_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_88618 (h0 : functor.add_const (topological_space (has_add pos)) Type) : @path_connected_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_88619 (h0 : ring (cancel_monoid Type)) : is_principal_ideal_ring (cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_88620 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_88621 (h0 : uniform_space (ordered_comm_ring (finset Type))) : separated_space (ordered_comm_ring (finset Type)) := sorry --non-trivial
lemma new_lemma_88622 (h0 : prod (group_with_zero congr_arg_kind) (group_with_zero congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_88623 (h0 : topological_space (normed_comm_ring (boolean_algebra (has_add linarith.comp)))) : loc_path_connected_space (normed_comm_ring (boolean_algebra (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_88624 (h0 : functor.add_const (topological_space (has_nndist pos)) (mul_one_class Type)) : @irreducible_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} pos)) (mul_one_class.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_88625 (h0 : topological_space (finset (mul_one_class linarith.comp))) : totally_disconnected_space (finset (mul_one_class linarith.comp)) := sorry --non-trivial
lemma new_lemma_88626 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_88627 (h0 : functor.add_const (list (option num)) (semiring (semiring (semiring (semiring (semiring empty)))))) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_88628 (h1 : add_group (with_bot to_additive.value_type)) : is_add_cyclic (with_bot to_additive.value_type) := sorry --non-trivial
lemma new_lemma_88629 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) linarith.comp) : @loc_path_connected_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_88630 (h1 : topological_space to_additive.value_type) : discrete_topology to_additive.value_type := sorry --non-trivial
lemma new_lemma_88631 (h0 : topological_space (monoid (option ennreal))) : locally_compact_space (monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_88632 (h0 : functor.add_const (topological_space znum) num) : @preirreducible_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) num h0)  := sorry --non-trivial
lemma new_lemma_88633 (h0 : functor.add_const (topological_space (add_left_cancel_semigroup empty)) empty) : @t1_space.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_88634 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (ring pos)) := sorry --non-trivial
lemma new_lemma_88635 (h0 : complete_lattice (linear_ordered_semiring (has_top (has_top num)))) : is_compactly_generated (linear_ordered_semiring (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_88636 (h0 : ring (topological_space char)) : rank_condition (topological_space char) := sorry --non-trivial
lemma new_lemma_88637 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_88638 (h1 : ring (ordered_comm_ring linarith.comp_source)) : strong_rank_condition (ordered_comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_88639 (h0 : function.extfun Type topological_space) : @normal_space.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_88640 (h0 : functor.add_const (functor.add_const Prop Type) unsigned) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_88641 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @rank_condition.{0} empty (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) empty)  := sorry --non-trivial
lemma new_lemma_88642 (h0 : uniform_space (comm_group environment.implicit_infer_kind)) : complete_space (comm_group environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_88643 (h0 : function.extfun (Type 1) filter) : filter.ne_bot (function.extfun_app h0 (plift (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_88644 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf (sub_neg_monoid (has_add real))))) : locally_compact_space (canonically_linear_ordered_monoid (has_Inf (sub_neg_monoid (has_add real)))) := sorry --non-trivial
lemma new_lemma_88645 (h0 : add_group (has_compl (random_gen string_imp))) : is_add_cyclic (has_compl (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_88646 (h0 : ring (has_add linarith.ineq)) : rank_condition (has_add linarith.ineq) := sorry --non-trivial
lemma new_lemma_88647 (h0 : topological_space (semiring (semiring unsigned))) : preirreducible_space (semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_88648 (h0 : filter (normed_comm_ring (comm_group (comm_group name)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_88649 (h0 : uniform_space (has_emptyc linarith.comp_source)) : complete_space (has_emptyc linarith.comp_source) := sorry --non-trivial
lemma new_lemma_88650 (h0 : topological_space (monoid num)) : irreducible_space (monoid num) := sorry --non-trivial
lemma new_lemma_88651 (h0 : prod (has_norm (semiring empty)) (has_norm (semiring empty))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_88652 (h0 : ring (has_neg name)) : is_domain (has_neg name) := sorry --non-trivial
lemma new_lemma_88653 (h0 : topological_space (add_cancel_monoid (has_add (comm_group name)))) : preirreducible_space (add_cancel_monoid (has_add (comm_group name))) := sorry --non-trivial
lemma new_lemma_88654 (h0 : topological_space (finset Type)) : regular_space (finset Type) := sorry --non-trivial
lemma new_lemma_88655 (h0 : functor.add_const (functor.add_const (group Type) pos) (finset (normed_comm_ring pos))) : @group.fg.{1} Type (@functor.add_const.run.{1 0} (group.{1} Type) pos (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (group.{1} Type) pos) (finset.{0} (normed_comm_ring.{0} pos)) h0))  := sorry --non-trivial
lemma new_lemma_88656 (h0 : functor.add_const (function.extfun Type group) pos) : @group.fg.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_88657 (h0 : functor.add_const (topological_space (add_cancel_monoid empty)) empty) : @totally_separated_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_88658 (h0 : filter (complete_distrib_lattice (option pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_88659 (h0 : uniform_space (finset pos)) : separated_space (finset pos) := sorry --non-trivial
lemma new_lemma_88660 (h0 : finset (semigroup (has_neg linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_88661 (h0 : functor.add_const (function.extfun Type monoid) linarith.comp) : @monoid.fg.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) linarith.comp h0) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_88662 (h0 : not (group (comm_ring char) -> false)) : @is_cyclic.{0} (comm_ring.{0} char) (@classical.by_contradiction'.{1} (group.{0} (comm_ring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_88663 (h0 : topological_space (normed_field (mul_one_class linarith.comp_source))) : path_connected_space (normed_field (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_88664 (h0 : function.extfun (Type 1) topological_space) : @discrete_topology.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_88665 (h0 : functor.add_const (ordered_comm_monoid (normed_comm_ring unsigned)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (normed_comm_ring.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_88666 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) unsigned) : @topological_space.separable_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_88667 (h0 : ring (linear_ordered_comm_ring (semiring (semiring congr_arg_kind)))) : strong_rank_condition (linear_ordered_comm_ring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_88668 (h0 : complete_lattice (has_zero (has_to_string pos))) : is_compactly_generated (has_zero (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_88669 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_88670 (h0 : topological_space (add_right_cancel_monoid empty)) : locally_compact_space (add_right_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_88671 (h0 : uniform_space (complete_linear_order (semiring num))) : complete_space (complete_linear_order (semiring num)) := sorry --non-trivial
lemma new_lemma_88672 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_88673 (h0 : group (complete_linear_order (semiring (semiring empty)))) : group.fg (complete_linear_order (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_88674 (h0 : complete_lattice (has_nnnorm linarith.comp_source)) : is_compactly_generated (has_nnnorm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_88675 (h0 : ring (add_cancel_comm_monoid (has_nnnorm (mul_one_class reducibility_hints)))) : strong_rank_condition (add_cancel_comm_monoid (has_nnnorm (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_88676 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) pos) : @preirreducible_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_88677 (h0 : topological_space (semigroup linarith.comp)) : preconnected_space (semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_88678 (h0 : filter (canonically_ordered_comm_semiring name)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_88679 (h0 : functor.add_const (ordered_add_comm_monoid (add_cancel_monoid pos)) (finset environment.implicit_infer_kind)) : @archimedean.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_cancel_monoid.{0} pos)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_88680 (h0 : ring (complete_semilattice_Sup (has_norm (has_norm empty)))) : rank_condition (complete_semilattice_Sup (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_88681 (h0 : function.extfun nat fin) : @regular_space.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_88682 (h0 : functor.comp topological_space semigroup name) : @sequential_space.{0} (semigroup.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} name h0)  := sorry --non-trivial
lemma new_lemma_88683 (h0 : group (bin_tree (semiring (semiring (semiring (semiring empty)))))) : is_cyclic (bin_tree (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_88684 (h0 : functor.add_const (topological_space (normed_comm_ring name)) linarith.comp) : @irreducible_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_88685 (h0 : topological_space (comm_group (has_zero (finset name)))) : t1_space (comm_group (has_zero (finset name))) := sorry --non-trivial
lemma new_lemma_88686 (h0 : topological_space (ring (has_Inf (finset linarith.comp)))) : topological_space.separable_space (ring (has_Inf (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_88687 (h0 : topological_space (has_zero (has_zero (option (has_add unsigned))))) : t1_space (has_zero (has_zero (option (has_add unsigned)))) := sorry --non-trivial
lemma new_lemma_88688 (h0 : topological_space (boolean_algebra (has_Inf (has_add real)))) : totally_disconnected_space (boolean_algebra (has_Inf (has_add real))) := sorry --non-trivial
lemma new_lemma_88689 (h0 : topological_space (linear_ordered_comm_monoid_with_zero congr_arg_kind)) : locally_compact_space (linear_ordered_comm_monoid_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_88690 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (linear_ordered_semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_88691 (h0 : topological_space (random_gen (has_norm num))) : totally_disconnected_space (random_gen (has_norm num)) := sorry --non-trivial
lemma new_lemma_88692 (h0 : list (encodable (random_gen char))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_88693 (h0 : list (complete_semilattice_Sup linarith.comp_source)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_88694 (h0 : ordered_add_comm_monoid (monoid (option (option unsigned)))) : archimedean (monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_88695 (h0 : ring (comm_ring (random_gen linarith.ineq))) : strong_rank_condition (comm_ring (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_88696 (h0 : topological_space (generalized_boolean_algebra (has_add (semigroup (boolean_algebra.core name))))) : preirreducible_space (generalized_boolean_algebra (has_add (semigroup (boolean_algebra.core name)))) := sorry --non-trivial
lemma new_lemma_88697 (h0 : functor.add_const (topological_space (boolean_algebra.core environment.implicit_infer_kind)) name) : @irreducible_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_88698 (h0 : topological_space (distrib (mul_one_class (mul_one_class (mul_one_class fun_info))))) : path_connected_space (distrib (mul_one_class (mul_one_class (mul_one_class fun_info)))) := sorry --non-trivial
lemma new_lemma_88699 (h0 : function.extfun (finset Type) (has_mem.mem (semiring linarith.comp))) : @totally_disconnected_space.{0} (semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_88700 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_88701 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) linarith.comp) : @t1_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_88702 (h1 : not (group reducibility_hints -> false)) : @is_cyclic.{0} reducibility_hints (@classical.by_contradiction'.{1} (group.{0} reducibility_hints) h1)  := sorry --non-trivial
lemma new_lemma_88703 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_88704 (h0 : uniform_space (has_pos_part (has_Inf (ordered_ring Type)))) : separated_space (has_pos_part (has_Inf (ordered_ring Type))) := sorry --non-trivial
lemma new_lemma_88705 (h0 : functor.add_const (add_monoid (linear_ordered_comm_monoid_with_zero empty)) empty) : @add_monoid.fg.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_88706 (h1 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h1) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_88707 (h0 : function.extfun Type group) : @is_cyclic.{0} (bin_tree.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (bin_tree.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_88708 (h0 : topological_space (has_append (has_nnnorm (has_nnnorm linarith.ineq)))) : t0_space (has_append (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_88709 (h0 : functor.add_const (ring (boolean_algebra environment.implicit_infer_kind)) (has_neg pos)) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_88710 (h0 : functor.add_const (function.extfun Type group) pos) : @normalizer_condition.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_88711 (h0 : monoid (id (has_inv (random_gen (has_inv linarith.comp_source))))) : monoid.fg (id (has_inv (random_gen (has_inv linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_88712 (h0 : complete_lattice (has_add (has_pos_part Type))) : complete_lattice.is_Sup_finite_compact (has_add (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_88713 (h0 : cancel_comm_monoid_with_zero (simple_graph (option (option unsigned)))) : unique_factorization_monoid (simple_graph (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_88714 (h0 : functor.add_const (topological_space (ordered_comm_monoid pos)) linarith.comp) : @path_connected_space.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_88715 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) (has_neg pos)) : @preconnected_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_88716 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) congr_arg_kind) : @t0_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_88717 (h0 : cancel_comm_monoid_with_zero (comm_semigroup (complete_distrib_lattice real))) : unique_factorization_monoid (comm_semigroup (complete_distrib_lattice real)) := sorry --non-trivial
lemma new_lemma_88718 (h0 : functor.add_const (functor.add_const (topological_space auto.case_option) empty) empty) : @path_connected_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} auto.case_option) empty) empty h0))  := sorry --non-trivial
lemma new_lemma_88719 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_inter.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_inter.{0} num))  := sorry --non-trivial
lemma new_lemma_88720 (h0 : not (topological_space (linear_ordered_comm_ring num) -> false)) : @t1_space.{0} (linear_ordered_comm_ring.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_ring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_88721 (h0 : topological_space (has_top (random_gen linarith.ineq))) : path_connected_space (has_top (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_88722 (h3 : topological_space fun_info) (h5 : add_group fun_info) : topological_add_group fun_info := sorry --non-trivial
lemma new_lemma_88723 (h0 : uniform_space (distrib (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) : complete_space (distrib (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_88724 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (partial_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_88725 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_88726 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) environment.implicit_infer_kind) : @preconnected_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_88727 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @irreducible_space.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_88728 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_88729 (h0 : uniform_space (normed_comm_ring unsigned)) : separated_space (normed_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_88730 (h0 : topological_space (has_ssubset (random_gen (random_gen to_additive.value_type)))) : t0_space (has_ssubset (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_88731 (h0 : group (has_union (semiring empty))) : is_cyclic (has_union (semiring empty)) := sorry --non-trivial
lemma new_lemma_88732 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_88733 (h0 : functor.add_const (add_monoid (finset pos)) linarith.comp) : @add_monoid.fg.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (finset.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_88734 (h0 : topological_space (has_to_string name)) : preirreducible_space (has_to_string name) := sorry --non-trivial
lemma new_lemma_88735 (h0 : topological_space stieltjes_function) : locally_compact_space stieltjes_function := sorry --non-trivial
lemma new_lemma_88736 (h1 : filter (has_union linarith.comp)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_88737 (h0 : topological_space (has_pos_part (has_Inf pos))) : regular_space (has_pos_part (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_88738 (h0 : topological_space (has_top (has_top congr_arg_kind))) : totally_separated_space (has_top (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_88739 (h0 : group (has_pos_part (has_add (has_add real)))) : is_simple_group (has_pos_part (has_add (has_add real))) := sorry --non-trivial
lemma new_lemma_88740 (h0 : functor.add_const (topological_space (cancel_monoid Type)) linarith.comp) : @sequential_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_88741 (h0 : functor.add_const (topological_space (cancel_monoid pos)) ennreal) : @t1_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_88742 (h0 : group (finset (has_neg environment.implicit_infer_kind))) : is_simple_group (finset (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_88743 (h0 : functor.add_const (ring (has_neg linarith.comp)) environment.implicit_infer_kind) : @is_domain.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_88744 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_88745 (h0 : not (function.extfun Type ring -> false)) : @is_principal_ideal_ring.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_88746 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (complete_linear_order.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (complete_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_88747 (h0 : complete_lattice (has_Inf (has_add (has_neg Type)))) : is_compactly_generated (has_Inf (has_add (has_neg Type))) := sorry --non-trivial
lemma new_lemma_88748 (h0 : prod (has_inter num) (has_inter num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_88749 (h0 : functor.add_const (ring (plift empty)) unsigned) : @rank_condition.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (ring.{1} (plift.{1} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_88750 (h0 : ring (left_cancel_semigroup (semiring (semiring (semiring unsigned))))) : is_principal_ideal_ring (left_cancel_semigroup (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_88751 (h0 : cancel_comm_monoid_with_zero (normed_lattice_add_comm_group (has_Inf name))) : unique_factorization_monoid (normed_lattice_add_comm_group (has_Inf name)) := sorry --non-trivial
lemma new_lemma_88752 (h0 : functor.add_const (topological_space (ring linarith.comp)) pos) : @t1_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_88753 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @topological_space.separable_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_88754 (h0 : group (cancel_monoid (comm_group (finset (comm_group Type))))) : normalizer_condition (cancel_monoid (comm_group (finset (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_88755 (h0 : topological_space (linear_ordered_comm_ring (semiring (option (semiring empty))))) : t1_space (linear_ordered_comm_ring (semiring (option (semiring empty)))) := sorry --non-trivial
lemma new_lemma_88756 (h0 : complete_lattice (boolean_algebra.core (option unsigned))) : complete_lattice.is_Sup_finite_compact (boolean_algebra.core (option unsigned)) := sorry --non-trivial
lemma new_lemma_88757 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) linarith.comp) : @discrete_topology.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_88758 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) name) : @locally_compact_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_88759 (h0 : filter (canonically_ordered_comm_semiring (has_add unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_88760 (h0 : functor.add_const (ring (left_cancel_monoid empty)) congr_arg_kind) : @rank_condition.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_88761 (h0 : group (canonically_ordered_comm_semiring (finset (has_nndist name)))) : is_simple_group (canonically_ordered_comm_semiring (finset (has_nndist name))) := sorry --non-trivial
lemma new_lemma_88762 (h1 : complete_lattice (fintype (has_ssubset fun_info))) : is_compactly_generated (fintype (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_88763 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_88764 (h0 : complete_lattice (add_comm_monoid (has_neg (has_neg (has_neg pos))))) : is_atomistic (add_comm_monoid (has_neg (has_neg (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_88765 (h0 : group (has_neg_part name)) : group.fg (has_neg_part name) := sorry --non-trivial
lemma new_lemma_88766 (h0 : topological_space (generalized_boolean_algebra name)) : loc_path_connected_space (generalized_boolean_algebra name) := sorry --non-trivial
lemma new_lemma_88767 (h0 : not (complete_lattice (has_one empty) -> false)) : @is_atomistic.{0} (has_one.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_one.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_88768 (h0 : functor.add_const (ring real.angle) empty) : @is_domain.{0} real.angle (@functor.add_const.run.{0 0} (ring.{0} real.angle) empty h0)  := sorry --non-trivial
lemma new_lemma_88769 (h0 : topological_space (monoid num)) : t0_space (monoid num) := sorry --non-trivial
lemma new_lemma_88770 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_88771 (h0 : group (uniform_space to_additive.value_type)) : is_cyclic (uniform_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_88772 (h0 : functor.add_const (group (ordered_comm_ring linarith.comp)) pos) : @is_simple_group.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (ordered_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_88773 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_88774 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_88775 (h0 : finset (add_cancel_monoid empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_88776 (h0 : not (ring (normed_field linarith.ineq) -> false)) : @rank_condition.{0} (normed_field.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (normed_field.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_88777 (h0 : functor.add_const (topological_space (has_Sup unsigned)) empty) : @t1_space.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_88778 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (has_norm.{0} string_imp) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (has_norm.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_88779 (h0 : topological_space (linear_ordered_cancel_comm_monoid (option unsigned))) : t1_space (linear_ordered_cancel_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_88780 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @t0_space.{0} (has_bot.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_88781 (h0 : not (topological_space (has_nnnorm linarith.ineq) -> false)) : @t0_space.{0} (has_nnnorm.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_nnnorm.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_88782 (h0 : topological_space (semigroup (has_add environment.implicit_infer_kind))) : loc_path_connected_space (semigroup (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_88783 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @t1_space.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_88784 (h0 : topological_space (semigroup (has_add Type))) : t1_space (semigroup (has_add Type)) := sorry --non-trivial
lemma new_lemma_88785 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_88786 (h0 : topological_space (boolean_algebra (has_neg (has_neg pos)))) : totally_separated_space (boolean_algebra (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_88787 (h0 : ring (has_top (random_gen (random_gen fun_info)))) : strong_rank_condition (has_top (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_88788 (h0 : uniform_space (has_Inf (has_add pos))) : complete_space (has_Inf (has_add pos)) := sorry --non-trivial
lemma new_lemma_88789 (h0 : topological_space (canonically_linear_ordered_add_monoid (option (option (option unsigned))))) : path_connected_space (canonically_linear_ordered_add_monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_88790 (h0 : topological_space (simple_graph Type)) : totally_separated_space (simple_graph Type) := sorry --non-trivial
lemma new_lemma_88791 (h0 : functor.add_const (monoid (boolean_algebra.core Type)) linarith.comp) : @monoid.fg.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (boolean_algebra.core.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_88792 (h0 : group (has_top (has_norm (dlist (random_gen linarith.ineq))))) : group.fg (has_top (has_norm (dlist (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_88793 (h0 : topological_space (cancel_monoid (cancel_monoid name))) : locally_compact_space (cancel_monoid (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_88794 (h0 : topological_space (ordered_comm_ring (ordered_comm_monoid (has_bot real)))) : t0_space (ordered_comm_ring (ordered_comm_monoid (has_bot real))) := sorry --non-trivial
lemma new_lemma_88795 (h0 : complete_lattice (has_add (random_gen fun_info))) : is_compactly_generated (has_add (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_88796 (h0 : ordered_add_comm_monoid (boolean_algebra.core (has_neg (semigroup linarith.comp)))) : archimedean (boolean_algebra.core (has_neg (semigroup linarith.comp))) := sorry --non-trivial
lemma new_lemma_88797 (h0 : ring (has_to_string (has_add (has_add pos)))) : rank_condition (has_to_string (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_88798 (h0 : not (group (linear_ordered_add_comm_group fun_info) -> false)) : @is_cyclic.{0} (linear_ordered_add_comm_group.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_add_comm_group.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_88799 (h0 : topological_space (complete_distrib_lattice (option unsigned))) : t1_space (complete_distrib_lattice (option unsigned)) := sorry --non-trivial
lemma new_lemma_88800 (h1 : prod (add_comm_semigroup ereal) (add_comm_semigroup ereal)) : set.diagonal (add_comm_semigroup ereal) h1 := sorry --non-trivial
lemma new_lemma_88801 (h0 : topological_space (random_gen string_imp)) : t0_space (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_88802 (h0 : topological_space (partial_order (semiring congr_arg_kind))) : loc_path_connected_space (partial_order (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_88803 (h0 : functor.add_const (group (add_cancel_monoid Type)) environment.implicit_infer_kind) : @is_cyclic.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (add_cancel_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_88804 (h0 : function.extfun Type uniform_space) : complete_space real := sorry --non-trivial
lemma new_lemma_88805 (h0 : functor.add_const (ordered_add_comm_monoid (has_nndist pos)) pos) : @archimedean.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_nndist.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_88806 (h0 : filter (complete_linear_order empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_88807 (h0 h1 : multiset ordering) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_88808 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (add_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_88809 (h0 : topological_space (with_one fun_info)) : totally_separated_space (with_one fun_info) := sorry --non-trivial
lemma new_lemma_88810 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} pos (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) pos)  := sorry --non-trivial
lemma new_lemma_88811 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_88812 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) pos) : @totally_separated_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_88813 (h0 : functor.add_const (function.extfun Type ring) (finset (finset pos))) : @is_domain.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (finset.{0} (finset.{0} pos)) h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_88814 (h0 : complete_lattice (measurable_space (random_gen to_additive.value_type))) : is_atomistic (measurable_space (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_88815 (h1 : not (ring (has_emptyc to_additive.value_type) -> false)) : @strong_rank_condition.{0} (has_emptyc.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (has_emptyc.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_88816 (h0 : functor.add_const (topological_space (normed_comm_ring ennreal)) num) : @t0_space.{0} (normed_comm_ring.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_88817 (h0 : complete_lattice (has_ssubset (comm_ring char))) (h1 : option (complete_lattice (has_ssubset (comm_ring char)))) : is_compactly_generated (has_ssubset (comm_ring char)) := sorry --non-trivial
lemma new_lemma_88818 (h0 : group (bin_tree num)) : is_cyclic (bin_tree num) := sorry --non-trivial
lemma new_lemma_88819 (h0 : functor.add_const (topological_space (as_linear_order unsigned)) empty) : @normal_space.{0} (as_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (as_linear_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_88820 (h0 : add_group (add_cancel_comm_monoid char)) : is_add_cyclic (add_cancel_comm_monoid char) := sorry --non-trivial
lemma new_lemma_88821 (h0 : topological_space (simple_graph linarith.comp)) : regular_space (simple_graph linarith.comp) := sorry --non-trivial
lemma new_lemma_88822 (h0 : ring (comm_monoid (option empty))) : is_principal_ideal_ring (comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_88823 (h0 : topological_space (finset (finset (finset pos)))) : locally_compact_space (finset (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_88824 (h0 : complete_lattice (normed_comm_ring (add_cancel_monoid environment.implicit_infer_kind))) : is_atomistic (normed_comm_ring (add_cancel_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_88825 (h0 : not (topological_space (normed_group nnreal) -> false)) : @preirreducible_space.{0} (normed_group.{0} nnreal) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} nnreal)) h0)  := sorry --non-trivial
lemma new_lemma_88826 (h0 : group (boolean_algebra (has_neg (finset pos)))) : normalizer_condition (boolean_algebra (has_neg (finset pos))) := sorry --non-trivial
lemma new_lemma_88827 (h0 : functor.add_const (uniform_space (measurable_space.dynkin_system empty)) (semiring num)) : @separated_space.{0} (measurable_space.dynkin_system.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (measurable_space.dynkin_system.{0} empty)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_88828 (h0 : topological_space (linear_ordered_cancel_comm_monoid congr_arg_kind)) : normal_space (linear_ordered_cancel_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_88829 (h0 : group (semi_normed_comm_ring char)) : is_cyclic (semi_normed_comm_ring char) := sorry --non-trivial
lemma new_lemma_88830 (h0 : functor.add_const (finset (normed_comm_ring unsigned)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_88831 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (has_neg name)) : @irreducible_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_88832 (h0 : topological_space (comm_group real)) : preirreducible_space (comm_group real) := sorry --non-trivial
lemma new_lemma_88833 (h0 : fin has_zero.zero) : @regular_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_88834 (h1 : complete_lattice (with_one linarith.ineq)) : is_compactly_generated (with_one linarith.ineq) := sorry --non-trivial
lemma new_lemma_88835 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (bin_tree congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_88836 (h0 : not (ring (random_gen (random_gen linarith.comp_source)) -> false)) : @is_domain.{0} (random_gen.{0} (random_gen.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} (random_gen.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_88837 (h0 : not (list (has_nnnorm to_additive.value_type) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_88838 (h0 : add_group (boolean_algebra.core (option empty))) : is_add_cyclic (boolean_algebra.core (option empty)) := sorry --non-trivial
lemma new_lemma_88839 (h0 : not (list (has_inv to_additive.value_type) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_88840 (h2 : topological_space string_imp) (h3 : set (set string_imp)) : topological_space.is_topological_basis h3 := sorry --non-trivial
lemma new_lemma_88841 (h0 : ring (has_union (has_norm empty))) : rank_condition (has_union (has_norm empty)) := sorry --non-trivial
lemma new_lemma_88842 (h0 : topological_space (has_inner (option empty) unsigned)) : irreducible_space (has_inner (option empty) unsigned) := sorry --non-trivial
lemma new_lemma_88843 (h0 : group (normed_group (random_gen linarith.comp_source))) : normalizer_condition (normed_group (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_88844 (h1 : add_group (topological_space (has_nnnorm (has_nnnorm char)))) : is_add_cyclic (topological_space (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_88845 (h0 : topological_space (boolean_algebra.core (comm_group environment.implicit_infer_kind))) : irreducible_space (boolean_algebra.core (comm_group environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_88846 (h0 : functor.add_const (topological_space (canonically_ordered_monoid linarith.comp)) (finset name)) : @regular_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_monoid.{0} linarith.comp)) (finset.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_88847 (h0 : group (option pos)) : is_simple_group (option pos) := sorry --non-trivial
lemma new_lemma_88848 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_88849 (h0 : group (has_compl (random_gen (has_nnnorm to_additive.value_type)))) : is_cyclic (has_compl (random_gen (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_88850 (h0 : functor.add_const (complete_lattice (canonically_ordered_comm_semiring empty)) empty) : @is_compactly_generated.{0} (canonically_ordered_comm_semiring.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_ordered_comm_semiring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_88851 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (with_one.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_88852 (h0 : not (topological_space (plift congr_arg_kind) -> false)) : @normal_space.{1} (plift.{1} congr_arg_kind) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_88853 (h0 : group (has_zero (comm_group Type))) : is_simple_group (has_zero (comm_group Type)) := sorry --non-trivial
lemma new_lemma_88854 (h0 : add_group (has_neg_part pos)) : is_add_cyclic (has_neg_part pos) := sorry --non-trivial
lemma new_lemma_88855 (h0 : topological_space (has_add (fintype (fintype (div_inv_monoid linarith.comp_source))))) : t0_space (has_add (fintype (fintype (div_inv_monoid linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_88856 (h0 : monoid (normed_comm_ring (has_add Type))) : monoid.fg (normed_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_88857 (h0 : topological_space (has_top (semiring (semiring linarith.comp)))) : totally_separated_space (has_top (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_88858 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (linear_ordered_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (linear_ordered_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_88859 (h0 : functor.add_const (group (has_Sup num)) congr_arg_kind) : @group.fg.{0} (has_Sup.{0} num) (@functor.add_const.run.{0 0} (group.{0} (has_Sup.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_88860 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_cyclic.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (group.{1} (sub_neg_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_88861 (h0 : ring (ordered_comm_ring (has_add (has_add (has_add pos))))) : strong_rank_condition (ordered_comm_ring (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_88862 (h0 : functor.add_const (topological_space (comm_group unsigned)) linarith.comp) : @normal_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_88863 (h0 : ring (normed_comm_ring empty)) : rank_condition (normed_comm_ring empty) := sorry --non-trivial
lemma new_lemma_88864 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_88865 (h0 : cancel_comm_monoid_with_zero (has_pos_part (has_neg Type))) : unique_factorization_monoid (has_pos_part (has_neg Type)) := sorry --non-trivial
lemma new_lemma_88866 (h0 : cancel_comm_monoid_with_zero (has_inter num)) : unique_factorization_monoid (has_inter num) := sorry --non-trivial
lemma new_lemma_88867 (h0 : list (pseudo_metric_space (add_comm_monoid (add_comm_monoid pos)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_88868 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (random_gen.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (random_gen.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_88869 (h0 : add_group (measurable_space string_imp)) : is_add_cyclic (measurable_space string_imp) := sorry --non-trivial
lemma new_lemma_88870 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (encodable linarith.ineq)) := sorry --non-trivial
lemma new_lemma_88871 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf (has_neg Type)))) : regular_space (normed_lattice_add_comm_group (has_Inf (has_neg Type))) := sorry --non-trivial
lemma new_lemma_88872 (h0 : fin has_zero.zero) : @is_domain.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (ordered_comm_ring.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))))  := sorry --non-trivial
lemma new_lemma_88873 (h0 : functor.add_const (add_monoid nnreal) congr_arg_kind) : add_monoid.fg nnreal := sorry --non-trivial
lemma new_lemma_88874 (h0 : topological_space (comm_ring string_imp)) : t0_space (comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_88875 (h0 : group (normed_group (has_inv (has_inv (has_inv (random_gen linarith.comp_source)))))) : group.fg (normed_group (has_inv (has_inv (has_inv (random_gen linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_88876 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc congr_arg_kind))) : @separated_space.{0} (has_emptyc.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_88877 (h0 : topological_space (simple_graph (mul_one_class string_imp))) : path_connected_space (simple_graph (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_88878 (h0 : topological_space (has_one (has_norm num))) : locally_compact_space (has_one (has_norm num)) := sorry --non-trivial
lemma new_lemma_88879 (h0 : function.extfun Type (functor.add_const (topological_space (has_neg linarith.comp)))) : @preconnected_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp))) h0 (has_neg.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_88880 (h0 : functor.add_const (topological_space (normed_linear_ordered_group num)) (option empty)) : @path_connected_space.{0} (normed_linear_ordered_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} num)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_88881 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (add_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_88882 (h0 : uniform_space (div_inv_monoid char)) : complete_space (div_inv_monoid char) := sorry --non-trivial
lemma new_lemma_88883 (h0 : functor.add_const (group (boolean_algebra.core pos)) name) : @is_simple_group.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.core.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_88884 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_88885 (h0 : topological_space (add_cancel_comm_monoid (random_gen (comm_ring linarith.comp_source)))) : totally_disconnected_space (add_cancel_comm_monoid (random_gen (comm_ring linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_88886 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (linear_ordered_cancel_comm_monoid.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_88887 (h0 : ring (linear_ordered_add_comm_group (random_gen char))) : rank_condition (linear_ordered_add_comm_group (random_gen char)) := sorry --non-trivial
lemma new_lemma_88888 (h0 : function.extfun Type filter) (h1 : option (function.extfun Type filter)) : filter.ne_bot (function.extfun_app (option.lhoare h0 h1) (normed_group empty)) := sorry --non-trivial
lemma new_lemma_88889 (h0 : ring (has_inv char)) : rank_condition (has_inv char) := sorry --non-trivial
lemma new_lemma_88890 (h0 : function.extfun (Type 1) topological_space) : @path_connected_space.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_88891 (h0 : uniform_space (has_one (mul_one_class (mul_one_class (mul_one_class (mul_one_class char)))))) : complete_space (has_one (mul_one_class (mul_one_class (mul_one_class (mul_one_class char))))) := sorry --non-trivial
lemma new_lemma_88892 (h0 : group (group_with_zero unsigned)) : is_simple_group (group_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_88893 (h0 : functor.add_const (topological_space (left_cancel_monoid num)) empty) : @normal_space.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_88894 (h0 : topological_space (add_semigroup congr_arg_kind)) : t1_space (add_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_88895 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (canonically_ordered_comm_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_88896 (h0 : filter (normed_group (semiring (semiring (semiring (semiring unsigned)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_88897 (h0 : group (distrib_lattice string_imp)) : normalizer_condition (distrib_lattice string_imp) := sorry --non-trivial
lemma new_lemma_88898 (h0 : functor.add_const (group (boolean_algebra unsigned)) environment.implicit_infer_kind) : @normalizer_condition.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_88899 (h0 : uniform_space (random_gen (has_nnnorm (has_ssubset linarith.ineq)))) : complete_space (random_gen (has_nnnorm (has_ssubset linarith.ineq))) := sorry --non-trivial
lemma new_lemma_88900 (h0 : complete_lattice (comm_group (option (option pos)))) : complete_lattice.is_Sup_finite_compact (comm_group (option (option pos))) := sorry --non-trivial
lemma new_lemma_88901 (h0 : functor.add_const (topological_space (linear_ordered_comm_monoid_with_zero unsigned)) empty) : @topological_space.separable_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_88902 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) linarith.comp) : @totally_separated_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_88903 (h0 : topological_space (omega_complete_partial_order (option unsigned))) : totally_disconnected_space (omega_complete_partial_order (option unsigned)) := sorry --non-trivial
lemma new_lemma_88904 (h0 : function.extfun Type topological_space) : locally_compact_space nnreal := sorry --non-trivial
lemma new_lemma_88905 (h0 : topological_space (has_neg (option pos))) : irreducible_space (has_neg (option pos)) := sorry --non-trivial
lemma new_lemma_88906 (h0 : complete_lattice (cancel_monoid (option (option ennreal)))) : is_compactly_generated (cancel_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_88907 (h0 : topological_space (preorder num)) : totally_separated_space (preorder num) := sorry --non-trivial
lemma new_lemma_88908 (h0 : ring char) (h1 : not (topological_space (ring.positive_cone char) -> false)) : @path_connected_space.{0} (@ring.positive_cone.{0} char h0) (@classical.by_contradiction'.{1} (topological_space.{0} (@ring.positive_cone.{0} char h0)) h1)  := sorry --non-trivial
lemma new_lemma_88909 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_88910 (h0 : monoid (has_norm (has_inv (has_inv to_additive.value_type)))) : monoid.fg (has_norm (has_inv (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_88911 (h0 : topological_space (measurable_space (semiring (semiring (semiring congr_arg_kind))))) : locally_compact_space (measurable_space (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_88912 (h0 : not (topological_space unsigned -> false)) : @discrete_topology.{0} unsigned (@classical.by_contradiction'.{1} (topological_space.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_88913 (h0 : topological_space (has_one (semiring (semiring fun_info)))) : normal_space (has_one (semiring (semiring fun_info))) := sorry --non-trivial
lemma new_lemma_88914 (h0 : functor.add_const (ring (has_add pos)) (has_Inf (has_Inf linarith.comp))) : @is_domain.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} pos)) (has_Inf.{0} (has_Inf.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_88915 (h0 : monoid (boolean_algebra (has_neg Type))) : monoid.fg (boolean_algebra (has_neg Type)) := sorry --non-trivial
lemma new_lemma_88916 (h0 : topological_space (has_to_string (finset environment.implicit_infer_kind))) : irreducible_space (has_to_string (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_88917 (h0 : ring (ordered_cancel_add_comm_monoid (option (option (option unsigned))))) : rank_condition (ordered_cancel_add_comm_monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_88918 (h0 : group (ordered_comm_monoid (has_Inf real))) : is_simple_group (ordered_comm_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_88919 (h0 : complete_lattice (with_one (has_append (topological_space linarith.ineq)))) : complete_lattice.is_Sup_finite_compact (with_one (has_append (topological_space linarith.ineq))) := sorry --non-trivial
lemma new_lemma_88920 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_88921 (h0 : topological_space (linear_ordered_field (has_to_string congr_arg_kind))) : loc_path_connected_space (linear_ordered_field (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_88922 (h0 : functor.add_const (topological_space (ordered_ring (semiring num))) empty) : @loc_path_connected_space.{0} (ordered_ring.{0} (semiring.{0} num)) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} (semiring.{0} num))) empty h0)  := sorry --non-trivial
lemma new_lemma_88923 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_88924 (h0 : not (ring (semi_normed_comm_ring char) -> false)) : @strong_rank_condition.{0} (semi_normed_comm_ring.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_comm_ring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_88925 (h0 : topological_space (boolean_algebra (finset (has_add linarith.comp)))) : totally_separated_space (boolean_algebra (finset (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_88926 (h0 : list (comm_group (semigroup Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_88927 (h0 : topological_space (has_compl to_additive.value_type)) (h1 : add_group (has_compl to_additive.value_type)) : topological_add_group (has_compl to_additive.value_type) := sorry --non-trivial
lemma new_lemma_88928 (h0 : add_group (mul_one_class (add_comm_semigroup enat))) : is_add_cyclic (mul_one_class (add_comm_semigroup enat)) := sorry --non-trivial
lemma new_lemma_88929 (h0 : topological_space (finset (boolean_algebra.core unsigned))) : t0_space (finset (boolean_algebra.core unsigned)) := sorry --non-trivial
lemma new_lemma_88930 (h0 : not (ring (with_one linarith.ineq) -> false)) : @strong_rank_condition.{0} (with_one.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (with_one.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_88931 (h0 : functor.add_const (semiring (plift num)) congr_arg_kind) : @is_noetherian_ring.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (semiring.{1} (plift.{1} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_88932 (h2 : add_monoid enat) (h3 : has_one enat) : char_zero enat := sorry --non-trivial
lemma new_lemma_88933 (h0 : has_lt (has_emptyc (semiring num))) : densely_ordered (has_emptyc (semiring num)) := sorry --non-trivial
lemma new_lemma_88934 (h0 : topological_space (has_top congr_arg_kind)) : normal_space (has_top congr_arg_kind) := sorry --non-trivial
lemma new_lemma_88935 (h0 : complete_lattice (add_semigroup (random_gen (random_gen num)))) : complete_lattice.is_Sup_finite_compact (add_semigroup (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_88936 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_Sup.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_88937 (h0 : functor.comp (functor.comp cancel_comm_monoid_with_zero has_neg_part) with_top nnreal) : @unique_factorization_monoid.{0} (has_neg_part.{0} ennreal) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_neg_part.{0} ennreal (@functor.comp.run.{0 0 0} (functor.comp.{0 0 0} cancel_comm_monoid_with_zero.{0} has_neg_part.{0}) with_top.{0} nnreal h0))  := sorry --non-trivial
lemma new_lemma_88938 (h5 : topological_space char) : path_connected_space char := sorry --non-trivial
lemma new_lemma_88939 (h0 : topological_space (left_cancel_monoid (semiring empty))) : totally_disconnected_space (left_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_88940 (h0 : functor.add_const (function.extfun Type topological_space) (ring name)) : @locally_compact_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (ring.{0} name) h0) (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_88941 (h1 : add_group (add_comm_semigroup fun_info)) : is_add_cyclic (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_88942 (h0 : function.extfun Type group) : @group.fg.{0} empty (@function.extfun_app.{2 1} Type group.{0} h0 empty)  := sorry --non-trivial
lemma new_lemma_88943 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_88944 (h0 : list (preorder (option (option empty)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_88945 (h0 : topological_space (has_zero (option (option (option (option (option pos))))))) : regular_space (has_zero (option (option (option (option (option pos)))))) := sorry --non-trivial
lemma new_lemma_88946 (h0 : ring (comm_ring (semigroup (has_ssubset string.iterator_imp)))) : is_domain (comm_ring (semigroup (has_ssubset string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_88947 (h0 : functor.add_const (function.extfun Type ring) Type) : @rank_condition.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_88948 (h0 : functor.add_const (finset (add_comm_monoid pos)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_88949 (h0 : topological_space (id (has_norm congr_arg_kind))) : locally_compact_space (id (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_88950 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_88951 (h0 : functor.add_const (ring (has_nndist pos)) (ring environment.implicit_infer_kind)) : @strong_rank_condition.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} pos)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_88952 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_star.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_star.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_88953 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) (boolean_algebra unsigned)) : @totally_disconnected_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) (boolean_algebra.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_88954 (h0 : semiring (has_zero (has_to_string Type))) : is_noetherian_ring (has_zero (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_88955 (h0 : ring (has_inv (has_inv (with_zero to_additive.value_type)))) : is_domain (has_inv (has_inv (with_zero to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_88956 (h0 : ring (has_ssubset reducibility_hints)) : strong_rank_condition (has_ssubset reducibility_hints) := sorry --non-trivial
lemma new_lemma_88957 (h0 : functor.add_const (ordered_add_comm_monoid (has_star congr_arg_kind)) congr_arg_kind) : @archimedean.{0} (has_star.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_star.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_88958 (h0 : functor.comp ring pseudo_metric_space pos) : @strong_rank_condition.{0} (pseudo_metric_space.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} pseudo_metric_space.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_88959 (h0 : functor.add_const (monoid (finset num)) unsigned) : @monoid.fg.{0} (finset.{0} num) (@functor.add_const.run.{0 0} (monoid.{0} (finset.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_88960 (h0 : ring (boolean_algebra (has_to_string (has_to_string unsigned)))) : rank_condition (boolean_algebra (has_to_string (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_88961 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_88962 (h0 : complete_lattice (normed_comm_ring (has_add (has_add (cancel_monoid unsigned))))) : is_atomistic (normed_comm_ring (has_add (has_add (cancel_monoid unsigned)))) := sorry --non-trivial
lemma new_lemma_88963 (h0 : topological_space (topological_space (has_ssubset linarith.comp_source))) : path_connected_space (topological_space (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_88964 (h0 : topological_space (sub_neg_monoid (has_neg (has_bot Type)))) : t1_space (sub_neg_monoid (has_neg (has_bot Type))) := sorry --non-trivial
lemma new_lemma_88965 (h0 : topological_space (add_cancel_monoid Type)) : totally_disconnected_space (add_cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_88966 (h0 : functor.add_const (function.extfun Type uniform_space) (has_pos_part linarith.comp)) : @separated_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) (has_pos_part.{0} linarith.comp) h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_88967 (h0 : function.extfun Type group) : @group.fg.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_88968 (h0 : group (canonically_ordered_comm_semiring (option unsigned))) : is_cyclic (canonically_ordered_comm_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_88969 (h0 : complete_lattice (simple_graph (has_pos_part pos))) : is_compactly_generated (simple_graph (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_88970 (h0 : ring (complete_semilattice_Sup num)) : strong_rank_condition (complete_semilattice_Sup num) := sorry --non-trivial
lemma new_lemma_88971 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_88972 (h0 : linarith.comp -> linarith.comp -> linarith.comp) : is_right_cancel linarith.comp h0 := sorry --non-trivial
lemma new_lemma_88973 (h0 : ring (ring (mul_one_class (finset environment.implicit_infer_kind)))) : strong_rank_condition (ring (mul_one_class (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_88974 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_separated_space.{0} to_additive.value_type (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_88975 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (pseudo_metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (pseudo_metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_88976 (h0 : functor.add_const (add_group (boolean_algebra environment.implicit_infer_kind)) pos) : @is_add_cyclic.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_group.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_88977 (h0 : finset (add_comm_monoid (option (option (option unsigned))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_88978 (h0 : functor.comp topological_space has_add Type) : @preirreducible_space.{1} (has_add.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_add.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_88979 (h0 : ordered_comm_monoid (finset (option (option (option (option pos)))))) : has_exists_mul_of_le (finset (option (option (option (option pos))))) := sorry --non-trivial
lemma new_lemma_88980 (h0 : functor.add_const (topological_space (bin_tree unsigned)) congr_arg_kind) : @path_connected_space.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_88981 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_88982 (h0 : topological_space (boolean_algebra.core (finset (finset linarith.comp)))) : regular_space (boolean_algebra.core (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_88983 (h0 : functor.add_const (topological_space (left_cancel_monoid unsigned)) num) : @loc_path_connected_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_88984 (h0 : topological_space (normed_comm_ring (has_neg (has_nndist linarith.comp)))) : regular_space (normed_comm_ring (has_neg (has_nndist linarith.comp))) := sorry --non-trivial
lemma new_lemma_88985 (h1 : complete_lattice (has_append (random_gen to_additive.value_type))) : is_compactly_generated (has_append (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_88986 (h0 : not (semiring (with_bot fun_info) -> false)) : @is_noetherian_ring.{0} (with_bot.{0} fun_info) (@classical.by_contradiction'.{1} (semiring.{0} (with_bot.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_88987 (h0 : has_mem.mem (semiring empty) has_emptyc.emptyc) : @is_domain.{0} (semiring.{0} empty) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_88988 (h0 : functor.add_const (function.extfun Type finset) linarith.comp) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (finset pos)) := sorry --non-trivial
lemma new_lemma_88989 (h0 : list (has_nndist unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_88990 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_neg_part environment.implicit_infer_kind)) name) : @unique_factorization_monoid.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_neg_part.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_88991 (h0 : functor.add_const (ring (semiring unsigned)) empty) : @is_domain.{0} (semiring.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (semiring.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_88992 (h0 : functor.add_const (topological_space (boolean_algebra name)) name) : @topological_space.separable_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_88993 (h1 : ring (has_compl (random_gen to_additive.value_type))) : rank_condition (has_compl (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_88994 (h0 : topological_space (has_to_string environment.implicit_infer_kind)) : irreducible_space (has_to_string environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_88995 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_88996 (h0 : not (complete_lattice (has_emptyc congr_arg_kind) -> false)) : @is_atomistic.{0} (has_emptyc.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_emptyc.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_88997 (h0 : ring (topological_space (random_gen string_imp))) : rank_condition (topological_space (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_88998 (h0 : topological_space (linear_ordered_comm_ring congr_arg_kind)) : discrete_topology (linear_ordered_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_88999 (h0 : functor.add_const (add_monoid auto.case_option) (option unsigned)) : @add_monoid.fg.{0} auto.case_option (@functor.add_const.run.{0 0} (add_monoid.{0} auto.case_option) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_89000 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (normed_lattice_add_comm_group.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_89001 (h0 : topological_space (mul_zero_class (has_add (has_add name)))) : totally_separated_space (mul_zero_class (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_89002 (h0 : add_group (has_dist (encodable (has_ssubset (has_top string_imp))))) : is_add_cyclic (has_dist (encodable (has_ssubset (has_top string_imp)))) := sorry --non-trivial
lemma new_lemma_89003 (h0 : topological_space (generalized_boolean_algebra (has_add real))) : t0_space (generalized_boolean_algebra (has_add real)) := sorry --non-trivial
lemma new_lemma_89004 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_89005 (h0 : complete_lattice (denumerable linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (denumerable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_89006 (h0 : topological_space (boolean_algebra.core (has_neg name))) : t0_space (boolean_algebra.core (has_neg name)) := sorry --non-trivial
lemma new_lemma_89007 (h0 : functor.add_const (topological_space (plift empty)) empty) : @preirreducible_space.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_89008 (h0 : group (pseudo_metric_space (option (option (option ennreal))))) : is_cyclic (pseudo_metric_space (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_89009 (h0 : topological_space (nondiscrete_normed_field linarith.ineq)) (h1 : preorder (nondiscrete_normed_field linarith.ineq)) : order_closed_topology (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_89010 (h0 : function.extfun nat fin) : @rank_condition.{0} (normed_lattice_add_comm_group.{0} real) (@matrix.vec_empty.{0} (ring.{0} (normed_lattice_add_comm_group.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_89011 (h0 : complete_lattice (has_Sup (option empty))) : complete_lattice.is_Sup_finite_compact (has_Sup (option empty)) := sorry --non-trivial
lemma new_lemma_89012 (h0 : group (complete_semilattice_Sup (random_gen (random_gen fun_info)))) : group.fg (complete_semilattice_Sup (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_89013 (h0 : uniform_space (with_bot (has_norm (has_norm (has_norm empty))))) : complete_space (with_bot (has_norm (has_norm (has_norm empty)))) := sorry --non-trivial
lemma new_lemma_89014 (h1 : topological_space (has_union (has_norm (has_norm linarith.comp)))) : locally_compact_space (has_union (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_89015 (h1 : not (ring (topological_space reducibility_hints) -> false)) : @is_domain.{0} (topological_space.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (topological_space.{0} reducibility_hints)) h1)  := sorry --non-trivial
lemma new_lemma_89016 (h0 : list (has_zero (ring (has_neg (ring Type))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_89017 (h0 : list (add_cancel_monoid (has_neg Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_89018 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (fintype.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (fintype.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_89019 (h0 : list (boolean_algebra.core environment.implicit_infer_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_89020 (h0 : ring (complete_semilattice_Sup linarith.comp_source)) : rank_condition (complete_semilattice_Sup linarith.comp_source) := sorry --non-trivial
lemma new_lemma_89021 (h0 : cancel_comm_monoid_with_zero (plift (option unsigned))) : unique_factorization_monoid (plift (option unsigned)) := sorry --non-trivial
lemma new_lemma_89022 (h0 : add_monoid (has_union (semiring (has_top congr_arg_kind)))) : add_monoid.fg (has_union (semiring (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_89023 (h0 : topological_space (with_bot (semiring num))) : discrete_topology (with_bot (semiring num)) := sorry --non-trivial
lemma new_lemma_89024 (h0 : topological_space (boolean_algebra.core (has_neg (has_neg name)))) : regular_space (boolean_algebra.core (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_89025 (h0 : ring (normed_group (semiring (semiring (semiring num))))) : is_domain (normed_group (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_89026 (h1 : semiring (nondiscrete_normed_field (add_comm_semigroup string.iterator_imp))) (h2 : ideal (nondiscrete_normed_field (add_comm_semigroup string.iterator_imp))) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_89027 (h0 : topological_space (has_ssubset (random_gen linarith.comp_source))) : totally_disconnected_space (has_ssubset (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_89028 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_89029 (h0 : has_mem.mem (random_gen fun_info) has_emptyc.emptyc) : @strong_rank_condition.{0} (random_gen.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (random_gen.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_89030 (h0 : filter (has_zero num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_89031 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} fun_info (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 fun_info)  := sorry --non-trivial
lemma new_lemma_89032 (h0 : topological_space (sub_neg_monoid (has_add name))) : preirreducible_space (sub_neg_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_89033 (h0 : functor.add_const (functor.add_const (group Type) linarith.comp) Type) : @group.fg.{1} Type (@functor.add_const.run.{1 0} (group.{1} Type) linarith.comp (@functor.add_const.run.{1 1} (functor.add_const.{1 0} (group.{1} Type) linarith.comp) Type h0))  := sorry --non-trivial
lemma new_lemma_89034 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (has_sub unsigned)) := sorry --non-trivial
lemma new_lemma_89035 (h0 : functor.add_const (topological_space Type) (has_pos_part (normed_comm_ring pos))) : @t0_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) (has_pos_part.{0} (normed_comm_ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_89036 (h0 : functor.comp topological_space has_neg ennreal) : @topological_space.separable_space.{0} (has_neg.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_89037 (h0 : complete_lattice (has_Inf (has_Inf (ordered_comm_monoid real)))) : is_compactly_generated (has_Inf (has_Inf (ordered_comm_monoid real))) := sorry --non-trivial
lemma new_lemma_89038 (h0 : function.extfun (finset Type) (has_mem.mem (semiring fun_info))) : @add_monoid.fg.{0} (semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type add_monoid.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_89039 (h0 : topological_space (measurable_space (semiring (has_norm linarith.comp)))) : normal_space (measurable_space (semiring (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_89040 (h0 : functor.add_const (list (add_cancel_monoid Type)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_89041 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_89042 (h0 : add_group (ordered_comm_ring (has_Inf (has_add (finset pos))))) : is_add_cyclic (ordered_comm_ring (has_Inf (has_add (finset pos)))) := sorry --non-trivial
lemma new_lemma_89043 (h0 : functor.add_const (function.extfun Type list) name) : palindrome (function.extfun_app (functor.add_const.run h0) (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_89044 (h0 : function.extfun (Type 1) topological_space) : @preconnected_space.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_89045 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_89046 (h0 : not (topological_space (semiring linarith.comp) -> false)) : @discrete_topology.{0} (semiring.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_89047 (h0 : semiring (add_comm_monoid (has_add Type))) : is_noetherian_ring (add_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_89048 (h0 : topological_space (has_Inf (has_pos_part Type))) : totally_separated_space (has_Inf (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_89049 (h0 : prod (non_assoc_semiring num) (non_assoc_semiring num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_89050 (h0 : topological_space (add_cancel_monoid pos)) : preirreducible_space (add_cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_89051 (h0 : topological_space (add_comm_monoid (option unsigned))) : preconnected_space (add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_89052 (h2 : complete_lattice (add_comm_semigroup enat)) : complete_lattice.is_Sup_finite_compact (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_89053 (h0 : functor.add_const (complete_lattice (has_inter unsigned)) (option unsigned)) : @is_atomistic.{0} (has_inter.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_inter.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_89054 (h0 : topological_space (add_cancel_monoid (finset (finset pos)))) : totally_disconnected_space (add_cancel_monoid (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_89055 (h0 : not (add_group (semi_normed_ring linarith.ineq) -> false)) : @is_add_cyclic.{0} (semi_normed_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (semi_normed_ring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_89056 (h0 : complete_lattice (ring (boolean_algebra name))) : is_compactly_generated (ring (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_89057 (h0 : has_lt (linear_ordered_comm_group_with_zero (mul_one_class to_additive.value_type))) : no_max_order (linear_ordered_comm_group_with_zero (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_89058 (h0 : functor.comp group has_nndist pos) : @is_cyclic.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_89059 (h0 : topological_space (has_Inf (has_pos_part (has_Inf linarith.comp)))) : t1_space (has_Inf (has_pos_part (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_89060 (h0 : uniform_space (has_to_string (option unsigned))) : complete_space (has_to_string (option unsigned)) := sorry --non-trivial
lemma new_lemma_89061 (h0 : ring (boolean_algebra (comm_group name))) : rank_condition (boolean_algebra (comm_group name)) := sorry --non-trivial
lemma new_lemma_89062 (h0 : topological_space (has_compl (has_ssubset string_imp))) : locally_compact_space (has_compl (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_89063 (h0 : ring (semiring (semiring num))) : is_principal_ideal_ring (semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_89064 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (random_gen.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (random_gen.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_89065 (h0 : functor.add_const (add_group (has_zero Type)) linarith.comp) : @is_add_cyclic.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (has_zero.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_89066 (h0 : topological_space (boolean_algebra name)) : loc_path_connected_space (boolean_algebra name) := sorry --non-trivial
lemma new_lemma_89067 (h0 : ring (has_nndist (add_comm_monoid Type))) : is_principal_ideal_ring (has_nndist (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_89068 (h0 : topological_space (has_inner (option (semiring unsigned)) num)) : loc_path_connected_space (has_inner (option (semiring unsigned)) num) := sorry --non-trivial
lemma new_lemma_89069 (h0 : group (has_star (semiring (has_top empty)))) : normalizer_condition (has_star (semiring (has_top empty))) := sorry --non-trivial
lemma new_lemma_89070 (h0 : finset (add_cancel_monoid unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_89071 (h0 : group (normed_comm_ring (has_add environment.implicit_infer_kind))) : is_simple_group (normed_comm_ring (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_89072 (h0 : ordered_add_comm_monoid (finset (finset (finset (finset (has_pos_part linarith.comp)))))) : archimedean (finset (finset (finset (finset (has_pos_part linarith.comp))))) := sorry --non-trivial
lemma new_lemma_89073 (h0 : functor.add_const (group (preorder unsigned)) empty) : @normalizer_condition.{0} (preorder.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (preorder.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_89074 (h0 : functor.add_const (list (has_add name)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_89075 (h0 : finset (add_cancel_comm_monoid num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_89076 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_89077 (h0 : function.extfun Type (functor.add_const (topological_space (complete_distrib_lattice name)))) : @t0_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} name)) (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} name))) h0 (has_pos_part.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_89078 (h0 : topological_space (linear_ordered_field (option ennreal))) : preconnected_space (linear_ordered_field (option ennreal)) := sorry --non-trivial
lemma new_lemma_89079 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} congr_arg_kind (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_89080 (h0 : fin has_zero.zero) : @path_connected_space.{0} (sub_neg_monoid.{0} (has_bot.{0} real)) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} (has_bot.{0} real))) h0)  := sorry --non-trivial
lemma new_lemma_89081 (h2 : ring (semi_normed_comm_ring linarith.ineq)) : rank_condition (semi_normed_comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_89082 (h0 : not (topological_space (semi_normed_comm_ring char) -> false)) : @totally_disconnected_space.{0} (semi_normed_comm_ring.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_comm_ring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_89083 (h0 : monoid (distrib_lattice to_additive.value_type)) : monoid.fg (distrib_lattice to_additive.value_type) := sorry --non-trivial
lemma new_lemma_89084 (h0 : topological_space (id fun_info)) : path_connected_space (id fun_info) := sorry --non-trivial
lemma new_lemma_89085 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (linear_ordered_add_comm_group.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_add_comm_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_89086 (h0 : function.extfun Type complete_lattice) : is_compactly_generated (measurable_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_89087 (h0 : add_group (left_cancel_monoid (option (option (option unsigned))))) : is_add_cyclic (left_cancel_monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_89088 (h0 : complete_lattice (semi_normed_ring (mul_one_class to_additive.value_type))) : is_compactly_generated (semi_normed_ring (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_89089 (h0 : topological_space (has_compl enat)) : totally_disconnected_space (has_compl enat) := sorry --non-trivial
lemma new_lemma_89090 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (non_assoc_semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} h0 (non_assoc_semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_89091 (h0 : function.extfun Type group) : @group.fg.{0} (has_nnnorm.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (has_nnnorm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_89092 (h0 : group (generalized_boolean_algebra (has_add (has_Inf Type)))) : normalizer_condition (generalized_boolean_algebra (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_89093 (h0 : complete_lattice (id (has_norm (has_norm (semiring congr_arg_kind))))) : is_atomistic (id (has_norm (has_norm (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_89094 (h0 : function.extfun Type (functor.add_const (complete_lattice (add_left_cancel_semigroup empty)))) : @is_compactly_generated.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_left_cancel_semigroup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (add_left_cancel_semigroup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_89095 (h0 : topological_space (ordered_ring congr_arg_kind)) : loc_path_connected_space (ordered_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_89096 (h0 : complete_lattice (semigroup (mul_one_class Type))) : is_compactly_generated (semigroup (mul_one_class Type)) := sorry --non-trivial
lemma new_lemma_89097 (h0 : has_mem.mem uniform_space has_emptyc.emptyc) : @complete_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} h0) (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_89098 (h0 : functor.add_const (add_group (has_nndist pos)) ennreal) : @is_add_cyclic.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_nndist.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_89099 (h0 : functor.add_const (ring (complete_distrib_lattice pos)) linarith.comp) : @strong_rank_condition.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_89100 (h0 : monoid (has_pos_part (finset (ring (ring Type))))) : monoid.fg (has_pos_part (finset (ring (ring Type)))) := sorry --non-trivial
lemma new_lemma_89101 (h0 : functor.add_const (list (mul_zero_class unsigned)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_89102 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_89103 (h0 : topological_space (linear_ordered_field (option (option (option unsigned))))) : discrete_topology (linear_ordered_field (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_89104 (h0 : functor.add_const (ring (normed_linear_ordered_group empty)) num) : @rank_condition.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (normed_linear_ordered_group.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_89105 (h0 : function.extfun Type group) : @normalizer_condition.{0} (random_gen.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (random_gen.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_89106 (h0 : ring (id (has_norm (has_norm (has_norm (has_norm congr_arg_kind)))))) : is_domain (id (has_norm (has_norm (has_norm (has_norm congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_89107 (h0 : functor.add_const (complete_lattice (has_nndist Type)) Type) : @is_compactly_generated.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (has_nndist.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_89108 (h0 : ordered_comm_monoid (linear_ordered_field (option (option (option unsigned))))) : has_exists_mul_of_le (linear_ordered_field (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_89109 (h0 : topological_space (normed_lattice_add_comm_group (sub_neg_monoid pos))) : topological_space.separable_space (normed_lattice_add_comm_group (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_89110 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) Type) : @sequential_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg_part.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_89111 (h0 : ordered_comm_monoid (complete_distrib_lattice (finset (finset linarith.comp)))) : has_exists_mul_of_le (complete_distrib_lattice (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_89112 (h1 : ring (add_comm_semigroup enat)) : is_domain (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_89113 (h1 : uniform_space (canonically_ordered_add_monoid (random_gen string_imp))) : complete_space (canonically_ordered_add_monoid (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_89114 (h0 : cancel_comm_monoid_with_zero (canonically_linear_ordered_monoid Type)) : unique_factorization_monoid (canonically_linear_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_89115 (h0 : set (prod linarith.comp linarith.comp)) : symmetric_rel h0 := sorry --non-trivial
lemma new_lemma_89116 (h0 : group (normed_comm_ring name)) : is_cyclic (normed_comm_ring name) := sorry --non-trivial
lemma new_lemma_89117 (h1 h2 : multiset (has_le enat)) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_89118 (h0 : topological_space (semigroup (boolean_algebra Type))) : totally_disconnected_space (semigroup (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_89119 (h0 : uniform_space (option (option pos))) : complete_space (option (option pos)) := sorry --non-trivial
lemma new_lemma_89120 (h0 : ring (semiring (has_top (has_top linarith.comp_source)))) : rank_condition (semiring (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_89121 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_89122 (h0 : ring (canonically_ordered_comm_semiring (finset (add_comm_monoid Type)))) : is_principal_ideal_ring (canonically_ordered_comm_semiring (finset (add_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_89123 (h0 : function.extfun Type group) : @is_cyclic.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_89124 (h0 : function.extfun (((Type -> Type) -> Type 1) -> Type 1) (function.extfun ((Type -> Type) -> Type 1))) : @preirreducible_space.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (@function.extfun_app.{3 3} (((Type → Type) → Type 1) → Type 1) (function.extfun.{3 2} ((Type → Type) → Type 1)) h0 (function.extfun.{2 2} (Type → Type))) (function.extfun.{2 1} Type)) topological_space.{0}) (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_89125 (h0 : ring (boolean_algebra (has_to_string (comm_group unsigned)))) : is_domain (boolean_algebra (has_to_string (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_89126 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preconnected_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_89127 (h1 : set (fun_info -> char)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_89128 (h0 : mul_one_class (has_ssubset reducibility_hints) -> mul_one_class (has_ssubset reducibility_hints) -> Prop) : is_total_preorder (mul_one_class (has_ssubset reducibility_hints)) h0 := sorry --non-trivial
lemma new_lemma_89129 (h0 : ring (add_cancel_monoid environment.implicit_infer_kind)) : rank_condition (add_cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_89130 (h0 : complete_lattice (add_cancel_comm_monoid (metric_space string_imp))) : is_compactly_generated (add_cancel_comm_monoid (metric_space string_imp)) := sorry --non-trivial
lemma new_lemma_89131 (h0 : fin has_zero.zero) : @irreducible_space.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_89132 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (as_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (as_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_89133 (h0 : ordered_add_comm_monoid (pseudo_metric_space (has_nndist name))) : archimedean (pseudo_metric_space (has_nndist name)) := sorry --non-trivial
lemma new_lemma_89134 (h0 : functor.add_const (uniform_space (has_neg name)) pos) : @separated_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_neg.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_89135 (h0 : add_group (comm_ring (has_nnnorm linarith.ineq))) : is_add_cyclic (comm_ring (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_89136 (h0 : group (has_nndist (has_nndist (has_add name)))) : is_simple_group (has_nndist (has_nndist (has_add name))) := sorry --non-trivial
lemma new_lemma_89137 (h0 : add_group (complete_distrib_lattice (ordered_comm_monoid linarith.comp))) : is_add_cyclic (complete_distrib_lattice (ordered_comm_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_89138 (h0 : topological_space (has_Inf (has_Inf (has_Inf (has_Inf name))))) : totally_separated_space (has_Inf (has_Inf (has_Inf (has_Inf name)))) := sorry --non-trivial
lemma new_lemma_89139 (h0 : semiring (has_add name)) : is_noetherian_ring (has_add name) := sorry --non-trivial
lemma new_lemma_89140 (h0 : group (has_add (has_nndist (has_neg pos)))) : normalizer_condition (has_add (has_nndist (has_neg pos))) := sorry --non-trivial
lemma new_lemma_89141 (h1 : ring (distrib (has_ssubset (random_gen char)))) : is_domain (distrib (has_ssubset (random_gen char))) := sorry --non-trivial
lemma new_lemma_89142 (h0 : topological_space (has_nndist (finset (finset (finset name))))) : totally_disconnected_space (has_nndist (finset (finset (finset name)))) := sorry --non-trivial
lemma new_lemma_89143 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_89144 (h0 : function.extfun Type group) : @group.fg.{0} (@id.{2} Type linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (@id.{2} Type linarith.ineq))  := sorry --non-trivial
lemma new_lemma_89145 (h0 : finset (has_star (semiring (semiring (semiring (semiring (semiring empty))))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_89146 (h0 : group (add_comm_monoid (has_neg_part (mul_zero_class name)))) : group.fg (add_comm_monoid (has_neg_part (mul_zero_class name))) := sorry --non-trivial
lemma new_lemma_89147 (h0 : topological_space (has_Inf (has_neg (has_Inf linarith.comp)))) : irreducible_space (has_Inf (has_neg (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_89148 (h0 : uniform_space (add_comm_semigroup environment.projection_info)) : complete_space (add_comm_semigroup environment.projection_info) := sorry --non-trivial
lemma new_lemma_89149 (h0 : functor.add_const (ring (non_assoc_semiring num)) (semiring congr_arg_kind)) : @rank_condition.{0} (non_assoc_semiring.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (non_assoc_semiring.{0} num)) (semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_89150 (h0 : complete_lattice (has_union (semiring unsigned))) : is_compactly_generated (has_union (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_89151 (h0 : functor.add_const (topological_space (has_add Type)) pos) : @t1_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_89152 (h0 : functor.add_const (function.extfun (Type 1) monoid) name) : @monoid.fg.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) monoid.{1}) name h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_89153 (h0 : set (nondiscrete_normed_field string.iterator_imp)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_89154 (h0 : topological_space (has_inter empty)) : t0_space (has_inter empty) := sorry --non-trivial
lemma new_lemma_89155 (h0 : functor.add_const (uniform_space (has_bot pos)) linarith.comp) : @separated_space.{0} (has_bot.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_bot.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_89156 (h0 : ring (sub_neg_monoid (has_add (has_pos_part pos)))) : strong_rank_condition (sub_neg_monoid (has_add (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_89157 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_dist.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_dist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_89158 (h0 : functor.add_const (topological_space (finset Type)) linarith.comp) : @irreducible_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_89159 (h0 : topological_space (has_neg (has_neg (has_neg (has_neg (has_neg (has_neg linarith.comp))))))) : regular_space (has_neg (has_neg (has_neg (has_neg (has_neg (has_neg linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_89160 (h0 : functor.add_const (ordered_add_comm_monoid (plift unsigned)) unsigned) : @archimedean.{1} (plift.{1} unsigned) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (plift.{1} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_89161 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_89162 (h0 : topological_space (has_to_string (has_add (finset environment.implicit_infer_kind)))) : sequential_space (has_to_string (has_add (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_89163 (h0 : monoid (simple_graph (has_Inf (has_Inf linarith.comp)))) : monoid.fg (simple_graph (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_89164 (h0 : complete_lattice (linear_ordered_add_comm_group (random_gen string_imp))) : is_atomistic (linear_ordered_add_comm_group (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_89165 (h0 : add_monoid (has_top congr_arg_kind)) : add_monoid.fg (has_top congr_arg_kind) := sorry --non-trivial
lemma new_lemma_89166 (h0 : group (has_zero (finset Type))) : normalizer_condition (has_zero (finset Type)) := sorry --non-trivial
lemma new_lemma_89167 (h0 : topological_space (semigroup ennreal)) : locally_compact_space (semigroup ennreal) := sorry --non-trivial
lemma new_lemma_89168 (h0 : functor.add_const Prop (generalized_boolean_algebra linarith.comp)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_89169 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (finset empty)) := sorry --non-trivial
lemma new_lemma_89170 (h0 : topological_space (comm_group (add_cancel_monoid environment.implicit_infer_kind))) : discrete_topology (comm_group (add_cancel_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_89171 (h1 : group (has_add linarith.comp_source)) : is_cyclic (has_add linarith.comp_source) := sorry --non-trivial
lemma new_lemma_89172 (h0 : group (has_neg_part (normed_comm_ring Type))) : is_simple_group (has_neg_part (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_89173 (h0 : topological_space (has_emptyc unsigned)) : locally_compact_space (has_emptyc unsigned) := sorry --non-trivial
lemma new_lemma_89174 (h1 : function.extfun Type topological_space) : @totally_separated_space.{0} (random_gen.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (random_gen.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_89175 (h0 : add_group (ring (option unsigned))) : is_add_cyclic (ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_89176 (h0 : topological_space (has_pos_part Type)) : discrete_topology (has_pos_part Type) := sorry --non-trivial
lemma new_lemma_89177 (h0 : functor.add_const (fin has_zero.zero) empty) : matrix.vec_empty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_89178 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_nnnorm.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nnnorm.{0} char))  := sorry --non-trivial
lemma new_lemma_89179 (h0 : topological_space (generalized_boolean_algebra (has_pos_part (finset linarith.comp)))) : irreducible_space (generalized_boolean_algebra (has_pos_part (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_89180 (h0 : uniform_space (normed_field to_additive.value_type)) : complete_space (normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_89181 (h0 : function.extfun Type group) : @is_cyclic.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_89182 (h0 : ordered_add_comm_monoid (comm_group (has_add name))) : archimedean (comm_group (has_add name)) := sorry --non-trivial
lemma new_lemma_89183 (h0 : uniform_space (has_add (has_Inf (has_Inf real)))) : complete_space (has_add (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_89184 (h0 : topological_space (plift (linear_ordered_comm_ring (semiring num)))) : t1_space (plift (linear_ordered_comm_ring (semiring num))) := sorry --non-trivial
lemma new_lemma_89185 (h0 : functor.add_const (topological_space (add_left_cancel_semigroup unsigned)) unsigned) : @t0_space.{0} (add_left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_89186 (h0 : function.extfun (Type 1) topological_space) : @t0_space.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_89187 (h0 : functor.comp topological_space normed_comm_ring Type) : @locally_compact_space.{1} (normed_comm_ring.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} normed_comm_ring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_89188 (h0 : functor.add_const (filter (has_Inf pos)) (ring Type)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_89189 (h0 : group (with_one (semiring num))) : group.fg (with_one (semiring num)) := sorry --non-trivial
lemma new_lemma_89190 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) linarith.comp) : @t1_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_89191 (h0 : not (group (dlist char) -> false)) : @group.fg.{0} (dlist.{0} char) (@classical.by_contradiction'.{1} (group.{0} (dlist.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_89192 (h0 : complete_lattice (id linarith.comp)) : is_atomistic (id linarith.comp) := sorry --non-trivial
lemma new_lemma_89193 (h0 : functor.add_const (group (has_Inf pos)) pos) : @is_simple_group.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_Inf.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_89194 (h0 : ring (has_top (has_norm (has_inv (has_inv (has_inv linarith.comp_source)))))) : is_domain (has_top (has_norm (has_inv (has_inv (has_inv linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_89195 (h0 : functor.add_const (ring (omega_complete_partial_order unsigned)) empty) : @rank_condition.{0} (omega_complete_partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (omega_complete_partial_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_89196 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_dist.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_dist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_89197 (h0 : functor.add_const (add_group (has_Inf pos)) name) : @is_add_cyclic.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_Inf.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_89198 (h3 : uniform_space (uniform_space linarith.comp_source)) : complete_space (uniform_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_89199 (h1 : ring occurrences) : is_domain occurrences := sorry --non-trivial
lemma new_lemma_89200 (h0 : function.extfun (Type 1) topological_space) : @normal_space.{1} (canonically_linear_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (canonically_linear_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_89201 (h0 : add_group (semi_normed_ring (topological_space (has_nnnorm linarith.ineq)))) : is_add_cyclic (semi_normed_ring (topological_space (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_89202 (h0 : group (normed_linear_ordered_group (semiring empty))) : normalizer_condition (normed_linear_ordered_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_89203 (h0 : topological_space (has_add (normed_comm_ring linarith.comp))) : irreducible_space (has_add (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_89204 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_89205 (h0 : not (ring (distrib_lattice to_additive.value_type) -> false)) : @strong_rank_condition.{0} (distrib_lattice.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (distrib_lattice.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_89206 (h0 : ring (boolean_algebra (has_Inf name))) : is_principal_ideal_ring (boolean_algebra (has_Inf name)) := sorry --non-trivial
lemma new_lemma_89207 (h0 : functor.add_const (group (boolean_algebra.core name)) linarith.comp) : @is_cyclic.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.core.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_89208 (h0 : ring (has_nndist (has_add (option name)))) : strong_rank_condition (has_nndist (has_add (option name))) := sorry --non-trivial
lemma new_lemma_89209 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm congr_arg_kind))) : @discrete_topology.{0} (has_norm.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_89210 (h0 : functor.add_const (finset (simple_graph pos)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_89211 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) Type) : @totally_separated_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_89212 (h0 : monoid (with_bot (has_top (has_top (has_inv linarith.ineq))))) : monoid.fg (with_bot (has_top (has_top (has_inv linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_89213 (h0 : complete_lattice (mul_one_class fun_info)) : complete_lattice.is_Sup_finite_compact (mul_one_class fun_info) := sorry --non-trivial
lemma new_lemma_89214 (h0 : topological_space (add_comm_monoid real)) : regular_space (add_comm_monoid real) := sorry --non-trivial
lemma new_lemma_89215 (h0 : complete_lattice (has_inter unsigned)) : complete_lattice.is_Sup_finite_compact (has_inter unsigned) := sorry --non-trivial
lemma new_lemma_89216 (h0 : has_le string.iterator_imp) (h1 : string.iterator_imp) : is_bot h1 := sorry --non-trivial
lemma new_lemma_89217 (h0 : uniform_space (has_add congr_arg_kind)) : separated_space (has_add congr_arg_kind) := sorry --non-trivial
lemma new_lemma_89218 (h0 : functor.add_const (topological_space (simple_graph linarith.comp)) linarith.comp) : @preconnected_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_89219 (h0 : topological_space (semigroup (finset (finset linarith.comp)))) : t0_space (semigroup (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_89220 (h0 : group (measurable_space (has_norm linarith.comp))) : is_cyclic (measurable_space (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_89221 (h0 : topological_space (comm_group (has_neg_part (has_add Type)))) : loc_path_connected_space (comm_group (has_neg_part (has_add Type))) := sorry --non-trivial
lemma new_lemma_89222 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_89223 (h0 : functor.add_const (group (has_inter unsigned)) congr_arg_kind) : @is_cyclic.{0} (has_inter.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_inter.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_89224 (h0 : functor.add_const (topological_space (finset unsigned)) num) : @normal_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_89225 (h0 : topological_space (measurable_space.dynkin_system unsigned)) : irreducible_space (measurable_space.dynkin_system unsigned) := sorry --non-trivial
lemma new_lemma_89226 (h0 : functor.add_const (filter (add_cancel_monoid name)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_89227 (h0 : functor.add_const (add_group (ordered_comm_monoid Type)) pos) : @is_add_cyclic.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (ordered_comm_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_89228 (h0 : topological_space (cancel_monoid ennreal)) : preirreducible_space (cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_89229 (h0 : functor.add_const (ordered_add_comm_monoid (add_comm_monoid Type)) Type) : @archimedean.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (ordered_add_comm_monoid.{1} (add_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_89230 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (canonically_linear_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_89231 (h0 : list (random_gen (has_inv (has_inv (has_inv linarith.ineq))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_89232 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @t0_space.{0} (semiring.{0} (has_inv.{0} (has_norm.{0} (has_norm.{0} linarith.ineq)))) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} (has_inv.{0} (has_norm.{0} (has_norm.{0} linarith.ineq)))))  := sorry --non-trivial
lemma new_lemma_89233 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} znum (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) znum)  := sorry --non-trivial
lemma new_lemma_89234 (h0 : monoid (add_group (add_group linarith.comp))) : monoid.fg (add_group (add_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_89235 (h0 : ring (option (option pos))) : is_domain (option (option pos)) := sorry --non-trivial
lemma new_lemma_89236 (h0 : functor.add_const (topological_space (simple_graph pos)) linarith.comp) : @totally_disconnected_space.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_89237 (h0 : group (has_add (cancel_monoid (option pos)))) : group.fg (has_add (cancel_monoid (option pos))) := sorry --non-trivial
lemma new_lemma_89238 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (complete_distrib_lattice unsigned)) := sorry --non-trivial
lemma new_lemma_89239 (h0 : function.extfun nat fin) : @monoid.fg.{0} (finset.{0} pos) (@matrix.vec_empty.{0} (monoid.{0} (finset.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_89240 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_89241 (h0 : topological_space (topological_space (mul_one_class (has_nnnorm reducibility_hints)))) : t0_space (topological_space (mul_one_class (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_89242 (h1 : ring (normed_field ereal)) : rank_condition (normed_field ereal) := sorry --non-trivial
lemma new_lemma_89243 (h0 : group (has_norm (linear_ordered_add_comm_group linarith.comp_source))) : group.fg (has_norm (linear_ordered_add_comm_group linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_89244 (h1 : set (semi_normed_comm_ring linarith.comp_source)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_89245 (h0 h1 : multiset (non_unital_non_assoc_semiring reducibility_hints)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_89246 (h0 : complete_lattice (has_sub num)) : complete_lattice.is_Sup_finite_compact (has_sub num) := sorry --non-trivial
lemma new_lemma_89247 (h0 : monoid (id (has_top (has_top empty)))) : monoid.fg (id (has_top (has_top empty))) := sorry --non-trivial
lemma new_lemma_89248 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) linarith.comp) : @sequential_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_89249 (h0 : ring (monoid_with_zero unsigned)) : rank_condition (monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_89250 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (is_R_or_C.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (is_R_or_C.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_89251 (h0 : functor.add_const (function.extfun Type semiring) name) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) name h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_89252 (h0 : topological_space (add_left_cancel_monoid to_additive.value_type)) : discrete_topology (add_left_cancel_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_89253 (h0 : topological_space (sub_neg_monoid (ordered_comm_monoid linarith.comp))) : sequential_space (sub_neg_monoid (ordered_comm_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_89254 (h0 : topological_space (ring (has_add environment.implicit_infer_kind))) : sequential_space (ring (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_89255 (h0 : topological_space (has_nndist (has_ssubset (random_gen (random_gen (random_gen string_imp)))))) : path_connected_space (has_nndist (has_ssubset (random_gen (random_gen (random_gen string_imp))))) := sorry --non-trivial
lemma new_lemma_89256 (h0 : monoid (ordered_comm_monoid (has_add Type))) : monoid.fg (ordered_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_89257 (h0 : ring (has_one (has_top congr_arg_kind))) : is_domain (has_one (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_89258 (h1 : function.extfun Type ring) : @is_domain.{0} to_additive.value_type (@function.extfun_app.{2 1} Type ring.{0} h1 to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_89259 (h0 : monoid (metric_space (has_top empty))) : monoid.fg (metric_space (has_top empty)) := sorry --non-trivial
lemma new_lemma_89260 (h0 : ring (add_comm_semigroup (mul_one_class (mul_one_class string.iterator_imp)))) : is_domain (add_comm_semigroup (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_89261 (h0 : topological_space (normed_group string_imp)) (h1 : function.extfun Type (has_vadd string_imp)) : @properly_discontinuous_vadd.{0 0} string_imp (normed_group.{0} string_imp) h0 (@function.extfun_app.{2 1} Type (has_vadd.{0 0} string_imp) h1 (normed_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_89262 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_edist.{0} (semiring.{0} (option.{0} empty))) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_edist.{0} (semiring.{0} (option.{0} empty))))  := sorry --non-trivial
lemma new_lemma_89263 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (linear_ordered_comm_ring.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_ordered_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_89264 (h0 : filter (distrib_lattice (random_gen (random_gen (has_nnnorm linarith.comp_source))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_89265 (h0 : group (normed_field (random_gen (random_gen (random_gen (random_gen (random_gen char))))))) : is_cyclic (normed_field (random_gen (random_gen (random_gen (random_gen (random_gen char)))))) := sorry --non-trivial
lemma new_lemma_89266 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (finset linarith.comp)) : @regular_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_89267 (h0 : semiring (has_star (semiring (semiring (semiring congr_arg_kind))))) : is_noetherian_ring (has_star (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_89268 (h0 : has_mem.mem ring has_emptyc.emptyc) : @is_domain.{0} string_imp (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) string_imp)  := sorry --non-trivial
lemma new_lemma_89269 (h0 : topological_space (has_compl (has_compl enat))) : path_connected_space (has_compl (has_compl enat)) := sorry --non-trivial
lemma new_lemma_89270 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_89271 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_89272 (h1 : ring (id linarith.comp_source)) : is_domain (id linarith.comp_source) := sorry --non-trivial
lemma new_lemma_89273 (h0 : topological_space (monoid_with_zero (option pos))) : discrete_topology (monoid_with_zero (option pos)) := sorry --non-trivial
lemma new_lemma_89274 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (boolean_algebra.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_89275 (h1 : complete_lattice (id (random_gen string_imp))) : is_atomistic (id (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_89276 (h1 : topological_space (topological_space (has_ssubset (has_ssubset (random_gen char))))) : t0_space (topological_space (has_ssubset (has_ssubset (random_gen char)))) := sorry --non-trivial
lemma new_lemma_89277 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf real))) : t1_space (normed_lattice_add_comm_group (has_Inf real)) := sorry --non-trivial
lemma new_lemma_89278 (h0 : group (linear_ordered_semiring (has_union unsigned))) : is_cyclic (linear_ordered_semiring (has_union unsigned)) := sorry --non-trivial
lemma new_lemma_89279 (h0 : group (has_dist (option (option empty)))) : normalizer_condition (has_dist (option (option empty))) := sorry --non-trivial
lemma new_lemma_89280 (h0 : topological_space (has_sub (semiring unsigned))) : preirreducible_space (has_sub (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_89281 (h0 : topological_space (non_assoc_semiring (semiring (semiring num)))) : t1_space (non_assoc_semiring (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_89282 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (denumerable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (denumerable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_89283 (h0 : has_mem.mem (normed_group (has_top linarith.comp_source)) has_emptyc.emptyc) : @irreducible_space.{0} (normed_group.{0} (has_top.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} (has_top.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_89284 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_89285 (h0 : ring (finset (has_zero (finset (has_zero environment.implicit_infer_kind))))) : is_principal_ideal_ring (finset (has_zero (finset (has_zero environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_89286 (h0 : topological_space (has_top (has_nnnorm char))) : locally_compact_space (has_top (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_89287 (h0 : list (add_cancel_monoid (has_neg (finset linarith.comp)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_89288 (h0 : ring (has_ssubset (linear_ordered_comm_group_with_zero string.iterator))) : rank_condition (has_ssubset (linear_ordered_comm_group_with_zero string.iterator)) := sorry --non-trivial
lemma new_lemma_89289 (h0 : has_mem.mem (has_emptyc num) has_emptyc.emptyc) : @path_connected_space.{0} (has_emptyc.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_89290 (h0 : complete_lattice (with_one (has_norm (has_norm (semiring empty))))) : is_compactly_generated (with_one (has_norm (has_norm (semiring empty)))) := sorry --non-trivial
lemma new_lemma_89291 (h0 : ring (simple_graph (finset linarith.comp))) : rank_condition (simple_graph (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_89292 (h0 : topological_space (complete_linear_order (semiring empty))) : locally_compact_space (complete_linear_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_89293 (h0 : uniform_space (semi_normed_comm_ring string_imp)) : complete_space (semi_normed_comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_89294 (h0 : functor.add_const (topological_space (ring linarith.comp)) linarith.comp) : @regular_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_89295 (h0 : topological_space (normed_linear_ordered_group empty)) : irreducible_space (normed_linear_ordered_group empty) := sorry --non-trivial
lemma new_lemma_89296 (h0 : topological_space (distrib (has_nnnorm fun_info))) : path_connected_space (distrib (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_89297 (h0 : not (ring (with_one linarith.ineq) -> false)) : @is_domain.{0} (with_one.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (with_one.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_89298 (h0 : ring (add_cancel_monoid (add_comm_monoid (comm_group (add_comm_monoid name))))) : strong_rank_condition (add_cancel_monoid (add_comm_monoid (comm_group (add_comm_monoid name)))) := sorry --non-trivial
lemma new_lemma_89299 (h0 : topological_space (comm_semigroup (has_pos_part Type))) : totally_separated_space (comm_semigroup (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_89300 (h0 : functor.add_const (topological_space (has_to_string unsigned)) environment.implicit_infer_kind) : @irreducible_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_89301 (h0 : topological_space (ordered_comm_monoid (ring (ring (has_pos_part Type))))) : regular_space (ordered_comm_monoid (ring (ring (has_pos_part Type)))) := sorry --non-trivial
lemma new_lemma_89302 (h0 : functor.add_const (ring (semigroup linarith.comp)) pos) : @is_domain.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_89303 (h0 : monoid (semiring (has_top fun_info))) : monoid.fg (semiring (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_89304 (h0 : semiring (ring Type)) : is_noetherian_ring (ring Type) := sorry --non-trivial
lemma new_lemma_89305 (h0 : functor.add_const (uniform_space (has_to_string environment.implicit_infer_kind)) Type) : @complete_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_89306 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} num (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) num)  := sorry --non-trivial
lemma new_lemma_89307 (h0 : add_group (comm_group (has_add (has_add environment.implicit_infer_kind)))) : is_add_cyclic (comm_group (has_add (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_89308 (h0 : has_mem.mem group has_emptyc.emptyc) : @is_cyclic.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_89309 (h0 : functor.add_const (topological_space (cancel_monoid environment.implicit_infer_kind)) Type) : @locally_compact_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_89310 (h0 : topological_space (has_Inf Type)) : t1_space (has_Inf Type) := sorry --non-trivial
lemma new_lemma_89311 (h0 : topological_space (complete_distrib_lattice (add_comm_monoid name))) : path_connected_space (complete_distrib_lattice (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_89312 (h0 : functor.add_const (ring (add_group unsigned)) empty) : @is_principal_ideal_ring.{0} (add_group.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (add_group.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_89313 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) pos) : @t1_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_89314 (h0 : monoid_with_zero (finset ennreal)) (h1 : nat.arithmetic_function (finset ennreal)) : nat.arithmetic_function.is_multiplicative h1 := sorry --non-trivial
lemma new_lemma_89315 (h0 : set (add_comm_semigroup (add_comm_semigroup ereal) -> char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_89316 (h0 : functor.add_const (semiring (measurable_space.dynkin_system num)) unsigned) : @is_noetherian_ring.{0} (measurable_space.dynkin_system.{0} num) (@functor.add_const.run.{0 0} (semiring.{0} (measurable_space.dynkin_system.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_89317 (h0 : group (has_top (random_gen (random_gen (has_inv to_additive.value_type))))) : is_cyclic (has_top (random_gen (random_gen (has_inv to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_89318 (h0 : topological_space (boolean_algebra real)) : regular_space (boolean_algebra real) := sorry --non-trivial
lemma new_lemma_89319 (h0 : monoid (random_gen (comm_ring (has_norm fun_info)))) : monoid.fg (random_gen (comm_ring (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_89320 (h0 : ring (measurable_space.dynkin_system (has_norm (semiring unsigned)))) : is_domain (measurable_space.dynkin_system (has_norm (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_89321 (h0 : functor.add_const (ring (has_neg linarith.comp)) name) : @strong_rank_condition.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_89322 (h0 : functor.add_const (complete_lattice (comm_group Type)) Type) : @is_atomistic.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (comm_group.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_89323 (h0 : topological_space (linear_ordered_semiring (semiring empty))) : path_connected_space (linear_ordered_semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_89324 (h0 : topological_space (add_cancel_monoid linarith.comp)) : topological_space.separable_space (add_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_89325 (h0 : group (id (random_gen (random_gen string_imp)))) : is_cyclic (id (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_89326 (h0 : topological_space (random_gen (has_top (has_top to_additive.value_type)))) : totally_disconnected_space (random_gen (has_top (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_89327 (h0 : topological_space (has_neg_part (has_nndist pos))) : topological_space.separable_space (has_neg_part (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_89328 (h0 : topological_space (has_neg congr_arg_kind)) : topological_space.separable_space (has_neg congr_arg_kind) := sorry --non-trivial
lemma new_lemma_89329 (h0 : add_monoid (has_add (has_scalar Type (has_scalar name (has_Inf real))))) : add_monoid.fg (has_add (has_scalar Type (has_scalar name (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_89330 (h0 : ring (has_append (random_gen linarith.comp_source))) : is_domain (has_append (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_89331 (h0 : function.extfun Type topological_space) : @normal_space.{0} (normed_linear_ordered_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_linear_ordered_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_89332 (h0 : topological_space (sub_neg_monoid (comm_semigroup real))) : discrete_topology (sub_neg_monoid (comm_semigroup real)) := sorry --non-trivial
lemma new_lemma_89333 (h0 : topological_space (linear_ordered_comm_monoid_with_zero (option unsigned))) : totally_disconnected_space (linear_ordered_comm_monoid_with_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_89334 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_89335 (h0 : uniform_space (measurable_space (has_norm linarith.comp))) : complete_space (measurable_space (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_89336 (h0 : functor.add_const (ring (has_nndist name)) linarith.comp) : @is_principal_ideal_ring.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_89337 (h0 : add_group (boolean_algebra (semigroup (ring Type)))) : is_add_cyclic (boolean_algebra (semigroup (ring Type))) := sorry --non-trivial
lemma new_lemma_89338 (h0 : topological_space (ordered_comm_monoid (ring pos))) : regular_space (ordered_comm_monoid (ring pos)) := sorry --non-trivial
lemma new_lemma_89339 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (add_comm_monoid (option pos))) := sorry --non-trivial
lemma new_lemma_89340 (h0 : functor.add_const (filter (boolean_algebra linarith.comp)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_89341 (h0 : measurable_space string_imp) (h1 : add_group (measure_theory.measure string_imp)) : is_add_cyclic (measure_theory.measure string_imp) := sorry --non-trivial
lemma new_lemma_89342 (h0 : function.extfun Type ring) : @rank_condition.{0} (dlist.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h0 (dlist.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_89343 (h0 : functor.add_const (group (canonically_ordered_add_monoid empty)) empty) : @normalizer_condition.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_89344 (h0 : ordered_comm_monoid (ring (comm_group unsigned))) : has_exists_mul_of_le (ring (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_89345 (h0 : uniform_space (has_sub (has_top (has_top empty)))) : separated_space (has_sub (has_top (has_top empty))) := sorry --non-trivial
lemma new_lemma_89346 (h0 : ring (metric_space (semiring (has_top unsigned)))) : is_domain (metric_space (semiring (has_top unsigned))) := sorry --non-trivial
lemma new_lemma_89347 (h0 : functor.add_const (ring (sub_neg_monoid name)) linarith.comp) : @rank_condition.{0} (sub_neg_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (sub_neg_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_89348 (h0 : functor.add_const (ordered_add_comm_monoid (has_nndist linarith.comp)) linarith.comp) : @archimedean.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_nndist.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_89349 (h0 : functor.add_const (topological_space (has_Sup empty)) empty) : @locally_compact_space.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_89350 (h0 : functor.add_const (topological_space (linear_ordered_comm_group empty)) unsigned) : @t0_space.{0} (linear_ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_group.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_89351 (h0 : group (add_cancel_monoid (finset linarith.comp))) : group.fg (add_cancel_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_89352 (h0 : list (complete_distrib_lattice empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_89353 (h0 : function.extfun (Type 1) finset) : finset.nonempty (function.extfun_app h0 (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_89354 (h0 : monoid (add_cancel_monoid (has_add Type))) : monoid.fg (add_cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_89355 (h0 : not (group (topological_space (has_ssubset char)) -> false)) : @is_cyclic.{0} (topological_space.{0} (has_ssubset.{0} char)) (@classical.by_contradiction'.{1} (group.{0} (topological_space.{0} (has_ssubset.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_89356 (h0 : topological_space (ordered_cancel_add_comm_monoid unsigned)) : t0_space (ordered_cancel_add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_89357 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_89358 (h0 : not (has_mem.mem (random_gen linarith.comp_source) has_emptyc.emptyc -> false)) : @is_add_cyclic.{0} (random_gen.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type add_group.{0} (random_gen.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_89359 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @sequential_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_89360 (h0 : function.extfun Type (prod (complete_distrib_lattice ennreal))) : id_rel (function.extfun_app h0 (complete_distrib_lattice ennreal)) := sorry --non-trivial
lemma new_lemma_89361 (h0 : measurable_space (add_comm_semigroup ereal)) (h1 : set (add_comm_semigroup ereal)) : measurable_set h1 := sorry --non-trivial
lemma new_lemma_89362 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_89363 (h0 : function.extfun Type (functor.add_const (uniform_space (comm_monoid empty)))) : @separated_space.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (comm_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (comm_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_89364 (h0 : filter (group_with_zero num)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_89365 (h0 : list (group_with_zero (option ennreal))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_89366 (h0 : functor.add_const (topological_space (is_R_or_C unsigned)) empty) : @loc_path_connected_space.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_89367 (h0 : complete_lattice (left_cancel_semigroup (semiring (semiring (has_top congr_arg_kind))))) : is_compactly_generated (left_cancel_semigroup (semiring (semiring (has_top congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_89368 (h1 : set (has_lt linarith.comp_source)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_89369 (h0 : uniform_space (normed_lattice_add_comm_group (has_Inf (sub_neg_monoid (has_add real))))) : separated_space (normed_lattice_add_comm_group (has_Inf (sub_neg_monoid (has_add real)))) := sorry --non-trivial
lemma new_lemma_89370 (h0 : not (topological_space (has_sub linarith.comp) -> false)) : @totally_separated_space.{0} (has_sub.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_89371 (h0 : function.extfun Type topological_space) : @t0_space.{0} (normed_group.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} char))  := sorry --non-trivial
lemma new_lemma_89372 (h0 : functor.add_const (topological_space (semigroup unsigned)) pos) : @discrete_topology.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_89373 (h0 : topological_space (plift (has_add unsigned))) : locally_compact_space (plift (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_89374 (h0 : fin has_zero.zero) : @is_noetherian_ring.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (semiring.{1} (comm_semigroup.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_89375 (h0 : not (topological_space (normed_lattice_add_comm_group linarith.ineq) -> false)) : @path_connected_space.{0} (normed_lattice_add_comm_group.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_lattice_add_comm_group.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_89376 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_89377 (h0 : topological_space (preorder (option empty))) : normal_space (preorder (option empty)) := sorry --non-trivial
lemma new_lemma_89378 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_dist num)) := sorry --non-trivial
lemma new_lemma_89379 (h0 : list (comm_monoid (option unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_89380 (h0 : filter (semigroup (comm_group (comm_group (comm_group pos))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_89381 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_89382 (h0 : ring (boolean_algebra.core (comm_monoid (comm_monoid unsigned)))) : rank_condition (boolean_algebra.core (comm_monoid (comm_monoid unsigned))) := sorry --non-trivial
lemma new_lemma_89383 (h0 : ring (boolean_algebra (has_to_string (has_to_string (has_to_string unsigned))))) : is_principal_ideal_ring (boolean_algebra (has_to_string (has_to_string (has_to_string unsigned)))) := sorry --non-trivial
lemma new_lemma_89384 (h0 : complete_lattice (add_right_cancel_monoid (semiring num))) : is_atomistic (add_right_cancel_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_89385 (h0 : function.extfun nat fin) : @separated_space.{0} (has_add.{0} name) (@matrix.vec_empty.{0} (uniform_space.{0} (has_add.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_89386 (h0 : has_lt (mul_one_class (add_comm_semigroup ereal))) : no_max_order (mul_one_class (add_comm_semigroup ereal)) := sorry --non-trivial
lemma new_lemma_89387 (h0 : functor.add_const (uniform_space (mul_zero_class num)) empty) : @complete_space.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (mul_zero_class.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_89388 (h0 : complete_lattice (mul_one_class std_gen)) : complete_lattice.is_Sup_finite_compact (mul_one_class std_gen) := sorry --non-trivial
lemma new_lemma_89389 (h0 : semiring (add_comm_semigroup std_gen)) (h1 : ideal (add_comm_semigroup std_gen)) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_89390 (h0 : group (has_nndist (has_to_string (has_add name)))) : is_simple_group (has_nndist (has_to_string (has_add name))) := sorry --non-trivial
lemma new_lemma_89391 (h0 : topological_space (has_neg_part (measurable_space.dynkin_system unsigned))) : path_connected_space (has_neg_part (measurable_space.dynkin_system unsigned)) := sorry --non-trivial
lemma new_lemma_89392 (h0 : not (topological_space linarith.comp -> false)) : @totally_separated_space.{0} linarith.comp (@classical.by_contradiction'.{1} (topological_space.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_89393 (h0 : ring (add_left_cancel_semigroup empty)) : rank_condition (add_left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_89394 (h0 : functor.add_const (complete_lattice (add_cancel_monoid linarith.comp)) (has_neg (has_neg (has_neg Type)))) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (add_cancel_monoid.{0} linarith.comp)) (has_neg.{1} (has_neg.{1} (has_neg.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_89395 (h0 : function.extfun Type group) : @normalizer_condition.{0} (metric_space.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_89396 (h0 : topological_space (plift (semiring (semiring empty)))) : irreducible_space (plift (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_89397 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (group_with_zero num)) := sorry --non-trivial
lemma new_lemma_89398 (h0 : complete_lattice (has_top string_imp)) : complete_lattice.is_Sup_finite_compact (has_top string_imp) := sorry --non-trivial
lemma new_lemma_89399 (h0 : functor.add_const (ring (has_nndist pos)) pos) : @rank_condition.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_89400 (h0 : add_monoid (has_add (sub_neg_monoid (sub_neg_monoid (ordered_comm_monoid (finset pos)))))) : add_monoid.fg (has_add (sub_neg_monoid (sub_neg_monoid (ordered_comm_monoid (finset pos))))) := sorry --non-trivial
lemma new_lemma_89401 (h0 : has_mem.mem (has_emptyc (random_gen fun_info)) has_emptyc.emptyc) : @irreducible_space.{0} (has_emptyc.{0} (random_gen.{0} fun_info)) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} (random_gen.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_89402 (h0 : add_group (ordered_cancel_add_comm_monoid num)) : is_add_cyclic (ordered_cancel_add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_89403 (h0 : not (topological_space (preorder unsigned) -> false)) : @preirreducible_space.{0} (preorder.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (preorder.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_89404 (h0 : topological_space (has_pos_part (has_Inf (has_bot (sub_neg_monoid real))))) : totally_separated_space (has_pos_part (has_Inf (has_bot (sub_neg_monoid real)))) := sorry --non-trivial
lemma new_lemma_89405 (h0 : functor.add_const (topological_space (finset ennreal)) Type) : @irreducible_space.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_89406 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @locally_compact_space.{1} (plift.{1} congr_arg_kind) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (plift.{1} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_89407 (h0 : topological_space (normed_lattice_add_comm_group pos)) : loc_path_connected_space (normed_lattice_add_comm_group pos) := sorry --non-trivial
lemma new_lemma_89408 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) Type) : @t0_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ordered_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_89409 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) group.{0}) (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_89410 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_89411 (h0 : complete_lattice (normed_comm_ring (semigroup (has_add environment.implicit_infer_kind)))) : is_compactly_generated (normed_comm_ring (semigroup (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_89412 (h0 : not (complete_lattice (has_norm linarith.comp_source) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_norm.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_89413 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_compactly_generated.{0} (partial_order.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) complete_lattice.{0}) (partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_89414 (h0 : list (has_neg_part (comm_group (comm_group name)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_89415 (h0 : topological_space (option (has_to_string num))) : preirreducible_space (option (has_to_string num)) := sorry --non-trivial
lemma new_lemma_89416 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_89417 (h0 : not (has_mem.mem (has_emptyc num) has_emptyc.emptyc -> false)) : @is_add_cyclic.{0} (has_emptyc.{0} num) (@finset.pi.empty.{1 0} Type add_group.{0} (has_emptyc.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_89418 (h0 : functor.add_const (uniform_space (has_to_string pos)) Type) : @separated_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_to_string.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_89419 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system congr_arg_kind)) empty) : @t1_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_89420 (h0 : not (filter (ordered_comm_ring linarith.ineq) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_89421 (h0 : topological_space (linear_ordered_semiring (has_norm (has_norm num)))) : t0_space (linear_ordered_semiring (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_89422 (h0 : functor.add_const (ring (ordered_comm_ring name)) pos) : @rank_condition.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_89423 (h0 : function.extfun nat fin) : @is_simple_group.{0} (has_Inf.{0} pos) (@matrix.vec_empty.{0} (group.{0} (has_Inf.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_89424 (h0 : functor.add_const (filter (ring Type)) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_89425 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (with_one.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_89426 (h0 : topological_space (has_add environment.implicit_infer_kind)) : preirreducible_space (has_add environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_89427 (h0 : cancel_comm_monoid_with_zero (ring (option (option unsigned)))) : unique_factorization_monoid (ring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_89428 (h0 : functor.add_const (add_group (ring linarith.comp)) pos) : @is_add_cyclic.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_89429 (h0 : functor.add_const (ring (semigroup environment.implicit_infer_kind)) linarith.comp) : @is_domain.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_89430 (h0 : group (boolean_algebra (has_add Type))) : is_cyclic (boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_89431 (h0 : group (measurable_space (random_gen (random_gen linarith.ineq)))) : is_cyclic (measurable_space (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_89432 (h0 : functor.add_const (list (finset name)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_89433 (h0 : uniform_space (has_star ennreal)) : complete_space (has_star ennreal) := sorry --non-trivial
lemma new_lemma_89434 (h0 : ring (ordered_comm_ring (ring name))) : rank_condition (ordered_comm_ring (ring name)) := sorry --non-trivial
lemma new_lemma_89435 (h0 : ring (has_zero unsigned)) : rank_condition (has_zero unsigned) := sorry --non-trivial
lemma new_lemma_89436 (h0 : monoid (normed_lattice_add_comm_group (has_dist congr_arg_kind))) : monoid.fg (normed_lattice_add_comm_group (has_dist congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_89437 (h0 : topological_space (has_norm (has_top (has_top linarith.comp_source)))) : t0_space (has_norm (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_89438 (h0 : mul_one_class (random_gen string_imp)) (h1 : filter (dlist (monoid.End (random_gen string_imp)))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_89439 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) pos) : @regular_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_89440 (h0 : functor.add_const (topological_space (has_dist congr_arg_kind)) ennreal) : @t1_space.{0} (has_dist.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} congr_arg_kind)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_89441 (h0 : complete_lattice (distrib (has_nnnorm char))) : is_compactly_generated (distrib (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_89442 (h2 : uniform_space (topological_space (random_gen linarith.ineq))) : complete_space (topological_space (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_89443 (h0 : topological_space (ring (option name))) : t0_space (ring (option name)) := sorry --non-trivial
lemma new_lemma_89444 (h0 : uniform_space (add_comm_monoid (linear_ordered_comm_monoid_with_zero name))) : separated_space (add_comm_monoid (linear_ordered_comm_monoid_with_zero name)) := sorry --non-trivial
lemma new_lemma_89445 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : t0_space real := sorry --non-trivial
lemma new_lemma_89446 (h0 : function.extfun (Type 1) topological_space) : @t1_space.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_89447 (h0 : ring (has_nndist (finset pos))) : strong_rank_condition (has_nndist (finset pos)) := sorry --non-trivial
lemma new_lemma_89448 (h0 : topological_space (semigroup (option (finset name)))) : regular_space (semigroup (option (finset name))) := sorry --non-trivial
lemma new_lemma_89449 (h0 : group (cancel_monoid environment.implicit_infer_kind)) : is_simple_group (cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_89450 (h3 : set (std_gen -> ereal)) : set.separates_points h3 := sorry --non-trivial
lemma new_lemma_89451 (h0 : functor.add_const (ring (normed_group num)) empty) : @is_principal_ideal_ring.{0} (normed_group.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (normed_group.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_89452 (h0 : ordered_add_comm_monoid (cancel_monoid (has_add (has_add Type)))) : archimedean (cancel_monoid (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_89453 (h0 : topological_space (has_nndist (has_add name))) : t1_space (has_nndist (has_add name)) := sorry --non-trivial
lemma new_lemma_89454 (h0 : topological_space (has_norm (has_inv num))) : discrete_topology (has_norm (has_inv num)) := sorry --non-trivial
lemma new_lemma_89455 (h0 : functor.add_const (filter (finset pos)) (has_Inf linarith.comp)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_89456 (h0 : filter (has_nndist (has_well_founded name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_89457 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_separated_space.{0} fun_info (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) fun_info)  := sorry --non-trivial
lemma new_lemma_89458 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @locally_compact_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_89459 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) linarith.comp) : @topological_space.separable_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_89460 (h0 : ordered_add_comm_monoid (linear_ordered_field (has_add name))) : archimedean (linear_ordered_field (has_add name)) := sorry --non-trivial
lemma new_lemma_89461 (h0 : not (group (with_one unsigned) -> false)) : @is_cyclic.{0} (with_one.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (with_one.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_89462 (h0 : monoid (has_bot (has_neg (has_neg pos)))) : monoid.fg (has_bot (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_89463 (h0 : topological_space (add_cancel_monoid (has_nndist (has_Inf linarith.comp)))) : preconnected_space (add_cancel_monoid (has_nndist (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_89464 (h0 : topological_space (has_ssubset (random_gen (has_ssubset (has_ssubset linarith.ineq))))) : path_connected_space (has_ssubset (random_gen (has_ssubset (has_ssubset linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_89465 (h0 : fin has_zero.zero) : @is_cyclic.{0} (comm_semigroup.{0} name) (@matrix.vec_empty.{0} (group.{0} (comm_semigroup.{0} name)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_89466 (h2 : group (complete_semilattice_Sup linarith.comp_source)) : normalizer_condition (complete_semilattice_Sup linarith.comp_source) := sorry --non-trivial
lemma new_lemma_89467 (h0 : topological_space (has_Inf (has_Inf (has_add pos)))) : totally_disconnected_space (has_Inf (has_Inf (has_add pos))) := sorry --non-trivial
lemma new_lemma_89468 (h0 : filter (semigroup (has_add name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_89469 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_89470 (h0 : function.extfun Type (functor.add_const (add_monoid pos))) : @add_monoid.fg.{0} pos (@functor.add_const.run.{0 0} (add_monoid.{0} pos) environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_monoid.{0} pos)) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_89471 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preconnected_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_89472 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_89473 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (linear_ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_89474 (h0 : topological_space (normed_group (has_inv fun_info))) : topological_space.separable_space (normed_group (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_89475 (h0 : topological_space (has_inter (option (option empty)))) : preirreducible_space (has_inter (option (option empty))) := sorry --non-trivial
lemma new_lemma_89476 (h0 : group std_gen) (h1 : subgroup std_gen) : subgroup.fg h1 := sorry --non-trivial
lemma new_lemma_89477 (h0 : add_monoid (semiring (has_norm (free_add_monoid num)))) : add_monoid.fg (semiring (has_norm (free_add_monoid num))) := sorry --non-trivial
lemma new_lemma_89478 (h0 : group (has_norm (has_emptyc linarith.comp))) : group.fg (has_norm (has_emptyc linarith.comp)) := sorry --non-trivial
lemma new_lemma_89479 (h0 : filter (boolean_algebra (has_add linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_89480 (h0 : complete_lattice (has_star empty)) : is_compactly_generated (has_star empty) := sorry --non-trivial
lemma new_lemma_89481 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_89482 (h0 : monoid (has_bot unsigned)) : monoid.fg (has_bot unsigned) := sorry --non-trivial
lemma new_lemma_89483 (h0 : measurable_space fun_info) (h2 : measure_theory.measure fun_info) : measure_theory.is_finite_measure h2 := sorry --non-trivial
lemma new_lemma_89484 (h0 : uniform_space (has_Inf (has_add (has_add (ring pos))))) : complete_space (has_Inf (has_add (has_add (ring pos)))) := sorry --non-trivial
lemma new_lemma_89485 (h0 : topological_space (normed_linear_ordered_group linarith.ineq)) : topological_space.first_countable_topology (normed_linear_ordered_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_89486 (h0 : add_group (simple_graph (has_add (has_neg Type)))) : is_add_cyclic (simple_graph (has_add (has_neg Type))) := sorry --non-trivial
lemma new_lemma_89487 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_89488 (h0 : finset (has_nndist pos)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_89489 (h0 : complete_lattice (has_dist (option (option congr_arg_kind)))) : is_atomistic (has_dist (option (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_89490 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_89491 (h0 : function.extfun Type ring) : @rank_condition.{0} (cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_89492 (h0 : add_monoid (linear_ordered_comm_monoid_with_zero empty)) : add_monoid.fg (linear_ordered_comm_monoid_with_zero empty) := sorry --non-trivial
lemma new_lemma_89493 (h0 : functor.add_const (complete_lattice (add_cancel_monoid linarith.comp)) linarith.comp) : @is_atomistic.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_89494 (h0 : complete_lattice (linear_ordered_field (finset (has_neg (has_neg (has_neg congr_arg_kind)))))) : is_compactly_generated (linear_ordered_field (finset (has_neg (has_neg (has_neg congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_89495 (h1 : topological_space (has_add fun_info)) : t0_space (has_add fun_info) := sorry --non-trivial
lemma new_lemma_89496 (h0 : add_monoid (has_add (has_add (has_pos_part linarith.comp)))) : add_monoid.fg (has_add (has_add (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_89497 (h0 : functor.add_const (topological_space (left_cancel_monoid empty)) num) : @discrete_topology.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_89498 (h0 : function.extfun Type group) : @normalizer_condition.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_89499 (h0 : topological_space (cancel_monoid pos)) : loc_path_connected_space (cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_89500 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @path_connected_space.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_89501 (h0 : function.extfun Type ring) : @is_domain.{0} (complete_semilattice_Sup.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_semilattice_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_89502 (h0 : uniform_space (random_gen (has_nnnorm (has_lt reducibility_hints)))) : complete_space (random_gen (has_nnnorm (has_lt reducibility_hints))) := sorry --non-trivial
lemma new_lemma_89503 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) linarith.comp) : @discrete_topology.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_89504 (h0 : functor.add_const (topological_space (semigroup name)) Type) : @path_connected_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_89505 (h0 : functor.add_const (uniform_space (has_Inf pos)) Type) : @separated_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_Inf.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_89506 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_89507 (h0 : complete_lattice (has_top (has_norm congr_arg_kind))) : is_atomistic (has_top (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_89508 (h0 : add_group reducibility_hints) : is_add_cyclic reducibility_hints := sorry --non-trivial
lemma new_lemma_89509 (h0 : semiring (has_add (has_neg (has_bot pos)))) : is_noetherian_ring (has_add (has_neg (has_bot pos))) := sorry --non-trivial
lemma new_lemma_89510 (h0 : monoid (preorder empty)) : monoid.fg (preorder empty) := sorry --non-trivial
lemma new_lemma_89511 (h0 : function.extfun (Type 1) topological_space) : @topological_space.separable_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_89512 (h0 : add_monoid linarith.comp_source) (h1 : list (add_action linarith.comp_source to_additive.value_type)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_89513 (h0 : function.extfun Type group) : @is_cyclic.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_89514 (h0 : functor.add_const (complete_lattice (semigroup name)) (comm_group name)) : @is_compactly_generated.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} name)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_89515 (h0 : ring (ring (has_pos_part (has_pos_part (has_pos_part linarith.comp))))) : rank_condition (ring (has_pos_part (has_pos_part (has_pos_part linarith.comp)))) := sorry --non-trivial
lemma new_lemma_89516 (h0 : function.extfun Type topological_space) : @t0_space.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_89517 (h0 : topological_space (linear_ordered_semiring (random_gen (has_norm (has_norm (random_gen fun_info)))))) : discrete_topology (linear_ordered_semiring (random_gen (has_norm (has_norm (random_gen fun_info))))) := sorry --non-trivial
lemma new_lemma_89518 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_89519 (h0 : group (with_bot (has_norm (has_norm empty)))) : normalizer_condition (with_bot (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_89520 (h0 : uniform_space (random_gen (has_inv (random_gen to_additive.value_type)))) : complete_space (random_gen (has_inv (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_89521 (h0 h1 : multiset (distrib fun_info)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_89522 (h0 : not (ring (has_union num) -> false)) : @strong_rank_condition.{0} (has_union.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (has_union.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_89523 (h1 : topological_space (has_compl ereal)) : path_connected_space (has_compl ereal) := sorry --non-trivial
lemma new_lemma_89524 (h0 : functor.add_const (topological_space (has_add Type)) (ring Type)) : @irreducible_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_add.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_89525 (h0 : topological_space (has_add (has_nndist linarith.comp))) : totally_separated_space (has_add (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_89526 (h0 : semiring (has_sub (has_norm unsigned))) : is_noetherian_ring (has_sub (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_89527 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_89528 (h0 : topological_space (mul_zero_class (has_pos_part linarith.comp))) : locally_compact_space (mul_zero_class (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_89529 (h0 : ring (has_top (semiring (has_norm linarith.comp)))) : strong_rank_condition (has_top (semiring (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_89530 (h0 : functor.add_const (list (has_dist congr_arg_kind)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_89531 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_89532 (h0 : topological_space (has_inv (has_top (has_inv (has_inv linarith.comp_source))))) : locally_compact_space (has_inv (has_top (has_inv (has_inv linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_89533 (h0 : topological_space (has_bot (has_add linarith.comp))) : loc_path_connected_space (has_bot (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_89534 (h2 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h2) (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_89535 (h0 : monoid (semigroup (normed_comm_ring (finset Type)))) : monoid.fg (semigroup (normed_comm_ring (finset Type))) := sorry --non-trivial
lemma new_lemma_89536 (h0 : ordered_add_comm_monoid (has_pos_part (ring (has_add (ring (boolean_algebra.core linarith.comp)))))) : archimedean (has_pos_part (ring (has_add (ring (boolean_algebra.core linarith.comp))))) := sorry --non-trivial
lemma new_lemma_89537 (h0 : filter (boolean_algebra (has_to_string pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_89538 (h0 : not (add_group (has_append fun_info) -> false)) : @is_add_cyclic.{0} (has_append.{0} fun_info) (@classical.by_contradiction'.{1} (add_group.{0} (has_append.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_89539 (h0 : functor.add_const (finset (complete_distrib_lattice pos)) (has_add (has_neg pos))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_89540 (h0 : functor.add_const (add_monoid (canonically_ordered_comm_semiring pos)) pos) : @add_monoid.fg.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (canonically_ordered_comm_semiring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_89541 (h0 : complete_lattice (fintype to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (fintype to_additive.value_type) := sorry --non-trivial
lemma new_lemma_89542 (h0 : group (has_nndist (has_add (finset pos)))) : is_simple_group (has_nndist (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_89543 (h0 : topological_space (semiring (has_top num))) : path_connected_space (semiring (has_top num)) := sorry --non-trivial
lemma new_lemma_89544 (h0 : topological_space (with_one (comm_ring linarith.ineq))) : locally_compact_space (with_one (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_89545 (h0 : topological_space (normed_lattice_add_comm_group (has_add (has_neg name)))) : t1_space (normed_lattice_add_comm_group (has_add (has_neg name))) := sorry --non-trivial
lemma new_lemma_89546 (h0 : topological_space (simple_graph (has_pos_part (ring Type)))) : regular_space (simple_graph (has_pos_part (ring Type))) := sorry --non-trivial
lemma new_lemma_89547 (h1 : ring (has_emptyc linarith.comp_source)) : strong_rank_condition (has_emptyc linarith.comp_source) := sorry --non-trivial
lemma new_lemma_89548 (h0 : ordered_add_comm_monoid (comm_group (has_add (add_cancel_monoid name)))) : archimedean (comm_group (has_add (add_cancel_monoid name))) := sorry --non-trivial
lemma new_lemma_89549 (h0 : functor.add_const (group (ordered_comm_ring Type)) pos) : @normalizer_condition.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (ordered_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_89550 (h0 : topological_space (boolean_algebra.core linarith.comp)) : preirreducible_space (boolean_algebra.core linarith.comp) := sorry --non-trivial
lemma new_lemma_89551 (h0 : ring (ordered_comm_group unsigned)) : strong_rank_condition (ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_89552 (h0 : functor.add_const (topological_space (finset linarith.comp)) (ring (boolean_algebra (has_neg (finset Type))))) : @normal_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} linarith.comp)) (ring.{1} (boolean_algebra.{1} (has_neg.{1} (finset.{1} Type)))) h0)  := sorry --non-trivial
lemma new_lemma_89553 (h0 : topological_space (encodable (linear_ordered_add_comm_group char))) : path_connected_space (encodable (linear_ordered_add_comm_group char)) := sorry --non-trivial
lemma new_lemma_89554 (h0 : not (topological_space (has_star congr_arg_kind) -> false)) : @discrete_topology.{0} (has_star.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_star.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_89555 (h2 : topological_space std_gen) : path_connected_space std_gen := sorry --non-trivial
lemma new_lemma_89556 (h0 : ring (metric_space (has_nnnorm linarith.ineq))) : is_domain (metric_space (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_89557 (h0 : topological_space (random_gen (has_dist num))) : totally_separated_space (random_gen (has_dist num)) := sorry --non-trivial
lemma new_lemma_89558 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_89559 (h0 : cancel_comm_monoid_with_zero (boolean_algebra (has_neg_part linarith.comp))) : unique_factorization_monoid (boolean_algebra (has_neg_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_89560 (h0 : topological_space (comm_group (comm_group (option unsigned)))) : totally_disconnected_space (comm_group (comm_group (option unsigned))) := sorry --non-trivial
lemma new_lemma_89561 (h0 : topological_space (semigroup (finset (has_Inf linarith.comp)))) : totally_disconnected_space (semigroup (finset (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_89562 (h0 : fin has_zero.zero) : @is_simple_group.{0} (add_comm_monoid.{0} real) (@matrix.vec_empty.{0} (group.{0} (add_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_89563 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (filter.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (filter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_89564 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_89565 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_89566 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (canonically_linear_ordered_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_89567 (h1 : has_lt (mul_one_class (mul_one_class std_gen))) : no_max_order (mul_one_class (mul_one_class std_gen)) := sorry --non-trivial
lemma new_lemma_89568 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_89569 (h0 : ring (comm_monoid congr_arg_kind)) : strong_rank_condition (comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_89570 (h0 : functor.add_const (ordered_comm_monoid (comm_group unsigned)) pos) : @has_exists_mul_of_le.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (comm_group.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_89571 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (encodable.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (encodable.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_89572 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_neg.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_neg.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_89573 (h0 : preorder (has_norm linarith.comp_source)) (h1 : group (topological_space (omega_complete_partial_order.chain (has_norm linarith.comp_source)))) : group.fg (topological_space (omega_complete_partial_order.chain (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_89574 (h0 : functor.add_const (topological_space (add_comm_monoid name)) name) : @preirreducible_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_89575 (h0 : functor.add_const (topological_space (comm_group name)) environment.implicit_infer_kind) : @preirreducible_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_89576 (h2 : num -> Prop) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) num h2  := sorry --non-trivial
lemma new_lemma_89577 (h0 : not (uniform_space (linear_ordered_comm_ring unsigned) -> false)) : @separated_space.{0} (linear_ordered_comm_ring.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (linear_ordered_comm_ring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_89578 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_89579 (h0 : list (has_top (random_gen (denumerable (random_gen linarith.comp_source))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_89580 (h0 : ring (canonically_linear_ordered_monoid (option (option ennreal)))) : is_domain (canonically_linear_ordered_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_89581 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (ordered_comm_ring.{0} linarith.comp) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (ordered_comm_ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_89582 (h0 : has_mem.mem (has_one linarith.comp) has_emptyc.emptyc) : @discrete_topology.{0} (has_one.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_89583 (h0 : functor.add_const (topological_space (option num)) empty) : @topological_space.separable_space.{0} (option.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_89584 (h0 : topological_space (has_zero (has_Inf (has_pos_part linarith.comp)))) : discrete_topology (has_zero (has_Inf (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_89585 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} num (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 num)  := sorry --non-trivial
lemma new_lemma_89586 (h0 : functor.add_const (ordered_add_comm_monoid (has_zero name)) environment.implicit_infer_kind) : @archimedean.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_zero.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_89587 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (add_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (add_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_89588 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} h0 (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_89589 (h4 : set (add_comm_semigroup ereal -> add_comm_semigroup (add_comm_semigroup string.iterator_imp))) : set.separates_points h4 := sorry --non-trivial
lemma new_lemma_89590 (h0 : complete_lattice (linear_ordered_field (option empty))) : is_compactly_generated (linear_ordered_field (option empty)) := sorry --non-trivial
lemma new_lemma_89591 (h0 : not (add_group (linear_ordered_comm_group_with_zero char) -> false)) : @is_add_cyclic.{0} (linear_ordered_comm_group_with_zero.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (linear_ordered_comm_group_with_zero.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_89592 (h0 : functor.add_const (uniform_space (ordered_ring unsigned)) empty) : @separated_space.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_ring.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_89593 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) pos) : @irreducible_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_89594 (h0 : group (finset (option (option ennreal)))) : normalizer_condition (finset (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_89595 (h0 : ring (has_inv (has_nnnorm (has_nnnorm linarith.comp_source)))) : is_domain (has_inv (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_89596 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (ordered_comm_monoid.{0} real) (@matrix.vec_empty.{0} (add_group.{0} (ordered_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_89597 (h0 : topological_space (has_nnnorm fun_info)) : totally_disconnected_space (has_nnnorm fun_info) := sorry --non-trivial
lemma new_lemma_89598 (h1 : topological_space (has_lt (metric_space linarith.comp_source))) : t0_space (has_lt (metric_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_89599 (h0 : uniform_space (add_cancel_monoid (has_zero (has_nndist Type)))) : separated_space (add_cancel_monoid (has_zero (has_nndist Type))) := sorry --non-trivial
lemma new_lemma_89600 (h0 : list (has_top (has_ssubset (has_ssubset (random_gen fun_info))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_89601 (h0 : topological_space (measure_theory.measure_space (semiring empty))) : irreducible_space (measure_theory.measure_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_89602 (h0 : complete_lattice (has_ssubset (comm_ring (random_gen linarith.comp_source)))) : complete_lattice.is_Sup_finite_compact (has_ssubset (comm_ring (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_89603 (h0 : topological_space (denumerable string_imp)) : path_connected_space (denumerable string_imp) := sorry --non-trivial
lemma new_lemma_89604 (h0 : topological_space (mul_zero_class (finset (has_scalar name name)))) : locally_compact_space (mul_zero_class (finset (has_scalar name name))) := sorry --non-trivial
lemma new_lemma_89605 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_modular_lattice.{0} (normed_group.{0} (has_ssubset.{0} linarith.ineq)) (@function.extfun_app.{2 1} Type lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 lattice.{0}) (normed_group.{0} (has_ssubset.{0} linarith.ineq)))  := sorry --non-trivial
lemma new_lemma_89606 (h0 : add_monoid (random_gen (has_inv linarith.comp_source))) (h1 : function.extfun Type random_gen) : is_of_fin_add_order (function.extfun_app h1 (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_89607 (h0 : topological_space (with_bot (has_top fun_info))) : discrete_topology (with_bot (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_89608 (h0 : topological_space (metric_space (semiring (semiring unsigned)))) : totally_disconnected_space (metric_space (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_89609 (h0 : ring (has_to_string (comm_group environment.implicit_infer_kind))) : strong_rank_condition (has_to_string (comm_group environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_89610 (h0 : functor.add_const (topological_space (option unsigned)) (semiring empty)) : @topological_space.separable_space.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} unsigned)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_89611 (h0 : ring (has_to_string (generalized_boolean_algebra (has_pos_part linarith.comp)))) : strong_rank_condition (has_to_string (generalized_boolean_algebra (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_89612 (h0 : not (topological_space (semiring empty) -> false)) : @discrete_topology.{0} (semiring.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_89613 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_89614 (h0 : function.extfun Type group) : @is_cyclic.{0} (complete_semilattice_Sup.{0} char) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_semilattice_Sup.{0} char))  := sorry --non-trivial
lemma new_lemma_89615 (h0 : topological_space (has_add (ordered_ring (ring Type)))) : loc_path_connected_space (has_add (ordered_ring (ring Type))) := sorry --non-trivial
lemma new_lemma_89616 (h0 : functor.add_const (topological_space (has_zero unsigned)) unsigned) : @locally_compact_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_89617 (h0 : uniform_space (ordered_comm_ring (has_add name))) : complete_space (ordered_comm_ring (has_add name)) := sorry --non-trivial
lemma new_lemma_89618 (h0 : topological_space (semigroup (option unsigned))) : t1_space (semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_89619 (h0 : ring (has_add name)) : strong_rank_condition (has_add name) := sorry --non-trivial
lemma new_lemma_89620 (h0 : uniform_space (finset linarith.comp)) : complete_space (finset linarith.comp) := sorry --non-trivial
lemma new_lemma_89621 (h0 : topological_space (measurable_space.dynkin_system linarith.comp)) : locally_compact_space (measurable_space.dynkin_system linarith.comp) := sorry --non-trivial
lemma new_lemma_89622 (h0 : filter (pseudo_metric_space ennreal)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_89623 (h0 : ring pos -> ring pos -> Prop) : is_refl (ring pos) h0 := sorry --non-trivial
lemma new_lemma_89624 (h0 : topological_space (add_group (linear_ordered_semiring congr_arg_kind))) : totally_disconnected_space (add_group (linear_ordered_semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_89625 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_89626 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_to_string.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_to_string.{0} empty))  := sorry --non-trivial
lemma new_lemma_89627 (h0 : ordered_comm_monoid (has_nndist (has_add linarith.comp))) : has_exists_mul_of_le (has_nndist (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_89628 (h0 : cancel_comm_monoid_with_zero (has_to_string (mul_zero_class Type))) : unique_factorization_monoid (has_to_string (mul_zero_class Type)) := sorry --non-trivial
lemma new_lemma_89629 (h0 : functor.add_const (topological_space (has_neg pos)) Type) : @sequential_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_89630 (h0 : topological_space (finset (has_nndist (finset environment.implicit_infer_kind)))) : locally_compact_space (finset (has_nndist (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_89631 (h0 : topological_space (has_neg (finset linarith.comp))) : t0_space (has_neg (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_89632 (h0 : monoid (metric_space (conditionally_complete_linear_order congr_arg_kind))) : monoid.fg (metric_space (conditionally_complete_linear_order congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_89633 (h0 : semiring (has_pos_part (ring linarith.comp))) : is_noetherian_ring (has_pos_part (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_89634 (h1 : function.extfun (linarith.comp_source -> Type) (function.extfun linarith.comp_source)) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) linarith.comp_source (@function.extfun_app.{1 1} linarith.comp_source (λ (x : linarith.comp_source), Prop) (@function.extfun_app.{2 1} (linarith.comp_source → Type) (function.extfun.{1 1} linarith.comp_source) h1 (λ (x : linarith.comp_source), Prop)))  := sorry --non-trivial
lemma new_lemma_89635 (h0 : topological_space (boolean_algebra (finset (finset environment.implicit_infer_kind)))) : totally_separated_space (boolean_algebra (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_89636 (h0 : function.extfun Type topological_space) : @t0_space.{0} (add_monoid.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_monoid.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_89637 (h3 : set (add_comm_semigroup (add_comm_semigroup linarith.ineq))) : set.finite h3 := sorry --non-trivial
lemma new_lemma_89638 (h0 : topological_space (add_comm_monoid (option pos))) : discrete_topology (add_comm_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_89639 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @t1_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_89640 (h0 : functor.add_const (topological_space (has_to_string pos)) (option pos)) : @loc_path_connected_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_89641 (h0 : functor.add_const (add_group (has_neg Type)) (finset (boolean_algebra.core pos))) : @is_add_cyclic.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (has_neg.{1} Type)) (finset.{0} (boolean_algebra.core.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_89642 (h0 : functor.add_const (ring (add_comm_monoid name)) environment.implicit_infer_kind) : @strong_rank_condition.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_89643 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_89644 (h0 : complete_lattice (semiring (has_norm congr_arg_kind))) : is_atomistic (semiring (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_89645 (h0 : topological_space (boolean_algebra (semigroup environment.implicit_infer_kind))) : t1_space (boolean_algebra (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_89646 (h2 : complete_lattice (complete_semilattice_Sup to_additive.value_type)) : is_compactly_generated (complete_semilattice_Sup to_additive.value_type) := sorry --non-trivial
lemma new_lemma_89647 (h0 : function.extfun (Type 1) topological_space) : @path_connected_space.{1} (plift.{1} (option.{0} empty)) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (plift.{1} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_89648 (h0 : ring (filter num)) : rank_condition (filter num) := sorry --non-trivial
lemma new_lemma_89649 (h0 : functor.add_const (add_monoid (left_cancel_monoid empty)) unsigned) : @add_monoid.fg.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (left_cancel_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_89650 (h0 : topological_space (has_neg (finset (finset linarith.comp)))) : path_connected_space (has_neg (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_89651 (h0 : topological_space (simple_graph (finset pos))) : loc_path_connected_space (simple_graph (finset pos)) := sorry --non-trivial
lemma new_lemma_89652 (h0 : ring (mul_zero_class (semiring unsigned))) : is_domain (mul_zero_class (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_89653 (h0 : functor.add_const (functor.comp ring has_add name) Type) : @rank_condition.{0} (has_add.{0} name) (@functor.comp.run.{0 0 0} ring.{0} has_add.{0} name (@functor.add_const.run.{0 1} (functor.comp.{0 0 0} ring.{0} has_add.{0} name) Type h0))  := sorry --non-trivial
lemma new_lemma_89654 (h0 : complete_lattice (measure_theory.measure_space (semiring empty))) : complete_lattice.is_Sup_finite_compact (measure_theory.measure_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_89655 (h0 : functor.add_const (topological_space (free_add_monoid unsigned)) unsigned) : @loc_path_connected_space.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_89656 (h0 : functor.add_const (group (cancel_monoid Type)) (boolean_algebra linarith.comp)) : @is_cyclic.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (cancel_monoid.{1} Type)) (boolean_algebra.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_89657 (h0 : functor.add_const (functor.add_const (topological_space pos) linarith.comp) pos) : @path_connected_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) linarith.comp (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} pos) linarith.comp) pos h0))  := sorry --non-trivial
lemma new_lemma_89658 (h0 : uniform_space (as_linear_order (option unsigned))) : separated_space (as_linear_order (option unsigned)) := sorry --non-trivial
lemma new_lemma_89659 (h0 : list (complete_distrib_lattice (boolean_algebra ennreal))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_89660 (h0 : functor.add_const (group (boolean_algebra pos)) environment.implicit_infer_kind) : @normalizer_condition.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_89661 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_89662 (h0 : complete_lattice (monoid (option ennreal))) : is_compactly_generated (monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_89663 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_89664 (h0 : not (list (linear_ordered_add_comm_group linarith.ineq) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_89665 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_bot.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_89666 (h0 : with_bot (function.extfun Type topological_space)) (h1 : ne h0 has_bot.bot) : @totally_disconnected_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@with_bot.unbot.{1} (function.extfun.{2 1} Type topological_space.{0}) h0 h1) (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_89667 (h1 : complete_lattice (metric_space to_additive.value_type)) : is_compactly_generated (metric_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_89668 (h0 : finset (has_add (has_pos_part (normed_comm_ring environment.implicit_infer_kind)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_89669 (h0 : topological_space (has_Inf (has_add (has_neg (has_add (has_Inf linarith.comp)))))) : normal_space (has_Inf (has_add (has_neg (has_add (has_Inf linarith.comp))))) := sorry --non-trivial
lemma new_lemma_89670 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_89671 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) environment.implicit_infer_kind) : @normal_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_89672 (h0 : topological_space (random_gen (comm_ring (comm_ring fun_info)))) : path_connected_space (random_gen (comm_ring (comm_ring fun_info))) := sorry --non-trivial
lemma new_lemma_89673 (h2 : uniform_space (with_one (topological_space (with_one congr_arg_kind)))) : complete_space (with_one (topological_space (with_one congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_89674 (h0 : group (pseudo_metric_space num)) : normalizer_condition (pseudo_metric_space num) := sorry --non-trivial
lemma new_lemma_89675 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_89676 (h3 : function.extfun Type add_group) : @is_add_cyclic.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} h3 (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_89677 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_dist.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_dist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_89678 (h0 : ring (normed_group (has_norm char))) : is_domain (normed_group (has_norm char)) := sorry --non-trivial
lemma new_lemma_89679 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (ordered_cancel_add_comm_monoid.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_cancel_add_comm_monoid.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_89680 (h0 : topological_space (has_union (semiring (semiring num)))) : path_connected_space (has_union (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_89681 (h0 : linear_ordered_ring (left_cancel_semigroup num)) (h1 : topological_space (floor_ring (left_cancel_semigroup num))) : topological_space.separable_space (floor_ring (left_cancel_semigroup num)) := sorry --non-trivial
lemma new_lemma_89682 (h0 : group (topological_space (random_gen (random_gen (random_gen string_imp))))) : group.fg (topological_space (random_gen (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_89683 (h0 : topological_space (normed_comm_ring pos)) (h1 : has_scalar pos (normed_comm_ring pos)) : properly_discontinuous_smul pos (normed_comm_ring pos) := sorry --non-trivial
lemma new_lemma_89684 (h0 : not (complete_lattice (has_add linarith.ineq) -> false)) : @is_compactly_generated.{0} (has_add.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_add.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_89685 (h0 : finset (has_zero (has_pos_part linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_89686 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : discrete_topology real := sorry --non-trivial
lemma new_lemma_89687 (h0 : topological_space (has_neg_part (boolean_algebra pos))) : discrete_topology (has_neg_part (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_89688 (h0 : functor.add_const (complete_lattice (add_cancel_comm_monoid empty)) unsigned) : @is_compactly_generated.{0} (add_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_comm_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_89689 (h0 : not (uniform_space (normed_field reducibility_hints) -> false)) : @complete_space.{0} (normed_field.{0} reducibility_hints) (@classical.by_contradiction'.{1} (uniform_space.{0} (normed_field.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_89690 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_89691 (h1 : semiring std_gen) (h2 : ideal std_gen) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_89692 (h0 : add_group (ordered_comm_ring name)) : is_add_cyclic (ordered_comm_ring name) := sorry --non-trivial
lemma new_lemma_89693 (h0 : functor.add_const (add_monoid (has_neg_part Type)) name) : @add_monoid.fg.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (has_neg_part.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_89694 (h0 : function.extfun Type (functor.add_const (topological_space (has_Sup unsigned)))) : @totally_disconnected_space.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} unsigned)) (option.{0} unsigned) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_Sup.{0} unsigned))) h0 (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_89695 (h0 : complete_lattice (has_emptyc (has_norm linarith.comp_source))) : is_compactly_generated (has_emptyc (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_89696 (h0 : complete_lattice (has_neg_part (add_comm_monoid pos))) : is_compactly_generated (has_neg_part (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_89697 (h0 : functor.add_const (ring (has_add Type)) (finset pos)) : @is_domain.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_add.{1} Type)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_89698 (h0 : topological_space (filter (option (option empty)))) : t1_space (filter (option (option empty))) := sorry --non-trivial
lemma new_lemma_89699 (h0 : topological_space (non_assoc_semiring (semiring unsigned))) : totally_disconnected_space (non_assoc_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_89700 (h0 : topological_space (has_neg congr_arg_kind)) : path_connected_space (has_neg congr_arg_kind) := sorry --non-trivial
lemma new_lemma_89701 (h0 : group (linear_ordered_add_comm_group (random_gen (denumerable (has_inv linarith.ineq))))) : group.fg (linear_ordered_add_comm_group (random_gen (denumerable (has_inv linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_89702 (h0 : topological_space (with_bot (random_gen (comm_ring (random_gen (random_gen fun_info)))))) : t0_space (with_bot (random_gen (comm_ring (random_gen (random_gen fun_info))))) := sorry --non-trivial
lemma new_lemma_89703 (h0 : topological_space (ring (option (option num)))) : t1_space (ring (option (option num))) := sorry --non-trivial
lemma new_lemma_89704 (h1 : filter (div_inv_monoid char)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_89705 (h0 : has_mem.mem (has_emptyc congr_arg_kind) has_emptyc.emptyc) : @irreducible_space.{0} (has_emptyc.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_89706 (h0 : topological_space (has_compl environment.projection_info)) : totally_disconnected_space (has_compl environment.projection_info) := sorry --non-trivial
lemma new_lemma_89707 (h0 : add_group (has_inv (random_gen (random_gen linarith.ineq)))) : is_add_cyclic (has_inv (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_89708 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_89709 (h0 : ordered_add_comm_monoid (has_neg (finset linarith.comp))) : archimedean (has_neg (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_89710 (h0 : topological_space (with_one (semiring empty))) : t0_space (with_one (semiring empty)) := sorry --non-trivial
lemma new_lemma_89711 (h1 : topological_space (dlist (fintype (has_inv (has_nnnorm fun_info))))) : t0_space (dlist (fintype (has_inv (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_89712 (h0 : topological_space (has_nnnorm string.iterator_imp)) (h1 : add_group (has_nnnorm string.iterator_imp)) : topological_add_group (has_nnnorm string.iterator_imp) := sorry --non-trivial
lemma new_lemma_89713 (h0 : list (has_emptyc (has_norm to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_89714 (h0 : uniform_space (has_append (has_nnnorm linarith.ineq))) : complete_space (has_append (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_89715 (h0 : functor.add_const (function.extfun Type uniform_space) linarith.comp) : @separated_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) linarith.comp h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_89716 (h0 : filter (canonically_ordered_monoid name)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_89717 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_inner.{0 0} unsigned (option.{0} (option.{0} unsigned))) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_inner.{0 0} unsigned (option.{0} (option.{0} unsigned))))  := sorry --non-trivial
lemma new_lemma_89718 (h0 : topological_space (complete_semilattice_Sup (semiring (semiring unsigned)))) : totally_separated_space (complete_semilattice_Sup (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_89719 (h0 : complete_lattice (linear_ordered_semiring (has_norm unsigned))) : is_compactly_generated (linear_ordered_semiring (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_89720 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_principal_ideal_ring.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_89721 (h0 : uniform_space (add_left_cancel_semigroup (option (option (add_left_cancel_semigroup empty))))) : complete_space (add_left_cancel_semigroup (option (option (add_left_cancel_semigroup empty)))) := sorry --non-trivial
lemma new_lemma_89722 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @locally_compact_space.{0} (has_Inf.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (has_Inf.{0} name)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_89723 (h0 : ring (has_to_string (add_comm_monoid (has_add Type)))) : is_domain (has_to_string (add_comm_monoid (has_add Type))) := sorry --non-trivial
lemma new_lemma_89724 (h0 : topological_space (has_to_string (option (option (option (option ennreal)))))) : regular_space (has_to_string (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_89725 (h0 : topological_space (canonically_ordered_comm_semiring (normed_comm_ring pos))) : discrete_topology (canonically_ordered_comm_semiring (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_89726 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_89727 (h0 : functor.add_const (complete_lattice (comm_group Type)) linarith.comp) : @is_atomistic.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (comm_group.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_89728 (h0 : topological_space (boolean_algebra (has_neg linarith.comp))) : t1_space (boolean_algebra (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_89729 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_89730 (h0 : function.extfun Type complete_lattice) : is_atomistic (measurable_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_89731 (h0 : ring (canonically_linear_ordered_monoid num)) : strong_rank_condition (canonically_linear_ordered_monoid num) := sorry --non-trivial
lemma new_lemma_89732 (h0 : complete_lattice (has_emptyc (semiring num))) : is_atomistic (has_emptyc (semiring num)) := sorry --non-trivial
lemma new_lemma_89733 (h0 : cancel_monoid pos -> cancel_monoid pos -> Prop) : reflexive h0 := sorry --non-trivial
lemma new_lemma_89734 (h0 : thunk pnat) (h1 : fin has_zero.zero) : pnat.coprime (@trace_call_stack.{0} pnat h0) (@id.{1} pnat (@matrix.vec_empty.{0} pnat h1))  := sorry --non-trivial
lemma new_lemma_89735 (h0 : topological_space (has_to_string pos)) : topological_space.separable_space (has_to_string pos) := sorry --non-trivial
lemma new_lemma_89736 (h0 : complete_lattice (linear_ordered_semiring num)) : is_atomistic (linear_ordered_semiring num) := sorry --non-trivial
lemma new_lemma_89737 (h0 : topological_space ordering) : regular_space ordering := sorry --non-trivial
lemma new_lemma_89738 (h0 : functor.add_const (topological_space (linear_ordered_comm_monoid_with_zero empty)) empty) : @irreducible_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_89739 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) linarith.comp) : @preirreducible_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_89740 (h0 : function.extfun nat fin) : @is_simple_group.{0} (boolean_algebra.{0} real) (@matrix.vec_empty.{0} (group.{0} (boolean_algebra.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_89741 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} real.angle (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) real.angle)  := sorry --non-trivial
lemma new_lemma_89742 (h0 : topological_space (ordered_comm_ring (has_nndist (has_nndist pos)))) : preconnected_space (ordered_comm_ring (has_nndist (has_nndist pos))) := sorry --non-trivial
lemma new_lemma_89743 (h1 : topological_space (add_comm_semigroup char)) : path_connected_space (add_comm_semigroup char) := sorry --non-trivial
lemma new_lemma_89744 (h0 : group (has_union unsigned)) : is_cyclic (has_union unsigned) := sorry --non-trivial
lemma new_lemma_89745 (h0 : semiring empty -> semiring empty -> Prop) : is_strict_order (semiring empty) h0 := sorry --non-trivial
lemma new_lemma_89746 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} num (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 complete_lattice.{0}) num)  := sorry --non-trivial
lemma new_lemma_89747 (h0 : functor.add_const (list (comm_group Type)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_89748 (h0 : topological_space (free_add_monoid (semiring num))) : normal_space (free_add_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_89749 (h0 : topological_space (add_right_cancel_monoid congr_arg_kind)) : t0_space (add_right_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_89750 (h0 : fun_info -> fun_info -> Prop) : reflexive h0 := sorry --non-trivial
lemma new_lemma_89751 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_89752 (h0 : has_mem.mem (measurable_space empty) has_emptyc.emptyc) : @path_connected_space.{0} (measurable_space.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_89753 (h0 : functor.add_const (group (has_add pos)) linarith.comp) : @is_simple_group.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_89754 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (has_pos_part.{0} linarith.comp) (@matrix.vec_empty.{0} (add_group.{0} (has_pos_part.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_89755 (h2 : complete_lattice char) : complete_lattice.is_Sup_finite_compact char := sorry --non-trivial
lemma new_lemma_89756 (h0 : functor.add_const (add_group (has_neg_part name)) linarith.comp) : @is_add_cyclic.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (has_neg_part.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_89757 (h0 : ring (add_cancel_monoid name)) : strong_rank_condition (add_cancel_monoid name) := sorry --non-trivial
lemma new_lemma_89758 (h0 : filter (ring (normed_comm_ring (ring Type)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_89759 (h2 : set (non_unital_non_assoc_semiring (mul_one_class (mul_one_class string.iterator_imp)))) : set.subsingleton h2 := sorry --non-trivial
lemma new_lemma_89760 (h0 : functor.add_const (function.extfun Type complete_lattice) Type) : @is_compactly_generated.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type complete_lattice.{0}) Type h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_89761 (h0 : topological_space (add_cancel_comm_monoid unsigned)) : locally_compact_space (add_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_89762 (h0 : functor.add_const (topological_space (ring linarith.comp)) environment.implicit_infer_kind) : @topological_space.separable_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_89763 (h0 : topological_space (has_nndist (has_add name))) : topological_space.separable_space (has_nndist (has_add name)) := sorry --non-trivial
lemma new_lemma_89764 (h0 : functor.add_const (topological_space (has_nndist name)) (semigroup environment.implicit_infer_kind)) : @totally_separated_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) (semigroup.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_89765 (h0 : topological_space (ring (has_neg_part Type))) : totally_separated_space (ring (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_89766 (h0 : complete_lattice (distrib_lattice fun_info)) : is_compactly_generated (distrib_lattice fun_info) := sorry --non-trivial
lemma new_lemma_89767 (h0 : fin has_zero.zero) : @discrete_topology.{0} (complete_distrib_lattice.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_89768 (h0 : topological_space (has_emptyc (has_inv (random_gen linarith.ineq)))) : totally_disconnected_space (has_emptyc (has_inv (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_89769 (h4 : set (has_lt linarith.comp_source)) : set.finite h4 := sorry --non-trivial
lemma new_lemma_89770 (h0 : ring (add_cancel_monoid (ring (ordered_semiring (ring Type))))) : strong_rank_condition (add_cancel_monoid (ring (ordered_semiring (ring Type)))) := sorry --non-trivial
lemma new_lemma_89771 (h0 : topological_space (is_R_or_C congr_arg_kind)) : totally_separated_space (is_R_or_C congr_arg_kind) := sorry --non-trivial
lemma new_lemma_89772 (h0 : functor.add_const (monoid (is_R_or_C unsigned)) (option (option unsigned))) : @monoid.fg.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (is_R_or_C.{0} unsigned)) (option.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_89773 (h0 : group (canonically_ordered_comm_semiring (ring linarith.comp))) : is_simple_group (canonically_ordered_comm_semiring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_89774 (h0 : uniform_space (has_neg (comm_group Type))) : separated_space (has_neg (comm_group Type)) := sorry --non-trivial
lemma new_lemma_89775 (h0 : uniform_space (add_comm_monoid (option (ring (option (option unsigned)))))) : complete_space (add_comm_monoid (option (ring (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_89776 (h0 : ring (measurable_space (has_norm (has_norm (has_top fun_info))))) : strong_rank_condition (measurable_space (has_norm (has_norm (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_89777 (h0 : topological_space (id to_additive.value_type)) : totally_separated_space (id to_additive.value_type) := sorry --non-trivial
lemma new_lemma_89778 (h0 : ring (sub_neg_monoid real)) : rank_condition (sub_neg_monoid real) := sorry --non-trivial
lemma new_lemma_89779 (h0 : topological_space (monoid empty)) : path_connected_space (monoid empty) := sorry --non-trivial
lemma new_lemma_89780 (h0 : not (function.extfun (finset Type -> Prop) (function.extfun (finset Type)) -> false)) : @is_atomistic.{0} to_additive.value_type (@finset.pi.empty.{1 0} Type complete_lattice.{0} to_additive.value_type (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) to_additive.value_type) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type))) h0) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) to_additive.value_type)) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_89781 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ring unsigned)) (has_neg_part pos)) : @unique_factorization_monoid.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ring.{0} unsigned)) (has_neg_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_89782 (h0 : functor.add_const (group (has_pos_part pos)) (has_neg pos)) : @normalizer_condition.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_pos_part.{0} pos)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_89783 (h0 : complete_lattice (id congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (id congr_arg_kind) := sorry --non-trivial
lemma new_lemma_89784 (h0 : topological_space (normed_group (semiring (has_norm num)))) : path_connected_space (normed_group (semiring (has_norm num))) := sorry --non-trivial
lemma new_lemma_89785 (h0 : filter (has_norm (semiring (has_top congr_arg_kind)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_89786 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_89787 (h0 : group (has_Inf name)) : is_cyclic (has_Inf name) := sorry --non-trivial
lemma new_lemma_89788 (h0 : functor.add_const (group (has_nndist linarith.comp)) name) : @is_simple_group.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_89789 (h0 : topological_space (has_bot Type)) : totally_disconnected_space (has_bot Type) := sorry --non-trivial
lemma new_lemma_89790 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) pos) : @has_exists_mul_of_le.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) pos h0) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_89791 (h0 : list nnreal) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_89792 (h0 : add_group (comm_monoid unsigned)) : is_add_cyclic (comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_89793 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (add_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_89794 (h0 : filter (boolean_algebra linarith.comp)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_89795 (h0 : function.extfun nat fin) : @sequential_space.{0} (simple_graph.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (simple_graph.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_89796 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_89797 (h0 : finset (non_assoc_semiring (option unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_89798 (h0 : topological_space (linear_ordered_field (option empty))) : preirreducible_space (linear_ordered_field (option empty)) := sorry --non-trivial
lemma new_lemma_89799 (h0 : topological_space (generalized_boolean_algebra (has_neg pos))) : regular_space (generalized_boolean_algebra (has_neg pos)) := sorry --non-trivial
lemma new_lemma_89800 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (mul_zero_class unsigned)) := sorry --non-trivial
lemma new_lemma_89801 (h0 : complete_lattice (ordered_comm_group (option empty))) : is_atomistic (ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_89802 (h0 : not (has_mem.mem (has_inv linarith.comp_source) has_emptyc.emptyc -> false)) : @totally_disconnected_space.{0} (has_inv.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_inv.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_inv.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_89803 (h0 : add_group stieltjes_function) : is_add_cyclic stieltjes_function := sorry --non-trivial
lemma new_lemma_89804 (h1 : complete_lattice (has_compl (non_unital_non_assoc_semiring reducibility_hints))) : is_compactly_generated (has_compl (non_unital_non_assoc_semiring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_89805 (h0 : function.extfun (Type 1) group) : @normalizer_condition.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_89806 (h0 : fin has_zero.zero) : @is_domain.{1} (boolean_algebra.core.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (boolean_algebra.core.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_89807 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_89808 (h0 : uniform_space (has_ssubset (has_ssubset linarith.ineq))) : complete_space (has_ssubset (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_89809 (h0 : topological_space (monoid (option (option (option (option (option (option (option ennreal))))))))) : t1_space (monoid (option (option (option (option (option (option (option ennreal)))))))) := sorry --non-trivial
lemma new_lemma_89810 (h0 : topological_space (comm_semigroup name)) : t1_space (comm_semigroup name) := sorry --non-trivial
lemma new_lemma_89811 (h0 : topological_space (has_neg_part (finset pos))) : totally_separated_space (has_neg_part (finset pos)) := sorry --non-trivial
lemma new_lemma_89812 (h0 : ring (boolean_algebra.core (has_add (semigroup (has_zero name))))) : rank_condition (boolean_algebra.core (has_add (semigroup (has_zero name)))) := sorry --non-trivial
lemma new_lemma_89813 (h0 : complete_lattice (omega_complete_partial_order empty)) : is_compactly_generated (omega_complete_partial_order empty) := sorry --non-trivial
lemma new_lemma_89814 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (non_assoc_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (non_assoc_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_89815 (h0 : functor.add_const (complete_lattice (add_group_with_zero_nhd unsigned)) empty) : @is_compactly_generated.{0} (add_group_with_zero_nhd.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_group_with_zero_nhd.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_89816 (h0 : ring (complete_semilattice_Sup (complete_semilattice_Sup string_imp))) : strong_rank_condition (complete_semilattice_Sup (complete_semilattice_Sup string_imp)) := sorry --non-trivial
lemma new_lemma_89817 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_89818 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (linear_ordered_cancel_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_89819 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_89820 (h0 : topological_space (left_cancel_monoid (option (option (option unsigned))))) : totally_disconnected_space (left_cancel_monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_89821 (h0 : functor.add_const (group (has_to_string Type)) (has_neg linarith.comp)) : @group.fg.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_to_string.{1} Type)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_89822 (h0 : functor.add_const (prod (left_cancel_monoid unsigned) (left_cancel_monoid unsigned)) empty) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_89823 (h0 : measurable_space (comm_group empty)) (h1 : has_add (comm_group empty)) : has_measurable_add (comm_group empty) := sorry --non-trivial
lemma new_lemma_89824 (h0 : list (measurable_space (has_norm (random_gen (random_gen linarith.ineq))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_89825 (h0 : topological_space (has_to_string (finset name))) : topological_space.separable_space (has_to_string (finset name)) := sorry --non-trivial
lemma new_lemma_89826 (h0 : functor.add_const (add_group (add_comm_monoid name)) linarith.comp) : @is_add_cyclic.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (add_comm_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_89827 (h0 : uniform_space (ring num)) : separated_space (ring num) := sorry --non-trivial
lemma new_lemma_89828 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_89829 (h0 : functor.add_const (function.extfun Type ring) (boolean_algebra name)) : @rank_condition.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (boolean_algebra.{0} name) h0) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_89830 (h0 : monoid (has_union (semiring (semiring (semiring congr_arg_kind))))) : monoid.fg (has_union (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_89831 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_89832 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (linear_ordered_field ennreal)) := sorry --non-trivial
lemma new_lemma_89833 (h0 : topological_space (has_zero (has_Inf pos))) : loc_path_connected_space (has_zero (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_89834 (h0 : function.extfun nat fin) : @add_monoid.fg.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (add_monoid.{1} (has_add.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_89835 (h1 : complete_lattice (semi_normed_comm_ring enat)) : complete_lattice.is_Sup_finite_compact (semi_normed_comm_ring enat) := sorry --non-trivial
lemma new_lemma_89836 (h0 : functor.add_const Prop (has_zero (option ennreal))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_89837 (h0 : topological_space (has_to_string (finset linarith.comp))) : loc_path_connected_space (has_to_string (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_89838 (h0 : eq (add_group (random_gen (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))))) fun_info) (h1 : fun_info) : @is_add_cyclic.{0} (random_gen.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} fun_info)))))) (@eq.mpr.{1} (add_group.{0} (random_gen.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} fun_info))))))) fun_info h0 h1)  := sorry --non-trivial
lemma new_lemma_89839 (h0 : group (linear_ordered_semiring (random_gen linarith.comp_source))) : normalizer_condition (linear_ordered_semiring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_89840 (h0 : has_mem.mem (with_bot unsigned) has_emptyc.emptyc) : @t0_space.{0} (with_bot.{0} unsigned) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_89841 (h0 : filter (id fun_info)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_89842 (h0 : list (semiring (has_top fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_89843 (h0 : ring (add_cancel_monoid (has_add (has_zero linarith.comp)))) : is_domain (add_cancel_monoid (has_add (has_zero linarith.comp))) := sorry --non-trivial
lemma new_lemma_89844 (h0 : topological_space (add_comm_monoid (finset Type))) : locally_compact_space (add_comm_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_89845 (h0 : topological_space (linear_ordered_add_comm_group (random_gen linarith.comp_source))) : t0_space (linear_ordered_add_comm_group (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_89846 (h0 : ring (linear_ordered_semiring linarith.ineq)) : rank_condition (linear_ordered_semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_89847 (h0 : topological_space (canonically_linear_ordered_monoid (ordered_comm_monoid Type))) : preirreducible_space (canonically_linear_ordered_monoid (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_89848 (h0 : group (add_right_cancel_monoid num)) : normalizer_condition (add_right_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_89849 (h0 : ring (group_with_zero (option (option unsigned)))) : is_domain (group_with_zero (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_89850 (h0 : functor.add_const (functor.add_const (add_group (add_left_cancel_semigroup empty)) empty) num) : @is_add_cyclic.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (add_left_cancel_semigroup.{0} empty)) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (add_group.{0} (add_left_cancel_semigroup.{0} empty)) empty) num h0))  := sorry --non-trivial
lemma new_lemma_89851 (h0 : uniform_space (has_bot (has_Inf (has_Inf pos)))) : complete_space (has_bot (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_89852 (h2 : uniform_space (uniform_space linarith.ineq)) : complete_space (uniform_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_89853 (h0 : uniform_space (complete_distrib_lattice (ring linarith.comp))) : separated_space (complete_distrib_lattice (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_89854 (h1 : topological_space (mul_one_class ereal)) : t0_space (mul_one_class ereal) := sorry --non-trivial
lemma new_lemma_89855 (h3 : add_group (has_ssubset linarith.ineq)) : is_add_cyclic (has_ssubset linarith.ineq) := sorry --non-trivial
lemma new_lemma_89856 (h0 : group (add_cancel_comm_monoid string_imp)) : is_cyclic (add_cancel_comm_monoid string_imp) := sorry --non-trivial
lemma new_lemma_89857 (h1 : ring (has_lt (random_gen string_imp))) : is_domain (has_lt (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_89858 (h0 : ring (add_left_cancel_monoid string_imp)) : strong_rank_condition (add_left_cancel_monoid string_imp) := sorry --non-trivial
lemma new_lemma_89859 (h0 : not (group (add_group empty) -> false)) : @group.fg.{0} (add_group.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (add_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_89860 (h0 : ring (plift (option unsigned))) : strong_rank_condition (plift (option unsigned)) := sorry --non-trivial
lemma new_lemma_89861 (h0 : topological_space (finset (has_add (has_add pos)))) : preconnected_space (finset (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_89862 (h0 : topological_space (comm_ring (has_ssubset (random_gen fun_info)))) : t0_space (comm_ring (has_ssubset (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_89863 (h0 : functor.add_const (complete_lattice (canonically_ordered_comm_semiring linarith.comp)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_89864 (h0 : add_group (add_group (semiring empty))) : is_add_cyclic (add_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_89865 (h0 : ring (has_neg (has_Inf (finset (has_neg Type))))) : strong_rank_condition (has_neg (has_Inf (finset (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_89866 (h0 : function.extfun Type group) : @group.fg.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_89867 (h0 : list (complete_distrib_lattice (option (option unsigned)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_89868 (h0 : filter (simple_graph (has_pos_part (boolean_algebra.core Type)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_89869 (h0 : fin has_zero.zero) : @t0_space.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (ordered_cancel_add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_89870 (h0 : topological_space (has_union (has_nnnorm fun_info))) : path_connected_space (has_union (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_89871 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_89872 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @t0_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_89873 (h0 : pnat) (h1 : thunk (ulower pnat)) : @id.{1} Prop (pnat.coprime h0 (@ulower.up.{0} pnat encodable.pnat (@trace_call_stack.{0} (@ulower.{0} pnat encodable.pnat) h1)))  := sorry --non-trivial
lemma new_lemma_89874 (h0 : filter (has_dist unsigned)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_89875 (h0 : uniform_space (has_lt (metric_space (metric_space to_additive.value_type)))) : complete_space (has_lt (metric_space (metric_space to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_89876 (h0 : ring (has_compl (has_nnnorm linarith.comp_source))) : is_domain (has_compl (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_89877 (h2 : topological_space (has_inv (random_gen (random_gen linarith.ineq)))) : totally_separated_space (has_inv (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_89878 (h0 : topological_space (id (semiring empty))) : totally_disconnected_space (id (semiring empty)) := sorry --non-trivial
lemma new_lemma_89879 (h0 : topological_space (with_bot (semiring (semiring congr_arg_kind)))) : normal_space (with_bot (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_89880 (h0 : function.extfun Type (functor.add_const (topological_space (omega_complete_partial_order unsigned)))) : @totally_disconnected_space.{0} (omega_complete_partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (omega_complete_partial_order.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (omega_complete_partial_order.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_89881 (h0 : topological_space environment.projection_info) : t0_space environment.projection_info := sorry --non-trivial
lemma new_lemma_89882 (h0 : ring (finset (canonically_linear_ordered_monoid Type))) : strong_rank_condition (finset (canonically_linear_ordered_monoid Type)) := sorry --non-trivial
lemma new_lemma_89883 (h0 : ring (add_comm_monoid (finset Type))) : rank_condition (add_comm_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_89884 (h0 : functor.add_const (list (normed_comm_ring linarith.comp)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_89885 (h0 : functor.add_const (ordered_add_comm_monoid (free_add_monoid empty)) (semiring (semiring unsigned))) : @archimedean.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (free_add_monoid.{0} empty)) (semiring.{0} (semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_89886 (h1 : ring (simple_graph reducibility_hints)) : is_domain (simple_graph reducibility_hints) := sorry --non-trivial
lemma new_lemma_89887 (h0 : has_star (simple_graph fun_info)) (h1 : has_lt (has_trivial_star (simple_graph fun_info))) : no_max_order (has_trivial_star (simple_graph fun_info)) := sorry --non-trivial
lemma new_lemma_89888 (h0 : not (add_group (uniform_space linarith.ineq) -> false)) : @is_add_cyclic.{0} (uniform_space.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (uniform_space.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_89889 (h0 : ring (has_pos_part (has_neg Type))) : rank_condition (has_pos_part (has_neg Type)) := sorry --non-trivial
lemma new_lemma_89890 (h0 : finset (pseudo_metric_space (option num))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_89891 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen num))) : @is_compactly_generated.{0} (random_gen.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_89892 (h0 : complete_lattice (comm_group ennreal)) : is_atomistic (comm_group ennreal) := sorry --non-trivial
lemma new_lemma_89893 (h0 : preorder ereal) (h1 : set ereal) : nonempty (bdd_above h1) := sorry --non-trivial
lemma new_lemma_89894 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_89895 (h0 : not (group (canonically_ordered_add_monoid to_additive.value_type) -> false)) : @group.fg.{0} (canonically_ordered_add_monoid.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (canonically_ordered_add_monoid.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_89896 (h0 : not (ring (metric_space string_imp) -> false)) : @is_domain.{0} (metric_space.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (metric_space.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_89897 (h0 : complete_lattice (normed_lattice_add_comm_group real)) : is_atomistic (normed_lattice_add_comm_group real) := sorry --non-trivial
lemma new_lemma_89898 (h0 : functor.add_const (topological_space (add_cancel_monoid ennreal)) pos) : @regular_space.{0} (add_cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_89899 (h1 : add_group (comm_ring (metric_space to_additive.value_type))) : is_add_cyclic (comm_ring (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_89900 (h0 : topological_space (add_comm_monoid (has_to_string Type))) : discrete_topology (add_comm_monoid (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_89901 (h1 : monoid (has_emptyc linarith.comp_source)) : monoid.fg (has_emptyc linarith.comp_source) := sorry --non-trivial
lemma new_lemma_89902 (h0 : function.extfun Type group) : @is_cyclic.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_89903 (h0 : finset (plift (semiring (semiring (semiring (semiring congr_arg_kind)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_89904 (h1 : set (has_sdiff linarith.comp_source)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_89905 (h0 : ring (option unsigned)) : is_domain (option unsigned) := sorry --non-trivial
lemma new_lemma_89906 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_89907 (h0 : ring (linear_ordered_semiring (semiring num))) : strong_rank_condition (linear_ordered_semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_89908 (h0 : function.extfun (Type 1) topological_space) : @totally_disconnected_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_89909 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_89910 (h0 : topological_space (finset (has_nndist (semilattice_inf pos)))) : totally_separated_space (finset (has_nndist (semilattice_inf pos))) := sorry --non-trivial
lemma new_lemma_89911 (h0 : list (add_cancel_monoid (finset (has_Inf (normed_comm_ring pos))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_89912 (h0 : topological_space (has_well_founded (right_cancel_semigroup Type))) : locally_compact_space (has_well_founded (right_cancel_semigroup Type)) := sorry --non-trivial
lemma new_lemma_89913 (h0 : functor.comp semiring add_comm_monoid ennreal) : @is_noetherian_ring.{0} (add_comm_monoid.{0} ennreal) (@functor.comp.run.{0 0 0} semiring.{0} add_comm_monoid.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_89914 (h0 : has_mem.mem (has_emptyc to_additive.value_type) has_emptyc.emptyc) : @strong_rank_condition.{0} (has_emptyc.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type ring.{0} (has_emptyc.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_89915 (h0 : filter (with_bot (semiring (semiring unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_89916 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_89917 (h0 : complete_lattice (has_neg (boolean_algebra linarith.comp))) : is_atomistic (has_neg (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_89918 (h0 : filter (canonically_linear_ordered_monoid pos)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_89919 (h0 : functor.add_const (ring (has_neg_part unsigned)) pos) : @strong_rank_condition.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_neg_part.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_89920 (h1 : ring (distrib (has_ssubset to_additive.value_type))) : strong_rank_condition (distrib (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_89921 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_89922 (h0 : add_monoid (with_one (has_top (has_top linarith.comp)))) : add_monoid.fg (with_one (has_top (has_top linarith.comp))) := sorry --non-trivial
lemma new_lemma_89923 (h0 : topological_space (has_nndist (ring (ring (add_cancel_monoid (finset (finset (finset name)))))))) : t0_space (has_nndist (ring (ring (add_cancel_monoid (finset (finset (finset name))))))) := sorry --non-trivial
lemma new_lemma_89924 (h0 : not (add_group (has_lt reducibility_hints) -> false)) : @is_add_cyclic.{0} (has_lt.{0} reducibility_hints) (@classical.by_contradiction'.{1} (add_group.{0} (has_lt.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_89925 (h0 : functor.add_const (ring (boolean_algebra pos)) (has_neg pos)) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} pos)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_89926 (h0 : functor.add_const (ring (normed_comm_ring pos)) Type) : @is_domain.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (normed_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_89927 (h0 : function.extfun Type topological_space) : topological_space.separable_space real := sorry --non-trivial
lemma new_lemma_89928 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_89929 (h0 : not (ring (has_append (has_nnnorm fun_info)) -> false)) : @is_domain.{0} (has_append.{0} (has_nnnorm.{0} fun_info)) (@classical.by_contradiction'.{1} (ring.{0} (has_append.{0} (has_nnnorm.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_89930 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_89931 (h0 : pnat) (h1 : fin has_zero.zero) (h2 : list (fin has_zero.zero)) : pnat.coprime h0 (matrix.vec_empty (list.ilast' h1 h2)) := sorry --non-trivial
lemma new_lemma_89932 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_89933 (h0 : measurable_space (has_compl linarith.comp_source)) (h1 : filter (has_compl linarith.comp_source)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_89934 (h0 : functor.add_const (topological_space (has_neg name)) pos) : @t1_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_89935 (h0 : topological_space (has_nndist (has_neg_part environment.implicit_infer_kind))) : totally_separated_space (has_nndist (has_neg_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_89936 (h0 : add_group (has_ssubset (with_bot (random_gen to_additive.value_type)))) : is_add_cyclic (has_ssubset (with_bot (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_89937 (h0 : functor.add_const (function.extfun Type topological_space) (add_comm_monoid pos)) : @locally_compact_space.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (add_comm_monoid.{0} pos) h0) (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_89938 (h0 : add_group (has_sdiff (add_comm_semigroup linarith.ineq))) : is_add_cyclic (has_sdiff (add_comm_semigroup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_89939 (h0 : topological_space (plift (group_with_zero unsigned))) : loc_path_connected_space (plift (group_with_zero unsigned)) := sorry --non-trivial
lemma new_lemma_89940 (h0 : group (left_cancel_semigroup (semiring congr_arg_kind))) : is_cyclic (left_cancel_semigroup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_89941 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_ordered_semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_89942 (h0 : functor.add_const (topological_space (has_neg_part pos)) linarith.comp) : @locally_compact_space.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_89943 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (pseudo_metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (pseudo_metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_89944 (h0 : functor.add_const (ring (finset Type)) ennreal) : @is_principal_ideal_ring.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (finset.{1} Type)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_89945 (h0 : functor.add_const (ring (has_nndist pos)) name) : @is_domain.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_89946 (h0 : has_mem.mem (has_emptyc linarith.comp_source) has_emptyc.emptyc) : @is_add_cyclic.{0} (has_emptyc.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type add_group.{0} (has_emptyc.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_89947 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_comm_group.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_89948 (h0 : ring (canonically_linear_ordered_monoid real)) : is_domain (canonically_linear_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_89949 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (canonically_ordered_monoid.{0} (has_Inf.{0} pos)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} (has_Inf.{0} pos)))  := sorry --non-trivial
lemma new_lemma_89950 (h0 : group (random_gen (has_top unsigned))) : group.fg (random_gen (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_89951 (h0 : topological_space (linear_ordered_comm_group (option ennreal))) : irreducible_space (linear_ordered_comm_group (option ennreal)) := sorry --non-trivial
lemma new_lemma_89952 (h0 : not (topological_space (topological_space linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (topological_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (topological_space.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_89953 (h0 : uniform_space (ring (has_pos_part (has_pos_part linarith.comp)))) : complete_space (ring (has_pos_part (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_89954 (h0 : topological_space (normed_comm_ring (has_add (boolean_algebra.core Type)))) : preirreducible_space (normed_comm_ring (has_add (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_89955 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_89956 (h0 : ring (linear_ordered_semiring (has_top to_additive.value_type))) : is_domain (linear_ordered_semiring (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_89957 (h0 : functor.add_const (topological_space (comm_semigroup pos)) real) : @normal_space.{0} (comm_semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_semigroup.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_89958 (h1 : function.extfun Type group) : @group.fg.{0} (@id.{2} Type string_imp) (@function.extfun_app.{2 1} Type group.{0} h1 (@id.{2} Type string_imp))  := sorry --non-trivial
lemma new_lemma_89959 (h0 : functor.add_const (topological_space (has_to_string unsigned)) (option name)) : @irreducible_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) (option.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_89960 (h0 : functor.add_const (filter (boolean_algebra linarith.comp)) (normed_comm_ring Type)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_89961 (h0 : filter (finset num)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_89962 (h0 : ring (has_add pos)) : is_principal_ideal_ring (has_add pos) := sorry --non-trivial
lemma new_lemma_89963 (h0 : topological_space (boolean_algebra (boolean_algebra linarith.comp))) : normal_space (boolean_algebra (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_89964 (h0 : topological_space (comm_group (boolean_algebra (boolean_algebra (boolean_algebra Type))))) : path_connected_space (comm_group (boolean_algebra (boolean_algebra (boolean_algebra Type)))) := sorry --non-trivial
lemma new_lemma_89965 (h0 : not (group (complete_semilattice_Sup unsigned) -> false)) : @group.fg.{0} (complete_semilattice_Sup.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (complete_semilattice_Sup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_89966 (h0 : topological_space (add_cancel_monoid (ring pos))) : preconnected_space (add_cancel_monoid (ring pos)) := sorry --non-trivial
lemma new_lemma_89967 (h1 : ring (add_cancel_comm_monoid string_imp)) : strong_rank_condition (add_cancel_comm_monoid string_imp) := sorry --non-trivial
lemma new_lemma_89968 (h0 : functor.add_const (topological_space (has_zero pos)) linarith.comp) : @t1_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_89969 (h0 : topological_space (linear_ordered_field num)) : normal_space (linear_ordered_field num) := sorry --non-trivial
lemma new_lemma_89970 (h0 : char -> fintype (fintype (fintype (fintype (distrib (has_append (topological_space char)))))) -> char) : right_commutative h0 := sorry --non-trivial
lemma new_lemma_89971 (h0 : topological_space (has_div to_additive.value_type)) (h1 : add_group (has_div to_additive.value_type)) : topological_add_group (has_div to_additive.value_type) := sorry --non-trivial
lemma new_lemma_89972 (h0 : functor.add_const (complete_lattice (canonically_linear_ordered_monoid ennreal)) congr_arg_kind) : @is_atomistic.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_linear_ordered_monoid.{0} ennreal)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_89973 (h0 : not (complete_lattice (comm_ring string_imp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (comm_ring.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (comm_ring.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_89974 (h1 : topological_space (add_comm_semigroup (mul_one_class (normed_field char)))) (h2 : preorder (add_comm_semigroup (mul_one_class (normed_field char)))) : order_topology (add_comm_semigroup (mul_one_class (normed_field char))) := sorry --non-trivial
lemma new_lemma_89975 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) linarith.comp) : @has_exists_mul_of_le.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) linarith.comp h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_89976 (h0 : not (monoid (preorder congr_arg_kind) -> false)) : @monoid.fg.{0} (preorder.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (monoid.{0} (preorder.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_89977 (h1 : list (measurable_space (with_bot string_imp))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_89978 (h0 : function.extfun (((Type -> Type) -> Type 1) -> Type 1) (function.extfun ((Type -> Type) -> Type 1))) : @is_add_cyclic.{0} (comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (@function.extfun_app.{3 3} (((Type → Type) → Type 1) → Type 1) (function.extfun.{3 2} ((Type → Type) → Type 1)) h0 (function.extfun.{2 2} (Type → Type))) (function.extfun.{2 1} Type)) add_group.{0}) (comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_89979 (h0 : list (semi_normed_comm_ring linarith.ineq)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_89980 (h0 : functor.add_const (topological_space (add_cancel_comm_monoid unsigned)) empty) : @discrete_topology.{0} (add_cancel_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_comm_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_89981 (h0 : topological_space (add_cancel_monoid (has_neg environment.implicit_infer_kind))) : regular_space (add_cancel_monoid (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_89982 (h0 : topological_space (normed_comm_ring ennreal)) : preirreducible_space (normed_comm_ring ennreal) := sorry --non-trivial
lemma new_lemma_89983 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_89984 (h0 : semiring (has_Inf name)) : is_noetherian_ring (has_Inf name) := sorry --non-trivial
lemma new_lemma_89985 (h0 : function.extfun Type ring) : @rank_condition.{0} (canonically_linear_ordered_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_linear_ordered_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_89986 (h0 : topological_space (mul_zero_class (finset Type))) : discrete_topology (mul_zero_class (finset Type)) := sorry --non-trivial
lemma new_lemma_89987 (h0 : topological_space (boolean_algebra (finset name))) : topological_space.separable_space (boolean_algebra (finset name)) := sorry --non-trivial
lemma new_lemma_89988 (h0 : topological_space (monoid_with_zero unsigned)) : preirreducible_space (monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_89989 (h0 : monoid (add_right_cancel_monoid (semiring (semiring unsigned)))) : monoid.fg (add_right_cancel_monoid (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_89990 (h0 : not (ring (distrib (has_nnnorm linarith.comp_source)) -> false)) : @rank_condition.{0} (distrib.{0} (has_nnnorm.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} (has_nnnorm.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_89991 (h0 : finset (left_cancel_semigroup (option (option (option (option empty)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_89992 (h1 : complete_lattice to_additive.value_type) : complete_lattice.is_Sup_finite_compact to_additive.value_type := sorry --non-trivial
lemma new_lemma_89993 (h0 : group (has_Inf (has_add (has_add pos)))) : is_cyclic (has_Inf (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_89994 (h0 : list (ordered_cancel_add_comm_monoid num)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_89995 (h0 : not (topological_space unsigned -> false)) : @locally_compact_space.{0} unsigned (@classical.by_contradiction'.{1} (topological_space.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_89996 (h0 : list (has_neg (normed_comm_ring pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_89997 (h0 : add_group (metric_space (random_gen char))) : is_add_cyclic (metric_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_89998 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) pos) : @normal_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_89999 (h1 : fin has_zero.zero) : @t0_space.{0} (semi_normed_comm_ring.{0} string_imp) (@matrix.vec_empty.{0} (topological_space.{0} (semi_normed_comm_ring.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_90000 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_90001 (h1 : topological_space (mul_one_class (normed_field linarith.ineq))) (h2 : set (mul_one_class (normed_field linarith.ineq))) : is_path_connected h2 := sorry --non-trivial
lemma new_lemma_90002 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (normed_linear_ordered_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_90003 (h0 : topological_space (id linarith.comp)) : preirreducible_space (id linarith.comp) := sorry --non-trivial
lemma new_lemma_90004 (h0 : topological_space (has_zero (has_add pos))) : preconnected_space (has_zero (has_add pos)) := sorry --non-trivial
lemma new_lemma_90005 (h0 : topological_space (canonically_ordered_monoid (has_Inf (has_add pos)))) : regular_space (canonically_ordered_monoid (has_Inf (has_add pos))) := sorry --non-trivial
lemma new_lemma_90006 (h1 : function.extfun Type ring) : @strong_rank_condition.{0} linarith.comp (@function.extfun_app.{2 1} Type ring.{0} h1 linarith.comp)  := sorry --non-trivial
lemma new_lemma_90007 (h1 : filter (with_one linarith.comp)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_90008 (h0 : topological_space (normed_group (has_norm linarith.comp_source))) : totally_disconnected_space (normed_group (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_90009 (h0 : add_monoid (semigroup (has_to_string (has_to_string pos)))) : add_monoid.fg (semigroup (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_90010 (h0 : topological_space (generalized_boolean_algebra Type)) : path_connected_space (generalized_boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_90011 (h1 : ring (distrib_lattice (has_nnnorm fun_info))) : rank_condition (distrib_lattice (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_90012 (h0 : function.extfun (Type 1) topological_space) : @discrete_topology.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_90013 (h0 : functor.add_const (group (has_star num)) (option (semiring num))) : @group.fg.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (group.{0} (has_star.{0} num)) (option.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_90014 (h0 : ring (canonically_linear_ordered_monoid (has_add real))) : rank_condition (canonically_linear_ordered_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_90015 (h0 : functor.add_const (group (ordered_comm_ring linarith.comp)) (has_neg pos)) : @is_cyclic.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (ordered_comm_ring.{0} linarith.comp)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_90016 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @t1_space.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_90017 (h0 : list (ordered_comm_monoid (ring pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_90018 (h0 : function.extfun Type topological_space) : @t0_space.{0} (linear_ordered_cancel_add_comm_monoid.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_cancel_add_comm_monoid.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_90019 (h0 : function.extfun Type topological_space) : @t0_space.{0} (canonically_ordered_comm_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_90020 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) linarith.comp) : @regular_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_90021 (h0 : functor.comp topological_space has_to_string pos) : @irreducible_space.{0} (has_to_string.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_90022 (h0 : function.extfun Type group) : @normalizer_condition.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_90023 (h0 : functor.add_const (functor.add_const (functor.add_const Prop Type) linarith.comp) name) : functor.add_const.run (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_90024 (h0 : ordered_add_comm_monoid (has_add (has_neg pos))) : archimedean (has_add (has_neg pos)) := sorry --non-trivial
lemma new_lemma_90025 (h0 : complete_lattice (add_group (semiring (semiring congr_arg_kind)))) : complete_lattice.is_Sup_finite_compact (add_group (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_90026 (h0 : functor.add_const (monoid (has_pos_part linarith.comp)) Type) : @monoid.fg.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 1} (monoid.{0} (has_pos_part.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_90027 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_90028 (h0 : function.extfun Type ring) : @rank_condition.{0} (left_cancel_monoid.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type ring.{0} h0 (left_cancel_monoid.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_90029 (h0 : add_group (comm_group (has_add (boolean_algebra.core pos)))) : is_add_cyclic (comm_group (has_add (boolean_algebra.core pos))) := sorry --non-trivial
lemma new_lemma_90030 (h0 : group (option (option name))) : group.fg (option (option name)) := sorry --non-trivial
lemma new_lemma_90031 (h0 : fin has_zero.zero) : @separated_space.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (has_bot.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_90032 (h0 : filter (finset (semigroup environment.implicit_infer_kind))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_90033 (h0 : ring (sub_neg_monoid (finset (finset (finset pos))))) : is_domain (sub_neg_monoid (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_90034 (h0 : has_neg (has_compl linarith.ineq)) (h1 : option (measurable_space (has_compl linarith.ineq))) (h2 : measurable_space (has_compl linarith.ineq)) : has_measurable_neg (has_compl linarith.ineq) := sorry --non-trivial
lemma new_lemma_90035 (h0 : ring (add_cancel_monoid (comm_monoid (comm_monoid empty)))) : strong_rank_condition (add_cancel_monoid (comm_monoid (comm_monoid empty))) := sorry --non-trivial
lemma new_lemma_90036 (h0 : fin has_zero.zero) : @normal_space.{0} (generalized_boolean_algebra.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (generalized_boolean_algebra.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_90037 (h0 : topological_space (cancel_monoid Type)) : path_connected_space (cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_90038 (h0 : semiring (normed_comm_ring (finset environment.implicit_infer_kind))) : is_noetherian_ring (normed_comm_ring (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_90039 (h0 : functor.comp topological_space has_add environment.implicit_infer_kind) : @locally_compact_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_90040 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_90041 (h0 : topological_space (measurable_space (has_norm empty))) : irreducible_space (measurable_space (has_norm empty)) := sorry --non-trivial
lemma new_lemma_90042 (h0 : add_monoid (plift (left_cancel_semigroup congr_arg_kind))) : add_monoid.fg (plift (left_cancel_semigroup congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_90043 (h0 : not (topological_space (left_cancel_semigroup unsigned) -> false)) : @topological_space.separable_space.{0} (left_cancel_semigroup.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_semigroup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_90044 (h0 : cancel_comm_monoid_with_zero (ordered_comm_ring name)) : unique_factorization_monoid (ordered_comm_ring name) := sorry --non-trivial
lemma new_lemma_90045 (h0 : monoid (preorder (add_left_cancel_semigroup empty))) : monoid.fg (preorder (add_left_cancel_semigroup empty)) := sorry --non-trivial
lemma new_lemma_90046 (h0 : functor.add_const (topological_space (free_add_monoid num)) num) : @preirreducible_space.{0} (free_add_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_90047 (h0 : functor.add_const (add_monoid (non_assoc_semiring empty)) empty) : @add_monoid.fg.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (non_assoc_semiring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_90048 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_90049 (h0 : topological_space (comm_group (has_nndist (finset environment.implicit_infer_kind)))) : discrete_topology (comm_group (has_nndist (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_90050 (h0 : group (canonically_ordered_comm_semiring Type)) : normalizer_condition (canonically_ordered_comm_semiring Type) := sorry --non-trivial
lemma new_lemma_90051 (h0 : function.extfun Type topological_space) : @t0_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_90052 (h0 : functor.add_const (ring (finset Type)) (ring (ring Type))) : @is_domain.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (finset.{1} Type)) (ring.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_90053 (h0 : list (canonically_ordered_comm_semiring (finset (finset (finset ennreal))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_90054 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_90055 (h2 : not (group (has_top congr_arg_kind) -> false)) : @normalizer_condition.{0} (has_top.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (has_top.{0} congr_arg_kind)) h2)  := sorry --non-trivial
lemma new_lemma_90056 (h0 : topological_space (finset (option ennreal))) : discrete_topology (finset (option ennreal)) := sorry --non-trivial
lemma new_lemma_90057 (h0 : topological_space (add_cancel_monoid (boolean_algebra environment.implicit_infer_kind))) : path_connected_space (add_cancel_monoid (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_90058 (h0 : ring (semi_normed_comm_ring (mul_one_class linarith.ineq))) : is_domain (semi_normed_comm_ring (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_90059 (h0 : monoid (has_emptyc (with_bot string_imp))) : monoid.fg (has_emptyc (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_90060 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @totally_separated_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_90061 (h0 : topological_space (has_zero (finset (finset (finset (has_add linarith.comp)))))) : normal_space (has_zero (finset (finset (finset (has_add linarith.comp))))) := sorry --non-trivial
lemma new_lemma_90062 (h0 : topological_space (has_to_string (finset (has_add pos)))) : sequential_space (has_to_string (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_90063 (h0 : topological_space (add_cancel_monoid (has_Inf linarith.comp))) : t0_space (add_cancel_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_90064 (h0 : functor.add_const (monoid (comm_group linarith.comp)) name) : @monoid.fg.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (comm_group.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_90065 (h0 : function.extfun Type (functor.add_const (topological_space (boolean_algebra linarith.comp)))) : @totally_disconnected_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_90066 (h0 : topological_space (boolean_algebra.core (finset name))) : t1_space (boolean_algebra.core (finset name)) := sorry --non-trivial
lemma new_lemma_90067 (h0 : functor.add_const (topological_space (mul_zero_class num)) empty) : @discrete_topology.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_90068 (h0 : not (complete_lattice (quiver.empty to_additive.value_type) -> false)) : @is_compactly_generated.{0} (quiver.empty.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (quiver.empty.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_90069 (h0 : topological_space (ring (finset environment.implicit_infer_kind))) : preirreducible_space (ring (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_90070 (h0 : complete_lattice (linear_ordered_semiring (has_top to_additive.value_type))) : is_atomistic (linear_ordered_semiring (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_90071 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (boolean_algebra.core.{0} (add_comm_monoid.{0} name)) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (boolean_algebra.core.{0} (add_comm_monoid.{0} name)))  := sorry --non-trivial
lemma new_lemma_90072 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_90073 (h0 : ring num) : is_principal_ideal_ring num := sorry --non-trivial
lemma new_lemma_90074 (h1 : has_le (add_comm_semigroup environment.projection_info)) (h2 : add_comm_semigroup environment.projection_info) : is_max h2 := sorry --non-trivial
lemma new_lemma_90075 (h0 : functor.comp topological_space mul_zero_class pos) : @topological_space.separable_space.{0} (mul_zero_class.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_90076 (h0 : functor.add_const (topological_space (semigroup name)) unsigned) : @sequential_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_90077 (h0 : group (canonically_ordered_monoid (has_Inf real))) : group.fg (canonically_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_90078 (h0 : functor.add_const Prop (ordered_cancel_add_comm_monoid pos)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_90079 (h0 : group (normed_group (has_top linarith.ineq))) : normalizer_condition (normed_group (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_90080 (h0 : topological_space (boolean_algebra.core Type)) : t0_space (boolean_algebra.core Type) := sorry --non-trivial
lemma new_lemma_90081 (h0 : monoid (measurable_space (random_gen (random_gen (has_inv to_additive.value_type))))) : monoid.fg (measurable_space (random_gen (random_gen (has_inv to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_90082 (h0 : fin has_zero.zero) : @is_atomistic.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (complete_distrib_lattice.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_90083 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) linarith.comp) : @loc_path_connected_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_90084 (h0 : cancel_comm_monoid_with_zero (finset (has_neg linarith.comp))) : unique_factorization_monoid (finset (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_90085 (h0 : ring (has_neg (comm_group unsigned))) : is_domain (has_neg (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_90086 (h0 : ring (semiring linarith.comp)) : strong_rank_condition (semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_90087 (h0 : functor.add_const (uniform_space (has_neg_part name)) environment.implicit_infer_kind) : @complete_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_neg_part.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_90088 (h0 : functor.add_const (ring (has_nndist unsigned)) Type) : @strong_rank_condition.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 1} (ring.{0} (has_nndist.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_90089 (h0 : functor.add_const (add_monoid (semigroup pos)) linarith.comp) : @add_monoid.fg.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (semigroup.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_90090 (h0 : add_group (id (semiring unsigned))) : is_add_cyclic (id (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_90091 (h0 : topological_space (has_inner empty num)) : topological_space.separable_space (has_inner empty num) := sorry --non-trivial
lemma new_lemma_90092 (h0 : uniform_space (denumerable (has_inv (random_gen (random_gen linarith.ineq))))) : complete_space (denumerable (has_inv (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_90093 (h0 : topological_space (has_emptyc (has_top to_additive.value_type))) : locally_compact_space (has_emptyc (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_90094 (h0 : add_group (sub_neg_monoid (has_add linarith.comp))) : is_add_cyclic (sub_neg_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_90095 (h0 : topological_space (has_union (add_group unsigned))) : irreducible_space (has_union (add_group unsigned)) := sorry --non-trivial
lemma new_lemma_90096 (h0 : functor.add_const (group (boolean_algebra pos)) (has_add pos)) : @normalizer_condition.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} pos)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_90097 (h0 : uniform_space (random_gen (has_inv (has_norm linarith.comp_source)))) : complete_space (random_gen (has_inv (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_90098 (h0 : topological_space ereal) (h1 : set ereal) : is_clopen h1 := sorry --non-trivial
lemma new_lemma_90099 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_90100 (h0 : add_monoid (boolean_algebra (has_bot name))) : add_monoid.fg (boolean_algebra (has_bot name)) := sorry --non-trivial
lemma new_lemma_90101 (h0 : ordered_comm_monoid (pseudo_metric_space unsigned)) : has_exists_mul_of_le (pseudo_metric_space unsigned) := sorry --non-trivial
lemma new_lemma_90102 (h0 : filter (boolean_algebra (finset (finset linarith.comp)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_90103 (h0 : topological_space (id (has_top linarith.ineq))) : locally_compact_space (id (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_90104 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) Type) : @t0_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_90105 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_90106 (h0 : ring (complete_linear_order (semiring (semiring (semiring (semiring unsigned)))))) : is_principal_ideal_ring (complete_linear_order (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_90107 (h0 : topological_space (cancel_monoid (mul_zero_class Type))) : irreducible_space (cancel_monoid (mul_zero_class Type)) := sorry --non-trivial
lemma new_lemma_90108 (h0 : uniform_space (normed_comm_ring (has_add Type))) : complete_space (normed_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_90109 (h0 : topological_space (generalized_boolean_algebra (has_Inf (ordered_comm_monoid name)))) : preirreducible_space (generalized_boolean_algebra (has_Inf (ordered_comm_monoid name))) := sorry --non-trivial
lemma new_lemma_90110 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_90111 (h0 : topological_space (has_norm (with_bot to_additive.value_type))) : locally_compact_space (has_norm (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_90112 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_noetherian_ring.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (semiring.{1} (generalized_boolean_algebra.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_90113 (h1 : group (add_monoid (random_gen char))) : is_cyclic (add_monoid (random_gen char)) := sorry --non-trivial
lemma new_lemma_90114 (h1 : has_sdiff (topological_space fun_info)) (h2 : not (has_sdiff (topological_space fun_info) -> false)) : is_distinct (has_sdiff (topological_space fun_info)) h1 (classical.by_contradiction' h2) := sorry --non-trivial
lemma new_lemma_90115 (h0 : ordered_add_comm_monoid (ordered_comm_group (option (option empty)))) : archimedean (ordered_comm_group (option (option empty))) := sorry --non-trivial
lemma new_lemma_90116 (h0 : semiring (has_zero (has_add pos))) : is_noetherian_ring (has_zero (has_add pos)) := sorry --non-trivial
lemma new_lemma_90117 (h0 : group (semigroup (finset (has_pos_part linarith.comp)))) : group.fg (semigroup (finset (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_90118 (h1 : not (complete_lattice (with_one num) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_one.{0} num)) h1)  := sorry --non-trivial
lemma new_lemma_90119 (h0 : function.extfun (finset ((Type -> Type) -> Type 1)) (has_mem.mem (function.extfun Type))) : @complete_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@function.extfun_app.{3 0} (finset.{2} ((Type → Type) → Type 1)) (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (finset.{2} ((Type → Type) → Type 1)) (@finset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type)) h0 (@has_emptyc.emptyc.{2} (finset.{2} ((Type → Type) → Type 1)) (@finset.has_emptyc.{2} ((Type → Type) → Type 1))))) uniform_space.{0}) (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_90120 (h0 : function.extfun Type (functor.add_const (topological_space pos))) : @irreducible_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} pos)) h0 pos))  := sorry --non-trivial
lemma new_lemma_90121 (h0 : ring (add_comm_monoid (option (option (option ennreal))))) : strong_rank_condition (add_comm_monoid (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_90122 (h0 : ring (denumerable (comm_ring (comm_ring reducibility_hints)))) : rank_condition (denumerable (comm_ring (comm_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_90123 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_90124 (h1 : not (group (add_cancel_comm_monoid reducibility_hints) -> false)) : @is_cyclic.{0} (add_cancel_comm_monoid.{0} reducibility_hints) (@classical.by_contradiction'.{1} (group.{0} (add_cancel_comm_monoid.{0} reducibility_hints)) h1)  := sorry --non-trivial
lemma new_lemma_90125 (h0 : function.extfun Type ring) : @is_domain.{0} (has_bot.{0} (has_Inf.{0} linarith.comp)) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_bot.{0} (has_Inf.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_90126 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring environment.implicit_infer_kind)) Type) : @sequential_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_90127 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_90128 (h0 : topological_space (left_cancel_semigroup (option num))) : normal_space (left_cancel_semigroup (option num)) := sorry --non-trivial
lemma new_lemma_90129 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (pseudo_metric_space congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_90130 (h0 : group (has_one (semiring (semiring unsigned)))) : normalizer_condition (has_one (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_90131 (h0 : functor.add_const (complete_lattice (linear_order unsigned)) num) : @complete_lattice.is_Sup_finite_compact.{0} (linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_order.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_90132 (h0 : topological_space (has_pos_part (has_Inf real))) : discrete_topology (has_pos_part (has_Inf real)) := sorry --non-trivial
lemma new_lemma_90133 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (finset num)) := sorry --non-trivial
lemma new_lemma_90134 (h0 : ring (normed_field (has_nnnorm (comm_ring (has_nnnorm char))))) : is_domain (normed_field (has_nnnorm (comm_ring (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_90135 (h0 : functor.add_const (topological_space (has_nndist pos)) linarith.comp) : @irreducible_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_90136 (h0 : complete_lattice (has_norm linarith.ineq)) : is_atomistic (has_norm linarith.ineq) := sorry --non-trivial
lemma new_lemma_90137 (h0 : functor.add_const (function.extfun Type topological_space) (has_Inf linarith.comp)) : @topological_space.separable_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_Inf.{0} linarith.comp) h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_90138 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @monoid.fg.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) monoid.{0}) (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_90139 (h0 : add_monoid (add_monoid linarith.comp_source)) (h1 : filter (add_left_cancel_monoid (add_units (add_monoid linarith.comp_source)))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_90140 (h0 : ring (has_add (has_neg (has_Inf Type)))) : strong_rank_condition (has_add (has_neg (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_90141 (h0 : functor.add_const (complete_lattice (generalized_boolean_algebra name)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (generalized_boolean_algebra.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_90142 (h0 : topological_space (has_div (has_nnnorm (has_lt linarith.ineq)))) (h1 : preorder (has_div (has_nnnorm (has_lt linarith.ineq)))) : order_topology (has_div (has_nnnorm (has_lt linarith.ineq))) := sorry --non-trivial
lemma new_lemma_90143 (h1 : not (ring (measurable_space congr_arg_kind) -> false)) : @strong_rank_condition.{0} (measurable_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.{0} congr_arg_kind)) h1)  := sorry --non-trivial
lemma new_lemma_90144 (h0 : ring (boolean_algebra (boolean_algebra.core unsigned))) : is_domain (boolean_algebra (boolean_algebra.core unsigned)) := sorry --non-trivial
lemma new_lemma_90145 (h0 : topological_space (semiring (has_norm linarith.comp))) : irreducible_space (semiring (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_90146 (h1 : functor.add_const (complete_lattice (with_one string_imp)) fun_info) : @is_compactly_generated.{0} (with_one.{0} string_imp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (with_one.{0} string_imp)) fun_info h1)  := sorry --non-trivial
lemma new_lemma_90147 (h0 : topological_space (has_pos_part (has_Inf linarith.comp))) : regular_space (has_pos_part (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_90148 (h0 : ring (has_zero (comm_group Type))) : rank_condition (has_zero (comm_group Type)) := sorry --non-trivial
lemma new_lemma_90149 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : locally_compact_space empty := sorry --non-trivial
lemma new_lemma_90150 (h0 : function.extfun (Type 1) group) : @is_cyclic.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_90151 (h0 : not (topological_space (comm_ring to_additive.value_type) -> false)) : @locally_compact_space.{0} (comm_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (comm_ring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_90152 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (generalized_boolean_algebra.{0} real) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (generalized_boolean_algebra.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_90153 (h0 : topological_space (linear_ordered_comm_group_with_zero linarith.ineq)) : path_connected_space (linear_ordered_comm_group_with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_90154 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (ring.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_90155 (h0 : monoid (has_emptyc (has_inv linarith.comp_source))) : monoid.fg (has_emptyc (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_90156 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @is_cyclic.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_90157 (h0 : topological_space (has_top (random_gen linarith.comp))) : t0_space (has_top (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_90158 (h0 : ring (add_cancel_comm_monoid empty)) : invariant_basis_number (add_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_90159 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_90160 (h0 : add_group (comm_group (boolean_algebra (boolean_algebra environment.implicit_infer_kind)))) : is_add_cyclic (comm_group (boolean_algebra (boolean_algebra environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_90161 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_90162 (h0 : function.extfun Type (functor.add_const (ring (ordered_comm_ring linarith.comp)))) : @is_principal_ideal_ring.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} linarith.comp)) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (ordered_comm_ring.{0} linarith.comp))) h0 pos))  := sorry --non-trivial
lemma new_lemma_90163 (h0 : list (ring name)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_90164 (h0 : semiring (comm_group (has_to_string unsigned))) : is_noetherian_ring (comm_group (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_90165 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @is_domain.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (linear_ordered_add_comm_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_90166 (h0 : topological_space (add_cancel_monoid (ring Type))) : topological_space.separable_space (add_cancel_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_90167 (h0 : topological_space (add_comm_monoid (comm_group Type))) : discrete_topology (add_comm_monoid (comm_group Type)) := sorry --non-trivial
lemma new_lemma_90168 (h0 : not (monoid (normed_lattice_add_comm_group congr_arg_kind) -> false)) : @monoid.fg.{0} (normed_lattice_add_comm_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (monoid.{0} (normed_lattice_add_comm_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_90169 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_90170 (h0 : prod (bin_tree (normed_linear_ordered_group unsigned)) (bin_tree (normed_linear_ordered_group unsigned))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_90171 (h0 : filter (boolean_algebra (boolean_algebra.core linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_90172 (h0 : topological_space (has_norm (random_gen string_imp))) : t0_space (has_norm (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_90173 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @irreducible_space.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_90174 (h0 : not (has_mem.mem add_group has_emptyc.emptyc -> false)) : @is_add_cyclic.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_group.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_90175 (h0 : filter (boolean_algebra (normed_comm_ring environment.implicit_infer_kind))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_90176 (h0 : ring (ring (boolean_algebra (boolean_algebra (has_Inf Type))))) : is_domain (ring (boolean_algebra (boolean_algebra (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_90177 (h2 : topological_space (measurable_space num)) : t0_space (measurable_space num) := sorry --non-trivial
lemma new_lemma_90178 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (left_cancel_semigroup.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (left_cancel_semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_90179 (h0 : cancel_comm_monoid_with_zero (mul_zero_class (has_neg (semigroup unsigned)))) : unique_factorization_monoid (mul_zero_class (has_neg (semigroup unsigned))) := sorry --non-trivial
lemma new_lemma_90180 (h0 : ring (ordered_comm_ring (ring pos))) : is_domain (ordered_comm_ring (ring pos)) := sorry --non-trivial
lemma new_lemma_90181 (h0 : group (bin_tree congr_arg_kind)) : is_cyclic (bin_tree congr_arg_kind) := sorry --non-trivial
lemma new_lemma_90182 (h0 : functor.add_const (cancel_comm_monoid_with_zero (plift unsigned)) num) : @unique_factorization_monoid.{1} (plift.{1} unsigned) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (plift.{1} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_90183 (h0 : topological_space (linear_ordered_semiring fun_info)) : locally_compact_space (linear_ordered_semiring fun_info) := sorry --non-trivial
lemma new_lemma_90184 (h0 : function.extfun nat fin) : @monoid.fg.{0} (canonically_linear_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (monoid.{0} (canonically_linear_ordered_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_90185 (h0 : monoid (has_neg_part name)) : monoid.fg (has_neg_part name) := sorry --non-trivial
lemma new_lemma_90186 (h0 : topological_space (normed_comm_ring (has_to_string linarith.comp))) : t1_space (normed_comm_ring (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_90187 (h0 : group (has_pos_part (ring Type))) : is_cyclic (has_pos_part (ring Type)) := sorry --non-trivial
lemma new_lemma_90188 (h0 : ring (ring real)) : is_principal_ideal_ring (ring real) := sorry --non-trivial
lemma new_lemma_90189 (h0 : functor.add_const (ring (normed_comm_ring unsigned)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_90190 (h0 : function.extfun nat fin) : @preconnected_space.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_90191 (h0 : topological_space (has_pos_part pos)) : normal_space (has_pos_part pos) := sorry --non-trivial
lemma new_lemma_90192 (h0 : functor.comp topological_space add_comm_monoid Type) : @irreducible_space.{1} (add_comm_monoid.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} add_comm_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_90193 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_90194 (h0 : filter (semigroup name)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_90195 (h0 : finset (has_bot real)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_90196 (h0 : not (topological_space (complete_semilattice_Sup linarith.ineq) -> false)) : @locally_compact_space.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_90197 (h0 : has_mem.mem (has_top (random_gen linarith.comp_source)) has_emptyc.emptyc) : @path_connected_space.{0} (has_top.{0} (random_gen.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} (random_gen.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_90198 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_90199 (h0 : function.extfun (Type 1) add_group) : @is_add_cyclic.{1} (plift.{1} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} unsigned)))))))) (@function.extfun_app.{3 2} (Type 1) add_group.{1} h0 (plift.{1} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} unsigned)))))))))  := sorry --non-trivial
lemma new_lemma_90200 (h1 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_90201 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_90202 (h0 : topological_space (random_gen (has_norm congr_arg_kind))) : t0_space (random_gen (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_90203 (h2 : complete_lattice (linear_ordered_add_comm_group linarith.ineq)) : complete_lattice.is_Sup_finite_compact (linear_ordered_add_comm_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_90204 (h0 : add_comm_group (has_zero (option num))) (h1 : has_norm (has_zero (option num))) : normed_group.core (has_zero (option num)) := sorry --non-trivial
lemma new_lemma_90205 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_90206 (h0 : topological_space (boolean_algebra (has_pos_part linarith.comp))) : discrete_topology (boolean_algebra (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_90207 (h0 : topological_space (with_bot (semiring (semiring linarith.comp)))) : preirreducible_space (with_bot (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_90208 (h0 : complete_lattice (is_R_or_C unsigned)) : is_compactly_generated (is_R_or_C unsigned) := sorry --non-trivial
lemma new_lemma_90209 (h0 : add_group (linear_order empty)) : is_add_cyclic (linear_order empty) := sorry --non-trivial
lemma new_lemma_90210 (h0 : group (has_dist (option (option num)))) : is_cyclic (has_dist (option (option num))) := sorry --non-trivial
lemma new_lemma_90211 (h0 : filter (has_neg_part (has_nndist (has_nndist pos)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_90212 (h0 : not (function.extfun Type ring -> false)) : @is_principal_ideal_ring.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_90213 (h0 : functor.add_const (finset (complete_distrib_lattice pos)) (has_add Type)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_90214 (h0 : functor.add_const (function.extfun Type finset) Type) : finset.nonempty (function.extfun_app (functor.add_const.run h0) linarith.comp) := sorry --non-trivial
lemma new_lemma_90215 (h0 : topological_space (add_left_cancel_semigroup congr_arg_kind)) : preirreducible_space (add_left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_90216 (h1 : complete_lattice (denumerable reducibility_hints)) : complete_lattice.is_Sup_finite_compact (denumerable reducibility_hints) := sorry --non-trivial
lemma new_lemma_90217 (h0 : semiring (finset empty)) : is_noetherian_ring (finset empty) := sorry --non-trivial
lemma new_lemma_90218 (h0 : not (ring (measure_theory.measure_space empty) -> false)) : @rank_condition.{0} (measure_theory.measure_space.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (measure_theory.measure_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_90219 (h1 : ring (semiring empty)) : is_domain (semiring empty) := sorry --non-trivial
lemma new_lemma_90220 (h0 : uniform_space (has_sub congr_arg_kind)) : complete_space (has_sub congr_arg_kind) := sorry --non-trivial
lemma new_lemma_90221 (h0 : functor.add_const (finset (has_zero Type)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_90222 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_90223 (h0 : function.extfun Type (functor.add_const (topological_space pos))) : @t1_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} pos)) h0 pos))  := sorry --non-trivial
lemma new_lemma_90224 (h0 : topological_space (finset (has_add (has_add (has_add (has_add name)))))) : path_connected_space (finset (has_add (has_add (has_add (has_add name))))) := sorry --non-trivial
lemma new_lemma_90225 (h0 : ordered_comm_monoid (has_nndist (has_neg_part pos))) : has_exists_mul_of_le (has_nndist (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_90226 (h0 : monoid (id (has_inv (random_gen linarith.comp_source)))) : monoid.fg (id (has_inv (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_90227 (h0 : uniform_space (comm_semigroup (has_add (has_pos_part real)))) : complete_space (comm_semigroup (has_add (has_pos_part real))) := sorry --non-trivial
lemma new_lemma_90228 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_90229 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (@id.{2} Type to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_90230 (h0 : topological_space (add_comm_monoid (comm_group (comm_group pos)))) : totally_disconnected_space (add_comm_monoid (comm_group (comm_group pos))) := sorry --non-trivial
lemma new_lemma_90231 (h0 : topological_space (ring (semigroup Type))) : locally_compact_space (ring (semigroup Type)) := sorry --non-trivial
lemma new_lemma_90232 (h0 : functor.add_const (topological_space (generalized_boolean_algebra real)) (has_add linarith.comp)) : @locally_compact_space.{0} (generalized_boolean_algebra.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} real)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_90233 (h0 : topological_space (encodable (has_nnnorm to_additive.value_type))) : locally_compact_space (encodable (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_90234 (h0 : function.extfun Type (functor.add_const (list (has_edist unsigned)))) : palindrome (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_90235 (h0 : topological_space (mul_zero_class (has_add (has_add (has_add name))))) : totally_separated_space (mul_zero_class (has_add (has_add (has_add name)))) := sorry --non-trivial
lemma new_lemma_90236 (h0 : topological_space (boolean_algebra linarith.comp)) : irreducible_space (boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_90237 (h0 : cancel_comm_monoid_with_zero (has_zero unsigned)) : unique_factorization_monoid (has_zero unsigned) := sorry --non-trivial
lemma new_lemma_90238 (h0 : ordered_comm_monoid (add_comm_monoid unsigned)) : has_exists_mul_of_le (add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_90239 (h0 : uniform_space (linear_ordered_semiring (semiring (semiring (semiring (semiring empty)))))) : complete_space (linear_ordered_semiring (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_90240 (h0 : not (ring (normed_group congr_arg_kind) -> false)) : @is_domain.{0} (normed_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (normed_group.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_90241 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) num)  := sorry --non-trivial
lemma new_lemma_90242 (h0 : ring (add_monoid (has_ssubset linarith.comp_source))) : is_domain (add_monoid (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_90243 (h0 : list (finset (comm_group Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_90244 (h0 : functor.add_const (semiring (is_R_or_C empty)) (semiring (semiring empty))) : @is_noetherian_ring.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (is_R_or_C.{0} empty)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_90245 (h0 : group (has_edist congr_arg_kind)) : normalizer_condition (has_edist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_90246 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (complete_semilattice_Sup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_semilattice_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_90247 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_90248 (h0 : functor.add_const (ring (has_nndist environment.implicit_infer_kind)) pos) : @rank_condition.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_90249 (h0 : function.extfun Type ring) : @is_domain.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_90250 (h0 : filter (comm_ring (has_lt linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_90251 (h0 : functor.add_const (uniform_space (add_cancel_monoid linarith.comp)) pos) : @complete_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_90252 (h0 : functor.add_const (add_monoid (ordered_comm_ring linarith.comp)) (ring linarith.comp)) : @add_monoid.fg.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (ordered_comm_ring.{0} linarith.comp)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_90253 (h0 : topological_space (ring (has_add environment.implicit_infer_kind))) : totally_separated_space (ring (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_90254 (h0 : topological_space (comm_ring char)) : t0_space (comm_ring char) := sorry --non-trivial
lemma new_lemma_90255 (h0 : group (normed_field (semi_normed_comm_ring (topological_space linarith.ineq)))) : is_cyclic (normed_field (semi_normed_comm_ring (topological_space linarith.ineq))) := sorry --non-trivial
lemma new_lemma_90256 (h0 : group (has_top fun_info)) : normalizer_condition (has_top fun_info) := sorry --non-trivial
lemma new_lemma_90257 (h0 : topological_space (with_one (has_norm linarith.comp))) : t0_space (with_one (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_90258 (h0 : functor.add_const (topological_space (ring Type)) (has_neg (has_neg Type))) : @t1_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ring.{1} Type)) (has_neg.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_90259 (h0 : complete_lattice (normed_field (mul_one_class char))) : is_compactly_generated (normed_field (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_90260 (h0 : functor.add_const (ring (has_neg pos)) (boolean_algebra Type)) : @strong_rank_condition.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_neg.{0} pos)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_90261 (h0 : ring (has_emptyc (random_gen linarith.ineq))) : is_domain (has_emptyc (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_90262 (h0 : Prop) (h1 : list Prop) : id (list.ilast' (id h0) h1) := sorry --non-trivial
lemma new_lemma_90263 (h1 : not (topological_space (semiring num) -> false)) : @totally_disconnected_space.{0} (semiring.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} num)) h1)  := sorry --non-trivial
lemma new_lemma_90264 (h0 : functor.add_const (topological_space (linear_order empty)) empty) : @totally_disconnected_space.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_90265 (h0 : add_group (has_add congr_arg_kind)) : is_add_cyclic (has_add congr_arg_kind) := sorry --non-trivial
lemma new_lemma_90266 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @group.fg.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_90267 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_90268 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (canonically_ordered_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (canonically_ordered_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_90269 (h0 : ring (semiring (semiring linarith.comp_source))) : rank_condition (semiring (semiring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_90270 (h0 : topological_space (has_nndist (has_add pos))) : preirreducible_space (has_nndist (has_add pos)) := sorry --non-trivial
lemma new_lemma_90271 (h0 : prod (plift empty) (plift empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_90272 (h0 : topological_space (canonically_linear_ordered_monoid num)) : preconnected_space (canonically_linear_ordered_monoid num) := sorry --non-trivial
lemma new_lemma_90273 (h1 : group (has_nnnorm to_additive.value_type)) : is_cyclic (has_nnnorm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_90274 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) pos) : @totally_separated_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_90275 (h0 : not (add_group (id empty) -> false)) : @is_add_cyclic.{0} (@id.{2} Type empty) (@classical.by_contradiction'.{1} (add_group.{0} (@id.{2} Type empty)) h0)  := sorry --non-trivial
lemma new_lemma_90276 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_90277 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) (boolean_algebra (boolean_algebra Type))) : @t0_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} name)) (boolean_algebra.{1} (boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_90278 (h0 : list (semigroup (finset (has_add Type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_90279 (h0 : linarith.ineq -> linarith.ineq -> Prop) : is_directed linarith.ineq h0 := sorry --non-trivial
lemma new_lemma_90280 (h0 : functor.add_const (group (bin_tree num)) empty) : @is_cyclic.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (group.{0} (bin_tree.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_90281 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) unsigned) : @totally_disconnected_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_90282 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} h0 (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_90283 (h0 : topological_space (finset (finset name))) : t1_space (finset (finset name)) := sorry --non-trivial
lemma new_lemma_90284 (h1 : not (uniform_space (has_top congr_arg_kind) -> false)) : @complete_space.{0} (has_top.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_top.{0} congr_arg_kind)) h1)  := sorry --non-trivial
lemma new_lemma_90285 (h0 : filter (add_left_cancel_monoid (has_append (denumerable linarith.comp_source)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_90286 (h0 : functor.add_const (function.extfun Type group) pos) : @normalizer_condition.{0} pos (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) pos)  := sorry --non-trivial
lemma new_lemma_90287 (h0 : not (uniform_space (add_left_cancel_monoid linarith.comp_source) -> false)) : @complete_space.{0} (add_left_cancel_monoid.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (uniform_space.{0} (add_left_cancel_monoid.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_90288 (h0 : functor.add_const (ordered_comm_monoid (generalized_boolean_algebra linarith.comp)) (finset linarith.comp)) : @has_exists_mul_of_le.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (generalized_boolean_algebra.{0} linarith.comp)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_90289 (h0 : functor.add_const (topological_space (free_add_monoid unsigned)) num) : @irreducible_space.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_90290 (h0 : monoid (sub_neg_monoid (finset linarith.comp))) : monoid.fg (sub_neg_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_90291 (h0 : ordered_comm_monoid (has_to_string (comm_group linarith.comp))) : has_exists_mul_of_le (has_to_string (comm_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_90292 (h0 : uniform_space (comm_group (has_neg_part (comm_group ennreal)))) : complete_space (comm_group (has_neg_part (comm_group ennreal))) := sorry --non-trivial
lemma new_lemma_90293 (h0 : uniform_space (normed_group (semiring empty))) : separated_space (normed_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_90294 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @sequential_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_90295 (h0 : complete_lattice (add_comm_monoid (add_comm_monoid environment.implicit_infer_kind))) : is_compactly_generated (add_comm_monoid (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_90296 (h0 : topological_space (comm_monoid (semiring empty))) : loc_path_connected_space (comm_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_90297 (h0 : functor.add_const (group (canonically_ordered_comm_semiring linarith.comp)) Type) : @is_cyclic.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_90298 (h0 : topological_space (has_zero (ring (ring Type)))) : normal_space (has_zero (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_90299 (h0 : functor.add_const (ring (normed_comm_ring unsigned)) pos) : @is_domain.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_90300 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_emptyc.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_emptyc.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_90301 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_90302 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_90303 (h0 : not (semiring (has_top unsigned) -> false)) : @is_noetherian_ring.{0} (has_top.{0} unsigned) (@classical.by_contradiction'.{1} (semiring.{0} (has_top.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_90304 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_90305 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) name) : @regular_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_90306 (h0 : functor.add_const (topological_space (comm_group Type)) linarith.comp) : @locally_compact_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_90307 (h0 : topological_space (comm_ring (has_nnnorm (has_nnnorm (has_nnnorm (random_gen reducibility_hints)))))) : t0_space (comm_ring (has_nnnorm (has_nnnorm (has_nnnorm (random_gen reducibility_hints))))) := sorry --non-trivial
lemma new_lemma_90308 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @irreducible_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_90309 (h0 : topological_space (plift (semiring (semiring empty)))) : totally_separated_space (plift (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_90310 (h0 : function.extfun nat fin) : @loc_path_connected_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_90311 (h0 : measurable_space (dlist fun_info)) (h1 : not (has_sub (dlist fun_info) -> false)) : @has_measurable_sub.{0} (dlist.{0} fun_info) h0 (@classical.by_contradiction'.{1} (has_sub.{0} (dlist.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_90312 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf Type))) : totally_separated_space (normed_lattice_add_comm_group (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_90313 (h0 : has_mem.mem (has_one (random_gen (has_top linarith.comp))) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (has_one.{0} (random_gen.{0} (has_top.{0} linarith.comp))) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_one.{0} (random_gen.{0} (has_top.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_90314 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_90315 (h0 : cancel_comm_monoid_with_zero (has_add (option (option (option ennreal))))) : unique_factorization_monoid (has_add (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_90316 (h0 : topological_space (ordered_cancel_add_comm_monoid pos)) : preconnected_space (ordered_cancel_add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_90317 (h0 : functor.add_const (group (complete_distrib_lattice Type)) pos) : @group.fg.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (complete_distrib_lattice.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_90318 (h0 : topological_space (option (semiring num))) : normal_space (option (semiring num)) := sorry --non-trivial
lemma new_lemma_90319 (h0 : add_group (has_inv (denumerable linarith.ineq))) : is_add_cyclic (has_inv (denumerable linarith.ineq)) := sorry --non-trivial
lemma new_lemma_90320 (h0 : functor.add_const (ring (has_to_string pos)) Type) : @is_principal_ideal_ring.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_to_string.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_90321 (h0 : ring (encodable (random_gen (has_ssubset fun_info)))) : is_domain (encodable (random_gen (has_ssubset fun_info))) := sorry --non-trivial
lemma new_lemma_90322 (h0 : topological_space (has_bot (has_add (has_Inf (has_add pos))))) : path_connected_space (has_bot (has_add (has_Inf (has_add pos)))) := sorry --non-trivial
lemma new_lemma_90323 (h1 : topological_space (normed_group (random_gen linarith.comp))) : t0_space (normed_group (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_90324 (h0 : not (Prop -> false)) : not (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_90325 (h0 : list (has_nndist (has_nndist (has_nndist (has_to_string num))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_90326 (h1 : topological_space (topological_space (has_nnnorm to_additive.value_type))) : totally_disconnected_space (topological_space (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_90327 (h0 : functor.add_const (topological_space (finset linarith.comp)) (has_Inf (has_Inf (finset pos)))) : @discrete_topology.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) (has_Inf.{0} (has_Inf.{0} (finset.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_90328 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) name) : @regular_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_90329 (h0 : topological_space (complete_distrib_lattice (finset ennreal))) : totally_disconnected_space (complete_distrib_lattice (finset ennreal)) := sorry --non-trivial
lemma new_lemma_90330 (h0 : topological_space (complete_distrib_lattice (cancel_monoid (boolean_algebra.core pos)))) : locally_compact_space (complete_distrib_lattice (cancel_monoid (boolean_algebra.core pos))) := sorry --non-trivial
lemma new_lemma_90331 (h0 : functor.add_const (topological_space (partial_order empty)) (semiring (semiring empty))) : @totally_separated_space.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} empty)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_90332 (h0 : functor.add_const (list (normed_comm_ring Type)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_90333 (h0 : ordered_comm_monoid (ring (finset pos))) : has_exists_mul_of_le (ring (finset pos)) := sorry --non-trivial
lemma new_lemma_90334 (h0 : group (random_gen (has_top to_additive.value_type))) : group.fg (random_gen (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_90335 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_90336 (h1 : uniform_space to_additive.value_type) : complete_space to_additive.value_type := sorry --non-trivial
lemma new_lemma_90337 (h0 : function.extfun nat fin) : @sequential_space.{0} (generalized_boolean_algebra.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (generalized_boolean_algebra.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_90338 (h0 : not (complete_lattice (has_ssubset fun_info) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_ssubset.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_ssubset.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_90339 (h0 : functor.add_const (topological_space (has_zero Type)) name) : @topological_space.separable_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_90340 (h0 : function.extfun Type list) : list.head (function.extfun_app h0 Prop) := sorry --non-trivial
lemma new_lemma_90341 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_90342 (h0 : monoid (plift (semiring (semiring empty)))) : monoid.fg (plift (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_90343 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} pos (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) pos)  := sorry --non-trivial
lemma new_lemma_90344 (h0 : functor.add_const (function.extfun Type group) (ordered_comm_ring Type)) : @group.fg.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) (ordered_comm_ring.{1} Type) h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_90345 (h0 : functor.add_const (group (boolean_algebra.core unsigned)) linarith.comp) : @is_cyclic.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.core.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_90346 (h0 : topological_space (generalized_boolean_algebra (finset (finset linarith.comp)))) : t0_space (generalized_boolean_algebra (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_90347 (h0 : functor.add_const (list (semigroup empty)) num) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_90348 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_90349 (h0 : not (function.extfun (finset Type) (has_mem.mem (semiring fun_info)) -> false)) : @is_compactly_generated.{0} (semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} fun_info)) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} fun_info))) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_90350 (h0 : topological_space (boolean_algebra.core pos)) : t1_space (boolean_algebra.core pos) := sorry --non-trivial
lemma new_lemma_90351 (h0 : ring (complete_semilattice_Sup num)) : is_principal_ideal_ring (complete_semilattice_Sup num) := sorry --non-trivial
lemma new_lemma_90352 (h0 : ordered_add_comm_monoid (boolean_algebra.core (comm_group (has_neg name)))) : archimedean (boolean_algebra.core (comm_group (has_neg name))) := sorry --non-trivial
lemma new_lemma_90353 (h0 : not (topological_space Type -> false)) : @discrete_topology.{1} Type (@classical.by_contradiction'.{2} (topological_space.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_90354 (h0 : add_monoid (has_pos_part (boolean_algebra.core Type))) : add_monoid.fg (has_pos_part (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_90355 (h0 : function.extfun Type (functor.add_const (topological_space environment.implicit_infer_kind))) : @t0_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (topological_space.{0} environment.implicit_infer_kind) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} environment.implicit_infer_kind)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_90356 (h0 : topological_space (normed_comm_ring (has_neg linarith.comp))) : preconnected_space (normed_comm_ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_90357 (h1 : uniform_space (ordered_comm_ring (comm_ring (comm_ring char)))) : complete_space (ordered_comm_ring (comm_ring (comm_ring char))) := sorry --non-trivial
lemma new_lemma_90358 (h0 : complete_lattice (has_compl char)) : complete_lattice.is_Sup_finite_compact (has_compl char) := sorry --non-trivial
lemma new_lemma_90359 (h0 : functor.add_const (ordered_add_comm_monoid (normed_comm_ring environment.implicit_infer_kind)) linarith.comp) : @archimedean.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_90360 (h0 : uniform_space (has_le (mul_one_class char))) : complete_space (has_le (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_90361 (h0 : functor.add_const (group (ordered_ring congr_arg_kind)) congr_arg_kind) : @group.fg.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (ordered_ring.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_90362 (h0 : cancel_comm_monoid_with_zero (add_group (complete_linear_order (semiring num)))) : unique_factorization_monoid (add_group (complete_linear_order (semiring num))) := sorry --non-trivial
lemma new_lemma_90363 (h1 : group (encodable to_additive.value_type)) : is_cyclic (encodable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_90364 (h0 : functor.add_const (function.extfun (Type 1) monoid) (finset pos)) : @monoid.fg.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) monoid.{1}) (finset.{0} pos) h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_90365 (h0 : group (plift num)) : normalizer_condition (plift num) := sorry --non-trivial
lemma new_lemma_90366 (h0 : group (semigroup (finset (finset (finset (finset ennreal)))))) : group.fg (semigroup (finset (finset (finset (finset ennreal))))) := sorry --non-trivial
lemma new_lemma_90367 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} h0 (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_90368 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (finset.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} num))  := sorry --non-trivial
lemma new_lemma_90369 (h0 : functor.add_const (function.extfun Type add_group) Type) : @is_add_cyclic.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_group.{0}) Type h0) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_90370 (h0 : add_group (with_bot (has_norm (has_norm unsigned)))) : is_add_cyclic (with_bot (has_norm (has_norm unsigned))) := sorry --non-trivial
lemma new_lemma_90371 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_90372 (h0 : topological_space (canonically_ordered_monoid (has_add (has_Inf Type)))) : t0_space (canonically_ordered_monoid (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_90373 (h0 : complete_lattice (random_gen (random_gen (random_gen linarith.ineq)))) : is_compactly_generated (random_gen (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_90374 (h0 : semiring (linear_ordered_field pos)) : is_noetherian_ring (linear_ordered_field pos) := sorry --non-trivial
lemma new_lemma_90375 (h0 : functor.add_const (function.extfun Type add_monoid) pos) : @add_monoid.fg.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) pos h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_90376 (h0 : add_group auto.case_option) : is_add_cyclic auto.case_option := sorry --non-trivial
lemma new_lemma_90377 (h0 : semiring (add_comm_semigroup fun_info)) (h1 : has_mem.mem h0 has_zero.zero) : @ideal.is_prime.{0} (add_comm_semigroup.{0} fun_info) h0 (@multiset.pi.empty.{0 0} (semiring.{0} (add_comm_semigroup.{0} fun_info)) (@ideal.{0} (add_comm_semigroup.{0} fun_info)) h0 h1)  := sorry --non-trivial
lemma new_lemma_90378 (h0 : complete_lattice (random_gen (random_gen char))) : complete_lattice.is_Sup_finite_compact (random_gen (random_gen char)) := sorry --non-trivial
lemma new_lemma_90379 (h0 : add_group (has_zero (has_pos_part (has_pos_part linarith.comp)))) : is_add_cyclic (has_zero (has_pos_part (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_90380 (h0 : uniform_space (monoid ennreal)) : separated_space (monoid ennreal) := sorry --non-trivial
lemma new_lemma_90381 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_90382 (h0 : topological_space (complete_distrib_lattice (option (option pos)))) : normal_space (complete_distrib_lattice (option (option pos))) := sorry --non-trivial
lemma new_lemma_90383 (h0 : topological_space (has_bot empty) -> Prop) (h1 : Exists (fun (x : topological_space (has_bot empty)), h0 x)) : @path_connected_space.{0} (has_bot.{0} empty) (@classical.some.{1} (topological_space.{0} (has_bot.{0} empty)) h0 h1)  := sorry --non-trivial
lemma new_lemma_90384 (h0 : functor.add_const (ring (has_pos_part linarith.comp)) (has_add (has_add pos))) : @is_principal_ideal_ring.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_pos_part.{0} linarith.comp)) (has_add.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_90385 (h0 : functor.add_const (function.extfun Type complete_lattice) pos) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) pos h0) (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_90386 (h0 : topological_space (linear_ordered_semiring num)) : normal_space (linear_ordered_semiring num) := sorry --non-trivial
lemma new_lemma_90387 (h0 : group (has_add (mul_one_class Type))) : is_simple_group (has_add (mul_one_class Type)) := sorry --non-trivial
lemma new_lemma_90388 (h0 : topological_space (has_Inf (ring (ring (has_add (has_add (has_add pos))))))) : totally_disconnected_space (has_Inf (ring (ring (has_add (has_add (has_add pos)))))) := sorry --non-trivial
lemma new_lemma_90389 (h0 : group (normed_comm_ring (has_add (option (option (cancel_monoid pos)))))) : is_cyclic (normed_comm_ring (has_add (option (option (cancel_monoid pos))))) := sorry --non-trivial
lemma new_lemma_90390 (h0 : functor.add_const (topological_space (has_neg_part pos)) pos) : @discrete_topology.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_90391 (h1 : pos_num) (h2 : tree Prop) (h3 : Prop) : tree.get_or_else h1 h2 h3 := sorry --non-trivial
lemma new_lemma_90392 (h0 : not (ring (has_top linarith.comp) -> false)) : @rank_condition.{0} (has_top.{0} linarith.comp) (@classical.by_contradiction'.{1} (ring.{0} (has_top.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_90393 (h0 : topological_space (complete_distrib_lattice (has_add pos))) : preirreducible_space (complete_distrib_lattice (has_add pos)) := sorry --non-trivial
lemma new_lemma_90394 (h0 : topological_space (option ennreal)) : t1_space (option ennreal) := sorry --non-trivial
lemma new_lemma_90395 (h0 : group (with_bot (has_norm num))) : is_cyclic (with_bot (has_norm num)) := sorry --non-trivial
lemma new_lemma_90396 (h0 : ring (has_inner (option (option empty)) congr_arg_kind)) : strong_rank_condition (has_inner (option (option empty)) congr_arg_kind) := sorry --non-trivial
lemma new_lemma_90397 (h0 : topological_space (canonically_ordered_comm_semiring ennreal)) : topological_space.separable_space (canonically_ordered_comm_semiring ennreal) := sorry --non-trivial
lemma new_lemma_90398 (h0 : function.extfun Type topological_space) : @t0_space.{0} (free_add_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (free_add_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_90399 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_90400 (h0 : functor.add_const (finset (left_cancel_semigroup congr_arg_kind)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_90401 (h0 : complete_lattice (non_unital_non_assoc_semiring (mul_one_class linarith.ineq))) : is_compactly_generated (non_unital_non_assoc_semiring (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_90402 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_90403 (h0 : group (add_cancel_monoid (has_add (has_add (has_add (has_add (has_add (has_add Type)))))))) : group.fg (add_cancel_monoid (has_add (has_add (has_add (has_add (has_add (has_add Type))))))) := sorry --non-trivial
lemma new_lemma_90404 (h0 : filter (has_ssubset (has_ssubset linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_90405 (h0 : topological_space (has_neg_part ennreal)) : loc_path_connected_space (has_neg_part ennreal) := sorry --non-trivial
lemma new_lemma_90406 (h0 : topological_space (has_to_string (cancel_monoid Type))) : t1_space (has_to_string (cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_90407 (h0 : topological_space (ordered_comm_ring (finset name))) : t0_space (ordered_comm_ring (finset name)) := sorry --non-trivial
lemma new_lemma_90408 (h0 : functor.add_const (list (add_cancel_monoid pos)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_90409 (h0 : semiring num) : is_noetherian_ring num := sorry --non-trivial
lemma new_lemma_90410 (h0 : uniform_space (complete_semilattice_Sup (random_gen linarith.comp_source))) : separated_space (complete_semilattice_Sup (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_90411 (h0 : functor.add_const (function.extfun (Type 1) group) (has_Inf Type)) : @is_cyclic.{1} Type (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) (has_Inf.{1} Type) h0) Type)  := sorry --non-trivial
lemma new_lemma_90412 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (with_zero.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_zero.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_90413 (h0 : functor.add_const (topological_space (cancel_monoid name)) linarith.comp) : @irreducible_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_90414 (h0 : complete_lattice (has_subset unsigned)) : complete_lattice.is_Sup_finite_compact (has_subset unsigned) := sorry --non-trivial
lemma new_lemma_90415 (h1 : to_additive.value_type -> ring (topological_space to_additive.value_type)) (h2 : not (ordinal -> false)) (h3 : has_lt.lt (classical.by_contradiction' h2) (ordinal.type well_ordering_rel)) : @rank_condition.{0} (topological_space.{0} to_additive.value_type) (@ordinal.bfamily_of_family.{0 0} (ring.{0} (topological_space.{0} to_additive.value_type)) to_additive.value_type h1 (@classical.by_contradiction'.{2} ordinal.{0} h2) h3)  := sorry --non-trivial
lemma new_lemma_90416 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} pos (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) pos)  := sorry --non-trivial
lemma new_lemma_90417 (h0 : functor.add_const (list (normed_comm_ring name)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_90418 (h0 : functor.add_const (function.extfun Type monoid) linarith.comp) : @monoid.fg.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) linarith.comp h0) (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_90419 (h1 : complete_lattice (denumerable linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (denumerable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_90420 (h0 : topological_space (boolean_algebra (ring linarith.comp))) : regular_space (boolean_algebra (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_90421 (h0 : topological_space (monoid (option (option (option empty))))) : topological_space.separable_space (monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_90422 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_90423 (h1 : topological_space (has_nnnorm string_imp)) (h2 : add_group (has_nnnorm string_imp)) : topological_add_group (has_nnnorm string_imp) := sorry --non-trivial
lemma new_lemma_90424 (h0 : topological_space (semigroup (finset (finset name)))) : irreducible_space (semigroup (finset (finset name))) := sorry --non-trivial
lemma new_lemma_90425 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group empty))) : @group.fg.{0} (normed_group.{0} empty) (@finset.pi.empty.{1 0} Type group.{0} (normed_group.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_90426 (h0 : functor.add_const (add_group (ring linarith.comp)) (has_add pos)) : @is_add_cyclic.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (ring.{0} linarith.comp)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_90427 (h0 : filter (ring (option (option (option (option (option (option (option (option (option empty))))))))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_90428 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (distrib_lattice.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (distrib_lattice.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_90429 (h0 : function.extfun Type topological_space) : @t0_space.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_90430 (h0 : functor.add_const (group (has_bot linarith.comp)) name) : @group.fg.{0} (has_bot.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_bot.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_90431 (h0 : list (has_neg linarith.comp)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_90432 (h0 : function.extfun Type ring) : @is_domain.{0} (comm_ring.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_ring.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_90433 (h0 : list (has_bot real)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_90434 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_90435 (h0 : ring (boolean_algebra.core (option num))) : strong_rank_condition (boolean_algebra.core (option num)) := sorry --non-trivial
lemma new_lemma_90436 (h0 : has_mem.mem add_group has_emptyc.emptyc) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} h0) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_90437 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_90438 (h0 : functor.add_const (topological_space name) congr_arg_kind) : @normal_space.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_90439 (h2 : group (has_add to_additive.value_type)) : is_cyclic (has_add to_additive.value_type) := sorry --non-trivial
lemma new_lemma_90440 (h0 : group (comm_ring (random_gen char))) : group.fg (comm_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_90441 (h0 : not (functor.add_const Prop (has_sub congr_arg_kind) -> false)) : functor.add_const.run (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_90442 (h0 : topological_space (semi_normed_comm_ring std_gen)) : t0_space (semi_normed_comm_ring std_gen) := sorry --non-trivial
lemma new_lemma_90443 (h0 : function.extfun (Type 1) topological_space) : @preirreducible_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_90444 (h0 : complete_lattice (with_bot (has_top (has_top linarith.ineq)))) : is_compactly_generated (with_bot (has_top (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_90445 (h0 : topological_space (has_star unsigned)) : sequential_space (has_star unsigned) := sorry --non-trivial
lemma new_lemma_90446 (h2 : add_group (uniform_space to_additive.value_type)) : is_add_cyclic (uniform_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_90447 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring name)) (finset Type)) : @rank_condition.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (canonically_ordered_comm_semiring.{0} name)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_90448 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_90449 (h0 : has_mem.mem (has_sub fun_info) has_emptyc.emptyc) : @is_cyclic.{0} (has_sub.{0} fun_info) (@finset.pi.empty.{1 0} Type group.{0} (has_sub.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_90450 (h1 : not (topological_space (semiring linarith.comp_source) -> false)) : @t0_space.{0} (semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_90451 (h0 : group (has_pos_part (has_pos_part pos))) : group.fg (has_pos_part (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_90452 (h0 : functor.add_const (ring (ring linarith.comp)) (ring linarith.comp)) : @strong_rank_condition.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} linarith.comp)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_90453 (h0 : functor.add_const (topological_space (cancel_monoid name)) linarith.comp) : @preconnected_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_90454 (h0 : topological_space (add_group (semiring (semiring (semiring (semiring num)))))) : normal_space (add_group (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_90455 (h0 : fin has_zero.zero) : @ulower.up.{0} Prop encodable.Prop (@id.{1} (@ulower.{0} Prop encodable.Prop) (@matrix.vec_empty.{0} (@ulower.{0} Prop encodable.Prop) (@id.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@id.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))))  := sorry --non-trivial
lemma new_lemma_90456 (h0 : has_coe (nondiscrete_normed_field fun_info) Prop) (h1 : nondiscrete_normed_field fun_info) : @coe_b.{1 1} (nondiscrete_normed_field.{0} fun_info) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_90457 (h0 : topological_space string) : path_connected_space string := sorry --non-trivial
lemma new_lemma_90458 (h0 : filter (has_nndist (option (option unsigned)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_90459 (h0 : cancel_comm_monoid_with_zero (linear_ordered_comm_ring (semiring congr_arg_kind))) : unique_factorization_monoid (linear_ordered_comm_ring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_90460 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (is_R_or_C.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (is_R_or_C.{0} empty))  := sorry --non-trivial
lemma new_lemma_90461 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_90462 (h0 : ring (comm_group (option name))) : is_domain (comm_group (option name)) := sorry --non-trivial
lemma new_lemma_90463 (h1 : has_mem.mem (semiring linarith.comp) has_emptyc.emptyc) : @discrete_topology.{0} (semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} linarith.comp) h1)  := sorry --non-trivial
lemma new_lemma_90464 (h0 : functor.add_const (uniform_space ennreal) num) : @complete_space.{0} ennreal (@functor.add_const.run.{0 0} (uniform_space.{0} ennreal) num h0)  := sorry --non-trivial
lemma new_lemma_90465 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_90466 (h0 : topological_space (has_norm (semiring empty))) : totally_separated_space (has_norm (semiring empty)) := sorry --non-trivial
lemma new_lemma_90467 (h1 : ring (dlist linarith.ineq)) : strong_rank_condition (dlist linarith.ineq) := sorry --non-trivial
lemma new_lemma_90468 (h0 : functor.add_const (topological_space (has_dist unsigned)) num) : @normal_space.{0} (has_dist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_90469 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_add linarith.comp)) : @preirreducible_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_add.{0} linarith.comp) h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_90470 (h4 : topological_space enat) : path_connected_space enat := sorry --non-trivial
lemma new_lemma_90471 (h0 : group (measurable_space (has_norm linarith.comp))) : group.fg (measurable_space (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_90472 (h0 : function.extfun Type topological_space) : @t0_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_90473 (h1 : uniform_space (non_unital_non_assoc_semiring fun_info)) : complete_space (non_unital_non_assoc_semiring fun_info) := sorry --non-trivial
lemma new_lemma_90474 (h0 : topological_space (canonically_ordered_monoid (has_Inf (has_add real)))) : locally_compact_space (canonically_ordered_monoid (has_Inf (has_add real))) := sorry --non-trivial
lemma new_lemma_90475 (h0 : topological_space (sub_neg_monoid (has_pos_part pos))) : t0_space (sub_neg_monoid (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_90476 (h0 : ring (comm_semigroup linarith.comp)) : is_principal_ideal_ring (comm_semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_90477 (h0 : group (has_bot (has_Inf (has_Inf pos)))) : normalizer_condition (has_bot (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_90478 (h0 : uniform_space (linear_ordered_comm_group_with_zero ereal)) : complete_space (linear_ordered_comm_group_with_zero ereal) := sorry --non-trivial
lemma new_lemma_90479 (h0 : group (has_union unsigned)) : group.fg (has_union unsigned) := sorry --non-trivial
lemma new_lemma_90480 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_inv.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inv.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_90481 (h0 : not (topological_space (has_one linarith.comp) -> false)) : @path_connected_space.{0} (has_one.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_one.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_90482 (h0 : uniform_space (canonically_ordered_monoid (has_add real))) : complete_space (canonically_ordered_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_90483 (h1 : group (has_emptyc linarith.ineq)) : normalizer_condition (has_emptyc linarith.ineq) := sorry --non-trivial
lemma new_lemma_90484 (h0 : cancel_comm_monoid_with_zero (random_gen (mul_one_class reducibility_hints))) : unique_factorization_monoid (random_gen (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_90485 (h1 : ring (normed_group linarith.ineq)) : rank_condition (normed_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_90486 (h0 : semiring (add_cancel_monoid (comm_group (boolean_algebra Type)))) : is_noetherian_ring (add_cancel_monoid (comm_group (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_90487 (h0 : ring (has_append (comm_ring string_imp))) : rank_condition (has_append (comm_ring string_imp)) := sorry --non-trivial
lemma new_lemma_90488 (h0 : ordered_comm_monoid (has_zero (option (option ennreal)))) : has_exists_mul_of_le (has_zero (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_90489 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_90490 (h0 : topological_space (comm_group (option (ring ennreal)))) : locally_compact_space (comm_group (option (ring ennreal))) := sorry --non-trivial
lemma new_lemma_90491 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (linear_ordered_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_90492 (h0 : topological_space (left_cancel_monoid (semiring (semiring (semiring unsigned))))) : normal_space (left_cancel_monoid (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_90493 (h1 : prod (mul_one_class ereal) (mul_one_class ereal)) : set.diagonal (mul_one_class ereal) h1 := sorry --non-trivial
lemma new_lemma_90494 (h0 : char) (h1 : set (prod char char)) (h2 : char) : uniform_space.ball h0 h1 h2 := sorry --non-trivial
lemma new_lemma_90495 (h0 : filter (option (option unsigned))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_90496 (h0 : topological_space (cancel_monoid (has_add (has_neg_part name)))) : locally_compact_space (cancel_monoid (has_add (has_neg_part name))) := sorry --non-trivial
lemma new_lemma_90497 (h0 : group (random_gen (has_top (comm_ring linarith.comp_source)))) : group.fg (random_gen (has_top (comm_ring linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_90498 (h0 : topological_space (has_zero (ring (ring (finset (ring name)))))) : regular_space (has_zero (ring (ring (finset (ring name))))) := sorry --non-trivial
lemma new_lemma_90499 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @locally_compact_space.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_90500 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @path_connected_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_90501 (h0 : topological_space (has_norm (random_gen string_imp))) : path_connected_space (has_norm (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_90502 (h0 : measurable_space ereal) (h1 : filter ereal -> std_gen) (h2 : coe_sort (set.range h1) -> Prop) : filter.is_measurably_generated (set.range_splitting h1 (classical.epsilon h2)) := sorry --non-trivial
lemma new_lemma_90503 (h0 : topological_space (plift (metric_space unsigned))) : locally_compact_space (plift (metric_space unsigned)) := sorry --non-trivial
lemma new_lemma_90504 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_90505 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring linarith.comp)) (has_neg_part pos)) : @strong_rank_condition.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) (has_neg_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_90506 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (measurable_space.dynkin_system.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} empty))) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.add_const.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} empty)))) empty))  := sorry --non-trivial
lemma new_lemma_90507 (h0 : topological_space (add_cancel_monoid (option (option pos)))) : totally_separated_space (add_cancel_monoid (option (option pos))) := sorry --non-trivial
lemma new_lemma_90508 (h0 : functor.add_const (group (linear_ordered_comm_monoid_with_zero empty)) congr_arg_kind) : @group.fg.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_90509 (h0 : topological_space (add_cancel_monoid (finset environment.implicit_infer_kind))) : t0_space (add_cancel_monoid (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_90510 (h0 : complete_lattice (normed_group (has_inv (has_norm (has_inv name))))) : is_atomistic (normed_group (has_inv (has_norm (has_inv name)))) := sorry --non-trivial
lemma new_lemma_90511 (h1 : topological_space (metric_space num)) : totally_separated_space (metric_space num) := sorry --non-trivial
lemma new_lemma_90512 (h0 : filter (has_norm congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_90513 (h0 : set (has_lt std_gen)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_90514 (h0 : complete_lattice (non_assoc_semiring num)) : is_atomistic (non_assoc_semiring num) := sorry --non-trivial
lemma new_lemma_90515 (h0 : ring (has_zero (finset linarith.comp))) : is_principal_ideal_ring (has_zero (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_90516 (h0 : topological_space (has_Inf (has_Inf (has_Inf (has_Inf (has_add linarith.comp)))))) : path_connected_space (has_Inf (has_Inf (has_Inf (has_Inf (has_add linarith.comp))))) := sorry --non-trivial
lemma new_lemma_90517 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_90518 (h0 : set (simple_graph (has_compl linarith.ineq))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_90519 (h0 : topological_space (linear_ordered_cancel_comm_monoid (option congr_arg_kind))) : totally_disconnected_space (linear_ordered_cancel_comm_monoid (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_90520 (h0 : topological_space (has_add (ring (finset (semigroup Type))))) : loc_path_connected_space (has_add (ring (finset (semigroup Type)))) := sorry --non-trivial
lemma new_lemma_90521 (h0 : ring (simple_graph string.iterator)) : rank_condition (simple_graph string.iterator) := sorry --non-trivial
lemma new_lemma_90522 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_90523 (h0 : ordered_comm_monoid (has_neg_part (option (option (ring (option pos)))))) : has_exists_mul_of_le (has_neg_part (option (option (ring (option pos))))) := sorry --non-trivial
lemma new_lemma_90524 (h0 : ring (has_nndist (comm_group pos))) : is_principal_ideal_ring (has_nndist (comm_group pos)) := sorry --non-trivial
lemma new_lemma_90525 (h0 : finset (add_comm_monoid (comm_group (comm_group Type)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_90526 (h0 : ring (fintype (has_lt (has_nnnorm linarith.ineq)))) : is_domain (fintype (has_lt (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_90527 (h0 : ring (add_group unsigned)) : rank_condition (add_group unsigned) := sorry --non-trivial
lemma new_lemma_90528 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @normal_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_90529 (h0 : functor.add_const (function.extfun (Type 1) group) pos) : @is_simple_group.{1} (has_sdiff.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) pos h0) (has_sdiff.{1} Type))  := sorry --non-trivial
lemma new_lemma_90530 (h0 : topological_space real) : path_connected_space real := sorry --non-trivial
lemma new_lemma_90531 (h0 : add_group (simple_graph (has_add (has_add pos)))) : is_add_cyclic (simple_graph (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_90532 (h0 : topological_space (measurable_space (semiring empty))) : irreducible_space (measurable_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_90533 (h0 : topological_space (normed_comm_ring (ring unsigned))) : regular_space (normed_comm_ring (ring unsigned)) := sorry --non-trivial
lemma new_lemma_90534 (h0 : function.extfun (finset (Type 1)) (has_mem.mem Type)) : @is_compactly_generated.{1} Type (@finset.pi.empty.{2 1} (Type 1) complete_lattice.{1} Type (@function.extfun_app.{3 0} (finset.{2} (Type 1)) (@has_mem.mem.{2 2} (Type 1) (finset.{2} (Type 1)) (@finset.has_mem.{2} (Type 1)) Type) h0 (@has_emptyc.emptyc.{2} (finset.{2} (Type 1)) (@finset.has_emptyc.{2} (Type 1)))))  := sorry --non-trivial
lemma new_lemma_90535 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_90536 (h0 : list (boolean_algebra (finset linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_90537 (h0 : not (has_mem.mem (complete_semilattice_Sup (has_top linarith.ineq)) has_emptyc.emptyc -> false)) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} (has_top.{0} linarith.ineq)) (@finset.pi.empty.{1 0} Type group.{0} (complete_semilattice_Sup.{0} (has_top.{0} linarith.ineq)) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} (has_top.{0} linarith.ineq)) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_90538 (h0 : functor.add_const (filter (normed_comm_ring ennreal)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_90539 (h0 : ring (with_bot (random_gen (random_gen (random_gen to_additive.value_type))))) : rank_condition (with_bot (random_gen (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_90540 (h0 : topological_space (mul_one_class (add_comm_semigroup (add_comm_semigroup ereal)))) : t0_space (mul_one_class (add_comm_semigroup (add_comm_semigroup ereal))) := sorry --non-trivial
lemma new_lemma_90541 (h0 : ring (has_add (boolean_algebra name))) : rank_condition (has_add (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_90542 (h0 : functor.add_const (topological_space (finset linarith.comp)) linarith.comp) : @discrete_topology.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_90543 (h0 : complete_lattice (semi_normed_comm_ring string_imp)) : is_compactly_generated (semi_normed_comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_90544 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) empty) : @unique_factorization_monoid.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) empty h0) (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_90545 (h0 : functor.add_const (topological_space (ring pos)) (finset linarith.comp)) : @totally_disconnected_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_90546 (h0 : functor.add_const (ring (normed_lattice_add_comm_group linarith.comp)) name) : @is_principal_ideal_ring.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (normed_lattice_add_comm_group.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_90547 (h0 : topological_space (linear_ordered_field congr_arg_kind)) : t0_space (linear_ordered_field congr_arg_kind) := sorry --non-trivial
lemma new_lemma_90548 (h0 : topological_space (has_to_string (finset name))) : discrete_topology (has_to_string (finset name)) := sorry --non-trivial
lemma new_lemma_90549 (h0 : add_monoid (ordered_comm_ring (has_add name))) : add_monoid.fg (ordered_comm_ring (has_add name)) := sorry --non-trivial
lemma new_lemma_90550 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @has_exists_mul_of_le.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ordered_comm_monoid.{1}) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_90551 (h0 : ordered_add_comm_monoid (canonically_ordered_monoid (boolean_algebra Type))) : archimedean (canonically_ordered_monoid (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_90552 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (simple_graph.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} empty))  := sorry --non-trivial
lemma new_lemma_90553 (h0 : add_group ereal) : is_add_cyclic ereal := sorry --non-trivial
lemma new_lemma_90554 (h0 : functor.add_const (group (left_cancel_monoid empty)) num) : @group.fg.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (left_cancel_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_90555 (h0 : list (boolean_algebra (has_neg_part Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_90556 (h0 : functor.add_const (ordered_add_comm_monoid (has_Inf name)) Type) : @archimedean.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_Inf.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_90557 (h0 : functor.add_const (ring (complete_distrib_lattice linarith.comp)) (has_Inf (has_nndist (has_Inf name)))) : @rank_condition.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} linarith.comp)) (has_Inf.{0} (has_nndist.{0} (has_Inf.{0} name))) h0)  := sorry --non-trivial
lemma new_lemma_90558 (h0 : prod (has_to_string (has_Sup name)) (has_to_string (has_Sup name))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_90559 (h0 : cancel_comm_monoid_with_zero (has_pos_part (ring pos))) : unique_factorization_monoid (has_pos_part (ring pos)) := sorry --non-trivial
lemma new_lemma_90560 (h0 : function.extfun Type ring) : @is_domain.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_90561 (h0 : fin has_zero.zero) : @monoid.fg.{0} (boolean_algebra.{0} name) (@matrix.vec_empty.{0} (monoid.{0} (boolean_algebra.{0} name)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))))  := sorry --non-trivial
lemma new_lemma_90562 (h0 : group (finset (ring linarith.comp))) : group.fg (finset (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_90563 (h0 : monoid (generalized_boolean_algebra (has_add linarith.comp))) : monoid.fg (generalized_boolean_algebra (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_90564 (h0 : topological_space (encodable (has_nnnorm linarith.ineq))) : path_connected_space (encodable (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_90565 (h2 : topological_space (add_comm_semigroup std_gen)) : path_connected_space (add_comm_semigroup std_gen) := sorry --non-trivial
lemma new_lemma_90566 (h0 : has_top (mul_zero_class num) -> has_top (mul_zero_class num) -> has_top (mul_zero_class num)) : is_idempotent (has_top (mul_zero_class num)) h0 := sorry --non-trivial
lemma new_lemma_90567 (h0 : function.extfun Type group) : @normalizer_condition.{0} (distrib_lattice.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (distrib_lattice.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_90568 (h0 : functor.add_const (add_group (normed_comm_ring pos)) pos) : @is_add_cyclic.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (normed_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_90569 (h0 : functor.add_const (list (cancel_monoid Type)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_90570 (h0 : function.extfun Type (functor.comp topological_space boolean_algebra)) : @normal_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} boolean_algebra.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_90571 (h0 : uniform_space ereal) : nonempty (uniform_space.separation_quotient ereal) := sorry --simp
lemma new_lemma_90572 (h0 : functor.add_const (topological_space (add_comm_monoid unsigned)) Type) : @sequential_space.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_90573 (h0 : nat) (h1 : vector Prop (has_add.add h0 has_one.one)) (h2 : punit) : vector.last (category_theory.hom_of_element h1 h2) := sorry --non-trivial
lemma new_lemma_90574 (h1 : complete_lattice (has_emptyc (has_top congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (has_emptyc (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_90575 (h0 : functor.add_const (topological_space unsigned) (option empty)) : @loc_path_connected_space.{0} unsigned (@functor.add_const.run.{0 0} (topological_space.{0} unsigned) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_90576 (h0 : fin has_zero.zero) : @t1_space.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_90577 (h0 : not (add_group (has_nnnorm linarith.comp_source) -> false)) : @is_add_cyclic.{0} (has_nnnorm.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (add_group.{0} (has_nnnorm.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_90578 (h0 : prod (has_to_string ennreal) (has_to_string ennreal)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_90579 (h0 : monoid (with_bot (comm_ring (random_gen (random_gen (has_inv to_additive.value_type)))))) : monoid.fg (with_bot (comm_ring (random_gen (random_gen (has_inv to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_90580 (h0 : group (metric_space (semiring congr_arg_kind))) : group.fg (metric_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_90581 (h0 : topological_space (has_bot (sub_neg_monoid (ordered_comm_monoid pos)))) : irreducible_space (has_bot (sub_neg_monoid (ordered_comm_monoid pos))) := sorry --non-trivial
lemma new_lemma_90582 (h0 : topological_space (with_one (has_ssubset to_additive.value_type))) : path_connected_space (with_one (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_90583 (h0 : topological_space (has_union (has_norm unsigned))) : discrete_topology (has_union (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_90584 (h0 : topological_space (has_Inf (has_neg Type))) : sequential_space (has_Inf (has_neg Type)) := sorry --non-trivial
lemma new_lemma_90585 (h0 : not (group (denumerable reducibility_hints) -> false)) : @is_cyclic.{0} (denumerable.{0} reducibility_hints) (@classical.by_contradiction'.{1} (group.{0} (denumerable.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_90586 (h0 : filter (ring (finset pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_90587 (h0 : complete_lattice (ordered_comm_ring congr_arg_kind)) : is_atomistic (ordered_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_90588 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_90589 (h0 : list (plift num)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_90590 (h0 : topological_space (ordered_comm_monoid (ring (ordered_ring pos)))) : totally_separated_space (ordered_comm_monoid (ring (ordered_ring pos))) := sorry --non-trivial
lemma new_lemma_90591 (h0 : functor.add_const (topological_space (mul_zero_class pos)) unsigned) : @normal_space.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_90592 (h3 : uniform_space congr_arg_kind) : complete_space congr_arg_kind := sorry --non-trivial
lemma new_lemma_90593 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_90594 (h0 : functor.add_const (monoid (boolean_algebra linarith.comp)) (simple_graph name)) : @monoid.fg.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (boolean_algebra.{0} linarith.comp)) (simple_graph.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_90595 (h0 : ring (ordered_comm_ring (ordered_comm_ring linarith.comp))) : is_domain (ordered_comm_ring (ordered_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_90596 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_90597 (h0 : functor.add_const (complete_lattice (comm_group linarith.comp)) (has_neg pos)) : @complete_lattice.is_Sup_finite_compact.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} linarith.comp)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_90598 (h0 : topological_space (has_Inf Type)) : irreducible_space (has_Inf Type) := sorry --non-trivial
lemma new_lemma_90599 (h0 : functor.comp topological_space mul_zero_class ennreal) : @path_connected_space.{0} (mul_zero_class.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_90600 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (complete_linear_order.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_90601 (h0 : functor.add_const (ring (ring name)) (boolean_algebra name)) : @rank_condition.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} name)) (boolean_algebra.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_90602 (h0 : function.extfun (Type 1) monoid) : @monoid.fg.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} h0 (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_90603 (h0 : set (has_ssubset (normed_field reducibility_hints))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_90604 (h0 : not (ring (has_div string_imp) -> false)) : @is_domain.{0} (has_div.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (has_div.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_90605 (h0 : complete_lattice (boolean_algebra (has_neg (has_neg (has_neg linarith.comp))))) : complete_lattice.is_Sup_finite_compact (boolean_algebra (has_neg (has_neg (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_90606 (h0 : function.extfun nat fin) : @t1_space.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_pos_part.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_90607 (h0 : ring (has_bot (sub_neg_monoid real))) : strong_rank_condition (has_bot (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_90608 (h0 : topological_space (generalized_boolean_algebra (finset pos))) : normal_space (generalized_boolean_algebra (finset pos)) := sorry --non-trivial
lemma new_lemma_90609 (h0 : topological_space (non_unital_non_assoc_semiring (mul_one_class linarith.ineq))) : t0_space (non_unital_non_assoc_semiring (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_90610 (h0 : filter (simple_graph (ring (ring linarith.comp)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_90611 (h0 : group (pseudo_metric_space ennreal)) : is_simple_group (pseudo_metric_space ennreal) := sorry --non-trivial
lemma new_lemma_90612 (h0 : functor.add_const (topological_space (finset name)) linarith.comp) : @t0_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_90613 (h0 : ring (has_append (has_nnnorm fun_info))) : strong_rank_condition (has_append (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_90614 (h0 : set (has_compl enat)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_90615 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_zero pos)) name) : @unique_factorization_monoid.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_zero.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_90616 (h2 : set (fun_info -> ereal)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_90617 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_90618 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @sequential_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_90619 (h0 : topological_space (has_nndist (has_add (has_add ennreal)))) : regular_space (has_nndist (has_add (has_add ennreal))) := sorry --non-trivial
lemma new_lemma_90620 (h0 : ring (has_compl (has_nnnorm (mul_one_class reducibility_hints)))) : rank_condition (has_compl (has_nnnorm (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_90621 (h0 : semiring (ordered_comm_monoid (has_neg (has_neg (has_neg name))))) : is_noetherian_ring (ordered_comm_monoid (has_neg (has_neg (has_neg name)))) := sorry --non-trivial
lemma new_lemma_90622 (h0 : topological_space (has_norm (has_norm (has_top empty)))) : t0_space (has_norm (has_norm (has_top empty))) := sorry --non-trivial
lemma new_lemma_90623 (h0 : complete_lattice (has_inter (option (option (option unsigned))))) : is_atomistic (has_inter (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_90624 (h0 : has_mem.mem (has_top (has_norm congr_arg_kind)) has_emptyc.emptyc) : @locally_compact_space.{0} (has_top.{0} (has_norm.{0} congr_arg_kind)) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} (has_norm.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_90625 (h0 : topological_space (has_nndist (finset linarith.comp))) : locally_compact_space (has_nndist (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_90626 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_90627 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_90628 (h0 : topological_space (has_nndist (finset linarith.comp))) : path_connected_space (has_nndist (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_90629 (h0 : functor.add_const (function.extfun nat fin) real) : @group.fg.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (group.{1} (has_bot.{1} Type)) (@function.extfun_app.{1 1} nat fin (@functor.add_const.run.{0 0} (function.extfun.{1 1} nat fin) real h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_90630 (h0 : complete_lattice (lex (semigroup (semigroup unsigned)))) : is_atomistic (lex (semigroup (semigroup unsigned))) := sorry --non-trivial
lemma new_lemma_90631 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) (boolean_algebra name)) : @normal_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) (boolean_algebra.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_90632 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (pseudo_metric_space congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_90633 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_90634 (h0 : function.extfun (Type 1) topological_space) : @locally_compact_space.{1} (canonically_linear_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (canonically_linear_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_90635 (h1 : list (semi_normed_comm_ring (random_gen to_additive.value_type))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_90636 (h0 : function.extfun Type group) : @group.fg.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_90637 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra linarith.comp)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_90638 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_domain.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_90639 (h0 : ring (has_neg (add_comm_monoid name))) : is_domain (has_neg (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_90640 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_90641 (h0 : topological_space (option num)) : loc_path_connected_space (option num) := sorry --non-trivial
lemma new_lemma_90642 (h0 : complete_lattice (measurable_space (has_norm (has_norm (has_norm fun_info))))) : is_atomistic (measurable_space (has_norm (has_norm (has_norm fun_info)))) := sorry --non-trivial
lemma new_lemma_90643 (h0 : set (set std_gen)) (h1 : set std_gen) : filter.generate_sets h0 h1 := sorry --non-trivial
lemma new_lemma_90644 (h0 : ring (canonically_ordered_comm_semiring (add_cancel_monoid (option ennreal)))) : is_domain (canonically_ordered_comm_semiring (add_cancel_monoid (option ennreal))) := sorry --non-trivial
lemma new_lemma_90645 (h0 : topological_space (bin_tree (semiring unsigned))) : t0_space (bin_tree (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_90646 (h0 : list (linear_ordered_semiring empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_90647 (h0 : complete_lattice (add_comm_monoid (complete_distrib_lattice unsigned))) : is_atomistic (add_comm_monoid (complete_distrib_lattice unsigned)) := sorry --non-trivial
lemma new_lemma_90648 (h1 : comm_ring environment.projection_info) : local_ring environment.projection_info := sorry --non-trivial
lemma new_lemma_90649 (h0 : topological_space (has_add (has_add real))) : loc_path_connected_space (has_add (has_add real)) := sorry --non-trivial
lemma new_lemma_90650 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) name) : @t0_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_90651 (h0 : functor.add_const (add_group (boolean_algebra Type)) pos) : @is_add_cyclic.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_90652 (h0 : ordered_comm_monoid (add_cancel_monoid ennreal)) : has_exists_mul_of_le (add_cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_90653 (h0 : finset (monoid_with_zero congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_90654 (h0 : topological_space (linear_ordered_add_comm_group linarith.ineq)) : irreducible_space (linear_ordered_add_comm_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_90655 (h0 : topological_space (ordered_comm_monoid (ring linarith.comp))) : irreducible_space (ordered_comm_monoid (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_90656 (h0 : filter (normed_group (has_top to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_90657 (h0 : function.extfun Type group) : @is_cyclic.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_90658 (h0 : uniform_space (has_inv (has_nnnorm to_additive.value_type))) : complete_space (has_inv (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_90659 (h0 : functor.add_const (ring pos) (normed_comm_ring pos)) : @is_principal_ideal_ring.{0} pos (@functor.add_const.run.{0 0} (ring.{0} pos) (normed_comm_ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_90660 (h0 : topological_space (has_nndist (option (option empty)))) : t0_space (has_nndist (option (option empty))) := sorry --non-trivial
lemma new_lemma_90661 (h0 : function.extfun Type complete_lattice) : is_compactly_generated (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_90662 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_90663 (h0 : list (linear_order (option empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_90664 (h0 : topological_space (semiring (has_top (has_top num)))) : locally_compact_space (semiring (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_90665 (h0 : ordered_add_comm_monoid (boolean_algebra (finset pos))) : archimedean (boolean_algebra (finset pos)) := sorry --non-trivial
lemma new_lemma_90666 (h0 : complete_lattice (cancel_monoid unsigned)) : is_compactly_generated (cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_90667 (h0 : ring (boolean_algebra.core (ring (has_pos_part linarith.comp)))) : is_principal_ideal_ring (boolean_algebra.core (ring (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_90668 (h0 : has_mem.mem (has_emptyc congr_arg_kind) has_emptyc.emptyc) : @rank_condition.{0} (has_emptyc.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type ring.{0} (has_emptyc.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_90669 (h0 : uniform_space (has_bot (sub_neg_monoid Type))) : separated_space (has_bot (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_90670 (h1 : set (add_comm_semigroup enat -> mul_one_class enat)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_90671 (h0 : group (bin_tree (semiring (semiring (semiring (semiring num)))))) : normalizer_condition (bin_tree (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_90672 (h0 : functor.add_const (topological_space (ring linarith.comp)) environment.implicit_infer_kind) : @t1_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_90673 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (non_assoc_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_90674 (h0 : functor.add_const (topological_space (has_nndist empty)) num) : @path_connected_space.{0} (has_nndist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_90675 (h2 : topological_space (has_emptyc congr_arg_kind)) : t0_space (has_emptyc congr_arg_kind) := sorry --non-trivial
lemma new_lemma_90676 (h0 : topological_space (boolean_algebra (semigroup unsigned))) : path_connected_space (boolean_algebra (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_90677 (h0 : topological_space (has_nnnorm (has_nnnorm linarith.comp_source))) : totally_disconnected_space (has_nnnorm (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_90678 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_90679 (h0 : functor.add_const (monoid (complete_distrib_lattice pos)) linarith.comp) : @monoid.fg.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (complete_distrib_lattice.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_90680 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (finset.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} real))  := sorry --non-trivial
lemma new_lemma_90681 (h0 : filter (boolean_algebra.core (comm_group Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_90682 (h0 : ring (finset (finset (finset (finset linarith.comp))))) : is_principal_ideal_ring (finset (finset (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_90683 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_90684 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_neg.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_neg.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_90685 (h0 : topological_space (boolean_algebra.core (finset (has_add (has_Inf linarith.comp))))) : t1_space (boolean_algebra.core (finset (has_add (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_90686 (h1 : not (topological_space to_additive.value_type -> false)) : @t0_space.{0} to_additive.value_type (@classical.by_contradiction'.{1} (topological_space.{0} to_additive.value_type) h1)  := sorry --non-trivial
lemma new_lemma_90687 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_90688 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) name) : @regular_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_90689 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_90690 (h0 : ring (has_nndist (finset (has_to_string (finset linarith.comp))))) : is_principal_ideal_ring (has_nndist (finset (has_to_string (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_90691 (h0 : group (option (semiring (semiring (has_top (semiring (semiring (has_top empty)))))))) : is_cyclic (option (semiring (semiring (has_top (semiring (semiring (has_top empty))))))) := sorry --non-trivial
lemma new_lemma_90692 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} to_additive.value_type (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_90693 (h0 : functor.add_const (topological_space (has_zero name)) (comm_group Type)) : @regular_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} name)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_90694 (h1 : topological_space string_imp) : path_connected_space string_imp := sorry --non-trivial
lemma new_lemma_90695 (h1 : Prop) : h1 := sorry --non-trivial
lemma new_lemma_90696 (h0 : add_group (semigroup (finset unsigned))) : is_add_cyclic (semigroup (finset unsigned)) := sorry --non-trivial
lemma new_lemma_90697 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : totally_separated_space nnreal := sorry --non-trivial
lemma new_lemma_90698 (h0 : list (canonically_ordered_comm_semiring (finset (finset ennreal)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_90699 (h0 : complete_lattice (plift (option congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (plift (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_90700 (h0 : ordered_comm_monoid (complete_distrib_lattice (has_add (has_add pos)))) : has_exists_mul_of_le (complete_distrib_lattice (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_90701 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_90702 (h0 : topological_space (semiring (has_union linarith.comp))) : irreducible_space (semiring (has_union linarith.comp)) := sorry --non-trivial
lemma new_lemma_90703 (h1 : ring (has_lt (random_gen reducibility_hints))) : is_domain (has_lt (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_90704 (h0 : topological_space (boolean_algebra (boolean_algebra (finset pos)))) : topological_space.separable_space (boolean_algebra (boolean_algebra (finset pos))) := sorry --non-trivial
lemma new_lemma_90705 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_90706 (h0 : add_group (has_norm (has_top (has_top linarith.comp_source)))) : is_add_cyclic (has_norm (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_90707 (h0 : complete_lattice (non_assoc_semiring congr_arg_kind)) : is_atomistic (non_assoc_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_90708 (h0 : topological_space (left_cancel_semigroup congr_arg_kind)) : preirreducible_space (left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_90709 (h0 : ring (has_sub num)) : is_domain (has_sub num) := sorry --non-trivial
lemma new_lemma_90710 (h0 : topological_space (random_gen (has_top (has_top num)))) : normal_space (random_gen (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_90711 (h0 : complete_lattice (has_inv (random_gen to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (has_inv (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_90712 (h0 : filter (add_right_cancel_monoid (semiring unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_90713 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_one.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_90714 (h0 : add_monoid (has_neg (has_neg Type))) : add_monoid.fg (has_neg (has_neg Type)) := sorry --non-trivial
lemma new_lemma_90715 (h0 : functor.add_const (topological_space (left_cancel_monoid empty)) num) : @totally_disconnected_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_90716 (h0 : functor.add_const (filter (ring pos)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_90717 (h0 : topological_space (has_neg name)) : t1_space (has_neg name) := sorry --non-trivial
lemma new_lemma_90718 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_90719 (h1 : fin has_zero.zero) : @strong_rank_condition.{1} (linear_ordered_add_comm_group.{1} (plift.{1} (with_bot.{0} char))) (@matrix.vec_empty.{1} (ring.{1} (linear_ordered_add_comm_group.{1} (plift.{1} (with_bot.{0} char)))) h1)  := sorry --non-trivial
lemma new_lemma_90720 (h0 : complete_lattice (denumerable linarith.comp_source)) : is_compactly_generated (denumerable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_90721 (h1 : group (has_ssubset linarith.comp_source)) : is_cyclic (has_ssubset linarith.comp_source) := sorry --non-trivial
lemma new_lemma_90722 (h0 : functor.add_const (function.extfun Type list) linarith.comp) : list.nodup (function.extfun_app (functor.add_const.run h0) (ordered_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_90723 (h0 : topological_space (has_neg (comm_group unsigned))) : t0_space (has_neg (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_90724 (h0 : topological_space (has_div (normed_field (has_compl string_imp)))) : t0_space (has_div (normed_field (has_compl string_imp))) := sorry --non-trivial
lemma new_lemma_90725 (h0 : function.extfun Type group) : @group.fg.{0} (distrib_lattice.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (distrib_lattice.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_90726 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @preconnected_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_90727 (h0 : topological_space (has_neg (has_add linarith.comp))) : totally_disconnected_space (has_neg (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_90728 (h8 : topological_space (has_compl linarith.comp_source)) : t0_space (has_compl linarith.comp_source) := sorry --non-trivial
lemma new_lemma_90729 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (@id.{2} Type string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (@id.{2} Type string_imp))  := sorry --non-trivial
lemma new_lemma_90730 (h0 : not (add_group (uniform_space string.iterator_imp) -> false)) : @is_add_cyclic.{0} (uniform_space.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (add_group.{0} (uniform_space.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_90731 (h0 : complete_lattice (ordered_comm_monoid (has_Inf real))) : is_compactly_generated (ordered_comm_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_90732 (h0 : ring (has_neg (ring (ring unsigned)))) : is_domain (has_neg (ring (ring unsigned))) := sorry --non-trivial
lemma new_lemma_90733 (h0 : functor.add_const (complete_lattice nnreal) empty) : @complete_lattice.is_Sup_finite_compact.{0} nnreal (@functor.add_const.run.{0 0} (complete_lattice.{0} nnreal) empty h0)  := sorry --non-trivial
lemma new_lemma_90734 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_90735 (h0 : function.extfun Type add_monoid) : add_monoid.fg ennreal := sorry --non-trivial
lemma new_lemma_90736 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_dist ennreal)) := sorry --non-trivial
lemma new_lemma_90737 (h0 : topological_space (has_neg (add_cancel_monoid Type))) : sequential_space (has_neg (add_cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_90738 (h0 : group (semigroup (has_add (has_add (has_add (has_add name)))))) : is_cyclic (semigroup (has_add (has_add (has_add (has_add name))))) := sorry --non-trivial
lemma new_lemma_90739 (h0 : topological_space (simple_graph (option unsigned))) : irreducible_space (simple_graph (option unsigned)) := sorry --non-trivial
lemma new_lemma_90740 (h0 : ring (linear_ordered_add_comm_group (has_append linarith.comp_source))) : rank_condition (linear_ordered_add_comm_group (has_append linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_90741 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_90742 (h0 : topological_space (has_le (mul_one_class linarith.ineq))) : path_connected_space (has_le (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_90743 (h0 : function.extfun (Type 1) list) : list.nodup (function.extfun_app h0 Type) := sorry --non-trivial
lemma new_lemma_90744 (h0 : functor.add_const (function.extfun Type complete_lattice) (normed_comm_ring (finset pos))) : @is_compactly_generated.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) (normed_comm_ring.{0} (finset.{0} pos)) h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_90745 (h0 : cancel_comm_monoid_with_zero (linear_ordered_add_comm_group_with_top ennreal)) : unique_factorization_monoid (linear_ordered_add_comm_group_with_top ennreal) := sorry --non-trivial
lemma new_lemma_90746 (h0 : topological_space (denumerable (random_gen linarith.comp_source))) : path_connected_space (denumerable (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_90747 (h0 : functor.add_const (topological_space (cancel_monoid name)) environment.implicit_infer_kind) : @normal_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_90748 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} unsigned (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) unsigned)  := sorry --non-trivial
lemma new_lemma_90749 (h0 : functor.add_const (finset (has_zero Type)) (has_add (comm_group pos))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_90750 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_90751 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (add_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_90752 (h0 : not (filter (has_compl linarith.comp_source) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_90753 (h0 : functor.add_const (ring (semigroup pos)) (comm_group Type)) : @is_principal_ideal_ring.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (semigroup.{0} pos)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_90754 (h0 : topological_space (has_emptyc (encodable char))) : totally_disconnected_space (has_emptyc (encodable char)) := sorry --non-trivial
lemma new_lemma_90755 (h0 : ring (complete_distrib_lattice (has_Inf real))) : rank_condition (complete_distrib_lattice (has_Inf real)) := sorry --non-trivial
lemma new_lemma_90756 (h0 : functor.add_const (topological_space (has_inner unsigned congr_arg_kind)) unsigned) : @t0_space.{0} (has_inner.{0 0} unsigned congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_inner.{0 0} unsigned congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_90757 (h0 : add_group (normed_group to_additive.value_type)) : is_add_cyclic (normed_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_90758 (h0 : uniform_space (mul_one_class (has_ssubset string.iterator_imp))) : complete_space (mul_one_class (has_ssubset string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_90759 (h0 : topological_space (pseudo_metric_space name)) : totally_separated_space (pseudo_metric_space name) := sorry --non-trivial
lemma new_lemma_90760 (h1 : uniform_space (normed_group linarith.comp_source)) : complete_space (normed_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_90761 (h1 : topological_space (add_comm_semigroup environment.projection_info)) (h2 : set (add_comm_semigroup environment.projection_info)) : is_path_connected h2 := sorry --non-trivial
lemma new_lemma_90762 (h0 : topological_space (ordered_comm_ring linarith.comp)) : t1_space (ordered_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_90763 (h0 : functor.add_const (group (has_nndist unsigned)) Type) : @is_simple_group.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 1} (group.{0} (has_nndist.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_90764 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_90765 (h0 : functor.add_const (topological_space (has_to_string Type)) unsigned) : @totally_separated_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_90766 (h0 : not (semiring (has_union num) -> false)) : @is_noetherian_ring.{0} (has_union.{0} num) (@classical.by_contradiction'.{1} (semiring.{0} (has_union.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_90767 (h0 : functor.add_const (uniform_space (has_add linarith.comp)) (has_add (has_neg_part Type))) : @separated_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_add.{0} linarith.comp)) (has_add.{1} (has_neg_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_90768 (h0 : topological_space znum) : topological_space.separable_space znum := sorry --non-trivial
lemma new_lemma_90769 (h0 : topological_space (pseudo_metric_space num)) : loc_path_connected_space (pseudo_metric_space num) := sorry --non-trivial
lemma new_lemma_90770 (h0 : topological_space (with_one (semiring (semiring (semiring (semiring linarith.comp)))))) : path_connected_space (with_one (semiring (semiring (semiring (semiring linarith.comp))))) := sorry --non-trivial
lemma new_lemma_90771 (h1 : ring (has_emptyc linarith.comp_source)) : is_domain (has_emptyc linarith.comp_source) := sorry --non-trivial
lemma new_lemma_90772 (h0 : group (normed_comm_ring (comm_group environment.implicit_infer_kind))) : normalizer_condition (normed_comm_ring (comm_group environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_90773 (h0 : uniform_space (cancel_monoid (option (option ennreal)))) : separated_space (cancel_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_90774 (h0 : complete_lattice (has_compl string.iterator_imp)) : is_compactly_generated (has_compl string.iterator_imp) := sorry --non-trivial
lemma new_lemma_90775 (h0 : not (uniform_space (has_emptyc linarith.comp) -> false)) : @separated_space.{0} (has_emptyc.{0} linarith.comp) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_emptyc.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_90776 (h0 : topological_space (has_zero (has_nndist unsigned))) : totally_disconnected_space (has_zero (has_nndist unsigned)) := sorry --non-trivial
lemma new_lemma_90777 (h0 : topological_space (simple_graph (mul_one_class (mul_one_class char)))) : totally_disconnected_space (simple_graph (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_90778 (h0 : topological_space (ordered_comm_ring (sub_neg_monoid Type))) : irreducible_space (ordered_comm_ring (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_90779 (h0 : functor.add_const (topological_space (is_R_or_C congr_arg_kind)) empty) : @normal_space.{0} (is_R_or_C.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_90780 (h0 : complete_lattice (has_bot (finset name))) : is_compactly_generated (has_bot (finset name)) := sorry --non-trivial
lemma new_lemma_90781 (h0 : list (cancel_monoid (semigroup (has_neg (has_neg (pseudo_metric_space (semigroup (has_to_string name)))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_90782 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_90783 (h0 : functor.add_const (finset (canonically_linear_ordered_monoid unsigned)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_90784 (h0 : not (group (distrib_lattice char) -> false)) : @is_cyclic.{0} (distrib_lattice.{0} char) (@classical.by_contradiction'.{1} (group.{0} (distrib_lattice.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_90785 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normalizer_condition.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_90786 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : complete_space nnreal := sorry --non-trivial
lemma new_lemma_90787 (h0 : has_mem.mem ring has_emptyc.emptyc) : @strong_rank_condition.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_90788 (h0 : functor.add_const (ring (has_Inf linarith.comp)) (ring Type)) : @rank_condition.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (has_Inf.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_90789 (h0 : list (ordered_comm_group (option empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_90790 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) Type) : @discrete_topology.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (normed_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_90791 (h0 : has_mem.mem congr_arg_kind has_zero.zero) : @locally_compact_space.{0} congr_arg_kind (@multiset.pi.empty.{1 0} Type topological_space.{0} congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_90792 (h0 : functor.add_const (add_monoid (has_add linarith.comp)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_add.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_90793 (h0 : topological_space (has_nndist (has_add (has_add (has_add (has_add name)))))) : totally_separated_space (has_nndist (has_add (has_add (has_add (has_add name))))) := sorry --non-trivial
lemma new_lemma_90794 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_90795 (h0 : set (has_neg (has_compl enat))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_90796 (h1 : not (ring (with_one num) -> false)) : @is_domain.{0} (with_one.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (with_one.{0} num)) h1)  := sorry --non-trivial
lemma new_lemma_90797 (h0 : ring (left_cancel_monoid (semiring (semiring empty)))) : is_principal_ideal_ring (left_cancel_monoid (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_90798 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_90799 (h0 : topological_space (add_comm_monoid environment.implicit_infer_kind)) : t0_space (add_comm_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_90800 (h1 : function.extfun Type topological_space) : @totally_disconnected_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} h1 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_90801 (h0 : topological_space (has_top (random_gen char))) : totally_disconnected_space (has_top (random_gen char)) := sorry --non-trivial
lemma new_lemma_90802 (h0 : fin has_zero.zero) : @totally_separated_space.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (sub_neg_monoid.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_90803 (h2 : ring (has_ssubset to_additive.value_type)) : is_domain (has_ssubset to_additive.value_type) := sorry --non-trivial
lemma new_lemma_90804 (h1 : uniform_space (has_norm (has_norm (has_norm linarith.comp)))) : separated_space (has_norm (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_90805 (h0 : ring (has_neg (comm_group Type))) : is_domain (has_neg (comm_group Type)) := sorry --non-trivial
lemma new_lemma_90806 (h1 : not (ring (semi_normed_ring linarith.ineq) -> false)) : @rank_condition.{0} (semi_normed_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_ring.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_90807 (h0 : function.extfun (finset Type) (has_mem.mem unsigned)) : @group.fg.{0} unsigned (@finset.pi.empty.{1 0} Type group.{0} unsigned (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) unsigned) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_90808 (h0 : complete_lattice (has_to_string ennreal)) : is_atomistic (has_to_string ennreal) := sorry --non-trivial
lemma new_lemma_90809 (h0 : functor.add_const (add_group (normed_lattice_add_comm_group real)) real) : @is_add_cyclic.{0} (normed_lattice_add_comm_group.{0} real) (@functor.add_const.run.{0 0} (add_group.{0} (normed_lattice_add_comm_group.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_90810 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_90811 (h0 : group (has_neg (has_nndist (finset (finset linarith.comp))))) : normalizer_condition (has_neg (has_nndist (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_90812 (h0 : functor.add_const (topological_space (ring Type)) pos) : @totally_separated_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_90813 (h0 : functor.add_const (topological_space (boolean_algebra Type)) pos) : @discrete_topology.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_90814 (h0 : complete_lattice znum) : is_compactly_generated znum := sorry --non-trivial
lemma new_lemma_90815 (h0 : finset (measure_theory.measure_space num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_90816 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_bot name)) (has_Inf (has_Inf (has_Inf linarith.comp)))) : @unique_factorization_monoid.{0} (has_bot.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_bot.{0} name)) (has_Inf.{0} (has_Inf.{0} (has_Inf.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_90817 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_90818 (h0 : fin has_zero.zero) : @group.fg.{0} (comm_semigroup.{0} name) (@matrix.vec_empty.{0} (group.{0} (comm_semigroup.{0} name)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_90819 (h0 : ring (has_zero (has_add pos))) : strong_rank_condition (has_zero (has_add pos)) := sorry --non-trivial
lemma new_lemma_90820 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_90821 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (complete_linear_order num)) := sorry --non-trivial
lemma new_lemma_90822 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_90823 (h0 : has_star (bin_tree congr_arg_kind) -> has_star (bin_tree congr_arg_kind) -> Prop) : is_trans (has_star (bin_tree congr_arg_kind)) h0 := sorry --non-trivial
lemma new_lemma_90824 (h0 : functor.add_const (complete_lattice (add_cancel_monoid name)) unsigned) : @is_atomistic.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_90825 (h0 : function.extfun Type topological_space) : @normal_space.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_90826 (h0 : functor.add_const (function.extfun Type ring) Type) : @is_principal_ideal_ring.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_90827 (h0 : topological_space (has_union congr_arg_kind)) : normal_space (has_union congr_arg_kind) := sorry --non-trivial
lemma new_lemma_90828 (h0 : functor.add_const (topological_space (has_add name)) (has_neg linarith.comp)) : @preirreducible_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_90829 (h0 : functor.comp filter add_comm_monoid pos) : countable_Inter_filter (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_90830 (h1 h2 : multiset (distrib (has_nnnorm reducibility_hints))) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_90831 (h0 : add_group (boolean_algebra linarith.comp)) : is_add_cyclic (boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_90832 (h0 : function.extfun Type (functor.comp topological_space canonically_ordered_comm_semiring)) : @preconnected_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_90833 (h0 : group (is_R_or_C (semiring num))) : is_cyclic (is_R_or_C (semiring num)) := sorry --non-trivial
lemma new_lemma_90834 (h0 : finset (add_comm_monoid (has_neg (finset (has_neg (finset (finset linarith.comp))))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_90835 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_90836 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_90837 (h0 : ordered_add_comm_monoid (finset congr_arg_kind)) : archimedean (finset congr_arg_kind) := sorry --non-trivial
lemma new_lemma_90838 (h0 : uniform_space (semiring (semiring (has_norm empty)))) : complete_space (semiring (semiring (has_norm empty))) := sorry --non-trivial
lemma new_lemma_90839 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_90840 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (id linarith.ineq)) := sorry --non-trivial
lemma new_lemma_90841 (h0 : complete_lattice (left_cancel_semigroup (semiring congr_arg_kind))) : is_atomistic (left_cancel_semigroup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_90842 (h0 : functor.add_const (complete_lattice (finset Type)) Type) : @is_atomistic.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (finset.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_90843 (h0 : not (topological_space (comm_ring (has_nnnorm string.iterator_imp)) -> false)) : @path_connected_space.{0} (comm_ring.{0} (has_nnnorm.{0} string.iterator_imp)) (@classical.by_contradiction'.{1} (topological_space.{0} (comm_ring.{0} (has_nnnorm.{0} string.iterator_imp))) h0)  := sorry --non-trivial
lemma new_lemma_90844 (h0 : topological_space (nondiscrete_normed_field reducibility_hints)) : path_connected_space (nondiscrete_normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_90845 (h0 : functor.add_const (function.extfun (Type 1) group) (ring Type)) : @normalizer_condition.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) (ring.{1} Type) h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_90846 (h0 : cancel_comm_monoid_with_zero (has_nndist (has_nndist ennreal))) : unique_factorization_monoid (has_nndist (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_90847 (h0 : ordered_add_comm_monoid (canonically_linear_ordered_monoid (option (option ennreal)))) : archimedean (canonically_linear_ordered_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_90848 (h0 : function.extfun Type ring) : @is_domain.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_90849 (h0 : topological_space (has_append (has_dist fun_info))) : t0_space (has_append (has_dist fun_info)) := sorry --non-trivial
lemma new_lemma_90850 (h0 : complete_lattice (semi_normed_comm_ring (random_gen (random_gen to_additive.value_type)))) : is_compactly_generated (semi_normed_comm_ring (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_90851 (h0 : has_mem.mem (linear_ordered_semiring congr_arg_kind) has_emptyc.emptyc) : @is_compactly_generated.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (linear_ordered_semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_90852 (h0 : ring (ordered_comm_group (option (option (add_cancel_monoid (option unsigned)))))) : is_principal_ideal_ring (ordered_comm_group (option (option (add_cancel_monoid (option unsigned))))) := sorry --non-trivial
lemma new_lemma_90853 (h0 : ring (finset (mul_zero_class name))) : is_domain (finset (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_90854 (h0 : has_mem.mem ring has_emptyc.emptyc) : @strong_rank_condition.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (linear_ordered_semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_90855 (h0 : comm_ring char) (h1 : ring Prop) (h2 : ring_hom char Prop) : @classical.epsilon.{1} Prop (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@ring_hom.is_integral_elem.{0 0} char Prop h0 h1 h2)  := sorry --non-trivial
lemma new_lemma_90856 (h0 : complete_lattice (ordered_comm_ring name)) : is_atomistic (ordered_comm_ring name) := sorry --non-trivial
lemma new_lemma_90857 (h0 : linear_ordered_field (has_add ennreal) -> linear_ordered_field (has_add ennreal) -> Prop) : reflexive h0 := sorry --non-trivial
lemma new_lemma_90858 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_dist num)) := sorry --non-trivial
lemma new_lemma_90859 (h0 : complete_lattice ennreal) : is_compactly_generated ennreal := sorry --non-trivial
lemma new_lemma_90860 (h0 : functor.add_const (group (add_comm_monoid pos)) (ring linarith.comp)) : @group.fg.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} pos)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_90861 (h0 : topological_space (ordered_cancel_add_comm_monoid (has_zero num))) : locally_compact_space (ordered_cancel_add_comm_monoid (has_zero num)) := sorry --non-trivial
lemma new_lemma_90862 (h0 : functor.add_const (ordered_comm_monoid (has_add pos)) Type) : @has_exists_mul_of_le.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (has_add.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_90863 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_90864 (h0 : complete_lattice (topological_space (has_nnnorm fun_info))) : complete_lattice.is_Sup_finite_compact (topological_space (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_90865 (h0 : uniform_space (complete_distrib_lattice (has_add (has_add (ring (ordered_ring name)))))) : separated_space (complete_distrib_lattice (has_add (has_add (ring (ordered_ring name))))) := sorry --non-trivial
lemma new_lemma_90866 (h0 : functor.add_const (semiring (boolean_algebra.core Type)) unsigned) : @is_noetherian_ring.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (boolean_algebra.core.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_90867 (h0 : uniform_space (has_div (mul_one_class enat))) : complete_space (has_div (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_90868 (h1 : group (uniform_space linarith.comp_source)) : is_cyclic (uniform_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_90869 (h0 : topological_space (random_gen (semiring (has_top congr_arg_kind)))) : discrete_topology (random_gen (semiring (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_90870 (h0 : not (topological_space (complete_semilattice_Sup empty) -> false)) : @normal_space.{0} (complete_semilattice_Sup.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_90871 (h0 : fin has_zero.zero) : @t0_space.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_90872 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_90873 (h0 : uniform_space (has_top (has_inv (has_inv to_additive.value_type)))) : separated_space (has_top (has_inv (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_90874 (h0 : topological_space (has_norm (has_norm num))) : path_connected_space (has_norm (has_norm num)) := sorry --non-trivial
lemma new_lemma_90875 (h0 : not (complete_lattice (random_gen to_additive.value_type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_90876 (h0 : uniform_space (normed_lattice_add_comm_group (has_add real))) : complete_space (normed_lattice_add_comm_group (has_add real)) := sorry --non-trivial
lemma new_lemma_90877 (h0 : functor.add_const (topological_space (has_dist unsigned)) empty) : @path_connected_space.{0} (has_dist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_90878 (h0 : not (uniform_space (left_cancel_semigroup num) -> false)) : @separated_space.{0} (left_cancel_semigroup.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (left_cancel_semigroup.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_90879 (h1 : uniform_space (denumerable (denumerable (denumerable reducibility_hints)))) : complete_space (denumerable (denumerable (denumerable reducibility_hints))) := sorry --non-trivial
lemma new_lemma_90880 (h0 : ring (generalized_boolean_algebra linarith.comp)) : is_principal_ideal_ring (generalized_boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_90881 (h0 : topological_space (has_neg (has_add pos))) : discrete_topology (has_neg (has_add pos)) := sorry --non-trivial
lemma new_lemma_90882 (h0 : function.extfun Type ring) : @rank_condition.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_90883 (h0 : function.extfun Type topological_space) : @normal_space.{0} (canonically_ordered_comm_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_90884 (h0 : functor.add_const (ring (omega_complete_partial_order empty)) empty) : @rank_condition.{0} (omega_complete_partial_order.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (omega_complete_partial_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_90885 (h0 : ring (add_group congr_arg_kind)) : rank_condition (add_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_90886 (h0 : ordered_add_comm_monoid (add_cancel_monoid congr_arg_kind)) : archimedean (add_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_90887 (h0 : functor.add_const (complete_lattice (has_to_string linarith.comp)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_to_string.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_90888 (h0 : topological_space (denumerable reducibility_hints)) : t0_space (denumerable reducibility_hints) := sorry --non-trivial
lemma new_lemma_90889 (h0 : topological_space (random_gen (add_cancel_comm_monoid char))) : t0_space (random_gen (add_cancel_comm_monoid char)) := sorry --non-trivial
lemma new_lemma_90890 (h0 : topological_space (has_neg unsigned)) : loc_path_connected_space (has_neg unsigned) := sorry --non-trivial
lemma new_lemma_90891 (h0 : group (topological_space (random_gen (random_gen string_imp)))) : group.fg (topological_space (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_90892 (h0 : topological_space (normed_comm_ring (option unsigned))) : locally_compact_space (normed_comm_ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_90893 (h0 : ring (filter unsigned)) : rank_condition (filter unsigned) := sorry --non-trivial
lemma new_lemma_90894 (h0 : complete_lattice (finset (finset (finset environment.implicit_infer_kind)))) : is_compactly_generated (finset (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_90895 (h0 : fin has_zero.zero) : @rank_condition.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)) (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_90896 (h0 : function.extfun Type ring) : @is_domain.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_90897 (h0 : topological_space (has_zero name)) : totally_disconnected_space (has_zero name) := sorry --non-trivial
lemma new_lemma_90898 (h0 : add_group (mul_zero_class pos)) : is_add_cyclic (mul_zero_class pos) := sorry --non-trivial
lemma new_lemma_90899 (h0 : topological_space (normed_lattice_add_comm_group (sub_neg_monoid real))) : t1_space (normed_lattice_add_comm_group (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_90900 (h0 : topological_space (has_bot (sub_neg_monoid pos))) : normal_space (has_bot (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_90901 (h0 : function.extfun nat fin) : @is_add_cyclic.{0} (has_pos_part.{0} name) (@matrix.vec_empty.{0} (add_group.{0} (has_pos_part.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_90902 (h0 : topological_space (has_add (option (option (option pos))))) : preconnected_space (has_add (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_90903 (h0 : not (function.extfun Type topological_space -> false)) : @t1_space.{0} (measurable_space.dynkin_system.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.dynkin_system.{0} empty))  := sorry --non-trivial
lemma new_lemma_90904 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (ordered_comm_monoid.{1} (comm_semigroup.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_90905 (h0 : topological_space (sub_neg_monoid (has_neg (has_neg (has_neg pos))))) : preirreducible_space (sub_neg_monoid (has_neg (has_neg (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_90906 (h0 : uniform_space (has_one empty)) : separated_space (has_one empty) := sorry --non-trivial
lemma new_lemma_90907 (h0 : add_monoid (cancel_monoid (has_add name))) : add_monoid.fg (cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_90908 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (option pos)) := sorry --non-trivial
lemma new_lemma_90909 (h0 : group (linear_ordered_semiring empty)) : group.fg (linear_ordered_semiring empty) := sorry --non-trivial
lemma new_lemma_90910 (h0 : add_monoid (cancel_monoid (add_comm_monoid Type))) : add_monoid.fg (cancel_monoid (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_90911 (h0 : add_monoid (simple_graph (boolean_algebra.core (has_add Type)))) : add_monoid.fg (simple_graph (boolean_algebra.core (has_add Type))) := sorry --non-trivial
lemma new_lemma_90912 (h0 : uniform_space (has_nndist num)) : complete_space (has_nndist num) := sorry --non-trivial
lemma new_lemma_90913 (h0 : functor.add_const (ring (comm_group pos)) pos) : @strong_rank_condition.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_90914 (h0 : ordered_comm_monoid (has_Inf (has_add (has_add linarith.comp)))) : has_exists_mul_of_le (has_Inf (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_90915 (h0 : topological_space (has_lt fun_info)) (h1 : preorder (has_lt fun_info)) : order_closed_topology (has_lt fun_info) := sorry --non-trivial
lemma new_lemma_90916 (h0 : topological_space (has_inter (option ennreal))) : irreducible_space (has_inter (option ennreal)) := sorry --non-trivial
lemma new_lemma_90917 (h0 : functor.add_const (group (comm_group pos)) environment.implicit_infer_kind) : @is_simple_group.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_90918 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)) (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_90919 (h0 : topological_space linarith.ineq) : totally_separated_space linarith.ineq := sorry --non-trivial
lemma new_lemma_90920 (h0 : topological_space (dlist string_imp)) : irreducible_space (dlist string_imp) := sorry --non-trivial
lemma new_lemma_90921 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_90922 (h0 : ring (has_neg linarith.ineq)) : strong_rank_condition (has_neg linarith.ineq) := sorry --non-trivial
lemma new_lemma_90923 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) linarith.comp) : @t1_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_90924 (h0 : filter (semi_normed_comm_ring linarith.comp_source)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_90925 (h0 : uniform_space (has_top (random_gen linarith.ineq))) : complete_space (has_top (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_90926 (h0 : ring (ordered_comm_monoid (boolean_algebra.core linarith.comp))) : rank_condition (ordered_comm_monoid (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_90927 (h0 : topological_space (complete_distrib_lattice (normed_comm_ring environment.implicit_infer_kind))) : irreducible_space (complete_distrib_lattice (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_90928 (h0 : cancel_comm_monoid_with_zero (has_neg_part (finset environment.implicit_infer_kind))) : unique_factorization_monoid (has_neg_part (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_90929 (h0 : topological_space (sub_neg_monoid pos)) : regular_space (sub_neg_monoid pos) := sorry --non-trivial
lemma new_lemma_90930 (h0 : topological_space (canonically_linear_ordered_monoid (option num))) : topological_space.separable_space (canonically_linear_ordered_monoid (option num)) := sorry --non-trivial
lemma new_lemma_90931 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_90932 (h0 : ordered_comm_monoid (has_to_string (has_add name))) : has_exists_mul_of_le (has_to_string (has_add name)) := sorry --non-trivial
lemma new_lemma_90933 (h0 : measurable_space (measurable_space linarith.comp) -> measurable_space (measurable_space linarith.comp) -> Prop) : is_per (measurable_space (measurable_space linarith.comp)) h0 := sorry --non-trivial
lemma new_lemma_90934 (h0 : topological_space (has_to_string unsigned)) : discrete_topology (has_to_string unsigned) := sorry --non-trivial
lemma new_lemma_90935 (h0 : topological_space (ordered_comm_ring (has_neg Type))) : normal_space (ordered_comm_ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_90936 (h0 : functor.add_const (topological_space (add_comm_monoid environment.implicit_infer_kind)) linarith.comp) : @discrete_topology.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_90937 (h0 : functor.add_const (topological_space (has_zero unsigned)) pos) : @preconnected_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_90938 (h0 : ring (has_zero (has_to_string Type))) : rank_condition (has_zero (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_90939 (h2 : topological_space (id to_additive.value_type)) : locally_compact_space (id to_additive.value_type) := sorry --non-trivial
lemma new_lemma_90940 (h0 : group (linear_ordered_comm_ring (semiring (semiring unsigned)))) : normalizer_condition (linear_ordered_comm_ring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_90941 (h0 : ordered_comm_monoid (has_Inf (finset (has_add linarith.comp)))) : has_exists_mul_of_le (has_Inf (finset (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_90942 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_90943 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_bot.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_90944 (h0 : functor.add_const (group (comm_group environment.implicit_infer_kind)) environment.implicit_infer_kind) : @group.fg.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_90945 (h0 : ring (has_nnnorm (has_nnnorm string_imp))) : rank_condition (has_nnnorm (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_90946 (h0 : topological_space (non_assoc_semiring num)) : locally_compact_space (non_assoc_semiring num) := sorry --non-trivial
lemma new_lemma_90947 (h0 : functor.add_const (ring (has_zero unsigned)) Type) : @rank_condition.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 1} (ring.{0} (has_zero.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_90948 (h0 : functor.add_const (uniform_space (ordered_comm_monoid pos)) pos) : @separated_space.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_comm_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_90949 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (as_linear_order unsigned)) := sorry --non-trivial
lemma new_lemma_90950 (h0 : group (has_inv linarith.ineq)) : normalizer_condition (has_inv linarith.ineq) := sorry --non-trivial
lemma new_lemma_90951 (h0 : uniform_space (semiring (has_top (semiring (semiring empty))))) : separated_space (semiring (has_top (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_90952 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (ring (ring linarith.comp))) : @t1_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (ring.{0} (ring.{0} linarith.comp)) h0) Type)  := sorry --non-trivial
lemma new_lemma_90953 (h0 : uniform_space (random_gen (has_lt reducibility_hints))) : complete_space (random_gen (has_lt reducibility_hints)) := sorry --non-trivial
lemma new_lemma_90954 (h0 : function.extfun Type topological_space) : @t0_space.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_90955 (h0 : topological_space (has_pos_part (has_neg Type))) : path_connected_space (has_pos_part (has_neg Type)) := sorry --non-trivial
lemma new_lemma_90956 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_90957 (h0 : topological_space (has_bot (has_Inf linarith.comp))) : discrete_topology (has_bot (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_90958 (h0 : topological_space (comm_ring (random_gen (random_gen fun_info)))) : path_connected_space (comm_ring (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_90959 (h0 : functor.add_const (topological_space pos) (ordered_comm_group Type)) : @normal_space.{0} pos (@functor.add_const.run.{0 1} (topological_space.{0} pos) (ordered_comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_90960 (h0 : has_mem.mem (has_emptyc linarith.comp_source) has_emptyc.emptyc) : @path_connected_space.{0} (has_emptyc.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_90961 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_principal_ideal_ring.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_90962 (h0 h1 : pnat) (h2 : list pnat) : pnat.coprime h0 (list.ilast' h1 h2) := sorry --non-trivial
lemma new_lemma_90963 (h0 : ring (has_to_string (ring Type))) : rank_condition (has_to_string (ring Type)) := sorry --non-trivial
lemma new_lemma_90964 (h0 : topological_space (add_cancel_monoid (finset (finset linarith.comp)))) : loc_path_connected_space (add_cancel_monoid (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_90965 (h1 : add_group (uniform_space reducibility_hints)) : is_add_cyclic (uniform_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_90966 (h0 : ordered_add_comm_monoid (ring (finset linarith.comp))) : archimedean (ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_90967 (h4 : topological_space enat) (h5 : preorder enat) : order_topology enat := sorry --non-trivial
lemma new_lemma_90968 (h0 : topological_space (linear_ordered_add_comm_group (random_gen to_additive.value_type))) : irreducible_space (linear_ordered_add_comm_group (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_90969 (h0 : ordered_comm_monoid (has_add (add_cancel_monoid name))) : has_exists_mul_of_le (has_add (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_90970 (h0 : fin has_zero.zero) : @is_simple_group.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (group.{1} (canonically_linear_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_90971 (h3 : not (ring (with_one num) -> false)) : @strong_rank_condition.{0} (with_one.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (with_one.{0} num)) h3)  := sorry --non-trivial
lemma new_lemma_90972 (h0 : functor.add_const (topological_space (comm_group pos)) name) : @normal_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_90973 (h0 : set (has_div string.iterator_imp)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_90974 (h0 : topological_space (has_one (has_norm fun_info))) : normal_space (has_one (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_90975 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (omega_complete_partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (omega_complete_partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_90976 (h0 : add_group (has_lt (mul_one_class (mul_one_class enat)))) : is_add_cyclic (has_lt (mul_one_class (mul_one_class enat))) := sorry --non-trivial
lemma new_lemma_90977 (h0 : topological_space (comm_semigroup (sub_neg_monoid (has_bot (sub_neg_monoid linarith.comp))))) : preconnected_space (comm_semigroup (sub_neg_monoid (has_bot (sub_neg_monoid linarith.comp)))) := sorry --non-trivial
lemma new_lemma_90978 (h0 : comm_group name -> comm_group name -> Prop) : irreflexive h0 := sorry --non-trivial
lemma new_lemma_90979 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (boolean_algebra real)) := sorry --non-trivial
lemma new_lemma_90980 (h0 : functor.add_const (ring (has_zero Type)) pos) : @strong_rank_condition.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_zero.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_90981 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (canonically_ordered_comm_semiring pos)) := sorry --non-trivial
lemma new_lemma_90982 (h0 : functor.add_const (list (has_add name)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_90983 (h0 : function.extfun Type ring) : @rank_condition.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_90984 (h0 : preorder (distrib_lattice char)) (h1 : set (distrib_lattice char)) : bdd_above h1 := sorry --non-trivial
lemma new_lemma_90985 (h0 : functor.add_const (filter (has_zero name)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_90986 (h0 : functor.add_const (finset (has_zero environment.implicit_infer_kind)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_90987 (h1 : ring (random_gen (has_compl (mul_one_class string_imp)))) : strong_rank_condition (random_gen (has_compl (mul_one_class string_imp))) := sorry --non-trivial
lemma new_lemma_90988 (h1 : filter (distrib_lattice char)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_90989 (h0 : add_monoid (canonically_ordered_comm_semiring (has_add name))) : add_monoid.fg (canonically_ordered_comm_semiring (has_add name)) := sorry --non-trivial
lemma new_lemma_90990 (h0 : not (topological_space (distrib reducibility_hints) -> false)) : @totally_disconnected_space.{0} (distrib.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_90991 (h0 : functor.add_const (ring (option name)) pos) : @is_domain.{0} (option.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (option.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_90992 (h2 : ring (encodable string_imp)) : rank_condition (encodable string_imp) := sorry --non-trivial
lemma new_lemma_90993 (h0 : ring (mul_one_class (mul_one_class ereal))) : is_domain (mul_one_class (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_90994 (h0 : functor.add_const (finset (comm_semigroup name)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_90995 (h0 : functor.comp topological_space comm_group Type) : @locally_compact_space.{1} (comm_group.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} comm_group.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_90996 (h0 : complete_lattice (has_Sup empty)) : complete_lattice.is_Sup_finite_compact (has_Sup empty) := sorry --non-trivial
lemma new_lemma_90997 (h0 : uniform_space (has_top (semiring fun_info))) : separated_space (has_top (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_90998 (h0 : functor.add_const (complete_lattice (add_right_cancel_monoid unsigned)) (option unsigned)) : @complete_lattice.is_Sup_finite_compact.{0} (add_right_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_right_cancel_monoid.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_90999 (h0 : function.extfun (Type -> Type) (function.extfun Type)) (h1 : to_additive.value_type -> Prop) : @filter.limsup.{0 0} Prop to_additive.value_type (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice) (@function.extfun_app.{2 1} Type filter.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 filter.{0}) to_additive.value_type) h1  := sorry --non-trivial
lemma new_lemma_91000 (h0 : topological_space (simple_graph (has_ssubset reducibility_hints))) : t0_space (simple_graph (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_91001 (h0 : functor.add_const (add_group (has_to_string environment.implicit_infer_kind)) Type) : @is_add_cyclic.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (add_group.{0} (has_to_string.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_91002 (h0 : functor.add_const (topological_space (monoid_with_zero pos)) (has_nndist pos)) : @sequential_space.{0} (monoid_with_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid_with_zero.{0} pos)) (has_nndist.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_91003 (h0 : functor.comp topological_space has_to_string unsigned) : @discrete_topology.{0} (has_to_string.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_91004 (h0 : functor.add_const (function.extfun Type complete_lattice) (has_add pos)) : @is_compactly_generated.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) (has_add.{0} pos) h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_91005 (h0 : function.extfun (Type 1) topological_space) : @sequential_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_91006 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (complete_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_91007 (h0 : not (ring (mul_one_class string_imp) -> false)) : @strong_rank_condition.{0} (mul_one_class.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (mul_one_class.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_91008 (h0 : set (prod (has_Inf (has_pos_part (has_pos_part pos))) (has_Inf (has_pos_part (has_pos_part pos))))) (h1 : prod (has_Inf (has_pos_part (has_pos_part pos))) (has_Inf (has_pos_part (has_pos_part pos)))) : symmetrize_rel h0 h1 := sorry --non-trivial
lemma new_lemma_91009 (h0 : function.extfun Type (functor.comp topological_space comm_group)) : @preirreducible_space.{0} (comm_group.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} comm_group.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_91010 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_separated_space.{0} linarith.ineq (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) linarith.ineq)  := sorry --non-trivial
lemma new_lemma_91011 (h0 : function.extfun Type (functor.add_const (topological_space (omega_complete_partial_order unsigned)))) : @normal_space.{0} (omega_complete_partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (omega_complete_partial_order.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (omega_complete_partial_order.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_91012 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @regular_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_91013 (h0 : topological_space (boolean_algebra (ring linarith.comp))) : t1_space (boolean_algebra (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_91014 (h0 : topological_space (semiring congr_arg_kind)) : t0_space (semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_91015 (h0 : complete_lattice (complete_distrib_lattice ennreal)) : is_compactly_generated (complete_distrib_lattice ennreal) := sorry --non-trivial
lemma new_lemma_91016 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) Type) : @totally_separated_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_91017 (h0 : complete_lattice (has_nnnorm (has_nnnorm to_additive.value_type))) : is_compactly_generated (has_nnnorm (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_91018 (h0 : functor.add_const (filter (cancel_monoid unsigned)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_91019 (h0 : preorder congr_arg_kind) (h1 : monoid (omega_complete_partial_order.chain congr_arg_kind)) : monoid.fg (omega_complete_partial_order.chain congr_arg_kind) := sorry --non-trivial
lemma new_lemma_91020 (h0 : topological_space (id linarith.comp_source)) : path_connected_space (id linarith.comp_source) := sorry --non-trivial
lemma new_lemma_91021 (h0 : set (prod linarith.comp linarith.comp)) (h1 : function.extfun Type (prod linarith.comp)) : symmetrize_rel h0 (function.extfun_app h1 linarith.comp) := sorry --non-trivial
lemma new_lemma_91022 (h0 : not (group (has_top linarith.ineq) -> false)) : @group.fg.{0} (has_top.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (has_top.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_91023 (h0 : complete_lattice (boolean_algebra.core congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (boolean_algebra.core congr_arg_kind) := sorry --non-trivial
lemma new_lemma_91024 (h0 : monoid (metric_space (semiring linarith.comp))) : monoid.fg (metric_space (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_91025 (h0 : functor.add_const (group (pseudo_metric_space pos)) (mul_zero_class ennreal)) : @is_simple_group.{0} (pseudo_metric_space.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (pseudo_metric_space.{0} pos)) (mul_zero_class.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_91026 (h0 : not (complete_lattice (semi_normed_comm_ring to_additive.value_type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (semi_normed_comm_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semi_normed_comm_ring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_91027 (h0 : topological_space (ring (normed_comm_ring (has_Inf linarith.comp)))) : totally_disconnected_space (ring (normed_comm_ring (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_91028 (h0 : function.extfun Type group) : @normalizer_condition.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_91029 (h0 : functor.add_const (cancel_comm_monoid_with_zero (left_cancel_monoid num)) unsigned) : @unique_factorization_monoid.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (left_cancel_monoid.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_91030 (h0 : complete_lattice (random_gen (random_gen (random_gen (random_gen linarith.ineq))))) : is_compactly_generated (random_gen (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_91031 (h0 : uniform_space (has_compl environment.projection_info)) : complete_space (has_compl environment.projection_info) := sorry --non-trivial
lemma new_lemma_91032 (h0 : topological_space (semigroup (has_Inf linarith.comp))) : preirreducible_space (semigroup (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_91033 (h0 : functor.add_const (finset (mul_zero_class unsigned)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_91034 (h0 : functor.add_const (complete_lattice (has_neg Type)) name) : @complete_lattice.is_Sup_finite_compact.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_neg.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_91035 (h0 : has_lt (has_div (mul_one_class (mul_one_class (mul_one_class (mul_one_class enat)))))) : no_max_order (has_div (mul_one_class (mul_one_class (mul_one_class (mul_one_class enat))))) := sorry --non-trivial
lemma new_lemma_91036 (h0 : ring (cancel_monoid num)) : is_principal_ideal_ring (cancel_monoid num) := sorry --non-trivial
lemma new_lemma_91037 (h0 : add_group (boolean_algebra (has_neg_part name))) : is_add_cyclic (boolean_algebra (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_91038 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_91039 (h0 : nat) (h1 : add_group (fin h0)) : is_add_cyclic (fin h0) := sorry --non-trivial
lemma new_lemma_91040 (h0 : filter (add_cancel_monoid (finset (has_pos_part Type)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_91041 (h1 : topological_space (div_inv_monoid fun_info)) : t0_space (div_inv_monoid fun_info) := sorry --non-trivial
lemma new_lemma_91042 (h0 : functor.add_const (add_group (comm_monoid empty)) num) : @is_add_cyclic.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (comm_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_91043 (h0 : not (group (has_add char) -> false)) : @is_cyclic.{0} (has_add.{0} char) (@classical.by_contradiction'.{1} (group.{0} (has_add.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_91044 (h0 : semiring (add_group (add_group unsigned))) : is_noetherian_ring (add_group (add_group unsigned)) := sorry --non-trivial
lemma new_lemma_91045 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_91046 (h0 : function.extfun Type topological_space) : @t0_space.{0} (simple_graph.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_91047 (h0 : topological_space (with_one linarith.ineq)) : locally_compact_space (with_one linarith.ineq) := sorry --non-trivial
lemma new_lemma_91048 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) complete_lattice.{0}) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_91049 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (semigroup.{0} unsigned))) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.add_const.{0 0} (complete_lattice.{0} (semigroup.{0} unsigned)))) empty))  := sorry --non-trivial
lemma new_lemma_91050 (h0 : complete_lattice (has_neg_part (add_comm_monoid environment.implicit_infer_kind))) : is_compactly_generated (has_neg_part (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_91051 (h0 : topological_space (random_gen (has_norm linarith.comp_source))) : totally_separated_space (random_gen (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_91052 (h0 : topological_space (add_semigroup unsigned)) : discrete_topology (add_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_91053 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_91054 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_91055 (h0 : topological_space (has_nndist (boolean_algebra.core name))) : regular_space (has_nndist (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_91056 (h0 : filter (has_nndist (option num))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_91057 (h0 : filter (finset (option (option (option congr_arg_kind))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_91058 (h0 : not (ring (has_ssubset char) -> false)) : @is_domain.{0} (has_ssubset.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_91059 (h0 : topological_space (simple_graph (has_nndist Type))) : totally_separated_space (simple_graph (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_91060 (h0 : functor.add_const (add_monoid (has_to_string linarith.comp)) pos) : @add_monoid.fg.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_to_string.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_91061 (h0 : functor.add_const (function.extfun (Type 1) ring) name) : @is_domain.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) name h0) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_91062 (h0 : set (mul_one_class environment.projection_info)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_91063 (h0 : functor.add_const (topological_space (semigroup unsigned)) num) : @totally_disconnected_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_91064 (h0 : topological_space (canonically_ordered_comm_semiring (boolean_algebra pos))) : preconnected_space (canonically_ordered_comm_semiring (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_91065 (h0 : functor.add_const (add_group (bin_tree empty)) congr_arg_kind) : @is_add_cyclic.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (bin_tree.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_91066 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_91067 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_91068 (h0 : finset (has_neg_part name)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_91069 (h0 : ring (linear_ordered_add_comm_group fun_info)) : is_domain (linear_ordered_add_comm_group fun_info) := sorry --non-trivial
lemma new_lemma_91070 (h0 : uniform_space (generalized_boolean_algebra (has_pos_part (ring pos)))) : complete_space (generalized_boolean_algebra (has_pos_part (ring pos))) := sorry --non-trivial
lemma new_lemma_91071 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_91072 (h0 : functor.add_const (group (add_group unsigned)) empty) : @normalizer_condition.{0} (add_group.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (add_group.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_91073 (h0 : topological_space (comm_monoid empty)) : topological_space.separable_space (comm_monoid empty) := sorry --non-trivial
lemma new_lemma_91074 (h0 : ring (ring name)) : strong_rank_condition (ring name) := sorry --non-trivial
lemma new_lemma_91075 (h0 : group (has_top (semiring num))) : is_cyclic (has_top (semiring num)) := sorry --non-trivial
lemma new_lemma_91076 (h1 : topological_space (encodable char)) : path_connected_space (encodable char) := sorry --non-trivial
lemma new_lemma_91077 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_91078 (h0 : ring (has_to_string (ring Type))) : is_principal_ideal_ring (has_to_string (ring Type)) := sorry --non-trivial
lemma new_lemma_91079 (h0 : complete_lattice (normed_comm_ring (has_add linarith.comp))) : is_compactly_generated (normed_comm_ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_91080 (h0 : ring (has_bot real)) : is_domain (has_bot real) := sorry --non-trivial
lemma new_lemma_91081 (h0 : group (denumerable (comm_ring (has_append reducibility_hints)))) : is_cyclic (denumerable (comm_ring (has_append reducibility_hints))) := sorry --non-trivial
lemma new_lemma_91082 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ordered_cancel_add_comm_monoid unsigned)) (option num)) : @unique_factorization_monoid.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ordered_cancel_add_comm_monoid.{0} unsigned)) (option.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_91083 (h1 : has_mem.mem (has_norm linarith.comp) has_emptyc.emptyc) : @is_domain.{0} (has_norm.{0} linarith.comp) (@finset.pi.empty.{1 0} Type ring.{0} (has_norm.{0} linarith.comp) h1)  := sorry --non-trivial
lemma new_lemma_91084 (h0 : topological_space (boolean_algebra (ordered_comm_monoid Type))) : preconnected_space (boolean_algebra (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_91085 (h0 : functor.add_const (ring (add_comm_monoid name)) linarith.comp) : @strong_rank_condition.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_91086 (h0 : ring (has_lt environment.projection_info)) : strong_rank_condition (has_lt environment.projection_info) := sorry --non-trivial
lemma new_lemma_91087 (h0 : functor.add_const (ring (has_add Type)) pos) : @is_principal_ideal_ring.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_add.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_91088 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_91089 (h0 : set (std_gen -> add_comm_semigroup linarith.ineq)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_91090 (h0 : monoid (with_bot congr_arg_kind)) : monoid.fg (with_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_91091 (h0 : topological_space (with_bot (random_gen (random_gen linarith.comp_source)))) : totally_separated_space (with_bot (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_91092 (h2 : ring (add_comm_semigroup fun_info)) : strong_rank_condition (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_91093 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (measurable_space.dynkin_system.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (measurable_space.dynkin_system.{0} empty))  := sorry --non-trivial
lemma new_lemma_91094 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_91095 (h0 : topological_space (denumerable fun_info)) : totally_separated_space (denumerable fun_info) := sorry --non-trivial
lemma new_lemma_91096 (h0 : has_mem.mem (with_bot (has_norm empty)) has_emptyc.emptyc) : @strong_rank_condition.{0} (with_bot.{0} (has_norm.{0} empty)) (@finset.pi.empty.{1 0} Type ring.{0} (with_bot.{0} (has_norm.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_91097 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} auto.case_option (@functor.add_const.run.{0 0} (add_monoid.{0} auto.case_option) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_monoid.{0} auto.case_option)) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.add_const.{0 0} (add_monoid.{0} auto.case_option))) unsigned))  := sorry --non-trivial
lemma new_lemma_91098 (h0 : semiring (linear_ordered_field (option pos))) : is_noetherian_ring (linear_ordered_field (option pos)) := sorry --non-trivial
lemma new_lemma_91099 (h0 : filter (ordered_comm_ring (has_Inf (ring Type)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_91100 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (complete_distrib_lattice.{0} num) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (complete_distrib_lattice.{0} num))  := sorry --non-trivial
lemma new_lemma_91101 (h0 : has_lift (mul_one_class string.iterator_imp) Prop) (h1 : mul_one_class string.iterator_imp) : @lift.{1 1} (mul_one_class.{0} string.iterator_imp) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_91102 (h0 : topological_space (has_pos_part (has_Inf pos))) : preirreducible_space (has_pos_part (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_91103 (h0 : functor.add_const (group (has_neg_part environment.implicit_infer_kind)) name) : @group.fg.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_neg_part.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_91104 (h0 : has_mem.mem (with_bot empty) has_emptyc.emptyc) : @locally_compact_space.{0} (with_bot.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_91105 (h0 : topological_space (with_bot (random_gen linarith.comp_source))) : locally_compact_space (with_bot (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_91106 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preconnected_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_91107 (h0 : functor.add_const (topological_space (ordered_ring congr_arg_kind)) unsigned) : @t0_space.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_91108 (h0 : ring (nondiscrete_normed_field string.iterator_imp)) : rank_condition (nondiscrete_normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_91109 (h0 : topological_space (has_nnnorm char)) : t0_space (has_nnnorm char) := sorry --non-trivial
lemma new_lemma_91110 (h0 : functor.add_const (uniform_space (ordered_comm_ring linarith.comp)) linarith.comp) : @separated_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_91111 (h0 : complete_lattice (denumerable (random_gen linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (denumerable (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_91112 (h0 : semiring (semigroup (option pos))) : is_noetherian_ring (semigroup (option pos)) := sorry --non-trivial
lemma new_lemma_91113 (h0 : fin has_zero.zero) : @sequential_space.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_91114 (h0 : add_group (uniform_space (uniform_space linarith.ineq))) : is_add_cyclic (uniform_space (uniform_space linarith.ineq)) := sorry --non-trivial
lemma new_lemma_91115 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : archimedean ennreal := sorry --non-trivial
lemma new_lemma_91116 (h0 : ring (id (has_norm unsigned))) : rank_condition (id (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_91117 (h1 : complete_lattice (comm_ring linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_91118 (h0 : has_le linarith.ineq) (h4 : linarith.ineq) : is_bot h4 := sorry --non-trivial
lemma new_lemma_91119 (h0 : functor.add_const (finset (add_right_cancel_monoid empty)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_91120 (h0 : functor.add_const (function.extfun Type filter) pos) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) (has_to_string name)) := sorry --non-trivial
lemma new_lemma_91121 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_91122 (h0 : add_group (has_add num)) : is_add_cyclic (has_add num) := sorry --non-trivial
lemma new_lemma_91123 (h0 : topological_space (boolean_algebra (has_Inf (has_Inf name)))) : preconnected_space (boolean_algebra (has_Inf (has_Inf name))) := sorry --non-trivial
lemma new_lemma_91124 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) (has_pos_part linarith.comp)) : @discrete_topology.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) (has_pos_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_91125 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @normalizer_condition.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_91126 (h0 : not (function.extfun Type topological_space -> false)) : irreducible_space complex := sorry --non-trivial
lemma new_lemma_91127 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_91128 (h0 : measurable_space (has_div char)) (h1 : set (has_div char)) : measurable_set h1 := sorry --non-trivial
lemma new_lemma_91129 (h0 : topological_space (non_assoc_semiring (semiring (semiring (has_norm congr_arg_kind))))) : discrete_topology (non_assoc_semiring (semiring (semiring (has_norm congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_91130 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) linarith.comp) : @locally_compact_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_91131 (h0 : functor.add_const (topological_space (semigroup Type)) environment.implicit_infer_kind) : @preirreducible_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_91132 (h0 : fin has_zero.zero) : @regular_space.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_91133 (h0 : functor.add_const (topological_space environment.implicit_infer_kind) pos) : @topological_space.separable_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (topological_space.{0} environment.implicit_infer_kind) pos h0)  := sorry --non-trivial
lemma new_lemma_91134 (h0 : function.extfun Type (functor.comp topological_space semigroup)) : @discrete_topology.{0} (semigroup.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} semigroup.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_91135 (h0 : functor.add_const (topological_space (has_Inf name)) pos) : @totally_disconnected_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_91136 (h0 : topological_space (mul_zero_class ennreal)) : t1_space (mul_zero_class ennreal) := sorry --non-trivial
lemma new_lemma_91137 (h0 : not (topological_space (has_div char) -> false)) : @path_connected_space.{0} (has_div.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (has_div.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_91138 (h0 : topological_space (denumerable (random_gen string_imp))) : locally_compact_space (denumerable (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_91139 (h0 : topological_space (has_star (semiring (semiring unsigned)))) : path_connected_space (has_star (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_91140 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) Type) : @archimedean.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) Type h0) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_91141 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (omega_complete_partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (omega_complete_partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_91142 (h0 : functor.add_const (ring (has_edist num)) (option empty)) : @is_domain.{0} (has_edist.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (has_edist.{0} num)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_91143 (h0 : ordered_comm_monoid (sub_neg_monoid Type)) : has_exists_mul_of_le (sub_neg_monoid Type) := sorry --non-trivial
lemma new_lemma_91144 (h0 : functor.add_const (list (sub_neg_monoid congr_arg_kind)) (option unsigned)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_91145 (h0 : filter (add_comm_monoid ennreal)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_91146 (h0 : ordered_comm_monoid Type) : has_exists_mul_of_le Type := sorry --non-trivial
lemma new_lemma_91147 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (measurable_space.{0} string_imp) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (measurable_space.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_91148 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) pos) : @totally_separated_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_91149 (h0 : functor.add_const (topological_space (has_neg pos)) Type) : @loc_path_connected_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_91150 (h0 : complete_lattice (normed_group (random_gen (random_gen linarith.ineq)))) : complete_lattice.is_Sup_finite_compact (normed_group (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_91151 (h0 : topological_space (ordered_comm_monoid (has_Inf pos))) : preconnected_space (ordered_comm_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_91152 (h0 : ring (complete_semilattice_Sup (random_gen (semiring (has_emptyc num))))) : rank_condition (complete_semilattice_Sup (random_gen (semiring (has_emptyc num)))) := sorry --non-trivial
lemma new_lemma_91153 (h1 : topological_space (linear_ordered_add_comm_group char)) : t0_space (linear_ordered_add_comm_group char) := sorry --non-trivial
lemma new_lemma_91154 (h0 : topological_space (has_nndist congr_arg_kind)) : preirreducible_space (has_nndist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_91155 (h1 : has_neg (nondiscrete_normed_field (normed_field reducibility_hints))) (h2 : measurable_space (nondiscrete_normed_field (normed_field reducibility_hints))) : has_measurable_neg (nondiscrete_normed_field (normed_field reducibility_hints)) := sorry --non-trivial
lemma new_lemma_91156 (h0 : topological_space (random_gen (semiring empty))) : totally_separated_space (random_gen (semiring empty)) := sorry --non-trivial
lemma new_lemma_91157 (h1 : filter (with_zero (has_inv (has_inv linarith.ineq)))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_91158 (h0 : group (complete_distrib_lattice (finset (boolean_algebra.core environment.implicit_infer_kind)))) : is_cyclic (complete_distrib_lattice (finset (boolean_algebra.core environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_91159 (h0 : topological_space (has_one (has_norm (semiring num)))) : discrete_topology (has_one (has_norm (semiring num))) := sorry --non-trivial
lemma new_lemma_91160 (h0 : functor.add_const (group (cancel_monoid Type)) unsigned) : @group.fg.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (cancel_monoid.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_91161 (h0 : uniform_space (has_Inf (has_Inf (has_Inf (has_pos_part (has_Inf (finset pos))))))) : separated_space (has_Inf (has_Inf (has_Inf (has_pos_part (has_Inf (finset pos)))))) := sorry --non-trivial
lemma new_lemma_91162 (h0 : complete_lattice (option unsigned)) : is_atomistic (option unsigned) := sorry --non-trivial
lemma new_lemma_91163 (h0 : complete_lattice (has_compl (has_nnnorm (random_gen fun_info)))) : is_compactly_generated (has_compl (has_nnnorm (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_91164 (h0 : functor.add_const (semiring (boolean_algebra.core linarith.comp)) pos) : @is_noetherian_ring.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (boolean_algebra.core.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_91165 (h0 : functor.add_const (topological_space (comm_group name)) name) : @preirreducible_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_91166 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg (finset (has_neg linarith.comp)))) : @topological_space.separable_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{0} (finset.{0} (has_neg.{0} linarith.comp))) h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_91167 (h0 : functor.add_const (list (comm_group pos)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_91168 (h0 : complete_lattice (complete_semilattice_Sup (random_gen char))) : is_compactly_generated (complete_semilattice_Sup (random_gen char)) := sorry --non-trivial
lemma new_lemma_91169 (h0 : not (complete_lattice (semi_normed_ring string.iterator_imp) -> false)) : @is_compactly_generated.{0} (semi_normed_ring.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semi_normed_ring.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_91170 (h0 : monoid (has_add (ring Type))) : monoid.fg (has_add (ring Type)) := sorry --non-trivial
lemma new_lemma_91171 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_91172 (h0 : fin has_zero.zero) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@matrix.vec_empty.{0} (filter.{0} Prop) (@id.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_91173 (h0 : add_monoid (comm_semigroup (has_Inf pos))) : add_monoid.fg (comm_semigroup (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_91174 (h0 : list (with_one (random_gen (random_gen (random_gen string_imp))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_91175 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} name (@function.extfun_app.{2 1} Type topological_space.{0} h0 name)  := sorry --non-trivial
lemma new_lemma_91176 (h0 : pnat) (h1 : fin has_zero.zero) : pnat.coprime h0 (ulower.up (matrix.vec_empty h1)) := sorry --non-trivial
lemma new_lemma_91177 (h0 : not (topological_space (semi_normed_ring reducibility_hints) -> false)) : @totally_disconnected_space.{0} (semi_normed_ring.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_ring.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_91178 (h0 : topological_space (boolean_algebra (has_Inf linarith.comp))) : path_connected_space (boolean_algebra (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_91179 (h0 : topological_space (add_cancel_monoid (has_add (has_add (has_add (has_add (finset linarith.comp))))))) : t0_space (add_cancel_monoid (has_add (has_add (has_add (has_add (finset linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_91180 (h0 : functor.add_const (complete_lattice (cancel_monoid pos)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_91181 (h0 : finset (add_cancel_comm_monoid (semiring empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_91182 (h0 : topological_space (measurable_space (random_gen to_additive.value_type))) : path_connected_space (measurable_space (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_91183 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @separated_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (canonically_ordered_comm_semiring.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_91184 (h0 : functor.add_const (complete_lattice (preorder num)) num) : @is_compactly_generated.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (preorder.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_91185 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_bot.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_91186 (h0 : topological_space (has_to_string (has_neg linarith.comp))) : totally_separated_space (has_to_string (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_91187 (h0 : topological_space (normed_field (metric_space (metric_space (metric_space to_additive.value_type))))) : t0_space (normed_field (metric_space (metric_space (metric_space to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_91188 (h0 : ring (has_append (has_nnnorm reducibility_hints))) : rank_condition (has_append (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_91189 (h0 : functor.add_const (ordered_comm_monoid (cancel_monoid unsigned)) linarith.comp) : @has_exists_mul_of_le.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (cancel_monoid.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_91190 (h1 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @discrete_topology.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h1 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_91191 (h0 : topological_space (mul_zero_class (has_add ennreal))) : totally_separated_space (mul_zero_class (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_91192 (h0 : functor.add_const (topological_space (complete_linear_order num)) num) : @t0_space.{0} (complete_linear_order.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_linear_order.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_91193 (h0 : ring (non_unital_non_assoc_semiring linarith.ineq)) : is_domain (non_unital_non_assoc_semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_91194 (h2 : set (enat -> string.iterator_imp)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_91195 (h0 : topological_space (plift empty)) : discrete_topology (plift empty) := sorry --non-trivial
lemma new_lemma_91196 (h0 : monoid (ordered_comm_ring (has_neg name))) : monoid.fg (ordered_comm_ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_91197 (h0 : monoid (boolean_algebra (has_add (normed_comm_ring (has_Inf (has_Inf pos)))))) : monoid.fg (boolean_algebra (has_add (normed_comm_ring (has_Inf (has_Inf pos))))) := sorry --non-trivial
lemma new_lemma_91198 (h0 : has_lt environment.implicit_infer_kind) : no_max_order environment.implicit_infer_kind := sorry --non-trivial
lemma new_lemma_91199 (h0 : function.extfun (Type 1) topological_space) : @sequential_space.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_91200 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_91201 (h0 : functor.add_const (topological_space (complete_distrib_lattice unsigned)) unsigned) : @discrete_topology.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_91202 (h0 : semiring (with_one (has_norm (has_norm (has_union (semiring (has_norm empty))))))) : is_noetherian_ring (with_one (has_norm (has_norm (has_union (semiring (has_norm empty)))))) := sorry --non-trivial
lemma new_lemma_91203 (h0 : has_mem.mem unsigned has_emptyc.emptyc) : @strong_rank_condition.{0} unsigned (@finset.pi.empty.{1 0} Type ring.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_91204 (h0 : not (ring (add_left_cancel_monoid linarith.comp_source) -> false)) : @rank_condition.{0} (add_left_cancel_monoid.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (add_left_cancel_monoid.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_91205 (h0 : boolean_algebra.core unsigned -> boolean_algebra.core unsigned -> Prop) : is_symm (boolean_algebra.core unsigned) h0 := sorry --non-trivial
lemma new_lemma_91206 (h0 : topological_space (normed_lattice_add_comm_group (has_neg (has_bot real)))) : sequential_space (normed_lattice_add_comm_group (has_neg (has_bot real))) := sorry --non-trivial
lemma new_lemma_91207 (h0 : functor.add_const (ring (add_cancel_monoid Type)) name) : @is_principal_ideal_ring.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (add_cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_91208 (h0 : ring (normed_lattice_add_comm_group (sub_neg_monoid (has_bot (has_Inf (has_add Type)))))) : rank_condition (normed_lattice_add_comm_group (sub_neg_monoid (has_bot (has_Inf (has_add Type))))) := sorry --non-trivial
lemma new_lemma_91209 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) linarith.comp)  := sorry --non-trivial
lemma new_lemma_91210 (h0 : functor.add_const (function.extfun Type group) Type) : @normalizer_condition.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_91211 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_91212 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_91213 (h0 : ring (finset (add_comm_monoid Type))) : is_principal_ideal_ring (finset (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_91214 (h0 : topological_space (has_emptyc (has_norm linarith.comp_source))) : totally_disconnected_space (has_emptyc (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_91215 (h0 : topological_space (cancel_monoid (has_add ennreal))) : totally_separated_space (cancel_monoid (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_91216 (h0 : function.extfun Type group) : @normalizer_condition.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_91217 (h0 : ring (cancel_monoid (has_add (boolean_algebra.core (has_add Type))))) : is_principal_ideal_ring (cancel_monoid (has_add (boolean_algebra.core (has_add Type)))) := sorry --non-trivial
lemma new_lemma_91218 (h0 : pfun enat fun_info -> pfun enat fun_info -> Prop) : is_total (pfun enat fun_info) h0 := sorry --non-trivial
lemma new_lemma_91219 (h0 : list (linear_order (semiring unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_91220 (h0 : functor.add_const (topological_space (has_nndist name)) pos) : @sequential_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_91221 (h0 : finset (comm_group (option pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_91222 (h0 : function.extfun Type topological_space) : @t0_space.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_91223 (h0 h1 : not (multiset (random_gen (semigroup reducibility_hints)) -> false)) : multiset.disjoint (classical.by_contradiction' h0) (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_91224 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_91225 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_91226 (h0 : ring (ring (finset environment.implicit_infer_kind))) : rank_condition (ring (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_91227 (h0 : add_monoid (linear_ordered_add_comm_monoid_with_top pos)) : add_monoid.fg (linear_ordered_add_comm_monoid_with_top pos) := sorry --non-trivial
lemma new_lemma_91228 (h0 : list (free_add_monoid (semiring (semiring (semiring (semiring (semiring (semiring (semiring unsigned))))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_91229 (h0 : ring (uniform_space string_imp)) : is_domain (uniform_space string_imp) := sorry --non-trivial
lemma new_lemma_91230 (h0 : add_group (semi_normed_comm_ring (random_gen linarith.ineq))) : is_add_cyclic (semi_normed_comm_ring (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_91231 (h0 : not (has_mem.mem (with_bot linarith.comp) has_emptyc.emptyc -> false)) : @is_domain.{0} (with_bot.{0} linarith.comp) (@finset.pi.empty.{1 0} Type ring.{0} (with_bot.{0} linarith.comp) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} linarith.comp) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_91232 (h0 : not (monoid (id empty) -> false)) : @monoid.fg.{0} (@id.{2} Type empty) (@classical.by_contradiction'.{1} (monoid.{0} (@id.{2} Type empty)) h0)  := sorry --non-trivial
lemma new_lemma_91233 (h1 : uniform_space (with_one (has_nnnorm (has_nnnorm linarith.ineq)))) : complete_space (with_one (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_91234 (h0 : finset (linear_ordered_semiring unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_91235 (h0 : uniform_space (has_append (random_gen string_imp))) : complete_space (has_append (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_91236 (h0 : list (boolean_algebra.core (option unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_91237 (h0 : topological_space (generalized_boolean_algebra (has_Inf pos))) : totally_separated_space (generalized_boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_91238 (h0 : not (topological_space (distrib_lattice linarith.ineq) -> false)) : @totally_disconnected_space.{0} (distrib_lattice.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib_lattice.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_91239 (h0 : functor.add_const (ring znum) num) : @is_domain.{0} znum (@functor.add_const.run.{0 0} (ring.{0} znum) num h0)  := sorry --non-trivial
lemma new_lemma_91240 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_91241 (h0 : measurable_space fun_info) (h1 : has_inf fun_info) : has_measurable_inf fun_info := sorry --non-trivial
lemma new_lemma_91242 (h0 : functor.add_const (function.extfun (Type 1) cancel_comm_monoid_with_zero) linarith.comp) : @unique_factorization_monoid.{1} Type (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1}) linarith.comp h0) Type)  := sorry --non-trivial
lemma new_lemma_91243 (h1 : ring (linear_ordered_add_comm_group string_imp)) : is_domain (linear_ordered_add_comm_group string_imp) := sorry --non-trivial
lemma new_lemma_91244 (h0 : function.extfun (Type 1) add_monoid) : @add_monoid.fg.{1} Type (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} h0 Type)  := sorry --non-trivial
lemma new_lemma_91245 (h0 : add_monoid (has_nndist empty)) : add_monoid.fg (has_nndist empty) := sorry --non-trivial
lemma new_lemma_91246 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_atomistic.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_91247 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_nnnorm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_nnnorm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_91248 (h0 : add_group (distrib (has_ssubset linarith.comp_source))) : is_add_cyclic (distrib (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_91249 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) (finset linarith.comp)) : @preirreducible_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_91250 (h0 : add_group (add_cancel_monoid congr_arg_kind)) : is_add_cyclic (add_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_91251 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_91252 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (mul_zero_class.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (mul_zero_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_91253 (h0 : topological_space (semi_normed_comm_ring (has_norm (has_norm to_additive.value_type)))) : t0_space (semi_normed_comm_ring (has_norm (has_norm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_91254 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} string_imp (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 ring.{0}) string_imp)  := sorry --non-trivial
lemma new_lemma_91255 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_star unsigned)) := sorry --non-trivial
lemma new_lemma_91256 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preirreducible_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_91257 (h0 : functor.add_const (list (complete_distrib_lattice Type)) (has_add Type)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_91258 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_neg.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} num))  := sorry --non-trivial
lemma new_lemma_91259 (h0 : finset (canonically_linear_ordered_monoid Type)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_91260 (h3 : topological_space (add_comm_semigroup fun_info)) : topological_space.first_countable_topology (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_91261 (h0 : ring (has_compl (canonically_linear_ordered_monoid string_imp))) : strong_rank_condition (has_compl (canonically_linear_ordered_monoid string_imp)) := sorry --non-trivial
lemma new_lemma_91262 (h0 : topological_space (normed_comm_ring (option (option empty)))) : discrete_topology (normed_comm_ring (option (option empty))) := sorry --non-trivial
lemma new_lemma_91263 (h0 : uniform_space (cancel_monoid (option (option (option empty))))) : separated_space (cancel_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_91264 (h0 : monoid (complete_semilattice_Sup (semiring empty))) : monoid.fg (complete_semilattice_Sup (semiring empty)) := sorry --non-trivial
lemma new_lemma_91265 (h0 : cancel_comm_monoid_with_zero (add_cancel_monoid num)) : unique_factorization_monoid (add_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_91266 (h0 : topological_space (complete_distrib_lattice (has_Inf real))) : totally_disconnected_space (complete_distrib_lattice (has_Inf real)) := sorry --non-trivial
lemma new_lemma_91267 (h0 : functor.add_const (cancel_comm_monoid_with_zero (normed_comm_ring name)) environment.implicit_infer_kind) : @unique_factorization_monoid.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (normed_comm_ring.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_91268 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_one congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_91269 (h0 : add_monoid (boolean_algebra (has_pos_part linarith.comp))) : add_monoid.fg (boolean_algebra (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_91270 (h0 : char -> ereal -> order_hom nat Prop) (h1 : prod char ereal) : @monotonic_sequence_limit.{0} Prop (@complete_semilattice_Inf.to_partial_order.{0} Prop (@complete_lattice.to_complete_semilattice_Inf.{0} Prop Prop.complete_lattice)) (@function.uncurry.{0 0 0} char ereal (@order_hom.{0 0} nat Prop (@partial_order.to_preorder.{0} nat (@ordered_cancel_add_comm_monoid.to_partial_order.{0} nat (@ordered_semiring.to_ordered_cancel_add_comm_monoid.{0} nat nat.ordered_semiring))) (@partial_order.to_preorder.{0} Prop (@complete_semilattice_Inf.to_partial_order.{0} Prop (@complete_lattice.to_complete_semilattice_Inf.{0} Prop Prop.complete_lattice)))) h0 h1)  := sorry --non-trivial
lemma new_lemma_91271 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (mul_zero_class pos)) := sorry --non-trivial
lemma new_lemma_91272 (h0 : ring (has_top (has_norm (semiring congr_arg_kind)))) : is_domain (has_top (has_norm (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_91273 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_91274 (h0 : ulower (fin has_zero.zero)) (h1 : list (ulower (fin has_zero.zero))) (h2 : ulower pnat) : pnat.coprime (matrix.vec_empty (ulower.up (list.ilast' h0 h1))) (ulower.up h2) := sorry --non-trivial
lemma new_lemma_91275 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @sequential_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_91276 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_91277 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_91278 (h0 : functor.add_const (complete_lattice (free_add_monoid unsigned)) unsigned) : @is_compactly_generated.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (free_add_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_91279 (h0 : functor.add_const (topological_space (has_zero Type)) name) : @path_connected_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_91280 (h0 : not (fin has_zero.zero -> false)) : @complete_space.{0} name (@matrix.vec_empty.{0} (uniform_space.{0} name) (@classical.by_contradiction'.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_91281 (h0 : functor.add_const (cancel_comm_monoid_with_zero (comm_group pos)) name) : @unique_factorization_monoid.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (comm_group.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_91282 (h2 : topological_space (has_add (has_nnnorm to_additive.value_type))) : t0_space (has_add (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_91283 (h1 : ring string_imp -> ring string_imp -> Prop) (h2 : well_founded h1) (h3 : set (ring string_imp)) (h4 : set.bounded h1 h3) : @is_domain.{0} string_imp (@well_founded.sup.{0} (ring.{0} string_imp) h1 h2 h3 h4)  := sorry --non-trivial
lemma new_lemma_91284 (h0 : topological_space (add_comm_semigroup ereal)) : topological_space.first_countable_topology (add_comm_semigroup ereal) := sorry --non-trivial
lemma new_lemma_91285 (h0 : topological_space (normed_lattice_add_comm_group Type)) : sequential_space (normed_lattice_add_comm_group Type) := sorry --non-trivial
lemma new_lemma_91286 (h0 : group (ordered_cancel_add_comm_monoid pos)) : normalizer_condition (ordered_cancel_add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_91287 (h0 : functor.add_const (topological_space (boolean_algebra Type)) name) : @normal_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_91288 (h0 : complete_lattice (has_norm (comm_ring to_additive.value_type))) : is_compactly_generated (has_norm (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_91289 (h0 : complete_lattice (with_one (has_norm (has_top fun_info)))) : complete_lattice.is_Sup_finite_compact (with_one (has_norm (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_91290 (h0 : functor.add_const (topological_space (add_cancel_comm_monoid empty)) empty) : @discrete_topology.{0} (add_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_91291 (h0 : topological_space (semigroup (has_to_string (comm_group Type)))) : preirreducible_space (semigroup (has_to_string (comm_group Type))) := sorry --non-trivial
lemma new_lemma_91292 (h0 : topological_space (has_append (has_nnnorm (has_nnnorm string.iterator_imp)))) : totally_disconnected_space (has_append (has_nnnorm (has_nnnorm string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_91293 (h0 : group (group_with_zero (option ennreal))) : is_simple_group (group_with_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_91294 (h0 : functor.add_const (filter (comm_group unsigned)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_91295 (h0 : topological_space (has_neg (canonically_ordered_comm_semiring environment.implicit_infer_kind))) : preconnected_space (has_neg (canonically_ordered_comm_semiring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_91296 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_91297 (h0 : topological_space (comm_monoid (semiring empty))) : locally_compact_space (comm_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_91298 (h0 : monoid (boolean_algebra (has_add (has_add linarith.comp)))) : monoid.fg (boolean_algebra (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_91299 (h0 : monoid (linear_ordered_cancel_comm_monoid (has_edist unsigned))) : monoid.fg (linear_ordered_cancel_comm_monoid (has_edist unsigned)) := sorry --non-trivial
lemma new_lemma_91300 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_91301 (h0 : topological_space (has_bot (has_add (has_Inf Type)))) : topological_space.separable_space (has_bot (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_91302 (h0 : topological_space (has_top (has_top fun_info))) : totally_separated_space (has_top (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_91303 (h0 : monoid (mul_zero_class (boolean_algebra.core environment.implicit_infer_kind))) : monoid.fg (mul_zero_class (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_91304 (h0 : measurable_space (has_compl to_additive.value_type)) (h1 : filter (has_compl to_additive.value_type)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_91305 (h0 : functor.add_const (function.extfun Type group) pos) : @normalizer_condition.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_91306 (h1 : list (with_bot linarith.ineq)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_91307 (h0 : not (ring (fintype string_imp) -> false)) : @is_domain.{0} (fintype.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (fintype.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_91308 (h0 : function.extfun (finset Type) (has_mem.mem (with_one congr_arg_kind))) : @is_compactly_generated.{0} (with_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_91309 (h0 : topological_space (with_zero char)) : path_connected_space (with_zero char) := sorry --non-trivial
lemma new_lemma_91310 (h0 : ordered_comm_monoid (add_cancel_monoid linarith.comp)) : has_exists_mul_of_le (add_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_91311 (h0 : ring (has_norm (semiring linarith.comp))) : is_domain (has_norm (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_91312 (h0 : functor.add_const (topological_space (comm_monoid empty)) empty) : @loc_path_connected_space.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_91313 (h0 : topological_space (add_cancel_comm_monoid congr_arg_kind)) : discrete_topology (add_cancel_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_91314 (h0 : complete_lattice (has_neg_part (option (option pos)))) : is_compactly_generated (has_neg_part (option (option pos))) := sorry --non-trivial
lemma new_lemma_91315 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (bin_tree.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (bin_tree.{0} num))  := sorry --non-trivial
lemma new_lemma_91316 (h2 : ring (comm_ring fun_info)) : is_domain (comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_91317 (h0 : not (group (fintype fun_info) -> false)) : @group.fg.{0} (fintype.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (fintype.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_91318 (h0 : functor.add_const (function.extfun (Type 1) ring) (finset Type)) : @strong_rank_condition.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) (finset.{1} Type) h0) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_91319 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_91320 (h0 : function.extfun Type group) : @group.fg.{0} (linear_order.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_91321 (h0 : function.extfun Type (functor.add_const (list (semigroup unsigned)))) : list.nodup (functor.add_const.run (function.extfun_app h0 (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_91322 (h0 : complete_lattice (nondiscrete_normed_field linarith.ineq)) : complete_lattice.is_Sup_finite_compact (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_91323 (h1 : group (dlist (has_compl (has_inv linarith.ineq)))) : is_cyclic (dlist (has_compl (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_91324 (h0 : finset (has_edist (option (option (option (option empty)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_91325 (h0 : functor.add_const (topological_space (finset unsigned)) pos) : @t1_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_91326 (h1 : complete_lattice linarith.comp_source -> Prop) (h2 : Exists (fun (x : complete_lattice linarith.comp_source), h1 x)) : @complete_lattice.is_Sup_finite_compact.{0} linarith.comp_source (@classical.some.{1} (complete_lattice.{0} linarith.comp_source) h1 h2)  := sorry --non-trivial
lemma new_lemma_91327 (h0 : ring (has_neg_part (semigroup environment.implicit_infer_kind))) : is_domain (has_neg_part (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_91328 (h1 : add_group (mul_one_class string.iterator_imp)) (h2 : ring (simple_graph (add_subgroup (mul_one_class string.iterator_imp)))) : rank_condition (simple_graph (add_subgroup (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_91329 (h0 : uniform_space (sub_neg_monoid (has_Inf (has_Inf pos)))) : complete_space (sub_neg_monoid (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_91330 (h0 : function.extfun Type (functor.add_const (topological_space auto.case_option))) : @preirreducible_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} auto.case_option)) h0 num))  := sorry --non-trivial
lemma new_lemma_91331 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_91332 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preconnected_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_91333 (h0 : ring (ring (has_add Type))) : is_principal_ideal_ring (ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_91334 (h1 : add_group (has_append to_additive.value_type)) : is_add_cyclic (has_append to_additive.value_type) := sorry --non-trivial
lemma new_lemma_91335 (h0 : functor.add_const (uniform_space char) empty) : @complete_space.{0} char (@functor.add_const.run.{0 0} (uniform_space.{0} char) empty h0)  := sorry --non-trivial
lemma new_lemma_91336 (h0 : topological_space (mul_zero_class (has_neg ennreal))) : t1_space (mul_zero_class (has_neg ennreal)) := sorry --non-trivial
lemma new_lemma_91337 (h0 : complete_lattice (has_zero (option (mul_zero_class pos)))) : is_atomistic (has_zero (option (mul_zero_class pos))) := sorry --non-trivial
lemma new_lemma_91338 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_comm_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_91339 (h0 : ring (linear_ordered_semiring (add_group (semiring linarith.comp)))) : rank_condition (linear_ordered_semiring (add_group (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_91340 (h0 : function.extfun Type group) : @is_cyclic.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_91341 (h0 : add_monoid (complete_distrib_lattice (finset (finset name)))) : add_monoid.fg (complete_distrib_lattice (finset (finset name))) := sorry --non-trivial
lemma new_lemma_91342 (h0 : topological_space (distrib_lattice string_imp)) : path_connected_space (distrib_lattice string_imp) := sorry --non-trivial
lemma new_lemma_91343 (h0 : group (complete_semilattice_Sup (has_ssubset (random_gen to_additive.value_type)))) : group.fg (complete_semilattice_Sup (has_ssubset (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_91344 (h0 : topological_space (has_nndist (mul_zero_class (mul_zero_class name)))) : topological_space.separable_space (has_nndist (mul_zero_class (mul_zero_class name))) := sorry --non-trivial
lemma new_lemma_91345 (h0 : not (add_group (comm_ring char) -> false)) : @is_add_cyclic.{0} (comm_ring.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (comm_ring.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_91346 (h0 : ring (normed_group num)) : rank_condition (normed_group num) := sorry --non-trivial
lemma new_lemma_91347 (h0 : functor.add_const (topological_space (as_linear_order unsigned)) empty) : @t0_space.{0} (as_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (as_linear_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_91348 (h0 : function.extfun Type topological_space) : @normal_space.{0} name (@function.extfun_app.{2 1} Type topological_space.{0} h0 name)  := sorry --non-trivial
lemma new_lemma_91349 (h0 : functor.add_const (topological_space (has_neg_part name)) Type) : @discrete_topology.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg_part.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_91350 (h0 : functor.add_const (topological_space (has_Inf pos)) (finset linarith.comp)) : @totally_separated_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_91351 (h1 : has_mem.mem (complete_semilattice_Sup congr_arg_kind) has_emptyc.emptyc) : @group.fg.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type group.{0} (complete_semilattice_Sup.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_91352 (h0 : fin has_zero.zero) : @rank_condition.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (normed_lattice_add_comm_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_91353 (h0 : topological_space (canonically_ordered_comm_semiring (normed_comm_ring Type))) : topological_space.separable_space (canonically_ordered_comm_semiring (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_91354 (h0 : add_group (has_Inf (finset (has_add linarith.comp)))) : is_add_cyclic (has_Inf (finset (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_91355 (h0 : prod (complete_distrib_lattice (add_comm_monoid pos)) (complete_distrib_lattice (add_comm_monoid pos))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_91356 (h0 : monoid (mul_zero_class congr_arg_kind)) : monoid.fg (mul_zero_class congr_arg_kind) := sorry --non-trivial
lemma new_lemma_91357 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) name) : @regular_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_91358 (h0 : not (filter (topological_space to_additive.value_type) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_91359 (h0 : functor.add_const (monoid (boolean_algebra.core pos)) (has_add (has_add (has_add pos)))) : @monoid.fg.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (boolean_algebra.core.{0} pos)) (has_add.{0} (has_add.{0} (has_add.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_91360 (h0 : fun_info -> fun_info -> Prop) : total h0 := sorry --non-trivial
lemma new_lemma_91361 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_91362 (h0 : topological_space (normed_comm_ring (finset (finset pos)))) : locally_compact_space (normed_comm_ring (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_91363 (h0 : complete_lattice (linear_ordered_semiring (random_gen (random_gen congr_arg_kind)))) : is_atomistic (linear_ordered_semiring (random_gen (random_gen congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_91364 (h1 : uniform_space (has_top (with_bot (with_bot linarith.comp_source)))) : complete_space (has_top (with_bot (with_bot linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_91365 (h1 : ring (topological_space (has_ssubset string_imp))) : rank_condition (topological_space (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_91366 (h0 : uniform_space (bin_tree unsigned)) : complete_space (bin_tree unsigned) := sorry --non-trivial
lemma new_lemma_91367 (h0 : functor.add_const (monoid (boolean_algebra.core Type)) name) : @monoid.fg.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (boolean_algebra.core.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_91368 (h0 : ring (preorder congr_arg_kind)) : is_domain (preorder congr_arg_kind) := sorry --non-trivial
lemma new_lemma_91369 (h0 : functor.add_const (function.extfun (Type 1) semiring) pos) : @is_noetherian_ring.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) semiring.{1}) pos h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_91370 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_91371 (h0 : ring (normed_comm_ring (ring Type))) : rank_condition (normed_comm_ring (ring Type)) := sorry --non-trivial
lemma new_lemma_91372 (h0 : not (ring (has_inv string_imp) -> false)) : @strong_rank_condition.{0} (has_inv.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (has_inv.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_91373 (h0 : functor.add_const (functor.add_const (ring linarith.comp) name) pos) : @strong_rank_condition.{0} linarith.comp (@functor.add_const.run.{0 0} (ring.{0} linarith.comp) name (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ring.{0} linarith.comp) name) pos h0))  := sorry --non-trivial
lemma new_lemma_91374 (h0 : topological_space (measurable_space.dynkin_system congr_arg_kind)) : topological_space.separable_space (measurable_space.dynkin_system congr_arg_kind) := sorry --non-trivial
lemma new_lemma_91375 (h2 : ring (has_nnnorm environment.projection_info)) : is_domain (has_nnnorm environment.projection_info) := sorry --non-trivial
lemma new_lemma_91376 (h0 : functor.add_const (group (has_neg ennreal)) name) : @normalizer_condition.{0} (has_neg.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_91377 (h0 : topological_space (id (random_gen string_imp))) : topological_space.first_countable_topology (id (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_91378 (h0 : Prop -> add_comm_semigroup fun_info) (h1 : coe_sort (set.range h0)) : set.range_splitting h0 h1 := sorry --non-trivial
lemma new_lemma_91379 (h0 : topological_space (measurable_space num)) : t0_space (measurable_space num) := sorry --non-trivial
lemma new_lemma_91380 (h0 : topological_space (has_ssubset (has_ssubset linarith.comp_source))) : locally_compact_space (has_ssubset (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_91381 (h0 : topological_space (encodable (random_gen string_imp))) : t0_space (encodable (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_91382 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) h0) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_91383 (h0 : functor.add_const (uniform_space (has_pos_part Type)) (ring (ring pos))) : @separated_space.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_pos_part.{1} Type)) (ring.{0} (ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_91384 (h0 : topological_space (mul_one_class (has_ssubset reducibility_hints))) : totally_disconnected_space (mul_one_class (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_91385 (h0 : functor.add_const (function.extfun Type ring) pos) : @strong_rank_condition.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_91386 (h0 : not (ring (option unsigned) -> false)) : @rank_condition.{0} (option.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_91387 (h0 : group (boolean_algebra (comm_group Type))) : is_cyclic (boolean_algebra (comm_group Type)) := sorry --non-trivial
lemma new_lemma_91388 (h0 : list (has_repr (option congr_arg_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_91389 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_91390 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (add_left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_91391 (h0 : function.extfun Type topological_space) : @t1_space.{0} (complete_linear_order.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_91392 (h0 : ring (semi_normed_comm_ring (metric_space (metric_space reducibility_hints)))) : is_domain (semi_normed_comm_ring (metric_space (metric_space reducibility_hints))) := sorry --non-trivial
lemma new_lemma_91393 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_91394 (h0 : topological_space (random_gen (random_gen (random_gen linarith.comp_source)))) : t0_space (random_gen (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_91395 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (left_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (left_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_91396 (h0 : topological_space (finset (has_add (normed_comm_ring real)))) : path_connected_space (finset (has_add (normed_comm_ring real))) := sorry --non-trivial
lemma new_lemma_91397 (h0 : topological_space (measurable_space (random_gen linarith.comp_source))) : t0_space (measurable_space (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_91398 (h0 : functor.add_const (add_group (has_Inf linarith.comp)) (ordered_ring (ring Type))) : @is_add_cyclic.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_group.{0} (has_Inf.{0} linarith.comp)) (ordered_ring.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_91399 (h0 : finset (add_comm_monoid (finset name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_91400 (h0 : monoid (normed_lattice_add_comm_group name)) : monoid.fg (normed_lattice_add_comm_group name) := sorry --non-trivial
lemma new_lemma_91401 (h0 : functor.add_const (filter (boolean_algebra.core pos)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_91402 (h0 : topological_space (complete_distrib_lattice unsigned)) : path_connected_space (complete_distrib_lattice unsigned) := sorry --non-trivial
lemma new_lemma_91403 (h0 : functor.add_const (topological_space (lattice empty)) (option unsigned)) : @normal_space.{0} (lattice.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (lattice.{0} empty)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_91404 (h0 : functor.add_const (uniform_space (has_add Type)) Type) : @separated_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (has_add.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_91405 (h1 : set (mul_one_class (mul_one_class char))) : set.finite h1 := sorry --non-trivial
lemma new_lemma_91406 (h0 : ring (left_cancel_monoid (semiring num))) : rank_condition (left_cancel_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_91407 (h0 : functor.add_const (complete_lattice (has_zero Type)) Type) : @is_atomistic.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (has_zero.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_91408 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (linear_ordered_comm_monoid_with_zero.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_91409 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_91410 (h0 : topological_space (fintype linarith.ineq)) : t0_space (fintype linarith.ineq) := sorry --non-trivial
lemma new_lemma_91411 (h0 : group (has_ssubset (has_top (has_top (has_top (has_top linarith.ineq)))))) : group.fg (has_ssubset (has_top (has_top (has_top (has_top linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_91412 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_91413 (h0 : functor.add_const (group (has_add pos)) Type) : @group.fg.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (has_add.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_91414 (h0 : functor.add_const (function.extfun (Type 1) filter) pos) : filter.ne_bot (function.extfun_app (functor.add_const.run h0) (comm_group Type)) := sorry --non-trivial
lemma new_lemma_91415 (h0 : ring (comm_ring (random_gen (random_gen linarith.comp_source)))) : is_domain (comm_ring (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_91416 (h0 : functor.add_const (topological_space (cancel_monoid linarith.comp)) name) : @regular_space.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_91417 (h0 : ring (random_gen (mul_one_class (mul_one_class linarith.ineq)))) : strong_rank_condition (random_gen (mul_one_class (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_91418 (h0 : topological_space (generalized_boolean_algebra (ring (has_pos_part (has_neg Type))))) : locally_compact_space (generalized_boolean_algebra (ring (has_pos_part (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_91419 (h0 : function.extfun nat fin) : @preirreducible_space.{0} (simple_graph.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (simple_graph.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_91420 (h0 : function.extfun (Type 1) ring) : @is_principal_ideal_ring.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_91421 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_91422 (h0 : topological_space (ring (has_nndist (finset (has_neg Type))))) : irreducible_space (ring (has_nndist (finset (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_91423 (h0 : functor.comp topological_space comm_group environment.implicit_infer_kind) : @locally_compact_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_91424 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_91425 (h0 : topological_space (linear_ordered_comm_ring congr_arg_kind)) : path_connected_space (linear_ordered_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_91426 (h0 : functor.add_const (function.extfun Type monoid) linarith.comp) : @monoid.fg.{0} (has_edist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) linarith.comp h0) (has_edist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_91427 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @locally_compact_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_91428 (h0 : topological_space (dlist (has_nnnorm (linear_ordered_add_comm_group linarith.comp_source)))) : path_connected_space (dlist (has_nnnorm (linear_ordered_add_comm_group linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_91429 (h0 : monoid (measurable_space (random_gen (random_gen (random_gen to_additive.value_type))))) : monoid.fg (measurable_space (random_gen (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_91430 (h0 : functor.add_const (topological_space (semigroup pos)) pos) : @regular_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_91431 (h0 : functor.add_const (functor.add_const (finset name) num) empty) : finset.nonempty (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_91432 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (left_cancel_semigroup num)) := sorry --non-trivial
lemma new_lemma_91433 (h0 : filter (with_bot (has_top (has_norm (has_norm to_additive.value_type))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_91434 (h0 : ring (has_neg_part (mul_zero_class unsigned))) : is_domain (has_neg_part (mul_zero_class unsigned)) := sorry --non-trivial
lemma new_lemma_91435 (h0 : list (has_to_string (has_neg (group_with_zero ennreal)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_91436 (h0 : list (add_cancel_monoid (has_neg linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_91437 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_91438 (h0 : cancel_comm_monoid_with_zero (has_Inf (finset (finset pos)))) : unique_factorization_monoid (has_Inf (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_91439 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_91440 (h0 : complete_lattice (monoid_with_zero (option pos))) : is_compactly_generated (monoid_with_zero (option pos)) := sorry --non-trivial
lemma new_lemma_91441 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_91442 (h0 : functor.add_const (ring (has_to_string linarith.comp)) pos) : @strong_rank_condition.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_91443 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (uniform_space.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (uniform_space.{0} num))  := sorry --non-trivial
lemma new_lemma_91444 (h0 : prod (comm_group name) (comm_group name)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_91445 (h0 : ordered_comm_monoid (has_zero pos)) : has_exists_mul_of_le (has_zero pos) := sorry --non-trivial
lemma new_lemma_91446 (h0 : filter (random_gen (has_norm fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_91447 (h0 : ring (nondiscrete_normed_field (mul_one_class (normed_field ereal)))) : strong_rank_condition (nondiscrete_normed_field (mul_one_class (normed_field ereal))) := sorry --non-trivial
lemma new_lemma_91448 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} fun_info (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) fun_info)  := sorry --non-trivial
lemma new_lemma_91449 (h0 : topological_space (fintype char)) : totally_disconnected_space (fintype char) := sorry --non-trivial
lemma new_lemma_91450 (h0 : complete_lattice (option (semiring num))) : complete_lattice.is_Sup_finite_compact (option (semiring num)) := sorry --non-trivial
lemma new_lemma_91451 (h0 : group (comm_ring string_imp)) : is_cyclic (comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_91452 (h0 : complete_lattice (has_norm (random_gen num))) : is_compactly_generated (has_norm (random_gen num)) := sorry --non-trivial
lemma new_lemma_91453 (h0 : functor.add_const (topological_space (ring Type)) Type) : @loc_path_connected_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_91454 (h0 : topological_space (complete_linear_order (semiring (semiring congr_arg_kind)))) : totally_disconnected_space (complete_linear_order (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_91455 (h0 : complete_lattice (has_nnnorm to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (has_nnnorm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_91456 (h0 : fin has_zero.zero) : @discrete_topology.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (normed_lattice_add_comm_group.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_91457 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ring name)) linarith.comp) : @unique_factorization_monoid.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_91458 (h0 : group (measurable_space (random_gen to_additive.value_type))) : normalizer_condition (measurable_space (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_91459 (h0 : ordered_add_comm_monoid (has_dist unsigned)) : archimedean (has_dist unsigned) := sorry --non-trivial
lemma new_lemma_91460 (h0 : functor.add_const (function.extfun Type group) (semigroup pos)) : @normalizer_condition.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) (semigroup.{0} pos) h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_91461 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_91462 (h0 : group (has_add congr_arg_kind)) : group.fg (has_add congr_arg_kind) := sorry --non-trivial
lemma new_lemma_91463 (h0 : boolean_algebra.core (cancel_monoid (has_neg name)) -> boolean_algebra.core (cancel_monoid (has_neg name)) -> Prop) : is_antisymm (boolean_algebra.core (cancel_monoid (has_neg name))) h0 := sorry --non-trivial
lemma new_lemma_91464 (h1 : not (complete_lattice (with_one string_imp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_one.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_91465 (h0 : ring (encodable (has_inv linarith.ineq))) : strong_rank_condition (encodable (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_91466 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (denumerable linarith.ineq)) := sorry --non-trivial
lemma new_lemma_91467 (h0 : complete_lattice (linear_ordered_comm_monoid_with_zero (option empty))) : is_compactly_generated (linear_ordered_comm_monoid_with_zero (option empty)) := sorry --non-trivial
lemma new_lemma_91468 (h0 : finset (has_to_string (has_add (has_neg linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_91469 (h0 : function.extfun Type ring) : @rank_condition.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_linear_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_91470 (h0 : complete_lattice (add_cancel_monoid (option (option ennreal)))) : is_atomistic (add_cancel_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_91471 (h0 : uniform_space (has_le (mul_one_class enat))) : complete_space (has_le (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_91472 (h0 : topological_space (denumerable (complete_distrib_lattice (random_gen char)))) : t0_space (denumerable (complete_distrib_lattice (random_gen char))) := sorry --non-trivial
lemma new_lemma_91473 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring Type)) pos) : @irreducible_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_91474 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_91475 (h0 : group (ordered_comm_monoid (has_add Type))) : is_cyclic (ordered_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_91476 (h0 : topological_space (linear_ordered_add_comm_group linarith.comp_source)) : irreducible_space (linear_ordered_add_comm_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_91477 (h1 : ring (measurable_space num)) : strong_rank_condition (measurable_space num) := sorry --non-trivial
lemma new_lemma_91478 (h0 : function.extfun (Type 1) uniform_space) : @complete_space.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_91479 (h0 : semiring (add_right_cancel_monoid (semiring congr_arg_kind))) : is_noetherian_ring (add_right_cancel_monoid (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_91480 (h0 : complete_lattice (canonically_ordered_comm_semiring name)) : is_compactly_generated (canonically_ordered_comm_semiring name) := sorry --non-trivial
lemma new_lemma_91481 (h0 : functor.add_const (group (cancel_monoid linarith.comp)) name) : @is_simple_group.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (cancel_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_91482 (h0 : group (has_to_string Type)) : is_simple_group (has_to_string Type) := sorry --non-trivial
lemma new_lemma_91483 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring linarith.comp))) : @discrete_topology.{0} (linear_ordered_semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_91484 (h0 : functor.comp topological_space add_cancel_monoid unsigned) : @irreducible_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_91485 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) (has_Inf pos)) : @preirreducible_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} pos)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_91486 (h0 : topological_space (has_neg (add_comm_monoid (cancel_monoid Type)))) : discrete_topology (has_neg (add_comm_monoid (cancel_monoid Type))) := sorry --non-trivial
lemma new_lemma_91487 (h0 : not (topological_space (has_emptyc linarith.comp_source) -> false)) : @locally_compact_space.{0} (has_emptyc.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_91488 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} name (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) name)  := sorry --non-trivial
lemma new_lemma_91489 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_neg Type)) := sorry --non-trivial
lemma new_lemma_91490 (h1 : topological_space (has_emptyc (has_norm fun_info))) : path_connected_space (has_emptyc (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_91491 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf (has_Inf real)))) : loc_path_connected_space (canonically_linear_ordered_monoid (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_91492 (h0 : topological_space (ordered_comm_ring (has_pos_part pos))) : t1_space (ordered_comm_ring (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_91493 (h0 : semiring (has_add (has_add pos))) : is_noetherian_ring (has_add (has_add pos)) := sorry --non-trivial
lemma new_lemma_91494 (h0 : filter (measure_theory.measure_space (has_norm empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_91495 (h0 : filter (with_bot (has_norm (has_norm num)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_91496 (h0 : ring (canonically_linear_ordered_monoid (sub_neg_monoid name))) : is_principal_ideal_ring (canonically_linear_ordered_monoid (sub_neg_monoid name)) := sorry --non-trivial
lemma new_lemma_91497 (h0 : group (has_ssubset (has_top (has_top (has_nnnorm fun_info))))) : group.fg (has_ssubset (has_top (has_top (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_91498 (h0 : not (has_lt (simple_graph linarith.ineq) -> false)) : no_max_order (simple_graph linarith.ineq) := sorry --non-trivial
lemma new_lemma_91499 (h0 : topological_space (add_comm_monoid (option empty))) : totally_disconnected_space (add_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_91500 (h0 : topological_space (random_gen (has_inv (has_inv linarith.comp_source)))) : totally_separated_space (random_gen (has_inv (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_91501 (h0 : function.extfun Type (functor.add_const (topological_space unsigned))) : @topological_space.separable_space.{0} unsigned (@functor.add_const.run.{0 0} (topological_space.{0} unsigned) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} unsigned)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_91502 (h0 : functor.add_const (ring (preorder empty)) congr_arg_kind) : @is_principal_ideal_ring.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (preorder.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_91503 (h0 : functor.add_const (monoid (has_add environment.implicit_infer_kind)) Type) : @monoid.fg.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (monoid.{0} (has_add.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_91504 (h0 : add_group (has_neg_part (mul_zero_class name))) : is_add_cyclic (has_neg_part (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_91505 (h0 : topological_space (has_lt (has_ssubset reducibility_hints))) : totally_disconnected_space (has_lt (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_91506 (h0 : topological_space (metric_space (option (option empty)))) : loc_path_connected_space (metric_space (option (option empty))) := sorry --non-trivial
lemma new_lemma_91507 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @complete_space.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) uniform_space.{0}) (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_91508 (h0 : topological_space (dlist (has_norm linarith.ineq))) : irreducible_space (dlist (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_91509 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem add_monoid)) : @add_monoid.fg.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_monoid.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_monoid.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_91510 (h0 : functor.add_const (ordered_add_comm_monoid (generalized_boolean_algebra pos)) (ring linarith.comp)) : @archimedean.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (generalized_boolean_algebra.{0} pos)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_91511 (h0 : complete_lattice (plift name)) : complete_lattice.is_Sup_finite_compact (plift name) := sorry --non-trivial
lemma new_lemma_91512 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_neg.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_91513 (h0 : ring (normed_group (has_inv (has_top fun_info)))) : is_domain (normed_group (has_inv (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_91514 (h0 : function.extfun Type (prod (has_nndist pos))) : id_rel (function.extfun_app h0 (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_91515 (h0 : topological_space (has_norm (has_top (has_top fun_info)))) : totally_separated_space (has_norm (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_91516 (h0 : functor.comp complete_lattice has_neg Type) : @is_compactly_generated.{1} (has_neg.{1} Type) (@functor.comp.run.{1 1 1} complete_lattice.{1} has_neg.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_91517 (h0 : list (with_bot (random_gen (random_gen linarith.ineq)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_91518 (h0 : semiring (filter (option num))) : is_noetherian_ring (filter (option num)) := sorry --non-trivial
lemma new_lemma_91519 (h0 : functor.add_const (ring (semigroup name)) environment.implicit_infer_kind) : @is_domain.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_91520 (h0 : functor.add_const (ring (has_Inf pos)) pos) : @is_domain.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_Inf.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_91521 (h0 : functor.add_const (topological_space (has_neg_part name)) name) : @loc_path_connected_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_91522 (h0 : topological_space (normed_comm_ring (finset pos))) : t1_space (normed_comm_ring (finset pos)) := sorry --non-trivial
lemma new_lemma_91523 (h0 : ring (has_add (finset (has_add environment.implicit_infer_kind)))) : is_principal_ideal_ring (has_add (finset (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_91524 (h0 : ring (has_star (semiring empty))) : rank_condition (has_star (semiring empty)) := sorry --non-trivial
lemma new_lemma_91525 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (finset.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (finset.{0} real))  := sorry --non-trivial
lemma new_lemma_91526 (h3 : uniform_space (simple_graph to_additive.value_type)) : complete_space (simple_graph to_additive.value_type) := sorry --non-trivial
lemma new_lemma_91527 (h0 : set ordering) : set.finite h0 := sorry --non-trivial
lemma new_lemma_91528 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (add_left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_91529 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_91530 (h0 : topological_space (ordered_comm_ring real)) : t1_space (ordered_comm_ring real) := sorry --non-trivial
lemma new_lemma_91531 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_91532 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (add_cancel_monoid empty)) := sorry --non-trivial
lemma new_lemma_91533 (h0 : topological_space (semigroup (comm_group (has_add name)))) : t1_space (semigroup (comm_group (has_add name))) := sorry --non-trivial
lemma new_lemma_91534 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (ordered_ring.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned)))) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ordered_ring.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned)))))  := sorry --non-trivial
lemma new_lemma_91535 (h0 : functor.add_const (topological_space (add_comm_monoid unsigned)) Type) : @locally_compact_space.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_91536 (h0 : has_mem.mem (with_one linarith.comp) has_emptyc.emptyc) : @separated_space.{0} (with_one.{0} linarith.comp) (@finset.pi.empty.{1 0} Type uniform_space.{0} (with_one.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_91537 (h0 : fin has_zero.zero) : @archimedean.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (ordered_add_comm_monoid.{1} (generalized_boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_91538 (h0 : function.extfun Type (functor.add_const (topological_space (linear_ordered_comm_group empty)))) : @path_connected_space.{0} (linear_ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_group.{0} empty)) (option.{0} (option.{0} (option.{0} num))) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (linear_ordered_comm_group.{0} empty))) h0 (option.{0} (option.{0} (option.{0} num)))))  := sorry --non-trivial
lemma new_lemma_91539 (h0 : functor.add_const (finset (linear_ordered_comm_ring unsigned)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_91540 (h0 : finset (add_left_cancel_semigroup num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_91541 (h0 : ring (group_with_zero (option unsigned))) : is_principal_ideal_ring (group_with_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_91542 (h0 : not (add_group (semiring (random_gen (random_gen fun_info))) -> false)) : @is_add_cyclic.{0} (semiring.{0} (random_gen.{0} (random_gen.{0} fun_info))) (@classical.by_contradiction'.{1} (add_group.{0} (semiring.{0} (random_gen.{0} (random_gen.{0} fun_info)))) h0)  := sorry --non-trivial
lemma new_lemma_91543 (h0 : functor.add_const (uniform_space (bin_tree unsigned)) congr_arg_kind) : @complete_space.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (bin_tree.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_91544 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_91545 (h0 : ordered_comm_monoid (comm_semigroup (has_pos_part name))) : has_exists_mul_of_le (comm_semigroup (has_pos_part name)) := sorry --non-trivial
lemma new_lemma_91546 (h0 : ring (normed_group (has_inv linarith.ineq))) : is_domain (normed_group (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_91547 (h0 : functor.add_const (topological_space (has_to_string Type)) environment.implicit_infer_kind) : @sequential_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_91548 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @t1_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_91549 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_91550 (h0 : ring (has_nnnorm reducibility_hints)) : is_domain (has_nnnorm reducibility_hints) := sorry --non-trivial
lemma new_lemma_91551 (h0 : group (has_zero Type)) : is_cyclic (has_zero Type) := sorry --non-trivial
lemma new_lemma_91552 (h0 : ring (ring (finset pos))) : is_principal_ideal_ring (ring (finset pos)) := sorry --non-trivial
lemma new_lemma_91553 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_91554 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} h0 (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_91555 (h0 : topological_space (has_neg_part (has_nndist (finset Type)))) : preirreducible_space (has_neg_part (has_nndist (finset Type))) := sorry --non-trivial
lemma new_lemma_91556 (h1 : topological_space (with_one linarith.ineq)) : path_connected_space (with_one linarith.ineq) := sorry --non-trivial
lemma new_lemma_91557 (h0 : functor.add_const (ring (partial_order unsigned)) empty) : @is_principal_ideal_ring.{0} (partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (partial_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_91558 (h0 : uniform_space (fintype (random_gen linarith.comp_source))) : complete_space (fintype (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_91559 (h0 : ordered_add_comm_monoid (bin_tree unsigned)) : archimedean (bin_tree unsigned) := sorry --non-trivial
lemma new_lemma_91560 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (random_gen.{0} num)))))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (random_gen.{0} num)))))))  := sorry --non-trivial
lemma new_lemma_91561 (h0 : topological_space (random_gen (has_top congr_arg_kind))) : path_connected_space (random_gen (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_91562 (h0 : topological_space (group_with_zero empty)) : totally_disconnected_space (group_with_zero empty) := sorry --non-trivial
lemma new_lemma_91563 (h0 : topological_space (option (mul_zero_class congr_arg_kind))) : totally_disconnected_space (option (mul_zero_class congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_91564 (h0 : ring (denumerable (random_gen (has_nnnorm linarith.comp_source)))) : is_domain (denumerable (random_gen (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_91565 (h1 : ring (with_bot fun_info)) : strong_rank_condition (with_bot fun_info) := sorry --non-trivial
lemma new_lemma_91566 (h0 : topological_space (measurable_space (with_bot (with_bot string_imp)))) : totally_separated_space (measurable_space (with_bot (with_bot string_imp))) := sorry --non-trivial
lemma new_lemma_91567 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_91568 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_91569 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) empty) : @unique_factorization_monoid.{0} auto.case_option (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) empty h0) auto.case_option)  := sorry --non-trivial
lemma new_lemma_91570 (h0 : has_mem.mem linarith.comp has_emptyc.emptyc) : @locally_compact_space.{0} linarith.comp (@finset.pi.empty.{1 0} Type topological_space.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_91571 (h0 : group (free_add_monoid unsigned)) : normalizer_condition (free_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_91572 (h0 : functor.add_const (fin has_zero.zero) real) : @is_cyclic.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) real h0)) (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_91573 (h0 : functor.add_const (group (semigroup congr_arg_kind)) unsigned) : @group.fg.{0} (semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_91574 (h0 : topological_space (has_top (linear_ordered_semiring (has_norm linarith.comp)))) : normal_space (has_top (linear_ordered_semiring (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_91575 (h3 : complete_lattice (div_inv_monoid fun_info)) : is_compactly_generated (div_inv_monoid fun_info) := sorry --non-trivial
lemma new_lemma_91576 (h0 : ring (linear_ordered_field (option (option (option empty))))) : rank_condition (linear_ordered_field (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_91577 (h0 : functor.add_const (semiring (has_to_string Type)) (ring pos)) : @is_noetherian_ring.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (has_to_string.{1} Type)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_91578 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_91579 (h0 : list (linear_ordered_add_comm_group (has_nnnorm to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_91580 (h0 : ring (has_neg (mul_one_class fun_info))) : rank_condition (has_neg (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_91581 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (option.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (option.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_91582 (h1 : complete_lattice (nondiscrete_normed_field ereal)) : complete_lattice.is_Sup_finite_compact (nondiscrete_normed_field ereal) := sorry --non-trivial
lemma new_lemma_91583 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (preorder.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_91584 (h0 : monoid (canonically_ordered_comm_semiring (has_Inf pos))) : monoid.fg (canonically_ordered_comm_semiring (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_91585 (h0 : ring (complete_distrib_lattice (has_add pos))) : rank_condition (complete_distrib_lattice (has_add pos)) := sorry --non-trivial
lemma new_lemma_91586 (h1 : function.extfun Type topological_space) : @irreducible_space.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_91587 (h0 : topological_space (add_comm_monoid pos)) : topological_space.separable_space (add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_91588 (h0 : topological_space (semigroup (has_nndist Type))) : topological_space.separable_space (semigroup (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_91589 (h0 : not (ring (semi_normed_ring (normed_field linarith.comp_source)) -> false)) : @is_domain.{0} (semi_normed_ring.{0} (normed_field.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_ring.{0} (normed_field.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_91590 (h0 : topological_space (has_compl (mul_one_class (mul_one_class fun_info)))) : path_connected_space (has_compl (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_91591 (h0 : not (has_mem.mem (linear_ordered_semiring num) has_emptyc.emptyc -> false)) : @is_add_cyclic.{0} (linear_ordered_semiring.{0} num) (@finset.pi.empty.{1 0} Type add_group.{0} (linear_ordered_semiring.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_91592 (h0 : functor.add_const (topological_space (boolean_algebra Type)) environment.implicit_infer_kind) : @regular_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_91593 (h0 : functor.add_const (add_monoid (has_zero pos)) pos) : @add_monoid.fg.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_zero.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_91594 (h0 : group (linear_ordered_semiring linarith.ineq)) : group.fg (linear_ordered_semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_91595 (h0 : group (measurable_space to_additive.value_type)) : is_cyclic (measurable_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_91596 (h0 : functor.add_const (ring (has_Inf pos)) name) : @strong_rank_condition.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_Inf.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_91597 (h0 : functor.add_const (ring (finset pos)) linarith.comp) : @strong_rank_condition.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_91598 (h0 : topological_space (with_bot (has_top (random_gen congr_arg_kind)))) : path_connected_space (with_bot (has_top (random_gen congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_91599 (h0 : has_top congr_arg_kind -> has_top congr_arg_kind -> Prop) : is_equiv (has_top congr_arg_kind) h0 := sorry --non-trivial
lemma new_lemma_91600 (h0 : topological_space (semiring (has_norm linarith.comp_source))) : irreducible_space (semiring (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_91601 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (normed_comm_ring (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_91602 (h0 : function.extfun Type (functor.add_const (finset znum))) : finset.nonempty (functor.add_const.run (function.extfun_app h0 unsigned)) := sorry --non-trivial
lemma new_lemma_91603 (h0 : functor.comp topological_space canonically_ordered_comm_semiring name) : @preirreducible_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_91604 (h0 : thunk pnat) (h1 : pnat) (h2 : list pnat) : pnat.coprime (@trace_call_stack.{0} pnat h0) (@list.ilast'.{0} pnat h1 h2)  := sorry --non-trivial
lemma new_lemma_91605 (h0 : topological_space (simple_graph (has_add name))) : irreducible_space (simple_graph (has_add name)) := sorry --non-trivial
lemma new_lemma_91606 (h0 : topological_space (complete_distrib_lattice Type)) : loc_path_connected_space (complete_distrib_lattice Type) := sorry --non-trivial
lemma new_lemma_91607 (h0 : topological_space (normed_field (has_nnnorm (random_gen (has_nnnorm reducibility_hints))))) : t0_space (normed_field (has_nnnorm (random_gen (has_nnnorm reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_91608 (h0 : has_lt (has_compl linarith.comp_source)) : no_max_order (has_compl linarith.comp_source) := sorry --non-trivial
lemma new_lemma_91609 (h0 : ring (semigroup (mul_one_class linarith.comp))) : strong_rank_condition (semigroup (mul_one_class linarith.comp)) := sorry --non-trivial
lemma new_lemma_91610 (h0 : semiring (linear_ordered_semiring (semiring (semiring unsigned)))) : is_noetherian_ring (linear_ordered_semiring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_91611 (h1 : function.extfun Type group) : @is_cyclic.{0} empty (@function.extfun_app.{2 1} Type group.{0} h1 empty)  := sorry --non-trivial
lemma new_lemma_91612 (h0 : ordered_comm_monoid (has_neg_part (option (pseudo_metric_space pos)))) : has_exists_mul_of_le (has_neg_part (option (pseudo_metric_space pos))) := sorry --non-trivial
lemma new_lemma_91613 (h0 : topological_space (has_ssubset (mul_one_class (random_gen (has_nnnorm (has_nnnorm fun_info)))))) : t0_space (has_ssubset (mul_one_class (random_gen (has_nnnorm (has_nnnorm fun_info))))) := sorry --non-trivial
lemma new_lemma_91614 (h0 : complete_lattice (partial_order (semiring (semiring (semiring num))))) : is_atomistic (partial_order (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_91615 (h0 : functor.add_const (function.extfun Type topological_space) (option (finset (finset name)))) : @t1_space.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (option.{0} (finset.{0} (finset.{0} name))) h0) (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_91616 (h0 : function.extfun Type topological_space) : @normal_space.{0} (cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_91617 (h0 : ring (has_neg (finset (finset ennreal)))) : strong_rank_condition (has_neg (finset (finset ennreal))) := sorry --non-trivial
lemma new_lemma_91618 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_91619 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) pos) : @totally_disconnected_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_91620 (h0 : uniform_space (has_add (has_add (finset pos)))) : complete_space (has_add (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_91621 (h0 : functor.add_const (ring (finset linarith.comp)) environment.implicit_infer_kind) : @is_domain.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_91622 (h0 : ring (distrib (comm_ring (has_nnnorm linarith.ineq)))) : strong_rank_condition (distrib (comm_ring (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_91623 (h0 : function.extfun nat fin) : @add_monoid.fg.{0} (boolean_algebra.{0} real) (@matrix.vec_empty.{0} (add_monoid.{0} (boolean_algebra.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_91624 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @path_connected_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_91625 (h0 : topological_space (add_cancel_monoid (has_pos_part name))) : totally_disconnected_space (add_cancel_monoid (has_pos_part name)) := sorry --non-trivial
lemma new_lemma_91626 (h0 : add_monoid (canonically_ordered_comm_semiring (boolean_algebra.core pos))) : add_monoid.fg (canonically_ordered_comm_semiring (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_91627 (h0 : functor.add_const (topological_space (add_left_cancel_semigroup empty)) empty) : @topological_space.separable_space.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_91628 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (comm_ring.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (comm_ring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_91629 (h0 : filter (monoid (option (option (option unsigned))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_91630 (h0 : functor.add_const (topological_space (sub_neg_monoid name)) linarith.comp) : @loc_path_connected_space.{0} (sub_neg_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_91631 (h1 : topological_space (has_ssubset reducibility_hints)) : t0_space (has_ssubset reducibility_hints) := sorry --non-trivial
lemma new_lemma_91632 (h0 : complete_lattice (preorder (semiring unsigned))) : is_atomistic (preorder (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_91633 (h0 : topological_space (add_cancel_monoid (ring name))) : discrete_topology (add_cancel_monoid (ring name)) := sorry --non-trivial
lemma new_lemma_91634 (h0 : topological_space (ring (finset Type))) : regular_space (ring (finset Type)) := sorry --non-trivial
lemma new_lemma_91635 (h0 : monoid (add_group (semiring empty))) : monoid.fg (add_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_91636 (h0 : group (boolean_algebra (has_neg linarith.comp))) : group.fg (boolean_algebra (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_91637 (h0 : topological_space (boolean_algebra (ring (ring (has_Inf (has_Inf pos)))))) : t0_space (boolean_algebra (ring (ring (has_Inf (has_Inf pos))))) := sorry --non-trivial
lemma new_lemma_91638 (h0 : functor.add_const (ordered_add_comm_monoid (add_comm_monoid name)) pos) : @archimedean.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_comm_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_91639 (h0 : topological_space (bin_tree (semiring (semiring (semiring unsigned))))) : t0_space (bin_tree (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_91640 (h0 : group (semiring (random_gen to_additive.value_type))) : normalizer_condition (semiring (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_91641 (h0 : group (semigroup pos)) : is_cyclic (semigroup pos) := sorry --non-trivial
lemma new_lemma_91642 (h0 : not (has_mem.mem (comm_group linarith.ineq) has_emptyc.emptyc -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (comm_group.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (comm_group.{0} linarith.ineq) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (comm_group.{0} linarith.ineq) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_91643 (h0 : group (random_gen (random_gen (random_gen to_additive.value_type)))) : group.fg (random_gen (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_91644 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @is_principal_ideal_ring.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_91645 (h0 : functor.add_const (monoid (add_cancel_monoid linarith.comp)) (has_neg Type)) : @monoid.fg.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (monoid.{0} (add_cancel_monoid.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_91646 (h0 : functor.add_const (complete_lattice (has_Inf pos)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_Inf.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_91647 (h0 : functor.add_const (topological_space (sub_neg_monoid linarith.comp)) linarith.comp) : @topological_space.separable_space.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_91648 (h0 : ring (has_nndist (comm_group environment.implicit_infer_kind))) : strong_rank_condition (has_nndist (comm_group environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_91649 (h0 : list (ordered_comm_ring (ring linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_91650 (h0 : functor.add_const (ordered_add_comm_monoid (monoid empty)) unsigned) : @archimedean.{0} (monoid.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_91651 (h0 : monoid (canonically_ordered_monoid (has_Inf real))) : monoid.fg (canonically_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_91652 (h0 : topological_space (simple_graph (mul_one_class char))) : path_connected_space (simple_graph (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_91653 (h0 : topological_space (has_zero (has_pos_part Type))) : locally_compact_space (has_zero (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_91654 (h0 : set (semi_normed_ring linarith.ineq)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_91655 (h0 : functor.comp topological_space has_add unsigned) : @preirreducible_space.{0} (has_add.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_91656 (h0 : functor.add_const (monoid (has_neg_part name)) Type) : @monoid.fg.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 1} (monoid.{0} (has_neg_part.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_91657 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_91658 (h0 : group (measure_theory.measure_space (semiring (semiring (semiring empty))))) : normalizer_condition (measure_theory.measure_space (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_91659 (h0 : topological_space (id (id (has_top congr_arg_kind)))) : preirreducible_space (id (id (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_91660 (h0 : complete_lattice (add_monoid (fintype linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (add_monoid (fintype linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_91661 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (option.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (option.{0} num))  := sorry --non-trivial
lemma new_lemma_91662 (h0 : topological_space (has_add pos)) : irreducible_space (has_add pos) := sorry --non-trivial
lemma new_lemma_91663 (h0 : list (normed_lattice_add_comm_group (has_add Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_91664 (h0 : functor.add_const (ring (boolean_algebra linarith.comp)) (has_neg (has_zero (boolean_algebra (ring Type))))) : @rank_condition.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (boolean_algebra.{0} linarith.comp)) (has_neg.{1} (has_zero.{1} (boolean_algebra.{1} (ring.{1} Type)))) h0)  := sorry --non-trivial
lemma new_lemma_91665 (h0 : topological_space (add_cancel_monoid name)) : t1_space (add_cancel_monoid name) := sorry --non-trivial
lemma new_lemma_91666 (h0 : functor.add_const (functor.comp monoid canonically_ordered_comm_semiring name) pos) : @monoid.fg.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.comp.run.{0 0 0} monoid.{0} canonically_ordered_comm_semiring.{0} name (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} monoid.{0} canonically_ordered_comm_semiring.{0} name) pos h0))  := sorry --non-trivial
lemma new_lemma_91667 (h0 : group (semiring (has_norm linarith.comp))) : normalizer_condition (semiring (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_91668 (h0 : complete_lattice (has_zero (has_neg linarith.comp))) : complete_lattice.is_Sup_finite_compact (has_zero (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_91669 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_91670 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_91671 (h0 : list (has_to_string (option unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_91672 (h0 : functor.add_const (ordered_add_comm_monoid (canonically_ordered_comm_semiring pos)) name) : @archimedean.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (canonically_ordered_comm_semiring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_91673 (h0 : finset (complete_distrib_lattice congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_91674 (h0 : topological_space (complete_semilattice_Sup empty)) : preirreducible_space (complete_semilattice_Sup empty) := sorry --non-trivial
lemma new_lemma_91675 (h0 : topological_space (ordered_comm_monoid (has_add Type))) : discrete_topology (ordered_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_91676 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_inter congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_91677 (h0 : ring (canonically_ordered_monoid (has_bot pos))) : strong_rank_condition (canonically_ordered_monoid (has_bot pos)) := sorry --non-trivial
lemma new_lemma_91678 (h0 : not (topological_space (has_nnnorm reducibility_hints) -> false)) : @totally_disconnected_space.{0} (has_nnnorm.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (has_nnnorm.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_91679 (h0 : function.extfun (Type 1) topological_space) : @loc_path_connected_space.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_91680 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_91681 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (complete_distrib_lattice congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_91682 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (as_linear_order.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (as_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_91683 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_91684 (h0 : topological_space (has_nnnorm char)) (h1 : not (has_vadd int (has_nnnorm char) -> false)) : @has_continuous_const_vadd.{0 0} int (has_nnnorm.{0} char) h0 (@classical.by_contradiction'.{1} (has_vadd.{0 0} int (has_nnnorm.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_91685 (h0 : monoid (add_comm_semigroup (nondiscrete_normed_field fun_info))) (h1 : add_comm_semigroup (nondiscrete_normed_field fun_info)) : is_of_fin_order h1 := sorry --non-trivial
lemma new_lemma_91686 (h0 : functor.add_const (list (cancel_monoid name)) (has_add (semigroup (has_add Type)))) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_91687 (h0 : functor.add_const (group (has_neg_part Type)) environment.implicit_infer_kind) : @is_simple_group.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_neg_part.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_91688 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_91689 (h0 : uniform_space (with_one fun_info)) : separated_space (with_one fun_info) := sorry --non-trivial
lemma new_lemma_91690 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_91691 (h0 : functor.add_const (topological_space (has_neg Type)) environment.implicit_infer_kind) : @irreducible_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_91692 (h0 : functor.add_const (topological_space (comm_group pos)) environment.implicit_infer_kind) : @regular_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_91693 (h0 : topological_space (measurable_space to_additive.value_type)) : totally_separated_space (measurable_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_91694 (h0 : finset (sub_neg_monoid name)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_91695 (h0 : topological_space (canonically_linear_ordered_monoid (sub_neg_monoid real))) : loc_path_connected_space (canonically_linear_ordered_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_91696 (h0 : list (has_to_string name)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_91697 (h0 : functor.add_const (add_group (comm_group environment.implicit_infer_kind)) linarith.comp) : @is_add_cyclic.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_group.{0} (comm_group.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_91698 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg pos)) : @totally_separated_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{0} pos) h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_91699 (h0 : uniform_space (has_star (semiring empty))) : complete_space (has_star (semiring empty)) := sorry --non-trivial
lemma new_lemma_91700 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (ring.{0} num) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (ring.{0} num))  := sorry --non-trivial
lemma new_lemma_91701 (h0 : set linarith.ineq) (h1 : linarith.ineq) : set.up h0 h1 := sorry --non-trivial
lemma new_lemma_91702 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_91703 (h0 : uniform_space (with_one char)) : complete_space (with_one char) := sorry --non-trivial
lemma new_lemma_91704 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (has_Inf.{0} linarith.comp) (@matrix.vec_empty.{0} (add_group.{0} (has_Inf.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_91705 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_91706 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_91707 (h0 : functor.add_const (list (has_add pos)) (finset (has_nndist (finset linarith.comp)))) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_91708 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_inter.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_91709 (h0 : not (finset (has_top congr_arg_kind) -> false)) : finset.nonempty (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_91710 (h0 : ring (nondiscrete_normed_field (add_comm_semigroup linarith.ineq))) : is_domain (nondiscrete_normed_field (add_comm_semigroup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_91711 (h0 : list (normed_lattice_add_comm_group (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid pos)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_91712 (h0 : not (group empty -> false)) : @group.fg.{0} empty (@classical.by_contradiction'.{1} (group.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_91713 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_91714 (h0 : topological_space (cancel_monoid ennreal)) : discrete_topology (cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_91715 (h0 : topological_space (ring (boolean_algebra.core name))) : t0_space (ring (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_91716 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_inter.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_inter.{0} ennreal)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_inter.{0} ennreal))) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.add_const.{0 0} (topological_space.{0} (has_inter.{0} ennreal)))) num))  := sorry --non-trivial
lemma new_lemma_91717 (h0 : topological_space (comm_group (boolean_algebra (has_add (has_add Type))))) : preirreducible_space (comm_group (boolean_algebra (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_91718 (h0 : function.extfun Type semiring) (h1 : metric_space congr_arg_kind) : @odd.{0} (metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (metric_space.{0} congr_arg_kind)) h1  := sorry --non-trivial
lemma new_lemma_91719 (h0 : add_group (has_sdiff fun_info)) : is_add_cyclic (has_sdiff fun_info) := sorry --non-trivial
lemma new_lemma_91720 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @group.fg.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_91721 (h0 : topological_space (has_emptyc (has_norm to_additive.value_type))) : regular_space (has_emptyc (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_91722 (h0 : add_group (ordered_comm_monoid (has_neg name))) : is_add_cyclic (ordered_comm_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_91723 (h0 : topological_space (ring linarith.comp)) : totally_separated_space (ring linarith.comp) := sorry --non-trivial
lemma new_lemma_91724 (h0 : functor.add_const Prop (has_zero (option num))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_91725 (h0 : topological_space (boolean_algebra.core environment.implicit_infer_kind)) : irreducible_space (boolean_algebra.core environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_91726 (h0 : topological_space (ordered_comm_ring (has_add (ring (semigroup name))))) : t0_space (ordered_comm_ring (has_add (ring (semigroup name)))) := sorry --non-trivial
lemma new_lemma_91727 (h0 : function.extfun (multiset Type) (has_mem.mem ennreal)) : @strong_rank_condition.{0} ennreal (@multiset.pi.empty.{1 0} Type ring.{0} ennreal (@function.extfun_app.{2 0} (multiset.{1} Type) (@has_mem.mem.{1 1} Type (multiset.{1} Type) (@multiset.has_mem.{1} Type) ennreal) h0 (@has_zero.zero.{1} (multiset.{1} Type) (@multiset.has_zero.{1} Type))))  := sorry --non-trivial
lemma new_lemma_91728 (h0 : fin has_zero.zero) : @is_domain.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_91729 (h0 : topological_space (comm_ring (has_compl char))) : path_connected_space (comm_ring (has_compl char)) := sorry --non-trivial
lemma new_lemma_91730 (h0 : topological_space (complete_semilattice_Sup linarith.comp)) : path_connected_space (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_91731 (h0 : ring (with_bot (semiring linarith.comp))) : rank_condition (with_bot (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_91732 (h2 : uniform_space (has_top (has_top (has_top congr_arg_kind)))) : complete_space (has_top (has_top (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_91733 (h0 : functor.add_const (monoid (has_nndist name)) pos) : @monoid.fg.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (has_nndist.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_91734 (h0 : functor.add_const (topological_space nnreal) empty) : totally_disconnected_space nnreal := sorry --non-trivial
lemma new_lemma_91735 (h0 : topological_space (linear_ordered_add_comm_group (has_norm linarith.comp_source))) : totally_disconnected_space (linear_ordered_add_comm_group (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_91736 (h0 : complete_lattice ereal) : is_atomistic ereal := sorry --non-trivial
lemma new_lemma_91737 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (simple_graph linarith.comp)) := sorry --non-trivial
lemma new_lemma_91738 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) (finset Type)) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} pos)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_91739 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_91740 (h0 : group (pseudo_metric_space (option (option (option (option ennreal)))))) : group.fg (pseudo_metric_space (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_91741 (h0 : topological_space (with_bot (has_norm to_additive.value_type))) : locally_compact_space (with_bot (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_91742 (h0 : set (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup std_gen)) -> std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_91743 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (measurable_space.dynkin_system.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.dynkin_system.{0} empty))  := sorry --non-trivial
lemma new_lemma_91744 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf name))) : discrete_topology (normed_lattice_add_comm_group (has_Inf name)) := sorry --non-trivial
lemma new_lemma_91745 (h0 : functor.add_const (add_group (canonically_ordered_comm_semiring Type)) name) : @is_add_cyclic.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (canonically_ordered_comm_semiring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_91746 (h0 : topological_space (semi_normed_comm_ring (has_nnnorm fun_info))) : t0_space (semi_normed_comm_ring (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_91747 (h0 : functor.add_const (filter (has_add linarith.comp)) (has_neg pos)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_91748 (h0 : topological_space (metric_space linarith.comp_source)) : path_connected_space (metric_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_91749 (h0 : ordered_comm_monoid (canonically_ordered_monoid (has_Inf linarith.comp))) : has_exists_mul_of_le (canonically_ordered_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_91750 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @path_connected_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_91751 (h1 : group (has_top (random_gen (with_bot linarith.comp_source)))) : normalizer_condition (has_top (random_gen (with_bot linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_91752 (h0 : function.extfun (Type 1) (functor.comp topological_space boolean_algebra)) : @irreducible_space.{1} (boolean_algebra.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} boolean_algebra.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} boolean_algebra.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_91753 (h0 : topological_space (cancel_monoid (option empty))) : loc_path_connected_space (cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_91754 (h0 : group (boolean_algebra.core (boolean_algebra.core (has_add name)))) : is_cyclic (boolean_algebra.core (boolean_algebra.core (has_add name))) := sorry --non-trivial
lemma new_lemma_91755 (h1 : mul_one_class (semi_normed_comm_ring string_imp)) (h3 : add_group (monoid.End (semi_normed_comm_ring string_imp))) : is_add_cyclic (monoid.End (semi_normed_comm_ring string_imp)) := sorry --non-trivial
lemma new_lemma_91756 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) pos) : @totally_disconnected_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_91757 (h0 : not (complete_lattice (uniform_space linarith.ineq) -> false)) : is_compactly_generated (uniform_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_91758 (h0 : list (has_edist congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_91759 (h0 : functor.add_const (cancel_comm_monoid_with_zero (mul_zero_class empty)) empty) : @unique_factorization_monoid.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (mul_zero_class.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_91760 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf (has_add pos)))) : t1_space (normed_lattice_add_comm_group (has_Inf (has_add pos))) := sorry --non-trivial
lemma new_lemma_91761 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @locally_compact_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_91762 (h1 : filter (has_add (has_nnnorm to_additive.value_type))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_91763 (h0 : not (list (has_inv linarith.comp_source) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_91764 (h0 : function.extfun Type (functor.add_const (topological_space (comm_monoid empty)))) : @discrete_topology.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (comm_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_91765 (h0 : list (mul_zero_class (finset (has_nndist ennreal)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_91766 (h0 : measurable_space (add_comm_semigroup ereal)) (h1 : filter (add_comm_semigroup ereal)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_91767 (h0 : ring (add_left_cancel_monoid linarith.comp_source)) : is_domain (add_left_cancel_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_91768 (h1 : has_mem.mem (normed_group congr_arg_kind) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (normed_group.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_91769 (h0 : uniform_space (boolean_algebra (add_comm_monoid (has_neg_part Type)))) : separated_space (boolean_algebra (add_comm_monoid (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_91770 (h0 : topological_space (has_Inf (has_add linarith.comp))) : totally_separated_space (has_Inf (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_91771 (h0 : complete_lattice (semigroup (has_add pos))) : complete_lattice.is_Sup_finite_compact (semigroup (has_add pos)) := sorry --non-trivial
lemma new_lemma_91772 (h0 : filter (has_nndist Type)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_91773 (h0 : has_mem.mem (has_norm linarith.comp) has_emptyc.emptyc) : @rank_condition.{0} (has_norm.{0} linarith.comp) (@finset.pi.empty.{1 0} Type ring.{0} (has_norm.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_91774 (h0 : function.extfun (Type 1) ordered_add_comm_monoid) : @archimedean.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} h0 (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_91775 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (comm_group name)) := sorry --non-trivial
lemma new_lemma_91776 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_91777 (h0 : measurable_space (nondiscrete_normed_field (mul_one_class ereal))) (h1 : measure_theory.measure (nondiscrete_normed_field (mul_one_class ereal))) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_91778 (h0 : topological_space (has_neg (normed_comm_ring unsigned))) : topological_space.separable_space (has_neg (normed_comm_ring unsigned)) := sorry --non-trivial
lemma new_lemma_91779 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_91780 (h0 : topological_space (complete_distrib_lattice (normed_comm_ring name))) : locally_compact_space (complete_distrib_lattice (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_91781 (h0 : function.extfun Type (functor.add_const (complete_lattice (boolean_algebra.core pos)))) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} pos)) (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} pos))) h0 (has_neg_part.{0} pos)))  := sorry --non-trivial
lemma new_lemma_91782 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (non_assoc_semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_91783 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf pos))) : normal_space (normed_lattice_add_comm_group (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_91784 (h0 : function.extfun Type topological_space) : @t0_space.{0} (comm_ring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_ring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_91785 (h0 : ring (encodable (has_inv (group_with_zero linarith.ineq)))) : rank_condition (encodable (has_inv (group_with_zero linarith.ineq))) := sorry --non-trivial
lemma new_lemma_91786 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_91787 (h0 : ring (normed_comm_ring (option ennreal))) : strong_rank_condition (normed_comm_ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_91788 (h0 : functor.add_const (function.extfun Type semiring) name) : @is_noetherian_ring.{0} pos (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) name h0) pos)  := sorry --non-trivial
lemma new_lemma_91789 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_91790 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_91791 (h0 : ring (has_emptyc (random_gen linarith.comp_source))) : is_domain (has_emptyc (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_91792 (h0 : add_group (has_nnnorm string)) : is_add_cyclic (has_nnnorm string) := sorry --non-trivial
lemma new_lemma_91793 (h0 : functor.add_const (topological_space (measure_theory.measure_space congr_arg_kind)) congr_arg_kind) : @preirreducible_space.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (measure_theory.measure_space.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_91794 (h0 : functor.add_const (function.extfun Type ring) (ring environment.implicit_infer_kind)) : @rank_condition.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (ring.{0} environment.implicit_infer_kind) h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_91795 (h0 : functor.add_const (complete_lattice (has_bot empty)) (semiring (semiring (semiring empty)))) : @is_compactly_generated.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_bot.{0} empty)) (semiring.{0} (semiring.{0} (semiring.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_91796 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @irreducible_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_91797 (h0 : set (nondiscrete_normed_field (add_comm_semigroup ereal) -> enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_91798 (h0 : topological_space (measurable_space.dynkin_system (semiring (semiring unsigned)))) : preirreducible_space (measurable_space.dynkin_system (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_91799 (h0 : eq (ring (has_append string_imp)) string_imp) (h1 : not (string_imp -> false)) : @is_domain.{0} (has_append.{0} string_imp) (@eq.mpr.{1} (ring.{0} (has_append.{0} string_imp)) string_imp h0 (@classical.by_contradiction'.{1} string_imp h1))  := sorry --non-trivial
lemma new_lemma_91800 (h0 h1 : fun_info -> ereal) : set.separates_points (set.Ioc h0 h1) := sorry --non-trivial
lemma new_lemma_91801 (h0 : not (has_mem.mem (has_top empty) has_emptyc.emptyc -> false)) : @add_monoid.fg.{0} (has_top.{0} empty) (@finset.pi.empty.{1 0} Type add_monoid.{0} (has_top.{0} empty) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} empty) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_91802 (h0 : not (ring (simple_graph string_imp) -> false)) : @strong_rank_condition.{0} (simple_graph.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (simple_graph.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_91803 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} (has_one.{0} empty)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (random_gen.{0} (has_one.{0} empty)))  := sorry --non-trivial
lemma new_lemma_91804 (h0 : ring (normed_lattice_add_comm_group (has_add linarith.comp))) : rank_condition (normed_lattice_add_comm_group (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_91805 (h0 : finset (has_neg_part (boolean_algebra linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_91806 (h0 : functor.add_const (topological_space (has_neg pos)) Type) : @normal_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_91807 (h0 : finset (add_left_cancel_semigroup unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_91808 (h0 : not (monoid (left_cancel_semigroup (semiring (semiring (semiring (semiring congr_arg_kind))))) -> false)) : @monoid.fg.{0} (left_cancel_semigroup.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} congr_arg_kind))))) (@classical.by_contradiction'.{1} (monoid.{0} (left_cancel_semigroup.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} congr_arg_kind)))))) h0)  := sorry --non-trivial
lemma new_lemma_91809 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_91810 (h0 : complete_lattice (measurable_space (has_inv (has_norm (random_gen (has_inv to_additive.value_type)))))) : is_atomistic (measurable_space (has_inv (has_norm (random_gen (has_inv to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_91811 (h0 : group (has_neg linarith.comp)) : is_simple_group (has_neg linarith.comp) := sorry --non-trivial
lemma new_lemma_91812 (h0 : filter (has_top (has_top (with_bot (has_norm (has_norm (has_norm to_additive.value_type))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_91813 (h0 : add_group (semi_normed_comm_ring (has_inv string_imp))) : is_add_cyclic (semi_normed_comm_ring (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_91814 (h0 : filter (has_nndist (option (option empty)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_91815 (h0 : functor.add_const (finset (normed_comm_ring linarith.comp)) (finset Type)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_91816 (h0 : topological_space (measure_theory.measure_space (semiring empty))) : discrete_topology (measure_theory.measure_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_91817 (h0 : ring (with_one (semiring num))) : strong_rank_condition (with_one (semiring num)) := sorry --non-trivial
lemma new_lemma_91818 (h0 : functor.add_const (ring (add_semigroup empty)) empty) : @rank_condition.{0} (add_semigroup.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (add_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_91819 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (semi_normed_comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_91820 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @monoid.fg.{0} (simple_graph.{0} pos) (@matrix.vec_empty.{0} (monoid.{0} (simple_graph.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_91821 (h0 : not (ring (has_div (mul_one_class char)) -> false)) : @is_domain.{0} (has_div.{0} (mul_one_class.{0} char)) (@classical.by_contradiction'.{1} (ring.{0} (has_div.{0} (mul_one_class.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_91822 (h1 : not (complete_lattice (semi_normed_ring string_imp) -> false)) : @is_compactly_generated.{0} (semi_normed_ring.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semi_normed_ring.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_91823 (h0 : not (ring (complete_semilattice_Sup congr_arg_kind) -> false)) : @rank_condition.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (complete_semilattice_Sup.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_91824 (h0 : complete_lattice (left_cancel_monoid (semiring num))) : complete_lattice.is_Sup_finite_compact (left_cancel_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_91825 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (ordered_comm_ring.{0} name) (@matrix.vec_empty.{0} (add_group.{0} (ordered_comm_ring.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_91826 (h0 : semiring reducibility_hints) (h1 : ring (polynomial reducibility_hints)) : is_domain (polynomial reducibility_hints) := sorry --non-trivial
lemma new_lemma_91827 (h0 : function.extfun Type topological_space) : @t1_space.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_91828 (h0 : not (topological_space (linear_ordered_semiring unsigned) -> false)) : @topological_space.separable_space.{0} (linear_ordered_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_91829 (h0 : not (filter (encodable linarith.ineq) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_91830 (h0 : functor.add_const (topological_space (ring Type)) linarith.comp) : @path_connected_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_91831 (h0 : complete_lattice (has_inter congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (has_inter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_91832 (h0 : functor.add_const (complete_lattice (has_neg unsigned)) pos) : @is_atomistic.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_91833 (h0 : function.extfun (Type 1) uniform_space) : @complete_space.{1} (has_bot.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (has_bot.{1} Type))  := sorry --non-trivial
lemma new_lemma_91834 (h0 : ring (has_bot real)) : is_principal_ideal_ring (has_bot real) := sorry --non-trivial
lemma new_lemma_91835 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_91836 (h0 : add_monoid (ordered_comm_monoid (has_nndist Type))) : add_monoid.fg (ordered_comm_monoid (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_91837 (h0 : topological_space (pseudo_metric_space pos)) : locally_compact_space (pseudo_metric_space pos) := sorry --non-trivial
lemma new_lemma_91838 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_91839 (h0 : topological_space (has_nndist (mul_zero_class (mul_zero_class name)))) : locally_compact_space (has_nndist (mul_zero_class (mul_zero_class name))) := sorry --non-trivial
lemma new_lemma_91840 (h0 : topological_space (has_to_string (has_to_string pos))) : regular_space (has_to_string (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_91841 (h0 : ring (distrib_lattice (has_inv (metric_space (random_gen to_additive.value_type))))) : is_domain (distrib_lattice (has_inv (metric_space (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_91842 (h0 : order_hom nat (list Prop)) : list.tfae (monotonic_sequence_limit h0) := sorry --non-trivial
lemma new_lemma_91843 (h0 : topological_space (has_neg (has_add pos))) : regular_space (has_neg (has_add pos)) := sorry --non-trivial
lemma new_lemma_91844 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (mul_zero_class.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (mul_zero_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_91845 (h0 : ring (normed_comm_ring (option (option (option unsigned))))) : is_domain (normed_comm_ring (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_91846 (h0 : topological_space (has_Inf (ordered_ring name))) : totally_separated_space (has_Inf (ordered_ring name)) := sorry --non-trivial
lemma new_lemma_91847 (h0 : functor.comp uniform_space has_add pos) : @separated_space.{0} (has_add.{0} pos) (@functor.comp.run.{0 0 0} uniform_space.{0} has_add.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_91848 (h0 : ring (finset (comm_group (has_to_string (comm_group Type))))) : is_domain (finset (comm_group (has_to_string (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_91849 (h0 : uniform_space (topological_space (has_nnnorm fun_info))) : complete_space (topological_space (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_91850 (h0 : functor.add_const (group (has_nndist Type)) pos) : @is_simple_group.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_nndist.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_91851 (h0 : functor.add_const (finset (simple_graph linarith.comp)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_91852 (h0 : topological_space (finset (ordered_cancel_add_comm_monoid congr_arg_kind))) : loc_path_connected_space (finset (ordered_cancel_add_comm_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_91853 (h0 : topological_space (add_group (semiring real))) : topological_space.separable_space (add_group (semiring real)) := sorry --non-trivial
lemma new_lemma_91854 (h0 : fin has_zero.zero) : @separated_space.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (comm_semigroup.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_91855 (h1 : topological_space (simple_graph (mul_one_class linarith.ineq))) (h2 : preorder (simple_graph (mul_one_class linarith.ineq))) : order_topology (simple_graph (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_91856 (h0 : topological_space (random_gen unsigned)) : t0_space (random_gen unsigned) := sorry --non-trivial
lemma new_lemma_91857 (h0 : list (has_neg (has_neg (finset linarith.comp)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_91858 (h1 : topological_space fun_info) : irreducible_space fun_info := sorry --non-trivial
lemma new_lemma_91859 (h0 : topological_space (simple_graph unsigned)) : irreducible_space (simple_graph unsigned) := sorry --non-trivial
lemma new_lemma_91860 (h0 : topological_space (boolean_algebra.core (has_add Type))) : irreducible_space (boolean_algebra.core (has_add Type)) := sorry --non-trivial
lemma new_lemma_91861 (h0 : add_group ennreal) : is_add_cyclic ennreal := sorry --non-trivial
lemma new_lemma_91862 (h0 : cancel_comm_monoid_with_zero char) : unique_factorization_monoid char := sorry --non-trivial
lemma new_lemma_91863 (h0 : ring (linear_ordered_field pos)) : rank_condition (linear_ordered_field pos) := sorry --non-trivial
lemma new_lemma_91864 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (div_inv_monoid linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_91865 (h0 : monoid (semigroup (comm_group pos))) : monoid.fg (semigroup (comm_group pos)) := sorry --non-trivial
lemma new_lemma_91866 (h0 : uniform_space (has_neg (add_comm_monoid Type))) : separated_space (has_neg (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_91867 (h0 : partial_order (partial_order unsigned) -> partial_order (partial_order unsigned) -> Prop) : is_strict_order (partial_order (partial_order unsigned)) h0 := sorry --non-trivial
lemma new_lemma_91868 (h0 : measurable_space to_additive.value_type) (h1 : not (topological_space to_additive.value_type -> false)) (h2 : measure_theory.measure to_additive.value_type) : @measure_theory.measure.regular.{0} to_additive.value_type h0 (@classical.by_contradiction'.{1} (topological_space.{0} to_additive.value_type) h1) h2  := sorry --non-trivial
lemma new_lemma_91869 (h0 : functor.add_const (filter (ring unsigned)) ennreal) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_91870 (h0 : complete_lattice (with_one (with_bot string_imp))) : complete_lattice.is_Sup_finite_compact (with_one (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_91871 (h0 : filter (mul_zero_class name)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_91872 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) (has_zero Type)) : @topological_space.separable_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (add_cancel_monoid.{1} Type)) (has_zero.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_91873 (h0 : complete_lattice (dlist (has_nnnorm linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (dlist (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_91874 (h0 : function.extfun Type topological_space) : preirreducible_space nnreal := sorry --non-trivial
lemma new_lemma_91875 (h0 : complete_lattice (has_nndist (has_neg name))) : is_compactly_generated (has_nndist (has_neg name)) := sorry --non-trivial
lemma new_lemma_91876 (h0 : topological_space (canonically_ordered_comm_semiring Type)) : totally_separated_space (canonically_ordered_comm_semiring Type) := sorry --non-trivial
lemma new_lemma_91877 (h0 : function.extfun nat fin) : @is_noetherian_ring.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (semiring.{1} (canonically_linear_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_91878 (h0 : topological_space (add_cancel_monoid (comm_group (has_add name)))) : totally_separated_space (add_cancel_monoid (comm_group (has_add name))) := sorry --non-trivial
lemma new_lemma_91879 (h0 : monoid (has_top (semiring (semiring congr_arg_kind)))) : monoid.fg (has_top (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_91880 (h0 : not (topological_space (has_top empty) -> false)) : @totally_disconnected_space.{0} (has_top.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_91881 (h0 : functor.add_const (list (add_left_cancel_semigroup unsigned)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_91882 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_91883 (h0 : complete_lattice (has_top (has_top unsigned))) : is_atomistic (has_top (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_91884 (h0 : functor.add_const (ring (semigroup pos)) name) : @strong_rank_condition.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_91885 (h0 : functor.add_const (topological_space (has_add ennreal)) pos) : @regular_space.{0} (has_add.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_91886 (h0 : topological_space (has_ssubset (mul_one_class fun_info))) : t0_space (has_ssubset (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_91887 (h0 : nat) (h1 : topological_space (zmod h0)) : totally_separated_space (zmod h0) := sorry --non-trivial
lemma new_lemma_91888 (h0 : function.extfun (finset Type) (has_mem.mem Prop)) : @multiset.inf.{0} Prop (@lattice.to_semilattice_inf.{0} Prop (@conditionally_complete_lattice.to_lattice.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice))) (@bounded_order.to_order_top.{0} Prop (@preorder.to_has_le.{0} Prop (@partial_order.to_preorder.{0} Prop (@semilattice_inf.to_partial_order.{0} Prop (@lattice.to_semilattice_inf.{0} Prop (@conditionally_complete_lattice.to_lattice.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)))))) Prop.bounded_order) (@finset.pi.empty.{1 0} Type multiset.{0} Prop (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) Prop) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_91889 (h0 : function.extfun nat fin) : @totally_separated_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_91890 (h0 : ring (semigroup Type)) : is_principal_ideal_ring (semigroup Type) := sorry --non-trivial
lemma new_lemma_91891 (h0 : complete_lattice (semiring (random_gen num))) : is_compactly_generated (semiring (random_gen num)) := sorry --non-trivial
lemma new_lemma_91892 (h0 : ring (has_pos_part (has_Inf (has_Inf (finset (has_Inf linarith.comp)))))) : rank_condition (has_pos_part (has_Inf (has_Inf (finset (has_Inf linarith.comp))))) := sorry --non-trivial
lemma new_lemma_91893 (h0 : list (comm_group (has_add (has_add Type)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_91894 (h0 : ring (normed_group (has_norm num))) : is_domain (normed_group (has_norm num)) := sorry --non-trivial
lemma new_lemma_91895 (h0 : topological_space (has_zero unsigned)) : path_connected_space (has_zero unsigned) := sorry --non-trivial
lemma new_lemma_91896 (h0 : ring (semiring to_additive.value_type)) : is_domain (semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_91897 (h0 : topological_space (ordered_ring (semiring unsigned))) : totally_separated_space (ordered_ring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_91898 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_91899 (h0 : functor.add_const (topological_space (free_add_monoid empty)) empty) : @topological_space.separable_space.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_91900 (h0 : semiring linarith.ineq) (h3 : ideal linarith.ineq) : ideal.is_prime h3 := sorry --non-trivial
lemma new_lemma_91901 (h1 : filter (add_left_cancel_monoid linarith.comp_source)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_91902 (h0 : complete_lattice (with_one (semiring (has_norm (has_norm empty))))) : is_compactly_generated (with_one (semiring (has_norm (has_norm empty)))) := sorry --non-trivial
lemma new_lemma_91903 (h0 : not (group (has_compl linarith.ineq) -> false)) : @group.fg.{0} (has_compl.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (has_compl.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_91904 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @is_principal_ideal_ring.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_91905 (h0 : functor.add_const (uniform_space (finset unsigned)) pos) : @separated_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (finset.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_91906 (h0 : functor.add_const (topological_space (mul_zero_class pos)) unsigned) : @path_connected_space.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_91907 (h0 : finset (has_Inf (has_neg (has_neg Type)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_91908 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_91909 (h0 : topological_space (monoid (option pos))) : normal_space (monoid (option pos)) := sorry --non-trivial
lemma new_lemma_91910 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_nnnorm.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nnnorm.{0} char))  := sorry --non-trivial
lemma new_lemma_91911 (h0 : ordered_add_comm_monoid (boolean_algebra (has_Inf (has_Inf (finset (has_Inf (finset linarith.comp))))))) : archimedean (boolean_algebra (has_Inf (has_Inf (finset (has_Inf (finset linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_91912 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_91913 (h0 : functor.add_const (ring (is_R_or_C unsigned)) unsigned) : @strong_rank_condition.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (is_R_or_C.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_91914 (h0 : function.extfun Type ring) : @rank_condition.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_91915 (h0 : add_group (add_comm_monoid (option (option pos)))) : is_add_cyclic (add_comm_monoid (option (option pos))) := sorry --non-trivial
lemma new_lemma_91916 (h0 : functor.add_const (topological_space (finset linarith.comp)) environment.implicit_infer_kind) : @sequential_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_91917 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_simple_group.{0} (complete_distrib_lattice.{0} name) (@matrix.vec_empty.{0} (group.{0} (complete_distrib_lattice.{0} name)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_91918 (h0 : fin has_zero.zero) : @sequential_space.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_91919 (h0 : topological_space (has_neg (has_to_string (has_to_string congr_arg_kind)))) : normal_space (has_neg (has_to_string (has_to_string congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_91920 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_Sup num)) := sorry --non-trivial
lemma new_lemma_91921 (h0 : complete_lattice (linear_ordered_add_comm_group linarith.comp_source)) : is_compactly_generated (linear_ordered_add_comm_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_91922 (h0 : group (has_nndist pos)) : normalizer_condition (has_nndist pos) := sorry --non-trivial
lemma new_lemma_91923 (h0 : list (canonically_ordered_add_monoid congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_91924 (h0 : functor.add_const (monoid (cancel_monoid environment.implicit_infer_kind)) name) : @monoid.fg.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_91925 (h0 : ring (has_add (comm_group (has_add name)))) : is_domain (has_add (comm_group (has_add name))) := sorry --non-trivial
lemma new_lemma_91926 (h0 : topological_space (ring (finset pos))) : normal_space (ring (finset pos)) := sorry --non-trivial
lemma new_lemma_91927 (h0 : function.extfun Type ring) : @rank_condition.{0} congr_arg_kind (@function.extfun_app.{2 1} Type ring.{0} h0 congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_91928 (h0 : uniform_space (sub_neg_monoid name)) : complete_space (sub_neg_monoid name) := sorry --non-trivial
lemma new_lemma_91929 (h0 : has_mem.mem ring has_emptyc.emptyc) : @rank_condition.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_91930 (h1 : not (filter (distrib_lattice to_additive.value_type) -> false)) : filter.ne_bot (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_91931 (h0 : topological_space (ring (has_add name))) : sequential_space (ring (has_add name)) := sorry --non-trivial
lemma new_lemma_91932 (h0 : topological_space (ordered_comm_monoid (finset Type))) : t0_space (ordered_comm_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_91933 (h0 : topological_space (normed_lattice_add_comm_group (ordered_comm_monoid (has_Inf (has_Inf Type))))) : discrete_topology (normed_lattice_add_comm_group (ordered_comm_monoid (has_Inf (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_91934 (h0 : not (add_group (left_cancel_semigroup unsigned) -> false)) : @is_add_cyclic.{0} (left_cancel_semigroup.{0} unsigned) (@classical.by_contradiction'.{1} (add_group.{0} (left_cancel_semigroup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_91935 (h0 : topological_space (has_norm string_imp)) : totally_disconnected_space (has_norm string_imp) := sorry --non-trivial
lemma new_lemma_91936 (h0 : cancel_comm_monoid_with_zero (has_to_string (boolean_algebra (has_zero name)))) : unique_factorization_monoid (has_to_string (boolean_algebra (has_zero name))) := sorry --non-trivial
lemma new_lemma_91937 (h0 : topological_space (ordered_comm_monoid (ordered_comm_monoid (has_Inf pos)))) : totally_separated_space (ordered_comm_monoid (ordered_comm_monoid (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_91938 (h0 : functor.comp topological_space has_nndist ennreal) : @topological_space.separable_space.{0} (has_nndist.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_91939 (h1 : add_group (distrib_lattice linarith.ineq)) : is_add_cyclic (distrib_lattice linarith.ineq) := sorry --non-trivial
lemma new_lemma_91940 (h0 : functor.add_const (complete_lattice (has_nndist pos)) name) : @is_atomistic.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_91941 (h0 : topological_space (semi_normed_comm_ring linarith.ineq)) : locally_compact_space (semi_normed_comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_91942 (h0 : function.extfun Type (functor.comp uniform_space has_to_string)) : @separated_space.{0} (has_to_string.{0} pos) (@functor.comp.run.{0 0 0} uniform_space.{0} has_to_string.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} uniform_space.{0} has_to_string.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_91943 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_91944 (h0 : complete_lattice (plift (semiring empty))) : is_compactly_generated (plift (semiring empty)) := sorry --non-trivial
lemma new_lemma_91945 (h0 : functor.add_const (ordered_comm_monoid (normed_comm_ring pos)) (has_pos_part Type)) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (normed_comm_ring.{0} pos)) (has_pos_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_91946 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_91947 (h0 : add_group (semigroup (has_zero linarith.comp))) : is_add_cyclic (semigroup (has_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_91948 (h1 : pfun fun_info Prop) (h2 : coe_sort (pfun.dom h1)) : pfun.as_subtype h1 h2 := sorry --non-trivial
lemma new_lemma_91949 (h0 : topological_space (has_Sup (semiring (semiring num)))) : discrete_topology (has_Sup (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_91950 (h0 : monoid (has_inner unsigned unsigned)) : monoid.fg (has_inner unsigned unsigned) := sorry --non-trivial
lemma new_lemma_91951 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_91952 (h0 : functor.add_const (topological_space (semigroup pos)) (has_neg Type)) : @regular_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_91953 (h0 : topological_space (mul_zero_class (finset (has_add (finset (finset (finset ennreal))))))) : path_connected_space (mul_zero_class (finset (has_add (finset (finset (finset ennreal)))))) := sorry --non-trivial
lemma new_lemma_91954 (h0 : topological_space (has_zero (has_add name))) : irreducible_space (has_zero (has_add name)) := sorry --non-trivial
lemma new_lemma_91955 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) linarith.comp) : @path_connected_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_91956 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) linarith.comp) : @discrete_topology.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_91957 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_91958 (h0 : complete_lattice (has_add (order_dual linarith.comp))) : complete_lattice.is_Sup_finite_compact (has_add (order_dual linarith.comp)) := sorry --non-trivial
lemma new_lemma_91959 (h0 : topological_space (cancel_monoid (boolean_algebra Type))) : sequential_space (cancel_monoid (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_91960 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_91961 (h0 : uniform_space (comm_monoid unsigned)) : separated_space (comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_91962 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_91963 (h2 : group (id num)) : group.fg (id num) := sorry --non-trivial
lemma new_lemma_91964 (h1 : complete_lattice (simple_graph reducibility_hints)) : is_compactly_generated (simple_graph reducibility_hints) := sorry --non-trivial
lemma new_lemma_91965 (h0 : topological_space (normed_comm_ring (has_add linarith.comp))) : irreducible_space (normed_comm_ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_91966 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_91967 (h0 : complete_lattice (has_bot empty)) : is_compactly_generated (has_bot empty) := sorry --non-trivial
lemma new_lemma_91968 (h1 : topological_space (has_emptyc (has_norm congr_arg_kind))) : t0_space (has_emptyc (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_91969 (h0 : function.extfun Type (functor.add_const (list (bin_tree unsigned)))) : list.nodup (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_91970 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_91971 (h0 : topological_space (linear_ordered_comm_group num)) : preconnected_space (linear_ordered_comm_group num) := sorry --non-trivial
lemma new_lemma_91972 (h0 : topological_space (has_top (semiring unsigned))) : irreducible_space (has_top (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_91973 (h0 : complete_lattice (ordered_comm_monoid (has_neg pos))) : is_compactly_generated (ordered_comm_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_91974 (h0 : topological_space (comm_group unsigned)) : topological_space.separable_space (comm_group unsigned) := sorry --non-trivial
lemma new_lemma_91975 (h0 : monoid (measurable_space (has_norm linarith.comp))) : monoid.fg (measurable_space (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_91976 (h0 : functor.add_const (group (mul_zero_class unsigned)) unsigned) : @normalizer_condition.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (mul_zero_class.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_91977 (h0 : functor.add_const (group (semigroup Type)) linarith.comp) : @group.fg.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (semigroup.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_91978 (h1 : topological_space (dlist linarith.ineq)) : path_connected_space (dlist linarith.ineq) := sorry --non-trivial
lemma new_lemma_91979 (h0 : topological_space (linear_ordered_comm_ring (semiring unsigned))) : t1_space (linear_ordered_comm_ring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_91980 (h0 : topological_space string_imp) : totally_separated_space string_imp := sorry --non-trivial
lemma new_lemma_91981 (h0 : topological_space (comm_ring (random_gen fun_info))) : irreducible_space (comm_ring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_91982 (h0 : functor.add_const (group (add_comm_monoid pos)) pos) : @is_simple_group.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_91983 (h0 : function.extfun Type group) : @is_simple_group.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_91984 (h0 : topological_space (semigroup (has_neg_part pos))) : regular_space (semigroup (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_91985 (h0 : functor.add_const (topological_space (has_neg Type)) ennreal) : @totally_disconnected_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_91986 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} ordering) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_top.{0} ordering))  := sorry --non-trivial
lemma new_lemma_91987 (h0 : cancel_comm_monoid_with_zero (has_Inf (ring name))) : unique_factorization_monoid (has_Inf (ring name)) := sorry --non-trivial
lemma new_lemma_91988 (h0 : ring (has_nndist (has_to_string (has_to_string (has_to_string name))))) : is_principal_ideal_ring (has_nndist (has_to_string (has_to_string (has_to_string name)))) := sorry --non-trivial
lemma new_lemma_91989 (h0 : functor.add_const (topological_space (semigroup unsigned)) empty) : @t0_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_91990 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type monoid.{0} h0 (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_91991 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (mul_zero_class.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} empty))  := sorry --non-trivial
lemma new_lemma_91992 (h0 : topological_space (has_Inf (has_add (has_add name)))) : totally_separated_space (has_Inf (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_91993 (h0 : complete_lattice (boolean_algebra.core (has_to_string pos))) : is_atomistic (boolean_algebra.core (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_91994 (h0 : topological_space (free_add_monoid (option (option (option (option unsigned)))))) : discrete_topology (free_add_monoid (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_91995 (h0 : topological_space (linear_ordered_field (option name))) : t0_space (linear_ordered_field (option name)) := sorry --non-trivial
lemma new_lemma_91996 (h0 : functor.add_const (ring (has_neg_part name)) name) : @is_principal_ideal_ring.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_neg_part.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_91997 (h1 : complete_lattice (with_zero (has_nnnorm char))) : is_compactly_generated (with_zero (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_91998 (h0 : topological_space (finset (finset Type))) : irreducible_space (finset (finset Type)) := sorry --non-trivial
lemma new_lemma_91999 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) name) : @preconnected_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_92000 (h0 : ring (comm_group (comm_group Type))) : is_principal_ideal_ring (comm_group (comm_group Type)) := sorry --non-trivial
lemma new_lemma_92001 (h1 : uniform_space (with_one (has_top linarith.ineq))) : complete_space (with_one (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_92002 (h0 : set (has_nnnorm (has_nnnorm (has_nnnorm (mul_one_class (has_nnnorm enat)))))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_92003 (h0 : ring (has_Inf (has_add pos))) : is_principal_ideal_ring (has_Inf (has_add pos)) := sorry --non-trivial
lemma new_lemma_92004 (h0 : list (boolean_algebra (has_to_string (finset pos)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_92005 (h0 : group (has_neg (option num))) : is_cyclic (has_neg (option num)) := sorry --non-trivial
lemma new_lemma_92006 (h0 : topological_space (semigroup (has_add pos))) : normal_space (semigroup (has_add pos)) := sorry --non-trivial
lemma new_lemma_92007 (h0 : ring (linear_ordered_comm_ring (semiring empty))) : is_domain (linear_ordered_comm_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_92008 (h0 : uniform_space (has_pos_part (has_pos_part pos))) : separated_space (has_pos_part (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_92009 (h0 : normed_comm_ring (has_neg linarith.comp) -> normed_comm_ring (has_neg linarith.comp) -> Prop) : reflexive h0 := sorry --non-trivial
lemma new_lemma_92010 (h0 : complete_lattice (linear_ordered_field pos)) : complete_lattice.is_Sup_finite_compact (linear_ordered_field pos) := sorry --non-trivial
lemma new_lemma_92011 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_92012 (h0 : list (semiring to_additive.value_type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_92013 (h0 : functor.add_const (complete_lattice (add_group unsigned)) unsigned) : @is_compactly_generated.{0} (add_group.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_92014 (h0 : set (set (random_gen linarith.ineq))) : is_countably_spanning h0 := sorry --non-trivial
lemma new_lemma_92015 (h0 : function.extfun (Type 1) complete_lattice) : @is_atomistic.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_92016 (h0 : complete_lattice (topological_space (comm_ring (comm_ring (comm_ring char))))) : is_compactly_generated (topological_space (comm_ring (comm_ring (comm_ring char)))) := sorry --non-trivial
lemma new_lemma_92017 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @locally_compact_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_92018 (h0 : functor.add_const (list (canonically_ordered_comm_semiring linarith.comp)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_92019 (h0 : topological_space (canonically_ordered_monoid pos)) : t1_space (canonically_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_92020 (h0 : finset (has_nndist (finset ennreal))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_92021 (h0 : topological_space (linear_ordered_add_comm_monoid_with_top (option (option ennreal)))) : normal_space (linear_ordered_add_comm_monoid_with_top (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_92022 (h0 : not (has_mem.mem (normed_group num) has_emptyc.emptyc -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (normed_group.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_92023 (h0 : topological_space (complete_distrib_lattice (ring linarith.comp))) : normal_space (complete_distrib_lattice (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_92024 (h0 : functor.add_const (topological_space (semilattice_inf name)) Type) : @discrete_topology.{0} (semilattice_inf.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (semilattice_inf.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_92025 (h0 : functor.add_const (topological_space (semigroup name)) environment.implicit_infer_kind) : @topological_space.separable_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_92026 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot congr_arg_kind))) : @monoid.fg.{0} (with_bot.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type monoid.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_92027 (h0 : complete_lattice (semigroup (option (option (option unsigned))))) : is_atomistic (semigroup (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_92028 (h0 : group (has_to_string (has_neg ennreal))) : is_cyclic (has_to_string (has_neg ennreal)) := sorry --non-trivial
lemma new_lemma_92029 (h0 : ring (has_emptyc (random_gen (random_gen (random_gen linarith.comp_source))))) : strong_rank_condition (has_emptyc (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_92030 (h0 : ring (ring (add_comm_monoid environment.implicit_infer_kind))) : rank_condition (ring (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_92031 (h0 : not (ring (random_gen linarith.comp_source) -> false)) : @is_domain.{0} (random_gen.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_92032 (h0 : ring (simple_graph (mul_one_class to_additive.value_type))) : strong_rank_condition (simple_graph (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_92033 (h0 : topological_space (add_cancel_monoid (has_sdiff pos))) : discrete_topology (add_cancel_monoid (has_sdiff pos)) := sorry --non-trivial
lemma new_lemma_92034 (h0 : group (has_union (has_norm num))) : normalizer_condition (has_union (has_norm num)) := sorry --non-trivial
lemma new_lemma_92035 (h0 : not (topological_space (semiring fun_info) -> false)) : @discrete_topology.{0} (semiring.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_92036 (h0 : functor.add_const (topological_space (has_neg Type)) pos) : @t0_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_92037 (h0 : ring (has_add (has_add name))) : strong_rank_condition (has_add (has_add name)) := sorry --non-trivial
lemma new_lemma_92038 (h0 : topological_space (cancel_monoid (boolean_algebra pos))) : t0_space (cancel_monoid (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_92039 (h0 : complete_lattice (with_bot (has_norm (has_norm empty)))) : is_atomistic (with_bot (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_92040 (h0 : functor.add_const (topological_space (has_add Type)) (has_zero name)) : @irreducible_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) (has_zero.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_92041 (h0 : monoid (has_zero (has_neg_part Type))) : monoid.fg (has_zero (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_92042 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_92043 (h1 : ring (comm_ring string_imp)) : is_domain (comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_92044 (h0 : topological_space (omega_complete_partial_order (semiring empty))) : discrete_topology (omega_complete_partial_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_92045 (h0 : ordered_add_comm_monoid (cancel_monoid unsigned)) : archimedean (cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_92046 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (ordered_ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_92047 (h0 : functor.add_const (topological_space pos) name) : @discrete_topology.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) name h0)  := sorry --non-trivial
lemma new_lemma_92048 (h0 : group (non_assoc_semiring (semiring (semiring unsigned)))) : normalizer_condition (non_assoc_semiring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_92049 (h0 : complete_lattice (normed_field (mul_one_class fun_info))) : complete_lattice.is_Sup_finite_compact (normed_field (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_92050 (h1 : ring (complete_semilattice_Sup linarith.comp)) : is_domain (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_92051 (h0 : ring (has_add (has_neg Type))) : is_domain (has_add (has_neg Type)) := sorry --non-trivial
lemma new_lemma_92052 (h0 : cancel_comm_monoid_with_zero (has_nndist (finset (finset environment.implicit_infer_kind)))) : unique_factorization_monoid (has_nndist (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_92053 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_92054 (h0 : functor.add_const (topological_space (has_to_string pos)) Type) : @normal_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_92055 (h0 : functor.add_const (group (filter unsigned)) unsigned) : @group.fg.{0} (filter.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (filter.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_92056 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_92057 (h0 : topological_space (has_neg_part (cancel_monoid ennreal))) : t0_space (has_neg_part (cancel_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_92058 (h2 : complete_lattice (has_top (has_top linarith.comp_source))) : is_atomistic (has_top (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_92059 (h0 : add_monoid (simple_graph (boolean_algebra.core (boolean_algebra.core (has_Inf linarith.comp))))) : add_monoid.fg (simple_graph (boolean_algebra.core (boolean_algebra.core (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_92060 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @irreducible_space.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_92061 (h0 : topological_space (add_cancel_monoid (sub_neg_monoid (has_neg Type)))) : totally_disconnected_space (add_cancel_monoid (sub_neg_monoid (has_neg Type))) := sorry --non-trivial
lemma new_lemma_92062 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (linear_ordered_field.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_92063 (h0 : semiring (canonically_linear_ordered_monoid Type)) : is_noetherian_ring (canonically_linear_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_92064 (h0 : functor.add_const (list (cancel_monoid name)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_92065 (h0 : uniform_space (add_cancel_comm_monoid unsigned)) : complete_space (add_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_92066 (h0 : functor.add_const (semiring (cancel_monoid ennreal)) environment.implicit_infer_kind) : @is_noetherian_ring.{0} (cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (semiring.{0} (cancel_monoid.{0} ennreal)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_92067 (h0 : finset (ordered_comm_monoid (finset (finset (finset (finset linarith.comp)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_92068 (h0 : complete_lattice (canonically_linear_ordered_monoid num) -> Prop) (h1 : Exists (fun (x : complete_lattice (canonically_linear_ordered_monoid num)), h0 x)) : @is_atomistic.{0} (canonically_linear_ordered_monoid.{0} num) (@classical.some.{1} (complete_lattice.{0} (canonically_linear_ordered_monoid.{0} num)) h0 h1)  := sorry --non-trivial
lemma new_lemma_92069 (h0 : ring (has_Inf (has_add (has_add (has_Inf linarith.comp))))) : rank_condition (has_Inf (has_add (has_add (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_92070 (h0 : topological_space (has_zero pos)) : preconnected_space (has_zero pos) := sorry --non-trivial
lemma new_lemma_92071 (h0 : functor.add_const (topological_space (has_neg Type)) Type) : @irreducible_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_neg.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_92072 (h0 : function.extfun nat fin) : @rank_condition.{1} (has_to_string.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (has_to_string.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))))  := sorry --non-trivial
lemma new_lemma_92073 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) name) : @normal_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_92074 (h0 : functor.add_const (topological_space (cancel_monoid linarith.comp)) (has_neg Type)) : @t0_space.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_92075 (h0 : topological_space (topological_space (has_nnnorm reducibility_hints))) : t0_space (topological_space (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_92076 (h0 : topological_space (distrib (semiring linarith.comp))) : totally_separated_space (distrib (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_92077 (h0 : functor.add_const (function.extfun Type group) Type) : @normalizer_condition.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_92078 (h0 : complete_lattice (distrib_lattice (has_inv string_imp))) : is_compactly_generated (distrib_lattice (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_92079 (h0 : topological_space (ordered_comm_ring (has_to_string linarith.comp))) : preirreducible_space (ordered_comm_ring (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_92080 (h0 : add_group (with_one (semiring unsigned))) : is_add_cyclic (with_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_92081 (h0 : ordered_comm_monoid (boolean_algebra.core (ring Type))) : has_exists_mul_of_le (boolean_algebra.core (ring Type)) := sorry --non-trivial
lemma new_lemma_92082 (h0 : group (normed_comm_ring (has_add Type))) : normalizer_condition (normed_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_92083 (h0 : functor.add_const (topological_space (normed_linear_ordered_group empty)) empty) : @path_connected_space.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_92084 (h1 : uniform_space (comm_ring (has_nnnorm (has_nnnorm to_additive.value_type)))) : complete_space (comm_ring (has_nnnorm (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_92085 (h0 : functor.add_const (function.extfun Type group) (has_neg environment.implicit_infer_kind)) : @group.fg.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) (has_neg.{0} environment.implicit_infer_kind) h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_92086 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_92087 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_92088 (h0 : ordered_comm_monoid (linear_ordered_field (option empty))) : has_exists_mul_of_le (linear_ordered_field (option empty)) := sorry --non-trivial
lemma new_lemma_92089 (h0 : topological_space (add_comm_semigroup fun_info)) (h1 : set (set (add_comm_semigroup fun_info))) : topological_space.is_topological_basis h1 := sorry --non-trivial
lemma new_lemma_92090 (h0 : topological_space (distrib fun_info)) (h1 : not (preorder (distrib fun_info) -> false)) : @order_topology.{0} (distrib.{0} fun_info) h0 (@classical.by_contradiction'.{1} (preorder.{0} (distrib.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_92091 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_92092 (h0 : functor.add_const (function.extfun Type semiring) (ring environment.implicit_infer_kind)) : @is_noetherian_ring.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) (ring.{0} environment.implicit_infer_kind) h0) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_92093 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_92094 (h0 : ring (has_pos_part (has_Inf (has_Inf linarith.comp)))) : is_domain (has_pos_part (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_92095 (h0 : uniform_space (has_star (semiring (semiring congr_arg_kind)))) : complete_space (has_star (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_92096 (h2 : function.extfun Type topological_space) : @t0_space.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} h2 num)  := sorry --non-trivial
lemma new_lemma_92097 (h0 : topological_space (simple_graph (boolean_algebra.core linarith.comp))) : t0_space (simple_graph (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_92098 (h5 : ring (distrib (has_nnnorm char))) : is_domain (distrib (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_92099 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (encodable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (encodable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_92100 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_92101 (h0 : complete_lattice (normed_group (distrib_lattice string_imp))) : complete_lattice.is_Sup_finite_compact (normed_group (distrib_lattice string_imp)) := sorry --non-trivial
lemma new_lemma_92102 (h0 : fin has_zero.zero) : @strong_rank_condition.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (normed_lattice_add_comm_group.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_92103 (h0 : function.extfun (Type 1) topological_space) : @totally_disconnected_space.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_92104 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_nnnorm.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nnnorm.{0} char))  := sorry --non-trivial
lemma new_lemma_92105 (h0 : filter (distrib_lattice (has_norm string_imp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_92106 (h0 : uniform_space (has_zero (boolean_algebra.core name))) : separated_space (has_zero (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_92107 (h0 : topological_space (pseudo_metric_space (option pos))) : regular_space (pseudo_metric_space (option pos)) := sorry --non-trivial
lemma new_lemma_92108 (h0 : functor.add_const (topological_space (has_nndist unsigned)) num) : @irreducible_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_92109 (h0 : topological_space (has_add (has_add linarith.comp))) : preconnected_space (has_add (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_92110 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_92111 (h0 : ring (complete_linear_order (semiring unsigned))) : strong_rank_condition (complete_linear_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_92112 (h0 : random_gen (has_top linarith.comp_source) -> Prop) : Exists h0 := sorry --non-trivial
lemma new_lemma_92113 (h0 : ordered_add_comm_monoid (has_edist unsigned)) : archimedean (has_edist unsigned) := sorry --non-trivial
lemma new_lemma_92114 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) Type) : @topological_space.separable_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_92115 (h0 : group (monoid pos)) : normalizer_condition (monoid pos) := sorry --non-trivial
lemma new_lemma_92116 (h0 : semiring (pseudo_metric_space (option (option empty)))) : is_noetherian_ring (pseudo_metric_space (option (option empty))) := sorry --non-trivial
lemma new_lemma_92117 (h0 : topological_space (has_zero pos)) : locally_compact_space (has_zero pos) := sorry --non-trivial
lemma new_lemma_92118 (h2 : not (topological_space (comm_ring fun_info) -> false)) : @t0_space.{0} (comm_ring.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (comm_ring.{0} fun_info)) h2)  := sorry --non-trivial
lemma new_lemma_92119 (h0 : measurable_space char) (h2 : topological_space (lex char)) : measurable_set (id (fun (h1 : char), t0_space (lex char))) := sorry --non-trivial
lemma new_lemma_92120 (h0 : nat) (h1 : vector (complete_lattice (has_div linarith.ineq)) (has_add.add h0 has_one.one)) : @complete_lattice.is_Sup_finite_compact.{0} (has_div.{0} linarith.ineq) (@vector.last.{0} h0 (complete_lattice.{0} (has_div.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_92121 (h0 : add_monoid (bin_tree (semiring num))) : add_monoid.fg (bin_tree (semiring num)) := sorry --non-trivial
lemma new_lemma_92122 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_92123 (h0 : complete_lattice (pseudo_metric_space (option pos))) : is_compactly_generated (pseudo_metric_space (option pos)) := sorry --non-trivial
lemma new_lemma_92124 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_92125 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @preirreducible_space.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_92126 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_92127 (h0 : topological_space (complete_distrib_lattice (has_add Type))) : discrete_topology (complete_distrib_lattice (has_add Type)) := sorry --non-trivial
lemma new_lemma_92128 (h0 : topological_space (add_cancel_monoid (ring (semigroup (ring environment.implicit_infer_kind))))) : normal_space (add_cancel_monoid (ring (semigroup (ring environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_92129 (h0 : uniform_space (measure_theory.measure_space empty)) : complete_space (measure_theory.measure_space empty) := sorry --non-trivial
lemma new_lemma_92130 (h0 : ring (has_top (random_gen (has_norm (random_gen (random_gen fun_info)))))) : strong_rank_condition (has_top (random_gen (has_norm (random_gen (random_gen fun_info))))) := sorry --non-trivial
lemma new_lemma_92131 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_92132 (h0 : functor.add_const (topological_space (has_to_string environment.implicit_infer_kind)) name) : @normal_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_92133 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_92134 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_92135 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) environment.implicit_infer_kind) : @t1_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_92136 (h0 : functor.add_const (topological_space (option empty)) num) : @totally_separated_space.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_92137 (h0 : monoid (add_comm_monoid congr_arg_kind)) : monoid.fg (add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_92138 (h0 : not (group (encodable to_additive.value_type) -> false)) : @group.fg.{0} (encodable.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (encodable.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_92139 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_92140 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf (has_Inf (has_Inf Type))))) : totally_separated_space (canonically_linear_ordered_monoid (has_Inf (has_Inf (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_92141 (h0 : topological_space (has_to_string unsigned)) : totally_disconnected_space (has_to_string unsigned) := sorry --non-trivial
lemma new_lemma_92142 (h0 : group (has_ssubset (has_nnnorm to_additive.value_type))) : group.fg (has_ssubset (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_92143 (h0 : functor.add_const (topological_space (boolean_algebra.core ennreal)) Type) : @preirreducible_space.{0} (boolean_algebra.core.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_92144 (h0 : functor.add_const (complete_lattice (boolean_algebra environment.implicit_infer_kind)) Type) : @is_atomistic.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (complete_lattice.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_92145 (h0 : topological_space (has_norm linarith.comp_source)) : t0_space (has_norm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_92146 (h0 : ring (ordered_cancel_add_comm_monoid unsigned)) : strong_rank_condition (ordered_cancel_add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_92147 (h0 : group (boolean_algebra.core (add_comm_monoid environment.implicit_infer_kind))) : is_cyclic (boolean_algebra.core (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_92148 (h0 : uniform_space (measurable_space.dynkin_system (with_bot (has_top unsigned)))) : separated_space (measurable_space.dynkin_system (with_bot (has_top unsigned))) := sorry --non-trivial
lemma new_lemma_92149 (h0 : topological_space (linear_ordered_comm_group pos)) : preconnected_space (linear_ordered_comm_group pos) := sorry --non-trivial
lemma new_lemma_92150 (h0 : functor.add_const (ring (ring Type)) name) : @is_principal_ideal_ring.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_92151 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (canonically_linear_ordered_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_92152 (h3 : has_lt (mul_one_class (add_comm_semigroup ereal))) : no_max_order (mul_one_class (add_comm_semigroup ereal)) := sorry --non-trivial
lemma new_lemma_92153 (h0 : prod (option name) (option name)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_92154 (h0 : add_group (linear_ordered_semiring (semiring congr_arg_kind))) : is_add_cyclic (linear_ordered_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_92155 (h0 : ring (has_append (has_ssubset (has_ssubset (has_ssubset char))))) : rank_condition (has_append (has_ssubset (has_ssubset (has_ssubset char)))) := sorry --non-trivial
lemma new_lemma_92156 (h0 : topological_space (has_to_string (add_cancel_monoid (boolean_algebra Type)))) : normal_space (has_to_string (add_cancel_monoid (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_92157 (h2 : monoid char) (h3 : topological_space (conj_classes char)) : topological_space.first_countable_topology (conj_classes char) := sorry --non-trivial
lemma new_lemma_92158 (h0 : add_group environment.projection_info -> Prop) (h1 : Exists (fun (x : add_group environment.projection_info), h0 x)) : @is_add_cyclic.{0} environment.projection_info (@classical.some.{1} (add_group.{0} environment.projection_info) h0 h1)  := sorry --non-trivial
lemma new_lemma_92159 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_Inf Type)) : @preconnected_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_Inf.{1} Type) h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_92160 (h0 : ring (has_nndist (has_Inf (has_Inf pos)))) : strong_rank_condition (has_nndist (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_92161 (h0 : complete_lattice (comm_group (boolean_algebra Type))) : complete_lattice.is_Sup_finite_compact (comm_group (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_92162 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (boolean_algebra.core.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_92163 (h0 : ordered_add_comm_monoid (sub_neg_monoid (has_bot (has_Inf (has_add pos))))) : archimedean (sub_neg_monoid (has_bot (has_Inf (has_add pos)))) := sorry --non-trivial
lemma new_lemma_92164 (h0 : topological_space (has_lt (random_gen (random_gen (random_gen (random_gen (random_gen string_imp))))))) : t0_space (has_lt (random_gen (random_gen (random_gen (random_gen (random_gen string_imp)))))) := sorry --non-trivial
lemma new_lemma_92165 (h0 : topological_space (canonically_linear_ordered_monoid (option pos))) : loc_path_connected_space (canonically_linear_ordered_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_92166 (h0 : functor.add_const (function.extfun Type ring) environment.implicit_infer_kind) : @is_domain.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) environment.implicit_infer_kind h0) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_92167 (h0 : functor.add_const (list (ring unsigned)) (boolean_algebra pos)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_92168 (h0 : list (has_zero (finset (has_to_string Type)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_92169 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @loc_path_connected_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_92170 (h0 : uniform_space (random_gen (has_nnnorm linarith.comp_source))) : complete_space (random_gen (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_92171 (h0 : functor.add_const (functor.add_const (topological_space subsingleton_info) num) congr_arg_kind) : @normal_space.{0} subsingleton_info (@functor.add_const.run.{0 0} (topological_space.{0} subsingleton_info) num (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} subsingleton_info) num) congr_arg_kind h0))  := sorry --non-trivial
lemma new_lemma_92172 (h0 : uniform_space (complete_linear_order (semiring unsigned))) : separated_space (complete_linear_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_92173 (h0 : uniform_space (partial_order (has_star (has_sub num)))) : separated_space (partial_order (has_star (has_sub num))) := sorry --non-trivial
lemma new_lemma_92174 (h0 : fin has_zero.zero) : @is_simple_group.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (group.{0} (has_bot.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_92175 (h0 : group (add_comm_monoid (sub_neg_monoid pos))) : normalizer_condition (add_comm_monoid (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_92176 (h0 : topological_space congr_arg_kind) : locally_compact_space congr_arg_kind := sorry --non-trivial
lemma new_lemma_92177 (h0 : functor.add_const (functor.add_const (ordered_comm_monoid environment.implicit_infer_kind) linarith.comp) Type) : @has_exists_mul_of_le.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} environment.implicit_infer_kind) linarith.comp (@functor.add_const.run.{0 1} (functor.add_const.{0 0} (ordered_comm_monoid.{0} environment.implicit_infer_kind) linarith.comp) Type h0))  := sorry --non-trivial
lemma new_lemma_92178 (h1 : function.extfun Type topological_space) : @totally_separated_space.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_92179 (h0 : topological_space (has_neg_part (option (has_nndist (option (option pos)))))) : preirreducible_space (has_neg_part (option (has_nndist (option (option pos))))) := sorry --non-trivial
lemma new_lemma_92180 (h0 : topological_space (has_le string.iterator_imp)) : t0_space (has_le string.iterator_imp) := sorry --non-trivial
lemma new_lemma_92181 (h0 : ring ereal) : nonempty (is_field ereal) := sorry --non-trivial
lemma new_lemma_92182 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_compactly_generated.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (comm_semigroup.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_92183 (h0 : ordered_add_comm_monoid (complete_distrib_lattice (ordered_comm_ring (has_neg linarith.comp)))) : archimedean (complete_distrib_lattice (ordered_comm_ring (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_92184 (h0 : list (id fun_info)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_92185 (h0 : add_monoid (comm_group (has_neg_part pos))) : add_monoid.fg (comm_group (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_92186 (h0 : functor.add_const (topological_space (has_zero pos)) (comm_group (comm_group Type))) : @regular_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} pos)) (comm_group.{1} (comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_92187 (h0 : functor.add_const (function.extfun Type filter) name) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (has_neg pos)) := sorry --non-trivial
lemma new_lemma_92188 (h0 : group (has_norm linarith.comp_source)) : is_cyclic (has_norm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_92189 (h0 : functor.add_const (topological_space (bin_tree empty)) (semiring (semiring empty))) : @totally_separated_space.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} empty)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_92190 (h0 : complete_lattice (measurable_space (has_inv (has_inv linarith.comp_source)))) : complete_lattice.is_Sup_finite_compact (measurable_space (has_inv (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_92191 (h0 : functor.add_const (functor.comp list has_nndist name) Type) : palindrome (functor.comp.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_92192 (h0 : list (simple_graph unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_92193 (h0 : prod (has_top unsigned) (has_top unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_92194 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) pos) : @path_connected_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_92195 (h0 : functor.comp complete_lattice has_add ennreal) : @is_atomistic.{0} (has_add.{0} ennreal) (@functor.comp.run.{0 0 0} complete_lattice.{0} has_add.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_92196 (h0 : topological_space (has_neg (has_add pos))) : path_connected_space (has_neg (has_add pos)) := sorry --non-trivial
lemma new_lemma_92197 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_add_comm_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_92198 (h0 : topological_space (add_comm_monoid (has_neg (has_neg Type)))) : regular_space (add_comm_monoid (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_92199 (h0 : group (finset congr_arg_kind)) : is_simple_group (finset congr_arg_kind) := sorry --non-trivial
lemma new_lemma_92200 (h0 : add_group (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source)))) : is_add_cyclic (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_92201 (h0 : topological_space (denumerable (has_nnnorm (has_nnnorm linarith.ineq)))) : path_connected_space (denumerable (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_92202 (h0 : functor.add_const (ordered_comm_monoid (normed_comm_ring ennreal)) unsigned) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} ennreal) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (normed_comm_ring.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_92203 (h0 : has_mem.mem (normed_group linarith.comp_source) has_emptyc.emptyc) : @irreducible_space.{0} (normed_group.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_92204 (h0 : topological_space (has_norm (random_gen to_additive.value_type))) : totally_disconnected_space (has_norm (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_92205 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_92206 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : palindrome (function.extfun_app (function.extfun_app h0 list) (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_92207 (h0 : not (uniform_space (has_ssubset (has_compl char)) -> false)) : @complete_space.{0} (has_ssubset.{0} (has_compl.{0} char)) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_ssubset.{0} (has_compl.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_92208 (h0 : topological_space (add_left_cancel_semigroup linarith.ineq)) (h1 : preorder (add_left_cancel_semigroup linarith.ineq)) : order_topology (add_left_cancel_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_92209 (h0 : functor.add_const (topological_space (has_to_string unsigned)) pos) : @loc_path_connected_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_92210 (h0 : functor.add_const (topological_space (ordered_comm_monoid Type)) name) : @totally_separated_space.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_92211 (h0 : monoid (has_neg_part (has_add name))) : monoid.fg (has_neg_part (has_add name)) := sorry --non-trivial
lemma new_lemma_92212 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) num)  := sorry --non-trivial
lemma new_lemma_92213 (h0 : ring (linear_order congr_arg_kind)) : strong_rank_condition (linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_92214 (h1 : ring (normed_field (random_gen char))) : strong_rank_condition (normed_field (random_gen char)) := sorry --non-trivial
lemma new_lemma_92215 (h0 : group (semi_normed_comm_ring (has_top fun_info))) : group.fg (semi_normed_comm_ring (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_92216 (h0 : topological_space (has_union num)) : topological_space.separable_space (has_union num) := sorry --non-trivial
lemma new_lemma_92217 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_92218 (h1 : topological_space (comm_ring (random_gen linarith.ineq))) : t0_space (comm_ring (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_92219 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_92220 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @totally_separated_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_92221 (h0 : functor.add_const (topological_space (finset name)) pos) : @t1_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_92222 (h0 : functor.add_const (group (has_nndist unsigned)) empty) : @normalizer_condition.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_92223 (h0 : topological_space (add_comm_semigroup environment.projection_info)) (h1 : add_group (add_comm_semigroup environment.projection_info)) : topological_add_group (add_comm_semigroup environment.projection_info) := sorry --non-trivial
lemma new_lemma_92224 (h0 : fin has_zero.zero) : @add_monoid.fg.{0} (has_Inf.{0} pos) (@matrix.vec_empty.{0} (add_monoid.{0} (has_Inf.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_92225 (h0 : functor.add_const (group (has_zero pos)) pos) : @group.fg.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_92226 (h4 : add_group (normed_field (normed_field char))) : is_add_cyclic (normed_field (normed_field char)) := sorry --non-trivial
lemma new_lemma_92227 (h0 : complete_lattice (canonically_ordered_monoid (has_add (has_pos_part Type)))) : is_compactly_generated (canonically_ordered_monoid (has_add (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_92228 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_92229 (h0 : ring (semiring (semiring (semiring (semiring linarith.comp))))) : rank_condition (semiring (semiring (semiring (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_92230 (h0 : functor.add_const (function.extfun (Type 1) group) pos) : @group.fg.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) pos h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_92231 (h0 : group (pseudo_metric_space (option (option (option (option unsigned)))))) : is_simple_group (pseudo_metric_space (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_92232 (h0 : semiring (left_cancel_monoid empty)) : is_noetherian_ring (left_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_92233 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_92234 (h0 : group (comm_ring (has_nnnorm (has_nnnorm (random_gen to_additive.value_type))))) : group.fg (comm_ring (has_nnnorm (has_nnnorm (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_92235 (h0 : list (has_inv (has_ssubset (has_ssubset (random_gen (random_gen fun_info)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_92236 (h1 : group (comm_ring (has_nnnorm (has_nnnorm string_imp)))) : is_cyclic (comm_ring (has_nnnorm (has_nnnorm string_imp))) := sorry --non-trivial
lemma new_lemma_92237 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_disconnected_space.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_92238 (h0 : topological_space (has_neg_part (has_nndist unsigned))) : locally_compact_space (has_neg_part (has_nndist unsigned)) := sorry --non-trivial
lemma new_lemma_92239 (h0 : topological_space (semi_normed_comm_ring string.iterator_imp)) (h1 : preorder (semi_normed_comm_ring string.iterator_imp)) : order_topology (semi_normed_comm_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_92240 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_92241 (h0 : ring (has_Inf (finset (has_add pos)))) : is_domain (has_Inf (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_92242 (h0 : mul_one_class (has_norm num)) (h1 : add_group (monoid.End (has_norm num))) : is_add_cyclic (monoid.End (has_norm num)) := sorry --non-trivial
lemma new_lemma_92243 (h0 : functor.add_const (group (has_Inf name)) Type) : @normalizer_condition.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 1} (group.{0} (has_Inf.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_92244 (h0 : complete_lattice (linear_ordered_field congr_arg_kind)) : is_atomistic (linear_ordered_field congr_arg_kind) := sorry --non-trivial
lemma new_lemma_92245 (h0 : functor.add_const (filter (normed_comm_ring pos)) (has_neg (has_neg Type))) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_92246 (h0 : functor.add_const (monoid (add_cancel_monoid ennreal)) (has_nndist Type)) : @monoid.fg.{0} (add_cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 1} (monoid.{0} (add_cancel_monoid.{0} ennreal)) (has_nndist.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_92247 (h0 : complete_linear_order (complete_linear_order empty) -> complete_linear_order (complete_linear_order empty) -> Prop) : is_strict_order (complete_linear_order (complete_linear_order empty)) h0 := sorry --non-trivial
lemma new_lemma_92248 (h0 : functor.add_const (ring (boolean_algebra.core pos)) environment.implicit_infer_kind) : @rank_condition.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_92249 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_zero linarith.comp)) pos) : @unique_factorization_monoid.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_zero.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_92250 (h0 : topological_space (canonically_linear_ordered_monoid ennreal)) : path_connected_space (canonically_linear_ordered_monoid ennreal) := sorry --non-trivial
lemma new_lemma_92251 (h0 : ring (has_Inf (finset (has_Inf Type)))) : strong_rank_condition (has_Inf (finset (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_92252 (h0 : functor.add_const (ordered_comm_monoid (has_pos_part pos)) name) : @has_exists_mul_of_le.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_pos_part.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_92253 (h0 : topological_space congr_arg_kind) : path_connected_space congr_arg_kind := sorry --non-trivial
lemma new_lemma_92254 (h0 : topological_space (left_cancel_semigroup unsigned)) : t1_space (left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_92255 (h0 : ring (ordered_comm_group (option (option (option empty))))) : is_principal_ideal_ring (ordered_comm_group (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_92256 (h0 : topological_space (has_neg (has_add Type))) : irreducible_space (has_neg (has_add Type)) := sorry --non-trivial
lemma new_lemma_92257 (h0 : complete_lattice (has_div (mul_one_class linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (has_div (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_92258 (h0 : ring (has_nnnorm linarith.ineq)) : is_domain (has_nnnorm linarith.ineq) := sorry --non-trivial
lemma new_lemma_92259 (h0 : topological_space (has_star (semiring unsigned))) : t0_space (has_star (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_92260 (h0 : add_group empty) : is_add_cyclic empty := sorry --non-trivial
lemma new_lemma_92261 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (finset name)) := sorry --non-trivial
lemma new_lemma_92262 (h0 : add_group (semigroup (finset Type))) : is_add_cyclic (semigroup (finset Type)) := sorry --non-trivial
lemma new_lemma_92263 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @loc_path_connected_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_92264 (h1 : function.extfun (finset Type) (has_mem.mem (random_gen to_additive.value_type))) : @totally_separated_space.{0} (random_gen.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} to_additive.value_type)) h1 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_92265 (h0 : topological_space (has_ssubset string.iterator_imp)) : totally_disconnected_space (has_ssubset string.iterator_imp) := sorry --non-trivial
lemma new_lemma_92266 (h0 : group (ordered_cancel_add_comm_monoid num)) : group.fg (ordered_cancel_add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_92267 (h0 : functor.add_const (complete_lattice (add_cancel_monoid num)) unsigned) : @is_compactly_generated.{0} (add_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_92268 (h0 : group (ordered_comm_ring (ring (has_add (finset linarith.comp))))) : normalizer_condition (ordered_comm_ring (ring (has_add (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_92269 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @path_connected_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_92270 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) linarith.comp) : @preconnected_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_92271 (h0 : group (complete_distrib_lattice (has_nndist Type))) : is_simple_group (complete_distrib_lattice (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_92272 (h0 : function.extfun Type (functor.add_const (list (linear_ordered_cancel_comm_monoid unsigned)))) : palindrome (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_92273 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_92274 (h0 : functor.add_const (uniform_space (linear_ordered_cancel_comm_monoid empty)) unsigned) : @complete_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_92275 (h0 : functor.add_const (ring (mul_zero_class num)) (semiring unsigned)) : @is_principal_ideal_ring.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} num)) (semiring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_92276 (h0 : ring (generalized_boolean_algebra (ring pos))) : is_principal_ideal_ring (generalized_boolean_algebra (ring pos)) := sorry --non-trivial
lemma new_lemma_92277 (h0 : group (boolean_algebra.core (has_neg name))) : normalizer_condition (boolean_algebra.core (has_neg name)) := sorry --non-trivial
lemma new_lemma_92278 (h0 : group (sub_neg_monoid (finset (finset (finset pos))))) : is_simple_group (sub_neg_monoid (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_92279 (h0 : add_group (complete_distrib_lattice empty)) : is_add_cyclic (complete_distrib_lattice empty) := sorry --non-trivial
lemma new_lemma_92280 (h0 : monoid (has_add (option (option (option (option (option ennreal))))))) : monoid.fg (has_add (option (option (option (option (option ennreal)))))) := sorry --non-trivial
lemma new_lemma_92281 (h0 : ring (semigroup (comm_group pos))) : is_principal_ideal_ring (semigroup (comm_group pos)) := sorry --non-trivial
lemma new_lemma_92282 (h0 : topological_space (add_group (semiring congr_arg_kind))) : discrete_topology (add_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_92283 (h0 : ring (add_cancel_monoid (has_add (boolean_algebra (boolean_algebra linarith.comp))))) : rank_condition (add_cancel_monoid (has_add (boolean_algebra (boolean_algebra linarith.comp)))) := sorry --non-trivial
lemma new_lemma_92284 (h0 : ring (canonically_ordered_add_monoid empty)) : strong_rank_condition (canonically_ordered_add_monoid empty) := sorry --non-trivial
lemma new_lemma_92285 (h0 : functor.add_const (topological_space (complete_linear_order congr_arg_kind)) num) : @t1_space.{0} (complete_linear_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_linear_order.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_92286 (h0 : ring (normed_comm_ring (comm_group (comm_group unsigned)))) : is_principal_ideal_ring (normed_comm_ring (comm_group (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_92287 (h0 : pnat) (h1 : ulower (fin has_zero.zero)) : pnat.coprime h0 (matrix.vec_empty (matrix.vec_empty (ulower.up h1))) := sorry --non-trivial
lemma new_lemma_92288 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_92289 (h2 : ring ereal) : strong_rank_condition ereal := sorry --non-trivial
lemma new_lemma_92290 (h0 : semiring (has_to_string (semigroup linarith.comp))) : is_noetherian_ring (has_to_string (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_92291 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (canonically_ordered_add_monoid.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_add_monoid.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_92292 (h0 : topological_space (boolean_algebra (has_neg_part (has_neg (has_neg_part Type))))) : preconnected_space (boolean_algebra (has_neg_part (has_neg (has_neg_part Type)))) := sorry --non-trivial
lemma new_lemma_92293 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_nndist.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_nndist.{0} num))  := sorry --non-trivial
lemma new_lemma_92294 (h0 : functor.add_const (topological_space (add_comm_monoid environment.implicit_infer_kind)) name) : @totally_separated_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_92295 (h0 : topological_space (sub_neg_monoid (has_Inf (boolean_algebra.core (has_Inf Type))))) : irreducible_space (sub_neg_monoid (has_Inf (boolean_algebra.core (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_92296 (h0 : set (char -> char)) (h1 : set char) (h2 : char) : set.seq h0 h1 h2 := sorry --non-trivial
lemma new_lemma_92297 (h0 : not (complete_lattice (has_append linarith.ineq) -> false)) : @is_compactly_generated.{0} (has_append.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_append.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_92298 (h0 : ring (partial_order congr_arg_kind)) : rank_condition (partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_92299 (h0 : topological_space (option (mul_zero_class (boolean_algebra.core pos)))) : totally_disconnected_space (option (mul_zero_class (boolean_algebra.core pos))) := sorry --non-trivial
lemma new_lemma_92300 (h0 : function.extfun (Type 1) list) : list.nodup (function.extfun_app h0 (semigroup Type)) := sorry --non-trivial
lemma new_lemma_92301 (h0 : functor.add_const (function.extfun Type finset) pos) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_92302 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_nndist.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} num))  := sorry --non-trivial
lemma new_lemma_92303 (h0 : has_mem.mem (has_top linarith.ineq) has_emptyc.emptyc) : @path_connected_space.{0} (has_top.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_92304 (h0 : topological_space (linear_ordered_field congr_arg_kind)) : topological_space.separable_space (linear_ordered_field congr_arg_kind) := sorry --non-trivial
lemma new_lemma_92305 (h0 : topological_space (linear_ordered_semiring (random_gen congr_arg_kind))) : totally_separated_space (linear_ordered_semiring (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_92306 (h0 : functor.add_const (topological_space (group_with_zero empty)) ennreal) : @totally_disconnected_space.{0} (group_with_zero.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (group_with_zero.{0} empty)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_92307 (h0 : ordered_add_comm_monoid (comm_group (has_add Type))) : archimedean (comm_group (has_add Type)) := sorry --non-trivial
lemma new_lemma_92308 (h0 : topological_space (has_to_string (has_add Type))) : regular_space (has_to_string (has_add Type)) := sorry --non-trivial
lemma new_lemma_92309 (h1 : not (ring (fintype char) -> false)) : @is_domain.{0} (fintype.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (fintype.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_92310 (h0 : topological_space (has_pos_part (has_pos_part Type))) : sequential_space (has_pos_part (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_92311 (h0 : function.extfun ((finset Type -> Prop) -> Prop) (function.extfun (finset Type -> Prop))) : @complete_lattice.is_Sup_finite_compact.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type complete_lattice.{0} linarith.comp_source (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) (@function.extfun_app.{2 0} ((finset.{1} Type → Prop) → Prop) (function.extfun.{2 0} (finset.{1} Type → Prop)) h0 (function.extfun.{2 0} (finset.{1} Type))) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp_source)) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_92312 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (mul_zero_class.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} num))  := sorry --non-trivial
lemma new_lemma_92313 (h0 : semiring (add_cancel_monoid (option (option (option empty))))) : is_noetherian_ring (add_cancel_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_92314 (h0 : ring (free_add_monoid (semiring unsigned))) : rank_condition (free_add_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_92315 (h0 : topological_space (canonically_ordered_comm_semiring (finset (finset linarith.comp)))) : sequential_space (canonically_ordered_comm_semiring (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_92316 (h0 : topological_space (has_add (option (option unsigned)))) : preconnected_space (has_add (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_92317 (h0 : topological_space (comm_ring (has_ssubset char))) : path_connected_space (comm_ring (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_92318 (h0 : ring (has_inv (has_nnnorm (has_nnnorm linarith.comp_source)))) : rank_condition (has_inv (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_92319 (h0 : uniform_space (uniform_space (semilattice_inf linarith.comp_source))) : complete_space (uniform_space (semilattice_inf linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_92320 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra name)) name) : @archimedean.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (boolean_algebra.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_92321 (h0 : functor.add_const (functor.add_const Prop (generalized_boolean_algebra Type)) pos) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_92322 (h0 : has_neg (add_comm_semigroup string.iterator_imp)) (h1 : measurable_space (add_comm_semigroup string.iterator_imp)) : has_measurable_neg (add_comm_semigroup string.iterator_imp) := sorry --non-trivial
lemma new_lemma_92323 (h0 : topological_space (semi_normed_comm_ring to_additive.value_type)) (h1 : add_group (semi_normed_comm_ring to_additive.value_type)) : topological_add_group (semi_normed_comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_92324 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_92325 (h0 : has_lt fun_info) : no_min_order fun_info := sorry --non-trivial
lemma new_lemma_92326 (h1 : not (add_group (has_append linarith.comp_source) -> false)) : @is_add_cyclic.{0} (has_append.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (add_group.{0} (has_append.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_92327 (h0 : topological_space (linear_ordered_add_comm_group (has_nnnorm string_imp))) : totally_disconnected_space (linear_ordered_add_comm_group (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_92328 (h0 : has_to_string (has_to_string Type) -> has_to_string (has_to_string Type) -> Prop) : is_extensional (has_to_string (has_to_string Type)) h0 := sorry --non-trivial
lemma new_lemma_92329 (h0 : ring (ordered_comm_ring (has_neg Type))) : is_domain (ordered_comm_ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_92330 (h0 : ring (complete_linear_order (semiring (semiring unsigned)))) : is_principal_ideal_ring (complete_linear_order (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_92331 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) Type) : @locally_compact_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_92332 (h1 : uniform_space (normed_field (comm_ring char))) : complete_space (normed_field (comm_ring char)) := sorry --non-trivial
lemma new_lemma_92333 (h0 : functor.add_const (ring (cancel_monoid name)) name) : @is_domain.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_92334 (h0 : uniform_space (measurable_space.dynkin_system congr_arg_kind)) : complete_space (measurable_space.dynkin_system congr_arg_kind) := sorry --non-trivial
lemma new_lemma_92335 (h0 : not (add_group (has_add (has_nnnorm (has_nnnorm fun_info))) -> false)) : @is_add_cyclic.{0} (has_add.{0} (has_nnnorm.{0} (has_nnnorm.{0} fun_info))) (@classical.by_contradiction'.{1} (add_group.{0} (has_add.{0} (has_nnnorm.{0} (has_nnnorm.{0} fun_info)))) h0)  := sorry --non-trivial
lemma new_lemma_92336 (h0 : not (group (comm_ring (has_nnnorm linarith.ineq)) -> false)) : @is_cyclic.{0} (comm_ring.{0} (has_nnnorm.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (group.{0} (comm_ring.{0} (has_nnnorm.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_92337 (h0 : topological_space (measurable_space (has_inv linarith.ineq))) : locally_compact_space (measurable_space (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_92338 (h0 : topological_space (comm_group (semigroup (semigroup environment.implicit_infer_kind)))) : t1_space (comm_group (semigroup (semigroup environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_92339 (h1 : function.extfun (finset Type -> Prop) (function.extfun (finset Type))) : @path_connected_space.{0} to_additive.value_type (@finset.pi.empty.{1 0} Type topological_space.{0} to_additive.value_type (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) to_additive.value_type) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) h1 (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) to_additive.value_type)) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_92340 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (ring.{0} (has_add.{0} (has_add.{0} (has_add.{0} (has_add.{0} (has_add.{0} (has_add.{0} pos))))))) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (ring.{0} (has_add.{0} (has_add.{0} (has_add.{0} (has_add.{0} (has_add.{0} (has_add.{0} pos))))))))  := sorry --non-trivial
lemma new_lemma_92341 (h0 : not (group linarith.comp -> false)) : @group.fg.{0} linarith.comp (@classical.by_contradiction'.{1} (group.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_92342 (h1 : complete_lattice (div_inv_monoid to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (div_inv_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_92343 (h0 : complete_lattice (random_gen (random_gen (random_gen linarith.ineq)))) : complete_lattice.is_Sup_finite_compact (random_gen (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_92344 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_92345 (h0 : functor.add_const (topological_space (has_Inf pos)) pos) : @t1_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_92346 (h0 : functor.add_const (uniform_space (has_Sup empty)) empty) : @complete_space.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_Sup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_92347 (h0 : complete_lattice (complete_semilattice_Sup linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (complete_semilattice_Sup linarith.comp_source) := sorry --non-trivial
lemma new_lemma_92348 (h0 : complete_lattice (has_top (semiring num))) : complete_lattice.is_Sup_finite_compact (has_top (semiring num)) := sorry --non-trivial
lemma new_lemma_92349 (h0 : ring (normed_comm_ring (has_nndist pos))) : is_domain (normed_comm_ring (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_92350 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) linarith.comp) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_92351 (h0 : functor.add_const (complete_lattice (normed_comm_ring name)) (comm_group Type)) : @complete_lattice.is_Sup_finite_compact.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (normed_comm_ring.{0} name)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_92352 (h0 : functor.add_const (add_monoid (has_to_string Type)) name) : @add_monoid.fg.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (has_to_string.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_92353 (h0 : topological_space (has_bot (option (option (option unsigned))))) : normal_space (has_bot (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_92354 (h0 : add_group (semigroup (option (option unsigned)))) : is_add_cyclic (semigroup (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_92355 (h0 : ordered_add_comm_monoid (cancel_monoid (add_comm_monoid Type))) : archimedean (cancel_monoid (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_92356 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_zero.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_92357 (h0 : function.extfun nat fin) : @complete_space.{0} (has_bot.{0} linarith.comp) (@matrix.vec_empty.{0} (uniform_space.{0} (has_bot.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_92358 (h0 : functor.add_const (group (complete_distrib_lattice pos)) linarith.comp) : @normalizer_condition.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_92359 (h0 : topological_space (has_pos_part (has_add (has_add pos)))) : topological_space.separable_space (has_pos_part (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_92360 (h0 : ordered_add_comm_monoid (canonically_linear_ordered_monoid (has_Inf Type))) : archimedean (canonically_linear_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_92361 (h0 : add_group (add_cancel_monoid (has_add environment.implicit_infer_kind))) : is_add_cyclic (add_cancel_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_92362 (h0 : function.extfun Type (functor.comp topological_space cancel_monoid)) : @preirreducible_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} cancel_monoid.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_92363 (h0 : not (group (linear_ordered_add_comm_group fun_info) -> false)) : @group.fg.{0} (linear_ordered_add_comm_group.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_add_comm_group.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_92364 (h0 : has_mem.mem (with_bot linarith.ineq) has_emptyc.emptyc) : @irreducible_space.{0} (with_bot.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_92365 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_92366 (h0 : functor.add_const (topological_space (ordered_comm_monoid pos)) (has_pos_part pos)) : @topological_space.separable_space.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} pos)) (has_pos_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_92367 (h0 : not (uniform_space (metric_space linarith.comp) -> false)) : @complete_space.{0} (metric_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (uniform_space.{0} (metric_space.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_92368 (h0 : not (topological_space (measurable_space.dynkin_system unsigned) -> false)) : @irreducible_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.dynkin_system.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_92369 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (ordered_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_92370 (h0 : ring (comm_group (comm_group Type))) : rank_condition (comm_group (comm_group Type)) := sorry --non-trivial
lemma new_lemma_92371 (h0 : has_lt (add_comm_semigroup (mul_one_class enat))) : no_max_order (add_comm_semigroup (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_92372 (h0 : functor.add_const (add_group (add_cancel_monoid environment.implicit_infer_kind)) (has_add Type)) : @is_add_cyclic.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (add_group.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_92373 (h0 : topological_space (with_one (has_norm empty))) : normal_space (with_one (has_norm empty)) := sorry --non-trivial
lemma new_lemma_92374 (h0 : functor.comp list semigroup linarith.comp) : list.nodup (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_92375 (h0 : topological_space (has_neg num)) : totally_separated_space (has_neg num) := sorry --non-trivial
lemma new_lemma_92376 (h0 : topological_space (has_lt (mul_one_class fun_info))) : path_connected_space (has_lt (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_92377 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_92378 (h0 : monoid (has_Sup congr_arg_kind)) : monoid.fg (has_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_92379 (h0 : filter (finset (has_pos_part linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_92380 (h0 h1 : multiset (normed_field ereal)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_92381 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_zero name)) pos) : @unique_factorization_monoid.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_zero.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_92382 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} num (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) num)  := sorry --non-trivial
lemma new_lemma_92383 (h0 : ordered_comm_monoid (semilattice_inf (option (option pos)))) : has_exists_mul_of_le (semilattice_inf (option (option pos))) := sorry --non-trivial
lemma new_lemma_92384 (h0 : uniform_space (normed_lattice_add_comm_group (sub_neg_monoid real))) : separated_space (normed_lattice_add_comm_group (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_92385 (h0 : semiring (has_neg (finset (finset (normed_comm_ring (has_pos_part pos)))))) : is_noetherian_ring (has_neg (finset (finset (normed_comm_ring (has_pos_part pos))))) := sorry --non-trivial
lemma new_lemma_92386 (h0 : not (group (dlist to_additive.value_type) -> false)) : @group.fg.{0} (dlist.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (dlist.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_92387 (h0 : has_mem.mem (has_top linarith.comp_source) has_emptyc.emptyc) : @totally_separated_space.{0} (has_top.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_92388 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) name) : @normal_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_92389 (h0 : topological_space (ring (mul_one_class (has_pos_part (has_neg Type))))) : preconnected_space (ring (mul_one_class (has_pos_part (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_92390 (h0 : ring (boolean_algebra.core (comm_group name))) : strong_rank_condition (boolean_algebra.core (comm_group name)) := sorry --non-trivial
lemma new_lemma_92391 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) linarith.comp) : @t1_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_92392 (h0 : topological_space (generalized_boolean_algebra (finset pos))) : discrete_topology (generalized_boolean_algebra (finset pos)) := sorry --non-trivial
lemma new_lemma_92393 (h0 : measurable_space (nondiscrete_normed_field reducibility_hints)) (h1 : measure_theory.measure (nondiscrete_normed_field reducibility_hints)) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_92394 (h0 : ring (has_zero (option (linear_ordered_field pos)))) : is_domain (has_zero (option (linear_ordered_field pos))) := sorry --non-trivial
lemma new_lemma_92395 (h0 : topological_space (has_top congr_arg_kind)) : totally_disconnected_space (has_top congr_arg_kind) := sorry --non-trivial
lemma new_lemma_92396 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_92397 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (simple_graph linarith.comp)) := sorry --non-trivial
lemma new_lemma_92398 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_92399 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (pseudo_metric_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_92400 (h0 : functor.add_const (function.extfun Type uniform_space) linarith.comp) : @separated_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) linarith.comp h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_92401 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_92402 (h0 : functor.add_const (topological_space (add_cancel_monoid empty)) (option empty)) : @preirreducible_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_92403 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (canonically_ordered_comm_semiring.{0} num) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (canonically_ordered_comm_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_92404 (h0 : list (has_to_string linarith.comp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_92405 (h0 : cancel_comm_monoid_with_zero (has_sub (semiring (semiring unsigned)))) : unique_factorization_monoid (has_sub (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_92406 (h0 : functor.add_const (ring (ordered_comm_ring real)) name) : @strong_rank_condition.{0} (ordered_comm_ring.{0} real) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} real)) name h0)  := sorry --non-trivial
lemma new_lemma_92407 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (comm_ring.{0} char) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_ring.{0} char))  := sorry --non-trivial
lemma new_lemma_92408 (h0 : has_zero (has_zero num) -> has_zero (has_zero num) -> Prop) : is_symm (has_zero (has_zero num)) h0 := sorry --non-trivial
lemma new_lemma_92409 (h0 : topological_space (add_cancel_monoid (has_add pos))) : totally_disconnected_space (add_cancel_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_92410 (h0 : not (add_group (has_compl char) -> false)) : @is_add_cyclic.{0} (has_compl.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (has_compl.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_92411 (h0 : ring (measure_theory.measure_space congr_arg_kind)) : strong_rank_condition (measure_theory.measure_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_92412 (h0 : functor.add_const (topological_space (boolean_algebra pos)) pos) : @path_connected_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_92413 (h0 : functor.add_const (ring (has_zero Type)) pos) : @is_principal_ideal_ring.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_zero.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_92414 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_92415 (h1 : group (complete_semilattice_Sup (random_gen string_imp))) : group.fg (complete_semilattice_Sup (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_92416 (h0 : group (simple_graph (has_pos_part (finset (finset linarith.comp))))) : is_cyclic (simple_graph (has_pos_part (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_92417 (h0 : not (topological_space (option congr_arg_kind) -> false)) : @path_connected_space.{0} (option.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (option.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_92418 (h1 : ring (non_unital_non_assoc_semiring string_imp)) : rank_condition (non_unital_non_assoc_semiring string_imp) := sorry --non-trivial
lemma new_lemma_92419 (h0 : function.extfun Type group) : @is_simple_group.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_92420 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_92421 (h0 : not (group (topological_space string_imp) -> false)) : @is_cyclic.{0} (topological_space.{0} string_imp) (@classical.by_contradiction'.{1} (group.{0} (topological_space.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_92422 (h0 : topological_space (has_norm (has_inv (random_gen fun_info)))) : path_connected_space (has_norm (has_inv (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_92423 (h0 : topological_space (semi_normed_comm_ring string.iterator_imp)) : path_connected_space (semi_normed_comm_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_92424 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf (has_Inf pos)))) : topological_space.separable_space (normed_lattice_add_comm_group (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_92425 (h0 : uniform_space (boolean_algebra.core (boolean_algebra Type))) : separated_space (boolean_algebra.core (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_92426 (h0 : topological_space (ordered_comm_ring pos)) : locally_compact_space (ordered_comm_ring pos) := sorry --non-trivial
lemma new_lemma_92427 (h0 : functor.add_const Prop (ordered_comm_ring Type)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_92428 (h0 : not (topological_space (semiring congr_arg_kind) -> false)) : @path_connected_space.{0} (semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_92429 (h0 : monoid (add_comm_monoid (add_comm_monoid (semigroup name)))) : monoid.fg (add_comm_monoid (add_comm_monoid (semigroup name))) := sorry --non-trivial
lemma new_lemma_92430 (h0 : uniform_space (has_top (semiring empty))) : complete_space (has_top (semiring empty)) := sorry --non-trivial
lemma new_lemma_92431 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_star congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_92432 (h0 : ring (boolean_algebra environment.implicit_infer_kind)) : rank_condition (boolean_algebra environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_92433 (h0 : ring (pseudo_metric_space (option (complete_distrib_lattice unsigned)))) : is_principal_ideal_ring (pseudo_metric_space (option (complete_distrib_lattice unsigned))) := sorry --non-trivial
lemma new_lemma_92434 (h0 : function.extfun (finset Type) (has_mem.mem (semiring linarith.comp_source))) : @t0_space.{0} (semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_92435 (h0 : functor.add_const (finset (has_Inf linarith.comp)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_92436 (h0 : functor.add_const (group (has_zero environment.implicit_infer_kind)) (finset environment.implicit_infer_kind)) : @is_simple_group.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} environment.implicit_infer_kind)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_92437 (h0 : functor.add_const (monoid nnreal) empty) : monoid.fg nnreal := sorry --non-trivial
lemma new_lemma_92438 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measure_theory.measure_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_92439 (h0 : ring (has_le fun_info)) : rank_condition (has_le fun_info) := sorry --non-trivial
lemma new_lemma_92440 (h0 : function.extfun Type topological_space) : totally_separated_space ennreal := sorry --non-trivial
lemma new_lemma_92441 (h1 : not (has_lt (comm_ring linarith.comp_source) -> false)) (h2 : set (comm_ring linarith.comp_source)) : @set.is_wf.{0} (comm_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (has_lt.{0} (comm_ring.{0} linarith.comp_source)) h1) h2  := sorry --non-trivial
lemma new_lemma_92442 (h0 : topological_space (ordered_comm_monoid (has_add (has_add Type)))) : normal_space (ordered_comm_monoid (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_92443 (h0 : filter (linear_ordered_comm_monoid_with_zero unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_92444 (h0 : finset (boolean_algebra (has_to_string (has_to_string (has_to_string (has_add unsigned)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_92445 (h0 : Type) (h1 : list (parser h0)) : palindrome h1 := sorry --non-trivial
lemma new_lemma_92446 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) linarith.comp) : @preconnected_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_92447 (h0 : function.extfun Type group) : @is_simple_group.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_92448 (h0 : complete_lattice (complete_distrib_lattice (has_add (has_bot real)))) : is_atomistic (complete_distrib_lattice (has_add (has_bot real))) := sorry --non-trivial
lemma new_lemma_92449 (h1 : group (comm_ring (comm_ring (random_gen reducibility_hints)))) : is_cyclic (comm_ring (comm_ring (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_92450 (h0 : not (uniform_space (has_emptyc to_additive.value_type) -> false)) : @complete_space.{0} (has_emptyc.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_emptyc.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_92451 (h0 : monoid (measurable_space unsigned)) : monoid.fg (measurable_space unsigned) := sorry --non-trivial
lemma new_lemma_92452 (h0 : functor.add_const (group (canonically_ordered_comm_semiring linarith.comp)) (finset pos)) : @is_cyclic.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_92453 (h0 : group (has_inv (has_nnnorm linarith.ineq))) : is_cyclic (has_inv (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_92454 (h0 : group (mul_zero_class (option pos))) : normalizer_condition (mul_zero_class (option pos)) := sorry --non-trivial
lemma new_lemma_92455 (h0 : add_group (preorder (option (option empty)))) : is_add_cyclic (preorder (option (option empty))) := sorry --non-trivial
lemma new_lemma_92456 (h0 : semiring (simple_graph empty)) : is_noetherian_ring (simple_graph empty) := sorry --non-trivial
lemma new_lemma_92457 (h0 : ordered_add_comm_monoid (add_cancel_monoid name)) : archimedean (add_cancel_monoid name) := sorry --non-trivial
lemma new_lemma_92458 (h0 : not (group (has_one unsigned) -> false)) : @group.fg.{0} (has_one.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (has_one.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_92459 (h0 : ordered_add_comm_monoid (complete_distrib_lattice empty)) : archimedean (complete_distrib_lattice empty) := sorry --non-trivial
lemma new_lemma_92460 (h0 : ring (finset (ordered_ring (has_add name)))) : is_domain (finset (ordered_ring (has_add name))) := sorry --non-trivial
lemma new_lemma_92461 (h0 : functor.add_const (topological_space (partial_order congr_arg_kind)) num) : @locally_compact_space.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_92462 (h0 : complete_lattice (semi_normed_ring char)) : complete_lattice.is_Sup_finite_compact (semi_normed_ring char) := sorry --non-trivial
lemma new_lemma_92463 (h0 : topological_space (has_Sup (option empty))) : totally_separated_space (has_Sup (option empty)) := sorry --non-trivial
lemma new_lemma_92464 (h0 : functor.add_const (topological_space (has_to_string ennreal)) (normed_comm_ring pos)) : @loc_path_connected_space.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} ennreal)) (normed_comm_ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_92465 (h0 : functor.add_const (topological_space (ordered_comm_group empty)) empty) : @t0_space.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_92466 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_92467 (h0 : functor.add_const (topological_space (has_Inf pos)) (has_neg (has_neg name))) : @totally_disconnected_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) (has_neg.{0} (has_neg.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_92468 (h0 : monoid (add_cancel_monoid (has_pos_part pos))) : monoid.fg (add_cancel_monoid (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_92469 (h0 : functor.add_const (semiring (linear_ordered_comm_monoid_with_zero empty)) unsigned) : @is_noetherian_ring.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_92470 (h0 : topological_space (random_gen (mul_one_class (mul_one_class fun_info)))) (h1 : preorder (random_gen (mul_one_class (mul_one_class fun_info)))) : order_topology (random_gen (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_92471 (h0 : add_group (linear_ordered_comm_group_with_zero ereal)) : is_add_cyclic (linear_ordered_comm_group_with_zero ereal) := sorry --non-trivial
lemma new_lemma_92472 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra.core unsigned)) name) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.core.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_92473 (h1 : not (group (has_top num) -> false)) : @group.fg.{0} (has_top.{0} num) (@classical.by_contradiction'.{1} (group.{0} (has_top.{0} num)) h1)  := sorry --non-trivial
lemma new_lemma_92474 (h1 : ring (semi_normed_ring linarith.ineq)) : rank_condition (semi_normed_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_92475 (h0 : filter (add_comm_monoid (comm_group (comm_group (add_cancel_monoid (has_nndist (comm_group (comm_group pos)))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_92476 (h0 : function.extfun (Type 1) group) : @group.fg.{1} (normed_lattice_add_comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (normed_lattice_add_comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_92477 (h1 : not (complete_lattice (random_gen char) -> false)) : @is_compactly_generated.{0} (random_gen.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_92478 (h0 : not (topological_space empty -> false)) : locally_compact_space empty := sorry --non-trivial
lemma new_lemma_92479 (h0 : random_gen linarith.comp_source -> has_nnnorm (has_nnnorm reducibility_hints)) (h1 : has_nnnorm (has_nnnorm reducibility_hints) -> option (random_gen linarith.comp_source)) : function.is_partial_inv h0 h1 := sorry --non-trivial
lemma new_lemma_92480 (h0 : ring (has_bot (ordered_comm_monoid (has_Inf (ordered_comm_monoid (ordered_comm_monoid pos)))))) : is_domain (has_bot (ordered_comm_monoid (has_Inf (ordered_comm_monoid (ordered_comm_monoid pos))))) := sorry --non-trivial
lemma new_lemma_92481 (h0 : functor.add_const (function.extfun Type complete_lattice) Type) : @is_atomistic.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type complete_lattice.{0}) Type h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_92482 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem uniform_space)) : @separated_space.{0} fun_info (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) uniform_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) fun_info)  := sorry --non-trivial
lemma new_lemma_92483 (h0 : complete_lattice (canonically_linear_ordered_monoid (option (ring unsigned)))) : complete_lattice.is_Sup_finite_compact (canonically_linear_ordered_monoid (option (ring unsigned))) := sorry --non-trivial
lemma new_lemma_92484 (h0 : uniform_space (complete_distrib_lattice (option (option ennreal)))) : complete_space (complete_distrib_lattice (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_92485 (h0 : add_group (comm_monoid (mul_one_class char))) : is_add_cyclic (comm_monoid (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_92486 (h0 : topological_space (boolean_algebra.core (has_add Type))) : t1_space (boolean_algebra.core (has_add Type)) := sorry --non-trivial
lemma new_lemma_92487 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_atomistic.{0} unsigned (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) unsigned)  := sorry --non-trivial
lemma new_lemma_92488 (h0 : complete_lattice (left_cancel_semigroup (semiring (semiring empty)))) : is_atomistic (left_cancel_semigroup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_92489 (h0 : not (add_group (semiring linarith.comp_source) -> false)) : @is_add_cyclic.{0} (semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (add_group.{0} (semiring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_92490 (h0 : functor.add_const (ring (boolean_algebra.core Type)) name) : @is_principal_ideal_ring.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.core.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_92491 (h0 : group (topological_space (has_nnnorm (has_top char)))) : group.fg (topological_space (has_nnnorm (has_top char))) := sorry --non-trivial
lemma new_lemma_92492 (h0 : topological_space (ring (has_Inf (has_add name)))) : discrete_topology (ring (has_Inf (has_add name))) := sorry --non-trivial
lemma new_lemma_92493 (h0 : topological_space (option (ordered_cancel_comm_monoid (option congr_arg_kind)))) : discrete_topology (option (ordered_cancel_comm_monoid (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_92494 (h0 : filter (mul_zero_class (semiring congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_92495 (h0 : group (has_bot (has_pos_part Type))) : group.fg (has_bot (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_92496 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_92497 (h0 : topological_space (add_cancel_monoid (has_add Type))) : preconnected_space (add_cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_92498 (h0 : fin has_zero.zero) : @t1_space.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_92499 (h0 : add_monoid (bin_tree (option (option empty)))) : add_monoid.fg (bin_tree (option (option empty))) := sorry --non-trivial
lemma new_lemma_92500 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (@id.{2} Type linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (@id.{2} Type linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_92501 (h0 : monoid (plift (ordered_ring congr_arg_kind))) : monoid.fg (plift (ordered_ring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_92502 (h0 : ring (with_zero linarith.ineq)) : strong_rank_condition (with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_92503 (h0 : function.extfun Type ring) : @is_domain.{0} (complete_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_92504 (h0 : fin has_zero.zero) : @group.fg.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (group.{0} (complete_distrib_lattice.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_92505 (h0 : not (topological_space (semiring linarith.comp_source) -> false)) : @discrete_topology.{0} (semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_92506 (h1 : ring (comm_ring reducibility_hints)) : is_domain (comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_92507 (h0 : function.extfun Type topological_space) (h1 : set (has_edist congr_arg_kind)) : @is_open.{0} (has_edist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_edist.{0} congr_arg_kind)) h1  := sorry --non-trivial
lemma new_lemma_92508 (h0 : topological_space (finset (has_pos_part linarith.comp))) : path_connected_space (finset (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_92509 (h0 : functor.add_const (function.extfun Type monoid) name) : @monoid.fg.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) name h0) (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_92510 (h0 : ring (has_inv (has_norm char))) : is_domain (has_inv (has_norm char)) := sorry --non-trivial
lemma new_lemma_92511 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (add_semigroup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_92512 (h0 : add_comm_semigroup std_gen -> add_comm_semigroup std_gen -> Prop) : is_strict_total_order' (add_comm_semigroup std_gen) h0 := sorry --non-trivial
lemma new_lemma_92513 (h0 : topological_space (complete_distrib_lattice ennreal)) : t0_space (complete_distrib_lattice ennreal) := sorry --non-trivial
lemma new_lemma_92514 (h0 : list (id (with_bot string_imp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_92515 (h0 : topological_space (normed_field (has_ssubset linarith.ineq))) : totally_disconnected_space (normed_field (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_92516 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_92517 (h0 : ring (has_neg_part (option (option ennreal)))) : is_domain (has_neg_part (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_92518 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_92519 (h0 : topological_space (has_nndist (has_add pos))) : path_connected_space (has_nndist (has_add pos)) := sorry --non-trivial
lemma new_lemma_92520 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_92521 (h0 : functor.add_const (filter (normed_comm_ring name)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_92522 (h0 : fin has_zero.zero) : @sequential_space.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_pos_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_92523 (h0 : comm_ring name) (h1 : local_ring name) (h2 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (@local_ring.residue_field.{0} name h0 h1) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h2) (@local_ring.residue_field.{0} name h0 h1))  := sorry --non-trivial
lemma new_lemma_92524 (h0 : group (normed_group (has_top num))) : group.fg (normed_group (has_top num)) := sorry --non-trivial
lemma new_lemma_92525 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) name) : @t0_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_92526 (h0 : topological_space (has_compl fun_info)) : t0_space (has_compl fun_info) := sorry --non-trivial
lemma new_lemma_92527 (h0 : functor.add_const (complete_lattice (has_pos_part name)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (has_pos_part.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_pos_part.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_92528 (h0 : list (complete_distrib_lattice (has_add environment.implicit_infer_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_92529 (h0 : topological_space (semigroup (mul_one_class Type))) : normal_space (semigroup (mul_one_class Type)) := sorry --non-trivial
lemma new_lemma_92530 (h0 : topological_space (plift unsigned)) : preirreducible_space (plift unsigned) := sorry --non-trivial
lemma new_lemma_92531 (h0 : complete_lattice (linear_ordered_comm_monoid_with_zero congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (linear_ordered_comm_monoid_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_92532 (h1 : measurable_space (nondiscrete_normed_field std_gen)) (h2 : measure_theory.measure (nondiscrete_normed_field std_gen)) : measure_theory.is_finite_measure h2 := sorry --non-trivial
lemma new_lemma_92533 (h0 : uniform_space (has_neg_part Type)) : separated_space (has_neg_part Type) := sorry --non-trivial
lemma new_lemma_92534 (h0 : functor.add_const (topological_space (free_add_monoid num)) empty) : @irreducible_space.{0} (free_add_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_92535 (h0 : ring (complete_linear_order (semiring (semiring (semiring empty))))) : strong_rank_condition (complete_linear_order (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_92536 (h0 : function.extfun nat fin) : @totally_disconnected_space.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (normed_lattice_add_comm_group.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_92537 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) (has_to_string Type)) : @irreducible_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} linarith.comp)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_92538 (h1 : topological_space (nondiscrete_normed_field char)) (h2 : set (nondiscrete_normed_field char)) : is_path_connected h2 := sorry --non-trivial
lemma new_lemma_92539 (h0 : not (ring (has_compl (has_nnnorm linarith.ineq)) -> false)) : @rank_condition.{0} (has_compl.{0} (has_nnnorm.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} (has_nnnorm.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_92540 (h0 : not (ring (with_zero fun_info) -> false)) : @strong_rank_condition.{0} (with_zero.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (with_zero.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_92541 (h0 : functor.add_const (monoid (normed_comm_ring Type)) Type) : @monoid.fg.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (monoid.{1} (normed_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_92542 (h0 : ordered_comm_monoid (finset (option (finset (finset name))))) : has_exists_mul_of_le (finset (option (finset (finset name)))) := sorry --non-trivial
lemma new_lemma_92543 (h0 : list (denumerable (has_nnnorm fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_92544 (h0 : topological_space (add_cancel_comm_monoid (has_dist (comm_monoid unsigned)))) : loc_path_connected_space (add_cancel_comm_monoid (has_dist (comm_monoid unsigned))) := sorry --non-trivial
lemma new_lemma_92545 (h0 : complete_lattice (ordered_comm_ring (has_add (has_bot Type)))) : is_compactly_generated (ordered_comm_ring (has_add (has_bot Type))) := sorry --non-trivial
lemma new_lemma_92546 (h1 : add_group (simple_graph ereal)) : is_add_cyclic (simple_graph ereal) := sorry --non-trivial
lemma new_lemma_92547 (h0 : functor.add_const (complete_lattice (cancel_monoid pos)) name) : @complete_lattice.is_Sup_finite_compact.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_92548 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (canonically_ordered_comm_semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_92549 (h0 : functor.add_const (topological_space (semigroup empty)) empty) : @normal_space.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_92550 (h0 : topological_space (canonically_ordered_monoid (comm_semigroup pos))) : topological_space.separable_space (canonically_ordered_monoid (comm_semigroup pos)) := sorry --non-trivial
lemma new_lemma_92551 (h0 : functor.add_const (add_monoid (normed_comm_ring linarith.comp)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (normed_comm_ring.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_92552 (h0 : fin has_zero.zero) : @monoid.fg.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (monoid.{0} (has_add.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_92553 (h0 : functor.add_const (topological_space (finset linarith.comp)) (has_Inf Type)) : @totally_separated_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} linarith.comp)) (has_Inf.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_92554 (h0 : function.extfun (Type 1) (functor.add_const (topological_space Type))) : @regular_space.{1} Type (@functor.add_const.run.{1 1} (topological_space.{1} Type) Type (@function.extfun_app.{3 2} (Type 1) (functor.add_const.{1 1} (topological_space.{1} Type)) h0 Type))  := sorry --non-trivial
lemma new_lemma_92555 (h0 : functor.add_const (filter (finset linarith.comp)) environment.implicit_infer_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_92556 (h0 : finset (boolean_algebra (finset environment.implicit_infer_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_92557 (h0 : functor.add_const (ordered_comm_monoid (has_zero environment.implicit_infer_kind)) (has_neg_part unsigned)) : @has_exists_mul_of_le.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_zero.{0} environment.implicit_infer_kind)) (has_neg_part.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_92558 (h0 : functor.add_const (topological_space (has_add pos)) linarith.comp) : @path_connected_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_92559 (h0 : topological_space (generalized_boolean_algebra (has_Inf real))) : topological_space.separable_space (generalized_boolean_algebra (has_Inf real)) := sorry --non-trivial
lemma new_lemma_92560 (h1 : topological_space (has_compl reducibility_hints)) : totally_disconnected_space (has_compl reducibility_hints) := sorry --non-trivial
lemma new_lemma_92561 (h0 : filter (has_neg (has_add (has_add (has_add linarith.comp))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_92562 (h0 : functor.add_const (list (boolean_algebra environment.implicit_infer_kind)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_92563 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf real))) : totally_disconnected_space (normed_lattice_add_comm_group (has_Inf real)) := sorry --non-trivial
lemma new_lemma_92564 (h0 h1 : multiset (linear_ordered_comm_group_with_zero reducibility_hints)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_92565 (h0 : functor.add_const (topological_space pos) congr_arg_kind) : @irreducible_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_92566 (h0 : not (monoid (complete_linear_order congr_arg_kind) -> false)) : @monoid.fg.{0} (complete_linear_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (monoid.{0} (complete_linear_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_92567 (h0 : topological_space (semigroup (has_add (option ennreal)))) : totally_separated_space (semigroup (has_add (option ennreal))) := sorry --non-trivial
lemma new_lemma_92568 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_92569 (h0 : functor.add_const (topological_space (partial_order empty)) num) : @locally_compact_space.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_92570 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_92571 (h0 : ring (mul_zero_class (cancel_monoid pos))) : strong_rank_condition (mul_zero_class (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_92572 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @rank_condition.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_92573 (h0 : function.extfun Type group) : @group.fg.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_92574 (h0 : complete_lattice (normed_lattice_add_comm_group (has_add Type))) : is_compactly_generated (normed_lattice_add_comm_group (has_add Type)) := sorry --non-trivial
lemma new_lemma_92575 (h0 : add_group (distrib linarith.ineq)) : is_add_cyclic (distrib linarith.ineq) := sorry --non-trivial
lemma new_lemma_92576 (h0 : complete_lattice (has_top linarith.comp)) : complete_lattice.is_Sup_finite_compact (has_top linarith.comp) := sorry --non-trivial
lemma new_lemma_92577 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_92578 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (comm_ring.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (comm_ring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_92579 (h0 : function.extfun Type ring) : @rank_condition.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_92580 (h0 : functor.add_const (function.extfun (Type 1) filter) linarith.comp) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_92581 (h0 : topological_space (distrib_lattice linarith.ineq)) : locally_compact_space (distrib_lattice linarith.ineq) := sorry --non-trivial
lemma new_lemma_92582 (h0 : not (ring (semi_normed_ring string_imp) -> false)) : @is_domain.{0} (semi_normed_ring.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_ring.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_92583 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @add_monoid.fg.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_monoid.{1}) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_92584 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) pos) : @irreducible_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_92585 (h0 : has_mem.mem to_additive.value_type has_emptyc.emptyc) : @strong_rank_condition.{0} to_additive.value_type (@finset.pi.empty.{1 0} Type ring.{0} to_additive.value_type h0)  := sorry --non-trivial
lemma new_lemma_92586 (h0 : functor.add_const (topological_space (semigroup Type)) (add_cancel_monoid (finset (has_zero Type)))) : @regular_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (semigroup.{1} Type)) (add_cancel_monoid.{1} (finset.{1} (has_zero.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_92587 (h0 : ring (measurable_space (random_gen to_additive.value_type))) : is_domain (measurable_space (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_92588 (h0 : functor.add_const (function.extfun Type add_monoid) name) : @add_monoid.fg.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) name h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_92589 (h0 : functor.add_const (function.extfun Type finset) (has_add name)) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_add pos)) := sorry --non-trivial
lemma new_lemma_92590 (h0 : functor.add_const (function.extfun (Type 1) group) (has_neg linarith.comp)) : @normalizer_condition.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) (has_neg.{0} linarith.comp) h0) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_92591 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @totally_disconnected_space.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_92592 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (linear_ordered_add_comm_group.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (linear_ordered_add_comm_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_92593 (h0 : functor.add_const (complete_lattice (semigroup unsigned)) name) : @is_atomistic.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_92594 (h0 : function.extfun Type (prod (pseudo_metric_space congr_arg_kind))) : id_rel (function.extfun_app h0 (pseudo_metric_space congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_92595 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) Type) : @has_exists_mul_of_le.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) Type h0) (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_92596 (h0 : functor.add_const (function.extfun Type topological_space) name) : @topological_space.separable_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_92597 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_emptyc.{0} (random_gen.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.comp_source))))) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_emptyc.{0} (random_gen.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.comp_source))))))  := sorry --non-trivial
lemma new_lemma_92598 (h0 : ring (ordered_comm_ring Type)) : is_domain (ordered_comm_ring Type) := sorry --non-trivial
lemma new_lemma_92599 (h0 : fin has_zero.zero) : @group.fg.{0} (generalized_boolean_algebra.{0} real) (@matrix.vec_empty.{0} (group.{0} (generalized_boolean_algebra.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_92600 (h1 : ring (topological_space (has_nnnorm char))) : rank_condition (topological_space (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_92601 (h0 : topological_space (with_one fun_info)) : t0_space (with_one fun_info) := sorry --non-trivial
lemma new_lemma_92602 (h0 : ring (semiring (semiring (semiring (has_top (semiring congr_arg_kind)))))) : is_domain (semiring (semiring (semiring (has_top (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_92603 (h0 : ring (linear_ordered_semiring (quiver.empty num))) (h1 : topological_space (has_norm (ring.positive_cone (linear_ordered_semiring (quiver.empty num))))) (h2 : preorder (has_norm (ring.positive_cone (linear_ordered_semiring (quiver.empty num))))) : compact_Icc_space (has_norm (ring.positive_cone (linear_ordered_semiring (quiver.empty num)))) := sorry --non-trivial
lemma new_lemma_92604 (h0 : functor.add_const (function.extfun Type semiring) pos) : @is_noetherian_ring.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) pos h0) (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_92605 (h0 : function.extfun (Type 1) topological_space) : @t0_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_92606 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_92607 (h0 : function.extfun Type group) : @group.fg.{0} (has_ssubset.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (has_ssubset.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_92608 (h0 : topological_space (mul_one_class (random_gen char))) : t0_space (mul_one_class (random_gen char)) := sorry --non-trivial
lemma new_lemma_92609 (h0 : topological_space (has_neg (has_add unsigned))) : irreducible_space (has_neg (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_92610 (h0 : not (add_group (has_compl linarith.comp_source) -> false)) : @is_add_cyclic.{0} (has_compl.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (add_group.{0} (has_compl.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_92611 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_92612 (h0 : function.extfun Type topological_space) : @regular_space.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_92613 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (random_gen.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (random_gen.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_92614 (h0 : topological_space (has_to_string (has_neg_part (cancel_monoid unsigned)))) : regular_space (has_to_string (has_neg_part (cancel_monoid unsigned))) := sorry --non-trivial
lemma new_lemma_92615 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_92616 (h0 : functor.add_const (cancel_comm_monoid_with_zero (boolean_algebra.core Type)) pos) : @unique_factorization_monoid.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (boolean_algebra.core.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_92617 (h2 : not (ring (linear_ordered_add_comm_group fun_info) -> false)) : @strong_rank_condition.{0} (linear_ordered_add_comm_group.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_add_comm_group.{0} fun_info)) h2)  := sorry --non-trivial
lemma new_lemma_92618 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_92619 (h0 : semiring (has_neg_part (cancel_monoid ennreal))) : is_noetherian_ring (has_neg_part (cancel_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_92620 (h0 : group (semigroup Type)) : is_simple_group (semigroup Type) := sorry --non-trivial
lemma new_lemma_92621 (h0 : ring (has_Sup empty)) : is_domain (has_Sup empty) := sorry --non-trivial
lemma new_lemma_92622 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (left_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (left_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_92623 (h0 : add_group (dlist (ordered_comm_semiring linarith.ineq))) : is_add_cyclic (dlist (ordered_comm_semiring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_92624 (h0 : function.extfun Type group) : @group.fg.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_92625 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_92626 (h0 : topological_space (is_R_or_C (option (option unsigned)))) : totally_disconnected_space (is_R_or_C (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_92627 (h0 : functor.add_const (ring (cancel_monoid name)) linarith.comp) : @rank_condition.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_92628 (h0 : uniform_space (sub_neg_monoid Type)) : complete_space (sub_neg_monoid Type) := sorry --non-trivial
lemma new_lemma_92629 (h0 : uniform_space (semigroup (mul_one_class environment.implicit_infer_kind))) : separated_space (semigroup (mul_one_class environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_92630 (h2 : list (denumerable fun_info)) : list.nodup h2 := sorry --non-trivial
lemma new_lemma_92631 (h0 : group (with_bot (has_inv (has_inv (has_inv to_additive.value_type))))) : normalizer_condition (with_bot (has_inv (has_inv (has_inv to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_92632 (h0 : ring (add_cancel_monoid (ring pos))) : rank_condition (add_cancel_monoid (ring pos)) := sorry --non-trivial
lemma new_lemma_92633 (h0 : list (has_zero ennreal)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_92634 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) Type) : @irreducible_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_92635 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_92636 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (finset unsigned)) := sorry --non-trivial
lemma new_lemma_92637 (h0 : eq (ring (topological_space string_imp)) char) (h1 : char) : @strong_rank_condition.{0} (topological_space.{0} string_imp) (@eq.mpr.{1} (ring.{0} (topological_space.{0} string_imp)) char h0 h1)  := sorry --non-trivial
lemma new_lemma_92638 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (linear_ordered_field empty)) := sorry --non-trivial
lemma new_lemma_92639 (h0 : functor.add_const (function.extfun Type group) (ring (ring (ring (has_pos_part linarith.comp))))) : @group.fg.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) (ring.{0} (ring.{0} (ring.{0} (has_pos_part.{0} linarith.comp)))) h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_92640 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_92641 (h0 : functor.add_const (uniform_space (cancel_monoid Type)) environment.implicit_infer_kind) : @separated_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (cancel_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_92642 (h0 : semiring (group_with_zero num)) : is_noetherian_ring (group_with_zero num) := sorry --non-trivial
lemma new_lemma_92643 (h0 : not (uniform_space (normed_group num) -> false)) : @separated_space.{0} (normed_group.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (normed_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_92644 (h0 : functor.add_const (finset (has_nndist Type)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_92645 (h0 : add_group (generalized_boolean_algebra (has_neg (has_neg Type)))) : is_add_cyclic (generalized_boolean_algebra (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_92646 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_92647 (h0 : topological_space (has_pos_part linarith.comp)) : t1_space (has_pos_part linarith.comp) := sorry --non-trivial
lemma new_lemma_92648 (h0 : add_group (with_bot linarith.comp_source)) : is_add_cyclic (with_bot linarith.comp_source) := sorry --non-trivial
lemma new_lemma_92649 (h0 : group (semigroup (has_Inf (has_pos_part (has_pos_part (semigroup (has_Inf Type))))))) : is_simple_group (semigroup (has_Inf (has_pos_part (has_pos_part (semigroup (has_Inf Type)))))) := sorry --non-trivial
lemma new_lemma_92650 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (mul_zero_class.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_92651 (h0 : ring (random_gen (random_gen (random_gen string_imp)))) : strong_rank_condition (random_gen (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_92652 (h0 : complete_lattice (add_right_cancel_monoid (semiring (semiring (semiring (semiring unsigned)))))) : is_atomistic (add_right_cancel_monoid (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_92653 (h0 : uniform_space (normed_field (mul_one_class ereal))) : complete_space (normed_field (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_92654 (h1 : not (complete_lattice (random_gen string_imp) -> false)) : @is_compactly_generated.{0} (random_gen.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_92655 (h0 : complete_lattice (has_add Type)) : complete_lattice.is_Sup_finite_compact (has_add Type) := sorry --non-trivial
lemma new_lemma_92656 (h0 : group (add_right_cancel_monoid (semiring (semiring (semiring (semiring congr_arg_kind)))))) : is_cyclic (add_right_cancel_monoid (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_92657 (h0 : list (canonically_ordered_comm_semiring linarith.comp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_92658 (h0 : functor.comp topological_space canonically_ordered_comm_semiring environment.implicit_infer_kind) : @loc_path_connected_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_92659 (h0 : topological_space real.angle) : preirreducible_space real.angle := sorry --non-trivial
lemma new_lemma_92660 (h0 : uniform_space (has_zero (has_Inf (metric_space environment.implicit_infer_kind)))) : separated_space (has_zero (has_Inf (metric_space environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_92661 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_92662 (h0 : ring (has_nnnorm (mul_one_class environment.projection_info))) : rank_condition (has_nnnorm (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_92663 (h0 : functor.add_const (function.extfun Type semiring) Type) : @is_noetherian_ring.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type semiring.{0}) Type h0) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_92664 (h0 : functor.add_const (topological_space (boolean_algebra name)) Type) : @topological_space.separable_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_92665 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) pos) : @t0_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_92666 (h0 : function.extfun Type topological_space) : @t1_space.{0} (ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_92667 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_92668 (h0 : add_group (has_top (comm_ring linarith.ineq))) : is_add_cyclic (has_top (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_92669 (h2 : complete_lattice fun_info) : is_compactly_generated fun_info := sorry --non-trivial
lemma new_lemma_92670 (h1 : complete_lattice (measurable_space to_additive.value_type)) : is_atomistic (measurable_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_92671 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_92672 (h0 : ordered_add_comm_monoid (ring (boolean_algebra (has_add linarith.comp)))) : archimedean (ring (boolean_algebra (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_92673 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) name) : @topological_space.separable_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_92674 (h0 : list (has_neg (has_Inf (has_pos_part Type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_92675 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (semi_normed_comm_ring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semi_normed_comm_ring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_92676 (h0 : topological_space (has_norm num)) : t0_space (has_norm num) := sorry --non-trivial
lemma new_lemma_92677 (h0 : functor.add_const (functor.add_const (list (left_cancel_monoid num)) empty) num) : list.nodup (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_92678 (h0 : add_group (normed_comm_ring (mul_one_class (mul_one_class (normed_comm_ring Type))))) : is_add_cyclic (normed_comm_ring (mul_one_class (mul_one_class (normed_comm_ring Type)))) := sorry --non-trivial
lemma new_lemma_92679 (h0 : ring (has_nnnorm (has_nnnorm (random_gen char)))) : rank_condition (has_nnnorm (has_nnnorm (random_gen char))) := sorry --non-trivial
lemma new_lemma_92680 (h0 : function.extfun Type (functor.add_const (topological_space unsigned))) : @discrete_topology.{0} unsigned (@functor.add_const.run.{0 0} (topological_space.{0} unsigned) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} unsigned)) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_92681 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) empty) : @t0_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_92682 (h0 : not (group (distrib_lattice linarith.comp_source) -> false)) : @group.fg.{0} (distrib_lattice.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (distrib_lattice.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_92683 (h0 : group (metric_space (semiring (semiring num)))) : normalizer_condition (metric_space (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_92684 (h0 : uniform_space pos) : separated_space pos := sorry --non-trivial
lemma new_lemma_92685 (h0 : topological_space (linear_ordered_semiring (has_top empty))) : locally_compact_space (linear_ordered_semiring (has_top empty)) := sorry --non-trivial
lemma new_lemma_92686 (h0 : topological_space (boolean_algebra.core (has_to_string Type))) : discrete_topology (boolean_algebra.core (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_92687 (h1 : topological_space num) : totally_disconnected_space num := sorry --non-trivial
lemma new_lemma_92688 (h1 : group (add_cancel_comm_monoid (random_gen linarith.comp_source))) : is_cyclic (add_cancel_comm_monoid (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_92689 (h0 : group (left_cancel_semigroup (semiring num))) : normalizer_condition (left_cancel_semigroup (semiring num)) := sorry --non-trivial
lemma new_lemma_92690 (h0 : topological_space (ring unsigned)) : preconnected_space (ring unsigned) := sorry --non-trivial
lemma new_lemma_92691 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf real))) : normal_space (normed_lattice_add_comm_group (has_Inf real)) := sorry --non-trivial
lemma new_lemma_92692 (h0 : not (ring (normed_group empty) -> false)) : @strong_rank_condition.{0} (normed_group.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (normed_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_92693 (h0 : topological_space (simple_graph (has_add name))) : totally_separated_space (simple_graph (has_add name)) := sorry --non-trivial
lemma new_lemma_92694 (h0 : topological_space (comm_group (boolean_algebra.core linarith.comp))) : totally_disconnected_space (comm_group (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_92695 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (add_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (add_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_92696 (h0 : functor.add_const (finset (comm_group linarith.comp)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_92697 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (uniform_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (uniform_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_92698 (h0 : ring (has_nndist (finset pos))) : rank_condition (has_nndist (finset pos)) := sorry --non-trivial
lemma new_lemma_92699 (h0 : functor.add_const (complete_lattice (free_add_monoid unsigned)) congr_arg_kind) : @is_compactly_generated.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (free_add_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_92700 (h0 : not (ring (fintype string_imp) -> false)) : @strong_rank_condition.{0} (fintype.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (fintype.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_92701 (h0 : topological_space (has_union (has_zero linarith.comp))) : normal_space (has_union (has_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_92702 (h0 : not (topological_space (has_norm char) -> false)) : @t0_space.{0} (has_norm.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_92703 (h0 : functor.add_const (function.extfun (Type 1) group) linarith.comp) : @normalizer_condition.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) linarith.comp h0) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_92704 (h0 : ring (with_bot empty)) : is_principal_ideal_ring (with_bot empty) := sorry --non-trivial
lemma new_lemma_92705 (h0 : topological_space (normed_group (has_norm linarith.ineq))) : totally_separated_space (normed_group (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_92706 (h3 : topological_space (uniform_space (metric_space to_additive.value_type))) : path_connected_space (uniform_space (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_92707 (h0 : complete_lattice (random_gen (random_gen (has_nnnorm linarith.ineq)))) : is_compactly_generated (random_gen (random_gen (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_92708 (h0 : topological_space (add_cancel_monoid (boolean_algebra linarith.comp))) : topological_space.separable_space (add_cancel_monoid (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_92709 (h0 : functor.add_const (finset (normed_comm_ring pos)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_92710 (h0 : ring (add_cancel_monoid (has_add pos))) : strong_rank_condition (add_cancel_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_92711 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_92712 (h0 : ring (non_assoc_semiring (semiring (semiring empty)))) : strong_rank_condition (non_assoc_semiring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_92713 (h0 : ordered_comm_monoid (has_neg (option (option ennreal)))) : has_exists_mul_of_le (has_neg (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_92714 (h0 : set (simple_graph (mul_one_class linarith.ineq))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_92715 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @irreducible_space.{0} fun_info (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) fun_info)  := sorry --non-trivial
lemma new_lemma_92716 (h0 : function.extfun nat fin) : @normal_space.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_92717 (h0 : add_monoid (boolean_algebra (has_neg Type))) : add_monoid.fg (boolean_algebra (has_neg Type)) := sorry --non-trivial
lemma new_lemma_92718 (h0 : functor.add_const (topological_space (has_dist empty)) num) : @t0_space.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_92719 (h0 : complete_lattice (simple_graph (has_nnnorm reducibility_hints))) : complete_lattice.is_Sup_finite_compact (simple_graph (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_92720 (h0 : topological_space (has_to_string unsigned)) : loc_path_connected_space (has_to_string unsigned) := sorry --non-trivial
lemma new_lemma_92721 (h0 : functor.add_const (topological_space (finset Type)) environment.implicit_infer_kind) : @discrete_topology.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_92722 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_92723 (h0 : functor.add_const (group (normed_comm_ring (add_cancel_monoid environment.implicit_infer_kind))) (finset Type)) : @group.fg.{0} (normed_comm_ring.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) (@functor.add_const.run.{0 1} (group.{0} (normed_comm_ring.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind))) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_92724 (h0 : functor.comp group finset ennreal) : @group.fg.{0} (finset.{0} ennreal) (@functor.comp.run.{0 0 0} group.{0} finset.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_92725 (h0 : ring (has_neg_part (boolean_algebra (has_to_string pos)))) : is_principal_ideal_ring (has_neg_part (boolean_algebra (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_92726 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_92727 (h0 : filter (dlist (random_gen string_imp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_92728 (h0 : filter (ordered_cancel_add_comm_monoid (option ennreal))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_92729 (h0 : not (ring (measurable_space.dynkin_system (has_ssubset char)) -> false)) : @strong_rank_condition.{0} (measurable_space.dynkin_system.{0} (has_ssubset.{0} char)) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.dynkin_system.{0} (has_ssubset.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_92730 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_92731 (h0 : functor.add_const (function.extfun nat fin) real) : @unique_factorization_monoid.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (cancel_comm_monoid_with_zero.{1} (boolean_algebra.{1} Type)) (@function.extfun_app.{1 1} nat fin (@functor.add_const.run.{0 0} (function.extfun.{1 1} nat fin) real h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_92732 (h2 : topological_space (nondiscrete_normed_field reducibility_hints)) (h3 : add_group (nondiscrete_normed_field reducibility_hints)) : topological_add_group (nondiscrete_normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_92733 (h0 : topological_space (has_neg_part (boolean_algebra unsigned))) : t0_space (has_neg_part (boolean_algebra unsigned)) := sorry --non-trivial
lemma new_lemma_92734 (h0 : functor.add_const (function.extfun (Type 1) monoid) linarith.comp) : @monoid.fg.{1} Type (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) monoid.{1}) linarith.comp h0) Type)  := sorry --non-trivial
lemma new_lemma_92735 (h0 : ring (left_cancel_monoid empty)) : is_domain (left_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_92736 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (semiring.{0} (ordered_comm_ring.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_92737 (h0 : semigroup pos -> semigroup pos -> Prop) : is_symm (semigroup pos) h0 := sorry --non-trivial
lemma new_lemma_92738 (h0 : ordered_comm_ring (ordered_comm_monoid real) -> ordered_comm_ring (ordered_comm_monoid real) -> Prop) : well_founded h0 := sorry --non-trivial
lemma new_lemma_92739 (h0 : list (measurable_space (has_nnnorm fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_92740 (h0 : functor.add_const (ring (add_comm_monoid ennreal)) name) : @rank_condition.{0} (add_comm_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_92741 (h0 : ring (finset (option unsigned))) : rank_condition (finset (option unsigned)) := sorry --non-trivial
lemma new_lemma_92742 (h0 : functor.comp topological_space comm_group name) : @path_connected_space.{0} (comm_group.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} name h0)  := sorry --non-trivial
lemma new_lemma_92743 (h0 : uniform_space (ordered_comm_monoid (has_add pos))) : separated_space (ordered_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_92744 (h1 : ring empty) : rank_condition empty := sorry --non-trivial
lemma new_lemma_92745 (h0 : group (simple_graph (ring (has_to_string Type)))) : normalizer_condition (simple_graph (ring (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_92746 (h0 : topological_space (linear_order unsigned)) : path_connected_space (linear_order unsigned) := sorry --non-trivial
lemma new_lemma_92747 (h0 : group (has_Sup congr_arg_kind)) : is_cyclic (has_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_92748 (h0 : filter (complete_distrib_lattice linarith.ineq)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_92749 (h0 : topological_space (normed_comm_ring (has_to_string (has_to_string Type)))) : loc_path_connected_space (normed_comm_ring (has_to_string (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_92750 (h0 : function.extfun Type group) : @is_cyclic.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_92751 (h0 : ring (normed_comm_ring (comm_group (comm_group (has_to_string Type))))) : rank_condition (normed_comm_ring (comm_group (comm_group (has_to_string Type)))) := sorry --non-trivial
lemma new_lemma_92752 (h0 : topological_space (metric_space empty)) : normal_space (metric_space empty) := sorry --non-trivial
lemma new_lemma_92753 (h0 : topological_space (has_union congr_arg_kind)) : t0_space (has_union congr_arg_kind) := sorry --non-trivial
lemma new_lemma_92754 (h1 : topological_space (has_nnnorm linarith.ineq)) : path_connected_space (has_nnnorm linarith.ineq) := sorry --non-trivial
lemma new_lemma_92755 (h0 : has_lt (nondiscrete_normed_field (mul_one_class (mul_one_class fun_info)))) : no_max_order (nondiscrete_normed_field (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_92756 (h0 : functor.add_const Prop (ordered_cancel_add_comm_monoid empty)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_92757 (h0 : topological_space (plift (option (semiring num)))) : irreducible_space (plift (option (semiring num))) := sorry --non-trivial
lemma new_lemma_92758 (h0 : ring (pseudo_metric_space (option (has_dist (option (ring unsigned)))))) : strong_rank_condition (pseudo_metric_space (option (has_dist (option (ring unsigned))))) := sorry --non-trivial
lemma new_lemma_92759 (h0 : function.extfun Type (functor.add_const (topological_space (free_add_monoid unsigned)))) : @t0_space.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} unsigned)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (free_add_monoid.{0} unsigned))) h0 num))  := sorry --non-trivial
lemma new_lemma_92760 (h0 : topological_space (comm_group (has_add unsigned))) : t0_space (comm_group (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_92761 (h0 : add_monoid (has_bot real)) : add_monoid.fg (has_bot real) := sorry --non-trivial
lemma new_lemma_92762 (h2 : set (omega_complete_partial_order fun_info -> linarith.ineq)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_92763 (h0 h1 : multiset (distrib linarith.ineq)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_92764 (h1 h2 : multiset (simple_graph fun_info)) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_92765 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_92766 (h0 : topological_space (with_bot (has_norm fun_info))) : totally_separated_space (with_bot (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_92767 (h0 : topological_space (preorder ennreal)) : t1_space (preorder ennreal) := sorry --non-trivial
lemma new_lemma_92768 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_92769 (h0 : function.extfun Type ring) : @rank_condition.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_92770 (h0 : group (has_union (has_top congr_arg_kind))) : is_cyclic (has_union (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_92771 (h0 : prod (canonically_ordered_add_monoid unsigned) (canonically_ordered_add_monoid unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_92772 (h0 : topological_space (has_pos_part (ring name))) : preirreducible_space (has_pos_part (ring name)) := sorry --non-trivial
lemma new_lemma_92773 (h0 : complete_lattice (has_sub (semiring (semiring unsigned)))) : is_atomistic (has_sub (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_92774 (h0 : functor.add_const (topological_space (comm_group Type)) environment.implicit_infer_kind) : @preirreducible_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_92775 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_92776 (h0 : topological_space (sub_neg_monoid name)) : path_connected_space (sub_neg_monoid name) := sorry --non-trivial
lemma new_lemma_92777 (h0 : ordered_comm_monoid (normed_lattice_add_comm_group Type)) : has_exists_mul_of_le (normed_lattice_add_comm_group Type) := sorry --non-trivial
lemma new_lemma_92778 (h0 : ring (is_R_or_C (semiring empty))) : rank_condition (is_R_or_C (semiring empty)) := sorry --non-trivial
lemma new_lemma_92779 (h0 : functor.add_const (topological_space (has_Inf name)) linarith.comp) : @sequential_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_92780 (h0 : complete_lattice (simple_graph (has_pos_part (has_Inf linarith.comp)))) : complete_lattice.is_Sup_finite_compact (simple_graph (has_pos_part (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_92781 (h0 : group (semigroup (option (option pos)))) : normalizer_condition (semigroup (option (option pos))) := sorry --non-trivial
lemma new_lemma_92782 (h0 : not (uniform_space (has_union num) -> false)) : @separated_space.{0} (has_union.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_union.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_92783 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_92784 (h0 : has_neg (nondiscrete_normed_field linarith.ineq)) (h1 : measurable_space (nondiscrete_normed_field linarith.ineq)) : has_measurable_neg (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_92785 (h0 : filter (ordered_comm_monoid (has_add (finset linarith.comp)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_92786 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_92787 (h0 : functor.add_const (topological_space (cancel_monoid environment.implicit_infer_kind)) Type) : @totally_separated_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_92788 (h0 : uniform_space (nondiscrete_normed_field reducibility_hints)) : complete_space (nondiscrete_normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_92789 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) environment.implicit_infer_kind) : @irreducible_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_92790 (h0 : functor.add_const (semiring (has_add linarith.comp)) name) : @is_noetherian_ring.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (has_add.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_92791 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_92792 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_92793 (h0 : ring (has_zero enat)) : is_domain (has_zero enat) := sorry --non-trivial
lemma new_lemma_92794 (h0 : topological_space (boolean_algebra (finset Type))) : regular_space (boolean_algebra (finset Type)) := sorry --non-trivial
lemma new_lemma_92795 (h0 : topological_space (has_bot congr_arg_kind)) : totally_separated_space (has_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_92796 (h1 : topological_space (distrib_lattice char)) : t0_space (distrib_lattice char) := sorry --non-trivial
lemma new_lemma_92797 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (distrib_lattice.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (distrib_lattice.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_92798 (h0 : has_le (nondiscrete_normed_field enat)) (h1 : nondiscrete_normed_field enat) : is_max h1 := sorry --non-trivial
lemma new_lemma_92799 (h0 : group (has_pos_part unsigned)) : normalizer_condition (has_pos_part unsigned) := sorry --non-trivial
lemma new_lemma_92800 (h0 : functor.comp group canonically_ordered_comm_semiring name) : @group.fg.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.comp.run.{0 0 0} group.{0} canonically_ordered_comm_semiring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_92801 (h0 : fin has_zero.zero) : @preconnected_space.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_92802 (h0 : complete_lattice (has_add (comm_semigroup real))) : is_compactly_generated (has_add (comm_semigroup real)) := sorry --non-trivial
lemma new_lemma_92803 (h0 : ring (comm_group (add_comm_monoid (has_add (has_add unsigned))))) : is_principal_ideal_ring (comm_group (add_comm_monoid (has_add (has_add unsigned)))) := sorry --non-trivial
lemma new_lemma_92804 (h0 : filter (fintype linarith.comp_source)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_92805 (h0 : finset (generalized_boolean_algebra pos)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_92806 (h0 : topological_space (has_zero (comm_group Type))) : locally_compact_space (has_zero (comm_group Type)) := sorry --non-trivial
lemma new_lemma_92807 (h0 : has_mem.mem linarith.comp has_emptyc.emptyc) : @t0_space.{0} linarith.comp (@finset.pi.empty.{1 0} Type topological_space.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_92808 (h0 : functor.add_const (topological_space (sub_neg_monoid name)) linarith.comp) : @topological_space.separable_space.{0} (sub_neg_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_92809 (h0 : functor.add_const (cancel_comm_monoid_with_zero (bin_tree empty)) (semiring num)) : @unique_factorization_monoid.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (bin_tree.{0} empty)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_92810 (h1 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_92811 (h0 : monoid (filter empty)) : monoid.fg (filter empty) := sorry --non-trivial
lemma new_lemma_92812 (h0 : group (add_group (has_top congr_arg_kind))) : is_cyclic (add_group (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_92813 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_disconnected_space.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_92814 (h0 : filter (add_left_cancel_monoid (fintype (distrib linarith.comp_source)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_92815 (h0 : uniform_space (cancel_monoid pos)) : complete_space (cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_92816 (h0 : topological_space (add_left_cancel_semigroup congr_arg_kind)) : totally_disconnected_space (add_left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_92817 (h0 : ordered_comm_monoid (has_to_string (has_neg (ring name)))) : has_exists_mul_of_le (has_to_string (has_neg (ring name))) := sorry --non-trivial
lemma new_lemma_92818 (h0 : functor.add_const (finset (has_add Type)) (ring linarith.comp)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_92819 (h0 : ring (complete_distrib_lattice (option (option (option (option empty)))))) : rank_condition (complete_distrib_lattice (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_92820 (h0 : functor.add_const (group (cancel_monoid linarith.comp)) linarith.comp) : @is_cyclic.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_92821 (h0 : list (semigroup (add_comm_monoid (add_comm_monoid (semigroup name))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_92822 (h0 : functor.add_const (list (left_cancel_monoid empty)) (semiring num)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_92823 (h0 : fin has_zero.zero) : @is_cyclic.{0} (has_add.{0} pos) (@matrix.vec_empty.{0} (group.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_92824 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_92825 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ordered_comm_ring Type)) pos) : @unique_factorization_monoid.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (ordered_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_92826 (h0 : complete_lattice (non_unital_non_assoc_semiring reducibility_hints)) : complete_lattice.is_Sup_finite_compact (non_unital_non_assoc_semiring reducibility_hints) := sorry --non-trivial
lemma new_lemma_92827 (h0 : topological_space (add_left_cancel_monoid (comm_ring linarith.comp_source))) : path_connected_space (add_left_cancel_monoid (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_92828 (h1 : complete_lattice string_imp) : is_atomistic string_imp := sorry --non-trivial
lemma new_lemma_92829 (h0 : uniform_space (boolean_algebra (has_zero environment.implicit_infer_kind))) : complete_space (boolean_algebra (has_zero environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_92830 (h0 : filter (boolean_algebra linarith.comp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_92831 (h0 : topological_space (has_nndist (has_to_string pos))) : sequential_space (has_nndist (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_92832 (h0 : not (topological_space (has_union empty) -> false)) : @preirreducible_space.{0} (has_union.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_92833 (h0 : list (normed_comm_ring ennreal)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_92834 (h0 : topological_space (comm_monoid empty)) : normal_space (comm_monoid empty) := sorry --non-trivial
lemma new_lemma_92835 (h0 : function.extfun Type ring) : @is_domain.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_92836 (h0 : fin has_zero.zero) : @strong_rank_condition.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (normed_lattice_add_comm_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_92837 (h0 : topological_space (distrib fun_info)) (h1 : set (distrib fun_info)) : is_preirreducible h1 := sorry --non-trivial
lemma new_lemma_92838 (h0 : complete_lattice (nondiscrete_normed_field string.iterator_imp)) : complete_lattice.is_Sup_finite_compact (nondiscrete_normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_92839 (h0 : group (linear_ordered_cancel_comm_monoid empty)) : normalizer_condition (linear_ordered_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_92840 (h0 : function.extfun Type ring) : @is_domain.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_92841 (h0 : not (topological_space (measurable_space congr_arg_kind) -> false)) : @locally_compact_space.{0} (measurable_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_92842 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} h0 congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_92843 (h0 : group (add_cancel_comm_monoid (comm_ring (comm_ring linarith.ineq)))) : is_cyclic (add_cancel_comm_monoid (comm_ring (comm_ring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_92844 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (boolean_algebra.core.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} empty))  := sorry --non-trivial
lemma new_lemma_92845 (h0 : function.extfun (Type 1) add_group) : @is_add_cyclic.{1} (plift.{1} congr_arg_kind) (@function.extfun_app.{3 2} (Type 1) add_group.{1} h0 (plift.{1} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_92846 (h0 : topological_space (mul_zero_class empty)) : discrete_topology (mul_zero_class empty) := sorry --non-trivial
lemma new_lemma_92847 (h0 : topological_space (finset (option empty))) : normal_space (finset (option empty)) := sorry --non-trivial
lemma new_lemma_92848 (h0 : add_monoid (id (has_top empty))) : add_monoid.fg (id (has_top empty)) := sorry --non-trivial
lemma new_lemma_92849 (h0 : filter (has_nndist (has_neg_part unsigned))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_92850 (h0 : group (comm_semigroup (has_bot name))) : normalizer_condition (comm_semigroup (has_bot name)) := sorry --non-trivial
lemma new_lemma_92851 (h0 : topological_space (ordered_ring (semiring empty))) : locally_compact_space (ordered_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_92852 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring fun_info))) : @rank_condition.{0} (linear_ordered_semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_92853 (h0 : complete_lattice (linear_ordered_comm_ring (semiring empty))) : complete_lattice.is_Sup_finite_compact (linear_ordered_comm_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_92854 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) pos) : @has_exists_mul_of_le.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) pos h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_92855 (h0 : function.extfun Type group) : @group.fg.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_92856 (h0 : add_group (mul_one_class std_gen)) : is_add_cyclic (mul_one_class std_gen) := sorry --non-trivial
lemma new_lemma_92857 (h0 : group (has_to_string (finset environment.implicit_infer_kind))) : is_simple_group (has_to_string (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_92858 (h1 : ring (dlist char)) : is_domain (dlist char) := sorry --non-trivial
lemma new_lemma_92859 (h0 : monoid (left_cancel_monoid unsigned)) : monoid.fg (left_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_92860 (h0 : fin has_zero.zero) : @is_atomistic.{0} (comm_semigroup.{0} name) (@matrix.vec_empty.{0} (complete_lattice.{0} (comm_semigroup.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_92861 (h0 : list (dlist (has_ssubset linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_92862 (h0 : functor.add_const (topological_space (boolean_algebra.core environment.implicit_infer_kind)) linarith.comp) : @discrete_topology.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_92863 (h0 : not (has_mem.mem (with_bot num) has_emptyc.emptyc -> false)) : @locally_compact_space.{0} (with_bot.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_92864 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_92865 (h0 : function.extfun Type ring) : @is_domain.{0} (@id.{2} Type (semiring.{0} empty)) (@function.extfun_app.{2 1} Type ring.{0} h0 (@id.{2} Type (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_92866 (h0 : group (has_union linarith.comp)) : is_cyclic (has_union linarith.comp) := sorry --non-trivial
lemma new_lemma_92867 (h0 : topological_space (ordered_comm_monoid name)) : normal_space (ordered_comm_monoid name) := sorry --non-trivial
lemma new_lemma_92868 (h0 : uniform_space (sub_neg_monoid (has_add linarith.comp))) : complete_space (sub_neg_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_92869 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @loc_path_connected_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_92870 (h0 : function.extfun (Type 1) ring) : @is_principal_ideal_ring.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_92871 (h1 : topological_space (linear_ordered_add_comm_monoid to_additive.value_type)) : path_connected_space (linear_ordered_add_comm_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_92872 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @totally_separated_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_92873 (h1 : list (encodable (has_ssubset (random_gen string_imp)))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_92874 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preirreducible_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_92875 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra name)) name) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_92876 (h0 : topological_space (has_sub (semiring congr_arg_kind))) : totally_disconnected_space (has_sub (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_92877 (h0 : functor.add_const (finset (ring Type)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_92878 (h0 : topological_space (id (semiring (semiring (semiring (semiring (semiring congr_arg_kind))))))) : normal_space (id (semiring (semiring (semiring (semiring (semiring congr_arg_kind)))))) := sorry --non-trivial
lemma new_lemma_92879 (h0 : function.extfun Type topological_space) : @t0_space.{0} (boolean_algebra.core.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} num))  := sorry --non-trivial
lemma new_lemma_92880 (h0 : functor.add_const (ring (add_comm_monoid pos)) unsigned) : @rank_condition.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_92881 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_emptyc.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_emptyc.{0} empty))  := sorry --non-trivial
lemma new_lemma_92882 (h0 : add_group (complete_distrib_lattice (has_Inf (has_Inf real)))) : is_add_cyclic (complete_distrib_lattice (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_92883 (h0 : group (has_neg_part (comm_group pos))) : normalizer_condition (has_neg_part (comm_group pos)) := sorry --non-trivial
lemma new_lemma_92884 (h0 : functor.add_const (topological_space (normed_comm_ring name)) linarith.comp) : @locally_compact_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_92885 (h0 : functor.add_const (topological_space linarith.comp) (has_nndist (finset pos))) : @preirreducible_space.{0} linarith.comp (@functor.add_const.run.{0 0} (topological_space.{0} linarith.comp) (has_nndist.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_92886 (h0 : function.extfun Type group) : @group.fg.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_92887 (h0 : functor.comp group ring name) : @group.fg.{0} (ring.{0} name) (@functor.comp.run.{0 0 0} group.{0} ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_92888 (h0 : topological_space (encodable (has_nnnorm linarith.ineq))) : totally_disconnected_space (encodable (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_92889 (h0 : topological_space (distrib (comm_ring (has_nnnorm fun_info)))) : path_connected_space (distrib (comm_ring (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_92890 (h0 : ring (has_to_string Type)) : is_principal_ideal_ring (has_to_string Type) := sorry --non-trivial
lemma new_lemma_92891 (h0 : topological_space (ordered_comm_ring (sub_neg_monoid pos))) : preirreducible_space (ordered_comm_ring (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_92892 (h0 : topological_space (semiring (has_top linarith.ineq))) : irreducible_space (semiring (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_92893 (h0 : functor.add_const (filter (sub_neg_monoid linarith.comp)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_92894 (h0 : topological_space (topological_space (has_norm (complete_semilattice_Sup char)))) : locally_compact_space (topological_space (has_norm (complete_semilattice_Sup char))) := sorry --non-trivial
lemma new_lemma_92895 (h0 : functor.add_const (topological_space (semigroup unsigned)) unsigned) : @regular_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_92896 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_92897 (h0 : uniform_space (left_cancel_semigroup unsigned)) : separated_space (left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_92898 (h0 : functor.add_const (add_group (mul_zero_class ennreal)) ennreal) : @is_add_cyclic.{0} (mul_zero_class.{0} ennreal) (@functor.add_const.run.{0 0} (add_group.{0} (mul_zero_class.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_92899 (h0 : ring (monoid (option (option (option empty))))) : is_principal_ideal_ring (monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_92900 (h0 : functor.add_const (function.extfun Type topological_space) name) : @normal_space.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_92901 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group linarith.comp_source))) : @path_connected_space.{0} (normed_group.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_92902 (h0 : has_le (linear_ordered_cancel_add_comm_monoid enat)) : no_top_order (linear_ordered_cancel_add_comm_monoid enat) := sorry --non-trivial
lemma new_lemma_92903 (h0 : functor.add_const (topological_space (comm_group unsigned)) pos) : @preirreducible_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_92904 (h0 : semiring fun_info) : is_noetherian_ring fun_info := sorry --non-trivial
lemma new_lemma_92905 (h0 : ring (generalized_boolean_algebra (sub_neg_monoid pos))) : is_domain (generalized_boolean_algebra (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_92906 (h0 : complete_lattice (has_top (semiring (semiring empty)))) : complete_lattice.is_Sup_finite_compact (has_top (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_92907 (h0 : ring (cancel_monoid (option empty))) : strong_rank_condition (cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_92908 (h0 : functor.add_const (cancel_comm_monoid_with_zero (boolean_algebra linarith.comp)) linarith.comp) : @unique_factorization_monoid.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_92909 (h0 : functor.add_const (list (finset linarith.comp)) (add_cancel_monoid environment.implicit_infer_kind)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_92910 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preconnected_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_92911 (h0 : topological_space (linear_ordered_comm_group_with_zero (mul_one_class linarith.comp_source))) : path_connected_space (linear_ordered_comm_group_with_zero (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_92912 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @irreducible_space.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_92913 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_92914 (h0 : ordered_comm_monoid (add_comm_monoid (has_neg name))) : has_exists_mul_of_le (add_comm_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_92915 (h0 : function.extfun Type (functor.comp topological_space cancel_monoid)) : @t1_space.{0} (cancel_monoid.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} cancel_monoid.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_92916 (h0 : functor.add_const (topological_space (linear_ordered_field ennreal)) (option unsigned)) : @locally_compact_space.{0} (linear_ordered_field.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} ennreal)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_92917 (h0 : topological_space (has_top (has_norm (has_top congr_arg_kind)))) : totally_disconnected_space (has_top (has_norm (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_92918 (h0 : fin has_zero.zero) : @t1_space.{0} (ordered_comm_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_92919 (h0 : complete_lattice (finset (has_zero (has_zero (has_zero pos))))) : is_compactly_generated (finset (has_zero (has_zero (has_zero pos)))) := sorry --non-trivial
lemma new_lemma_92920 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_92921 (h0 : complete_lattice (has_inv (has_inv linarith.ineq))) : complete_lattice.is_Sup_finite_compact (has_inv (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_92922 (h0 : topological_space (has_compl (has_ssubset linarith.ineq))) : locally_compact_space (has_compl (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_92923 (h0 : add_group (has_nnnorm (random_gen char))) : is_add_cyclic (has_nnnorm (random_gen char)) := sorry --non-trivial
lemma new_lemma_92924 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_92925 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_92926 (h0 : function.extfun Type (functor.add_const (add_group znum))) : @is_add_cyclic.{0} znum (@functor.add_const.run.{0 0} (add_group.{0} znum) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_group.{0} znum)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_92927 (h0 : group (with_bot unsigned)) : normalizer_condition (with_bot unsigned) := sorry --non-trivial
lemma new_lemma_92928 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_92929 (h0 : functor.add_const (topological_space (complete_distrib_lattice unsigned)) name) : @t0_space.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_92930 (h0 : complete_lattice (mul_zero_class (semiring unsigned))) : complete_lattice.is_Sup_finite_compact (mul_zero_class (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_92931 (h0 : functor.add_const (function.extfun Type ring) name) : @is_domain.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_92932 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} linarith.ineq (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) linarith.ineq)  := sorry --non-trivial
lemma new_lemma_92933 (h0 : topological_space (canonically_ordered_monoid (has_Inf pos))) : preconnected_space (canonically_ordered_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_92934 (h0 : topological_space (has_to_string (ring Type))) : normal_space (has_to_string (ring Type)) := sorry --non-trivial
lemma new_lemma_92935 (h1 : ring (complete_semilattice_Sup string_imp)) : is_domain (complete_semilattice_Sup string_imp) := sorry --non-trivial
lemma new_lemma_92936 (h0 : topological_space (uniform_space reducibility_hints)) (h1 : preorder (uniform_space reducibility_hints)) : order_topology (uniform_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_92937 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_group unsigned)) unsigned) : @unique_factorization_monoid.{0} (add_group.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_92938 (h0 : uniform_space (has_le (mul_one_class linarith.comp_source))) : complete_space (has_le (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_92939 (h0 : complete_lattice (has_neg_part (option (option name)))) : is_compactly_generated (has_neg_part (option (option name))) := sorry --non-trivial
lemma new_lemma_92940 (h0 : ring (with_zero (random_gen string_imp))) : rank_condition (with_zero (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_92941 (h0 : has_le enat -> has_le enat -> Prop) (h1 : has_le enat) : set.subsingleton (relation.refl_gen h0 h1) := sorry --non-trivial
lemma new_lemma_92942 (h0 : has_neg (has_ssubset reducibility_hints)) (h1 : measurable_space (has_ssubset reducibility_hints)) : has_measurable_neg (has_ssubset reducibility_hints) := sorry --non-trivial
lemma new_lemma_92943 (h0 : functor.comp add_monoid has_nndist Type) : @add_monoid.fg.{1} (has_nndist.{1} Type) (@functor.comp.run.{1 1 1} add_monoid.{1} has_nndist.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_92944 (h0 : not (uniform_space (has_add linarith.ineq) -> false)) : @complete_space.{0} (has_add.{0} linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_add.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_92945 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_92946 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (cancel_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_92947 (h0 : group (has_top (semiring unsigned))) : is_cyclic (has_top (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_92948 (h0 : semiring (add_cancel_monoid (finset environment.implicit_infer_kind))) : is_noetherian_ring (add_cancel_monoid (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_92949 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg pos)) : @locally_compact_space.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{0} pos) h0) (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_92950 (h0 : topological_space (ring (boolean_algebra Type))) : preirreducible_space (ring (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_92951 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_92952 (h0 : functor.add_const (ring (cancel_monoid name)) environment.implicit_infer_kind) : @rank_condition.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (cancel_monoid.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_92953 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_92954 (h0 : uniform_space (has_neg (ring (has_add (ring (has_to_string pos)))))) : separated_space (has_neg (ring (has_add (ring (has_to_string pos))))) := sorry --non-trivial
lemma new_lemma_92955 (h0 : has_mem.mem (complete_semilattice_Sup linarith.comp_source) has_emptyc.emptyc) : @t0_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_92956 (h0 : complete_lattice (normed_group (has_norm congr_arg_kind))) : is_compactly_generated (normed_group (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_92957 (h0 : topological_space (mul_one_class (mul_one_class (mul_one_class enat)))) : t0_space (mul_one_class (mul_one_class (mul_one_class enat))) := sorry --non-trivial
lemma new_lemma_92958 (h1 : add_group (distrib_lattice (has_nnnorm char))) : is_add_cyclic (distrib_lattice (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_92959 (h0 : topological_space (comm_semigroup Type)) : regular_space (comm_semigroup Type) := sorry --non-trivial
lemma new_lemma_92960 (h0 : group (canonically_ordered_comm_semiring (has_Inf (finset linarith.comp)))) : group.fg (canonically_ordered_comm_semiring (has_Inf (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_92961 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_92962 (h0 : group (order_dual num)) : is_cyclic (order_dual num) := sorry --non-trivial
lemma new_lemma_92963 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (semiring.{0} (has_norm.{0} (has_norm.{0} (semiring.{0} empty)))) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} (has_norm.{0} (has_norm.{0} (semiring.{0} empty)))))  := sorry --non-trivial
lemma new_lemma_92964 (h0 : topological_space (pseudo_metric_space name)) : irreducible_space (pseudo_metric_space name) := sorry --non-trivial
lemma new_lemma_92965 (h0 : topological_space (has_neg_part (finset (finset pos)))) : regular_space (has_neg_part (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_92966 (h1 : uniform_space (id string_imp)) : complete_space (id string_imp) := sorry --non-trivial
lemma new_lemma_92967 (h0 : topological_space (comm_group (comm_group name))) : path_connected_space (comm_group (comm_group name)) := sorry --non-trivial
lemma new_lemma_92968 (h0 : ring (cancel_monoid name)) : is_domain (cancel_monoid name) := sorry --non-trivial
lemma new_lemma_92969 (h0 : complete_lattice (linear_ordered_semiring (has_norm fun_info))) : is_atomistic (linear_ordered_semiring (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_92970 (h0 : functor.add_const (complete_lattice (has_neg_part name)) name) : @is_atomistic.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg_part.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_92971 (h0 : topological_space (linear_ordered_field congr_arg_kind)) : discrete_topology (linear_ordered_field congr_arg_kind) := sorry --non-trivial
lemma new_lemma_92972 (h0 : ordered_comm_monoid (has_bot (has_add (has_Inf Type)))) : has_exists_mul_of_le (has_bot (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_92973 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_92974 (h0 : functor.add_const (semiring (semigroup unsigned)) environment.implicit_infer_kind) : @is_noetherian_ring.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (semigroup.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_92975 (h0 : complete_lattice (has_nndist (boolean_algebra.core Type))) : is_compactly_generated (has_nndist (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_92976 (h0 : functor.add_const (topological_space (comm_group unsigned)) linarith.comp) : @loc_path_connected_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_92977 (h0 : functor.add_const (topological_space (has_neg unsigned)) linarith.comp) : @topological_space.separable_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_92978 (h0 : topological_space (has_one (semiring empty))) : irreducible_space (has_one (semiring empty)) := sorry --non-trivial
lemma new_lemma_92979 (h0 : topological_space (has_nndist (ring (ring (ring Type))))) : totally_separated_space (has_nndist (ring (ring (ring Type)))) := sorry --non-trivial
lemma new_lemma_92980 (h0 : complete_lattice (add_cancel_monoid (add_comm_monoid Type))) : is_atomistic (add_cancel_monoid (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_92981 (h0 : topological_space (finset (finset (finset ennreal)))) : t1_space (finset (finset (finset ennreal))) := sorry --non-trivial
lemma new_lemma_92982 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_92983 (h0 : functor.add_const (add_group (ring name)) unsigned) : @is_add_cyclic.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (ring.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_92984 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_92985 (h0 : list (finset (ring environment.implicit_infer_kind))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_92986 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_92987 (h0 : topological_space (has_add (finset pos))) : path_connected_space (has_add (finset pos)) := sorry --non-trivial
lemma new_lemma_92988 (h0 : functor.add_const (ordered_comm_monoid (canonically_ordered_comm_semiring linarith.comp)) (has_Inf linarith.comp)) : @has_exists_mul_of_le.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_92989 (h0 : topological_space (semigroup (option (option (option ennreal))))) : normal_space (semigroup (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_92990 (h0 : ring (fintype (add_cancel_comm_monoid linarith.ineq))) : strong_rank_condition (fintype (add_cancel_comm_monoid linarith.ineq)) := sorry --non-trivial
lemma new_lemma_92991 (h0 : ordered_add_comm_monoid (complete_distrib_lattice linarith.comp)) : archimedean (complete_distrib_lattice linarith.comp) := sorry --non-trivial
lemma new_lemma_92992 (h0 : functor.add_const (ring (has_neg Type)) linarith.comp) : @rank_condition.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_neg.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_92993 (h0 : ring (simple_graph congr_arg_kind)) : strong_rank_condition (simple_graph congr_arg_kind) := sorry --non-trivial
lemma new_lemma_92994 (h0 : ordered_comm_monoid (sub_neg_monoid (has_Inf (finset (finset Type))))) : has_exists_mul_of_le (sub_neg_monoid (has_Inf (finset (finset Type)))) := sorry --non-trivial
lemma new_lemma_92995 (h0 : complete_lattice (has_zero linarith.comp)) : complete_lattice.is_Sup_finite_compact (has_zero linarith.comp) := sorry --non-trivial
lemma new_lemma_92996 (h0 : uniform_space (id num)) : complete_space (id num) := sorry --non-trivial
lemma new_lemma_92997 (h0 : functor.add_const (topological_space (mul_zero_class pos)) name) : @t1_space.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_92998 (h0 : ring (ordered_ring congr_arg_kind)) : rank_condition (ordered_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_92999 (h0 : topological_space (has_neg_part ennreal)) : normal_space (has_neg_part ennreal) := sorry --non-trivial
lemma new_lemma_93000 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_93001 (h0 : filter (has_bot (option unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_93002 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_93003 (h0 : function.extfun Type uniform_space) : @complete_space.{0} name (@function.extfun_app.{2 1} Type uniform_space.{0} h0 name)  := sorry --non-trivial
lemma new_lemma_93004 (h0 : functor.add_const (add_group (has_add pos)) name) : @is_add_cyclic.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_add.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_93005 (h0 : functor.add_const (ring (boolean_algebra.core unsigned)) Type) : @is_domain.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 1} (ring.{0} (boolean_algebra.core.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_93006 (h0 : function.extfun Type (functor.comp topological_space ring)) : @totally_disconnected_space.{0} (ring.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} ring.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_93007 (h0 : functor.comp group semigroup Type) : @is_cyclic.{1} (semigroup.{1} Type) (@functor.comp.run.{1 1 1} group.{1} semigroup.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_93008 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_comm_monoid environment.implicit_infer_kind)) Type) : @unique_factorization_monoid.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_93009 (h0 : topological_space (has_to_string (normed_comm_ring Type))) : t0_space (has_to_string (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_93010 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_93011 (h0 : group (complete_linear_order (semiring (semiring empty)))) : normalizer_condition (complete_linear_order (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_93012 (h0 : complete_lattice (encodable linarith.ineq)) : complete_lattice.is_Sup_finite_compact (encodable linarith.ineq) := sorry --non-trivial
lemma new_lemma_93013 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_domain.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_93014 (h0 : not (topological_space name -> false)) : @totally_disconnected_space.{0} name (@classical.by_contradiction'.{1} (topological_space.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_93015 (h0 : not (group (semi_normed_comm_ring fun_info) -> false)) : @is_cyclic.{0} (semi_normed_comm_ring.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (semi_normed_comm_ring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_93016 (h0 : filter (metric_space (semiring num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_93017 (h0 : function.extfun Type ring) : @rank_condition.{0} (left_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (left_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_93018 (h0 : uniform_space (linear_ordered_add_comm_group (has_nnnorm fun_info))) : complete_space (linear_ordered_add_comm_group (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_93019 (h0 : topological_space (ordered_cancel_add_comm_monoid (option (option empty)))) : t0_space (ordered_cancel_add_comm_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_93020 (h0 : functor.add_const (topological_space (ring linarith.comp)) name) : @sequential_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_93021 (h0 : add_monoid (has_add Type)) : add_monoid.fg (has_add Type) := sorry --non-trivial
lemma new_lemma_93022 (h0 : group (linear_ordered_semiring (has_top (has_emptyc congr_arg_kind)))) : is_cyclic (linear_ordered_semiring (has_top (has_emptyc congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_93023 (h0 : topological_space (topological_space (has_nnnorm (has_nnnorm to_additive.value_type)))) : locally_compact_space (topological_space (has_nnnorm (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_93024 (h0 : not (filter (fintype (random_gen fun_info)) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_93025 (h0 : functor.add_const (complete_lattice (add_right_cancel_monoid empty)) num) : @complete_lattice.is_Sup_finite_compact.{0} (add_right_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_right_cancel_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_93026 (h0 : functor.add_const (topological_space (comm_group pos)) environment.implicit_infer_kind) : @locally_compact_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_93027 (h0 : functor.add_const (topological_space (has_Inf Type)) Type) : @path_connected_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_Inf.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_93028 (h0 : group (normed_group char)) : group.fg (normed_group char) := sorry --non-trivial
lemma new_lemma_93029 (h0 : topological_space (non_assoc_semiring unsigned)) : path_connected_space (non_assoc_semiring unsigned) := sorry --non-trivial
lemma new_lemma_93030 (h0 : list (has_neg_part name)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_93031 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_93032 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_93033 (h0 : topological_space (has_pos_part (has_add linarith.comp))) : t0_space (has_pos_part (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_93034 (h0 : topological_space (add_group (has_union empty))) : locally_compact_space (add_group (has_union empty)) := sorry --non-trivial
lemma new_lemma_93035 (h0 : has_mem.mem (with_bot empty) has_emptyc.emptyc) : @group.fg.{0} (with_bot.{0} empty) (@finset.pi.empty.{1 0} Type group.{0} (with_bot.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_93036 (h0 : monoid (ordered_comm_monoid (has_Inf (has_Inf (finset pos))))) : monoid.fg (ordered_comm_monoid (has_Inf (has_Inf (finset pos)))) := sorry --non-trivial
lemma new_lemma_93037 (h0 : function.extfun (finset Type) (has_mem.mem (semiring linarith.comp_source))) : @is_cyclic.{0} (semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type group.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_93038 (h0 : functor.add_const (uniform_space (boolean_algebra.core Type)) pos) : @complete_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (boolean_algebra.core.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_93039 (h0 : group (random_gen (with_bot to_additive.value_type))) : group.fg (random_gen (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_93040 (h0 : ring (ring (boolean_algebra Type))) : is_domain (ring (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_93041 (h0 : functor.add_const (function.extfun Type group) pos) : @is_cyclic.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_93042 (h0 : to_additive.value_type -> linarith.ineq -> Prop) : relator.right_total h0 := sorry --non-trivial
lemma new_lemma_93043 (h0 : ring string_imp) (h1 : ring (complete_semilattice_Sup (ring.positive_cone string_imp))) : rank_condition (complete_semilattice_Sup (ring.positive_cone string_imp)) := sorry --non-trivial
lemma new_lemma_93044 (h0 : ring (boolean_algebra.core congr_arg_kind)) : is_principal_ideal_ring (boolean_algebra.core congr_arg_kind) := sorry --non-trivial
lemma new_lemma_93045 (h0 : fin has_zero.zero) : @is_compactly_generated.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (has_bot.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_93046 (h0 : topological_space (add_left_cancel_semigroup num)) : loc_path_connected_space (add_left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_93047 (h0 : functor.add_const (add_monoid (comm_group Type)) name) : @add_monoid.fg.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (comm_group.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_93048 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (with_one.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (with_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_93049 (h0 : topological_space (add_comm_monoid (option pos))) : normal_space (add_comm_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_93050 (h1 : filter (denumerable (has_nnnorm char))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_93051 (h0 : set (semi_normed_ring std_gen)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_93052 (h0 : uniform_space (has_add (ring linarith.comp))) : separated_space (has_add (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_93053 (h0 : group (random_gen (has_norm (semiring (has_norm (has_norm fun_info)))))) : group.fg (random_gen (has_norm (semiring (has_norm (has_norm fun_info))))) := sorry --non-trivial
lemma new_lemma_93054 (h0 : uniform_space (finset (has_pos_part pos))) : complete_space (finset (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_93055 (h0 : add_group (has_star unsigned)) : is_add_cyclic (has_star unsigned) := sorry --non-trivial
lemma new_lemma_93056 (h0 : function.extfun Type topological_space) : @t0_space.{0} (comm_monoid.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_monoid.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_93057 (h0 : topological_space (has_to_string num)) : locally_compact_space (has_to_string num) := sorry --non-trivial
lemma new_lemma_93058 (h0 : functor.add_const (topological_space (has_zero pos)) Type) : @t0_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_93059 (h0 : linear_ordered_field pos -> linear_ordered_field pos -> Prop) : is_symm (linear_ordered_field pos) h0 := sorry --non-trivial
lemma new_lemma_93060 (h0 : functor.add_const (complete_lattice (add_comm_monoid Type)) Type) : @is_compactly_generated.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (add_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_93061 (h0 : functor.add_const (functor.add_const (semiring subsingleton_info) linarith.comp) linarith.comp) : @is_noetherian_ring.{0} subsingleton_info (@functor.add_const.run.{0 0} (semiring.{0} subsingleton_info) linarith.comp (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (semiring.{0} subsingleton_info) linarith.comp) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_93062 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_93063 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_93064 (h0 : finset (has_nndist (has_Inf linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_93065 (h0 : group (with_bot to_additive.value_type)) : group.fg (with_bot to_additive.value_type) := sorry --non-trivial
lemma new_lemma_93066 (h1 : Prop) : set.separates_points (id (fun (h0 : add_comm_semigroup environment.projection_info -> char), h1)) := sorry --non-trivial
lemma new_lemma_93067 (h1 : group (with_bot (random_gen string_imp))) : is_cyclic (with_bot (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_93068 (h0 : functor.add_const (complete_lattice (ring pos)) (has_to_string pos)) : @is_atomistic.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} pos)) (has_to_string.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_93069 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} h0 (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_93070 (h0 : group (filter num)) : group.fg (filter num) := sorry --non-trivial
lemma new_lemma_93071 (h0 : topological_space (pseudo_metric_space ennreal)) : totally_disconnected_space (pseudo_metric_space ennreal) := sorry --non-trivial
lemma new_lemma_93072 (h0 : complete_lattice (boolean_algebra.core (finset ennreal))) : is_atomistic (boolean_algebra.core (finset ennreal)) := sorry --non-trivial
lemma new_lemma_93073 (h2 : has_mem.mem (with_one (preorder (random_gen (with_bot (with_bot string_imp))))) has_emptyc.emptyc) : @t0_space.{0} (with_one.{0} (preorder.{0} (random_gen.{0} (with_bot.{0} (with_bot.{0} string_imp))))) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} (preorder.{0} (random_gen.{0} (with_bot.{0} (with_bot.{0} string_imp))))) h2)  := sorry --non-trivial
lemma new_lemma_93074 (h0 : ring (has_neg (finset linarith.comp))) : is_principal_ideal_ring (has_neg (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_93075 (h0 : topological_space (group_with_zero (option (option (option num))))) : locally_compact_space (group_with_zero (option (option (option num)))) := sorry --non-trivial
lemma new_lemma_93076 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (canonically_ordered_comm_semiring.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_ordered_comm_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_93077 (h0 : uniform_space (denumerable char)) : complete_space (denumerable char) := sorry --non-trivial
lemma new_lemma_93078 (h0 : has_to_string num -> has_to_string num -> Prop) : is_symm (has_to_string num) h0 := sorry --non-trivial
lemma new_lemma_93079 (h0 : not (finset (option empty) -> false)) : finset.nonempty (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_93080 (h0 : functor.add_const (function.extfun Type add_group) (option name)) : @is_add_cyclic.{0} (pseudo_metric_space.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) (option.{0} name) h0) (pseudo_metric_space.{0} name))  := sorry --non-trivial
lemma new_lemma_93081 (h1 : group (complete_semilattice_Sup congr_arg_kind)) : is_cyclic (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_93082 (h0 : uniform_space (has_nndist (finset (finset name)))) : separated_space (has_nndist (finset (finset name))) := sorry --non-trivial
lemma new_lemma_93083 (h0 : function.extfun Type topological_space) : @normal_space.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_93084 (h0 : set (linear_ordered_comm_group_with_zero linarith.ineq)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_93085 (h0 : ring (add_right_cancel_monoid (semiring num))) : rank_condition (add_right_cancel_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_93086 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (comm_ring.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_ring.{0} char))  := sorry --non-trivial
lemma new_lemma_93087 (h0 : function.extfun Type topological_space) : discrete_topology empty := sorry --non-trivial
lemma new_lemma_93088 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_93089 (h0 : complete_lattice (semigroup (has_neg (ring Type)))) : is_compactly_generated (semigroup (has_neg (ring Type))) := sorry --non-trivial
lemma new_lemma_93090 (h0 : functor.add_const (topological_space (comm_group pos)) Type) : @path_connected_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_93091 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (id congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_93092 (h2 : add_group linarith.ineq) : is_add_cyclic linarith.ineq := sorry --non-trivial
lemma new_lemma_93093 (h0 : functor.add_const (topological_space (left_cancel_monoid num)) empty) : @t1_space.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_93094 (h0 : list (ring (has_add unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_93095 (h0 : topological_space (has_norm (has_top linarith.ineq))) : totally_disconnected_space (has_norm (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_93096 (h0 : ordered_comm_monoid (has_neg_part (option pos))) : has_exists_mul_of_le (has_neg_part (option pos)) := sorry --non-trivial
lemma new_lemma_93097 (h1 : complete_lattice (uniform_space string_imp)) : complete_lattice.is_Sup_finite_compact (uniform_space string_imp) := sorry --non-trivial
lemma new_lemma_93098 (h0 : topological_space (has_pos_part (has_add Type))) : preconnected_space (has_pos_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_93099 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_93100 (h0 : complete_lattice (ordered_comm_ring (has_Inf pos))) : is_compactly_generated (ordered_comm_ring (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_93101 (h0 : function.extfun Type (functor.add_const (topological_space (is_R_or_C empty)))) : @normal_space.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (is_R_or_C.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_93102 (h1 : complete_lattice (has_norm fun_info)) : is_atomistic (has_norm fun_info) := sorry --non-trivial
lemma new_lemma_93103 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_add_cyclic.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (add_group.{1} (generalized_boolean_algebra.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_93104 (h0 : monoid (with_bot (random_gen empty))) : monoid.fg (with_bot (random_gen empty)) := sorry --non-trivial
lemma new_lemma_93105 (h0 : monoid (has_norm ennreal)) : monoid.fg (has_norm ennreal) := sorry --non-trivial
lemma new_lemma_93106 (h0 : complete_lattice (add_comm_monoid (has_Inf Type))) : complete_lattice.is_Sup_finite_compact (add_comm_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_93107 (h0 : topological_space (complete_distrib_lattice (option (option congr_arg_kind)))) : normal_space (complete_distrib_lattice (option (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_93108 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @topological_space.separable_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_93109 (h0 : functor.add_const (prod (semiring empty) (semiring empty)) unsigned) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_93110 (h0 : functor.add_const (add_monoid (has_zero environment.implicit_infer_kind)) linarith.comp) : @add_monoid.fg.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_zero.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_93111 (h0 : ring (linear_ordered_comm_group_with_zero fun_info)) : is_domain (linear_ordered_comm_group_with_zero fun_info) := sorry --non-trivial
lemma new_lemma_93112 (h0 : set (add_comm_semigroup (add_comm_semigroup std_gen))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_93113 (h0 : list (free_add_monoid (semiring (semiring (semiring unsigned))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_93114 (h0 : ring (dlist (has_nnnorm linarith.ineq))) : strong_rank_condition (dlist (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_93115 (h1 : ring (random_gen linarith.comp)) : is_domain (random_gen linarith.comp) := sorry --non-trivial
lemma new_lemma_93116 (h0 : topological_space (random_gen (has_norm (has_norm (has_norm linarith.comp))))) : irreducible_space (random_gen (has_norm (has_norm (has_norm linarith.comp)))) := sorry --non-trivial
lemma new_lemma_93117 (h0 : set (semi_normed_comm_ring linarith.comp_source)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_93118 (h0 : topological_space (group_with_zero (option (option ennreal)))) : preirreducible_space (group_with_zero (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_93119 (h0 : finset (boolean_algebra (ring (has_Inf linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_93120 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_93121 (h0 : linarith.comp_source -> nat) (h1 : nat) (h2 : add_group (derive_fintype.finset_above linarith.comp_source h0 h1)) : is_add_cyclic (derive_fintype.finset_above linarith.comp_source h0 h1) := sorry --non-trivial
lemma new_lemma_93122 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_93123 (h0 : functor.add_const (topological_space (ordered_ring unsigned)) unsigned) : @topological_space.separable_space.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_93124 (h0 : ring (normed_group (semiring (semiring empty)))) : rank_condition (normed_group (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_93125 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_93126 (h0 : uniform_space (has_norm (has_inv (has_nnnorm linarith.comp_source)))) : complete_space (has_norm (has_inv (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_93127 (h0 : filter (has_ssubset (has_nnnorm char))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_93128 (h0 : fin has_zero.zero) : @normalizer_condition.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (group.{1} (boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_93129 (h0 : function.extfun Type (functor.add_const (topological_space (ordered_comm_monoid name)))) : @irreducible_space.{0} (ordered_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} name)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} name))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_93130 (h0 : not (complete_lattice (has_top to_additive.value_type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_top.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_93131 (h0 : topological_space (normed_comm_ring congr_arg_kind)) : irreducible_space (normed_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_93132 (h0 : not (topological_space (partial_order num) -> false)) : @topological_space.separable_space.{0} (partial_order.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (partial_order.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_93133 (h0 : complete_lattice (has_nnnorm (has_ssubset to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (has_nnnorm (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_93134 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type monoid.{0} h0 (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_93135 (h0 : list (has_top (has_norm linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_93136 (h0 : complete_lattice (add_comm_monoid (option empty))) : is_compactly_generated (add_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_93137 (h0 : has_lt (normed_field (mul_one_class (mul_one_class reducibility_hints)))) : no_max_order (normed_field (mul_one_class (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_93138 (h0 : functor.add_const (group (normed_linear_ordered_group empty)) congr_arg_kind) : @normalizer_condition.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (normed_linear_ordered_group.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_93139 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_93140 (h0 : not (ring (id empty) -> false)) : @is_domain.{0} (@id.{2} Type empty) (@classical.by_contradiction'.{1} (ring.{0} (@id.{2} Type empty)) h0)  := sorry --non-trivial
lemma new_lemma_93141 (h0 : topological_space (ring (normed_comm_ring (normed_comm_ring pos)))) : locally_compact_space (ring (normed_comm_ring (normed_comm_ring pos))) := sorry --non-trivial
lemma new_lemma_93142 (h0 : ring (measurable_space.dynkin_system num)) : strong_rank_condition (measurable_space.dynkin_system num) := sorry --non-trivial
lemma new_lemma_93143 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_neg pos)) environment.implicit_infer_kind) : @unique_factorization_monoid.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_neg.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_93144 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_93145 (h0 : topological_space (ordered_ring unsigned)) : t1_space (ordered_ring unsigned) := sorry --non-trivial
lemma new_lemma_93146 (h0 : monoid (has_norm (random_gen congr_arg_kind))) : monoid.fg (has_norm (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_93147 (h0 : not (add_monoid (add_right_cancel_monoid num) -> false)) : @add_monoid.fg.{0} (add_right_cancel_monoid.{0} num) (@classical.by_contradiction'.{1} (add_monoid.{0} (add_right_cancel_monoid.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_93148 (h0 : topological_space (add_group (semiring unsigned))) : totally_separated_space (add_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_93149 (h0 : ring (has_neg_part (comm_group (comm_group name)))) : is_principal_ideal_ring (has_neg_part (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_93150 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @topological_space.separable_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_93151 (h0 : functor.add_const (list (normed_comm_ring name)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_93152 (h0 : group (has_pos_part (has_Inf (has_pos_part Type)))) : normalizer_condition (has_pos_part (has_Inf (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_93153 (h0 : group (with_one (has_inv linarith.comp_source))) : normalizer_condition (with_one (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_93154 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (simple_graph.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (simple_graph.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_93155 (h1 : list (measurable_space (with_bot (with_bot string_imp)))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_93156 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_ssubset.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (has_ssubset.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_93157 (h0 : topological_space (has_pos_part real)) : preirreducible_space (has_pos_part real) := sorry --non-trivial
lemma new_lemma_93158 (h0 : topological_space (generalized_boolean_algebra (finset (finset pos)))) : normal_space (generalized_boolean_algebra (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_93159 (h0 : add_group (ordered_comm_monoid Type)) : is_add_cyclic (ordered_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_93160 (h0 : functor.add_const (topological_space (left_cancel_semigroup congr_arg_kind)) congr_arg_kind) : @topological_space.separable_space.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_93161 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_93162 (h0 : topological_space (has_neg (has_neg linarith.comp))) : preirreducible_space (has_neg (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_93163 (h0 : ring (has_to_string (finset Type))) : rank_condition (has_to_string (finset Type)) := sorry --non-trivial
lemma new_lemma_93164 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (ring (option empty))) := sorry --non-trivial
lemma new_lemma_93165 (h0 : ring (has_nndist (pseudo_metric_space name))) : strong_rank_condition (has_nndist (pseudo_metric_space name)) := sorry --non-trivial
lemma new_lemma_93166 (h0 : add_group (monoid_with_zero (option (option ennreal)))) : is_add_cyclic (monoid_with_zero (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_93167 (h0 : complete_lattice (boolean_algebra (boolean_algebra.core unsigned))) : is_atomistic (boolean_algebra (boolean_algebra.core unsigned)) := sorry --non-trivial
lemma new_lemma_93168 (h0 : functor.comp filter cancel_monoid pos) : countable_Inter_filter (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_93169 (h0 : topological_space (add_right_cancel_monoid (semiring (semiring congr_arg_kind)))) (h1 : option (topological_space (add_right_cancel_monoid (semiring (semiring congr_arg_kind))))) : topological_space.separable_space (add_right_cancel_monoid (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_93170 (h0 : functor.add_const (filter (finset unsigned)) (ring (ring linarith.comp))) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_93171 (h0 : function.extfun Type group) : @normalizer_condition.{0} (as_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (as_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_93172 (h0 : ring (complete_distrib_lattice real)) : is_principal_ideal_ring (complete_distrib_lattice real) := sorry --non-trivial
lemma new_lemma_93173 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_93174 (h0 : functor.add_const (group (has_neg linarith.comp)) linarith.comp) : @group.fg.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_93175 (h0 : functor.add_const (ring (semigroup pos)) environment.implicit_infer_kind) : @rank_condition.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_93176 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 string_imp) := sorry --non-trivial
lemma new_lemma_93177 (h0 : topological_space (as_linear_order unsigned)) : locally_compact_space (as_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_93178 (h0 : complete_lattice (fintype (random_gen to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (fintype (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_93179 (h0 : functor.add_const (filter (has_to_string linarith.comp)) environment.implicit_infer_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_93180 (h0 : set (has_lt (mul_one_class (mul_one_class (mul_one_class (mul_one_class fun_info)))))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_93181 (h0 h1 : multiset (has_div linarith.comp_source)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_93182 (h1 : not (ring (add_left_cancel_monoid linarith.comp_source) -> false)) : @is_domain.{0} (add_left_cancel_monoid.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (add_left_cancel_monoid.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_93183 (h0 : group (has_pos_part (has_nndist (finset (ring (has_nndist (has_nndist pos))))))) : normalizer_condition (has_pos_part (has_nndist (finset (ring (has_nndist (has_nndist pos)))))) := sorry --non-trivial
lemma new_lemma_93184 (h0 : complete_lattice (measurable_space.dynkin_system empty)) : is_atomistic (measurable_space.dynkin_system empty) := sorry --non-trivial
lemma new_lemma_93185 (h0 : functor.add_const (uniform_space (normed_linear_ordered_group unsigned)) empty) : @complete_space.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (normed_linear_ordered_group.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_93186 (h0 : functor.add_const (ordered_comm_monoid (add_comm_monoid Type)) (ring Type)) : @has_exists_mul_of_le.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (ordered_comm_monoid.{1} (add_comm_monoid.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_93187 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) name) : @t1_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_93188 (h0 : ring (has_emptyc (has_top linarith.comp_source))) : is_domain (has_emptyc (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_93189 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (linear_ordered_add_comm_group.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_add_comm_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_93190 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_93191 (h0 : functor.add_const (topological_space (mul_zero_class ennreal)) unsigned) : @regular_space.{0} (mul_zero_class.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_93192 (h0 : function.extfun (Type 1) topological_space) : @t1_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_93193 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_93194 (h0 : cancel_comm_monoid_with_zero (ordered_comm_monoid (has_pos_part (finset Type)))) : unique_factorization_monoid (ordered_comm_monoid (has_pos_part (finset Type))) := sorry --non-trivial
lemma new_lemma_93195 (h0 : topological_space (boolean_algebra.core unsigned)) : path_connected_space (boolean_algebra.core unsigned) := sorry --non-trivial
lemma new_lemma_93196 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_93197 (h0 : topological_space (has_top string_imp)) : t0_space (has_top string_imp) := sorry --non-trivial
lemma new_lemma_93198 (h0 : set (normed_field enat)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_93199 (h0 : semiring (has_pos_part (has_bot (has_bot (has_Inf real))))) : is_noetherian_ring (has_pos_part (has_bot (has_bot (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_93200 (h0 : ring (has_neg_part name)) : strong_rank_condition (has_neg_part name) := sorry --non-trivial
lemma new_lemma_93201 (h0 : group (add_comm_monoid (has_add (has_add name)))) : group.fg (add_comm_monoid (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_93202 (h0 : ereal) (h1 : sym2 ereal) : sym2.mem h0 h1 := sorry --non-trivial
lemma new_lemma_93203 (h0 : monoid (free_add_monoid empty)) : monoid.fg (free_add_monoid empty) := sorry --non-trivial
lemma new_lemma_93204 (h0 : topological_space (with_one congr_arg_kind)) : preirreducible_space (with_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_93205 (h0 : has_mem.mem (normed_group linarith.comp) has_emptyc.emptyc) : @totally_separated_space.{0} (normed_group.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_93206 (h0 : functor.add_const (functor.add_const (group environment.implicit_infer_kind) Type) (mul_one_class linarith.comp)) : @group.fg.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 1} (group.{0} environment.implicit_infer_kind) Type (@functor.add_const.run.{0 0} (functor.add_const.{0 1} (group.{0} environment.implicit_infer_kind) Type) (mul_one_class.{0} linarith.comp) h0))  := sorry --non-trivial
lemma new_lemma_93207 (h0 : group (comm_group (has_add Type))) : is_cyclic (comm_group (has_add Type)) := sorry --non-trivial
lemma new_lemma_93208 (h0 : group (linear_ordered_add_comm_group (has_nnnorm linarith.comp_source))) : is_cyclic (linear_ordered_add_comm_group (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_93209 (h0 : prod (group_with_zero num) (group_with_zero num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_93210 (h0 : function.extfun Type (functor.add_const (list znum))) : list.nodup (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_93211 (h0 : ring (has_ssubset (random_gen linarith.comp_source))) : rank_condition (has_ssubset (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_93212 (h1 : group (dlist char)) : group.fg (dlist char) := sorry --non-trivial
lemma new_lemma_93213 (h0 : topological_space (dlist (has_nnnorm linarith.ineq))) : path_connected_space (dlist (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_93214 (h0 : not (topological_space (normed_field (comm_ring reducibility_hints)) -> false)) : @t0_space.{0} (normed_field.{0} (comm_ring.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_field.{0} (comm_ring.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_93215 (h0 : ordered_add_comm_monoid (has_bot (has_Inf (has_Inf real)))) : archimedean (has_bot (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_93216 (h0 : complete_lattice (left_cancel_monoid (option (option unsigned)))) : complete_lattice.is_Sup_finite_compact (left_cancel_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_93217 (h0 : filter (normed_comm_ring (has_nndist pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_93218 (h1 : list (comm_ring fun_info)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_93219 (h0 : topological_space (has_zero (has_add (has_pos_part (has_Inf Type))))) : normal_space (has_zero (has_add (has_pos_part (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_93220 (h3 : uniform_space (semi_normed_comm_ring (denumerable (comm_ring char)))) : complete_space (semi_normed_comm_ring (denumerable (comm_ring char))) := sorry --non-trivial
lemma new_lemma_93221 (h0 : not (complete_lattice (add_cancel_comm_monoid reducibility_hints) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_comm_monoid.{0} reducibility_hints) (@classical.by_contradiction'.{1} (complete_lattice.{0} (add_cancel_comm_monoid.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_93222 (h0 : functor.add_const (filter (linear_ordered_comm_monoid_with_zero empty)) empty) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_93223 (h0 : uniform_space (partial_order num) -> Prop) (h1 : Exists (fun (x : uniform_space (partial_order num)), h0 x)) : @complete_space.{0} (partial_order.{0} num) (@classical.some.{1} (uniform_space.{0} (partial_order.{0} num)) h0 h1)  := sorry --non-trivial
lemma new_lemma_93224 (h0 : ring (cancel_monoid (has_nndist ennreal))) : is_principal_ideal_ring (cancel_monoid (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_93225 (h0 : uniform_space (has_nnnorm to_additive.value_type)) : complete_space (has_nnnorm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_93226 (h1 : topological_space (normed_field (has_nnnorm (random_gen (has_lt linarith.comp_source))))) : t0_space (normed_field (has_nnnorm (random_gen (has_lt linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_93227 (h0 : functor.add_const (monoid (semigroup Type)) (ring Type)) : @monoid.fg.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (monoid.{1} (semigroup.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_93228 (h0 : group (has_top (semiring num))) : group.fg (has_top (semiring num)) := sorry --non-trivial
lemma new_lemma_93229 (h0 : name -> name -> Prop) : well_founded h0 := sorry --non-trivial
lemma new_lemma_93230 (h0 : function.extfun Type group) : @group.fg.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_93231 (h0 : measurable_space (lex linarith.comp_source)) (h1 : set (lex linarith.comp_source)) : measurable_set h1 := sorry --non-trivial
lemma new_lemma_93232 (h0 : topological_space (has_nnnorm (denumerable fun_info))) : locally_compact_space (has_nnnorm (denumerable fun_info)) := sorry --non-trivial
lemma new_lemma_93233 (h0 : topological_space (id (has_inv linarith.comp_source))) : t0_space (id (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_93234 (h0 : ring (ordered_comm_monoid (has_neg (has_neg name)))) : is_principal_ideal_ring (ordered_comm_monoid (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_93235 (h0 : topological_space (id (random_gen (random_gen (random_gen string_imp))))) : path_connected_space (id (random_gen (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_93236 (h0 : ring (ring (has_add linarith.comp))) : strong_rank_condition (ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_93237 (h0 : semiring (add_comm_semigroup char)) (h3 : ideal (add_comm_semigroup char)) : ideal.is_prime h3 := sorry --non-trivial
lemma new_lemma_93238 (h0 : functor.comp ring has_to_string environment.implicit_infer_kind) : @strong_rank_condition.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} ring.{0} has_to_string.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_93239 (h0 : function.extfun Type group) : @is_cyclic.{0} (is_R_or_C.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (is_R_or_C.{0} num))  := sorry --non-trivial
lemma new_lemma_93240 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_compactly_generated.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_add.{0} real)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_93241 (h0 : filter (ring (boolean_algebra linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_93242 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_93243 (h0 : complete_lattice reducibility_hints) : complete_lattice.is_Sup_finite_compact reducibility_hints := sorry --non-trivial
lemma new_lemma_93244 (h0 : ordered_add_comm_monoid (canonically_linear_ordered_monoid (option name))) : archimedean (canonically_linear_ordered_monoid (option name)) := sorry --non-trivial
lemma new_lemma_93245 (h0 : topological_space (has_Inf (finset linarith.comp))) : preconnected_space (has_Inf (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_93246 (h0 : group (add_cancel_monoid (has_add (has_add (has_add name))))) : is_cyclic (add_cancel_monoid (has_add (has_add (has_add name)))) := sorry --non-trivial
lemma new_lemma_93247 (h0 : functor.add_const (add_group (boolean_algebra.core environment.implicit_infer_kind)) Type) : @is_add_cyclic.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (add_group.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_93248 (h0 : functor.add_const (topological_space (comm_group Type)) (has_neg linarith.comp)) : @totally_disconnected_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_93249 (h0 : add_monoid (normed_lattice_add_comm_group (has_add linarith.comp))) : add_monoid.fg (normed_lattice_add_comm_group (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_93250 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (linear_ordered_field.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} name))  := sorry --non-trivial
lemma new_lemma_93251 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (finset empty)) := sorry --non-trivial
lemma new_lemma_93252 (h0 : finset (normed_comm_ring (comm_group (comm_group Type)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_93253 (h0 : ordered_comm_monoid (canonically_ordered_monoid (has_Inf (has_Inf (has_Inf Type))))) : has_exists_mul_of_le (canonically_ordered_monoid (has_Inf (has_Inf (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_93254 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_93255 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (add_cancel_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_93256 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (linear_ordered_field.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_field.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_93257 (h0 : uniform_space (has_norm (random_gen (random_gen num)))) : separated_space (has_norm (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_93258 (h0 : uniform_space (has_add (distrib (distrib char)))) : complete_space (has_add (distrib (distrib char))) := sorry --non-trivial
lemma new_lemma_93259 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) (has_to_string Type)) : @path_connected_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_93260 (h0 : list (ordered_comm_monoid (ring Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_93261 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_93262 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) environment.implicit_infer_kind) : @discrete_topology.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_93263 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (add_left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_93264 (h0 : functor.add_const (uniform_space (has_zero name)) linarith.comp) : @separated_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_zero.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_93265 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @is_cyclic.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_93266 (h0 : functor.add_const (complete_lattice (option pos)) pos) : @is_atomistic.{0} (option.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (option.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_93267 (h0 : monoid (has_zero name)) : monoid.fg (has_zero name) := sorry --non-trivial
lemma new_lemma_93268 (h0 : topological_space (add_comm_monoid (add_cancel_monoid name))) : regular_space (add_comm_monoid (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_93269 (h1 : uniform_space (boolean_algebra.core fun_info)) : complete_space (boolean_algebra.core fun_info) := sorry --non-trivial
lemma new_lemma_93270 (h0 : complete_lattice (normed_field (random_gen reducibility_hints))) : is_compactly_generated (normed_field (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_93271 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_93272 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (measure_theory.measure_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measure_theory.measure_space.{0} num))  := sorry --non-trivial
lemma new_lemma_93273 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @normal_space.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_93274 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (monoid_with_zero pos)) := sorry --non-trivial
lemma new_lemma_93275 (h0 : functor.add_const (topological_space (has_neg name)) linarith.comp) : @t1_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_93276 (h0 : not (uniform_space (metric_space num) -> false)) : @complete_space.{0} (metric_space.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (metric_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_93277 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_93278 (h0 : ring (ring (boolean_algebra Type))) : rank_condition (ring (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_93279 (h0 : ring (is_R_or_C unsigned)) : is_domain (is_R_or_C unsigned) := sorry --non-trivial
lemma new_lemma_93280 (h0 : not (complete_lattice (bin_tree congr_arg_kind) -> false)) : @is_atomistic.{0} (bin_tree.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (bin_tree.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_93281 (h0 : functor.add_const (topological_space (has_add name)) linarith.comp) : @discrete_topology.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_93282 (h0 : functor.add_const (topological_space (partial_order empty)) (semiring empty)) : @locally_compact_space.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_93283 (h0 : has_mem.mem (normed_group linarith.comp_source) has_emptyc.emptyc) : @strong_rank_condition.{0} (normed_group.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (normed_group.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_93284 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_one.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_one.{0} num))  := sorry --non-trivial
lemma new_lemma_93285 (h0 : ring (measurable_space (has_norm linarith.comp_source))) : rank_condition (measurable_space (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_93286 (h0 : topological_space (cancel_monoid (boolean_algebra linarith.comp))) : normal_space (cancel_monoid (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_93287 (h0 : list (complete_distrib_lattice (has_nndist Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_93288 (h0 : group (add_cancel_monoid (has_neg linarith.comp))) : is_simple_group (add_cancel_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_93289 (h0 : not (ring (random_gen (has_nnnorm reducibility_hints)) -> false)) : @is_domain.{0} (random_gen.{0} (has_nnnorm.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} (has_nnnorm.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_93290 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_93291 (h0 : functor.add_const (group (free_add_monoid empty)) num) : @normalizer_condition.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (free_add_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_93292 (h0 : add_monoid (random_gen (semiring num))) : add_monoid.fg (random_gen (semiring num)) := sorry --non-trivial
lemma new_lemma_93293 (h0 : functor.add_const (finset (boolean_algebra.core name)) (has_Inf (has_Inf pos))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_93294 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_norm.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_93295 (h0 : filter (canonically_ordered_comm_semiring congr_arg_kind)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_93296 (h0 : functor.add_const (topological_space (has_nndist ennreal)) ennreal) : @loc_path_connected_space.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_93297 (h0 : cancel_comm_monoid_with_zero (ordered_comm_monoid (ring Type))) : unique_factorization_monoid (ordered_comm_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_93298 (h0 : not (function.extfun Type multiset -> false)) : multiset.nodup (function.extfun_app (classical.by_contradiction' h0) num) := sorry --non-trivial
lemma new_lemma_93299 (h0 : function.extfun Type (functor.add_const (complete_lattice (add_semigroup empty)))) : @complete_lattice.is_Sup_finite_compact.{0} (add_semigroup.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_semigroup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (add_semigroup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_93300 (h0 : functor.add_const (uniform_space (measure_theory.measure_space congr_arg_kind)) (semiring empty)) : @separated_space.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (measure_theory.measure_space.{0} congr_arg_kind)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_93301 (h0 : functor.add_const (add_monoid (normed_comm_ring unsigned)) pos) : @add_monoid.fg.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (normed_comm_ring.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_93302 (h0 : complete_lattice (canonically_linear_ordered_monoid (option (option ennreal)))) : is_atomistic (canonically_linear_ordered_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_93303 (h0 : function.extfun Type ring) : @rank_condition.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_93304 (h1 : ring (comm_ring (has_nnnorm (has_nnnorm to_additive.value_type)))) : is_domain (comm_ring (has_nnnorm (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_93305 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem add_monoid)) : @add_monoid.fg.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_monoid.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_monoid.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_93306 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_93307 (h0 : uniform_space (add_comm_semigroup enat)) : complete_space (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_93308 (h1 : list (semi_normed_comm_ring (has_ssubset (has_nnnorm (has_norm (complete_semilattice_Sup linarith.ineq)))))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_93309 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_93310 (h0 : add_group (distrib enat)) : is_add_cyclic (distrib enat) := sorry --non-trivial
lemma new_lemma_93311 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_93312 (h0 : list (linear_ordered_comm_group (option pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_93313 (h0 : has_mem.mem (function.extfun Type) has_emptyc.emptyc) : @is_domain.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) h0) ring.{0}) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_93314 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_93315 (h0 : not (complete_lattice (semi_normed_ring string.iterator_imp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (semi_normed_ring.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semi_normed_ring.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_93316 (h0 : add_group (boolean_algebra.core (comm_group (add_comm_monoid Type)))) : is_add_cyclic (boolean_algebra.core (comm_group (add_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_93317 (h0 : functor.add_const (topological_space (pseudo_metric_space ennreal)) unsigned) : @irreducible_space.{0} (pseudo_metric_space.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_93318 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_simple_group.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_93319 (h0 : list (dlist string_imp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_93320 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) pos) : @is_compactly_generated.{1} Type (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) pos h0) Type)  := sorry --non-trivial
lemma new_lemma_93321 (h0 : has_lt (semi_normed_comm_ring string.iterator_imp)) : no_max_order (semi_normed_comm_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_93322 (h0 : complete_lattice (has_norm (semiring (semiring linarith.comp)))) : is_atomistic (has_norm (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_93323 (h0 : list (canonically_ordered_comm_semiring Type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_93324 (h0 : functor.add_const (list (has_zero pos)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_93325 (h0 : group (has_neg (finset (finset Type)))) : normalizer_condition (has_neg (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_93326 (h0 : functor.add_const (topological_space (finset linarith.comp)) Type) : @t0_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_93327 (h0 : functor.add_const (list (finset linarith.comp)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_93328 (h0 : ring (non_unital_non_assoc_semiring (has_compl num))) : rank_condition (non_unital_non_assoc_semiring (has_compl num)) := sorry --non-trivial
lemma new_lemma_93329 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_sub.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_sub.{0} empty))  := sorry --non-trivial
lemma new_lemma_93330 (h2 : not (uniform_space (add_left_cancel_monoid fun_info) -> false)) : @complete_space.{0} (add_left_cancel_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (uniform_space.{0} (add_left_cancel_monoid.{0} fun_info)) h2)  := sorry --non-trivial
lemma new_lemma_93331 (h0 : set (semi_normed_comm_ring (mul_one_class (mul_one_class string.iterator_imp)))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_93332 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_93333 (h0 : functor.add_const (monoid (has_nndist Type)) pos) : @monoid.fg.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (has_nndist.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_93334 (h1 : function.extfun Type ring) : @rank_condition.{0} to_additive.value_type (@function.extfun_app.{2 1} Type ring.{0} h1 to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_93335 (h0 : filter (has_norm (has_top num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_93336 (h0 : ring (ordered_comm_ring (has_add (has_add real)))) : strong_rank_condition (ordered_comm_ring (has_add (has_add real))) := sorry --non-trivial
lemma new_lemma_93337 (h0 : functor.add_const (ordered_add_comm_monoid (has_add linarith.comp)) (has_Inf Type)) : @archimedean.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_add.{0} linarith.comp)) (has_Inf.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_93338 (h0 : topological_space (normed_comm_ring num)) : normal_space (normed_comm_ring num) := sorry --non-trivial
lemma new_lemma_93339 (h0 : topological_space (semigroup (semiring congr_arg_kind))) : topological_space.separable_space (semigroup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_93340 (h0 : prod (has_neg real) (has_neg real)) : set.diagonal (has_neg real) h0 := sorry --non-trivial
lemma new_lemma_93341 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_Sup.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_93342 (h0 : functor.add_const (add_group (comm_group pos)) name) : @is_add_cyclic.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (comm_group.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_93343 (h0 : ring (linear_ordered_comm_monoid_with_zero num)) : is_domain (linear_ordered_comm_monoid_with_zero num) := sorry --non-trivial
lemma new_lemma_93344 (h0 : not (topological_space (has_norm fun_info) -> false)) : @irreducible_space.{0} (has_norm.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_93345 (h0 : functor.add_const (monoid (canonically_ordered_comm_semiring Type)) pos) : @monoid.fg.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (canonically_ordered_comm_semiring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_93346 (h0 : complete_lattice (comm_group unsigned)) : complete_lattice.is_Sup_finite_compact (comm_group unsigned) := sorry --non-trivial
lemma new_lemma_93347 (h0 : ordered_add_comm_monoid (complete_distrib_lattice (has_bot real))) : archimedean (complete_distrib_lattice (has_bot real)) := sorry --non-trivial
lemma new_lemma_93348 (h0 : not (topological_space (has_emptyc num) -> false)) : @irreducible_space.{0} (has_emptyc.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_93349 (h0 : topological_space (normed_field char)) (h1 : preorder (normed_field char)) : order_closed_topology (normed_field char) := sorry --non-trivial
lemma new_lemma_93350 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_93351 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @discrete_topology.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_93352 (h0 : functor.add_const (topological_space (cancel_monoid unsigned)) empty) : @totally_separated_space.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_93353 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_93354 (h0 : group (mul_zero_class (lex (cancel_monoid environment.implicit_infer_kind)))) : normalizer_condition (mul_zero_class (lex (cancel_monoid environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_93355 (h0 : ordered_add_comm_monoid (complete_distrib_lattice real)) : archimedean (complete_distrib_lattice real) := sorry --non-trivial
lemma new_lemma_93356 (h1 : filter (with_one (has_norm to_additive.value_type))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_93357 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_93358 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_93359 (h0 : topological_space (has_bot (sub_neg_monoid (has_add real)))) : normal_space (has_bot (sub_neg_monoid (has_add real))) := sorry --non-trivial
lemma new_lemma_93360 (h0 : ring (non_unital_non_assoc_semiring (mul_one_class to_additive.value_type))) : rank_condition (non_unital_non_assoc_semiring (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_93361 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (mul_zero_class.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (mul_zero_class.{0} empty))  := sorry --non-trivial
lemma new_lemma_93362 (h0 : functor.add_const (ring (has_nndist Type)) environment.implicit_infer_kind) : @rank_condition.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_nndist.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_93363 (h0 : ring (boolean_algebra (ring Type))) : is_domain (boolean_algebra (ring Type)) := sorry --non-trivial
lemma new_lemma_93364 (h0 : topological_space (has_pos_part (has_to_string pos))) : preconnected_space (has_pos_part (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_93365 (h1 : filter (linear_ordered_add_comm_group (random_gen (random_gen char)))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_93366 (h0 : ring (has_norm (has_norm num))) : is_domain (has_norm (has_norm num)) := sorry --non-trivial
lemma new_lemma_93367 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_93368 (h0 : topological_space (cancel_monoid name)) : normal_space (cancel_monoid name) := sorry --non-trivial
lemma new_lemma_93369 (h0 : topological_space (ordered_comm_monoid (has_pos_part pos))) : discrete_topology (ordered_comm_monoid (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_93370 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_atomistic.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_93371 (h0 : group (measurable_space (random_gen congr_arg_kind))) : normalizer_condition (measurable_space (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_93372 (h0 : group (with_one (has_top fun_info))) : normalizer_condition (with_one (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_93373 (h0 : functor.add_const (semiring (has_nndist name)) name) : @is_noetherian_ring.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (has_nndist.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_93374 (h1 : reducibility_hints -> reducibility_hints -> Prop) (h2 h3 : reducibility_hints) : eqv_gen h1 h2 h3 := sorry --non-trivial
lemma new_lemma_93375 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_93376 (h0 : semiring (div_inv_monoid (semiring unsigned))) : is_noetherian_ring (div_inv_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_93377 (h0 : add_group (has_neg_part (option (option (option (option pos)))))) : is_add_cyclic (has_neg_part (option (option (option (option pos))))) := sorry --non-trivial
lemma new_lemma_93378 (h0 : uniform_space (ring unsigned)) : separated_space (ring unsigned) := sorry --non-trivial
lemma new_lemma_93379 (h0 : ring (measurable_space (has_norm congr_arg_kind))) : strong_rank_condition (measurable_space (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_93380 (h0 : functor.comp topological_space boolean_algebra.core Type) : @loc_path_connected_space.{1} (boolean_algebra.core.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} boolean_algebra.core.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_93381 (h0 : complete_lattice (measurable_space (random_gen string_imp))) : is_atomistic (measurable_space (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_93382 (h0 : topological_space (semilattice_inf (random_gen to_additive.value_type))) : locally_compact_space (semilattice_inf (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_93383 (h0 : uniform_space (has_dist (option unsigned))) : separated_space (has_dist (option unsigned)) := sorry --non-trivial
lemma new_lemma_93384 (h0 : functor.add_const (monoid (has_to_string name)) pos) : @monoid.fg.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (has_to_string.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_93385 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @normalizer_condition.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_93386 (h0 : ring (add_cancel_comm_monoid (random_gen real))) : is_domain (add_cancel_comm_monoid (random_gen real)) := sorry --non-trivial
lemma new_lemma_93387 (h0 : functor.add_const (topological_space (has_to_string name)) pos) : @path_connected_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_93388 (h0 : group (with_zero linarith.ineq)) : is_cyclic (with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_93389 (h0 : ring (linear_ordered_comm_ring num)) : rank_condition (linear_ordered_comm_ring num) := sorry --non-trivial
lemma new_lemma_93390 (h0 : functor.comp topological_space comm_group environment.implicit_infer_kind) : @normal_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_93391 (h0 : functor.add_const (complete_lattice (has_nndist ennreal)) (mul_zero_class (mul_zero_class Type))) : @is_atomistic.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_nndist.{0} ennreal)) (mul_zero_class.{1} (mul_zero_class.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_93392 (h1 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @t0_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h1 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_93393 (h0 : Prop) (h1 : list Prop) : list.ilast' h0 (id (id h1)) := sorry --non-trivial
lemma new_lemma_93394 (h0 : prod (has_inner unsigned unsigned) (has_inner unsigned unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_93395 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_93396 (h0 : topological_space (linear_ordered_semiring (has_top (has_norm congr_arg_kind)))) : totally_disconnected_space (linear_ordered_semiring (has_top (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_93397 (h0 : complete_lattice (linear_ordered_comm_ring (semiring (semiring (has_top (semiring empty)))))) : is_compactly_generated (linear_ordered_comm_ring (semiring (semiring (has_top (semiring empty))))) := sorry --non-trivial
lemma new_lemma_93398 (h0 : add_group (mul_zero_class (semiring (semiring (semiring num))))) : is_add_cyclic (mul_zero_class (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_93399 (h0 : group (denumerable (has_top (random_gen linarith.comp_source)))) : group.fg (denumerable (has_top (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_93400 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} pos (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) pos)  := sorry --non-trivial
lemma new_lemma_93401 (h0 : topological_space (has_neg_part (has_add pos))) : regular_space (has_neg_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_93402 (h0 : functor.add_const (functor.add_const (topological_space Type) (has_pos_part pos)) linarith.comp) : @locally_compact_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) (has_pos_part.{0} pos) (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (topological_space.{1} Type) (has_pos_part.{0} pos)) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_93403 (h0 : option (functor.add_const (topological_space (comm_group pos)) ennreal)) (h1 : functor.add_const (topological_space (comm_group pos)) ennreal) : @totally_separated_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) ennreal (@option.get_or_else.{0} (functor.add_const.{0 0} (topological_space.{0} (comm_group.{0} pos)) ennreal) h0 h1))  := sorry --non-trivial
lemma new_lemma_93404 (h0 : functor.add_const (ring (plift num)) congr_arg_kind) : @is_principal_ideal_ring.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (ring.{1} (plift.{1} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_93405 (h0 : function.extfun Type (functor.add_const (monoid (is_R_or_C empty)))) : @monoid.fg.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (is_R_or_C.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (monoid.{0} (is_R_or_C.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_93406 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_star.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_star.{0} num))  := sorry --non-trivial
lemma new_lemma_93407 (h0 : topological_space (add_left_cancel_monoid (has_nnnorm linarith.ineq))) : t0_space (add_left_cancel_monoid (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_93408 (h0 : add_group (mul_zero_class (has_nndist Type))) : is_add_cyclic (mul_zero_class (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_93409 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_93410 (h0 : complete_lattice (has_append (has_append (fintype (distrib char))))) : complete_lattice.is_Sup_finite_compact (has_append (has_append (fintype (distrib char)))) := sorry --non-trivial
lemma new_lemma_93411 (h0 : topological_space (add_comm_semigroup linarith.ineq)) (h2 : Prop) : is_path_connected (id (fun (h1 : add_comm_semigroup linarith.ineq), h2)) := sorry --non-trivial
lemma new_lemma_93412 (h0 : filter (comm_ring to_additive.value_type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_93413 (h0 : complete_lattice (has_union (linear_ordered_semiring (semiring empty)))) : complete_lattice.is_Sup_finite_compact (has_union (linear_ordered_semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_93414 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_93415 (h0 : topological_space (has_zero (finset (finset linarith.comp)))) : irreducible_space (has_zero (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_93416 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_93417 (h0 : cancel_comm_monoid_with_zero (has_pos_part (has_Inf Type))) : unique_factorization_monoid (has_pos_part (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_93418 (h0 : monoid (has_neg_part (comm_group linarith.comp))) : monoid.fg (has_neg_part (comm_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_93419 (h0 : functor.add_const (ring (has_edist unsigned)) empty) : @rank_condition.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_edist.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_93420 (h0 : not (complete_lattice (random_gen char) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_93421 (h0 : topological_space (linear_ordered_add_comm_group (has_inv linarith.comp_source))) : path_connected_space (linear_ordered_add_comm_group (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_93422 (h0 : prod (group_with_zero empty) (group_with_zero empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_93423 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_neg pos)) Type) : @unique_factorization_monoid.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (has_neg.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_93424 (h0 : complete_lattice (has_pos_part (has_neg (has_neg (has_pos_part Type))))) : complete_lattice.is_Sup_finite_compact (has_pos_part (has_neg (has_neg (has_pos_part Type)))) := sorry --non-trivial
lemma new_lemma_93425 (h2 : topological_space (linear_ordered_add_comm_group to_additive.value_type)) : t0_space (linear_ordered_add_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_93426 (h0 : functor.add_const (topological_space (semigroup unsigned)) name) : @topological_space.separable_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_93427 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type add_group.{0}) h0) (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_93428 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_nndist unsigned)) := sorry --non-trivial
lemma new_lemma_93429 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_93430 (h0 : topological_space (normed_group (has_norm empty))) : totally_disconnected_space (normed_group (has_norm empty)) := sorry --non-trivial
lemma new_lemma_93431 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_93432 (h0 : topological_space (add_cancel_monoid (option empty))) : irreducible_space (add_cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_93433 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preconnected_space.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_93434 (h0 : add_group (add_cancel_monoid (finset (finset (has_nndist ennreal))))) : is_add_cyclic (add_cancel_monoid (finset (finset (has_nndist ennreal)))) := sorry --non-trivial
lemma new_lemma_93435 (h0 : function.extfun Type ring) : @rank_condition.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_cancel_add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_93436 (h0 : ordered_add_comm_monoid (add_left_cancel_semigroup (option unsigned))) : archimedean (add_left_cancel_semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_93437 (h0 : topological_space (random_gen linarith.comp_source)) : t0_space (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_93438 (h0 : topological_space (complete_semilattice_Sup (has_ssubset linarith.comp_source))) : locally_compact_space (complete_semilattice_Sup (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_93439 (h0 : topological_space (has_bot unsigned)) : loc_path_connected_space (has_bot unsigned) := sorry --non-trivial
lemma new_lemma_93440 (h0 : multiset (has_lt string_imp)) (h1 : not (multiset (has_lt string_imp) -> false)) : multiset.disjoint h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_93441 (h0 : list (with_bot (has_inv to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_93442 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_93443 (h0 : list (complete_linear_order (option unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_93444 (h1 : group (comm_ring (comm_ring (comm_ring to_additive.value_type)))) : is_cyclic (comm_ring (comm_ring (comm_ring to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_93445 (h0 : has_mem.mem (random_gen empty) has_emptyc.emptyc) : filter.ne_bot (finset.pi.empty filter (random_gen empty) h0) := sorry --non-trivial
lemma new_lemma_93446 (h0 : functor.add_const (function.extfun Type topological_space) real) : @t1_space.{0} (comm_semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) real h0) (comm_semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_93447 (h0 : topological_space (ring (boolean_algebra.core environment.implicit_infer_kind))) : totally_separated_space (ring (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_93448 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (left_cancel_monoid.{0} (ordered_ring.{0} (option.{0} empty))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} (ordered_ring.{0} (option.{0} empty))))  := sorry --non-trivial
lemma new_lemma_93449 (h0 : ring (pseudo_metric_space congr_arg_kind)) : is_principal_ideal_ring (pseudo_metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_93450 (h3 : ring fun_info) : rank_condition fun_info := sorry --non-trivial
lemma new_lemma_93451 (h0 : topological_space (complete_linear_order empty)) : totally_separated_space (complete_linear_order empty) := sorry --non-trivial
lemma new_lemma_93452 (h0 : list (linear_ordered_field (option empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_93453 (h0 : topological_space (free_add_monoid unsigned)) : totally_separated_space (free_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_93454 (h0 : functor.add_const (monoid (add_comm_monoid linarith.comp)) environment.implicit_infer_kind) : @monoid.fg.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (add_comm_monoid.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_93455 (h0 : topological_space (linear_ordered_semiring (random_gen (semiring congr_arg_kind)))) : irreducible_space (linear_ordered_semiring (random_gen (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_93456 (h0 : group (generalized_boolean_algebra (has_neg Type))) : is_cyclic (generalized_boolean_algebra (has_neg Type)) := sorry --non-trivial
lemma new_lemma_93457 (h0 : functor.add_const (uniform_space (has_zero linarith.comp)) (finset linarith.comp)) : @separated_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_zero.{0} linarith.comp)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_93458 (h0 : group (complete_distrib_lattice (has_add (has_add (has_add name))))) : is_simple_group (complete_distrib_lattice (has_add (has_add (has_add name)))) := sorry --non-trivial
lemma new_lemma_93459 (h0 : ring (preorder char)) : is_domain (preorder char) := sorry --non-trivial
lemma new_lemma_93460 (h0 : random_gen (has_nnnorm to_additive.value_type) -> random_gen (has_nnnorm to_additive.value_type) -> bool) : is_dec_refl h0 := sorry --non-trivial
lemma new_lemma_93461 (h0 : functor.add_const (finset (finset pos)) (has_neg (has_neg (has_neg Type)))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_93462 (h0 : functor.add_const (function.extfun Type group) Type) : @group.fg.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_93463 (h1 : ring congr_arg_kind) : is_domain congr_arg_kind := sorry --non-trivial
lemma new_lemma_93464 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @t1_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_93465 (h0 : topological_space (normed_field char)) : totally_disconnected_space (normed_field char) := sorry --non-trivial
lemma new_lemma_93466 (h0 : topological_space (linear_ordered_add_comm_group (has_top fun_info))) : totally_disconnected_space (linear_ordered_add_comm_group (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_93467 (h0 : topological_space (has_bot num)) : totally_separated_space (has_bot num) := sorry --non-trivial
lemma new_lemma_93468 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_93469 (h0 : functor.add_const (group (finset pos)) ennreal) : @is_cyclic.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_93470 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_93471 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} h0 (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_93472 (h0 : topological_space (complete_semilattice_Sup (has_norm congr_arg_kind))) : t0_space (complete_semilattice_Sup (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_93473 (h1 : topological_space (normed_field string_imp)) : t0_space (normed_field string_imp) := sorry --non-trivial
lemma new_lemma_93474 (h0 : functor.comp add_group add_cancel_monoid name) : @is_add_cyclic.{0} (add_cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} add_group.{0} add_cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_93475 (h0 : add_monoid (has_Inf (has_Inf Type))) : add_monoid.fg (has_Inf (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_93476 (h0 : topological_space (normed_comm_ring (has_to_string Type))) : topological_space.separable_space (normed_comm_ring (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_93477 (h0 : empty) : @complete_space.{0} string_imp (@empty.elim.{1} (uniform_space.{0} string_imp) h0)  := sorry --non-trivial
lemma new_lemma_93478 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_93479 (h0 : monoid (finset unsigned)) : monoid.fg (finset unsigned) := sorry --non-trivial
lemma new_lemma_93480 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_93481 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_93482 (h0 : finset (boolean_algebra.core Type)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_93483 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) linarith.comp) : @t0_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_93484 (h0 : ring (with_bot (semiring (semiring (semiring empty))))) : is_domain (with_bot (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_93485 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) name) : @preconnected_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_93486 (h0 : topological_space (has_pos_part (has_Inf (has_Inf Type)))) : preirreducible_space (has_pos_part (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_93487 (h2 : group (denumerable (add_cancel_comm_monoid to_additive.value_type))) : is_cyclic (denumerable (add_cancel_comm_monoid to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_93488 (h0 : topological_space (comm_ring (has_nnnorm (has_nnnorm linarith.ineq)))) : totally_disconnected_space (comm_ring (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_93489 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @path_connected_space.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_93490 (h0 : topological_space (comm_monoid (has_neg_part (has_neg_part unsigned)))) : discrete_topology (comm_monoid (has_neg_part (has_neg_part unsigned))) := sorry --non-trivial
lemma new_lemma_93491 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_93492 (h0 : topological_space (has_dist (comm_monoid (option unsigned)))) : t0_space (has_dist (comm_monoid (option unsigned))) := sorry --non-trivial
lemma new_lemma_93493 (h0 : topological_space (encodable (random_gen string_imp))) (h1 : set (encodable (random_gen string_imp))) : is_open h1 := sorry --non-trivial
lemma new_lemma_93494 (h0 : semiring (has_add (has_Inf pos))) : is_noetherian_ring (has_add (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_93495 (h0 : topological_space (has_zero (finset pos))) : t1_space (has_zero (finset pos)) := sorry --non-trivial
lemma new_lemma_93496 (h0 : functor.comp topological_space has_neg_part name) : @locally_compact_space.{0} (has_neg_part.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} name h0)  := sorry --non-trivial
lemma new_lemma_93497 (h0 : function.extfun Type topological_space) : @t0_space.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_93498 (h0 : topological_space (add_comm_monoid (finset (ring environment.implicit_infer_kind)))) : irreducible_space (add_comm_monoid (finset (ring environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_93499 (h0 : function.extfun (finset ((Type -> Type) -> Type 1)) (has_mem.mem (function.extfun Type))) : @rank_condition.{0} num (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@function.extfun_app.{3 0} (finset.{2} ((Type → Type) → Type 1)) (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (finset.{2} ((Type → Type) → Type 1)) (@finset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type)) h0 (@has_emptyc.emptyc.{2} (finset.{2} ((Type → Type) → Type 1)) (@finset.has_emptyc.{2} ((Type → Type) → Type 1))))) ring.{0}) num)  := sorry --non-trivial
lemma new_lemma_93500 (h0 : function.extfun Type ring) : @rank_condition.{0} (encodable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (encodable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_93501 (h0 : topological_space (canonically_ordered_comm_semiring (boolean_algebra.core name))) : preconnected_space (canonically_ordered_comm_semiring (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_93502 (h2 : group (distrib to_additive.value_type)) : is_cyclic (distrib to_additive.value_type) := sorry --non-trivial
lemma new_lemma_93503 (h0 h1 : multiset (normed_field ereal)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_93504 (h0 : not (uniform_space (semi_normed_comm_ring to_additive.value_type) -> false)) : @complete_space.{0} (semi_normed_comm_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (uniform_space.{0} (semi_normed_comm_ring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_93505 (h0 : topological_space (boolean_algebra (semigroup name))) : sequential_space (boolean_algebra (semigroup name)) := sorry --non-trivial
lemma new_lemma_93506 (h0 : function.extfun Type group) : @group.fg.{0} (div_inv_monoid.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (div_inv_monoid.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_93507 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (comm_ring.{0} string_imp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (comm_ring.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_93508 (h0 : monoid (complete_semilattice_Sup (random_gen linarith.comp_source))) : monoid.fg (complete_semilattice_Sup (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_93509 (h0 : filter (distrib_lattice (distrib (has_div (linear_ordered_add_comm_group char))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_93510 (h0 : functor.add_const (topological_space (finset name)) pos) : @locally_compact_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_93511 (h0 : function.extfun Type ring) : @rank_condition.{0} (complete_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_93512 (h0 : not (ring (complete_linear_order congr_arg_kind) -> false)) : @is_domain.{0} (complete_linear_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (complete_linear_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_93513 (h0 : complete_lattice (complete_distrib_lattice (ring unsigned))) : is_atomistic (complete_distrib_lattice (ring unsigned)) := sorry --non-trivial
lemma new_lemma_93514 (h0 : ring (has_to_string (has_neg (has_to_string (has_to_string linarith.comp))))) : is_principal_ideal_ring (has_to_string (has_neg (has_to_string (has_to_string linarith.comp)))) := sorry --non-trivial
lemma new_lemma_93515 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_93516 (h0 : function.extfun Type group) : @normalizer_condition.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_93517 (h0 : topological_space (dlist (has_nnnorm to_additive.value_type))) : t0_space (dlist (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_93518 (h0 : ring (add_right_cancel_monoid (semiring num))) : is_domain (add_right_cancel_monoid (semiring num)) := sorry --non-trivial
lemma new_lemma_93519 (h0 : ring (complete_distrib_lattice ennreal)) : is_principal_ideal_ring (complete_distrib_lattice ennreal) := sorry --non-trivial
lemma new_lemma_93520 (h0 : topological_space (comm_semigroup (has_Inf Type))) : totally_disconnected_space (comm_semigroup (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_93521 (h0 : functor.add_const (ordered_comm_monoid (add_cancel_monoid Type)) (comm_group (has_neg_part name))) : @has_exists_mul_of_le.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (add_cancel_monoid.{1} Type)) (comm_group.{0} (has_neg_part.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_93522 (h0 : functor.add_const (topological_space ennreal) (option empty)) : preconnected_space ennreal := sorry --non-trivial
lemma new_lemma_93523 (h0 : ordered_comm_monoid (normed_comm_ring (boolean_algebra (has_add pos)))) : has_exists_mul_of_le (normed_comm_ring (boolean_algebra (has_add pos))) := sorry --non-trivial
lemma new_lemma_93524 (h0 : functor.add_const (group (normed_linear_ordered_group empty)) empty) : @normalizer_condition.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (normed_linear_ordered_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_93525 (h0 : topological_space (has_pos_part (ring linarith.comp))) : preconnected_space (has_pos_part (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_93526 (h0 : functor.comp ring has_to_string environment.implicit_infer_kind) : @rank_condition.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} ring.{0} has_to_string.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_93527 (h0 : ordered_add_comm_monoid (simple_graph (has_add (has_Inf linarith.comp)))) : archimedean (simple_graph (has_add (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_93528 (h0 : topological_space (complete_linear_order (semiring congr_arg_kind))) : locally_compact_space (complete_linear_order (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_93529 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (non_assoc_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_93530 (h0 : monoid (add_group (semiring congr_arg_kind))) : monoid.fg (add_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_93531 (h0 : topological_space (linear_ordered_comm_monoid_with_zero unsigned)) : loc_path_connected_space (linear_ordered_comm_monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_93532 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_93533 (h0 : topological_space (partial_order (semiring empty))) : irreducible_space (partial_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_93534 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (has_add.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_93535 (h0 : finset (has_bot name)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_93536 (h0 : function.extfun (finset Type) (has_mem.mem (has_one empty))) : @rank_condition.{0} (has_one.{0} empty) (@finset.pi.empty.{1 0} Type ring.{0} (has_one.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_one.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_93537 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_inter ennreal)) := sorry --non-trivial
lemma new_lemma_93538 (h0 : function.extfun Type group) : @normalizer_condition.{0} congr_arg_kind (@function.extfun_app.{2 1} Type group.{0} h0 congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_93539 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_93540 (h0 : topological_space (has_nndist (has_nndist (has_nndist (has_nndist name))))) : t0_space (has_nndist (has_nndist (has_nndist (has_nndist name)))) := sorry --non-trivial
lemma new_lemma_93541 (h0 : filter (has_one (semiring (semiring (semiring empty))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_93542 (h2 : has_lt environment.projection_info) : no_max_order environment.projection_info := sorry --non-trivial
lemma new_lemma_93543 (h0 : finset (ordered_comm_ring (boolean_algebra.core (has_add (ring Type))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_93544 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_93545 (h0 : topological_space (semigroup congr_arg_kind)) : t0_space (semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_93546 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (is_R_or_C empty)) := sorry --non-trivial
lemma new_lemma_93547 (h0 : congr_arg_kind -> congr_arg_kind -> Prop) : is_antisymm congr_arg_kind h0 := sorry --non-trivial
lemma new_lemma_93548 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @locally_compact_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_93549 (h0 : ordered_comm_monoid (comm_group (ring (has_add Type)))) : has_exists_mul_of_le (comm_group (ring (has_add Type))) := sorry --non-trivial
lemma new_lemma_93550 (h0 : ring (measure_theory.measure_space unsigned)) : rank_condition (measure_theory.measure_space unsigned) := sorry --non-trivial
lemma new_lemma_93551 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_93552 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_93553 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (complete_distrib_lattice (option pos))) := sorry --non-trivial
lemma new_lemma_93554 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_93555 (h0 : is_R_or_C (linear_order unsigned) -> is_R_or_C (linear_order unsigned) -> Prop) : is_refl (is_R_or_C (linear_order unsigned)) h0 := sorry --non-trivial
lemma new_lemma_93556 (h0 : complete_lattice (semiring (random_gen (random_gen fun_info)))) : is_atomistic (semiring (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_93557 (h0 : group (complete_semilattice_Sup (has_top linarith.comp_source))) : is_cyclic (complete_semilattice_Sup (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_93558 (h0 : uniform_space (div_inv_monoid string_imp)) : complete_space (div_inv_monoid string_imp) := sorry --non-trivial
lemma new_lemma_93559 (h0 : function.extfun Type topological_space) : @t1_space.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_93560 (h0 : functor.add_const (group (normed_comm_ring pos)) (normed_comm_ring (has_Inf (mul_one_class linarith.comp)))) : @normalizer_condition.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} pos)) (normed_comm_ring.{0} (has_Inf.{0} (mul_one_class.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_93561 (h0 : semiring (boolean_algebra.core (boolean_algebra (add_cancel_monoid Type)))) : is_noetherian_ring (boolean_algebra.core (boolean_algebra (add_cancel_monoid Type))) := sorry --non-trivial
lemma new_lemma_93562 (h0 : fin has_zero.zero) : @regular_space.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_93563 (h2 : semiring fun_info) (h3 : ideal fun_info) : ideal.is_prime h3 := sorry --non-trivial
lemma new_lemma_93564 (h0 : topological_space (mul_zero_class unsigned)) : irreducible_space (mul_zero_class unsigned) := sorry --non-trivial
lemma new_lemma_93565 (h0 : has_mem.mem (semiring linarith.comp) has_emptyc.emptyc) : @is_add_cyclic.{0} (semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type add_group.{0} (semiring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_93566 (h0 : cancel_comm_monoid_with_zero (order_dual congr_arg_kind)) : unique_factorization_monoid (order_dual congr_arg_kind) := sorry --non-trivial
lemma new_lemma_93567 (h0 : semiring (simple_graph (has_Inf (finset pos)))) : is_noetherian_ring (simple_graph (has_Inf (finset pos))) := sorry --non-trivial
lemma new_lemma_93568 (h0 : normed_linear_ordered_group (has_edist empty) -> normed_linear_ordered_group (has_edist empty) -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_93569 (h0 : normed_comm_ring (semigroup name) -> normed_comm_ring (semigroup name) -> Prop) : is_antisymm (normed_comm_ring (semigroup name)) h0 := sorry --non-trivial
lemma new_lemma_93570 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @regular_space.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_93571 (h0 : topological_space (semiring unsigned)) : totally_disconnected_space (semiring unsigned) := sorry --non-trivial
lemma new_lemma_93572 (h0 : functor.add_const (topological_space (comm_group name)) name) : @irreducible_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_93573 (h0 : function.extfun (Type -> Type 1) (function.extfun Type)) : @normalizer_condition.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (group.{1} (plift.{1} empty)) empty (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (group.{1} (plift.{1} empty))) (@function.extfun_app.{3 2} (Type → Type 1) (function.extfun.{2 2} Type) h0 (functor.add_const.{1 0} (group.{1} (plift.{1} empty)))) empty))  := sorry --non-trivial
lemma new_lemma_93574 (h0 : semiring (ring (option empty))) : is_noetherian_ring (ring (option empty)) := sorry --non-trivial
lemma new_lemma_93575 (h0 : functor.add_const (topological_space (normed_linear_ordered_group empty)) num) : @irreducible_space.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_93576 (h0 : add_group (normed_group num)) : is_add_cyclic (normed_group num) := sorry --non-trivial
lemma new_lemma_93577 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_93578 (h0 : monoid (has_nndist ennreal)) : monoid.fg (has_nndist ennreal) := sorry --non-trivial
lemma new_lemma_93579 (h0 : function.extfun Type topological_space) : @t0_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_93580 (h0 : ring (measurable_space (semiring (has_norm num)))) : strong_rank_condition (measurable_space (semiring (has_norm num))) := sorry --non-trivial
lemma new_lemma_93581 (h0 : ring Type) : is_domain Type := sorry --non-trivial
lemma new_lemma_93582 (h0 : topological_space (has_neg_part (has_add (option pos)))) : t1_space (has_neg_part (has_add (option pos))) := sorry --non-trivial
lemma new_lemma_93583 (h0 : ring (has_to_string (normed_comm_ring Type))) : rank_condition (has_to_string (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_93584 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_93585 (h0 : group (has_nndist (has_add linarith.comp))) : group.fg (has_nndist (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_93586 (h0 : topological_space (ring (has_neg linarith.comp))) : discrete_topology (ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_93587 (h0 : function.extfun (finset nat) (has_mem.mem has_zero.zero)) : @is_atomistic.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} fun_info)))))) (@matrix.vec_empty.{0} (complete_lattice.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} fun_info))))))) (@finset.pi.empty.{0 0} nat fin (@has_zero.zero.{0} nat nat.has_zero) (@function.extfun_app.{1 0} (finset.{0} nat) (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) (@has_zero.zero.{0} nat nat.has_zero)) h0 (@has_emptyc.emptyc.{0} (finset.{0} nat) (@finset.has_emptyc.{0} nat)))))  := sorry --non-trivial
lemma new_lemma_93588 (h0 : functor.add_const (add_monoid (boolean_algebra environment.implicit_infer_kind)) name) : @add_monoid.fg.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_93589 (h0 : add_monoid (option (semiring (semiring empty)))) : add_monoid.fg (option (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_93590 (h0 : function.extfun Type group) : @is_simple_group.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_93591 (h3 : ring linarith.comp_source) : is_domain linarith.comp_source := sorry --non-trivial
lemma new_lemma_93592 (h0 : functor.add_const (function.extfun Type group) Type) : @is_cyclic.{0} linarith.comp (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_93593 (h0 : functor.add_const (function.extfun Type uniform_space) (ring (has_neg (finset (ring pos))))) : @separated_space.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) (ring.{0} (has_neg.{0} (finset.{0} (ring.{0} pos)))) h0) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_93594 (h0 : monoid (has_zero (has_Inf pos))) : monoid.fg (has_zero (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_93595 (h0 : functor.add_const (topological_space (cancel_monoid linarith.comp)) name) : @topological_space.separable_space.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_93596 (h0 : functor.comp filter has_neg Type) : filter.ne_bot (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_93597 (h0 : group (simple_graph (option empty))) : is_cyclic (simple_graph (option empty)) := sorry --non-trivial
lemma new_lemma_93598 (h0 : topological_space (has_nndist Type)) : t1_space (has_nndist Type) := sorry --non-trivial
lemma new_lemma_93599 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (denumerable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (denumerable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_93600 (h0 : functor.add_const (uniform_space (left_cancel_monoid empty)) num) : @complete_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (left_cancel_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_93601 (h0 : topological_space (has_nndist unsigned)) : t1_space (has_nndist unsigned) := sorry --non-trivial
lemma new_lemma_93602 (h0 : group (comm_group (finset Type))) : normalizer_condition (comm_group (finset Type)) := sorry --non-trivial
lemma new_lemma_93603 (h0 : topological_space (normed_comm_ring (comm_group name))) : sequential_space (normed_comm_ring (comm_group name)) := sorry --non-trivial
lemma new_lemma_93604 (h0 : topological_space (ordered_comm_ring (has_add Type))) : sequential_space (ordered_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_93605 (h0 : has_lt (has_nnnorm environment.projection_info)) : no_max_order (has_nnnorm environment.projection_info) := sorry --non-trivial
lemma new_lemma_93606 (h1 : function.extfun Type group) : @is_cyclic.{0} (with_one.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h1 (with_one.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_93607 (h0 : monoid (boolean_algebra (has_Inf real))) : monoid.fg (boolean_algebra (has_Inf real)) := sorry --non-trivial
lemma new_lemma_93608 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_93609 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_93610 (h0 : functor.add_const (topological_space (left_cancel_monoid unsigned)) congr_arg_kind) : @path_connected_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_93611 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 ring.{0}) (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_93612 (h0 : semiring znum) : is_noetherian_ring znum := sorry --non-trivial
lemma new_lemma_93613 (h0 : functor.add_const (ordered_comm_monoid (has_neg unsigned)) unsigned) : @has_exists_mul_of_le.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_neg.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_93614 (h0 : functor.add_const (topological_space name) num) : @totally_disconnected_space.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) num h0)  := sorry --non-trivial
lemma new_lemma_93615 (h0 : topological_space (has_nndist ennreal)) : normal_space (has_nndist ennreal) := sorry --non-trivial
lemma new_lemma_93616 (h0 : topological_space (has_union (semiring (semiring (semiring (semiring congr_arg_kind)))))) : normal_space (has_union (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_93617 (h0 : monoid (metric_space (semiring empty))) : monoid.fg (metric_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_93618 (h1 : has_lt (simple_graph (mul_one_class reducibility_hints))) : no_max_order (simple_graph (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_93619 (h0 : not (has_mem.mem ring has_emptyc.emptyc -> false)) : @rank_condition.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_93620 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} unsigned (@function.extfun_app.{2 1} Type topological_space.{0} h0 unsigned)  := sorry --non-trivial
lemma new_lemma_93621 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_93622 (h0 : prod (metric_space congr_arg_kind) (metric_space congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_93623 (h0 : topological_space (has_nndist (option ennreal))) : t0_space (has_nndist (option ennreal)) := sorry --non-trivial
lemma new_lemma_93624 (h0 : group (has_top (random_gen (with_bot string_imp)))) : group.fg (has_top (random_gen (with_bot string_imp))) := sorry --non-trivial
lemma new_lemma_93625 (h0 : filter (semigroup (finset (has_pos_part environment.implicit_infer_kind)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_93626 (h0 : topological_space (ring (option unsigned))) : regular_space (ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_93627 (h0 : functor.add_const (group (normed_comm_ring linarith.comp)) (ring Type)) : @group.fg.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (normed_comm_ring.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_93628 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_93629 (h0 : ordered_add_comm_monoid (ring (ring Type))) : archimedean (ring (ring Type)) := sorry --non-trivial
lemma new_lemma_93630 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_distrib_lattice.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_93631 (h0 : functor.add_const (ring (has_neg name)) Type) : @is_principal_ideal_ring.{0} (has_neg.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (has_neg.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_93632 (h0 : topological_space (has_inner unsigned empty)) : t0_space (has_inner unsigned empty) := sorry --non-trivial
lemma new_lemma_93633 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (mul_zero_class ennreal)) := sorry --non-trivial
lemma new_lemma_93634 (h0 : functor.add_const Prop (has_neg (has_neg (has_neg linarith.comp)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_93635 (h0 : functor.add_const (group (ordered_ring empty)) num) : @group.fg.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (ordered_ring.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_93636 (h0 : functor.add_const (uniform_space (left_cancel_monoid empty)) (semiring (semiring (semiring empty)))) : @complete_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (left_cancel_monoid.{0} empty)) (semiring.{0} (semiring.{0} (semiring.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_93637 (h0 : monoid (has_top (has_norm linarith.comp))) : monoid.fg (has_top (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_93638 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (add_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (add_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_93639 (h0 : cancel_comm_monoid_with_zero (finset (option empty))) : unique_factorization_monoid (finset (option empty)) := sorry --non-trivial
lemma new_lemma_93640 (h1 : topological_space (has_nnnorm fun_info)) : locally_compact_space (has_nnnorm fun_info) := sorry --non-trivial
lemma new_lemma_93641 (h0 : functor.add_const (function.extfun Type add_monoid) (semiring congr_arg_kind)) : @add_monoid.fg.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) (semiring.{0} congr_arg_kind) h0) (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_93642 (h2 : complete_lattice (has_nnnorm (random_gen string_imp))) : is_compactly_generated (has_nnnorm (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_93643 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_93644 (h1 : uniform_space (distrib (random_gen to_additive.value_type))) : complete_space (distrib (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_93645 (h0 : ordered_add_comm_monoid (ring (has_neg environment.implicit_infer_kind))) : archimedean (ring (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_93646 (h0 : topological_space (has_zero (comm_group Type))) : loc_path_connected_space (has_zero (comm_group Type)) := sorry --non-trivial
lemma new_lemma_93647 (h0 : complete_lattice (non_unital_non_assoc_semiring (has_nnnorm linarith.ineq))) : is_compactly_generated (non_unital_non_assoc_semiring (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_93648 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (add_comm_monoid.{0} complex) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} complex))  := sorry --non-trivial
lemma new_lemma_93649 (h0 : prod (plift num) (plift num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_93650 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_93651 (h0 : fin has_zero.zero) : @normalizer_condition.{1} (ring.{1} Type) (@matrix.vec_empty.{1} (group.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_93652 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_93653 (h2 : complete_lattice (has_ssubset fun_info)) : is_compactly_generated (has_ssubset fun_info) := sorry --non-trivial
lemma new_lemma_93654 (h1 : preorder (mul_one_class (add_comm_semigroup std_gen))) (h2 : set (mul_one_class (add_comm_semigroup std_gen))) : set.is_pwo h2 := sorry --non-trivial
lemma new_lemma_93655 (h0 : filter (complete_distrib_lattice (has_pos_part Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_93656 (h0 : topological_space (has_lt (add_cancel_comm_monoid (has_lt char)))) : totally_disconnected_space (has_lt (add_cancel_comm_monoid (has_lt char))) := sorry --non-trivial
lemma new_lemma_93657 (h0 : list (ring (has_neg (ring name)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_93658 (h0 : topological_space (comm_group ennreal)) : t1_space (comm_group ennreal) := sorry --non-trivial
lemma new_lemma_93659 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (linear_ordered_comm_ring.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (linear_ordered_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_93660 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_93661 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_93662 (h0 : filter (has_Inf (has_pos_part (generalized_boolean_algebra linarith.comp)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_93663 (h0 : functor.add_const (topological_space (has_neg_part name)) unsigned) : @totally_disconnected_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_93664 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (generalized_boolean_algebra.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (generalized_boolean_algebra.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_93665 (h0 : functor.add_const (uniform_space (ring Type)) pos) : @separated_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_93666 (h0 : functor.add_const (list (linear_ordered_field unsigned)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_93667 (h0 : complete_lattice (has_norm (with_bot linarith.comp_source))) : is_atomistic (has_norm (with_bot linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_93668 (h0 : ring (has_bot (has_add (has_add linarith.comp)))) : strong_rank_condition (has_bot (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_93669 (h0 : topological_space (topological_space (has_nnnorm (has_inv fun_info)))) : totally_disconnected_space (topological_space (has_nnnorm (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_93670 (h0 : topological_space (topological_space (has_nnnorm (has_nnnorm (topological_space linarith.comp_source))))) : t0_space (topological_space (has_nnnorm (has_nnnorm (topological_space linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_93671 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (add_comm_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_93672 (h0 : functor.add_const (ring (boolean_algebra Type)) linarith.comp) : @is_principal_ideal_ring.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_93673 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_93674 (h0 : topological_space environment.projection_info) : path_connected_space environment.projection_info := sorry --non-trivial
lemma new_lemma_93675 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) pos) : @normal_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_93676 (h4 : topological_space (has_norm linarith.ineq)) : t0_space (has_norm linarith.ineq) := sorry --non-trivial
lemma new_lemma_93677 (h1 : is_empty (nondiscrete_normed_field char)) (h2 : nondiscrete_normed_field char) : @complete_space.{0} (mul_one_class.{0} char) (@is_empty.elim'.{1 1} (nondiscrete_normed_field.{0} char) (uniform_space.{0} (mul_one_class.{0} char)) h1 h2)  := sorry --non-trivial
lemma new_lemma_93678 (h0 : functor.add_const (ring (has_Inf linarith.comp)) Type) : @rank_condition.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (has_Inf.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_93679 (h0 : has_coe (nondiscrete_normed_field (add_comm_semigroup fun_info)) Prop) (h1 : nondiscrete_normed_field (add_comm_semigroup fun_info)) : @coe_b.{1 1} (nondiscrete_normed_field.{0} (add_comm_semigroup.{0} fun_info)) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_93680 (h0 : functor.add_const (monoid (has_nndist linarith.comp)) Type) : @monoid.fg.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 1} (monoid.{0} (has_nndist.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_93681 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_93682 (h0 : add_group (simple_graph (boolean_algebra.core Type))) : is_add_cyclic (simple_graph (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_93683 (h0 : topological_space (boolean_algebra pos)) : preirreducible_space (boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_93684 (h0 : complete_lattice (add_cancel_monoid (has_add ennreal))) : complete_lattice.is_Sup_finite_compact (add_cancel_monoid (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_93685 (h0 : topological_space (topological_space char)) : totally_disconnected_space (topological_space char) := sorry --non-trivial
lemma new_lemma_93686 (h0 : has_lt (monoid std_gen)) : no_max_order (monoid std_gen) := sorry --non-trivial
lemma new_lemma_93687 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (finset (finset Type))) : @path_connected_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} pos)) (finset.{1} (finset.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_93688 (h0 : functor.add_const (function.extfun Type uniform_space) (has_neg (has_nndist (has_nndist pos)))) : @separated_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) (has_neg.{0} (has_nndist.{0} (has_nndist.{0} pos))) h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_93689 (h0 : function.extfun Type topological_space) : @t0_space.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_93690 (h0 : ring (semigroup (has_pos_part (has_neg (has_Inf (has_Inf (has_Inf pos))))))) : strong_rank_condition (semigroup (has_pos_part (has_neg (has_Inf (has_Inf (has_Inf pos)))))) := sorry --non-trivial
lemma new_lemma_93691 (h0 : function.extfun Type topological_space) : @t1_space.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_93692 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preconnected_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_93693 (h0 : measurable_space (add_comm_semigroup enat)) (h1 : has_sup (add_comm_semigroup enat)) : has_measurable_sup₂ (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_93694 (h0 : group (measure_theory.measure_space (semiring empty))) : group.fg (measure_theory.measure_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_93695 (h0 : semiring (omega_complete_partial_order congr_arg_kind)) : is_noetherian_ring (omega_complete_partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_93696 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_norm.{0} (random_gen.{0} (has_top.{0} (has_top.{0} (random_gen.{0} (random_gen.{0} linarith.comp)))))) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_norm.{0} (random_gen.{0} (has_top.{0} (has_top.{0} (random_gen.{0} (random_gen.{0} linarith.comp)))))))  := sorry --non-trivial
lemma new_lemma_93697 (h0 : topological_space (has_Inf (has_Inf (ordered_ring Type)))) : irreducible_space (has_Inf (has_Inf (ordered_ring Type))) := sorry --non-trivial
lemma new_lemma_93698 (h0 : topological_space (distrib_lattice (random_gen (random_gen (random_gen linarith.ineq))))) : irreducible_space (distrib_lattice (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_93699 (h0 : finset (finset (has_neg (has_neg linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_93700 (h0 : complete_lattice (has_top (random_gen fun_info))) : is_atomistic (has_top (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_93701 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_93702 (h0 : function.extfun Type has_le) (h1 : bounded_order (measurable_space string_imp)) : is_simple_order (measurable_space string_imp) := sorry --non-trivial
lemma new_lemma_93703 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (linear_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_93704 (h0 : topological_space (boolean_algebra.core (generalized_boolean_algebra Type))) : preirreducible_space (boolean_algebra.core (generalized_boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_93705 (h0 : functor.add_const (add_group (complete_distrib_lattice pos)) (has_add linarith.comp)) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (complete_distrib_lattice.{0} pos)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_93706 (h0 : topological_space (has_nndist (finset Type))) : discrete_topology (has_nndist (finset Type)) := sorry --non-trivial
lemma new_lemma_93707 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_93708 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_93709 (h0 : add_group (ring (option ennreal))) : is_add_cyclic (ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_93710 (h0 : add_group (semiring (measurable_space (has_norm empty)))) : is_add_cyclic (semiring (measurable_space (has_norm empty))) := sorry --non-trivial
lemma new_lemma_93711 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (complete_linear_order.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_linear_order.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))))  := sorry --non-trivial
lemma new_lemma_93712 (h0 : functor.add_const (complete_lattice (finset linarith.comp)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_93713 (h0 : ring (semi_normed_comm_ring (mul_one_class linarith.comp_source))) : strong_rank_condition (semi_normed_comm_ring (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_93714 (h0 : functor.comp topological_space finset name) : @locally_compact_space.{0} (finset.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} name h0)  := sorry --non-trivial
lemma new_lemma_93715 (h0 : group (has_norm (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source))))) : group.fg (has_norm (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_93716 (h0 : complete_lattice (add_group (semiring (has_top linarith.comp)))) : complete_lattice.is_Sup_finite_compact (add_group (semiring (has_top linarith.comp))) := sorry --non-trivial
lemma new_lemma_93717 (h0 : not (monoid (add_group unsigned) -> false)) : @monoid.fg.{0} (add_group.{0} unsigned) (@classical.by_contradiction'.{1} (monoid.{0} (add_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_93718 (h0 : set (simple_graph (has_compl fun_info))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_93719 (h0 : prod (ring congr_arg_kind) (ring congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_93720 (h1 : uniform_space (complete_semilattice_Sup (has_nnnorm char))) : complete_space (complete_semilattice_Sup (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_93721 (h0 : complete_lattice (with_bot (semiring (semiring unsigned)))) : complete_lattice.is_Sup_finite_compact (with_bot (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_93722 (h0 : add_group (comm_semigroup (has_bot real))) : is_add_cyclic (comm_semigroup (has_bot real)) := sorry --non-trivial
lemma new_lemma_93723 (h0 : group (complete_semilattice_Sup (random_gen string_imp))) : normalizer_condition (complete_semilattice_Sup (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_93724 (h0 : topological_space (semiring (random_gen to_additive.value_type))) : t0_space (semiring (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_93725 (h0 : ordered_comm_monoid (has_add (mul_one_class (has_to_string linarith.comp)))) : has_exists_mul_of_le (has_add (mul_one_class (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_93726 (h0 : ring (has_neg_part (comm_group (has_add Type)))) : strong_rank_condition (has_neg_part (comm_group (has_add Type))) := sorry --non-trivial
lemma new_lemma_93727 (h0 : ring (has_compl linarith.ineq)) : rank_condition (has_compl linarith.ineq) := sorry --non-trivial
lemma new_lemma_93728 (h0 : list (pseudo_metric_space (cancel_monoid (option pos)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_93729 (h0 : monoid (add_cancel_monoid (cancel_monoid pos))) : monoid.fg (add_cancel_monoid (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_93730 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_93731 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) linarith.comp) : @archimedean.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) linarith.comp h0) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_93732 (h0 : topological_space (has_neg_part unsigned)) : topological_space.separable_space (has_neg_part unsigned) := sorry --non-trivial
lemma new_lemma_93733 (h0 : topological_space (has_Inf (ring (has_neg linarith.comp)))) : loc_path_connected_space (has_Inf (ring (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_93734 (h0 : monoid (boolean_algebra (finset (has_Inf linarith.comp)))) : monoid.fg (boolean_algebra (finset (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_93735 (h3 : topological_space (dlist to_additive.value_type)) : t0_space (dlist to_additive.value_type) := sorry --non-trivial
lemma new_lemma_93736 (h0 : topological_space (semiring (random_gen (random_gen (random_gen num))))) : discrete_topology (semiring (random_gen (random_gen (random_gen num)))) := sorry --non-trivial
lemma new_lemma_93737 (h0 : complete_lattice (semi_normed_ring (has_ssubset linarith.ineq))) : complete_lattice.is_Sup_finite_compact (semi_normed_ring (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_93738 (h0 : function.extfun (Type 1) filter) : countable_Inter_filter (function.extfun_app h0 (generalized_boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_93739 (h0 : topological_space (boolean_algebra (sub_neg_monoid pos))) : t0_space (boolean_algebra (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_93740 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) pos) : @topological_space.separable_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_93741 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_93742 (h0 : functor.add_const (list (ring linarith.comp)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_93743 (h0 : function.extfun Type topological_space) (h1 : preorder (mul_one_class std_gen)) : @order_closed_topology.{0} (mul_one_class.{0} std_gen) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_one_class.{0} std_gen)) h1  := sorry --non-trivial
lemma new_lemma_93744 (h0 : functor.add_const (monoid (boolean_algebra.core unsigned)) empty) : @monoid.fg.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (boolean_algebra.core.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_93745 (h0 : group (has_neg (finset pos))) : normalizer_condition (has_neg (finset pos)) := sorry --non-trivial
lemma new_lemma_93746 (h0 : topological_space (boolean_algebra (ring (finset linarith.comp)))) : t1_space (boolean_algebra (ring (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_93747 (h0 : measurable_space std_gen) (h1 : has_sup std_gen) : has_measurable_sup std_gen := sorry --non-trivial
lemma new_lemma_93748 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_93749 (h0 : add_monoid (metric_space num)) : add_monoid.fg (metric_space num) := sorry --non-trivial
lemma new_lemma_93750 (h0 : group (finset (has_to_string (boolean_algebra (ring (ring (has_add linarith.comp))))))) : group.fg (finset (has_to_string (boolean_algebra (ring (ring (has_add linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_93751 (h0 : not (topological_space (has_sub linarith.comp) -> false)) : @locally_compact_space.{0} (has_sub.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_93752 (h0 : complete_lattice (distrib empty)) : complete_lattice.is_Sup_finite_compact (distrib empty) := sorry --non-trivial
lemma new_lemma_93753 (h0 : semiring (has_nndist (finset (has_neg_part name)))) : is_noetherian_ring (has_nndist (finset (has_neg_part name))) := sorry --non-trivial
lemma new_lemma_93754 (h0 : ring (linear_ordered_semiring (semiring (semiring unsigned)))) : is_principal_ideal_ring (linear_ordered_semiring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_93755 (h0 : functor.add_const (topological_space (has_zero name)) environment.implicit_infer_kind) : @regular_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_93756 (h0 : topological_space (comm_monoid (semiring empty))) : path_connected_space (comm_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_93757 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @unique_factorization_monoid.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) cancel_comm_monoid_with_zero.{0}) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_93758 (h0 : ring (comm_group (has_neg Type))) : is_principal_ideal_ring (comm_group (has_neg Type)) := sorry --non-trivial
lemma new_lemma_93759 (h0 : uniform_space (has_pos_part (has_add linarith.comp))) : separated_space (has_pos_part (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_93760 (h0 : functor.add_const (complete_lattice (has_zero environment.implicit_infer_kind)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_93761 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (linear_ordered_field.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} num))  := sorry --non-trivial
lemma new_lemma_93762 (h3 : topological_space (fintype (has_nnnorm fun_info))) : totally_disconnected_space (fintype (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_93763 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_93764 (h0 : uniform_space (measurable_space.dynkin_system (semiring congr_arg_kind))) : separated_space (measurable_space.dynkin_system (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_93765 (h0 : functor.add_const (uniform_space (add_cancel_monoid environment.implicit_infer_kind)) Type) : @separated_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (uniform_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_93766 (h0 : functor.add_const (function.extfun Type uniform_space) Type) : @separated_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) Type h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_93767 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @is_cyclic.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_93768 (h0 : functor.add_const (group (left_cancel_monoid empty)) (semiring num)) : @is_cyclic.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (left_cancel_monoid.{0} empty)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_93769 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (bin_tree.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (bin_tree.{0} empty))  := sorry --non-trivial
lemma new_lemma_93770 (h0 : functor.add_const (topological_space (add_group unsigned)) unsigned) : @totally_separated_space.{0} (add_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_93771 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (add_left_cancel_semigroup.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_left_cancel_semigroup.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_93772 (h0 : list (normed_comm_ring unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_93773 (h0 : function.extfun (Type 1) group) : @is_simple_group.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_93774 (h0 : cancel_comm_monoid_with_zero (partial_order congr_arg_kind)) : unique_factorization_monoid (partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_93775 (h0 : not (topological_space (uniform_space linarith.comp_source) -> false)) : @t0_space.{0} (uniform_space.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_93776 (h1 : has_mem.mem (has_norm fun_info) has_emptyc.emptyc) : @is_domain.{0} (has_norm.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (has_norm.{0} fun_info) h1)  := sorry --non-trivial
lemma new_lemma_93777 (h0 : topological_space (monoid pos)) : loc_path_connected_space (monoid pos) := sorry --non-trivial
lemma new_lemma_93778 (h0 : group (normed_linear_ordered_group unsigned)) : normalizer_condition (normed_linear_ordered_group unsigned) := sorry --non-trivial
lemma new_lemma_93779 (h0 : functor.add_const (group (has_inter num)) empty) : @group.fg.{0} (has_inter.{0} num) (@functor.add_const.run.{0 0} (group.{0} (has_inter.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_93780 (h0 : topological_space (add_left_cancel_semigroup empty)) : preirreducible_space (add_left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_93781 (h0 : semiring (generalized_boolean_algebra (has_Inf (has_add pos)))) : is_noetherian_ring (generalized_boolean_algebra (has_Inf (has_add pos))) := sorry --non-trivial
lemma new_lemma_93782 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (ordered_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (semiring.{0} (ordered_comm_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_93783 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (has_ssubset.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (has_ssubset.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_93784 (h0 : functor.add_const (ring (has_nndist pos)) (has_neg Type)) : @rank_condition.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_nndist.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_93785 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_93786 (h0 : has_mem.mem ring has_emptyc.emptyc) : @strong_rank_condition.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_93787 (h0 : fin has_zero.zero) : @strong_rank_condition.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_93788 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (comm_semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_93789 (h0 : functor.add_const (topological_space (boolean_algebra.core linarith.comp)) name) : @path_connected_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_93790 (h0 : ring (has_one (semiring (semiring (semiring (semiring empty)))))) : strong_rank_condition (has_one (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_93791 (h0 : add_monoid (comm_group (has_to_string name))) : add_monoid.fg (comm_group (has_to_string name)) := sorry --non-trivial
lemma new_lemma_93792 (h0 : topological_space (boolean_algebra.core (normed_comm_ring Type))) : t0_space (boolean_algebra.core (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_93793 (h0 : uniform_space (distrib (has_nnnorm char))) : complete_space (distrib (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_93794 (h0 : functor.add_const (topological_space (option congr_arg_kind)) unsigned) : @irreducible_space.{0} (option.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_93795 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (add_right_cancel_monoid empty)) := sorry --non-trivial
lemma new_lemma_93796 (h0 : uniform_space (measurable_space to_additive.value_type)) : complete_space (measurable_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_93797 (h0 : functor.add_const (topological_space (ring empty)) num) : @t1_space.{0} (ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_93798 (h1 : topological_space (has_compl string_imp)) : path_connected_space (has_compl string_imp) := sorry --non-trivial
lemma new_lemma_93799 (h0 : topological_space (finset (finset pos))) : loc_path_connected_space (finset (finset pos)) := sorry --non-trivial
lemma new_lemma_93800 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_93801 (h0 : functor.add_const (monoid (comm_group unsigned)) (boolean_algebra (has_neg linarith.comp))) : @monoid.fg.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (comm_group.{0} unsigned)) (boolean_algebra.{0} (has_neg.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_93802 (h0 : ring (canonically_ordered_monoid (has_Inf (has_Inf name)))) : is_domain (canonically_ordered_monoid (has_Inf (has_Inf name))) := sorry --non-trivial
lemma new_lemma_93803 (h0 : filter (pseudo_metric_space (option (option (option (option ennreal)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_93804 (h0 : uniform_space (has_emptyc unsigned)) : complete_space (has_emptyc unsigned) := sorry --non-trivial
lemma new_lemma_93805 (h0 : function.extfun Type group) : @normalizer_condition.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_93806 (h0 : complete_lattice (add_comm_monoid (normed_comm_ring Type))) : is_compactly_generated (add_comm_monoid (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_93807 (h0 : topological_space (has_pos_part (has_neg linarith.comp))) : discrete_topology (has_pos_part (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_93808 (h0 : function.extfun Type ring) (h1 : function.extfun Type group) : @group.fg.{0} (@subring.{0} real (@function.extfun_app.{2 1} Type ring.{0} h0 real)) (@function.extfun_app.{2 1} Type group.{0} h1 (@subring.{0} real (@function.extfun_app.{2 1} Type ring.{0} h0 real)))  := sorry --non-trivial
lemma new_lemma_93809 (h0 : complete_lattice (linear_ordered_field num)) : is_compactly_generated (linear_ordered_field num) := sorry --non-trivial
lemma new_lemma_93810 (h0 : not (topological_space (with_bot linarith.comp) -> false)) : @path_connected_space.{0} (with_bot.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_93811 (h0 : functor.add_const (uniform_space (has_Inf pos)) (has_neg Type)) : @separated_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_Inf.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_93812 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_93813 (h0 : not (topological_space (add_cancel_comm_monoid to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (add_cancel_comm_monoid.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (add_cancel_comm_monoid.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_93814 (h0 : not (topological_space (add_left_cancel_monoid fun_info) -> false)) : @path_connected_space.{0} (add_left_cancel_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (add_left_cancel_monoid.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_93815 (h0 : group (semiring unsigned)) : is_cyclic (semiring unsigned) := sorry --non-trivial
lemma new_lemma_93816 (h0 : ring (linear_ordered_semiring (has_norm congr_arg_kind))) : strong_rank_condition (linear_ordered_semiring (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_93817 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_93818 (h0 : topological_space (ordered_comm_monoid (ring (ring Type)))) : irreducible_space (ordered_comm_monoid (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_93819 (h1 : ring (metric_space to_additive.value_type)) : strong_rank_condition (metric_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_93820 (h0 : topological_space (has_nndist environment.implicit_infer_kind)) : topological_space.separable_space (has_nndist environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_93821 (h0 : not (uniform_space (is_R_or_C num) -> false)) : @complete_space.{0} (is_R_or_C.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (is_R_or_C.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_93822 (h0 : ordered_comm_monoid (canonically_ordered_comm_semiring (ring unsigned))) : has_exists_mul_of_le (canonically_ordered_comm_semiring (ring unsigned)) := sorry --non-trivial
lemma new_lemma_93823 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf (has_Inf pos)))) : totally_separated_space (normed_lattice_add_comm_group (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_93824 (h0 : functor.add_const (monoid (ordered_comm_semiring unsigned)) unsigned) : @monoid.fg.{0} (ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (ordered_comm_semiring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_93825 (h0 : monoid (linear_ordered_add_comm_group (has_top (has_top fun_info)))) : monoid.fg (linear_ordered_add_comm_group (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_93826 (h0 : group (distrib (random_gen char))) : is_cyclic (distrib (random_gen char)) := sorry --non-trivial
lemma new_lemma_93827 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_93828 (h0 : ring (ordered_comm_ring (finset pos))) : strong_rank_condition (ordered_comm_ring (finset pos)) := sorry --non-trivial
lemma new_lemma_93829 (h0 : functor.add_const (topological_space (cancel_monoid name)) name) : @discrete_topology.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_93830 (h0 : functor.add_const (add_group (complete_distrib_lattice linarith.comp)) Type) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_group.{0} (complete_distrib_lattice.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_93831 (h0 : group (semigroup (boolean_algebra Type))) : is_cyclic (semigroup (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_93832 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_neg.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_neg.{0} empty))  := sorry --non-trivial
lemma new_lemma_93833 (h0 : finset (has_pos_part (has_nndist (ordered_comm_monoid pos)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_93834 (h0 : group (has_neg (boolean_algebra Type))) : is_cyclic (has_neg (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_93835 (h0 : topological_space (has_to_string (has_to_string Type))) : locally_compact_space (has_to_string (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_93836 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_93837 (h0 : function.extfun Type group) : @is_cyclic.{0} (simple_graph.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (simple_graph.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_93838 (h0 : group (boolean_algebra.core (option ennreal))) : group.fg (boolean_algebra.core (option ennreal)) := sorry --non-trivial
lemma new_lemma_93839 (h0 : functor.add_const (uniform_space (complete_distrib_lattice pos)) pos) : @separated_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (complete_distrib_lattice.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_93840 (h0 : function.extfun Type (functor.comp topological_space comm_group)) : @locally_compact_space.{0} (comm_group.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} comm_group.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_93841 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (is_R_or_C.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (is_R_or_C.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_93842 (h0 : ordered_comm_monoid (has_to_string (has_add (has_nndist (finset pos))))) : has_exists_mul_of_le (has_to_string (has_add (has_nndist (finset pos)))) := sorry --non-trivial
lemma new_lemma_93843 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space num))) : @strong_rank_condition.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_93844 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_93845 (h0 : topological_space (finset (has_neg (has_neg pos)))) : path_connected_space (finset (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_93846 (h0 : list (has_pos_part (has_neg pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_93847 (h0 : functor.add_const (finset (finset environment.implicit_infer_kind)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_93848 (h0 : cancel_comm_monoid_with_zero (free_add_monoid (semiring (semiring num)))) : unique_factorization_monoid (free_add_monoid (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_93849 (h0 : complete_lattice (normed_lattice_add_comm_group (has_Inf (has_add (has_add pos))))) : is_compactly_generated (normed_lattice_add_comm_group (has_Inf (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_93850 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_93851 (h0 : measurable_space (measurable_space empty)) (h1 : has_add (measurable_space empty)) (h2 : not (measure_theory.measure (measurable_space empty) -> false)) : measure_theory.measure.is_add_left_invariant (classical.by_contradiction' h2) := sorry --non-trivial
lemma new_lemma_93852 (h0 : monoid (measurable_space (semiring (semiring (semiring empty))))) : monoid.fg (measurable_space (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_93853 (h0 : finset (semiring congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_93854 (h0 : topological_space (comm_monoid unsigned)) : totally_disconnected_space (comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_93855 (h0 : topological_space (add_comm_monoid Type)) : regular_space (add_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_93856 (h0 : topological_space (mul_zero_class (pseudo_metric_space pos))) : totally_disconnected_space (mul_zero_class (pseudo_metric_space pos)) := sorry --non-trivial
lemma new_lemma_93857 (h0 : monoid (canonically_linear_ordered_monoid (has_add (has_neg real)))) : monoid.fg (canonically_linear_ordered_monoid (has_add (has_neg real))) := sorry --non-trivial
lemma new_lemma_93858 (h0 : uniform_space (ordered_comm_ring (ordered_comm_ring (has_add (has_add Type))))) : separated_space (ordered_comm_ring (ordered_comm_ring (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_93859 (h0 : functor.add_const (function.extfun Type semiring) empty) : @is_noetherian_ring.{0} (non_assoc_semiring.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) empty h0) (non_assoc_semiring.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_93860 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_93861 (h0 : functor.add_const (filter (finset pos)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_93862 (h0 : functor.add_const (topological_space (has_neg Type)) pos) : @t1_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_93863 (h0 : complete_lattice (has_emptyc (has_norm linarith.ineq))) : is_compactly_generated (has_emptyc (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_93864 (h0 : fin has_zero.zero) : @regular_space.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_93865 (h0 : ring (generalized_boolean_algebra (has_neg Type))) : is_principal_ideal_ring (generalized_boolean_algebra (has_neg Type)) := sorry --non-trivial
lemma new_lemma_93866 (h0 : set (add_comm_semigroup (add_comm_semigroup enat) -> std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_93867 (h2 : uniform_space (with_zero (with_zero to_additive.value_type))) : complete_space (with_zero (with_zero to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_93868 (h0 : add_group (with_bot (semiring (semiring unsigned)))) : is_add_cyclic (with_bot (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_93869 (h1 : group (with_one char)) : is_cyclic (with_one char) := sorry --non-trivial
lemma new_lemma_93870 (h0 : uniform_space (filter (option unsigned))) : complete_space (filter (option unsigned)) := sorry --non-trivial
lemma new_lemma_93871 (h0 : complete_lattice (has_neg (option (option (option (option (option empty))))))) : complete_lattice.is_Sup_finite_compact (has_neg (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_93872 (h0 : group (has_add (option (option unsigned)))) : is_cyclic (has_add (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_93873 (h0 : topological_space (sub_neg_monoid linarith.comp)) : t1_space (sub_neg_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_93874 (h0 : functor.add_const (ordered_add_comm_monoid (semiring congr_arg_kind)) congr_arg_kind) : @archimedean.{0} (semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semiring.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_93875 (h0 : ring (normed_group (semiring unsigned))) : is_domain (normed_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_93876 (h0 : functor.add_const (monoid (boolean_algebra.core pos)) (cancel_monoid Type)) : @monoid.fg.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 1} (monoid.{0} (boolean_algebra.core.{0} pos)) (cancel_monoid.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_93877 (h0 : not (topological_space (complete_linear_order unsigned) -> false)) : @totally_separated_space.{0} (complete_linear_order.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_linear_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_93878 (h0 : topological_space (has_lt (mul_one_class (mul_one_class linarith.ineq)))) : t0_space (has_lt (mul_one_class (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_93879 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) name) : @totally_disconnected_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_93880 (h0 : topological_space (random_gen (has_nnnorm (has_nnnorm fun_info)))) : t0_space (random_gen (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_93881 (h0 : functor.comp topological_space has_nndist Type) : @sequential_space.{1} (has_nndist.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_nndist.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_93882 (h0 : not (group (measurable_space.dynkin_system unsigned) -> false)) : @group.fg.{0} (measurable_space.dynkin_system.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (measurable_space.dynkin_system.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_93883 (h0 : functor.add_const (functor.add_const (topological_space (complete_distrib_lattice name)) Type) pos) : @totally_disconnected_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} name)) Type (@functor.add_const.run.{0 0} (functor.add_const.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} name)) Type) pos h0))  := sorry --non-trivial
lemma new_lemma_93884 (h0 : not (group (id empty) -> false)) : @group.fg.{0} (@id.{2} Type empty) (@classical.by_contradiction'.{1} (group.{0} (@id.{2} Type empty)) h0)  := sorry --non-trivial
lemma new_lemma_93885 (h0 : functor.add_const (group (comm_group pos)) linarith.comp) : @is_simple_group.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_93886 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (add_comm_monoid Type)) : @locally_compact_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) (add_comm_monoid.{1} Type) h0) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_93887 (h1 : ring (add_comm_semigroup (add_comm_semigroup std_gen))) : is_principal_ideal_ring (add_comm_semigroup (add_comm_semigroup std_gen)) := sorry --non-trivial
lemma new_lemma_93888 (h0 : functor.add_const (finset (ring linarith.comp)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_93889 (h0 : ring (has_top (has_norm (has_norm linarith.comp)))) : is_domain (has_top (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_93890 (h0 : functor.add_const (function.extfun Type group) name) : @is_simple_group.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) name h0) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_93891 (h0 : topological_space (metric_space num)) : discrete_topology (metric_space num) := sorry --non-trivial
lemma new_lemma_93892 (h0 : function.extfun (Type 1) topological_space) : @irreducible_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_93893 (h0 : list (ordered_comm_ring Type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_93894 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_neg pos)) pos) : @unique_factorization_monoid.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_neg.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_93895 (h0 : functor.add_const (uniform_space (non_assoc_semiring empty)) empty) : @complete_space.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (non_assoc_semiring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_93896 (h0 : ring (has_norm num)) : is_domain (has_norm num) := sorry --non-trivial
lemma new_lemma_93897 (h0 : topological_space (preorder (option (option unsigned)))) : loc_path_connected_space (preorder (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_93898 (h0 : has_mem.mem uniform_space has_emptyc.emptyc) : @separated_space.{0} (measurable_space.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} h0) (measurable_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_93899 (h0 : topological_space (has_ssubset (random_gen to_additive.value_type))) : path_connected_space (has_ssubset (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_93900 (h1 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @t0_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h1 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_93901 (h0 : topological_space (has_append (has_nnnorm reducibility_hints))) : t0_space (has_append (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_93902 (h0 : monoid (add_cancel_monoid (has_add (metric_space name)))) : monoid.fg (add_cancel_monoid (has_add (metric_space name))) := sorry --non-trivial
lemma new_lemma_93903 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@matrix.vec_empty.{0} (semiring.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_93904 (h0 : ring (fintype (has_nnnorm fun_info))) : strong_rank_condition (fintype (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_93905 (h0 : uniform_space (topological_space (has_nnnorm (has_nnnorm (denumerable reducibility_hints))))) : complete_space (topological_space (has_nnnorm (has_nnnorm (denumerable reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_93906 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_93907 (h0 : list (cancel_monoid (comm_monoid unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_93908 (h0 : topological_space (has_to_string linarith.comp)) : discrete_topology (has_to_string linarith.comp) := sorry --non-trivial
lemma new_lemma_93909 (h0 : functor.comp topological_space normed_comm_ring name) : @totally_disconnected_space.{0} (normed_comm_ring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} normed_comm_ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_93910 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (linear_ordered_field pos)) := sorry --non-trivial
lemma new_lemma_93911 (h0 : topological_space (has_zero (has_neg (has_neg Type)))) : normal_space (has_zero (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_93912 (h0 : topological_space (canonically_linear_ordered_monoid Type)) : normal_space (canonically_linear_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_93913 (h0 : topological_space (normed_comm_ring (comm_group (comm_group pos)))) : discrete_topology (normed_comm_ring (comm_group (comm_group pos))) := sorry --non-trivial
lemma new_lemma_93914 (h0 : topological_space (boolean_algebra (finset (has_add (finset (has_pos_part pos)))))) : preconnected_space (boolean_algebra (finset (has_add (finset (has_pos_part pos))))) := sorry --non-trivial
lemma new_lemma_93915 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_93916 (h0 : ring (has_ssubset (random_gen fun_info))) : is_domain (has_ssubset (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_93917 (h0 : topological_space (measurable_space to_additive.value_type)) : path_connected_space (measurable_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_93918 (h0 : uniform_space (has_dist congr_arg_kind)) : complete_space (has_dist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_93919 (h0 : functor.add_const (add_group (ordered_cancel_add_comm_monoid unsigned)) unsigned) : @is_add_cyclic.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (ordered_cancel_add_comm_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_93920 (h0 : functor.add_const (topological_space (plift num)) empty) : @totally_disconnected_space.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_93921 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_93922 (h0 : not (topological_space (has_top linarith.ineq) -> false)) : @totally_disconnected_space.{0} (has_top.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_93923 (h2 : topological_space (simple_graph char)) : path_connected_space (simple_graph char) := sorry --non-trivial
lemma new_lemma_93924 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_93925 (h0 : functor.add_const (topological_space (has_add Type)) (has_to_string pos)) : @t0_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) (has_to_string.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_93926 (h0 : cancel_monoid ennreal -> cancel_monoid ennreal -> Prop) : is_antisymm (cancel_monoid ennreal) h0 := sorry --non-trivial
lemma new_lemma_93927 (h0 : add_monoid (as_linear_order (option (option (option (option empty)))))) : add_monoid.fg (as_linear_order (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_93928 (h0 : ordered_comm_monoid (semigroup (pseudo_metric_space (option pos)))) : has_exists_mul_of_le (semigroup (pseudo_metric_space (option pos))) := sorry --non-trivial
lemma new_lemma_93929 (h0 : topological_space (has_div reducibility_hints)) : t0_space (has_div reducibility_hints) := sorry --non-trivial
lemma new_lemma_93930 (h0 : finset (mul_zero_class (semiring (semiring empty)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_93931 (h0 : functor.add_const (ring (finset name)) pos) : @strong_rank_condition.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_93932 (h0 : topological_space (normed_comm_ring (has_add Type))) : topological_space.separable_space (normed_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_93933 (h0 : functor.add_const (functor.add_const (group pos) Type) Type) : @is_cyclic.{0} pos (@functor.add_const.run.{0 1} (group.{0} pos) Type (@functor.add_const.run.{0 1} (functor.add_const.{0 1} (group.{0} pos) Type) Type h0))  := sorry --non-trivial
lemma new_lemma_93934 (h0 : group (mul_zero_class name)) : normalizer_condition (mul_zero_class name) := sorry --non-trivial
lemma new_lemma_93935 (h0 : functor.add_const (topological_space (has_neg_part name)) Type) : @normal_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg_part.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_93936 (h0 : not (topological_space (measurable_space empty) -> false)) : @path_connected_space.{0} (measurable_space.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_93937 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (free_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (free_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_93938 (h0 : not (uniform_space (has_add char) -> false)) : @complete_space.{0} (has_add.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_add.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_93939 (h0 : ring (with_bot fun_info)) : strong_rank_condition (with_bot fun_info) := sorry --non-trivial
lemma new_lemma_93940 (h0 : has_mem.mem (has_norm unsigned) has_emptyc.emptyc) : filter.ne_bot (finset.pi.empty filter (has_norm unsigned) h0) := sorry --non-trivial
lemma new_lemma_93941 (h0 : topological_space (complete_semilattice_Sup congr_arg_kind)) : irreducible_space (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_93942 (h0 : functor.add_const (list (canonically_ordered_comm_semiring unsigned)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_93943 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_93944 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (complete_semilattice_Sup.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (complete_semilattice_Sup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_93945 (h0 : ring (has_add (random_gen (has_inv linarith.comp_source)))) : strong_rank_condition (has_add (random_gen (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_93946 (h0 : complete_lattice (semigroup (add_cancel_monoid linarith.comp))) : is_compactly_generated (semigroup (add_cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_93947 (h0 : add_monoid (has_one congr_arg_kind)) : add_monoid.fg (has_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_93948 (h0 : ring (topological_space (has_ssubset linarith.ineq))) : strong_rank_condition (topological_space (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_93949 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @topological_space.separable_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_93950 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (bin_tree.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (bin_tree.{0} empty))  := sorry --non-trivial
lemma new_lemma_93951 (h0 : ring (has_nnnorm (mul_one_class linarith.comp_source))) : rank_condition (has_nnnorm (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_93952 (h0 : functor.add_const (functor.add_const (ring (measurable_space.dynkin_system empty)) empty) (option unsigned)) : @is_domain.{0} (measurable_space.dynkin_system.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (measurable_space.dynkin_system.{0} empty)) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ring.{0} (measurable_space.dynkin_system.{0} empty)) empty) (option.{0} unsigned) h0))  := sorry --non-trivial
lemma new_lemma_93953 (h0 : topological_space (boolean_algebra linarith.comp)) : regular_space (boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_93954 (h0 : add_group (left_cancel_monoid (semiring congr_arg_kind))) : is_add_cyclic (left_cancel_monoid (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_93955 (h0 : uniform_space (has_add (boolean_algebra.core name))) : complete_space (has_add (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_93956 (h0 : add_group (simple_graph (mul_one_class linarith.ineq))) : is_add_cyclic (simple_graph (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_93957 (h0 : topological_space (add_cancel_monoid Type)) : topological_space.separable_space (add_cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_93958 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_ordered_comm_semiring.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_ordered_comm_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_93959 (h0 : fin has_zero.zero) : @path_connected_space.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_93960 (h1 : topological_space (dlist (has_nnnorm char))) : path_connected_space (dlist (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_93961 (h0 : ring (mul_zero_class (boolean_algebra.core name))) : strong_rank_condition (mul_zero_class (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_93962 (h0 : ring (has_Inf (ordered_comm_monoid real))) : strong_rank_condition (has_Inf (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_93963 (h1 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h1 (measurable_space linarith.comp)) := sorry --non-trivial
lemma new_lemma_93964 (h0 : ring (comm_ring (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) : is_domain (comm_ring (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_93965 (h0 : set (add_comm_semigroup fun_info -> enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_93966 (h0 : uniform_space (linear_ordered_comm_ring (semiring num))) : complete_space (linear_ordered_comm_ring (semiring num)) := sorry --non-trivial
lemma new_lemma_93967 (h0 : functor.add_const (topological_space (ordered_comm_group empty)) empty) : @irreducible_space.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_93968 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_93969 (h0 : functor.comp topological_space normed_comm_ring Type) : @topological_space.separable_space.{1} (normed_comm_ring.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} normed_comm_ring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_93970 (h0 : functor.add_const (group (add_comm_monoid pos)) (finset (has_nndist (has_to_string (has_neg Type))))) : @group.fg.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (add_comm_monoid.{0} pos)) (finset.{1} (has_nndist.{1} (has_to_string.{1} (has_neg.{1} Type)))) h0)  := sorry --non-trivial
lemma new_lemma_93971 (h0 : function.extfun (Type 1) group) : @is_cyclic.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_93972 (h0 : ring (has_neg (has_neg Type))) : rank_condition (has_neg (has_neg Type)) := sorry --non-trivial
lemma new_lemma_93973 (h0 : functor.add_const (add_monoid (generalized_boolean_algebra pos)) Type) : @add_monoid.fg.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (add_monoid.{0} (generalized_boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_93974 (h0 : add_group (complete_linear_order (semiring (semiring (semiring unsigned))))) : is_add_cyclic (complete_linear_order (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_93975 (h1 : set (add_comm_semigroup ereal -> normed_field (add_comm_semigroup (mul_one_class ereal)))) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_93976 (h0 : topological_space (fintype (semiring (semiring empty)))) : irreducible_space (fintype (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_93977 (h0 : list (has_Inf (has_add linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_93978 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_93979 (h1 : add_group (add_comm_semigroup (mul_one_class environment.projection_info))) : is_add_cyclic (add_comm_semigroup (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_93980 (h0 : functor.add_const (ordered_comm_monoid (ring Type)) (ring (has_to_string (has_neg Type)))) : @has_exists_mul_of_le.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (ordered_comm_monoid.{1} (ring.{1} Type)) (ring.{1} (has_to_string.{1} (has_neg.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_93981 (h0 : functor.add_const (list (boolean_algebra.core linarith.comp)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_93982 (h0 : uniform_space enat) : separated_space enat := sorry --non-trivial
lemma new_lemma_93983 (h0 : list (normed_group (has_inv to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_93984 (h0 : topological_space (semigroup (ring name))) : regular_space (semigroup (ring name)) := sorry --non-trivial
lemma new_lemma_93985 (h0 : ring (normed_linear_ordered_group empty)) : strong_rank_condition (normed_linear_ordered_group empty) := sorry --non-trivial
lemma new_lemma_93986 (h0 : fin has_zero.zero) : @t1_space.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_93987 (h0 : not (group (has_union empty) -> false)) : @group.fg.{0} (has_union.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (has_union.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_93988 (h0 : list (comm_ring (random_gen linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_93989 (h0 : complete_lattice (complete_linear_order unsigned)) : complete_lattice.is_Sup_finite_compact (complete_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_93990 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_93991 (h0 : complete_lattice (monoid pos)) : is_atomistic (monoid pos) := sorry --non-trivial
lemma new_lemma_93992 (h0 : topological_space (as_linear_order (option num))) : irreducible_space (as_linear_order (option num)) := sorry --non-trivial
lemma new_lemma_93993 (h0 : group (has_nndist ennreal)) : normalizer_condition (has_nndist ennreal) := sorry --non-trivial
lemma new_lemma_93994 (h0 : filter (has_zero ennreal)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_93995 (h0 : functor.add_const (ordered_comm_monoid (comm_group name)) name) : @has_exists_mul_of_le.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (comm_group.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_93996 (h0 : topological_space (plift (option empty))) : locally_compact_space (plift (option empty)) := sorry --non-trivial
lemma new_lemma_93997 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (is_R_or_C.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (is_R_or_C.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_93998 (h0 : not (topological_space (non_unital_non_assoc_semiring reducibility_hints) -> false)) : @t0_space.{0} (non_unital_non_assoc_semiring.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (non_unital_non_assoc_semiring.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_93999 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_94000 (h0 : add_monoid (has_add (has_neg (ring Type)))) : add_monoid.fg (has_add (has_neg (ring Type))) := sorry --non-trivial
lemma new_lemma_94001 (h0 : functor.add_const (list (complete_distrib_lattice linarith.comp)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_94002 (h0 : functor.add_const (complete_lattice (boolean_algebra unsigned)) (has_to_string linarith.comp)) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} unsigned)) (has_to_string.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_94003 (h0 : not (ring (linear_ordered_comm_group_with_zero fun_info) -> false)) : @strong_rank_condition.{0} (linear_ordered_comm_group_with_zero.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_comm_group_with_zero.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_94004 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_94005 (h0 : topological_space (mul_zero_class (semiring (semiring unsigned)))) : locally_compact_space (mul_zero_class (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_94006 (h0 : functor.add_const (filter (boolean_algebra Type)) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_94007 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_94008 (h1 : function.extfun Type add_group) : @is_add_cyclic.{0} congr_arg_kind (@function.extfun_app.{2 1} Type add_group.{0} h1 congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_94009 (h0 : list (option ennreal)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_94010 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @t1_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_94011 (h0 : complete_lattice (semigroup (has_to_string (has_to_string congr_arg_kind)))) : is_compactly_generated (semigroup (has_to_string (has_to_string congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_94012 (h0 : topological_space (normed_comm_ring (option empty))) : totally_separated_space (normed_comm_ring (option empty)) := sorry --non-trivial
lemma new_lemma_94013 (h0 : functor.comp group has_neg pos) : @group.fg.{0} (has_neg.{0} pos) (@functor.comp.run.{0 0 0} group.{0} has_neg.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_94014 (h0 : finset (monoid_with_zero (option (option pos)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_94015 (h0 : not (topological_space (add_right_cancel_monoid empty) -> false)) : @t1_space.{0} (add_right_cancel_monoid.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (add_right_cancel_monoid.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_94016 (h0 : group (has_Inf (has_Inf (has_pos_part (has_add linarith.comp))))) : normalizer_condition (has_Inf (has_Inf (has_pos_part (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_94017 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (add_left_cancel_semigroup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_left_cancel_semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_94018 (h1 : add_group (random_gen (has_nnnorm (has_inv (has_nnnorm (has_nnnorm (has_nnnorm char))))))) : is_add_cyclic (random_gen (has_nnnorm (has_inv (has_nnnorm (has_nnnorm (has_nnnorm char)))))) := sorry --non-trivial
lemma new_lemma_94019 (h0 : ring (canonically_linear_ordered_monoid (option (option num)))) : strong_rank_condition (canonically_linear_ordered_monoid (option (option num))) := sorry --non-trivial
lemma new_lemma_94020 (h0 : measurable_space (mul_one_class linarith.ineq)) (h1 : measure_theory.measure (mul_one_class linarith.ineq)) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_94021 (h0 : functor.add_const (uniform_space (has_neg_part pos)) pos) : @separated_space.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_neg_part.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_94022 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_94023 (h0 : filter (semigroup (has_add (has_add name)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_94024 (h0 : add_monoid (semigroup ennreal)) : add_monoid.fg (semigroup ennreal) := sorry --non-trivial
lemma new_lemma_94025 (h0 : functor.comp ring normed_comm_ring name) : @is_domain.{0} (normed_comm_ring.{0} name) (@functor.comp.run.{0 0 0} ring.{0} normed_comm_ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_94026 (h0 : topological_space (distrib (has_lt (random_gen char)))) : t0_space (distrib (has_lt (random_gen char))) := sorry --non-trivial
lemma new_lemma_94027 (h0 : ring (has_top linarith.comp)) : is_domain (has_top linarith.comp) := sorry --non-trivial
lemma new_lemma_94028 (h0 : functor.add_const (filter (semigroup environment.implicit_infer_kind)) (finset name)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_94029 (h0 : function.extfun Type topological_space) : @t0_space.{0} (linear_ordered_field.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_94030 (h0 : add_group (distrib (has_nnnorm (denumerable char)))) : is_add_cyclic (distrib (has_nnnorm (denumerable char))) := sorry --non-trivial
lemma new_lemma_94031 (h0 : group (add_cancel_monoid (semiring (semiring (option empty))))) : group.fg (add_cancel_monoid (semiring (semiring (option empty)))) := sorry --non-trivial
lemma new_lemma_94032 (h0 : topological_space (with_one (has_top (has_top (has_top (has_top num)))))) : locally_compact_space (with_one (has_top (has_top (has_top (has_top num))))) := sorry --non-trivial
lemma new_lemma_94033 (h0 : ordered_add_comm_monoid (has_bot (has_pos_part (ordered_comm_monoid (sub_neg_monoid (has_bot pos)))))) : archimedean (has_bot (has_pos_part (ordered_comm_monoid (sub_neg_monoid (has_bot pos))))) := sorry --non-trivial
lemma new_lemma_94034 (h0 : (ereal -> fun_info) -> ereal -> fun_info) : set.separates_points (function.is_fixed_pt h0) := sorry --non-trivial
lemma new_lemma_94035 (h0 : topological_space (simple_graph (option empty))) : t0_space (simple_graph (option empty)) := sorry --non-trivial
lemma new_lemma_94036 (h0 : functor.add_const (topological_space (has_to_string environment.implicit_infer_kind)) Type) : @regular_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_94037 (h0 : monoid (canonically_linear_ordered_monoid congr_arg_kind)) : monoid.fg (canonically_linear_ordered_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_94038 (h0 : topological_space (measurable_space (random_gen num))) : totally_separated_space (measurable_space (random_gen num)) := sorry --non-trivial
lemma new_lemma_94039 (h0 : complete_lattice (canonically_ordered_comm_semiring (option ennreal))) : is_compactly_generated (canonically_ordered_comm_semiring (option ennreal)) := sorry --non-trivial
lemma new_lemma_94040 (h0 : list (has_to_string (has_Inf pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_94041 (h0 : function.extfun (Type 1) (functor.add_const (complete_lattice (has_nndist pos)))) : @is_atomistic.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_nndist.{0} pos)) Type (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (complete_lattice.{0} (has_nndist.{0} pos))) h0 Type))  := sorry --non-trivial
lemma new_lemma_94042 (h0 : functor.add_const (topological_space (left_cancel_monoid num)) congr_arg_kind) : @discrete_topology.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_94043 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (topological_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (topological_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_94044 (h0 : not (complete_lattice (linear_ordered_add_comm_group to_additive.value_type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_94045 (h0 : topological_space (mul_zero_class (option unsigned))) : normal_space (mul_zero_class (option unsigned)) := sorry --non-trivial
lemma new_lemma_94046 (h0 : semiring (has_zero (has_zero (ring (finset environment.implicit_infer_kind))))) : is_noetherian_ring (has_zero (has_zero (ring (finset environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_94047 (h0 : topological_space (has_neg (ring linarith.comp))) : totally_separated_space (has_neg (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_94048 (h0 : topological_space (metric_space unsigned)) : t0_space (metric_space unsigned) := sorry --non-trivial
lemma new_lemma_94049 (h0 : function.extfun Type ring) : @rank_condition.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_94050 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @is_cyclic.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_94051 (h0 : ring (comm_ring (random_gen char))) : rank_condition (comm_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_94052 (h0 : function.extfun Type has_neg) (h1 : measurable_space (has_div enat)) : @has_measurable_neg.{0} (has_div.{0} enat) (@function.extfun_app.{2 1} Type has_neg.{0} h0 (has_div.{0} enat)) h1  := sorry --non-trivial
lemma new_lemma_94053 (h0 : add_monoid (comm_group (cancel_monoid pos))) : add_monoid.fg (comm_group (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_94054 (h0 : topological_space (metric_space (semiring (semiring (semiring (semiring (semiring empty))))))) : t0_space (metric_space (semiring (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_94055 (h0 : set (has_nnnorm to_additive.value_type)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_94056 (h0 : topological_space (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup linarith.ineq)))) (h3 : preorder (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup linarith.ineq)))) : order_topology (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup linarith.ineq))) := sorry --non-trivial
lemma new_lemma_94057 (h0 : ring (left_cancel_monoid (option (option unsigned)))) : strong_rank_condition (left_cancel_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_94058 (h0 : topological_space (linear_ordered_semiring (semiring congr_arg_kind))) : preirreducible_space (linear_ordered_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_94059 (h1 : set (non_unital_non_assoc_semiring (mul_one_class (distrib linarith.comp_source)))) : set.finite h1 := sorry --non-trivial
lemma new_lemma_94060 (h0 : topological_space (has_top fun_info)) : t0_space (has_top fun_info) := sorry --non-trivial
lemma new_lemma_94061 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_norm.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_norm.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_94062 (h0 : function.extfun (Type 1) cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} h0 (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_94063 (h0 : filter (boolean_algebra (has_neg pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_94064 (h0 : not (function.extfun Type add_monoid -> false)) (h1 : not (has_one (add_right_cancel_monoid empty) -> false)) : @char_zero.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (add_right_cancel_monoid.{0} empty)) (@classical.by_contradiction'.{1} (has_one.{0} (add_right_cancel_monoid.{0} empty)) h1)  := sorry --non-trivial
lemma new_lemma_94065 (h0 : ring (comm_ring linarith.comp_source)) : is_domain (comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_94066 (h0 : list (complete_distrib_lattice (has_Inf (ordered_comm_monoid (has_bot (ordered_comm_monoid Type)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_94067 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (linear_ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (linear_ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_94068 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_94069 (h0 : complete_lattice (has_compl (has_lt reducibility_hints))) : is_compactly_generated (has_compl (has_lt reducibility_hints)) := sorry --non-trivial
lemma new_lemma_94070 (h0 : uniform_space (normed_comm_ring (finset linarith.comp))) : complete_space (normed_comm_ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_94071 (h0 : ring (with_bot (semiring (semiring num)))) : rank_condition (with_bot (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_94072 (h0 : topological_space (uniform_space char)) : path_connected_space (uniform_space char) := sorry --non-trivial
lemma new_lemma_94073 (h0 : functor.add_const (complete_lattice (ring linarith.comp)) name) : @is_atomistic.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_94074 (h0 : topological_space (nondiscrete_normed_field (add_comm_semigroup fun_info))) : path_connected_space (nondiscrete_normed_field (add_comm_semigroup fun_info)) := sorry --non-trivial
lemma new_lemma_94075 (h0 : function.extfun (Type 1) topological_space) : @t0_space.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_94076 (h0 : functor.add_const (functor.add_const (topological_space Type) linarith.comp) (has_Inf linarith.comp)) : @t0_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) linarith.comp (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (topological_space.{1} Type) linarith.comp) (has_Inf.{0} linarith.comp) h0))  := sorry --non-trivial
lemma new_lemma_94077 (h0 : functor.add_const (topological_space (partial_order num)) (semiring empty)) : @preirreducible_space.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} num)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_94078 (h1 : ring to_additive.value_type) : strong_rank_condition to_additive.value_type := sorry --non-trivial
lemma new_lemma_94079 (h0 : group (linear_ordered_cancel_comm_monoid (semiring empty))) : is_cyclic (linear_ordered_cancel_comm_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_94080 (h0 : set (semi_normed_comm_ring (non_unital_non_assoc_semiring reducibility_hints) -> environment.projection_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_94081 (h0 : topological_space (canonically_ordered_add_monoid (option unsigned))) : path_connected_space (canonically_ordered_add_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_94082 (h0 : topological_space string_imp) (h1 : not (preorder string_imp -> false)) : @order_topology.{0} string_imp h0 (@classical.by_contradiction'.{1} (preorder.{0} string_imp) h1)  := sorry --non-trivial
lemma new_lemma_94083 (h0 : add_group (omega_complete_partial_order empty)) : is_add_cyclic (omega_complete_partial_order empty) := sorry --non-trivial
lemma new_lemma_94084 (h0 : functor.add_const (topological_space (comm_group Type)) pos) : @regular_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_94085 (h0 : function.extfun Type comm_ring) : @local_ring.{0} linarith.comp_source (@function.extfun_app.{2 1} Type comm_ring.{0} h0 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_94086 (h0 : has_mem.mem (linear_ordered_semiring unsigned) has_emptyc.emptyc) : @is_atomistic.{0} (linear_ordered_semiring.{0} unsigned) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (linear_ordered_semiring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_94087 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_94088 (h0 : functor.add_const (topological_space (semigroup pos)) environment.implicit_infer_kind) : @topological_space.separable_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_94089 (h0 : group (has_neg (has_to_string (has_to_string (has_to_string (has_to_string Type)))))) : is_simple_group (has_neg (has_to_string (has_to_string (has_to_string (has_to_string Type))))) := sorry --non-trivial
lemma new_lemma_94090 (h0 : functor.add_const (topological_space (option congr_arg_kind)) unsigned) : @path_connected_space.{0} (option.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_94091 (h0 : group (boolean_algebra (has_pos_part linarith.comp))) : is_simple_group (boolean_algebra (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_94092 (h0 : group (has_to_string (has_add ennreal))) : group.fg (has_to_string (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_94093 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_94094 (h0 : ereal -> ereal -> Prop) (h1 : ereal) : nonempty (acc h0 h1) := sorry --non-trivial
lemma new_lemma_94095 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) Type) : @complete_lattice.is_Sup_finite_compact.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) Type h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_94096 (h0 : filter (normed_comm_ring (has_to_string pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_94097 (h0 : not (group (linear_ordered_semiring num) -> false)) : @group.fg.{0} (linear_ordered_semiring.{0} num) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_94098 (h0 : ring (mul_zero_class (semiring (semiring unsigned)))) : is_principal_ideal_ring (mul_zero_class (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_94099 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) Type) : @t0_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (normed_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_94100 (h0 : topological_space (random_gen (semiring linarith.comp))) : discrete_topology (random_gen (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_94101 (h0 : monoid (canonically_ordered_comm_semiring (option (option (option unsigned))))) : monoid.fg (canonically_ordered_comm_semiring (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_94102 (h0 : ring (finset (has_neg_part pos))) : is_principal_ideal_ring (finset (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_94103 (h1 : add_group (measurable_space (random_gen string_imp))) : is_add_cyclic (measurable_space (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_94104 (h0 : fin has_zero.zero) : @is_simple_group.{0} (ordered_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (group.{0} (ordered_comm_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_94105 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} znum (@function.extfun_app.{2 1} Type topological_space.{0} h0 znum)  := sorry --non-trivial
lemma new_lemma_94106 (h0 : ordered_add_comm_monoid (ring empty)) : archimedean (ring empty) := sorry --non-trivial
lemma new_lemma_94107 (h0 : list (has_pos_part (finset pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_94108 (h0 : topological_space (linear_ordered_semiring congr_arg_kind)) : normal_space (linear_ordered_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_94109 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @is_cyclic.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_94110 (h0 : topological_space (normed_lattice_add_comm_group (has_add Type))) : loc_path_connected_space (normed_lattice_add_comm_group (has_add Type)) := sorry --non-trivial
lemma new_lemma_94111 (h0 : list (has_top (comm_ring (has_ssubset (dlist (has_ssubset (has_ssubset to_additive.value_type))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_94112 (h2 : function.extfun Type group) : @is_cyclic.{0} (complete_semilattice_Sup.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h2 (complete_semilattice_Sup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_94113 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (complete_linear_order.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (complete_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_94114 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (option name)) := sorry --non-trivial
lemma new_lemma_94115 (h0 : has_mem.mem group has_emptyc.emptyc) : @is_cyclic.{0} string_imp (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) string_imp)  := sorry --non-trivial
lemma new_lemma_94116 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_94117 (h0 : topological_space (has_neg (add_comm_monoid pos))) : normal_space (has_neg (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_94118 (h0 : function.extfun Type group) : @is_cyclic.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_94119 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_bot.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_94120 (h0 : complete_lattice (canonically_ordered_comm_semiring (option name))) : is_atomistic (canonically_ordered_comm_semiring (option name)) := sorry --non-trivial
lemma new_lemma_94121 (h0 : functor.add_const (topological_space (has_Inf Type)) (ring (ring pos))) : @sequential_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_Inf.{1} Type)) (ring.{0} (ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_94122 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @t0_space.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_94123 (h0 : add_group (has_pos_part (finset linarith.comp))) : is_add_cyclic (has_pos_part (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_94124 (h1 : add_group (comm_ring (mul_one_class to_additive.value_type))) : is_add_cyclic (comm_ring (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_94125 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @rank_condition.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_94126 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_94127 (h0 : ring (ordered_comm_ring (has_neg (has_neg (has_neg name))))) : is_principal_ideal_ring (ordered_comm_ring (has_neg (has_neg (has_neg name)))) := sorry --non-trivial
lemma new_lemma_94128 (h0 : add_monoid (semiring (complete_semilattice_Sup congr_arg_kind))) : add_monoid.fg (semiring (complete_semilattice_Sup congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_94129 (h0 : function.extfun Type ring) : @rank_condition.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_94130 (h0 : add_group (boolean_algebra (add_comm_monoid Type))) : is_add_cyclic (boolean_algebra (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_94131 (h0 : filter (has_inter num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_94132 (h2 : topological_space (mul_one_class ereal)) : totally_disconnected_space (mul_one_class ereal) := sorry --non-trivial
lemma new_lemma_94133 (h0 : option (filter (normed_comm_ring congr_arg_kind))) (h1 : filter (normed_comm_ring congr_arg_kind)) : filter.ne_bot (option.get_or_else h0 h1) := sorry --non-trivial
lemma new_lemma_94134 (h0 : group (semi_normed_comm_ring fun_info)) : group.fg (semi_normed_comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_94135 (h0 : topological_space (normed_comm_ring congr_arg_kind)) : path_connected_space (normed_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_94136 (h0 : fin has_zero.zero) : @loc_path_connected_space.{1} (add_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (add_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_94137 (h0 : ordered_comm_monoid (add_comm_monoid (boolean_algebra environment.implicit_infer_kind))) : has_exists_mul_of_le (add_comm_monoid (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_94138 (h0 : ring (has_nnnorm (mul_one_class (has_ssubset (mul_one_class ereal))))) : is_domain (has_nnnorm (mul_one_class (has_ssubset (mul_one_class ereal)))) := sorry --non-trivial
lemma new_lemma_94139 (h0 : topological_space (semigroup unsigned)) : t1_space (semigroup unsigned) := sorry --non-trivial
lemma new_lemma_94140 (h0 : semiring (add_cancel_monoid (ring (has_pos_part Type)))) : is_noetherian_ring (add_cancel_monoid (ring (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_94141 (h0 : functor.add_const (list (has_Inf linarith.comp)) (has_pos_part linarith.comp)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_94142 (h0 : group (has_sub fun_info)) : normalizer_condition (has_sub fun_info) := sorry --non-trivial
lemma new_lemma_94143 (h0 : functor.add_const (list (free_add_monoid congr_arg_kind)) (option (option (option unsigned)))) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_94144 (h0 : functor.add_const (filter (semigroup name)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_94145 (h0 : semiring (canonically_ordered_comm_semiring (finset linarith.comp))) : is_noetherian_ring (canonically_ordered_comm_semiring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_94146 (h1 : topological_space (has_nnnorm string.iterator_imp)) : t0_space (has_nnnorm string.iterator_imp) := sorry --non-trivial
lemma new_lemma_94147 (h0 : ring (has_neg (option num))) : strong_rank_condition (has_neg (option num)) := sorry --non-trivial
lemma new_lemma_94148 (h0 : complete_lattice (uniform_space (random_gen char))) : is_compactly_generated (uniform_space (random_gen char)) := sorry --non-trivial
lemma new_lemma_94149 (h0 : list (has_neg (linear_ordered_comm_group_with_zero enat))) (h1 : nat) (h2 : has_lt.lt h1 (list.length h0)) (h3 : measurable_space (linear_ordered_comm_group_with_zero enat)) : @has_measurable_neg.{0} (linear_ordered_comm_group_with_zero.{0} enat) (@list.nth_le.{0} (has_neg.{0} (linear_ordered_comm_group_with_zero.{0} enat)) h0 h1 h2) h3  := sorry --non-trivial
lemma new_lemma_94150 (h0 : list (semigroup (semiring (semiring (semiring unsigned))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_94151 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (free_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (free_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_94152 (h0 : ring (topological_space linarith.comp_source)) : strong_rank_condition (topological_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_94153 (h0 : topological_space (linear_ordered_comm_group num)) : totally_separated_space (linear_ordered_comm_group num) := sorry --non-trivial
lemma new_lemma_94154 (h0 : function.extfun Type (functor.comp topological_space has_to_string)) : @sequential_space.{0} (has_to_string.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_to_string.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_94155 (h0 : functor.add_const (functor.add_const (list pos) (finset pos)) Type) : list.nodup (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_94156 (h0 : prod (linear_ordered_comm_monoid_with_zero congr_arg_kind) (linear_ordered_comm_monoid_with_zero congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_94157 (h0 : functor.add_const (finset (canonically_ordered_comm_semiring unsigned)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_94158 (h0 : add_group (canonically_ordered_comm_semiring num)) : is_add_cyclic (canonically_ordered_comm_semiring num) := sorry --non-trivial
lemma new_lemma_94159 (h0 : not (uniform_space (has_norm empty) -> false)) : @complete_space.{0} (has_norm.{0} empty) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_norm.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_94160 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @complete_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 uniform_space.{1}) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_94161 (h0 : set (simple_graph linarith.ineq)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_94162 (h0 : uniform_space (add_cancel_monoid (option pos))) : separated_space (add_cancel_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_94163 (h1 : uniform_space (semi_normed_comm_ring (has_ssubset char))) : complete_space (semi_normed_comm_ring (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_94164 (h0 : functor.add_const Prop (semiring congr_arg_kind)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_94165 (h0 : functor.add_const (add_group (boolean_algebra name)) name) : @is_add_cyclic.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (boolean_algebra.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_94166 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (monoid.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_94167 (h0 : not (add_monoid (with_one congr_arg_kind) -> false)) : @add_monoid.fg.{0} (with_one.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_monoid.{0} (with_one.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_94168 (h0 : functor.add_const (complete_lattice (free_add_monoid unsigned)) unsigned) : @is_atomistic.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (free_add_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_94169 (h0 : functor.add_const (topological_space (has_nndist pos)) (measurable_space.dynkin_system linarith.comp)) : @normal_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) (measurable_space.dynkin_system.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_94170 (h0 : functor.add_const (topological_space (mul_zero_class ennreal)) pos) : @totally_disconnected_space.{0} (mul_zero_class.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_94171 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_94172 (h0 : function.extfun Type topological_space) : @regular_space.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_94173 (h0 : has_top fun_info -> Prop) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) (has_top.{0} fun_info) h0  := sorry --non-trivial
lemma new_lemma_94174 (h0 : functor.comp topological_space has_zero pos) : @regular_space.{0} (has_zero.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_94175 (h0 : cancel_comm_monoid_with_zero (has_add (has_add (has_add real)))) : unique_factorization_monoid (has_add (has_add (has_add real))) := sorry --non-trivial
lemma new_lemma_94176 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (bin_tree.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} num))  := sorry --non-trivial
lemma new_lemma_94177 (h0 : function.extfun Type group) : @is_simple_group.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_94178 (h0 : topological_space (bin_tree congr_arg_kind)) : irreducible_space (bin_tree congr_arg_kind) := sorry --non-trivial
lemma new_lemma_94179 (h0 : set (has_ssubset (mul_one_class char))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_94180 (h0 : function.extfun Type (functor.comp topological_space has_neg)) : @sequential_space.{0} (has_neg.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_neg.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_94181 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_94182 (h0 : function.extfun Type topological_space) : @normal_space.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_94183 (h0 : topological_space (ring (has_Inf linarith.comp))) : path_connected_space (ring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_94184 (h0 : list (cancel_monoid unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_94185 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @sequential_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_94186 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (complete_linear_order unsigned)) := sorry --non-trivial
lemma new_lemma_94187 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (metric_space.{0} (has_norm.{0} linarith.comp)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} (has_norm.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_94188 (h0 : not (complete_lattice (with_bot linarith.comp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} linarith.comp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_bot.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_94189 (h0 : ordered_add_comm_monoid (has_Inf linarith.comp)) : archimedean (has_Inf linarith.comp) := sorry --non-trivial
lemma new_lemma_94190 (h0 : group (linear_ordered_comm_group_with_zero linarith.comp_source)) : is_cyclic (linear_ordered_comm_group_with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_94191 (h0 : char) (h1 : set (prod char char)) (h2 : char) : nonempty (uniform_space.ball h0 h1 h2) := sorry --non-trivial
lemma new_lemma_94192 (h0 : not (prod (id unsigned) (id unsigned) -> false)) : id_rel (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_94193 (h0 : functor.add_const (function.extfun Type complete_lattice) fun_info) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) fun_info h0) (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_94194 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_94195 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (distrib_lattice string_imp)) := sorry --non-trivial
lemma new_lemma_94196 (h0 : topological_space environment.projection_info) (h1 : add_group environment.projection_info) : topological_add_group environment.projection_info := sorry --non-trivial
lemma new_lemma_94197 (h2 : topological_space (topological_space (semigroup linarith.comp_source))) : t0_space (topological_space (semigroup linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_94198 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_94199 (h0 : measurable_space (nondiscrete_normed_field fun_info)) (h1 : measure_theory.measure (nondiscrete_normed_field fun_info)) : measure_theory.has_no_atoms h1 := sorry --non-trivial
lemma new_lemma_94200 (h0 : group (ordered_comm_monoid (has_neg (has_neg name)))) : is_simple_group (ordered_comm_monoid (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_94201 (h0 : functor.add_const (ordered_add_comm_monoid (has_nndist Type)) name) : @archimedean.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (has_nndist.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_94202 (h0 : topological_space (has_add (has_neg_part unsigned))) : totally_separated_space (has_add (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_94203 (h1 : ring (topological_space (comm_ring char))) : strong_rank_condition (topological_space (comm_ring char)) := sorry --non-trivial
lemma new_lemma_94204 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_Inf (has_Inf Type))) : @path_connected_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_Inf.{1} (has_Inf.{1} Type)) h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_94205 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (boolean_algebra.core.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} h0 (boolean_algebra.core.{0} num))  := sorry --non-trivial
lemma new_lemma_94206 (h0 : topological_space (add_cancel_monoid (boolean_algebra (comm_group Type)))) : regular_space (add_cancel_monoid (boolean_algebra (comm_group Type))) := sorry --non-trivial
lemma new_lemma_94207 (h0 : add_monoid (ring (finset Type))) : add_monoid.fg (ring (finset Type)) := sorry --non-trivial
lemma new_lemma_94208 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_94209 (h1 : complete_lattice (encodable string_imp)) : is_compactly_generated (encodable string_imp) := sorry --non-trivial
lemma new_lemma_94210 (h0 : topological_space (has_top (comm_ring linarith.comp_source))) : totally_disconnected_space (has_top (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_94211 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra unsigned)) (has_neg linarith.comp)) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.{0} unsigned)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_94212 (h0 : topological_space (comm_group (semigroup (boolean_algebra environment.implicit_infer_kind)))) : irreducible_space (comm_group (semigroup (boolean_algebra environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_94213 (h0 : filter (add_comm_monoid (finset linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_94214 (h0 : uniform_space (semigroup (has_to_string (comm_group pos)))) : separated_space (semigroup (has_to_string (comm_group pos))) := sorry --non-trivial
lemma new_lemma_94215 (h0 : functor.add_const (topological_space (bin_tree pos)) (ring Type)) : @irreducible_space.{0} (bin_tree.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (bin_tree.{0} pos)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_94216 (h0 : topological_space (has_one (has_norm empty))) : t0_space (has_one (has_norm empty)) := sorry --non-trivial
lemma new_lemma_94217 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (group_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (group_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_94218 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) Type) : @loc_path_connected_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_94219 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_94220 (h0 : uniform_space (filter linarith.ineq)) : complete_space (filter linarith.ineq) := sorry --non-trivial
lemma new_lemma_94221 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_emptyc fun_info)) := sorry --non-trivial
lemma new_lemma_94222 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @rank_condition.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_94223 (h0 : topological_space (comm_group (comm_group (has_neg_part pos)))) : regular_space (comm_group (comm_group (has_neg_part pos))) := sorry --non-trivial
lemma new_lemma_94224 (h0 : topological_space (has_neg (ring Type))) : totally_separated_space (has_neg (ring Type)) := sorry --non-trivial
lemma new_lemma_94225 (h0 : topological_space (normed_comm_ring unsigned)) : totally_disconnected_space (normed_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_94226 (h0 : group (distrib char)) : group.fg (distrib char) := sorry --non-trivial
lemma new_lemma_94227 (h0 : cancel_comm_monoid_with_zero (generalized_boolean_algebra (has_Inf linarith.comp))) : unique_factorization_monoid (generalized_boolean_algebra (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_94228 (h0 : uniform_space (mul_zero_class (has_add pos))) : separated_space (mul_zero_class (has_add pos)) := sorry --non-trivial
lemma new_lemma_94229 (h0 : topological_space (has_to_string (has_add ennreal))) : t1_space (has_to_string (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_94230 (h0 : topological_space (cancel_monoid name)) : irreducible_space (cancel_monoid name) := sorry --non-trivial
lemma new_lemma_94231 (h0 : uniform_space (id linarith.comp_source)) (h1 : group (id linarith.comp_source)) : uniform_group (id linarith.comp_source) := sorry --non-trivial
lemma new_lemma_94232 (h0 : ordered_add_comm_monoid (boolean_algebra.core name)) : archimedean (boolean_algebra.core name) := sorry --non-trivial
lemma new_lemma_94233 (h0 : ring (has_top (semiring num))) : is_domain (has_top (semiring num)) := sorry --non-trivial
lemma new_lemma_94234 (h0 : has_mem.mem Type has_emptyc.emptyc) : @t0_space.{1} Type (@finset.pi.empty.{2 1} (Type 1) topological_space.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_94235 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_zero pos)) := sorry --non-trivial
lemma new_lemma_94236 (h0 : not (add_group (left_cancel_semigroup congr_arg_kind) -> false)) : @is_add_cyclic.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_group.{0} (left_cancel_semigroup.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_94237 (h0 : ring (has_Inf (has_Inf (ordered_ring (has_add (has_Inf linarith.comp)))))) : is_principal_ideal_ring (has_Inf (has_Inf (ordered_ring (has_add (has_Inf linarith.comp))))) := sorry --non-trivial
lemma new_lemma_94238 (h1 : not (uniform_space (topological_space string_imp) -> false)) : @complete_space.{0} (topological_space.{0} string_imp) (@classical.by_contradiction'.{1} (uniform_space.{0} (topological_space.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_94239 (h0 : ring (has_pos_part (has_pos_part (has_pos_part (has_nndist pos))))) : is_domain (has_pos_part (has_pos_part (has_pos_part (has_nndist pos)))) := sorry --non-trivial
lemma new_lemma_94240 (h0 : topological_space nnreal) : normal_space nnreal := sorry --non-trivial
lemma new_lemma_94241 (h0 : filter (finset (boolean_algebra (has_to_string linarith.comp)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_94242 (h1 : ring (semi_normed_comm_ring reducibility_hints)) : is_domain (semi_normed_comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_94243 (h0 : complete_lattice (ordered_ring congr_arg_kind)) : is_atomistic (ordered_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_94244 (h0 : topological_space (monoid (option (option num)))) : t0_space (monoid (option (option num))) := sorry --non-trivial
lemma new_lemma_94245 (h0 : ring (has_nndist (ring linarith.comp))) : is_domain (has_nndist (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_94246 (h0 : not (uniform_space (has_norm linarith.comp) -> false)) : @complete_space.{0} (has_norm.{0} linarith.comp) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_norm.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_94247 (h0 : add_monoid (has_inter (option ennreal))) : add_monoid.fg (has_inter (option ennreal)) := sorry --non-trivial
lemma new_lemma_94248 (h0 : function.extfun Type (functor.comp topological_space has_neg_part)) : @loc_path_connected_space.{0} (has_neg_part.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_neg_part.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_94249 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_94250 (h0 : list (complete_distrib_lattice (has_add name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_94251 (h0 : topological_space (simple_graph num)) : t0_space (simple_graph num) := sorry --non-trivial
lemma new_lemma_94252 (h1 : topological_space (with_one (has_top num))) : totally_disconnected_space (with_one (has_top num)) := sorry --non-trivial
lemma new_lemma_94253 (h0 : function.extfun Type ring) : @rank_condition.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_94254 (h0 : cancel_comm_monoid_with_zero (simple_graph linarith.comp)) : unique_factorization_monoid (simple_graph linarith.comp) := sorry --non-trivial
lemma new_lemma_94255 (h0 : fin has_zero.zero) : @path_connected_space.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_94256 (h1 : group (measurable_space string_imp)) : normalizer_condition (measurable_space string_imp) := sorry --non-trivial
lemma new_lemma_94257 (h0 : list (left_cancel_monoid unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_94258 (h0 : ring (ring num)) : strong_rank_condition (ring num) := sorry --non-trivial
lemma new_lemma_94259 (h0 : has_mem.mem (has_norm num) has_emptyc.emptyc) : filter.ne_bot (finset.pi.empty filter (has_norm num) h0) := sorry --non-trivial
lemma new_lemma_94260 (h0 : function.extfun (Type 1) (functor.comp ring has_neg_part)) : @rank_condition.{1} (has_neg_part.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} has_neg_part.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} ring.{1} has_neg_part.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_94261 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_add_comm_group linarith.ineq))) : @is_add_cyclic.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type add_group.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_add_comm_group.{0} linarith.ineq)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_94262 (h0 : complete_lattice (mul_zero_class (semiring (semiring empty)))) : is_atomistic (mul_zero_class (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_94263 (h0 : function.extfun Type topological_space) : @t1_space.{0} (linear_ordered_comm_ring.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned)))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_ring.{0} (semiring.{0} (semiring.{0} (semiring.{0} unsigned)))))  := sorry --non-trivial
lemma new_lemma_94264 (h0 : group (linear_ordered_comm_monoid_with_zero num)) : group.fg (linear_ordered_comm_monoid_with_zero num) := sorry --non-trivial
lemma new_lemma_94265 (h0 : topological_space (has_star congr_arg_kind)) : totally_separated_space (has_star congr_arg_kind) := sorry --non-trivial
lemma new_lemma_94266 (h0 : ring (has_Inf (sub_neg_monoid real))) : is_domain (has_Inf (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_94267 (h0 : topological_space (add_cancel_monoid (boolean_algebra.core (has_neg_part Type)))) : totally_separated_space (add_cancel_monoid (boolean_algebra.core (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_94268 (h0 : topological_space (add_left_cancel_monoid fun_info)) : totally_disconnected_space (add_left_cancel_monoid fun_info) := sorry --non-trivial
lemma new_lemma_94269 (h0 : topological_space (has_to_string (has_neg linarith.comp))) : irreducible_space (has_to_string (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_94270 (h0 : topological_space (distrib_lattice (has_nnnorm (has_nnnorm fun_info)))) : path_connected_space (distrib_lattice (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_94271 (h0 : filter (has_add (has_to_string congr_arg_kind))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_94272 (h0 : functor.add_const (ring (finset Type)) linarith.comp) : @is_principal_ideal_ring.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (finset.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_94273 (h0 : not (topological_space char -> false)) : @t0_space.{0} char (@classical.by_contradiction'.{1} (topological_space.{0} char) h0)  := sorry --non-trivial
lemma new_lemma_94274 (h1 : monoid linarith.comp) : monoid.fg linarith.comp := sorry --non-trivial
lemma new_lemma_94275 (h0 : add_group (left_cancel_monoid unsigned)) : is_add_cyclic (left_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_94276 (h0 : Prop -> distrib linarith.comp) (h1 : coe_sort (set.range h0)) : set.range_splitting h0 h1 := sorry --non-trivial
lemma new_lemma_94277 (h0 : group (has_add (ring (ring pos)))) : group.fg (has_add (ring (ring pos))) := sorry --non-trivial
lemma new_lemma_94278 (h1 : add_group (add_monoid linarith.ineq)) : is_add_cyclic (add_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_94279 (h0 : not (topological_space (has_lt (random_gen (random_gen char))) -> false)) : @t0_space.{0} (has_lt.{0} (random_gen.{0} (random_gen.{0} char))) (@classical.by_contradiction'.{1} (topological_space.{0} (has_lt.{0} (random_gen.{0} (random_gen.{0} char)))) h0)  := sorry --non-trivial
lemma new_lemma_94280 (h0 : fin has_zero.zero) : @t0_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_94281 (h0 : has_neg num) (h1 : functor.add_const (measurable_space num) congr_arg_kind) : @has_measurable_neg.{0} num h0 (@functor.add_const.run.{0 0} (measurable_space.{0} num) congr_arg_kind h1)  := sorry --non-trivial
lemma new_lemma_94282 (h0 : add_group (has_star empty)) : is_add_cyclic (has_star empty) := sorry --non-trivial
lemma new_lemma_94283 (h0 : topological_space (normed_lattice_add_comm_group (has_add name))) : normal_space (normed_lattice_add_comm_group (has_add name)) := sorry --non-trivial
lemma new_lemma_94284 (h1 : add_group (dlist (comm_ring to_additive.value_type))) : is_add_cyclic (dlist (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_94285 (h0 : filter (has_to_string Type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_94286 (h0 : uniform_space (canonically_ordered_comm_semiring (normed_comm_ring Type))) : separated_space (canonically_ordered_comm_semiring (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_94287 (h0 : add_group (canonically_linear_ordered_monoid real)) : is_add_cyclic (canonically_linear_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_94288 (h0 : Prop -> linarith.comp_source) (h1 : function.surjective h0) (h2 : linarith.comp_source) : function.surj_inv h1 h2 := sorry --non-trivial
lemma new_lemma_94289 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_inter congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_94290 (h0 : group (pseudo_metric_space (option (option (option ennreal))))) : group.fg (pseudo_metric_space (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_94291 (h0 : group (random_gen (mul_one_class (mul_one_class (mul_one_class reducibility_hints))))) : is_cyclic (random_gen (mul_one_class (mul_one_class (mul_one_class reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_94292 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_94293 (h0 : ring (preorder fun_info)) : rank_condition (preorder fun_info) := sorry --non-trivial
lemma new_lemma_94294 (h0 : functor.add_const (list (has_add environment.implicit_infer_kind)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_94295 (h0 : function.extfun Type (functor.add_const (ring znum))) : @is_principal_ideal_ring.{0} znum (@functor.add_const.run.{0 0} (ring.{0} znum) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} znum)) h0 num))  := sorry --non-trivial
lemma new_lemma_94296 (h0 : ring (id (random_gen num))) : is_domain (id (random_gen num)) := sorry --non-trivial
lemma new_lemma_94297 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_94298 (h0 : finset (semigroup (has_Inf (has_pos_part linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_94299 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group empty))) : @add_monoid.fg.{0} (normed_group.{0} empty) (@finset.pi.empty.{1 0} Type add_monoid.{0} (normed_group.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_94300 (h0 : topological_space (ordered_comm_ring (has_add (has_Inf name)))) : sequential_space (ordered_comm_ring (has_add (has_Inf name))) := sorry --non-trivial
lemma new_lemma_94301 (h0 : functor.add_const (function.extfun (Type 1) ring) name) : @is_principal_ideal_ring.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) name h0) (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_94302 (h0 : group (normed_comm_ring unsigned)) : normalizer_condition (normed_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_94303 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) linarith.comp) : @has_exists_mul_of_le.{1} Type (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) linarith.comp h0) Type)  := sorry --non-trivial
lemma new_lemma_94304 (h0 : add_monoid (has_neg_part (has_add Type))) : add_monoid.fg (has_neg_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_94305 (h0 : functor.add_const (complete_lattice (ordered_comm_group empty)) (option unsigned)) : @is_compactly_generated.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_comm_group.{0} empty)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_94306 (h0 : not (ring (plift unsigned) -> false)) : @invariant_basis_number.{1} (plift.{1} unsigned) (@classical.by_contradiction'.{2} (ring.{1} (plift.{1} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_94307 (h0 : group (measurable_space (has_inv linarith.ineq))) : is_cyclic (measurable_space (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_94308 (h0 : topological_space (fintype to_additive.value_type)) : totally_disconnected_space (fintype to_additive.value_type) := sorry --non-trivial
lemma new_lemma_94309 (h0 : function.extfun Type group) : @is_simple_group.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_94310 (h0 : filter (metric_space (has_top empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_94311 (h0 : prod (with_one (has_inv fun_info)) (with_one (has_inv fun_info))) : set.diagonal (with_one (has_inv fun_info)) h0 := sorry --non-trivial
lemma new_lemma_94312 (h1 : group (has_ssubset (has_nnnorm char))) : is_cyclic (has_ssubset (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_94313 (h0 : ordered_comm_monoid (ordered_comm_monoid (ring (has_add (has_Inf (has_add pos)))))) : has_exists_mul_of_le (ordered_comm_monoid (ring (has_add (has_Inf (has_add pos))))) := sorry --non-trivial
lemma new_lemma_94314 (h0 : option (functor.add_const (finset (linear_ordered_comm_monoid_with_zero empty)) empty)) (h1 : functor.add_const (finset (linear_ordered_comm_monoid_with_zero empty)) empty) : finset.nonempty (functor.add_const.run (option.get_or_else h0 h1)) := sorry --non-trivial
lemma new_lemma_94315 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_94316 (h0 : uniform_space (cancel_monoid (option (option ennreal)))) : complete_space (cancel_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_94317 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_Inf linarith.comp)) name) : @unique_factorization_monoid.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_Inf.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_94318 (h0 : functor.add_const (group (has_zero pos)) linarith.comp) : @is_simple_group.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_94319 (h0 : functor.add_const (ring (add_comm_monoid pos)) linarith.comp) : @rank_condition.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_94320 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_norm.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_94321 (h0 : topological_space (is_R_or_C (option (option (option (option (has_edist (option unsigned)))))))) : irreducible_space (is_R_or_C (option (option (option (option (has_edist (option unsigned))))))) := sorry --non-trivial
lemma new_lemma_94322 (h0 : topological_space (semigroup pos)) : discrete_topology (semigroup pos) := sorry --non-trivial
lemma new_lemma_94323 (h0 : has_mem.mem (random_gen num) has_emptyc.emptyc) : @totally_separated_space.{0} (random_gen.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_94324 (h0 : ring (topological_space string_imp)) : is_domain (topological_space string_imp) := sorry --non-trivial
lemma new_lemma_94325 (h0 : finset (add_cancel_monoid congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_94326 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) pos) : @totally_disconnected_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_94327 (h0 : int) (h1 h2 : nat) : int.lt h0 (nat.gcd_a h1 h2) := sorry --non-trivial
lemma new_lemma_94328 (h0 : add_group (non_assoc_semiring unsigned)) : is_add_cyclic (non_assoc_semiring unsigned) := sorry --non-trivial
lemma new_lemma_94329 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_94330 (h0 : not (group (plift empty) -> false)) : @normalizer_condition.{1} (plift.{1} empty) (@classical.by_contradiction'.{2} (group.{1} (plift.{1} empty)) h0)  := sorry --non-trivial
lemma new_lemma_94331 (h0 : functor.add_const (ordered_comm_monoid (add_cancel_monoid linarith.comp)) (ring name)) : @has_exists_mul_of_le.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (add_cancel_monoid.{0} linarith.comp)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_94332 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_94333 (h0 : uniform_space (has_add (has_Inf name))) : complete_space (has_add (has_Inf name)) := sorry --non-trivial
lemma new_lemma_94334 (h0 : functor.add_const (ring (boolean_algebra linarith.comp)) linarith.comp) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_94335 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_94336 (h0 : complete_lattice (finset (has_Inf pos))) : complete_lattice.is_Sup_finite_compact (finset (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_94337 (h0 : functor.add_const (topological_space (left_cancel_monoid empty)) empty) : @path_connected_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_94338 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (monoid_with_zero pos)) := sorry --non-trivial
lemma new_lemma_94339 (h0 : topological_space (has_pos_part (has_Inf (has_Inf linarith.comp)))) : preirreducible_space (has_pos_part (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_94340 (h1 : prod (boolean_algebra.core std_gen) (boolean_algebra.core std_gen)) : set.diagonal (boolean_algebra.core std_gen) h1 := sorry --non-trivial
lemma new_lemma_94341 (h0 : ring (has_pos_part (ring linarith.comp))) : is_domain (has_pos_part (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_94342 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space linarith.comp_source))) : @totally_separated_space.{0} (measurable_space.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_94343 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_94344 (h0 : functor.comp topological_space has_neg Type) : @path_connected_space.{1} (has_neg.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_neg.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_94345 (h0 : topological_space (metric_space (has_top (has_top (has_top unsigned))))) : discrete_topology (metric_space (has_top (has_top (has_top unsigned)))) := sorry --non-trivial
lemma new_lemma_94346 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_94347 (h0 : filter (group_with_zero (option (option (option num))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_94348 (h0 : monoid (linear_ordered_comm_group (option (option unsigned)))) : monoid.fg (linear_ordered_comm_group (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_94349 (h0 : functor.add_const (topological_space (has_neg Type)) linarith.comp) : @sequential_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_94350 (h0 : functor.add_const (group (add_group num)) num) : @normalizer_condition.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (group.{0} (add_group.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_94351 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_94352 (h0 : list (finset (ring linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_94353 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_94354 (h0 : complete_lattice (complete_distrib_lattice congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (complete_distrib_lattice congr_arg_kind) := sorry --non-trivial
lemma new_lemma_94355 (h0 : topological_space (ordered_comm_ring (has_pos_part pos))) : regular_space (ordered_comm_ring (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_94356 (h0 : functor.add_const (group (non_assoc_semiring empty)) (option num)) : @is_cyclic.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (non_assoc_semiring.{0} empty)) (option.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_94357 (h0 : topological_space (comm_semigroup linarith.comp)) : locally_compact_space (comm_semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_94358 (h0 : topological_space (plift (option unsigned))) : locally_compact_space (plift (option unsigned)) := sorry --non-trivial
lemma new_lemma_94359 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (add_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (add_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_94360 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_94361 (h0 : functor.add_const (list (finset linarith.comp)) (semigroup linarith.comp)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_94362 (h0 : functor.add_const (fin has_zero.zero) Type) : @is_principal_ideal_ring.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (has_bot.{0} pos)) (@functor.add_const.run.{0 1} (fin (@has_zero.zero.{0} nat nat.has_zero)) Type h0))  := sorry --non-trivial
lemma new_lemma_94363 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (complete_distrib_lattice.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} num))  := sorry --non-trivial
lemma new_lemma_94364 (h0 : add_group (has_Sup (semiring unsigned))) : is_add_cyclic (has_Sup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_94365 (h0 : topological_space (add_comm_monoid (has_to_string ennreal))) : t1_space (add_comm_monoid (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_94366 (h0 : functor.add_const (list (ordered_comm_ring name)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_94367 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @locally_compact_space.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_94368 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) (has_neg pos)) : @totally_separated_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_94369 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_94370 (h0 : functor.add_const (add_monoid (add_cancel_monoid Type)) name) : @add_monoid.fg.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (add_cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_94371 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_94372 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_94373 (h0 : functor.add_const (finset (ring name)) (has_Inf (has_add (has_add (has_Inf (has_add Type)))))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_94374 (h0 : topological_space (canonically_ordered_comm_semiring num)) : t1_space (canonically_ordered_comm_semiring num) := sorry --non-trivial
lemma new_lemma_94375 (h0 : ring (id num)) : strong_rank_condition (id num) := sorry --non-trivial
lemma new_lemma_94376 (h0 : topological_space (has_neg_part unsigned)) : loc_path_connected_space (has_neg_part unsigned) := sorry --non-trivial
lemma new_lemma_94377 (h0 : topological_space (add_cancel_monoid (finset linarith.comp))) : topological_space.separable_space (add_cancel_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_94378 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_94379 (h1 : has_mem.mem (has_norm linarith.comp) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} linarith.comp) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_norm.{0} linarith.comp) h1)  := sorry --non-trivial
lemma new_lemma_94380 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} nnreal (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 nnreal)  := sorry --non-trivial
lemma new_lemma_94381 (h0 : functor.add_const (group (add_comm_monoid linarith.comp)) (ring linarith.comp)) : @group.fg.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} linarith.comp)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_94382 (h0 : function.extfun Type ring) : @is_domain.{0} pos (@function.extfun_app.{2 1} Type ring.{0} h0 pos)  := sorry --non-trivial
lemma new_lemma_94383 (h0 : add_group (has_ssubset (add_comm_semigroup environment.projection_info))) : is_add_cyclic (has_ssubset (add_comm_semigroup environment.projection_info)) := sorry --non-trivial
lemma new_lemma_94384 (h0 : topological_space (complete_linear_order empty)) : path_connected_space (complete_linear_order empty) := sorry --non-trivial
lemma new_lemma_94385 (h0 : functor.add_const (complete_lattice (has_nndist pos)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_nndist.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_94386 (h0 : topological_space (add_cancel_monoid congr_arg_kind)) : totally_disconnected_space (add_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_94387 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_94388 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_94389 (h0 : add_group (has_emptyc string_imp)) : is_add_cyclic (has_emptyc string_imp) := sorry --non-trivial
lemma new_lemma_94390 (h0 : functor.add_const (ring (cancel_monoid name)) Type) : @rank_condition.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_94391 (h0 : functor.comp monoid has_neg linarith.comp) : @monoid.fg.{0} (has_neg.{0} linarith.comp) (@functor.comp.run.{0 0 0} monoid.{0} has_neg.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_94392 (h0 : set (enat -> add_comm_semigroup (add_comm_semigroup (add_comm_semigroup std_gen)))) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_94393 (h0 : list (has_Inf (ring Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_94394 (h0 : functor.add_const (topological_space (has_pos_part Type)) pos) : @t0_space.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_pos_part.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_94395 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @t0_space.{0} (right_cancel_semigroup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (right_cancel_semigroup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_94396 (h0 : functor.add_const (topological_space (comm_semigroup real)) name) : @topological_space.separable_space.{0} (comm_semigroup.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_semigroup.{0} real)) name h0)  := sorry --non-trivial
lemma new_lemma_94397 (h0 : cancel_comm_monoid_with_zero (normed_comm_ring (ring (has_add (has_add Type))))) : unique_factorization_monoid (normed_comm_ring (ring (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_94398 (h0 : functor.add_const (group (finset environment.implicit_infer_kind)) (boolean_algebra pos)) : @is_cyclic.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} environment.implicit_infer_kind)) (boolean_algebra.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_94399 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (has_add.{0} pos) (@matrix.vec_empty.{0} (group.{0} (has_add.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))))))))  := sorry --non-trivial
lemma new_lemma_94400 (h0 : uniform_space (semigroup (boolean_algebra name))) : complete_space (semigroup (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_94401 (h0 : functor.add_const (topological_space (has_star num)) congr_arg_kind) : @totally_separated_space.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_94402 (h0 : ring (monoid (option (option empty)))) : is_domain (monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_94403 (h0 : function.extfun (multiset ((Type -> Type) -> Type 1)) (has_mem.mem (function.extfun Type))) : @irreducible_space.{0} (normed_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@multiset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@function.extfun_app.{3 0} (multiset.{2} ((Type → Type) → Type 1)) (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (multiset.{2} ((Type → Type) → Type 1)) (@multiset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type)) h0 (@has_zero.zero.{2} (multiset.{2} ((Type → Type) → Type 1)) (@multiset.has_zero.{2} ((Type → Type) → Type 1))))) topological_space.{0}) (normed_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_94404 (h2 : topological_space (distrib_lattice (has_nnnorm to_additive.value_type))) : totally_disconnected_space (distrib_lattice (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_94405 (h0 : functor.add_const (functor.add_const (uniform_space pos) pos) pos) : @complete_space.{0} pos (@functor.add_const.run.{0 0} (uniform_space.{0} pos) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (uniform_space.{0} pos) pos) pos h0))  := sorry --non-trivial
lemma new_lemma_94406 (h0 : monoid (with_one linarith.ineq)) : monoid.fg (with_one linarith.ineq) := sorry --non-trivial
lemma new_lemma_94407 (h0 : add_monoid (ordered_comm_monoid real)) : add_monoid.fg (ordered_comm_monoid real) := sorry --non-trivial
lemma new_lemma_94408 (h0 : functor.add_const (list (boolean_algebra name)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_94409 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_94410 (h0 : topological_space (normed_comm_ring (has_nndist (ring environment.implicit_infer_kind)))) : path_connected_space (normed_comm_ring (has_nndist (ring environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_94411 (h1 : functor.const Prop (nondiscrete_normed_field (normed_field linarith.ineq))) : functor.const.run h1 := sorry --non-trivial
lemma new_lemma_94412 (h0 : topological_space (has_Sup (option unsigned))) : t0_space (has_Sup (option unsigned)) := sorry --non-trivial
lemma new_lemma_94413 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (boolean_algebra.core congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_94414 (h0 : topological_space (normed_comm_ring (has_add (has_add (has_add name))))) : discrete_topology (normed_comm_ring (has_add (has_add (has_add name)))) := sorry --non-trivial
lemma new_lemma_94415 (h0 : group (distrib (has_ssubset linarith.comp_source))) : is_cyclic (distrib (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_94416 (h0 : topological_space (boolean_algebra.core (finset Type))) : discrete_topology (boolean_algebra.core (finset Type)) := sorry --non-trivial
lemma new_lemma_94417 (h0 : functor.add_const (add_group (ordered_comm_monoid Type)) (ring (ring (has_add pos)))) : @is_add_cyclic.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (ordered_comm_monoid.{1} Type)) (ring.{0} (ring.{0} (has_add.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_94418 (h0 : function.extfun Type (functor.comp ring normed_comm_ring)) : @strong_rank_condition.{0} (normed_comm_ring.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} normed_comm_ring.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} normed_comm_ring.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_94419 (h0 : functor.add_const (group (complete_distrib_lattice pos)) Type) : @group.fg.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (complete_distrib_lattice.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_94420 (h0 : has_mem.mem (random_gen empty) has_emptyc.emptyc) : @is_domain.{0} (random_gen.{0} empty) (@finset.pi.empty.{1 0} Type ring.{0} (random_gen.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_94421 (h0 : topological_space (canonically_ordered_comm_semiring (has_to_string (has_zero ennreal)))) : totally_disconnected_space (canonically_ordered_comm_semiring (has_to_string (has_zero ennreal))) := sorry --non-trivial
lemma new_lemma_94422 (h0 : ring (partial_order empty)) : rank_condition (partial_order empty) := sorry --non-trivial
lemma new_lemma_94423 (h0 : group (has_to_string (has_neg linarith.comp))) : normalizer_condition (has_to_string (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_94424 (h0 : functor.add_const (group (boolean_algebra Type)) name) : @is_cyclic.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (boolean_algebra.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_94425 (h0 : ordered_add_comm_monoid (has_to_string linarith.comp)) : archimedean (has_to_string linarith.comp) := sorry --non-trivial
lemma new_lemma_94426 (h0 : complete_lattice (distrib_lattice (random_gen (random_gen to_additive.value_type)))) : is_atomistic (distrib_lattice (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_94427 (h0 : ordered_comm_monoid (ordered_comm_ring (has_Inf (ordered_comm_ring (has_add pos))))) : has_exists_mul_of_le (ordered_comm_ring (has_Inf (ordered_comm_ring (has_add pos)))) := sorry --non-trivial
lemma new_lemma_94428 (h0 : topological_space (comm_semigroup (sub_neg_monoid (has_neg real)))) : totally_separated_space (comm_semigroup (sub_neg_monoid (has_neg real))) := sorry --non-trivial
lemma new_lemma_94429 (h0 : topological_space (sub_neg_monoid real)) : irreducible_space (sub_neg_monoid real) := sorry --non-trivial
lemma new_lemma_94430 (h0 : functor.comp complete_lattice comm_group Type) : @complete_lattice.is_Sup_finite_compact.{1} (comm_group.{1} Type) (@functor.comp.run.{1 1 1} complete_lattice.{1} comm_group.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_94431 (h0 : topological_space (has_Sup (semiring (semiring empty)))) : irreducible_space (has_Sup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_94432 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) environment.implicit_infer_kind) : @totally_disconnected_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_94433 (h0 : semiring (measure_theory.measure_space congr_arg_kind)) : is_noetherian_ring (measure_theory.measure_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_94434 (h0 : topological_space (has_pos_part (has_Inf (has_pos_part name)))) : sequential_space (has_pos_part (has_Inf (has_pos_part name))) := sorry --non-trivial
lemma new_lemma_94435 (h0 : function.extfun Type (functor.comp ordered_comm_monoid has_nndist)) : @has_exists_mul_of_le.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} has_nndist.{0} environment.implicit_infer_kind (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} has_nndist.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ordered_comm_monoid.{0} has_nndist.{0}) h0 environment.implicit_infer_kind))))  := sorry --non-trivial
lemma new_lemma_94436 (h0 : functor.add_const (topological_space (linear_ordered_field ennreal)) unsigned) : @path_connected_space.{0} (linear_ordered_field.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_94437 (h0 : group (has_union (has_union congr_arg_kind))) : normalizer_condition (has_union (has_union congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_94438 (h0 : cancel_comm_monoid_with_zero (measure_theory.measure_space (semiring empty))) : unique_factorization_monoid (measure_theory.measure_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_94439 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (with_one congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_94440 (h0 : ring (monoid_with_zero num)) : is_domain (monoid_with_zero num) := sorry --non-trivial
lemma new_lemma_94441 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (add_right_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_94442 (h0 : semiring (has_neg (ring pos))) : is_noetherian_ring (has_neg (ring pos)) := sorry --non-trivial
lemma new_lemma_94443 (h0 : topological_space (random_gen (has_one (has_norm empty)))) : discrete_topology (random_gen (has_one (has_norm empty))) := sorry --non-trivial
lemma new_lemma_94444 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_cyclic.{0} (comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_94445 (h0 : ordered_add_comm_monoid (finset (ring (has_neg linarith.comp)))) : archimedean (finset (ring (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_94446 (h0 : list (has_bot (ordered_comm_monoid (sub_neg_monoid Type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_94447 (h0 : not (complete_lattice (div_inv_monoid linarith.ineq) -> false)) : @is_compactly_generated.{0} (div_inv_monoid.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (div_inv_monoid.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_94448 (h0 : ring (has_one num)) : strong_rank_condition (has_one num) := sorry --non-trivial
lemma new_lemma_94449 (h0 : not (semiring (ordered_cancel_add_comm_monoid num) -> false)) : @is_noetherian_ring.{0} (ordered_cancel_add_comm_monoid.{0} num) (@classical.by_contradiction'.{1} (semiring.{0} (ordered_cancel_add_comm_monoid.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_94450 (h0 : topological_space (has_add (canonically_ordered_comm_semiring Type))) : sequential_space (has_add (canonically_ordered_comm_semiring Type)) := sorry --non-trivial
lemma new_lemma_94451 (h0 : function.extfun (Type 1) topological_space) : @preirreducible_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_94452 (h0 : function.extfun Type (functor.comp topological_space has_to_string)) : @normal_space.{0} (has_to_string.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_to_string.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_94453 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_94454 (h1 : ring (has_nnnorm string.iterator_imp)) : rank_condition (has_nnnorm string.iterator_imp) := sorry --non-trivial
lemma new_lemma_94455 (h0 : not (topological_space (add_right_cancel_monoid num) -> false)) : @discrete_topology.{0} (add_right_cancel_monoid.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (add_right_cancel_monoid.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_94456 (h0 : functor.add_const (list (boolean_algebra Type)) (has_neg (finset linarith.comp))) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_94457 (h0 : functor.add_const (group (simple_graph linarith.comp)) linarith.comp) : @is_cyclic.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (simple_graph.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_94458 (h0 : complete_lattice (plift (semiring (semiring unsigned)))) : complete_lattice.is_Sup_finite_compact (plift (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_94459 (h0 : functor.add_const (ring (ring linarith.comp)) (has_pos_part linarith.comp)) : @is_domain.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} linarith.comp)) (has_pos_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_94460 (h0 : measurable_space char) (h1 : has_sub char) : has_measurable_sub₂ char := sorry --non-trivial
lemma new_lemma_94461 (h0 : ring (denumerable (has_nnnorm (comm_ring reducibility_hints)))) : rank_condition (denumerable (has_nnnorm (comm_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_94462 (h0 : has_zero (ordered_cancel_add_comm_monoid ennreal) -> has_zero (ordered_cancel_add_comm_monoid ennreal) -> Prop) : reflexive h0 := sorry --non-trivial
lemma new_lemma_94463 (h0 : topological_space (boolean_algebra (has_add Type))) : t1_space (boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_94464 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) name) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_94465 (h0 : fin has_zero.zero) : @is_noetherian_ring.{1} Type (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) semiring.{1}) h0) Type)  := sorry --non-trivial
lemma new_lemma_94466 (h0 : topological_space (ordered_comm_monoid (ring Type))) : totally_disconnected_space (ordered_comm_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_94467 (h0 : finset (normed_comm_ring (mul_zero_class (option (option (option name)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_94468 (h0 : functor.add_const (uniform_space (add_comm_monoid Type)) name) : @separated_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (add_comm_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_94469 (h0 : functor.comp topological_space add_comm_monoid environment.implicit_infer_kind) : @locally_compact_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_94470 (h0 : complete_lattice (has_add (has_neg (measurable_space unsigned)))) : is_compactly_generated (has_add (has_neg (measurable_space unsigned))) := sorry --non-trivial
lemma new_lemma_94471 (h0 : topological_space (bin_tree (semiring (semiring (semiring num))))) : irreducible_space (bin_tree (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_94472 (h1 : function.extfun (multiset Type) (has_mem.mem (with_one num))) : @is_atomistic.{0} (with_one.{0} num) (@multiset.pi.empty.{1 0} Type complete_lattice.{0} (with_one.{0} num) (@function.extfun_app.{2 0} (multiset.{1} Type) (@has_mem.mem.{1 1} Type (multiset.{1} Type) (@multiset.has_mem.{1} Type) (with_one.{0} num)) h1 (@has_zero.zero.{1} (multiset.{1} Type) (@multiset.has_zero.{1} Type))))  := sorry --non-trivial
lemma new_lemma_94473 (h0 : has_mem.mem (semiring linarith.comp_source) has_emptyc.emptyc) : @is_atomistic.{0} (semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (semiring.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_94474 (h0 : topological_space (pseudo_metric_space congr_arg_kind)) : irreducible_space (pseudo_metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_94475 (h0 : functor.comp comm_ring boolean_algebra.core pos) : @local_ring.{0} (boolean_algebra.core.{0} pos) (@functor.comp.run.{0 0 0} comm_ring.{0} boolean_algebra.core.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_94476 (h0 : finset (has_neg (option ennreal))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_94477 (h0 : topological_space (comm_ring (has_inv (has_inv linarith.comp_source)))) : path_connected_space (comm_ring (has_inv (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_94478 (h1 : topological_space (with_one linarith.comp_source)) : totally_disconnected_space (with_one linarith.comp_source) := sorry --non-trivial
lemma new_lemma_94479 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_94480 (h0 : topological_space (boolean_algebra real)) : discrete_topology (boolean_algebra real) := sorry --non-trivial
lemma new_lemma_94481 (h0 : measurable_space (has_lt linarith.comp_source)) (h1 : set (has_lt linarith.comp_source)) : measurable_set h1 := sorry --non-trivial
lemma new_lemma_94482 (h0 : fin has_zero.zero) : @complete_space.{0} (finset.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_94483 (h0 : functor.add_const (topological_space (normed_lattice_add_comm_group linarith.comp)) (has_neg Type)) : @totally_separated_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_94484 (h0 : topological_space (comm_ring linarith.ineq)) (h1 : uniform_space (topological_space.opens (comm_ring linarith.ineq))) : complete_space (topological_space.opens (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_94485 (h0 : not (function.extfun Type complete_lattice -> false)) : complete_lattice.is_Sup_finite_compact (topological_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_94486 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_ssubset.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_ssubset.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_94487 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (complete_semilattice_Sup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_94488 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_94489 (h0 : functor.add_const (function.extfun Type finset) name) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (finset name)) := sorry --non-trivial
lemma new_lemma_94490 (h0 : mul_zero_class name -> mul_zero_class name -> Prop) : reflexive h0 := sorry --non-trivial
lemma new_lemma_94491 (h0 : topological_space (nondiscrete_normed_field std_gen)) : t0_space (nondiscrete_normed_field std_gen) := sorry --non-trivial
lemma new_lemma_94492 (h0 : functor.add_const (ring (has_neg environment.implicit_infer_kind)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_94493 (h0 : function.extfun Type ring) : @is_domain.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_94494 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_94495 (h0 : ring (with_one (has_norm empty))) : rank_condition (with_one (has_norm empty)) := sorry --non-trivial
lemma new_lemma_94496 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_94497 (h0 : topological_space (has_add unsigned)) : t0_space (has_add unsigned) := sorry --non-trivial
lemma new_lemma_94498 (h0 : add_group (normed_comm_ring (comm_group (has_neg_part (has_add Type))))) : is_add_cyclic (normed_comm_ring (comm_group (has_neg_part (has_add Type)))) := sorry --non-trivial
lemma new_lemma_94499 (h0 : topological_space (linear_ordered_semiring (has_norm empty))) : irreducible_space (linear_ordered_semiring (has_norm empty)) := sorry --non-trivial
lemma new_lemma_94500 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_94501 (h0 : not (ring (has_append linarith.ineq) -> false)) : @rank_condition.{0} (has_append.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (has_append.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_94502 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_inner.{0 0} unsigned congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inner.{0 0} unsigned congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_94503 (h0 : functor.add_const (monoid (semigroup name)) environment.implicit_infer_kind) : @monoid.fg.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (semigroup.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_94504 (h0 : list (linear_ordered_comm_monoid_with_zero num)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_94505 (h0 : ordered_add_comm_monoid (linear_ordered_field (option num))) : archimedean (linear_ordered_field (option num)) := sorry --non-trivial
lemma new_lemma_94506 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) (boolean_algebra name)) : @regular_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) (boolean_algebra.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_94507 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_94508 (h0 : functor.add_const (topological_space (has_pos_part Type)) (ring (has_nndist pos))) : @preirreducible_space.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_pos_part.{1} Type)) (ring.{0} (has_nndist.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_94509 (h0 : monoid (ordered_cancel_add_comm_monoid (option (option (option (option empty)))))) : monoid.fg (ordered_cancel_add_comm_monoid (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_94510 (h0 : topological_space (left_cancel_monoid (semiring (semiring (semiring empty))))) : t1_space (left_cancel_monoid (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_94511 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_94512 (h0 : functor.add_const (filter (add_left_cancel_semigroup empty)) num) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_94513 (h0 : function.extfun Type (functor.add_const (group pos))) : @is_cyclic.{0} pos (@functor.add_const.run.{0 0} (group.{0} pos) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} pos)) h0 pos))  := sorry --non-trivial
lemma new_lemma_94514 (h0 : topological_space (comm_group (finset linarith.comp))) : path_connected_space (comm_group (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_94515 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_94516 (h0 : ordered_comm_monoid (add_comm_monoid (has_add Type))) : has_exists_mul_of_le (add_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_94517 (h0 : semiring (has_add (option pos))) : is_noetherian_ring (has_add (option pos)) := sorry --non-trivial
lemma new_lemma_94518 (h0 : ordered_comm_monoid (add_cancel_monoid (ordered_ring pos))) : has_exists_mul_of_le (add_cancel_monoid (ordered_ring pos)) := sorry --non-trivial
lemma new_lemma_94519 (h0 : complete_lattice (boolean_algebra.core (has_add (option ennreal)))) : is_compactly_generated (boolean_algebra.core (has_add (option ennreal))) := sorry --non-trivial
lemma new_lemma_94520 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_domain.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_94521 (h0 : semiring (simple_graph unsigned)) : is_noetherian_ring (simple_graph unsigned) := sorry --non-trivial
lemma new_lemma_94522 (h0 : function.extfun Type group) : @is_cyclic.{0} (comm_ring.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (comm_ring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_94523 (h0 : ring (has_union (semiring num))) : is_domain (has_union (semiring num)) := sorry --non-trivial
lemma new_lemma_94524 (h0 : topological_space (has_neg (has_neg (measurable_space pos)))) : irreducible_space (has_neg (has_neg (measurable_space pos))) := sorry --non-trivial
lemma new_lemma_94525 (h0 : group (has_one (semiring num))) : normalizer_condition (has_one (semiring num)) := sorry --non-trivial
lemma new_lemma_94526 (h0 : complete_lattice (has_ssubset string.iterator_imp) -> Prop) (h1 : Exists (fun (x : complete_lattice (has_ssubset string.iterator_imp)), h0 x)) : @is_compactly_generated.{0} (has_ssubset.{0} string.iterator_imp) (@classical.some.{1} (complete_lattice.{0} (has_ssubset.{0} string.iterator_imp)) h0 h1)  := sorry --non-trivial
lemma new_lemma_94527 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring empty))) : @is_atomistic.{0} (linear_ordered_semiring.{0} empty) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_94528 (h0 : add_monoid (has_to_string (finset unsigned))) : add_monoid.fg (has_to_string (finset unsigned)) := sorry --non-trivial
lemma new_lemma_94529 (h0 : filter (has_norm (semiring num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_94530 (h0 : functor.add_const (topological_space (cancel_monoid pos)) congr_arg_kind) : @loc_path_connected_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} pos)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_94531 (h0 : group (bin_tree empty)) : group.fg (bin_tree empty) := sorry --non-trivial
lemma new_lemma_94532 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) name) : @locally_compact_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_94533 (h0 : topological_space (comm_group (has_to_string (has_to_string pos)))) : preconnected_space (comm_group (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_94534 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @path_connected_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_94535 (h0 : function.extfun nat fin) : @locally_compact_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_94536 (h1 : group linarith.ineq) : group.fg linarith.ineq := sorry --non-trivial
lemma new_lemma_94537 (h0 : topological_space (normed_linear_ordered_group (semiring (semiring empty)))) : t0_space (normed_linear_ordered_group (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_94538 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_94539 (h0 : functor.add_const (group (comm_group linarith.comp)) name) : @group.fg.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_94540 (h0 : topological_space name) : topological_space.separable_space name := sorry --non-trivial
lemma new_lemma_94541 (h0 : finset (complete_linear_order (semiring unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_94542 (h0 : ring (semiring (semiring congr_arg_kind))) : is_domain (semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_94543 (h0 : complete_lattice (monoid (complete_distrib_lattice (option unsigned)))) : complete_lattice.is_Sup_finite_compact (monoid (complete_distrib_lattice (option unsigned))) := sorry --non-trivial
lemma new_lemma_94544 (h0 : functor.add_const (topological_space (add_left_cancel_semigroup empty)) (option empty)) : @path_connected_space.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_94545 (h0 : functor.add_const (monoid (boolean_algebra.core environment.implicit_infer_kind)) name) : @monoid.fg.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_94546 (h0 : function.extfun Type ring) : @is_domain.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_94547 (h0 : topological_space (with_bot (has_norm fun_info))) : totally_disconnected_space (with_bot (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_94548 (h0 : filter (canonically_linear_ordered_monoid linarith.comp)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_94549 (h0 : topological_space (mul_zero_class (normed_comm_ring unsigned))) : normal_space (mul_zero_class (normed_comm_ring unsigned)) := sorry --non-trivial
lemma new_lemma_94550 (h0 : set (add_comm_semigroup enat -> fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_94551 (h9 : ring (distrib (has_nnnorm fun_info))) : rank_condition (distrib (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_94552 (h0 : list (finset (add_comm_monoid (has_add (has_add (finset pos)))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_94553 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) pos) : @normal_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_94554 (h0 : topological_space (normed_comm_ring Type)) : totally_disconnected_space (normed_comm_ring Type) := sorry --non-trivial
lemma new_lemma_94555 (h0 : ring (has_ssubset enat)) : rank_condition (has_ssubset enat) := sorry --non-trivial
lemma new_lemma_94556 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_94557 (h3 : list (with_bot string_imp)) : list.nodup h3 := sorry --non-trivial
lemma new_lemma_94558 (h0 : filter (distrib_lattice linarith.comp_source)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_94559 (h0 : topological_space (comm_semigroup (has_pos_part (has_pos_part linarith.comp)))) : t1_space (comm_semigroup (has_pos_part (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_94560 (h0 : topological_space (uniform_space (mul_one_class linarith.comp_source))) : totally_disconnected_space (uniform_space (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_94561 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_94562 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_94563 (h0 : cancel_comm_monoid_with_zero (pseudo_emetric_space name)) : unique_factorization_monoid (pseudo_emetric_space name) := sorry --non-trivial
lemma new_lemma_94564 (h0 : function.extfun Type group) : @group.fg.{0} (comm_ring.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (comm_ring.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_94565 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_94566 (h0 : functor.add_const (topological_space (finset linarith.comp)) Type) : @path_connected_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_94567 (h0 : not (ring (normed_group linarith.ineq) -> false)) : @rank_condition.{0} (normed_group.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (normed_group.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_94568 (h0 : add_monoid (linear_ordered_semiring num)) : add_monoid.fg (linear_ordered_semiring num) := sorry --non-trivial
lemma new_lemma_94569 (h0 : functor.add_const (function.extfun Type add_group) pos) : @is_add_cyclic.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) pos h0) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_94570 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_94571 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_94572 (h1 : complete_lattice (has_top string_imp)) : complete_lattice.is_Sup_finite_compact (has_top string_imp) := sorry --non-trivial
lemma new_lemma_94573 (h0 : group (normed_group (has_top (has_top (has_top (dlist (has_top (has_top linarith.ineq)))))))) : is_cyclic (normed_group (has_top (has_top (has_top (dlist (has_top (has_top linarith.ineq))))))) := sorry --non-trivial
lemma new_lemma_94574 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_94575 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_94576 (h0 : add_group (plift (semiring unsigned))) : is_add_cyclic (plift (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_94577 (h0 : functor.add_const (topological_space (semiring num)) empty) : @discrete_topology.{0} (semiring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_94578 (h0 : functor.add_const (complete_lattice (boolean_algebra.core Type)) (cancel_monoid name)) : @is_atomistic.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (boolean_algebra.core.{1} Type)) (cancel_monoid.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_94579 (h0 : complete_lattice (comm_semigroup (comm_semigroup pos))) : is_atomistic (comm_semigroup (comm_semigroup pos)) := sorry --non-trivial
lemma new_lemma_94580 (h0 : topological_space (has_norm (has_top (has_norm to_additive.value_type)))) : t0_space (has_norm (has_top (has_norm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_94581 (h1 : add_group (ordered_comm_ring (has_nnnorm (has_nnnorm char)))) : is_add_cyclic (ordered_comm_ring (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_94582 (h0 : topological_space (has_one (semiring (semiring congr_arg_kind)))) : totally_disconnected_space (has_one (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_94583 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_94584 (h0 : topological_space (has_nndist (has_Inf linarith.comp))) : preconnected_space (has_nndist (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_94585 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @sequential_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_94586 (h0 : finset (add_cancel_monoid (has_add (ring Type)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_94587 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_94588 (h4 : set environment.projection_info) : set.finite h4 := sorry --non-trivial
lemma new_lemma_94589 (h4 : complete_lattice (has_ssubset fun_info)) : complete_lattice.is_Sup_finite_compact (has_ssubset fun_info) := sorry --non-trivial
lemma new_lemma_94590 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (has_one.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (has_one.{0} num))  := sorry --non-trivial
lemma new_lemma_94591 (h2 : complete_lattice (has_compl string_imp)) : is_compactly_generated (has_compl string_imp) := sorry --non-trivial
lemma new_lemma_94592 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @discrete_topology.{0} (measurable_space.dynkin_system.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (measurable_space.dynkin_system.{0} empty))  := sorry --non-trivial
lemma new_lemma_94593 (h0 : functor.comp topological_space has_zero environment.implicit_infer_kind) : @path_connected_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_94594 (h0 : topological_space (sub_neg_monoid (has_neg pos))) : regular_space (sub_neg_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_94595 (h0 : topological_space (normed_lattice_add_comm_group Type)) : t0_space (normed_lattice_add_comm_group Type) := sorry --non-trivial
lemma new_lemma_94596 (h0 : function.extfun nat fin) : @monoid.fg.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (monoid.{0} (has_add.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_94597 (h0 : topological_space (metric_space linarith.comp_source)) : totally_disconnected_space (metric_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_94598 (h0 : not (monoid (has_one linarith.comp) -> false)) : @monoid.fg.{0} (has_one.{0} linarith.comp) (@classical.by_contradiction'.{1} (monoid.{0} (has_one.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_94599 (h0 : topological_space (semiring (random_gen to_additive.value_type))) : discrete_topology (semiring (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_94600 (h2 : pfun (add_comm_semigroup fun_info) Prop) (h3 : coe_sort (pfun.dom h2)) : pfun.as_subtype h2 h3 := sorry --non-trivial
lemma new_lemma_94601 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_94602 (h0 : topological_space (add_group (semiring unsigned))) : path_connected_space (add_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_94603 (h0 : topological_space (ring (has_Inf real))) : preirreducible_space (ring (has_Inf real)) := sorry --non-trivial
lemma new_lemma_94604 (h0 : add_group (nondiscrete_normed_field (nondiscrete_normed_field environment.projection_info))) : is_add_cyclic (nondiscrete_normed_field (nondiscrete_normed_field environment.projection_info)) := sorry --non-trivial
lemma new_lemma_94605 (h0 : complete_lattice (sub_neg_monoid Type)) : complete_lattice.is_Sup_finite_compact (sub_neg_monoid Type) := sorry --non-trivial
lemma new_lemma_94606 (h0 : measurable_space (simple_graph reducibility_hints)) (h1 : filter (simple_graph reducibility_hints)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_94607 (h0 : group (ordered_cancel_add_comm_monoid (option empty))) : is_cyclic (ordered_cancel_add_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_94608 (h0 : ring (random_gen (has_inv to_additive.value_type))) : rank_condition (random_gen (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_94609 (h0 : ring (mul_one_class (mul_one_class (metric_space to_additive.value_type)))) : strong_rank_condition (mul_one_class (mul_one_class (metric_space to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_94610 (h0 : functor.add_const (ring (ring environment.implicit_infer_kind)) (finset (ring pos))) : @rank_condition.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} environment.implicit_infer_kind)) (finset.{0} (ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_94611 (h0 : ring (canonically_ordered_monoid (has_add Type))) : is_domain (canonically_ordered_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_94612 (h0 : topological_space (has_neg (finset name))) : totally_disconnected_space (has_neg (finset name)) := sorry --non-trivial
lemma new_lemma_94613 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_monoid linarith.comp)) : unique_factorization_monoid (canonically_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_94614 (h0 : add_monoid (generalized_boolean_algebra (has_add (finset (finset linarith.comp))))) : add_monoid.fg (generalized_boolean_algebra (has_add (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_94615 (h0 : not (complete_lattice (semi_normed_comm_ring linarith.comp_source) -> false)) : @is_compactly_generated.{0} (semi_normed_comm_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semi_normed_comm_ring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_94616 (h0 : topological_space (cancel_monoid (add_cancel_monoid Type))) : locally_compact_space (cancel_monoid (add_cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_94617 (h0 : functor.add_const (uniform_space (complete_distrib_lattice Type)) linarith.comp) : @separated_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (complete_distrib_lattice.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_94618 (h0 : function.extfun Type group) : @group.fg.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_94619 (h0 : functor.add_const (add_group (ordered_ring unsigned)) empty) : @is_add_cyclic.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (ordered_ring.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_94620 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @normal_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_94621 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (generalized_boolean_algebra.{0} (has_add.{0} name)) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (generalized_boolean_algebra.{0} (has_add.{0} name)))  := sorry --non-trivial
lemma new_lemma_94622 (h0 : group (ordered_comm_monoid (has_neg name))) : is_cyclic (ordered_comm_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_94623 (h0 : topological_space (linear_ordered_comm_monoid_with_zero (option empty))) : totally_separated_space (linear_ordered_comm_monoid_with_zero (option empty)) := sorry --non-trivial
lemma new_lemma_94624 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_94625 (h0 : add_monoid linarith.ineq) (h1 : complete_lattice (has_le (add_action linarith.ineq fun_info))) : complete_lattice.is_Sup_finite_compact (has_le (add_action linarith.ineq fun_info)) := sorry --non-trivial
lemma new_lemma_94626 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_94627 (h1 : ring (semi_normed_ring linarith.comp_source)) : is_domain (semi_normed_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_94628 (h0 : not (topological_space (has_lt string.iterator_imp) -> false)) : @totally_disconnected_space.{0} (has_lt.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_lt.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_94629 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_94630 (h0 : ring (has_nndist (comm_group Type))) : is_domain (has_nndist (comm_group Type)) := sorry --non-trivial
lemma new_lemma_94631 (h0 : measurable_space (add_cancel_comm_monoid (random_gen to_additive.value_type))) (h1 h2 : measure_theory.measure (add_cancel_comm_monoid (random_gen to_additive.value_type))) : measure_theory.measure.absolutely_continuous h1 h2 := sorry --non-trivial
lemma new_lemma_94632 (h0 : complete_lattice (add_group empty)) : is_compactly_generated (add_group empty) := sorry --non-trivial
lemma new_lemma_94633 (h0 : group (has_zero (option name))) : group.fg (has_zero (option name)) := sorry --non-trivial
lemma new_lemma_94634 (h1 : filter (fintype (has_nnnorm (has_nnnorm char)))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_94635 (h0 : function.extfun Type topological_space) : @regular_space.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_94636 (h0 : add_group (non_unital_non_assoc_semiring (random_gen (random_gen char)))) : is_add_cyclic (non_unital_non_assoc_semiring (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_94637 (h0 : ordered_add_comm_monoid (monoid unsigned)) : archimedean (monoid unsigned) := sorry --non-trivial
lemma new_lemma_94638 (h0 : topological_space (comm_monoid empty)) (h1 : preorder (comm_monoid empty)) : order_closed_topology (comm_monoid empty) := sorry --non-trivial
lemma new_lemma_94639 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_94640 (h0 : topological_space (has_add (has_nnnorm (has_nnnorm linarith.ineq)))) : totally_disconnected_space (has_add (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_94641 (h0 : group (generalized_boolean_algebra (has_add (finset linarith.comp)))) : group.fg (generalized_boolean_algebra (has_add (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_94642 (h0 : ordered_add_comm_monoid (semigroup name)) : archimedean (semigroup name) := sorry --non-trivial
lemma new_lemma_94643 (h0 : filter (linear_ordered_add_comm_monoid char)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_94644 (h0 : has_mem.mem real.angle has_emptyc.emptyc) : filter.ne_bot (finset.pi.empty filter real.angle h0) := sorry --non-trivial
lemma new_lemma_94645 (h2 : ring (random_gen (random_gen (random_gen char)))) : rank_condition (random_gen (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_94646 (h0 : functor.add_const (topological_space environment.implicit_infer_kind) linarith.comp) : @t0_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (topological_space.{0} environment.implicit_infer_kind) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_94647 (h0 : has_mem.mem (normed_group empty) has_emptyc.emptyc) : @add_monoid.fg.{0} (normed_group.{0} empty) (@finset.pi.empty.{1 0} Type add_monoid.{0} (normed_group.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_94648 (h0 : uniform_space (normed_comm_ring (option (option empty)))) : separated_space (normed_comm_ring (option (option empty))) := sorry --non-trivial
lemma new_lemma_94649 (h0 : function.extfun Type (prod (uniform_space num))) : id_rel (function.extfun_app h0 (uniform_space num)) := sorry --non-trivial
lemma new_lemma_94650 (h0 : functor.add_const (ordered_comm_monoid (add_cancel_monoid environment.implicit_infer_kind)) pos) : @has_exists_mul_of_le.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_94651 (h0 : group (ring (ring name))) : is_simple_group (ring (ring name)) := sorry --non-trivial
lemma new_lemma_94652 (h0 : functor.add_const (filter (semigroup name)) (has_add pos)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_94653 (h0 : group (has_top (random_gen (random_gen string_imp)))) : normalizer_condition (has_top (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_94654 (h0 : filter (mul_zero_class (mul_zero_class pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_94655 (h7 : add_group (add_comm_semigroup linarith.ineq)) : is_add_cyclic (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_94656 (h0 : uniform_space (sub_neg_monoid (has_bot (has_bot real)))) : separated_space (sub_neg_monoid (has_bot (has_bot real))) := sorry --non-trivial
lemma new_lemma_94657 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_94658 (h0 : topological_space (linear_ordered_semiring (has_norm num))) : totally_separated_space (linear_ordered_semiring (has_norm num)) := sorry --non-trivial
lemma new_lemma_94659 (h0 : functor.add_const (add_group (finset Type)) name) : @is_add_cyclic.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (finset.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_94660 (h0 : has_lt (group ereal)) : no_max_order (group ereal) := sorry --non-trivial
lemma new_lemma_94661 (h0 : topological_space (ordered_comm_ring (has_Inf (has_neg name)))) : locally_compact_space (ordered_comm_ring (has_Inf (has_neg name))) := sorry --non-trivial
lemma new_lemma_94662 (h0 : functor.add_const (topological_space (finset pos)) pos) : @totally_separated_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_94663 (h0 : topological_space (has_add linarith.ineq)) : totally_disconnected_space (has_add linarith.ineq) := sorry --non-trivial
lemma new_lemma_94664 (h0 : functor.add_const (group (monoid empty)) unsigned) : @normalizer_condition.{0} (monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_94665 (h0 : topological_space (sub_neg_monoid (has_pos_part (finset pos)))) : totally_disconnected_space (sub_neg_monoid (has_pos_part (finset pos))) := sorry --non-trivial
lemma new_lemma_94666 (h0 : not (add_group (with_one empty) -> false)) : @is_add_cyclic.{0} (with_one.{0} empty) (@classical.by_contradiction'.{1} (add_group.{0} (with_one.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_94667 (h0 : functor.add_const (ordered_add_comm_monoid (pseudo_metric_space name)) (option name)) : @archimedean.{0} (pseudo_metric_space.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (pseudo_metric_space.{0} name)) (option.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_94668 (h0 : topological_space (finset (has_bot name))) : path_connected_space (finset (has_bot name)) := sorry --non-trivial
lemma new_lemma_94669 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) environment.implicit_infer_kind) : @irreducible_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_94670 (h0 : add_group (mul_zero_class (ring pos))) : is_add_cyclic (mul_zero_class (ring pos)) := sorry --non-trivial
lemma new_lemma_94671 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (is_R_or_C.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (is_R_or_C.{0} empty))  := sorry --non-trivial
lemma new_lemma_94672 (h0 : functor.add_const (uniform_space Type) pos) : @separated_space.{1} Type (@functor.add_const.run.{1 0} (uniform_space.{1} Type) pos h0)  := sorry --non-trivial
lemma new_lemma_94673 (h0 : ring (mul_zero_class (complete_distrib_lattice Type))) : rank_condition (mul_zero_class (complete_distrib_lattice Type)) := sorry --non-trivial
lemma new_lemma_94674 (h1 : ring (has_div std_gen)) : is_domain (has_div std_gen) := sorry --non-trivial
lemma new_lemma_94675 (h0 : functor.add_const (uniform_space (finset pos)) (has_pos_part (finset (has_Inf pos)))) : @complete_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (finset.{0} pos)) (has_pos_part.{0} (finset.{0} (has_Inf.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_94676 (h0 : function.extfun (Type 1) list) : palindrome (function.extfun_app h0 (ordered_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_94677 (h0 : function.extfun Type (functor.comp topological_space canonically_linear_ordered_monoid)) : @regular_space.{0} (canonically_linear_ordered_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_linear_ordered_monoid.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} canonically_linear_ordered_monoid.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_94678 (h0 : add_monoid (add_cancel_monoid (has_add (has_neg Type)))) : add_monoid.fg (add_cancel_monoid (has_add (has_neg Type))) := sorry --non-trivial
lemma new_lemma_94679 (h0 : functor.comp uniform_space boolean_algebra name) : @separated_space.{0} (boolean_algebra.{0} name) (@functor.comp.run.{0 0 0} uniform_space.{0} boolean_algebra.{0} name h0)  := sorry --non-trivial
lemma new_lemma_94680 (h0 : monoid (non_unital_non_assoc_semiring linarith.ineq)) (h1 : ring (star_monoid (non_unital_non_assoc_semiring linarith.ineq))) : strong_rank_condition (star_monoid (non_unital_non_assoc_semiring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_94681 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (with_zero.{0} linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (with_zero.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_94682 (h0 : complete_lattice (id linarith.comp)) : is_compactly_generated (id linarith.comp) := sorry --non-trivial
lemma new_lemma_94683 (h0 : functor.add_const (complete_lattice (has_add linarith.comp)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_add.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_94684 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) environment.implicit_infer_kind) : @locally_compact_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_94685 (h0 : functor.add_const (add_group (has_pos_part linarith.comp)) (has_neg pos)) : @is_add_cyclic.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (has_pos_part.{0} linarith.comp)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_94686 (h0 : topological_space (has_nnnorm (has_nnnorm to_additive.value_type))) : totally_disconnected_space (has_nnnorm (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_94687 (h0 : functor.add_const (add_group (has_nndist name)) name) : @is_add_cyclic.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (has_nndist.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_94688 (h0 : topological_space (topological_space (random_gen reducibility_hints))) : t0_space (topological_space (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_94689 (h0 : group (generalized_boolean_algebra (has_Inf pos))) : normalizer_condition (generalized_boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_94690 (h0 : ring (semigroup (ring pos))) : is_principal_ideal_ring (semigroup (ring pos)) := sorry --non-trivial
lemma new_lemma_94691 (h0 : has_mem.mem group has_emptyc.emptyc) : @normalizer_condition.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_94692 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_94693 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @totally_disconnected_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_94694 (h0 : topological_space (comm_group unsigned)) : regular_space (comm_group unsigned) := sorry --non-trivial
lemma new_lemma_94695 (h0 : complete_lattice (has_top (has_union unsigned))) : is_compactly_generated (has_top (has_union unsigned)) := sorry --non-trivial
lemma new_lemma_94696 (h0 : group (add_group linarith.comp)) : is_cyclic (add_group linarith.comp) := sorry --non-trivial
lemma new_lemma_94697 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_94698 (h0 : not (group (non_assoc_semiring empty) -> false)) : @is_cyclic.{0} (non_assoc_semiring.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (non_assoc_semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_94699 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_94700 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_94701 (h0 : topological_space (ring (option pos))) : t1_space (ring (option pos)) := sorry --non-trivial
lemma new_lemma_94702 (h0 : topological_space (comm_semigroup (has_pos_part Type))) : topological_space.separable_space (comm_semigroup (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_94703 (h0 : not (ring (semi_normed_ring (mul_one_class (uniform_space (mul_one_class char)))) -> false)) : @rank_condition.{0} (semi_normed_ring.{0} (mul_one_class.{0} (uniform_space.{0} (mul_one_class.{0} char)))) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_ring.{0} (mul_one_class.{0} (uniform_space.{0} (mul_one_class.{0} char))))) h0)  := sorry --non-trivial
lemma new_lemma_94704 (h0 : not (complete_lattice (complete_semilattice_Sup linarith.comp) -> false)) : @is_atomistic.{0} (complete_semilattice_Sup.{0} linarith.comp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (complete_semilattice_Sup.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_94705 (h0 : functor.add_const (list (comm_group name)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_94706 (h0 : topological_space (has_nnnorm (has_compl linarith.ineq))) : totally_disconnected_space (has_nnnorm (has_compl linarith.ineq)) := sorry --non-trivial
lemma new_lemma_94707 (h0 : filter (has_compl linarith.comp_source)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_94708 (h0 : function.extfun Type group) : @group.fg.{0} (linear_ordered_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_94709 (h0 : has_mem.mem add_group has_emptyc.emptyc) : @is_add_cyclic.{0} empty (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} h0) empty)  := sorry --non-trivial
lemma new_lemma_94710 (h0 : functor.add_const (filter (finset environment.implicit_infer_kind)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_94711 (h0 : ordered_comm_monoid (complete_distrib_lattice (has_add (has_neg real)))) : has_exists_mul_of_le (complete_distrib_lattice (has_add (has_neg real))) := sorry --non-trivial
lemma new_lemma_94712 (h0 : not (add_monoid (has_one congr_arg_kind) -> false)) : @add_monoid.fg.{0} (has_one.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_monoid.{0} (has_one.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_94713 (h0 : finset (has_neg_part (option (option name)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_94714 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} name (@function.extfun_app.{2 1} Type topological_space.{0} h0 name)  := sorry --non-trivial
lemma new_lemma_94715 (h0 : uniform_space (finset (normed_comm_ring linarith.comp))) : complete_space (finset (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_94716 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_94717 (h1 : uniform_space (mul_one_class string_imp)) : complete_space (mul_one_class string_imp) := sorry --non-trivial
lemma new_lemma_94718 (h0 : filter (with_one (complete_semilattice_Sup linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_94719 (h0 : complete_lattice (semi_normed_comm_ring linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (semi_normed_comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_94720 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (group_with_zero.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_94721 (h0 : group (canonically_linear_ordered_monoid linarith.comp)) : is_cyclic (canonically_linear_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_94722 (h0 : finset (add_cancel_monoid (has_add (boolean_algebra.core (has_add name))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_94723 (h1 : topological_space (linear_ordered_comm_group_with_zero string.iterator_imp)) : t0_space (linear_ordered_comm_group_with_zero string.iterator_imp) := sorry --non-trivial
lemma new_lemma_94724 (h0 : group (add_cancel_monoid (has_to_string (has_add name)))) : group.fg (add_cancel_monoid (has_to_string (has_add name))) := sorry --non-trivial
lemma new_lemma_94725 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_94726 (h0 : topological_space (bin_tree (semiring empty))) : irreducible_space (bin_tree (semiring empty)) := sorry --non-trivial
lemma new_lemma_94727 (h0 : ordered_comm_monoid (comm_group (cancel_monoid unsigned))) : has_exists_mul_of_le (comm_group (cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_94728 (h0 : complete_lattice (semigroup (normed_linear_ordered_group linarith.comp))) : is_compactly_generated (semigroup (normed_linear_ordered_group linarith.comp)) := sorry --non-trivial
lemma new_lemma_94729 (h0 : add_group (random_gen (has_inv linarith.comp_source))) : is_add_cyclic (random_gen (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_94730 (h0 : topological_space (has_Sup (semiring (semiring empty)))) : loc_path_connected_space (has_Sup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_94731 (h0 : topological_space (has_compl (has_nnnorm string_imp))) : path_connected_space (has_compl (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_94732 (h0 : add_monoid (normed_comm_ring (has_to_string (comm_group (has_to_string (comm_group Type)))))) : add_monoid.fg (normed_comm_ring (has_to_string (comm_group (has_to_string (comm_group Type))))) := sorry --non-trivial
lemma new_lemma_94733 (h0 : monoid (complete_semilattice_Sup (has_top fun_info))) : monoid.fg (complete_semilattice_Sup (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_94734 (h0 : functor.add_const (list (add_cancel_monoid pos)) (option pos)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_94735 (h0 : topological_space (normed_comm_ring environment.implicit_infer_kind)) : path_connected_space (normed_comm_ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_94736 (h0 : functor.add_const (topological_space (has_edist unsigned)) congr_arg_kind) : @totally_disconnected_space.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_94737 (h0 : functor.add_const (function.extfun Type topological_space) (mul_one_class (has_add pos))) : @preirreducible_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (mul_one_class.{0} (has_add.{0} pos)) h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_94738 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_94739 (h0 : add_group (has_neg environment.implicit_infer_kind)) : is_add_cyclic (has_neg environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_94740 (h0 : finset (cancel_monoid (mul_zero_class (option pos)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_94741 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (add_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_94742 (h0 : ordered_add_comm_monoid (has_dist ennreal)) : archimedean (has_dist ennreal) := sorry --non-trivial
lemma new_lemma_94743 (h0 : complete_lattice (with_one (semiring unsigned))) : is_compactly_generated (with_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_94744 (h0 : functor.add_const (topological_space (add_semigroup num)) num) : @locally_compact_space.{0} (add_semigroup.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (add_semigroup.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_94745 (h0 : function.extfun Type ring) : @is_domain.{0} (omega_complete_partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (omega_complete_partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_94746 (h0 : ordered_comm_monoid (has_neg_part (comm_group name))) : has_exists_mul_of_le (has_neg_part (comm_group name)) := sorry --non-trivial
lemma new_lemma_94747 (h0 : not (add_group (topological_space (random_gen linarith.comp_source)) -> false)) : @is_add_cyclic.{0} (topological_space.{0} (random_gen.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (add_group.{0} (topological_space.{0} (random_gen.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_94748 (h0 : ring (boolean_algebra (canonically_ordered_monoid real))) : strong_rank_condition (boolean_algebra (canonically_ordered_monoid real)) := sorry --non-trivial
lemma new_lemma_94749 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_94750 (h0 : topological_space (has_neg congr_arg_kind)) : preirreducible_space (has_neg congr_arg_kind) := sorry --non-trivial
lemma new_lemma_94751 (h0 : functor.add_const (complete_lattice (left_cancel_monoid unsigned)) empty) : @is_atomistic.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_94752 (h0 : functor.add_const (complete_lattice (monoid empty)) empty) : @is_compactly_generated.{0} (monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_94753 (h0 : group (distrib_lattice (has_nnnorm (has_nnnorm linarith.ineq)))) : is_cyclic (distrib_lattice (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_94754 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_atomistic.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_94755 (h2 : group (with_one (random_gen (random_gen string_imp)))) : group.fg (with_one (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_94756 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_nnnorm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nnnorm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_94757 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_94758 (h0 : group (has_Sup (has_Sup congr_arg_kind))) : group.fg (has_Sup (has_Sup congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_94759 (h0 : plift (has_sub empty) -> plift (has_sub empty) -> Prop) : is_refl (plift (has_sub empty)) h0 := sorry --non-trivial
lemma new_lemma_94760 (h1 : semiring (nondiscrete_normed_field (normed_field (mul_one_class (normed_field enat))))) (h3 : ideal (nondiscrete_normed_field (normed_field (mul_one_class (normed_field enat))))) : ideal.is_prime h3 := sorry --non-trivial
lemma new_lemma_94761 (h0 : topological_space (non_unital_non_assoc_semiring string.iterator_imp)) : totally_disconnected_space (non_unital_non_assoc_semiring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_94762 (h0 : ring (boolean_algebra (has_Inf (has_add (has_Inf Type))))) : strong_rank_condition (boolean_algebra (has_Inf (has_add (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_94763 (h0 : functor.add_const (list (has_add linarith.comp)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_94764 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) Type) : @archimedean.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) Type h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_94765 (h0 : function.extfun Type multiset) : multiset.nodup (function.extfun_app h0 (add_left_cancel_semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_94766 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_94767 (h1 : add_group (random_gen (random_gen linarith.ineq))) : is_add_cyclic (random_gen (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_94768 (h0 : has_mem.mem (has_norm linarith.comp) has_emptyc.emptyc) : @strong_rank_condition.{0} (has_norm.{0} linarith.comp) (@finset.pi.empty.{1 0} Type ring.{0} (has_norm.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_94769 (h0 : ring (ordered_comm_ring (has_add (ordered_comm_monoid real)))) : is_principal_ideal_ring (ordered_comm_ring (has_add (ordered_comm_monoid real))) := sorry --non-trivial
lemma new_lemma_94770 (h0 : monoid (generalized_boolean_algebra real)) : monoid.fg (generalized_boolean_algebra real) := sorry --non-trivial
lemma new_lemma_94771 (h0 : complete_lattice (has_bot (has_Inf linarith.comp))) : is_compactly_generated (has_bot (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_94772 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_94773 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_94774 (h0 : semiring (has_zero ennreal)) : is_noetherian_ring (has_zero ennreal) := sorry --non-trivial
lemma new_lemma_94775 (h0 : topological_space (has_one (semiring (semiring empty)))) : preirreducible_space (has_one (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_94776 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (linear_ordered_field num)) := sorry --non-trivial
lemma new_lemma_94777 (h0 : group (option (option (option pos)))) : is_cyclic (option (option (option pos))) := sorry --non-trivial
lemma new_lemma_94778 (h0 : not (topological_space (measurable_space.dynkin_system linarith.comp) -> false)) : @irreducible_space.{0} (measurable_space.dynkin_system.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.dynkin_system.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_94779 (h0 : topological_space (complete_distrib_lattice (option unsigned))) : discrete_topology (complete_distrib_lattice (option unsigned)) := sorry --non-trivial
lemma new_lemma_94780 (h0 : group (canonically_ordered_comm_semiring (finset linarith.comp))) : group.fg (canonically_ordered_comm_semiring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_94781 (h0 : functor.add_const (function.extfun (Type 1) finset) linarith.comp) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (ring Type)) := sorry --non-trivial
lemma new_lemma_94782 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_94783 (h0 : functor.add_const (topological_space (ordered_comm_group empty)) unsigned) : @id.{1} Prop (@locally_compact_space.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_group.{0} empty)) unsigned h0))  := sorry --non-trivial
lemma new_lemma_94784 (h0 : group (canonically_linear_ordered_monoid (has_add Type))) : is_cyclic (canonically_linear_ordered_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_94785 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} h0 (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_94786 (h3 : prod string.iterator_imp string.iterator_imp) : set.separates_points (id (fun (h0 : ereal -> std_gen), set.diagonal string.iterator_imp h3)) := sorry --non-trivial
lemma new_lemma_94787 (h0 : option pnat) (h1 : pnat) (h2 : list pnat) (h3 : pnat) (h4 : list pnat) : pnat.coprime (list.ilast' (option.get_or_else h0 h1) h2) (list.ilast' h3 h4) := sorry --non-trivial
lemma new_lemma_94788 (h1 : topological_space fun_info) (h2 : preorder fun_info) : order_topology fun_info := sorry --non-trivial
lemma new_lemma_94789 (h0 : functor.add_const (topological_space (has_Inf Type)) (ordered_ring (has_add (ring pos)))) : @normal_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_Inf.{1} Type)) (ordered_ring.{0} (has_add.{0} (ring.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_94790 (h0 : topological_space (nondiscrete_normed_field reducibility_hints)) (h1 : add_group (nondiscrete_normed_field reducibility_hints)) : topological_add_group (nondiscrete_normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_94791 (h0 : functor.add_const (complete_lattice (comm_group pos)) linarith.comp) : @is_compactly_generated.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_94792 (h0 : filter (distrib_lattice (has_nnnorm (has_nnnorm fun_info)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_94793 (h1 : topological_space (complete_semilattice_Sup linarith.comp_source)) : locally_compact_space (complete_semilattice_Sup linarith.comp_source) := sorry --non-trivial
lemma new_lemma_94794 (h0 : group (simple_graph (boolean_algebra.core linarith.comp))) : is_cyclic (simple_graph (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_94795 (h0 : uniform_space (linear_ordered_comm_ring (semiring empty))) : complete_space (linear_ordered_comm_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_94796 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (add_group.{0} (has_bot.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_94797 (h0 : monoid (canonically_ordered_monoid (comm_semigroup pos))) : monoid.fg (canonically_ordered_monoid (comm_semigroup pos)) := sorry --non-trivial
lemma new_lemma_94798 (h0 : ring (add_group linarith.comp)) : is_domain (add_group linarith.comp) := sorry --non-trivial
lemma new_lemma_94799 (h0 : functor.add_const (list (boolean_algebra name)) (has_add linarith.comp)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_94800 (h0 : function.extfun nat fin) : @t1_space.{0} (canonically_ordered_monoid.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_94801 (h0 : topological_space (add_cancel_monoid Type)) : regular_space (add_cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_94802 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system unsigned)) empty) : @preirreducible_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_94803 (h0 : topological_space (has_to_string name)) : totally_separated_space (has_to_string name) := sorry --non-trivial
lemma new_lemma_94804 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_94805 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (linear_ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_94806 (h0 : ring (has_bot (option (option (option empty))))) : rank_condition (has_bot (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_94807 (h0 : group (has_neg_part (finset (finset (finset name))))) : group.fg (has_neg_part (finset (finset (finset name)))) := sorry --non-trivial
lemma new_lemma_94808 (h0 : complete_lattice (comm_ring to_additive.value_type)) : is_compactly_generated (comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_94809 (h0 : function.extfun Type group) : @is_simple_group.{0} (boolean_algebra.core.{0} (ordered_comm_monoid.{0} linarith.comp)) (@function.extfun_app.{2 1} Type group.{0} h0 (boolean_algebra.core.{0} (ordered_comm_monoid.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_94810 (h0 : topological_space (has_top (semiring (semiring (semiring empty))))) : t0_space (has_top (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_94811 (h0 : topological_space (complete_distrib_lattice (has_add Type))) : irreducible_space (complete_distrib_lattice (has_add Type)) := sorry --non-trivial
lemma new_lemma_94812 (h0 : filter (comm_ring (random_gen fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_94813 (h0 : topological_space (has_nnnorm linarith.comp_source)) : path_connected_space (has_nnnorm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_94814 (h0 : add_group (normed_group (semiring (has_top linarith.ineq)))) : is_add_cyclic (normed_group (semiring (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_94815 (h0 : complete_lattice (has_add (has_to_string (finset pos)))) : complete_lattice.is_Sup_finite_compact (has_add (has_to_string (finset pos))) := sorry --non-trivial
lemma new_lemma_94816 (h0 : uniform_space (add_cancel_monoid (has_pos_part (finset linarith.comp)))) : complete_space (add_cancel_monoid (has_pos_part (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_94817 (h0 : topological_space (add_cancel_monoid Type)) : preconnected_space (add_cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_94818 (h0 : not (topological_space (complete_semilattice_Sup unsigned) -> false)) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_94819 (h0 : not (complete_lattice (fintype fun_info) -> false)) : @is_compactly_generated.{0} (fintype.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (fintype.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_94820 (h0 : fin has_zero.zero) : @sequential_space.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (boolean_algebra.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_94821 (h0 : plift (semiring empty) -> plift (semiring empty) -> Prop) : is_strict_order (plift (semiring empty)) h0 := sorry --non-trivial
lemma new_lemma_94822 (h0 : not (ring (simple_graph to_additive.value_type) -> false)) : @is_domain.{0} (simple_graph.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (simple_graph.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_94823 (h0 : cancel_comm_monoid_with_zero (generalized_boolean_algebra (has_add (has_nndist linarith.comp)))) : unique_factorization_monoid (generalized_boolean_algebra (has_add (has_nndist linarith.comp))) := sorry --non-trivial
lemma new_lemma_94824 (h0 : function.extfun Type ring) : @rank_condition.{0} (complete_semilattice_Sup.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_semilattice_Sup.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_94825 (h0 : complete_lattice (distrib_lattice (has_nnnorm fun_info))) : complete_lattice.is_Sup_finite_compact (distrib_lattice (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_94826 (h0 : topological_space (ring (boolean_algebra Type))) : t0_space (ring (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_94827 (h0 : functor.add_const (topological_space num) (semiring congr_arg_kind)) : @topological_space.separable_space.{0} num (@functor.add_const.run.{0 0} (topological_space.{0} num) (semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_94828 (h0 : monoid (linear_ordered_semiring empty)) : monoid.fg (linear_ordered_semiring empty) := sorry --non-trivial
lemma new_lemma_94829 (h0 : topological_space (finset (has_add name))) : path_connected_space (finset (has_add name)) := sorry --non-trivial
lemma new_lemma_94830 (h0 : ring (semigroup num)) : strong_rank_condition (semigroup num) := sorry --non-trivial
lemma new_lemma_94831 (h0 : topological_space (finset (has_neg environment.implicit_infer_kind))) : totally_disconnected_space (finset (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_94832 (h3 : not (monoid (with_one num) -> false)) : @monoid.fg.{0} (with_one.{0} num) (@classical.by_contradiction'.{1} (monoid.{0} (with_one.{0} num)) h3)  := sorry --non-trivial
lemma new_lemma_94833 (h0 : functor.add_const (topological_space (has_neg pos)) (has_to_string linarith.comp)) : @loc_path_connected_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) (has_to_string.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_94834 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_cancel_add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_94835 (h0 : group (comm_group (option ennreal))) : is_cyclic (comm_group (option ennreal)) := sorry --non-trivial
lemma new_lemma_94836 (h0 : ring (generalized_boolean_algebra (has_neg Type))) : rank_condition (generalized_boolean_algebra (has_neg Type)) := sorry --non-trivial
lemma new_lemma_94837 (h0 : complete_lattice (linear_ordered_comm_monoid_with_zero empty)) : is_compactly_generated (linear_ordered_comm_monoid_with_zero empty) := sorry --non-trivial
lemma new_lemma_94838 (h0 : has_mem.mem (has_top congr_arg_kind) has_emptyc.emptyc) : @discrete_topology.{0} (has_top.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_94839 (h0 : function.extfun Type (functor.comp topological_space has_nndist)) : @sequential_space.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_nndist.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_94840 (h0 : finset (has_add (has_add (has_to_string (has_add (comm_group (has_add pos))))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_94841 (h0 : filter (has_zero (has_to_string (has_to_string unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_94842 (h0 : functor.add_const (ring (normed_linear_ordered_group num)) empty) : @rank_condition.{0} (normed_linear_ordered_group.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (normed_linear_ordered_group.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_94843 (h0 : functor.add_const (topological_space (add_group num)) congr_arg_kind) : @normal_space.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_94844 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 real) := sorry --non-trivial
lemma new_lemma_94845 (h0 : functor.add_const (function.extfun Type add_monoid) linarith.comp) : @add_monoid.fg.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) linarith.comp h0) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_94846 (h0 : monoid (has_to_string (has_neg Type))) : monoid.fg (has_to_string (has_neg Type)) := sorry --non-trivial
lemma new_lemma_94847 (h0 : not (ring (add_right_cancel_monoid num) -> false)) : @strong_rank_condition.{0} (add_right_cancel_monoid.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (add_right_cancel_monoid.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_94848 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @regular_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_94849 (h0 : functor.add_const (filter (has_add environment.implicit_infer_kind)) environment.implicit_infer_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_94850 (h0 : topological_space (metric_space (has_norm (has_norm (semiring congr_arg_kind))))) : preirreducible_space (metric_space (has_norm (has_norm (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_94851 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_94852 (h0 : ring (free_add_monoid empty)) : rank_condition (free_add_monoid empty) := sorry --non-trivial
lemma new_lemma_94853 (h0 : topological_space (has_to_string (has_pos_part pos))) : preconnected_space (has_to_string (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_94854 (h0 : not (ring (has_div to_additive.value_type) -> false)) : @rank_condition.{0} (has_div.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (has_div.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_94855 (h0 : not (topological_space (denumerable (mul_one_class char)) -> false)) : @t0_space.{0} (denumerable.{0} (mul_one_class.{0} char)) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} (mul_one_class.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_94856 (h0 : has_mem.mem (has_top (random_gen (has_norm num))) has_emptyc.emptyc) : @is_domain.{0} (has_top.{0} (random_gen.{0} (has_norm.{0} num))) (@finset.pi.empty.{1 0} Type ring.{0} (has_top.{0} (random_gen.{0} (has_norm.{0} num))) h0)  := sorry --non-trivial
lemma new_lemma_94857 (h0 : topological_space (has_Sup (has_bot empty))) : t1_space (has_Sup (has_bot empty)) := sorry --non-trivial
lemma new_lemma_94858 (h0 : functor.add_const (topological_space (simple_graph unsigned)) num) : @loc_path_connected_space.{0} (simple_graph.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_94859 (h0 : semiring (has_dist (comm_monoid (comm_monoid (comm_monoid unsigned))))) : is_noetherian_ring (has_dist (comm_monoid (comm_monoid (comm_monoid unsigned)))) := sorry --non-trivial
lemma new_lemma_94860 (h0 : function.extfun Type (prod (comm_monoid empty))) : id_rel (function.extfun_app h0 (comm_monoid empty)) := sorry --non-trivial
lemma new_lemma_94861 (h0 : topological_space (add_comm_monoid (comm_group pos))) : totally_separated_space (add_comm_monoid (comm_group pos)) := sorry --non-trivial
lemma new_lemma_94862 (h0 : function.extfun Type (functor.add_const (ring Type))) : @is_principal_ideal_ring.{1} Type (@functor.add_const.run.{1 0} (ring.{1} Type) environment.implicit_infer_kind (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (ring.{1} Type)) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_94863 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_94864 (h0 : group (has_star (semiring (semiring (semiring (semiring num)))))) : normalizer_condition (has_star (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_94865 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_94866 (h0 : list (has_dist (option num))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_94867 (h0 : functor.add_const (group (has_add pos)) environment.implicit_infer_kind) : @group.fg.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_94868 (h1 : group (random_gen (random_gen char))) : is_cyclic (random_gen (random_gen char)) := sorry --non-trivial
lemma new_lemma_94869 (h0 : group (has_add (option ennreal))) : normalizer_condition (has_add (option ennreal)) := sorry --non-trivial
lemma new_lemma_94870 (h0 : topological_space (has_norm (random_gen linarith.ineq))) : path_connected_space (has_norm (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_94871 (h0 : add_group (has_top (semiring (semiring (semiring (with_bot linarith.comp)))))) : is_add_cyclic (has_top (semiring (semiring (semiring (with_bot linarith.comp))))) := sorry --non-trivial
lemma new_lemma_94872 (h0 : ring string) : is_domain string := sorry --non-trivial
lemma new_lemma_94873 (h0 : topological_space (has_nndist (has_neg linarith.comp))) : irreducible_space (has_nndist (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_94874 (h0 : topological_space (has_add (has_Inf (mul_one_class (has_pos_part linarith.comp))))) : irreducible_space (has_add (has_Inf (mul_one_class (has_pos_part linarith.comp)))) := sorry --non-trivial
lemma new_lemma_94875 (h0 : set (comm_ring environment.projection_info)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_94876 (h0 : ring (normed_field (random_gen (has_ssubset char)))) : is_domain (normed_field (random_gen (has_ssubset char))) := sorry --non-trivial
lemma new_lemma_94877 (h0 : topological_space (canonically_ordered_monoid Type)) : discrete_topology (canonically_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_94878 (h0 : pseudo_metric_space (option ennreal) -> pseudo_metric_space (option ennreal) -> Prop) : is_symm (pseudo_metric_space (option ennreal)) h0 := sorry --non-trivial
lemma new_lemma_94879 (h0 : functor.add_const (topological_space (boolean_algebra pos)) environment.implicit_infer_kind) : @normal_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_94880 (h0 : topological_space (ordered_comm_ring (sub_neg_monoid (sub_neg_monoid real)))) : t0_space (ordered_comm_ring (sub_neg_monoid (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_94881 (h0 : topological_space (add_cancel_monoid (has_add (boolean_algebra.core environment.implicit_infer_kind)))) : t1_space (add_cancel_monoid (has_add (boolean_algebra.core environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_94882 (h0 : topological_space (add_cancel_monoid (has_Inf (has_Inf (has_Inf (has_Inf (has_Inf Type))))))) : discrete_topology (add_cancel_monoid (has_Inf (has_Inf (has_Inf (has_Inf (has_Inf Type)))))) := sorry --non-trivial
lemma new_lemma_94883 (h1 : has_le (add_comm_semigroup nnreal)) (h2 : add_comm_semigroup nnreal) : is_bot h2 := sorry --non-trivial
lemma new_lemma_94884 (h0 : ordered_comm_monoid (linear_ordered_field ennreal)) : has_exists_mul_of_le (linear_ordered_field ennreal) := sorry --non-trivial
lemma new_lemma_94885 (h0 : fin has_zero.zero) : @normal_space.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_94886 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_94887 (h0 : functor.add_const (list (linear_ordered_comm_monoid_with_zero unsigned)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_94888 (h0 : functor.add_const (topological_space (semigroup pos)) name) : @t0_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_94889 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_94890 (h0 : measurable_space (has_lt std_gen)) (h1 : measure_theory.measure (has_lt std_gen)) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_94891 (h1 : topological_space (comm_ring to_additive.value_type)) : irreducible_space (comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_94892 (h0 : topological_space (add_group (semiring unsigned))) : discrete_topology (add_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_94893 (h0 : uniform_space (has_to_string (has_add (ring pos)))) : separated_space (has_to_string (has_add (ring pos))) := sorry --non-trivial
lemma new_lemma_94894 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_94895 (h0 : not (topological_space (random_gen unsigned) -> false)) : @path_connected_space.{0} (random_gen.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_94896 (h0 : group (add_left_cancel_semigroup num)) : normalizer_condition (add_left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_94897 (h0 : add_monoid (ordered_comm_group unsigned)) : add_monoid.fg (ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_94898 (h0 : topological_space (semigroup (option pos))) : locally_compact_space (semigroup (option pos)) := sorry --non-trivial
lemma new_lemma_94899 (h0 : complete_lattice (distrib_lattice (has_top linarith.ineq))) : is_atomistic (distrib_lattice (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_94900 (h0 : uniform_space (has_add pos)) : complete_space (has_add pos) := sorry --non-trivial
lemma new_lemma_94901 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_94902 (h0 : group (denumerable char)) : is_cyclic (denumerable char) := sorry --non-trivial
lemma new_lemma_94903 (h0 : complete_lattice (boolean_algebra (has_neg_part name))) : is_compactly_generated (boolean_algebra (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_94904 (h2 : uniform_space char) : complete_space char := sorry --non-trivial
lemma new_lemma_94905 (h0 : set (add_comm_semigroup (add_comm_semigroup ereal) -> add_comm_semigroup std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_94906 (h0 : not (topological_space (linear_ordered_comm_monoid_with_zero unsigned) -> false)) : @preirreducible_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_94907 (h2 : list (complete_semilattice_Sup linarith.ineq)) : list.nodup h2 := sorry --non-trivial
lemma new_lemma_94908 (h0 : group (has_pos_part real)) : is_simple_group (has_pos_part real) := sorry --non-trivial
lemma new_lemma_94909 (h0 : topological_space (has_pos_part (ring pos))) : locally_compact_space (has_pos_part (ring pos)) := sorry --non-trivial
lemma new_lemma_94910 (h0 : ring (has_neg (has_add name))) : strong_rank_condition (has_neg (has_add name)) := sorry --non-trivial
lemma new_lemma_94911 (h0 : filter (with_bot (has_norm linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_94912 (h0 : topological_space (id (random_gen linarith.comp))) : path_connected_space (id (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_94913 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) (boolean_algebra Type)) : @sequential_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (complete_distrib_lattice.{1} Type)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_94914 (h0 : topological_space (finset (finset (finset linarith.comp)))) : locally_compact_space (finset (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_94915 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg linarith.comp)) : @t0_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{0} linarith.comp) h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_94916 (h0 : functor.add_const (cancel_comm_monoid_with_zero (complete_distrib_lattice name)) pos) : @unique_factorization_monoid.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (complete_distrib_lattice.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_94917 (h0 : functor.add_const (topological_space (ring Type)) (has_add name)) : @preirreducible_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_94918 (h0 : ordered_comm_monoid (has_pos_part (has_add (finset (has_neg (has_add Type)))))) : has_exists_mul_of_le (has_pos_part (has_add (finset (has_neg (has_add Type))))) := sorry --non-trivial
lemma new_lemma_94919 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_94920 (h0 : fin has_zero.zero) : @complete_space.{0} (has_add.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_94921 (h0 : functor.add_const (add_group (semigroup pos)) (boolean_algebra.core (has_add (has_add name)))) : @is_add_cyclic.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} pos)) (boolean_algebra.core.{0} (has_add.{0} (has_add.{0} name))) h0)  := sorry --non-trivial
lemma new_lemma_94922 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_sub.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_sub.{0} num))  := sorry --non-trivial
lemma new_lemma_94923 (h0 : functor.add_const Prop (option (option empty))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_94924 (h0 : add_group (random_gen (random_gen (has_inv to_additive.value_type)))) : is_add_cyclic (random_gen (random_gen (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_94925 (h0 : ring linarith.comp) : strong_rank_condition linarith.comp := sorry --non-trivial
lemma new_lemma_94926 (h0 : topological_space (has_top (id (id (id (semiring (has_union congr_arg_kind))))))) : preirreducible_space (has_top (id (id (id (semiring (has_union congr_arg_kind)))))) := sorry --non-trivial
lemma new_lemma_94927 (h1 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_94928 (h0 : topological_space (linear_ordered_field (option empty))) : path_connected_space (linear_ordered_field (option empty)) := sorry --non-trivial
lemma new_lemma_94929 (h0 : ring (boolean_algebra.core (option (option (option ennreal))))) : is_principal_ideal_ring (boolean_algebra.core (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_94930 (h2 : monoid linarith.comp_source) : monoid.fg linarith.comp_source := sorry --non-trivial
lemma new_lemma_94931 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_94932 (h0 : topological_space (with_one empty)) : locally_compact_space (with_one empty) := sorry --non-trivial
lemma new_lemma_94933 (h0 : add_group (has_add (has_to_string name))) : is_add_cyclic (has_add (has_to_string name)) := sorry --non-trivial
lemma new_lemma_94934 (h0 : list (boolean_algebra (comm_group name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_94935 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) linarith.comp) : @totally_separated_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_94936 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (omega_complete_partial_order empty)) := sorry --non-trivial
lemma new_lemma_94937 (h0 : topological_space (monoid unsigned)) : discrete_topology (monoid unsigned) := sorry --non-trivial
lemma new_lemma_94938 (h0 : filter (normed_comm_ring environment.implicit_infer_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_94939 (h1 : complete_lattice (distrib (distrib (has_lt linarith.comp_source)))) : is_compactly_generated (distrib (distrib (has_lt linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_94940 (h0 : functor.add_const (group (has_add pos)) unsigned) : @is_cyclic.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_94941 (h0 : not (group (denumerable linarith.ineq) -> false)) : @is_cyclic.{0} (denumerable.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (denumerable.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_94942 (h0 : topological_space (has_nndist (option pos))) : path_connected_space (has_nndist (option pos)) := sorry --non-trivial
lemma new_lemma_94943 (h4 : ring (nondiscrete_normed_field string.iterator_imp)) : is_domain (nondiscrete_normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_94944 (h0 : ring (boolean_algebra.core (has_neg_part unsigned))) : rank_condition (boolean_algebra.core (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_94945 (h0 : function.extfun Type group) : @is_cyclic.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_lattice_add_comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_94946 (h0 : topological_space (has_bot Type)) : regular_space (has_bot Type) := sorry --non-trivial
lemma new_lemma_94947 (h0 : ring (free_add_monoid (semiring (semiring (semiring (semiring congr_arg_kind)))))) : rank_condition (free_add_monoid (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_94948 (h0 : ring (semigroup (has_neg_part pos))) : rank_condition (semigroup (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_94949 (h0 : Type) (h1 : list (parser (has_edist h0))) : palindrome h1 := sorry --non-trivial
lemma new_lemma_94950 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (normed_comm_ring unsigned)) := sorry --non-trivial
lemma new_lemma_94951 (h0 : topological_space (ordered_ring unsigned)) : locally_compact_space (ordered_ring unsigned) := sorry --non-trivial
lemma new_lemma_94952 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_94953 (h0 : functor.add_const (semiring (ring pos)) ennreal) (h1 : ring pos) : @odd.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (ring.{0} pos)) ennreal h0) h1  := sorry --non-trivial
lemma new_lemma_94954 (h0 : not (topological_space (has_union num) -> false)) : @t0_space.{0} (has_union.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_94955 (h0 : add_group (has_add (ring (ring pos)))) : is_add_cyclic (has_add (ring (ring pos))) := sorry --non-trivial
lemma new_lemma_94956 (h0 : topological_space (ordered_cancel_add_comm_monoid ennreal)) : locally_compact_space (ordered_cancel_add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_94957 (h0 : functor.add_const (uniform_space (has_nndist name)) linarith.comp) : @complete_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_nndist.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_94958 (h0 : topological_space (complete_distrib_lattice empty)) : loc_path_connected_space (complete_distrib_lattice empty) := sorry --non-trivial
lemma new_lemma_94959 (h0 : topological_space (linear_ordered_semiring congr_arg_kind)) : discrete_topology (linear_ordered_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_94960 (h0 : topological_space (mul_one_class char)) : totally_disconnected_space (mul_one_class char) := sorry --non-trivial
lemma new_lemma_94961 (h0 : group (distrib_lattice (random_gen (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))))) : group.fg (distrib_lattice (random_gen (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) := sorry --non-trivial
lemma new_lemma_94962 (h0 : monoid (has_zero (mul_one_class (has_add (mul_one_class Type))))) : monoid.fg (has_zero (mul_one_class (has_add (mul_one_class Type)))) := sorry --non-trivial
lemma new_lemma_94963 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (group_with_zero pos)) := sorry --non-trivial
lemma new_lemma_94964 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_94965 (h0 : has_to_string (option unsigned) -> has_to_string (option unsigned) -> Prop) : is_symm (has_to_string (option unsigned)) h0 := sorry --non-trivial
lemma new_lemma_94966 (h0 : semiring (complete_distrib_lattice (cancel_monoid pos))) : is_noetherian_ring (complete_distrib_lattice (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_94967 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_94968 (h0 : group (comm_semigroup (has_bot real))) : is_cyclic (comm_semigroup (has_bot real)) := sorry --non-trivial
lemma new_lemma_94969 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} fun_info (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) fun_info)  := sorry --non-trivial
lemma new_lemma_94970 (h0 : list (generalized_boolean_algebra (lattice pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_94971 (h0 : topological_space (ordered_comm_ring (has_Inf (ring Type)))) : normal_space (ordered_comm_ring (has_Inf (ring Type))) := sorry --non-trivial
lemma new_lemma_94972 (h0 : not (function.extfun (finset Type -> Prop) (function.extfun (finset Type)) -> false)) : @complete_space.{0} num (@finset.pi.empty.{1 0} Type uniform_space.{0} num (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type))) h0) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num)) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_94973 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (ring num)) := sorry --non-trivial
lemma new_lemma_94974 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_94975 (h0 : functor.add_const (function.extfun Type ring) (option (option (option name)))) : @strong_rank_condition.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (option.{0} (option.{0} (option.{0} name))) h0) (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_94976 (h0 : topological_space (random_gen (uniform_space (has_lt linarith.comp_source)))) : path_connected_space (random_gen (uniform_space (has_lt linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_94977 (h0 : cancel_comm_monoid_with_zero (mul_one_class fun_info)) (h1 : ring (gcd_monoid (mul_one_class fun_info))) : strong_rank_condition (gcd_monoid (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_94978 (h0 : functor.add_const (ring (add_cancel_monoid Type)) pos) : @strong_rank_condition.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (add_cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_94979 (h0 : functor.add_const (topological_space (linear_ordered_comm_monoid_with_zero unsigned)) num) : @locally_compact_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_94980 (h0 : complete_lattice (with_one (has_norm num))) : is_compactly_generated (with_one (has_norm num)) := sorry --non-trivial
lemma new_lemma_94981 (h0 : functor.add_const (group (has_edist empty)) congr_arg_kind) : @is_cyclic.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (has_edist.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_94982 (h0 : add_monoid (semigroup (has_nndist pos))) : add_monoid.fg (semigroup (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_94983 (h0 : topological_space (has_pos_part (has_neg (has_add Type)))) : irreducible_space (has_pos_part (has_neg (has_add Type))) := sorry --non-trivial
lemma new_lemma_94984 (h0 : function.extfun Type ring) : @is_domain.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_94985 (h0 : ordered_add_comm_monoid (boolean_algebra (add_comm_monoid Type))) : archimedean (boolean_algebra (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_94986 (h0 : list (comm_semigroup name)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_94987 (h1 : complete_lattice (random_gen (random_gen (random_gen string_imp)))) : is_compactly_generated (random_gen (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_94988 (h0 : list (normed_comm_ring (finset pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_94989 (h0 : functor.add_const (complete_lattice (bin_tree empty)) num) : @is_atomistic.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (bin_tree.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_94990 (h0 : topological_space (denumerable linarith.comp_source)) : path_connected_space (denumerable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_94991 (h0 : function.extfun (Type 1) cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} h0 (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_94992 (h0 : semiring (normed_lattice_add_comm_group (has_pos_part real))) : is_noetherian_ring (normed_lattice_add_comm_group (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_94993 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_94994 (h0 : functor.add_const (topological_space (has_neg pos)) (boolean_algebra Type)) : @t0_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} pos)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_94995 (h0 : functor.add_const (monoid (has_nndist Type)) linarith.comp) : @monoid.fg.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (has_nndist.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_94996 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_94997 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) linarith.comp) : @preconnected_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_94998 (h0 : topological_space (add_cancel_monoid (has_add environment.implicit_infer_kind))) : preirreducible_space (add_cancel_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_94999 (h0 : list (boolean_algebra (has_pos_part Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_95000 (h1 : set (semi_normed_comm_ring reducibility_hints)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_95001 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) Type) : @irreducible_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_95002 (h0 : not (complete_lattice (add_right_cancel_monoid congr_arg_kind) -> false)) : @is_compactly_generated.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (add_right_cancel_monoid.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_95003 (h0 : monoid (canonically_ordered_comm_semiring name)) : monoid.fg (canonically_ordered_comm_semiring name) := sorry --non-trivial
lemma new_lemma_95004 (h0 : add_monoid (has_nndist (mul_zero_class name))) : add_monoid.fg (has_nndist (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_95005 (h0 : list (has_neg_part Type)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_95006 (h0 : ordered_comm_monoid (canonically_linear_ordered_monoid Type)) : has_exists_mul_of_le (canonically_linear_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_95007 (h1 : not (topological_space (measurable_space congr_arg_kind) -> false)) : @discrete_topology.{0} (measurable_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} congr_arg_kind)) h1)  := sorry --non-trivial
lemma new_lemma_95008 (h0 : group (boolean_algebra.core (option ennreal))) : normalizer_condition (boolean_algebra.core (option ennreal)) := sorry --non-trivial
lemma new_lemma_95009 (h0 : function.extfun (Type 1) topological_space) : @loc_path_connected_space.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_95010 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @normal_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_95011 (h0 : topological_space (has_neg (has_neg (has_add (has_neg linarith.comp))))) : topological_space.separable_space (has_neg (has_neg (has_add (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_95012 (h0 : monoid (distrib_lattice string_imp)) : monoid.fg (distrib_lattice string_imp) := sorry --non-trivial
lemma new_lemma_95013 (h0 : ring (linear_ordered_semiring (has_top congr_arg_kind))) : strong_rank_condition (linear_ordered_semiring (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_95014 (h1 : topological_space (measurable_space (random_gen fun_info))) : t0_space (measurable_space (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_95015 (h0 : topological_space (preorder (semiring num))) : irreducible_space (preorder (semiring num)) := sorry --non-trivial
lemma new_lemma_95016 (h0 : topological_space (distrib (mul_one_class fun_info))) (h1 : add_group (distrib (mul_one_class fun_info))) : topological_add_group (distrib (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_95017 (h0 : function.extfun (Type -> Type) (function.extfun Type)) (h1 : has_mul (has_norm linarith.comp_source)) : @has_measurable_mul.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type measurable_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 measurable_space.{0}) (has_norm.{0} linarith.comp_source)) h1  := sorry --non-trivial
lemma new_lemma_95018 (h0 : ordered_comm_monoid (has_neg (boolean_algebra Type))) : has_exists_mul_of_le (has_neg (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_95019 (h0 : ring (add_cancel_comm_monoid empty)) : strong_rank_condition (add_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_95020 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (simple_graph.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (simple_graph.{0} empty))  := sorry --non-trivial
lemma new_lemma_95021 (h0 : functor.add_const (topological_space (bin_tree num)) empty) : @discrete_topology.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_95022 (h0 : topological_space (normed_comm_ring (finset environment.implicit_infer_kind))) : discrete_topology (normed_comm_ring (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_95023 (h0 : add_group (measurable_space (has_top num))) : is_add_cyclic (measurable_space (has_top num)) := sorry --non-trivial
lemma new_lemma_95024 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_inter unsigned)) := sorry --non-trivial
lemma new_lemma_95025 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_Sup num)) empty) : @unique_factorization_monoid.{0} (has_Sup.{0} num) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_Sup.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_95026 (h0 : ring (normed_group (random_gen fun_info))) : strong_rank_condition (normed_group (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_95027 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normal_space.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_95028 (h0 : functor.add_const (topological_space (has_add pos)) (has_zero (finset pos))) : @t0_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) (has_zero.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_95029 (h0 : complete_lattice (has_lt (has_lt linarith.comp_source))) : is_compactly_generated (has_lt (has_lt linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_95030 (h0 : not (ring (comm_ring reducibility_hints) -> false)) : @is_domain.{0} (comm_ring.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (comm_ring.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_95031 (h0 : ring (distrib (has_nnnorm (random_gen char)))) : is_domain (distrib (has_nnnorm (random_gen char))) := sorry --non-trivial
lemma new_lemma_95032 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (normed_linear_ordered_group.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_linear_ordered_group.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_95033 (h0 : function.extfun Type (functor.comp cancel_comm_monoid_with_zero has_neg_part)) : @unique_factorization_monoid.{0} (has_neg_part.{0} name) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} has_neg_part.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} cancel_comm_monoid_with_zero.{0} has_neg_part.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_95034 (h0 : finset (sub_neg_monoid (ordered_comm_monoid (has_Inf (has_Inf name))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_95035 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @locally_compact_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_95036 (h0 : ring (free_add_monoid num)) : is_domain (free_add_monoid num) := sorry --non-trivial
lemma new_lemma_95037 (h0 : monoid (has_norm (has_norm (has_one (random_gen (has_union (has_union linarith.comp))))))) : monoid.fg (has_norm (has_norm (has_one (random_gen (has_union (has_union linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_95038 (h0 : complete_lattice (left_cancel_monoid (semiring (semiring empty)))) : is_compactly_generated (left_cancel_monoid (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_95039 (h0 : uniform_space (distrib (denumerable fun_info))) : complete_space (distrib (denumerable fun_info)) := sorry --non-trivial
lemma new_lemma_95040 (h0 : topological_space (normed_field string.iterator_imp)) (h1 : preorder (normed_field string.iterator_imp)) : order_topology (normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_95041 (h0 : filter (has_zero (has_to_string (comm_group unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_95042 (h0 : prod (canonically_ordered_comm_semiring Type) (canonically_ordered_comm_semiring Type)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_95043 (h0 : add_monoid (ring (has_add environment.implicit_infer_kind))) : add_monoid.fg (ring (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_95044 (h0 : filter (has_top (has_norm (has_inv (random_gen fun_info))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_95045 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_95046 (h0 : with_bot (ordered_add_comm_monoid (bin_tree congr_arg_kind))) (h1 : ne h0 has_bot.bot) : @archimedean.{0} (bin_tree.{0} congr_arg_kind) (@with_bot.unbot.{0} (ordered_add_comm_monoid.{0} (bin_tree.{0} congr_arg_kind)) h0 h1)  := sorry --non-trivial
lemma new_lemma_95047 (h0 : uniform_space (linear_ordered_cancel_comm_monoid (option empty))) : complete_space (linear_ordered_cancel_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_95048 (h1 : group (complete_semilattice_Sup linarith.comp_source)) : group.fg (complete_semilattice_Sup linarith.comp_source) := sorry --non-trivial
lemma new_lemma_95049 (h0 : complete_lattice (complete_distrib_lattice (option ennreal))) : is_atomistic (complete_distrib_lattice (option ennreal)) := sorry --non-trivial
lemma new_lemma_95050 (h0 : function.extfun Type topological_space) : @regular_space.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_95051 (h0 : functor.add_const (prod auto.case_option auto.case_option) unsigned) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_95052 (h0 : functor.add_const (add_group (cancel_monoid name)) Type) : @is_add_cyclic.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (add_group.{0} (cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_95053 (h0 : semiring (has_inner (option empty) (option unsigned))) : is_noetherian_ring (has_inner (option empty) (option unsigned)) := sorry --non-trivial
lemma new_lemma_95054 (h0 : functor.add_const Prop (has_bot (has_add real))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_95055 (h0 : has_mem.mem (normed_group congr_arg_kind) has_emptyc.emptyc) : @strong_rank_condition.{0} (normed_group.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type ring.{0} (normed_group.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_95056 (h0 : add_monoid (finset (semigroup name))) : add_monoid.fg (finset (semigroup name)) := sorry --non-trivial
lemma new_lemma_95057 (h0 : group (has_to_string (option (option (option num))))) : normalizer_condition (has_to_string (option (option (option num)))) := sorry --non-trivial
lemma new_lemma_95058 (h1 : group (has_top char)) : is_cyclic (has_top char) := sorry --non-trivial
lemma new_lemma_95059 (h0 : functor.add_const (topological_space (add_comm_monoid environment.implicit_infer_kind)) pos) : @preconnected_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_95060 (h0 : topological_space (add_monoid linarith.ineq)) : path_connected_space (add_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_95061 (h0 : topological_space (has_add (has_Inf (has_add Type)))) : normal_space (has_add (has_Inf (has_add Type))) := sorry --non-trivial
lemma new_lemma_95062 (h0 : add_monoid (id (has_norm fun_info))) : add_monoid.fg (id (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_95063 (h0 : group (add_cancel_monoid (ring pos))) : normalizer_condition (add_cancel_monoid (ring pos)) := sorry --non-trivial
lemma new_lemma_95064 (h0 : group (add_group congr_arg_kind)) : group.fg (add_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_95065 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_95066 (h0 : uniform_space (random_gen (has_repr fun_info))) : separated_space (random_gen (has_repr fun_info)) := sorry --non-trivial
lemma new_lemma_95067 (h0 : cancel_comm_monoid_with_zero (normed_comm_ring (option (option (monoid_with_zero pos))))) : unique_factorization_monoid (normed_comm_ring (option (option (monoid_with_zero pos)))) := sorry --non-trivial
lemma new_lemma_95068 (h0 : functor.add_const (uniform_space (canonically_ordered_comm_semiring Type)) pos) : @complete_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (canonically_ordered_comm_semiring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_95069 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_95070 (h0 : topological_space (linear_ordered_comm_group ennreal)) : loc_path_connected_space (linear_ordered_comm_group ennreal) := sorry --non-trivial
lemma new_lemma_95071 (h1 : complete_lattice (topological_space (random_gen (random_gen char)))) : is_compactly_generated (topological_space (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_95072 (h0 : functor.add_const (ordered_add_comm_monoid (has_add pos)) (ring environment.implicit_infer_kind)) : @archimedean.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_add.{0} pos)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_95073 (h0 : add_group (has_top (has_top empty))) : is_add_cyclic (has_top (has_top empty)) := sorry --non-trivial
lemma new_lemma_95074 (h0 : functor.add_const (ring (has_neg_part Type)) (boolean_algebra pos)) : @is_principal_ideal_ring.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_neg_part.{1} Type)) (boolean_algebra.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_95075 (h0 : not (add_group (has_norm congr_arg_kind) -> false)) : @is_add_cyclic.{0} (has_norm.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_group.{0} (has_norm.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_95076 (h0 : group (bin_tree (semiring (semiring num)))) : group.fg (bin_tree (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_95077 (h0 : topological_space (has_add (has_neg (free_add_monoid name)))) : topological_space.separable_space (has_add (has_neg (free_add_monoid name))) := sorry --non-trivial
lemma new_lemma_95078 (h0 : cancel_comm_monoid_with_zero (has_to_string (finset pos))) : unique_factorization_monoid (has_to_string (finset pos)) := sorry --non-trivial
lemma new_lemma_95079 (h0 : not (complete_lattice (has_nnnorm to_additive.value_type) -> false)) : @is_compactly_generated.{0} (has_nnnorm.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_nnnorm.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_95080 (h0 : functor.add_const (group (ring unsigned)) environment.implicit_infer_kind) : @is_simple_group.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_95081 (h0 : ring (ring (has_to_string unsigned))) : rank_condition (ring (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_95082 (h1 : has_mem.mem (has_top num) has_emptyc.emptyc) : @add_monoid.fg.{0} (has_top.{0} num) (@finset.pi.empty.{1 0} Type add_monoid.{0} (has_top.{0} num) h1)  := sorry --non-trivial
lemma new_lemma_95083 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_95084 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_95085 (h0 : not (topological_space (encodable fun_info) -> false)) : @locally_compact_space.{0} (encodable.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (encodable.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_95086 (h1 : add_group (has_compl string_imp)) : is_add_cyclic (has_compl string_imp) := sorry --non-trivial
lemma new_lemma_95087 (h0 : topological_space (has_inter (option unsigned))) : totally_separated_space (has_inter (option unsigned)) := sorry --non-trivial
lemma new_lemma_95088 (h0 : uniform_space (semigroup (finset name))) : separated_space (semigroup (finset name)) := sorry --non-trivial
lemma new_lemma_95089 (h0 : functor.add_const (filter (generalized_boolean_algebra pos)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_95090 (h0 : functor.add_const (topological_space (ordered_comm_group unsigned)) unsigned) : @irreducible_space.{0} (ordered_comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_95091 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_principal_ideal_ring.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_95092 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type semiring.{0}) h0) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_95093 (h0 : functor.add_const (list (ordered_comm_ring linarith.comp)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_95094 (h0 : function.extfun (finset (nat -> Type)) (has_mem.mem fin)) : @irreducible_space.{0} (semiring.{0} linarith.ineq) (@matrix.vec_empty.{0} (topological_space.{0} (semiring.{0} linarith.ineq)) (@function.extfun_app.{1 1} nat fin (@finset.pi.empty.{1 0} (nat → Type) (function.extfun.{1 1} nat) fin (@function.extfun_app.{2 0} (finset.{1} (nat → Type)) (@has_mem.mem.{1 1} (nat → Type) (finset.{1} (nat → Type)) (@finset.has_mem.{1} (nat → Type)) fin) h0 (@has_emptyc.emptyc.{1} (finset.{1} (nat → Type)) (@finset.has_emptyc.{1} (nat → Type))))) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_95095 (h0 : ring (linear_order (option (option (option (option unsigned)))))) : is_domain (linear_order (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_95096 (h0 : filter (comm_group (comm_group (ring (add_left_cancel_monoid linarith.comp))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_95097 (h0 : add_group (has_norm (has_top congr_arg_kind))) : is_add_cyclic (has_norm (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_95098 (h0 : complete_lattice (boolean_algebra.core (has_neg linarith.comp))) : complete_lattice.is_Sup_finite_compact (boolean_algebra.core (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_95099 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @has_exists_mul_of_le.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ordered_comm_monoid.{1}) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_95100 (h0 : ring (boolean_algebra.core (finset (finset ennreal)))) : is_principal_ideal_ring (boolean_algebra.core (finset (finset ennreal))) := sorry --non-trivial
lemma new_lemma_95101 (h0 : function.extfun nat fin) : @is_add_cyclic.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (add_group.{0} (comm_semigroup.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_95102 (h0 : cancel_comm_monoid_with_zero auto.case_option) : unique_factorization_monoid auto.case_option := sorry --non-trivial
lemma new_lemma_95103 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @sequential_space.{0} (ordered_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_95104 (h0 : topological_space (has_add (has_pos_part pos))) : path_connected_space (has_add (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_95105 (h0 : functor.add_const (function.extfun (Type 1) add_monoid) (finset pos)) : @add_monoid.fg.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_monoid.{1}) (finset.{0} pos) h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_95106 (h0 : enat -> enat -> Prop) (h1 : filter enat) : filter.is_bounded h0 h1 := sorry --non-trivial
lemma new_lemma_95107 (h0 : ring (has_top (random_gen (random_gen fun_info)))) : is_domain (has_top (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_95108 (h0 : functor.add_const (complete_lattice (ordered_comm_monoid linarith.comp)) (has_add (has_add linarith.comp))) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_comm_monoid.{0} linarith.comp)) (has_add.{0} (has_add.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_95109 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (ordered_cancel_add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (ordered_cancel_add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_95110 (h1 : has_mem.mem (random_gen linarith.comp_source) has_emptyc.emptyc) : @path_connected_space.{0} (random_gen.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} linarith.comp_source) h1)  := sorry --non-trivial
lemma new_lemma_95111 (h0 : not (has_mem.mem (with_one name) has_emptyc.emptyc -> false)) : @is_atomistic.{0} (with_one.{0} name) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_one.{0} name) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} name) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_95112 (h0 : add_group (add_monoid linarith.comp_source)) : is_add_cyclic (add_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_95113 (h2 : topological_space (distrib fun_info)) : t0_space (distrib fun_info) := sorry --non-trivial
lemma new_lemma_95114 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_95115 (h0 : topological_space (has_neg_part (has_add (has_add Type)))) : irreducible_space (has_neg_part (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_95116 (h0 : functor.add_const (list (boolean_algebra unsigned)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_95117 (h1 : ring (topological_space (has_nnnorm string_imp))) : strong_rank_condition (topological_space (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_95118 (h0 : topological_space (has_zero (has_add name))) : regular_space (has_zero (has_add name)) := sorry --non-trivial
lemma new_lemma_95119 (h0 : topological_space (has_star (option (option (semiring unsigned))))) : totally_separated_space (has_star (option (option (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_95120 (h0 : topological_space (add_comm_monoid (finset ennreal))) : totally_disconnected_space (add_comm_monoid (finset ennreal)) := sorry --non-trivial
lemma new_lemma_95121 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @t0_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_95122 (h1 : topological_space (with_one congr_arg_kind)) : path_connected_space (with_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_95123 (h0 : topological_space (ordered_ring congr_arg_kind)) : t0_space (ordered_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_95124 (h0 : ring (measurable_space (has_norm linarith.ineq))) : is_domain (measurable_space (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_95125 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_95126 (h0 : ring (has_pos_part (has_pos_part (ring pos)))) : strong_rank_condition (has_pos_part (has_pos_part (ring pos))) := sorry --non-trivial
lemma new_lemma_95127 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) Type) : @preconnected_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_95128 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring unsigned)) name) : @sequential_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_95129 (h0 : semiring (sub_neg_monoid linarith.comp)) : is_noetherian_ring (sub_neg_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_95130 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_inter unsigned)) := sorry --non-trivial
lemma new_lemma_95131 (h0 : complete_lattice (id (has_norm congr_arg_kind))) : is_compactly_generated (id (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_95132 (h0 : topological_space (semiring (has_norm num))) : totally_disconnected_space (semiring (has_norm num)) := sorry --non-trivial
lemma new_lemma_95133 (h0 : topological_space (normed_group to_additive.value_type)) : t0_space (normed_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_95134 (h0 : finset (normed_comm_ring pos)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_95135 (h0 : add_monoid (has_scalar (has_add (has_add (has_add (has_add (has_add name))))) Type)) : add_monoid.fg (has_scalar (has_add (has_add (has_add (has_add (has_add name))))) Type) := sorry --non-trivial
lemma new_lemma_95136 (h1 : topological_space (has_compl (random_gen string_imp))) : totally_disconnected_space (has_compl (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_95137 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_95138 (h0 : group (has_star (semiring (semiring num)))) : group.fg (has_star (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_95139 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_dist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_dist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_95140 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) pos) : @loc_path_connected_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_95141 (h0 : functor.add_const (complete_lattice (has_star unsigned)) num) : @complete_lattice.is_Sup_finite_compact.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_star.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_95142 (h0 : add_monoid (has_pos_part (add_comm_monoid Type))) : add_monoid.fg (has_pos_part (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_95143 (h0 : set (linarith.ineq -> add_comm_semigroup ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_95144 (h0 : functor.add_const (finset (has_to_string unsigned)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_95145 (h0 : functor.add_const (semiring (has_Inf linarith.comp)) Type) : @is_noetherian_ring.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (semiring.{0} (has_Inf.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_95146 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_95147 (h1 : complete_lattice (with_one empty)) : is_atomistic (with_one empty) := sorry --non-trivial
lemma new_lemma_95148 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @path_connected_space.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_95149 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preconnected_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_95150 (h0 : monoid (add_comm_monoid linarith.comp)) : monoid.fg (add_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_95151 (h0 : add_monoid (linear_ordered_field (option empty))) : add_monoid.fg (linear_ordered_field (option empty)) := sorry --non-trivial
lemma new_lemma_95152 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_95153 (h0 : topological_space (has_top (measurable_space fun_info))) : locally_compact_space (has_top (measurable_space fun_info)) := sorry --non-trivial
lemma new_lemma_95154 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_95155 (h0 : monoid (semigroup ennreal)) : monoid.fg (semigroup ennreal) := sorry --non-trivial
lemma new_lemma_95156 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_atomistic.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) complete_lattice.{0}) (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_95157 (h0 : topological_space (mul_zero_class (has_to_string ennreal))) : irreducible_space (mul_zero_class (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_95158 (h0 : topological_space (distrib linarith.comp_source)) : path_connected_space (distrib linarith.comp_source) := sorry --non-trivial
lemma new_lemma_95159 (h0 : functor.add_const (add_monoid (complete_semilattice_Sup num)) congr_arg_kind) : @add_monoid.fg.{0} (complete_semilattice_Sup.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (complete_semilattice_Sup.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_95160 (h0 : functor.add_const (group (has_add linarith.comp)) linarith.comp) : @group.fg.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_95161 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_sub.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_sub.{0} num))  := sorry --non-trivial
lemma new_lemma_95162 (h0 : topological_space (has_add (ring (finset (has_add linarith.comp))))) : t0_space (has_add (ring (finset (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_95163 (h0 : filter (preorder congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_95164 (h0 : ring (boolean_algebra empty)) : strong_rank_condition (boolean_algebra empty) := sorry --non-trivial
lemma new_lemma_95165 (h0 : topological_space (has_Sup num)) : irreducible_space (has_Sup num) := sorry --non-trivial
lemma new_lemma_95166 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (normed_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_95167 (h0 : functor.add_const (group (add_cancel_monoid environment.implicit_infer_kind)) linarith.comp) : @is_simple_group.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_95168 (h0 : monoid (generalized_boolean_algebra (has_bot (has_bot (has_Inf real))))) : monoid.fg (generalized_boolean_algebra (has_bot (has_bot (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_95169 (h0 : functor.add_const (topological_space (semigroup ennreal)) (finset Type)) : @discrete_topology.{0} (semigroup.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} ennreal)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_95170 (h0 : not (group (normed_group empty) -> false)) : @is_cyclic.{0} (normed_group.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (normed_group.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_95171 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_95172 (h0 : topological_space (has_nndist (option empty))) : topological_space.separable_space (has_nndist (option empty)) := sorry --non-trivial
lemma new_lemma_95173 (h0 : topological_space (boolean_algebra (ring name))) : preconnected_space (boolean_algebra (ring name)) := sorry --non-trivial
lemma new_lemma_95174 (h0 : multiset (linear_ordered_semiring (random_gen congr_arg_kind))) : multiset.nodup h0 := sorry --non-trivial
lemma new_lemma_95175 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @discrete_topology.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_95176 (h0 : topological_space (has_inner empty unsigned)) : loc_path_connected_space (has_inner empty unsigned) := sorry --non-trivial
lemma new_lemma_95177 (h0 : functor.add_const (topological_space (boolean_algebra Type)) (has_neg pos)) : @discrete_topology.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_95178 (h0 : semiring (ring linarith.comp)) : is_noetherian_ring (ring linarith.comp) := sorry --non-trivial
lemma new_lemma_95179 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} h0 (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_95180 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @regular_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_95181 (h0 : ordered_add_comm_monoid (complete_distrib_lattice (ring (has_add linarith.comp)))) : archimedean (complete_distrib_lattice (ring (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_95182 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group fun_info))) : @is_add_cyclic.{0} (normed_group.{0} fun_info) (@finset.pi.empty.{1 0} Type add_group.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_95183 (h0 : group (simple_graph (option (option unsigned)))) : is_cyclic (simple_graph (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_95184 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) pos) : @irreducible_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_95185 (h0 : ring (add_cancel_monoid (finset (finset name)))) : is_principal_ideal_ring (add_cancel_monoid (finset (finset name))) := sorry --non-trivial
lemma new_lemma_95186 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_95187 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) Type) : @locally_compact_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_95188 (h0 : functor.add_const (topological_space (complete_distrib_lattice ennreal)) num) : @normal_space.{0} (complete_distrib_lattice.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_95189 (h0 : complete_lattice (has_bot unsigned)) : is_atomistic (has_bot unsigned) := sorry --non-trivial
lemma new_lemma_95190 (h0 : functor.add_const (group (option ennreal)) unsigned) : @group.fg.{0} (option.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (option.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_95191 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @t0_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_95192 (h0 : topological_space (ring (option empty))) : loc_path_connected_space (ring (option empty)) := sorry --non-trivial
lemma new_lemma_95193 (h0 : ordered_comm_monoid (has_Inf (finset (has_pos_part name)))) : has_exists_mul_of_le (has_Inf (finset (has_pos_part name))) := sorry --non-trivial
lemma new_lemma_95194 (h0 : topological_space (has_one (has_norm linarith.comp))) : irreducible_space (has_one (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_95195 (h0 : not (complete_lattice (add_cancel_comm_monoid string_imp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_comm_monoid.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (add_cancel_comm_monoid.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_95196 (h0 : monoid std_gen) (h1 : std_gen) : is_of_fin_order h1 := sorry --non-trivial
lemma new_lemma_95197 (h0 : function.extfun (Type 1) finset) : finset.nonempty (function.extfun_app h0 (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_95198 (h0 : topological_space (has_ssubset (has_nnnorm (has_nnnorm fun_info)))) : totally_disconnected_space (has_ssubset (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_95199 (h0 : topological_space (has_top (metric_space linarith.comp))) : locally_compact_space (has_top (metric_space linarith.comp)) := sorry --non-trivial
lemma new_lemma_95200 (h0 : complete_lattice (semigroup (option congr_arg_kind))) : is_atomistic (semigroup (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_95201 (h0 : group (has_inter empty)) : is_cyclic (has_inter empty) := sorry --non-trivial
lemma new_lemma_95202 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_95203 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (finset linarith.comp)) : @path_connected_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_95204 (h3 : ring (distrib empty)) : strong_rank_condition (distrib empty) := sorry --non-trivial
lemma new_lemma_95205 (h1 : topological_space (measurable_space (has_norm to_additive.value_type))) : discrete_topology (measurable_space (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_95206 (h0 : uniform_space (finset (has_Inf environment.implicit_infer_kind))) : complete_space (finset (has_Inf environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_95207 (h0 : complete_lattice (measurable_space fun_info)) : is_compactly_generated (measurable_space fun_info) := sorry --non-trivial
lemma new_lemma_95208 (h0 : list (monoid (option (option (option (option ennreal)))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_95209 (h0 : group (has_nnnorm (random_gen (mul_one_class to_additive.value_type)))) : is_cyclic (has_nnnorm (random_gen (mul_one_class to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_95210 (h0 : topological_space (ordered_comm_monoid (has_Inf (has_Inf (has_Inf linarith.comp))))) : discrete_topology (ordered_comm_monoid (has_Inf (has_Inf (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_95211 (h0 : filter (with_one (has_norm empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_95212 (h1 : uniform_space (encodable fun_info)) : complete_space (encodable fun_info) := sorry --non-trivial
lemma new_lemma_95213 (h1 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @path_connected_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h1) topological_space.{0}) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_95214 (h0 : has_to_string (comm_group Type) -> has_to_string (comm_group Type) -> Prop) : is_antisymm (has_to_string (comm_group Type)) h0 := sorry --non-trivial
lemma new_lemma_95215 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_95216 (h0 : uniform_space (denumerable (has_nnnorm fun_info))) : complete_space (denumerable (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_95217 (h0 : topological_space (has_nndist (add_comm_monoid pos))) : topological_space.separable_space (has_nndist (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_95218 (h0 : complete_lattice (measurable_space.dynkin_system empty)) : is_compactly_generated (measurable_space.dynkin_system empty) := sorry --non-trivial
lemma new_lemma_95219 (h0 : topological_space (emetric_space empty)) : topological_space.separable_space (emetric_space empty) := sorry --non-trivial
lemma new_lemma_95220 (h0 : function.extfun Type group) : @is_cyclic.{0} (measurable_space.{0} (semiring.{0} (semiring.{0} (semiring.{0} linarith.comp)))) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.{0} (semiring.{0} (semiring.{0} (semiring.{0} linarith.comp)))))  := sorry --non-trivial
lemma new_lemma_95221 (h0 : topological_space (has_le (mul_one_class ereal))) : path_connected_space (has_le (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_95222 (h0 : functor.add_const (semiring (non_assoc_semiring empty)) unsigned) : @is_noetherian_ring.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (non_assoc_semiring.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_95223 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) pos) : @locally_compact_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_95224 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_95225 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_95226 (h0 : topological_space (pseudo_metric_space ennreal)) : path_connected_space (pseudo_metric_space ennreal) := sorry --non-trivial
lemma new_lemma_95227 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) pos) : @archimedean.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) pos h0) (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_95228 (h0 : group (complete_semilattice_Sup (has_top to_additive.value_type))) : is_cyclic (complete_semilattice_Sup (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_95229 (h0 : ring (has_top (has_norm linarith.comp))) : rank_condition (has_top (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_95230 (h0 : not (function.extfun Type topological_space -> false)) : @topological_space.separable_space.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_95231 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (boolean_algebra unsigned)) := sorry --non-trivial
lemma new_lemma_95232 (h0 : topological_space (omega_complete_partial_order (option (option ennreal)))) : topological_space.separable_space (omega_complete_partial_order (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_95233 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_95234 (h0 : function.extfun Type (functor.add_const (finset (add_group congr_arg_kind)))) : finset.nonempty (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_95235 (h0 : monoid (with_bot (has_inv fun_info))) : monoid.fg (with_bot (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_95236 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_compactly_generated.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) complete_lattice.{0}) (linear_ordered_add_comm_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_95237 (h0 : complete_lattice (preorder (option empty))) : is_atomistic (preorder (option empty)) := sorry --non-trivial
lemma new_lemma_95238 (h0 : add_monoid (has_to_string (option (option (option (option unsigned)))))) : add_monoid.fg (has_to_string (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_95239 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (has_zero Type)) : @loc_path_connected_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} pos)) (has_zero.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_95240 (h1 : group (distrib_lattice to_additive.value_type)) : is_cyclic (distrib_lattice to_additive.value_type) := sorry --non-trivial
lemma new_lemma_95241 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_disconnected_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_95242 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @preirreducible_space.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_95243 (h0 : not (ring (add_right_cancel_monoid unsigned) -> false)) : @strong_rank_condition.{0} (add_right_cancel_monoid.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (add_right_cancel_monoid.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_95244 (h0 : not (topological_space (with_one num) -> false)) : @irreducible_space.{0} (with_one.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_95245 (h0 : complete_lattice (has_zero (has_zero pos))) : is_compactly_generated (has_zero (has_zero pos)) := sorry --non-trivial
lemma new_lemma_95246 (h0 : topological_space (simple_graph (has_neg name))) : discrete_topology (simple_graph (has_neg name)) := sorry --non-trivial
lemma new_lemma_95247 : nonempty nat := sorry --simp
lemma new_lemma_95248 (h0 : functor.add_const (ring empty) empty) : @rank_condition.{0} empty (@functor.add_const.run.{0 0} (ring.{0} empty) empty h0)  := sorry --non-trivial
lemma new_lemma_95249 (h0 : not (uniform_space (has_lt (mul_one_class reducibility_hints)) -> false)) : @complete_space.{0} (has_lt.{0} (mul_one_class.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_lt.{0} (mul_one_class.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_95250 (h0 : uniform_space (has_Sup (option (option (option (option empty)))))) : complete_space (has_Sup (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_95251 (h0 : list (has_emptyc (has_inv linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_95252 (h0 : functor.add_const (topological_space (has_to_string environment.implicit_infer_kind)) pos) : @totally_disconnected_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_95253 (h0 : filter (simple_graph Type)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_95254 (h0 : functor.add_const (function.extfun Type topological_space) (has_zero pos)) : @irreducible_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_zero.{0} pos) h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_95255 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group linarith.comp_source))) : @totally_disconnected_space.{0} (normed_group.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_95256 (h0 : complete_lattice (comm_group (has_add (has_add Type)))) : is_atomistic (comm_group (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_95257 (h0 : add_group (has_compl (mul_one_class enat))) : is_add_cyclic (has_compl (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_95258 (h0 : topological_space (semigroup (has_add (add_comm_monoid Type)))) : t1_space (semigroup (has_add (add_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_95259 (h0 : monoid (with_bot (random_gen (has_inv (has_inv linarith.comp_source))))) : monoid.fg (with_bot (random_gen (has_inv (has_inv linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_95260 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_95261 (h0 : complete_lattice (ring (has_add name))) : complete_lattice.is_Sup_finite_compact (ring (has_add name)) := sorry --non-trivial
lemma new_lemma_95262 (h0 : list (complete_distrib_lattice (ordered_ring (ordered_ring (has_Inf (has_pos_part pos)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_95263 (h0 : group (has_Inf linarith.comp)) : normalizer_condition (has_Inf linarith.comp) := sorry --non-trivial
lemma new_lemma_95264 (h0 : topological_space (boolean_algebra.core (option (option (option unsigned))))) : normal_space (boolean_algebra.core (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_95265 (h0 : group (linear_ordered_comm_monoid_with_zero (option unsigned))) : is_cyclic (linear_ordered_comm_monoid_with_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_95266 (h0 : functor.add_const (complete_lattice (ring pos)) name) : @is_compactly_generated.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_95267 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_95268 (h0 : function.extfun (finset Type) (has_mem.mem (has_inter linarith.comp_source))) : @irreducible_space.{0} (has_inter.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_inter.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_inter.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_95269 (h0 : functor.add_const (add_group (preorder congr_arg_kind)) empty) : @is_add_cyclic.{0} (preorder.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (add_group.{0} (preorder.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_95270 (h0 : functor.add_const (topological_space pos) unsigned) : @t0_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) unsigned h0)  := sorry --non-trivial
lemma new_lemma_95271 (h0 : add_monoid (has_nndist (option empty))) : add_monoid.fg (has_nndist (option empty)) := sorry --non-trivial
lemma new_lemma_95272 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) Type) : @totally_separated_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_95273 (h0 : topological_space (has_add (has_Inf Type))) : totally_disconnected_space (has_add (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_95274 (h0 : topological_space (cancel_monoid (has_nndist Type))) : loc_path_connected_space (cancel_monoid (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_95275 (h0 : add_group (add_cancel_comm_monoid (random_gen (has_nnnorm linarith.comp_source)))) : is_add_cyclic (add_cancel_comm_monoid (random_gen (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_95276 (h0 : topological_space (dlist znum)) : totally_disconnected_space (dlist znum) := sorry --non-trivial
lemma new_lemma_95277 (h0 : function.extfun Type topological_space) : @t0_space.{0} name (@function.extfun_app.{2 1} Type topological_space.{0} h0 name)  := sorry --non-trivial
lemma new_lemma_95278 (h0 : topological_space (linear_ordered_semiring (semiring empty))) : totally_disconnected_space (linear_ordered_semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_95279 (h0 : mul_zero_class (mul_zero_class num) -> mul_zero_class (mul_zero_class num) -> Prop) : is_strict_order (mul_zero_class (mul_zero_class num)) h0 := sorry --non-trivial
lemma new_lemma_95280 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_95281 (h0 : group (plift num)) : group.fg (plift num) := sorry --non-trivial
lemma new_lemma_95282 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) pos) : @t0_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_95283 (h0 : not (function.extfun Type cancel_comm_monoid_with_zero -> false)) : @unique_factorization_monoid.{0} (mul_zero_class.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) h0) (mul_zero_class.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_95284 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} empty (@function.extfun_app.{2 1} Type semiring.{0} h0 empty)  := sorry --non-trivial
lemma new_lemma_95285 (h0 : topological_space (random_gen (mul_one_class (random_gen string_imp)))) (h1 : preorder (random_gen (mul_one_class (random_gen string_imp)))) : order_topology (random_gen (mul_one_class (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_95286 (h0 : topological_space (linear_ordered_comm_group (option (option (option ennreal))))) : locally_compact_space (linear_ordered_comm_group (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_95287 (h0 : functor.add_const (topological_space (has_nndist pos)) pos) : @regular_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_95288 (h0 : group (finset (has_neg (finset (has_pos_part (has_pos_part (has_Inf Type))))))) : group.fg (finset (has_neg (finset (has_pos_part (has_pos_part (has_Inf Type)))))) := sorry --non-trivial
lemma new_lemma_95289 (h0 : filter (canonically_ordered_comm_semiring (has_add Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_95290 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (linear_ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_95291 (h0 : complete_lattice (preorder num)) : is_compactly_generated (preorder num) := sorry --non-trivial
lemma new_lemma_95292 (h0 : has_le (has_norm string_imp)) (h1 : bounded_order (has_norm string_imp)) : is_simple_order (has_norm string_imp) := sorry --non-trivial
lemma new_lemma_95293 (h1 : ring (add_comm_semigroup ereal)) : strong_rank_condition (add_comm_semigroup ereal) := sorry --non-trivial
lemma new_lemma_95294 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_95295 (h0 : topological_space (add_left_cancel_semigroup (add_left_cancel_semigroup unsigned))) : totally_disconnected_space (add_left_cancel_semigroup (add_left_cancel_semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_95296 (h0 : functor.add_const (group (complete_distrib_lattice name)) pos) : @is_cyclic.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_95297 (h0 : complete_lattice (has_Sup num)) : is_compactly_generated (has_Sup num) := sorry --non-trivial
lemma new_lemma_95298 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @monoid.fg.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 monoid.{1}) (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_95299 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_95300 (h0 : add_group (has_neg name)) : is_add_cyclic (has_neg name) := sorry --non-trivial
lemma new_lemma_95301 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (complete_linear_order.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (complete_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_95302 (h0 : topological_space (has_Inf (ring (has_neg pos)))) : sequential_space (has_Inf (ring (has_neg pos))) := sorry --non-trivial
lemma new_lemma_95303 (h0 : complete_lattice (has_nnnorm (random_gen linarith.ineq))) : is_compactly_generated (has_nnnorm (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_95304 (h0 : not (complete_lattice (add_monoid (comm_ring fun_info)) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (add_monoid.{0} (comm_ring.{0} fun_info)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (add_monoid.{0} (comm_ring.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_95305 (h0 : uniform_space (has_sub (semiring (semiring (semiring congr_arg_kind))))) : complete_space (has_sub (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_95306 (h2 : uniform_space (mul_one_class fun_info)) : complete_space (mul_one_class fun_info) := sorry --non-trivial
lemma new_lemma_95307 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_95308 (h0 : semiring (has_add (option (option pos)))) : is_noetherian_ring (has_add (option (option pos))) := sorry --non-trivial
lemma new_lemma_95309 (h0 : group (with_one (has_inv linarith.ineq))) : group.fg (with_one (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_95310 (h0 : functor.add_const (topological_space (left_cancel_monoid unsigned)) empty) : @irreducible_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_95311 (h0 : ordered_add_comm_monoid (measure_theory.measure_space (semiring empty))) : archimedean (measure_theory.measure_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_95312 (h0 : functor.add_const (cancel_comm_monoid_with_zero (normed_lattice_add_comm_group real)) real) : @unique_factorization_monoid.{0} (normed_lattice_add_comm_group.{0} real) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (normed_lattice_add_comm_group.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_95313 (h0 : complete_lattice (boolean_algebra real)) : is_compactly_generated (boolean_algebra real) := sorry --non-trivial
lemma new_lemma_95314 (h0 : complete_lattice (distrib (mul_one_class (mul_one_class linarith.ineq)))) : is_compactly_generated (distrib (mul_one_class (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_95315 (h0 : ring (non_assoc_semiring (semiring empty))) : strong_rank_condition (non_assoc_semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_95316 (h0 : not (list (option empty) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_95317 (h1 : topological_space (with_bot (denumerable char))) : irreducible_space (with_bot (denumerable char)) := sorry --non-trivial
lemma new_lemma_95318 (h0 : not (semiring (id empty) -> false)) : @is_noetherian_ring.{0} (@id.{2} Type empty) (@classical.by_contradiction'.{1} (semiring.{0} (@id.{2} Type empty)) h0)  := sorry --non-trivial
lemma new_lemma_95319 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @loc_path_connected_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_95320 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} h0 (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_95321 (h0 : group (with_bot (has_norm congr_arg_kind))) : normalizer_condition (with_bot (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_95322 (h0 : functor.add_const (filter (add_cancel_monoid pos)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_95323 (h0 : functor.add_const (topological_space (sub_neg_monoid linarith.comp)) (has_pos_part Type)) : @preirreducible_space.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) (has_pos_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_95324 (h0 : finset (simple_graph (has_add (has_add linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_95325 (h0 : ring (add_group (has_norm (semiring (semiring (semiring unsigned)))))) : rank_condition (add_group (has_norm (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_95326 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (measure_theory.measure_space.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (measure_theory.measure_space.{0} num))  := sorry --non-trivial
lemma new_lemma_95327 (h0 : topological_space (ordered_comm_monoid (ring (has_add (has_pos_part Type))))) : loc_path_connected_space (ordered_comm_monoid (ring (has_add (has_pos_part Type)))) := sorry --non-trivial
lemma new_lemma_95328 (h0 : functor.add_const (list (normed_comm_ring name)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_95329 (h0 : filter (has_add (has_neg Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_95330 (h0 : topological_space (has_norm char)) : totally_disconnected_space (has_norm char) := sorry --non-trivial
lemma new_lemma_95331 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_95332 (h0 : not (has_mem.mem (semiring linarith.ineq) has_emptyc.emptyc -> false)) : @normalizer_condition.{0} (semiring.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type group.{0} (semiring.{0} linarith.ineq) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.ineq) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_95333 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_95334 (h0 : ordered_comm_monoid (has_to_string (ring (semigroup (has_neg linarith.comp))))) : has_exists_mul_of_le (has_to_string (ring (semigroup (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_95335 (h0 h1 : multiset (has_div linarith.comp_source)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_95336 (h0 : list (has_star congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_95337 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (denumerable.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (denumerable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_95338 (h0 : set (add_comm_semigroup (add_comm_semigroup ereal) -> std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_95339 (h0 : add_group (plift (mul_zero_class (semiring num)))) : is_add_cyclic (plift (mul_zero_class (semiring num))) := sorry --non-trivial
lemma new_lemma_95340 (h0 : group (semiring (has_norm (has_top fun_info)))) : is_cyclic (semiring (has_norm (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_95341 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_95342 (h0 : function.extfun Type (prod (has_nndist ennreal))) : id_rel (function.extfun_app h0 (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_95343 (h0 : function.extfun nat fin) : @complete_space.{0} (ordered_comm_ring.{0} linarith.comp) (@matrix.vec_empty.{0} (uniform_space.{0} (ordered_comm_ring.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_95344 (h0 : topological_space (ordered_comm_monoid pos)) : irreducible_space (ordered_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_95345 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (comm_monoid empty)) := sorry --non-trivial
lemma new_lemma_95346 (h0 : topological_space (has_neg_part (cancel_monoid ennreal))) : regular_space (has_neg_part (cancel_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_95347 (h0 : ring (add_cancel_monoid linarith.comp)) : strong_rank_condition (add_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_95348 (h0 : uniform_space (has_top (semiring congr_arg_kind))) : complete_space (has_top (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_95349 (h0 : fin has_zero.zero) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@list.head.{0} (filter.{0} Prop) (@filter.inhabited.{0} Prop) (@matrix.vec_empty.{0} (list.{0} (filter.{0} Prop)) h0))  := sorry --non-trivial
lemma new_lemma_95350 (h0 : complete_lattice (simple_graph (ring (boolean_algebra.core Type)))) : complete_lattice.is_Sup_finite_compact (simple_graph (ring (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_95351 (h0 : functor.add_const (group (add_cancel_monoid Type)) (finset (finset pos))) : @is_simple_group.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (add_cancel_monoid.{1} Type)) (finset.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_95352 (h0 : topological_space (metric_space congr_arg_kind)) : discrete_topology (metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_95353 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_95354 (h0 : functor.add_const (topological_space (ordered_ring empty)) (semiring (semiring num))) : @t1_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} empty)) (semiring.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_95355 (h0 : finset (ring (option empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_95356 (h0 : function.extfun (Type 1) monoid) : @monoid.fg.{1} (normed_lattice_add_comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} h0 (normed_lattice_add_comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_95357 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) linarith.ineq) := sorry --non-trivial
lemma new_lemma_95358 (h0 : functor.add_const (group (has_Inf environment.implicit_infer_kind)) Type) : @group.fg.{0} (has_Inf.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (group.{0} (has_Inf.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_95359 (h1 : semi_normed_comm_ring linarith.ineq -> semi_normed_comm_ring linarith.ineq -> Prop) : symmetric h1 := sorry --non-trivial
lemma new_lemma_95360 (h0 : list (has_neg num)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_95361 (h0 : equiv.perm char) : equiv.perm.is_cycle h0 := sorry --non-trivial
lemma new_lemma_95362 (h0 : finset (complete_linear_order (semiring congr_arg_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_95363 (h0 : functor.add_const (finset (comm_group environment.implicit_infer_kind)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_95364 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @is_principal_ideal_ring.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_95365 (h3 : topological_space (add_cancel_comm_monoid to_additive.value_type)) : totally_disconnected_space (add_cancel_comm_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_95366 (h0 : topological_space (has_emptyc (has_norm linarith.ineq))) : totally_disconnected_space (has_emptyc (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_95367 (h0 : group (has_union (semiring empty))) : normalizer_condition (has_union (semiring empty)) := sorry --non-trivial
lemma new_lemma_95368 (h0 : fin has_zero.zero) : @group.fg.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (group.{0} (boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_95369 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_95370 (h0 : not (has_mem.mem to_additive.value_type has_emptyc.emptyc -> false)) : @is_domain.{0} to_additive.value_type (@finset.pi.empty.{1 0} Type ring.{0} to_additive.value_type (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) to_additive.value_type (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_95371 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_95372 (h0 : group (add_cancel_monoid (option empty))) : normalizer_condition (add_cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_95373 (h1 : complete_lattice (with_zero char)) : is_compactly_generated (with_zero char) := sorry --non-trivial
lemma new_lemma_95374 (h0 : complete_lattice (linear_ordered_field (has_to_string (has_to_string num)))) : is_atomistic (linear_ordered_field (has_to_string (has_to_string num))) := sorry --non-trivial
lemma new_lemma_95375 (h0 : complete_lattice (cancel_monoid ennreal)) : complete_lattice.is_Sup_finite_compact (cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_95376 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) linarith.comp) : @t0_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_95377 (h0 : topological_space (with_zero (random_gen (has_inv char)))) : totally_disconnected_space (with_zero (random_gen (has_inv char))) := sorry --non-trivial
lemma new_lemma_95378 (h0 : not (topological_space (denumerable linarith.ineq) -> false)) : @t0_space.{0} (denumerable.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_95379 (h0 : function.extfun nat fin) : @t0_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_95380 (h0 : topological_space (has_emptyc (random_gen (random_gen to_additive.value_type)))) : totally_separated_space (has_emptyc (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_95381 (h0 : topological_space (normed_group (semiring congr_arg_kind))) : preirreducible_space (normed_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_95382 (h0 : functor.add_const (semiring (has_star empty)) empty) : @is_noetherian_ring.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (has_star.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_95383 (h0 : add_group (random_gen (has_nnnorm (has_nnnorm char)))) : is_add_cyclic (random_gen (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_95384 (h0 : not (complete_lattice (has_emptyc linarith.comp_source) -> false)) : @is_compactly_generated.{0} (has_emptyc.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_emptyc.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_95385 (h0 : functor.add_const (group (has_zero linarith.comp)) (ring (finset linarith.comp))) : @is_simple_group.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} linarith.comp)) (ring.{0} (finset.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_95386 (h0 : functor.add_const (monoid (ring environment.implicit_infer_kind)) linarith.comp) : @monoid.fg.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (ring.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_95387 (h0 : topological_space (has_to_string (has_nndist pos))) : normal_space (has_to_string (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_95388 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (topological_space.{0} (has_top.{0} (has_top.{0} (has_nnnorm.{0} (has_nnnorm.{0} fun_info))))) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (topological_space.{0} (has_top.{0} (has_top.{0} (has_nnnorm.{0} (has_nnnorm.{0} fun_info))))))  := sorry --non-trivial
lemma new_lemma_95389 (h0 : not (ring (dlist reducibility_hints) -> false)) : @rank_condition.{0} (dlist.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (dlist.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_95390 (h0 : topological_space (finset (has_add pos))) : path_connected_space (finset (has_add pos)) := sorry --non-trivial
lemma new_lemma_95391 (h0 : add_group (has_pos_part (has_pos_part real))) : is_add_cyclic (has_pos_part (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_95392 (h0 : has_lt (mul_one_class to_additive.value_type)) : no_max_order (mul_one_class to_additive.value_type) := sorry --non-trivial
lemma new_lemma_95393 (h0 : functor.add_const (topological_space (option ennreal)) ennreal) : @totally_separated_space.{0} (option.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_95394 (h0 : has_mem.mem fun_info has_emptyc.emptyc) : @is_compactly_generated.{0} fun_info (@finset.pi.empty.{1 0} Type complete_lattice.{0} fun_info h0)  := sorry --non-trivial
lemma new_lemma_95395 (h0 : topological_space (has_inner environment.implicit_infer_kind environment.implicit_infer_kind)) : t1_space (has_inner environment.implicit_infer_kind environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_95396 (h0 : ring (has_lt to_additive.value_type)) : is_domain (has_lt to_additive.value_type) := sorry --non-trivial
lemma new_lemma_95397 (h0 : topological_space (metric_space (semiring linarith.comp))) : normal_space (metric_space (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_95398 (h0 : group (monoid (option empty))) : normalizer_condition (monoid (option empty)) := sorry --non-trivial
lemma new_lemma_95399 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_95400 (h1 : topological_space (random_gen (random_gen (random_gen string_imp)))) : locally_compact_space (random_gen (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_95401 (h0 : function.extfun (Type 1) topological_space) : @sequential_space.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_95402 (h0 : not (topological_space (ordered_cancel_add_comm_monoid unsigned) -> false)) : @normal_space.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (ordered_cancel_add_comm_monoid.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_95403 (h0 : topological_space (metric_space (comm_ring (comm_ring reducibility_hints)))) : t0_space (metric_space (comm_ring (comm_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_95404 (h0 : thunk pnat) (h1 : ulower pnat) : pnat.coprime (@trace_call_stack.{0} pnat h0) (@ulower.up.{0} pnat encodable.pnat h1)  := sorry --non-trivial
lemma new_lemma_95405 (h0 : ring (measurable_space (random_gen linarith.comp))) : is_domain (measurable_space (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_95406 (h0 : ring (has_compl (random_gen char))) : strong_rank_condition (has_compl (random_gen char)) := sorry --non-trivial
lemma new_lemma_95407 (h0 : functor.add_const (group (finset pos)) name) : @group.fg.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_95408 (h0 : function.extfun Type (functor.comp topological_space has_zero)) : @irreducible_space.{0} (has_zero.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_zero.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_95409 (h0 : filter (has_to_string linarith.comp)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_95410 (h0 : complete_lattice (ordered_comm_ring (has_Inf real))) : complete_lattice.is_Sup_finite_compact (ordered_comm_ring (has_Inf real)) := sorry --non-trivial
lemma new_lemma_95411 (h0 : topological_space (simple_graph (finset linarith.comp))) : t0_space (simple_graph (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_95412 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_95413 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_95414 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_95415 (h0 : topological_space (semigroup (comm_group (comm_group (comm_group Type))))) : regular_space (semigroup (comm_group (comm_group (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_95416 (h0 : finset (semigroup name)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_95417 (h0 : add_group (add_cancel_comm_monoid (has_nnnorm reducibility_hints))) : is_add_cyclic (add_cancel_comm_monoid (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_95418 (h0 : ring (has_neg (option (option (option (option ennreal)))))) : rank_condition (has_neg (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_95419 (h0 : cancel_comm_monoid_with_zero (ordered_comm_monoid (has_Inf (has_Inf real)))) : unique_factorization_monoid (ordered_comm_monoid (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_95420 (h0 : functor.add_const (topological_space (finset pos)) pos) : @preirreducible_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_95421 (h0 : cancel_comm_monoid_with_zero (group_with_zero (complete_distrib_lattice (option ennreal)))) : unique_factorization_monoid (group_with_zero (complete_distrib_lattice (option ennreal))) := sorry --non-trivial
lemma new_lemma_95422 (h0 : functor.add_const (prod pos pos) unsigned) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_95423 (h3 : add_group (has_append to_additive.value_type)) : is_add_cyclic (has_append to_additive.value_type) := sorry --non-trivial
lemma new_lemma_95424 (h0 : group (plift (option unsigned))) : normalizer_condition (plift (option unsigned)) := sorry --non-trivial
lemma new_lemma_95425 (h0 : functor.comp ring semigroup Type) : @rank_condition.{1} (semigroup.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} semigroup.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_95426 (h0 : functor.add_const (function.extfun (Type 1) ring) pos) : @rank_condition.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) pos h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_95427 (h0 : not (group (semiring (has_top num)) -> false)) : @normalizer_condition.{0} (semiring.{0} (has_top.{0} num)) (@classical.by_contradiction'.{1} (group.{0} (semiring.{0} (has_top.{0} num))) h0)  := sorry --non-trivial
lemma new_lemma_95428 (h0 : functor.add_const (complete_lattice (option empty)) congr_arg_kind) : @is_atomistic.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (option.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_95429 (h1 : topological_space (add_monoid (has_nnnorm char))) : totally_disconnected_space (add_monoid (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_95430 (h0 : functor.add_const (ordered_add_comm_monoid (has_zero environment.implicit_infer_kind)) (boolean_algebra Type)) : @archimedean.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_zero.{0} environment.implicit_infer_kind)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_95431 (h0 : functor.add_const (topological_space (has_Inf pos)) (has_neg Type)) : @normal_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_95432 (h0 : topological_space (has_nnnorm reducibility_hints)) (h1 : preorder (has_nnnorm reducibility_hints)) : order_topology (has_nnnorm reducibility_hints) := sorry --non-trivial
lemma new_lemma_95433 (h0 : list (option num)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_95434 (h0 : ring (semi_normed_comm_ring (non_unital_non_assoc_semiring string.iterator_imp))) : strong_rank_condition (semi_normed_comm_ring (non_unital_non_assoc_semiring string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_95435 (h0 : topological_space (random_gen congr_arg_kind)) : preirreducible_space (random_gen congr_arg_kind) := sorry --non-trivial
lemma new_lemma_95436 (h0 : functor.add_const (topological_space (has_to_string Type)) (finset pos)) : @loc_path_connected_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_95437 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ordered_comm_ring linarith.comp)) Type) : @unique_factorization_monoid.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (ordered_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_95438 (h0 : ordered_add_comm_monoid (ordered_comm_monoid linarith.comp)) : archimedean (ordered_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_95439 (h0 : topological_space (has_to_string (finset (normed_linear_ordered_group Type)))) : t0_space (has_to_string (finset (normed_linear_ordered_group Type))) := sorry --non-trivial
lemma new_lemma_95440 (h0 : topological_space string.iterator_imp) (h2 : preorder string.iterator_imp) : order_closed_topology string.iterator_imp := sorry --non-trivial
lemma new_lemma_95441 (h0 : functor.add_const (group (comm_group Type)) environment.implicit_infer_kind) : @normalizer_condition.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (comm_group.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_95442 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_95443 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_95444 (h0 : functor.add_const (complete_lattice (linear_ordered_field pos)) Type) : @is_compactly_generated.{0} (linear_ordered_field.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (linear_ordered_field.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_95445 (h0 : ring (measurable_space (has_norm fun_info))) : is_domain (measurable_space (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_95446 (h0 : topological_space (simple_graph (has_pos_part pos))) : preconnected_space (simple_graph (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_95447 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) linarith.comp) : @regular_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_95448 (h0 : functor.comp topological_space canonically_ordered_comm_semiring ennreal) : @topological_space.separable_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_95449 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_95450 (h0 : uniform_space (has_to_string (has_neg pos))) : complete_space (has_to_string (has_neg pos)) := sorry --non-trivial
lemma new_lemma_95451 (h0 : function.extfun Type group) : @normalizer_condition.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_95452 (h0 : not (ring (comm_ring linarith.comp_source) -> false)) : @is_domain.{0} (comm_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (comm_ring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_95453 (h0 : ring (sub_neg_monoid (has_add linarith.comp))) : rank_condition (sub_neg_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_95454 (h0 : uniform_space (canonically_ordered_comm_semiring Type)) : separated_space (canonically_ordered_comm_semiring Type) := sorry --non-trivial
lemma new_lemma_95455 (h0 : functor.add_const (topological_space (has_add linarith.comp)) environment.implicit_infer_kind) : @totally_disconnected_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_95456 (h0 : topological_space (ordered_comm_monoid (has_pos_part real))) : normal_space (ordered_comm_monoid (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_95457 (h1 : ring (semiring (has_norm linarith.comp_source))) : rank_condition (semiring (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_95458 (h0 : ordered_add_comm_monoid (sub_neg_monoid (has_add (has_Inf (has_add pos))))) : archimedean (sub_neg_monoid (has_add (has_Inf (has_add pos)))) := sorry --non-trivial
lemma new_lemma_95459 (h0 : left_cancel_semigroup ereal) (h1 : sym2 (left_cancel_semigroup ereal)) : sym2.mem h0 h1 := sorry --non-trivial
lemma new_lemma_95460 (h0 : has_le (has_norm linarith.comp_source)) (h1 : has_mem.mem linarith.comp_source has_emptyc.emptyc) : is_max (finset.pi.empty has_norm linarith.comp_source h1) := sorry --non-trivial
lemma new_lemma_95461 (h0 : not (topological_space (has_emptyc num) -> false)) : @totally_separated_space.{0} (has_emptyc.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_95462 (h0 : group (linear_ordered_semiring (has_norm empty))) : is_cyclic (linear_ordered_semiring (has_norm empty)) := sorry --non-trivial
lemma new_lemma_95463 (h0 : has_mem.mem (with_bot num) has_emptyc.emptyc) : @is_compactly_generated.{0} (with_bot.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_bot.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_95464 (h0 : add_group (with_bot (semiring (has_norm (semiring unsigned))))) : is_add_cyclic (with_bot (semiring (has_norm (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_95465 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) empty) : @locally_compact_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_95466 (h0 : functor.add_const (group (has_neg unsigned)) environment.implicit_infer_kind) : @normalizer_condition.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_95467 (h0 h1 h2 : pnat) : pnat.coprime h0 (pnat.gcd h1 (id h2)) := sorry --non-trivial
lemma new_lemma_95468 (h0 : list (add_cancel_monoid (finset (ring Type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_95469 (h0 : monoid (cancel_monoid (normed_comm_ring environment.implicit_infer_kind))) : monoid.fg (cancel_monoid (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_95470 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (denumerable.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (denumerable.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_95471 (h0 : group (denumerable linarith.comp_source)) : group.fg (denumerable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_95472 (h0 : topological_space (plift congr_arg_kind)) : t0_space (plift congr_arg_kind) := sorry --non-trivial
lemma new_lemma_95473 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @totally_disconnected_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_95474 (h0 : functor.comp complete_lattice mul_zero_class Type) : @is_compactly_generated.{1} (mul_zero_class.{1} Type) (@functor.comp.run.{1 1 1} complete_lattice.{1} mul_zero_class.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_95475 (h0 : ring name) : rank_condition name := sorry --non-trivial
lemma new_lemma_95476 (h0 : ring (semigroup (semiring empty))) : is_domain (semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_95477 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_95478 (h0 : topological_space (cancel_monoid (boolean_algebra linarith.comp))) : locally_compact_space (cancel_monoid (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_95479 (h0 : functor.add_const (function.extfun Type ring) name) : @is_principal_ideal_ring.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name h0) (mul_zero_class.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_95480 (h0 : functor.add_const (monoid (has_pos_part Type)) (has_neg Type)) : @monoid.fg.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 1} (monoid.{1} (has_pos_part.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_95481 (h0 : list (canonically_linear_ordered_monoid (option (option num)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_95482 (h0 : complete_lattice (pseudo_emetric_space (semiring num))) : complete_lattice.is_Sup_finite_compact (pseudo_emetric_space (semiring num)) := sorry --non-trivial
lemma new_lemma_95483 (h1 : complete_lattice (div_inv_monoid char)) : complete_lattice.is_Sup_finite_compact (div_inv_monoid char) := sorry --non-trivial
lemma new_lemma_95484 (h0 : group (complete_semilattice_Sup (random_gen to_additive.value_type))) : is_cyclic (complete_semilattice_Sup (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_95485 (h0 : functor.add_const (topological_space (has_add linarith.comp)) pos) : @t1_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_95486 (h0 : functor.add_const (ring (ring pos)) Type) : @strong_rank_condition.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_95487 (h0 : topological_space (generalized_boolean_algebra (has_add (has_Inf name)))) : t1_space (generalized_boolean_algebra (has_add (has_Inf name))) := sorry --non-trivial
lemma new_lemma_95488 (h0 : topological_space (canonically_ordered_comm_semiring empty)) : totally_disconnected_space (canonically_ordered_comm_semiring empty) := sorry --non-trivial
lemma new_lemma_95489 (h0 : list (filter Prop)) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@list.ilast.{0} (filter.{0} Prop) (@filter.inhabited.{0} Prop) (@id.{1} (list.{0} (filter.{0} Prop)) h0))  := sorry --non-trivial
lemma new_lemma_95490 (h0 : topological_space (has_pos_part (has_Inf (has_neg (has_neg (has_neg Type)))))) : totally_separated_space (has_pos_part (has_Inf (has_neg (has_neg (has_neg Type))))) := sorry --non-trivial
lemma new_lemma_95491 (h0 : topological_space (id empty)) : totally_separated_space (id empty) := sorry --non-trivial
lemma new_lemma_95492 (h0 : topological_space (has_nndist (finset ennreal))) : loc_path_connected_space (has_nndist (finset ennreal)) := sorry --non-trivial
lemma new_lemma_95493 (h0 : functor.add_const (monoid (add_cancel_monoid environment.implicit_infer_kind)) Type) : @monoid.fg.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (monoid.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_95494 (h0 : add_group (has_compl (random_gen to_additive.value_type))) : is_add_cyclic (has_compl (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_95495 (h0 : topological_space (distrib_lattice (random_gen (random_gen linarith.comp_source)))) : totally_separated_space (distrib_lattice (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_95496 (h0 : topological_space (measurable_space (semiring (semiring congr_arg_kind)))) : t0_space (measurable_space (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_95497 (h0 : topological_space (complete_linear_order (semiring unsigned))) : irreducible_space (complete_linear_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_95498 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_95499 (h0 : finset (cancel_monoid name)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_95500 (h0 : group (has_top (random_gen (random_gen (has_top num))))) : normalizer_condition (has_top (random_gen (random_gen (has_top num)))) := sorry --non-trivial
lemma new_lemma_95501 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (random_gen.{0} (semiring.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} num))))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} (semiring.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} num))))))  := sorry --non-trivial
lemma new_lemma_95502 (h0 : group (finset (option unsigned))) : normalizer_condition (finset (option unsigned)) := sorry --non-trivial
lemma new_lemma_95503 (h0 : topological_space (metric_space linarith.comp_source)) : locally_compact_space (metric_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_95504 (h0 : function.extfun nat fin) : @normal_space.{1} (has_Inf.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_Inf.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_95505 (h0 : ring (has_lt string.iterator_imp)) : is_domain (has_lt string.iterator_imp) := sorry --non-trivial
lemma new_lemma_95506 (h0 : functor.add_const (uniform_space (measurable_space.dynkin_system unsigned)) unsigned) : @separated_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (measurable_space.dynkin_system.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_95507 (h0 : topological_space (mul_zero_class (ring (finset pos)))) : totally_separated_space (mul_zero_class (ring (finset pos))) := sorry --non-trivial
lemma new_lemma_95508 (h0 : functor.add_const (topological_space (cancel_monoid name)) environment.implicit_infer_kind) : @t1_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_95509 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_95510 (h0 : finset (cancel_monoid (comm_group (has_add (has_add Type))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_95511 (h0 : functor.add_const (function.extfun Type topological_space) (has_add Type)) : @normal_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (has_add.{1} Type) h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_95512 (h0 : function.extfun (Type 1) (functor.add_const (function.extfun Type complete_lattice))) : @is_atomistic.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type complete_lattice.{0}) Type (@function.extfun_app.{3 2} (Type 1) (functor.add_const.{1 1} (function.extfun.{2 1} Type complete_lattice.{0})) h0 Type)) (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_95513 (h0 : functor.add_const (group (finset pos)) environment.implicit_infer_kind) : @normalizer_condition.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_95514 (h0 : ring (complete_distrib_lattice (option unsigned))) : is_principal_ideal_ring (complete_distrib_lattice (option unsigned)) := sorry --non-trivial
lemma new_lemma_95515 (h0 : topological_space (has_Inf name)) : t0_space (has_Inf name) := sorry --non-trivial
lemma new_lemma_95516 (h0 : list (add_comm_monoid (has_add Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_95517 (h0 : not (ring (uniform_space char) -> false)) : @rank_condition.{0} (uniform_space.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (uniform_space.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_95518 (h0 : topological_space (normed_group congr_arg_kind)) : totally_separated_space (normed_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_95519 (h0 : functor.add_const (ordered_add_comm_monoid (has_Inf Type)) (ring Type)) : @archimedean.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 1} (ordered_add_comm_monoid.{1} (has_Inf.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_95520 (h0 : not (complete_lattice (linear_ordered_add_comm_group fun_info) -> false)) : @is_compactly_generated.{0} (linear_ordered_add_comm_group.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_add_comm_group.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_95521 (h0 : function.extfun Type uniform_space) : @separated_space.{0} pos (@function.extfun_app.{2 1} Type uniform_space.{0} h0 pos)  := sorry --non-trivial
lemma new_lemma_95522 (h0 : topological_space (has_nndist (has_to_string (has_add ennreal)))) : totally_disconnected_space (has_nndist (has_to_string (has_add ennreal))) := sorry --non-trivial
lemma new_lemma_95523 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_95524 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_neg.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} num))  := sorry --non-trivial
lemma new_lemma_95525 (h0 : functor.add_const (functor.comp add_group has_neg name) linarith.comp) : @is_add_cyclic.{0} (has_neg.{0} name) (@functor.comp.run.{0 0 0} add_group.{0} has_neg.{0} name (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} add_group.{0} has_neg.{0} name) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_95526 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_95527 (h0 : topological_space (has_neg_part (has_nndist (has_nndist name)))) : sequential_space (has_neg_part (has_nndist (has_nndist name))) := sorry --non-trivial
lemma new_lemma_95528 (h1 : topological_space (has_nnnorm (random_gen linarith.ineq))) : path_connected_space (has_nnnorm (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_95529 (h0 : topological_space (finset (finset name))) : discrete_topology (finset (finset name)) := sorry --non-trivial
lemma new_lemma_95530 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (with_one.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_95531 (h0 : complete_lattice (has_zero (has_neg (ring environment.implicit_infer_kind)))) : is_compactly_generated (has_zero (has_neg (ring environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_95532 (h0 : functor.add_const (complete_lattice (normed_comm_ring pos)) linarith.comp) : @is_compactly_generated.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_95533 (h0 : functor.add_const (topological_space (ring Type)) pos) : @locally_compact_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_95534 (h1 : ring (simple_graph std_gen)) : strong_rank_condition (simple_graph std_gen) := sorry --non-trivial
lemma new_lemma_95535 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_95536 (h0 : topological_space (has_neg_part (option unsigned))) : loc_path_connected_space (has_neg_part (option unsigned)) := sorry --non-trivial
lemma new_lemma_95537 (h0 : prod (add_right_cancel_monoid (semiring num)) (add_right_cancel_monoid (semiring num))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_95538 (h0 : function.extfun Type (functor.comp topological_space has_nndist)) : @loc_path_connected_space.{0} (has_nndist.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_nndist.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_95539 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_95540 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_95541 (h0 : functor.add_const (group (ordered_cancel_add_comm_monoid unsigned)) unsigned) : @is_cyclic.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (ordered_cancel_add_comm_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_95542 (h1 : topological_space (has_top (random_gen to_additive.value_type))) : path_connected_space (has_top (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_95543 (h0 : functor.add_const (list (add_group empty)) (semiring (semiring empty))) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_95544 (h0 : ring (mul_one_class reducibility_hints)) : strong_rank_condition (mul_one_class reducibility_hints) := sorry --non-trivial
lemma new_lemma_95545 (h0 : false) : list.head (false.elim h0) := sorry --trivial
lemma new_lemma_95546 (h0 : functor.add_const (topological_space (has_pos_part pos)) linarith.comp) : @preirreducible_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_95547 (h0 : topological_space (normed_field environment.projection_info)) : t0_space (normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_95548 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_95549 (h0 : enat -> enat -> Prop) (h1 : set enat) : zorn.chain h0 (set.up h1) := sorry --non-trivial
lemma new_lemma_95550 (h0 : complete_lattice (generalized_boolean_algebra (has_add Type))) : is_atomistic (generalized_boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_95551 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) name) : @regular_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_95552 (h0 : complete_lattice (has_zero (add_cancel_monoid name))) : is_compactly_generated (has_zero (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_95553 (h0 : functor.add_const (function.extfun Type topological_space) name) : @topological_space.separable_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_95554 (h0 : group (ordered_comm_monoid Type)) : group.fg (ordered_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_95555 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_star.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_star.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_95556 (h0 : monoid (normed_comm_ring (ring (has_to_string (ring linarith.comp))))) : monoid.fg (normed_comm_ring (ring (has_to_string (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_95557 (h0 : has_lt (has_div char)) : no_max_order (has_div char) := sorry --non-trivial
lemma new_lemma_95558 (h0 : functor.add_const (topological_space (partial_order congr_arg_kind)) empty) : @t1_space.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_95559 (h0 : topological_space (add_cancel_comm_monoid (has_nnnorm linarith.ineq))) : t0_space (add_cancel_comm_monoid (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_95560 (h0 : uniform_space (has_norm (semiring (random_gen num)))) : separated_space (has_norm (semiring (random_gen num))) := sorry --non-trivial
lemma new_lemma_95561 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_95562 (h0 : functor.add_const (group (boolean_algebra.core name)) pos) : @is_simple_group.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.core.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_95563 (h0 : topological_space (has_union (metric_space linarith.comp))) : discrete_topology (has_union (metric_space linarith.comp)) := sorry --non-trivial
lemma new_lemma_95564 (h0 : complete_lattice (plift unsigned)) : is_atomistic (plift unsigned) := sorry --non-trivial
lemma new_lemma_95565 (h0 : uniform_space (add_group (has_norm congr_arg_kind))) : separated_space (add_group (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_95566 (h0 : ring (random_gen (uniform_space (uniform_space (has_ssubset reducibility_hints))))) : rank_condition (random_gen (uniform_space (uniform_space (has_ssubset reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_95567 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (ordered_ring.{0} (semiring.{0} congr_arg_kind)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_ring.{0} (semiring.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_95568 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type semiring.{0} h0 (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_95569 (h0 : functor.add_const (complete_lattice (finset ennreal)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_95570 (h0 : complete_lattice (canonically_linear_ordered_monoid (has_add real))) : is_atomistic (canonically_linear_ordered_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_95571 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (comm_ring.{0} (has_top.{0} (has_nnnorm.{0} (has_top.{0} (has_top.{0} to_additive.value_type))))) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (comm_ring.{0} (has_top.{0} (has_nnnorm.{0} (has_top.{0} (has_top.{0} to_additive.value_type))))))  := sorry --non-trivial
lemma new_lemma_95572 (h0 : functor.add_const (topological_space (has_nndist Type)) pos) : @regular_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_95573 (h0 : complete_lattice (has_Inf (has_neg name))) : complete_lattice.is_Sup_finite_compact (has_Inf (has_neg name)) := sorry --non-trivial
lemma new_lemma_95574 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (normed_lattice_add_comm_group pos)) := sorry --non-trivial
lemma new_lemma_95575 (h0 : function.extfun Type (functor.add_const (add_monoid znum))) : @add_monoid.fg.{0} znum (@functor.add_const.run.{0 0} (add_monoid.{0} znum) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_monoid.{0} znum)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_95576 (h0 : topological_space (has_top (metric_space num))) : normal_space (has_top (metric_space num)) := sorry --non-trivial
lemma new_lemma_95577 (h0 : functor.add_const (topological_space (has_nndist pos)) linarith.comp) : @locally_compact_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_95578 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (linear_ordered_semiring num)) := sorry --non-trivial
lemma new_lemma_95579 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_95580 (h0 : topological_space (add_cancel_monoid (add_cancel_monoid Type))) : t0_space (add_cancel_monoid (add_cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_95581 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (with_one.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_95582 (h0 : functor.add_const (group (ring pos)) environment.implicit_infer_kind) : @normalizer_condition.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_95583 (h0 : group (pseudo_metric_space (option (option pos)))) : group.fg (pseudo_metric_space (option (option pos))) := sorry --non-trivial
lemma new_lemma_95584 (h0 : ring (semi_normed_comm_ring (has_nnnorm linarith.comp_source))) : strong_rank_condition (semi_normed_comm_ring (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_95585 (h0 : ring (ordered_comm_ring (has_pos_part real))) : strong_rank_condition (ordered_comm_ring (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_95586 (h0 : ring (with_one (random_gen (random_gen to_additive.value_type)))) : is_domain (with_one (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_95587 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_95588 (h0 : not (list (mul_zero_class (semiring (semiring (semiring (semiring unsigned))))) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_95589 (h0 : functor.add_const (ordered_comm_monoid environment.implicit_infer_kind) (finset linarith.comp)) : @has_exists_mul_of_le.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} environment.implicit_infer_kind) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_95590 (h1 : topological_space (normed_field (comm_ring linarith.comp_source))) : t0_space (normed_field (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_95591 (h0 : group (boolean_algebra (has_add (has_add (has_add pos))))) : is_cyclic (boolean_algebra (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_95592 (h0 : filter (has_add (has_pos_part real))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_95593 (h0 : functor.add_const (complete_lattice (ring empty)) congr_arg_kind) : @is_compactly_generated.{0} (ring.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_95594 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) name) : @irreducible_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_95595 (h0 : add_monoid (has_bot (sub_neg_monoid Type))) : add_monoid.fg (has_bot (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_95596 (h0 : has_mem.mem (id linarith.comp) has_emptyc.emptyc) : @is_compactly_generated.{0} (@id.{2} Type linarith.comp) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (@id.{2} Type linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_95597 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_95598 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @loc_path_connected_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_95599 (h0 : functor.add_const (ring (as_linear_order unsigned)) unsigned) : @rank_condition.{0} (as_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (as_linear_order.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_95600 (h0 : ordered_add_comm_monoid (add_cancel_monoid (has_neg pos))) : archimedean (add_cancel_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_95601 (h0 : list (has_norm (has_norm fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_95602 (h0 : add_monoid (ring (has_neg linarith.comp))) : add_monoid.fg (ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_95603 (h0 : group (distrib char)) : is_cyclic (distrib char) := sorry --non-trivial
lemma new_lemma_95604 (h0 : function.extfun Type topological_space) : @t0_space.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_95605 (h0 : ring (uniform_space to_additive.value_type)) : rank_condition (uniform_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_95606 (h0 : not (functor.add_const Prop (has_top num) -> false)) : functor.add_const.run (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_95607 (h0 : group (linear_ordered_semiring (random_gen (has_top (has_norm congr_arg_kind))))) : is_cyclic (linear_ordered_semiring (random_gen (has_top (has_norm congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_95608 (h0 : group (has_sub unsigned)) : is_cyclic (has_sub unsigned) := sorry --non-trivial
lemma new_lemma_95609 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_95610 (h0 : functor.add_const (topological_space (measure_theory.measure_space num)) congr_arg_kind) : @preirreducible_space.{0} (measure_theory.measure_space.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (measure_theory.measure_space.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_95611 (h0 : complete_lattice (random_gen (with_bot to_additive.value_type))) : is_atomistic (random_gen (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_95612 (h0 : complete_lattice (has_to_string environment.implicit_infer_kind)) : is_compactly_generated (has_to_string environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_95613 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @sequential_space.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_95614 (h0 : topological_space (has_nndist (finset environment.implicit_infer_kind))) : discrete_topology (has_nndist (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_95615 (h1 : uniform_space (simple_graph (comm_ring to_additive.value_type))) : complete_space (simple_graph (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_95616 (h0 : functor.add_const (filter (boolean_algebra.core linarith.comp)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_95617 (h0 : function.extfun nat fin) : @irreducible_space.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_pos_part.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_95618 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_monoid (has_Inf real))) : unique_factorization_monoid (canonically_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_95619 (h0 : functor.add_const (functor.add_const (finset linarith.comp) Type) pos) : finset.nonempty (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_95620 (h0 : topological_space (has_neg (has_to_string name))) : path_connected_space (has_neg (has_to_string name)) := sorry --non-trivial
lemma new_lemma_95621 (h0 : functor.add_const (functor.add_const (ordered_comm_monoid Type) linarith.comp) (has_add pos)) : @has_exists_mul_of_le.{1} Type (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} Type) linarith.comp (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (ordered_comm_monoid.{1} Type) linarith.comp) (has_add.{0} pos) h0))  := sorry --non-trivial
lemma new_lemma_95622 (h0 : group (ordered_comm_ring (has_neg linarith.comp))) : is_simple_group (ordered_comm_ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_95623 (h0 : function.extfun Type (functor.add_const (topological_space (has_bot name)))) : @irreducible_space.{0} (has_bot.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} name)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_bot.{0} name))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_95624 (h0 : uniform_space (ordered_comm_ring (has_Inf Type))) : complete_space (ordered_comm_ring (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_95625 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (bin_tree.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (bin_tree.{0} num))  := sorry --non-trivial
lemma new_lemma_95626 (h0 : topological_space (comm_group (comm_group name))) : totally_separated_space (comm_group (comm_group name)) := sorry --non-trivial
lemma new_lemma_95627 (h0 : filter (boolean_algebra (has_to_string (has_add unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_95628 (h0 : topological_space (id fun_info)) : locally_compact_space (id fun_info) := sorry --non-trivial
lemma new_lemma_95629 (h0 : not (topological_space (normed_group unsigned) -> false)) : @irreducible_space.{0} (normed_group.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_95630 (h0 : functor.add_const (topological_space Type) linarith.comp) : @t1_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_95631 (h0 : has_mem.mem (complete_semilattice_Sup linarith.comp) has_emptyc.emptyc) : @add_monoid.fg.{0} (complete_semilattice_Sup.{0} linarith.comp) (@finset.pi.empty.{1 0} Type add_monoid.{0} (complete_semilattice_Sup.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_95632 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} fun_info (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) fun_info)  := sorry --non-trivial
lemma new_lemma_95633 (h0 : functor.add_const (ring (has_add unsigned)) name) : @is_domain.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_95634 (h0 : function.extfun Type (functor.add_const (complete_lattice (has_Sup unsigned)))) : @is_atomistic.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_Sup.{0} unsigned)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (has_Sup.{0} unsigned))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_95635 (h0 : ring (canonically_ordered_monoid (has_Inf Type))) : is_principal_ideal_ring (canonically_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_95636 (h0 : ring (dlist (has_nnnorm (has_nnnorm linarith.comp_source)))) : rank_condition (dlist (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_95637 (h1 : add_group (with_one fun_info)) : is_add_cyclic (with_one fun_info) := sorry --non-trivial
lemma new_lemma_95638 (h0 : topological_space (has_top (has_top linarith.ineq))) : path_connected_space (has_top (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_95639 (h0 : functor.comp topological_space finset unsigned) : @normal_space.{0} (finset.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_95640 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (linear_ordered_field.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} num))  := sorry --non-trivial
lemma new_lemma_95641 (h0 : complete_lattice (has_add (comm_semigroup Type))) : is_compactly_generated (has_add (comm_semigroup Type)) := sorry --non-trivial
lemma new_lemma_95642 (h0 : ring (normed_comm_ring name)) : is_principal_ideal_ring (normed_comm_ring name) := sorry --non-trivial
lemma new_lemma_95643 (h1 h2 : multiset enat) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_95644 (h0 : not (filter (has_emptyc linarith.ineq) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_95645 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @totally_disconnected_space.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_95646 (h1 : topological_space (has_add (linear_ordered_add_comm_group linarith.ineq))) : totally_disconnected_space (has_add (linear_ordered_add_comm_group linarith.ineq)) := sorry --non-trivial
lemma new_lemma_95647 (h0 : functor.add_const (add_monoid (has_add linarith.comp)) pos) : @add_monoid.fg.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_add.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_95648 (h0 : not (ring (normed_field (mul_one_class (mul_one_class (mul_one_class char)))) -> false)) : @rank_condition.{0} (normed_field.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} char)))) (@classical.by_contradiction'.{1} (ring.{0} (normed_field.{0} (mul_one_class.{0} (mul_one_class.{0} (mul_one_class.{0} char))))) h0)  := sorry --non-trivial
lemma new_lemma_95649 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_95650 (h0 : functor.add_const (topological_space (has_add Type)) Type) : @loc_path_connected_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_add.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_95651 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) Type) : @archimedean.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) Type h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_95652 (h0 : fin has_zero.zero) : @topological_space.separable_space.{1} (has_Inf.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_Inf.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_95653 (h0 : complete_lattice (sub_neg_monoid name)) : complete_lattice.is_Sup_finite_compact (sub_neg_monoid name) := sorry --non-trivial
lemma new_lemma_95654 (h0 : functor.add_const (list (has_to_string environment.implicit_infer_kind)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_95655 (h0 : functor.add_const (function.extfun Type monoid) (has_nndist Type)) : @monoid.fg.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type monoid.{0}) (has_nndist.{1} Type) h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_95656 (h0 : fin has_zero.zero) : @separated_space.{0} (has_pos_part.{0} name) (@matrix.vec_empty.{0} (uniform_space.{0} (has_pos_part.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_95657 (h0 : ring (has_sub congr_arg_kind)) : rank_condition (has_sub congr_arg_kind) := sorry --non-trivial
lemma new_lemma_95658 (h0 : fin has_zero.zero) : @strong_rank_condition.{0} (boolean_algebra.{0} real) (@matrix.vec_empty.{0} (ring.{0} (boolean_algebra.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_95659 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_95660 (h0 : add_group (has_append (has_compl char))) : is_add_cyclic (has_append (has_compl char)) := sorry --non-trivial
lemma new_lemma_95661 (h0 : has_mem.mem (random_gen (has_norm linarith.comp_source)) has_emptyc.emptyc) : @totally_separated_space.{0} (random_gen.{0} (has_norm.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} (has_norm.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_95662 (h0 : add_group (has_norm (semiring (semiring (semiring unsigned))))) : is_add_cyclic (has_norm (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_95663 (h0 : add_group (comm_group (option unsigned))) : is_add_cyclic (comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_95664 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_95665 (h0 : list (normed_linear_ordered_group (semiring congr_arg_kind))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_95666 (h1 : set (normed_field fun_info)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_95667 (h0 : topological_space (ordered_cancel_add_comm_monoid (option num))) : preirreducible_space (ordered_cancel_add_comm_monoid (option num)) := sorry --non-trivial
lemma new_lemma_95668 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_95669 (h0 : functor.add_const (cancel_comm_monoid_with_zero znum) unsigned) : @unique_factorization_monoid.{0} znum (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} znum) unsigned h0)  := sorry --non-trivial
lemma new_lemma_95670 (h0 : group (topological_space (mul_one_class to_additive.value_type))) : is_cyclic (topological_space (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_95671 (h0 : topological_space (option (option unsigned))) : locally_compact_space (option (option unsigned)) := sorry --non-trivial
lemma new_lemma_95672 (h0 : group (ring (has_to_string environment.implicit_infer_kind))) : is_cyclic (ring (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_95673 (h0 : ring (fintype (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) : rank_condition (fintype (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_95674 (h4 : ring fun_info) : rank_condition fun_info := sorry --non-trivial
lemma new_lemma_95675 (h0 : complete_lattice (has_nndist (finset unsigned))) : complete_lattice.is_Sup_finite_compact (has_nndist (finset unsigned)) := sorry --non-trivial
lemma new_lemma_95676 (h0 : functor.add_const (function.extfun Type ring) unsigned) : @rank_condition.{0} (has_neg.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) unsigned h0) (has_neg.{0} empty))  := sorry --non-trivial
lemma new_lemma_95677 (h0 : functor.add_const (topological_space (has_Inf Type)) name) : @preconnected_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_Inf.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_95678 (h0 : topological_space (has_emptyc (has_norm to_additive.value_type))) : irreducible_space (has_emptyc (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_95679 (h0 : functor.add_const (ordered_add_comm_monoid (has_neg_part pos)) Type) : @archimedean.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_neg_part.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_95680 (h0 : functor.add_const (topological_space (add_comm_monoid environment.implicit_infer_kind)) Type) : @preirreducible_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_95681 (h0 : functor.add_const (group (boolean_algebra.core linarith.comp)) Type) : @is_cyclic.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (boolean_algebra.core.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_95682 : infinite enat := sorry --non-trivial
lemma new_lemma_95683 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (with_one.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (with_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_95684 (h0 : ring environment.implicit_infer_kind) : is_domain environment.implicit_infer_kind := sorry --non-trivial
lemma new_lemma_95685 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_95686 (h0 : topological_space (simple_graph (has_add (has_pos_part linarith.comp)))) : sequential_space (simple_graph (has_add (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_95687 (h0 : topological_space (non_assoc_semiring (semiring (semiring (semiring (semiring congr_arg_kind)))))) : preirreducible_space (non_assoc_semiring (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_95688 (h0 : topological_space (distrib string.iterator_imp)) : path_connected_space (distrib string.iterator_imp) := sorry --non-trivial
lemma new_lemma_95689 (h0 : topological_space (option linarith.ineq)) : totally_separated_space (option linarith.ineq) := sorry --non-trivial
lemma new_lemma_95690 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 group.{0}) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_95691 (h0 : topological_space (ordered_comm_ring (has_neg Type))) : discrete_topology (ordered_comm_ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_95692 (h0 : functor.add_const (topological_space (finset Type)) linarith.comp) : @discrete_topology.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_95693 (h0 : add_monoid (option (option unsigned))) : add_monoid.fg (option (option unsigned)) := sorry --non-trivial
lemma new_lemma_95694 (h0 : complete_lattice (has_to_string (has_neg Type))) : is_compactly_generated (has_to_string (has_neg Type)) := sorry --non-trivial
lemma new_lemma_95695 (h0 : ring (has_append linarith.comp_source)) : rank_condition (has_append linarith.comp_source) := sorry --non-trivial
lemma new_lemma_95696 (h0 : ring (has_div string.iterator_imp)) : is_domain (has_div string.iterator_imp) := sorry --non-trivial
lemma new_lemma_95697 (h0 : set (mul_one_class (mul_one_class (mul_one_class std_gen)) -> mul_one_class (mul_one_class ereal))) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_95698 (h0 : ring (comm_ring (random_gen (random_gen (random_gen string_imp))))) : is_domain (comm_ring (random_gen (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_95699 (h0 : ring (is_R_or_C (semiring (semiring (semiring empty))))) : is_domain (is_R_or_C (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_95700 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) linarith.comp) : @has_exists_mul_of_le.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) linarith.comp h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_95701 (h0 : filter (canonically_ordered_monoid (has_Inf (has_add pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_95702 (h0 : functor.add_const (topological_space (has_Sup num)) congr_arg_kind) : @totally_separated_space.{0} (has_Sup.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_95703 (h0 h1 : multiset (non_unital_non_assoc_semiring string.iterator_imp)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_95704 (h1 : has_mem.mem (measurable_space linarith.comp_source) has_emptyc.emptyc) : @t0_space.{0} (measurable_space.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} linarith.comp_source) h1)  := sorry --non-trivial
lemma new_lemma_95705 (h2 : add_group (random_gen (random_gen string_imp))) : is_add_cyclic (random_gen (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_95706 (h0 : not (topological_space (option congr_arg_kind) -> false)) : @totally_disconnected_space.{0} (option.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (option.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_95707 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_95708 (h0 : functor.add_const (functor.add_const (topological_space pos) Type) linarith.comp) : @totally_separated_space.{0} pos (@functor.add_const.run.{0 1} (topological_space.{0} pos) Type (@functor.add_const.run.{0 0} (functor.add_const.{0 1} (topological_space.{0} pos) Type) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_95709 (h0 : list fun_info) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_95710 (h0 : ordered_comm_monoid (has_Inf (has_Inf linarith.comp))) : has_exists_mul_of_le (has_Inf (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_95711 (h0 : group (has_compl (semi_normed_comm_ring (has_ssubset string_imp)))) : group.fg (has_compl (semi_normed_comm_ring (has_ssubset string_imp))) := sorry --non-trivial
lemma new_lemma_95712 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (measure_theory.measure_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measure_theory.measure_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_95713 (h2 : not (add_group (complete_semilattice_Sup congr_arg_kind) -> false)) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_group.{0} (complete_semilattice_Sup.{0} congr_arg_kind)) h2)  := sorry --non-trivial
lemma new_lemma_95714 (h0 : finset (ordered_cancel_add_comm_monoid (option (option (option pos))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_95715 (h0 : fin has_zero.zero) : @topological_space.separable_space.{0} (simple_graph.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (simple_graph.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_95716 (h0 : uniform_space (has_sub (semiring empty))) : separated_space (has_sub (semiring empty)) := sorry --non-trivial
lemma new_lemma_95717 (h0 : topological_space (has_compl string.iterator_imp)) (h1 : preorder (has_compl string.iterator_imp)) : order_topology (has_compl string.iterator_imp) := sorry --non-trivial
lemma new_lemma_95718 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_95719 (h0 : functor.comp monoid has_neg name) : @monoid.fg.{0} (has_neg.{0} name) (@functor.comp.run.{0 0 0} monoid.{0} has_neg.{0} name h0)  := sorry --non-trivial
lemma new_lemma_95720 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_95721 (h0 : topological_space (has_one (linear_ordered_semiring empty))) : preirreducible_space (has_one (linear_ordered_semiring empty)) := sorry --non-trivial
lemma new_lemma_95722 (h0 : prod (normed_comm_ring ennreal) (normed_comm_ring ennreal)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_95723 (h0 : topological_space (boolean_algebra (add_comm_monoid unsigned))) : loc_path_connected_space (boolean_algebra (add_comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_95724 (h0 : monoid (with_bot (has_top fun_info))) : monoid.fg (with_bot (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_95725 (h0 : filter (has_neg (option (option (option pos))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_95726 (h0 : topological_space (with_one (random_gen (denumerable num)))) : t0_space (with_one (random_gen (denumerable num))) := sorry --non-trivial
lemma new_lemma_95727 (h0 : topological_space (has_neg (has_add (has_neg (has_neg pos))))) : t1_space (has_neg (has_add (has_neg (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_95728 (h0 : cancel_comm_monoid_with_zero (monoid (option (option (option empty))))) : unique_factorization_monoid (monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_95729 (h0 : functor.add_const (semiring (has_neg environment.implicit_infer_kind)) Type) : @is_noetherian_ring.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (semiring.{0} (has_neg.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_95730 (h0 : topological_space (has_compl to_additive.value_type)) : locally_compact_space (has_compl to_additive.value_type) := sorry --non-trivial
lemma new_lemma_95731 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (linear_ordered_field (finset unsigned))) := sorry --non-trivial
lemma new_lemma_95732 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_95733 (h0 : functor.add_const (add_group (ring linarith.comp)) linarith.comp) : @is_add_cyclic.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_95734 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_95735 (h0 : function.extfun (Type 1) group) : @is_simple_group.{1} (normed_lattice_add_comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (normed_lattice_add_comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_95736 (h0 : functor.add_const (semiring (has_neg_part Type)) pos) : @is_noetherian_ring.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (has_neg_part.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_95737 (h0 : function.extfun Type (functor.add_const (complete_lattice (option empty)))) : @is_atomistic.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (option.{0} empty)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (option.{0} empty))) h0 num))  := sorry --non-trivial
lemma new_lemma_95738 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} linarith.ineq (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) linarith.ineq)  := sorry --non-trivial
lemma new_lemma_95739 (h0 : functor.add_const (ring (monoid empty)) unsigned) : @is_principal_ideal_ring.{0} (monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_95740 (h0 : topological_space (has_top linarith.comp_source)) : preconnected_space (has_top linarith.comp_source) := sorry --non-trivial
lemma new_lemma_95741 (h0 : functor.add_const (monoid (add_comm_monoid Type)) linarith.comp) : @monoid.fg.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (add_comm_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_95742 (h0 : functor.add_const (add_group (normed_linear_ordered_group unsigned)) congr_arg_kind) : @is_add_cyclic.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (normed_linear_ordered_group.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_95743 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_95744 (h0 : fin has_zero.zero) : @separated_space.{0} (finset.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type uniform_space.{0}) h0) (finset.{0} real))  := sorry --non-trivial
lemma new_lemma_95745 (h0 : topological_space (has_add (finset (has_pos_part linarith.comp)))) : path_connected_space (has_add (finset (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_95746 (h0 : topological_space (has_add (has_add environment.implicit_infer_kind))) : preconnected_space (has_add (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_95747 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_95748 (h0 : functor.add_const (topological_space (preorder num)) num) : @normal_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_95749 (h0 : topological_space (has_add (has_to_string Type))) : preconnected_space (has_add (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_95750 (h0 : functor.add_const (finset (has_star empty)) (semiring congr_arg_kind)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_95751 (h0 : not (uniform_space (has_emptyc congr_arg_kind) -> false)) : @separated_space.{0} (has_emptyc.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_emptyc.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_95752 (h0 : group (complete_semilattice_Sup (random_gen (random_gen linarith.comp_source)))) : normalizer_condition (complete_semilattice_Sup (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_95753 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @discrete_topology.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_95754 (h0 : filter (has_add Type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_95755 (h1 : topological_space (mul_one_class linarith.ineq)) : t0_space (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_95756 (h0 : function.extfun Type (functor.add_const (finset (linear_ordered_comm_monoid_with_zero unsigned)))) : finset.nonempty (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_95757 (h0 : functor.add_const (topological_space (mul_zero_class unsigned)) (semiring num)) : @normal_space.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} unsigned)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_95758 (h0 : topological_space (has_bot (has_Inf pos))) : preirreducible_space (has_bot (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_95759 (h0 : topological_space (metric_space empty)) : preirreducible_space (metric_space empty) := sorry --non-trivial
lemma new_lemma_95760 (h0 : functor.add_const (topological_space (has_nndist Type)) pos) : @sequential_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_95761 (h0 : ring (has_pos_part to_additive.value_type)) : rank_condition (has_pos_part to_additive.value_type) := sorry --non-trivial
lemma new_lemma_95762 (h0 : filter (monoid num)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_95763 (h0 : topological_space (complete_distrib_lattice name)) : irreducible_space (complete_distrib_lattice name) := sorry --non-trivial
lemma new_lemma_95764 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_95765 (h0 : group (linear_ordered_semiring (random_gen to_additive.value_type))) : normalizer_condition (linear_ordered_semiring (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_95766 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) (has_zero Type)) : @preconnected_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} linarith.comp)) (has_zero.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_95767 (h0 : function.extfun Type topological_space) : @t0_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_95768 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_95769 (h0 : list (has_nndist unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_95770 (h0 : topological_space (complete_distrib_lattice (add_comm_monoid (add_comm_monoid pos)))) : sequential_space (complete_distrib_lattice (add_comm_monoid (add_comm_monoid pos))) := sorry --non-trivial
lemma new_lemma_95771 (h0 : topological_space (sub_neg_monoid (ordered_comm_monoid name))) : sequential_space (sub_neg_monoid (ordered_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_95772 (h0 : ring (has_emptyc (has_top (has_top (has_norm congr_arg_kind))))) : is_domain (has_emptyc (has_top (has_top (has_norm congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_95773 (h0 : functor.comp topological_space has_to_string Type) : @t1_space.{1} (has_to_string.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_to_string.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_95774 (h0 : ring (semiring unsigned)) : rank_condition (semiring unsigned) := sorry --non-trivial
lemma new_lemma_95775 (h0 : complete_lattice (has_bot (comm_semigroup real))) : is_atomistic (has_bot (comm_semigroup real)) := sorry --non-trivial
lemma new_lemma_95776 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_95777 (h0 h1 : not (multiset (simple_graph reducibility_hints) -> false)) : multiset.disjoint (classical.by_contradiction' h0) (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_95778 (h0 : group (monoid_with_zero pos)) : is_cyclic (monoid_with_zero pos) := sorry --non-trivial
lemma new_lemma_95779 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @t0_space.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_95780 (h0 : not (topological_space (complete_semilattice_Sup linarith.comp_source) -> false)) : @t0_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_95781 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_95782 (h2 : ring (denumerable to_additive.value_type)) : strong_rank_condition (denumerable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_95783 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (with_one.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} num))))) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_one.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} num))))))  := sorry --non-trivial
lemma new_lemma_95784 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_95785 (h0 : topological_space (has_norm (random_gen (random_gen linarith.comp_source)))) : totally_separated_space (has_norm (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_95786 (h0 : function.extfun Type ring) : @is_domain.{0} (finset.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (finset.{0} num))  := sorry --non-trivial
lemma new_lemma_95787 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} linarith.ineq (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 monoid.{0}) linarith.ineq)  := sorry --non-trivial
lemma new_lemma_95788 (h0 : complete_lattice (distrib (has_ssubset linarith.ineq))) : complete_lattice.is_Sup_finite_compact (distrib (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_95789 (h6 : add_group (nondiscrete_normed_field linarith.ineq)) : is_add_cyclic (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_95790 (h0 : group (canonically_linear_ordered_monoid name)) : normalizer_condition (canonically_linear_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_95791 (h0 : add_group (comm_ring (has_ssubset char))) : is_add_cyclic (comm_ring (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_95792 (h0 : topological_space (with_one (has_top (has_norm (has_norm empty))))) : totally_disconnected_space (with_one (has_top (has_norm (has_norm empty)))) := sorry --non-trivial
lemma new_lemma_95793 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (canonically_linear_ordered_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_95794 (h0 : list (measurable_space.dynkin_system (semiring (semiring (semiring (semiring (semiring unsigned))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_95795 (h0 : functor.add_const (filter (semigroup Type)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_95796 (h1 : topological_space (mul_one_class linarith.ineq)) (h2 : preorder (mul_one_class linarith.ineq)) : order_topology (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_95797 (h0 : topological_space (mul_zero_class (has_to_string (comm_group (has_to_string pos))))) : sequential_space (mul_zero_class (has_to_string (comm_group (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_95798 (h0 : topological_space (boolean_algebra.core (add_cancel_monoid (has_add (has_add Type))))) : totally_separated_space (boolean_algebra.core (add_cancel_monoid (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_95799 (h0 : ring (has_emptyc (random_gen (random_gen string_imp)))) : is_domain (has_emptyc (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_95800 (h0 : add_monoid (semiring fun_info)) : add_monoid.fg (semiring fun_info) := sorry --non-trivial
lemma new_lemma_95801 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_neg Type)) : @discrete_topology.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_neg.{1} Type) h0) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_95802 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) (boolean_algebra (boolean_algebra Type))) : @regular_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} name)) (boolean_algebra.{1} (boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_95803 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_95804 (h0 : topological_space (normed_comm_ring (has_to_string Type))) : normal_space (normed_comm_ring (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_95805 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (generalized_boolean_algebra.{0} (has_pos_part.{0} linarith.comp)) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (generalized_boolean_algebra.{0} (has_pos_part.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_95806 (h0 : group (has_bot (has_Inf pos))) : is_simple_group (has_bot (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_95807 (h0 : function.extfun Type ring) : @rank_condition.{0} (distrib_lattice.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (distrib_lattice.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_95808 (h0 : functor.add_const (filter (has_add name)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_95809 (h0 : functor.add_const (topological_space (finset congr_arg_kind)) unsigned) : @path_connected_space.{0} (finset.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_95810 (h0 : functor.comp topological_space semigroup name) : @totally_separated_space.{0} (semigroup.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} name h0)  := sorry --non-trivial
lemma new_lemma_95811 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (option.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (option.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_95812 (h0 : functor.add_const (ring (has_neg name)) linarith.comp) : @rank_condition.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_95813 (h0 : topological_space (measurable_space (with_bot (random_gen (with_bot (with_bot string_imp)))))) : totally_separated_space (measurable_space (with_bot (random_gen (with_bot (with_bot string_imp))))) := sorry --non-trivial
lemma new_lemma_95814 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring unsigned)) num) : @rank_condition.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (canonically_ordered_comm_semiring.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_95815 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_95816 (h0 : not (complete_lattice (semiring empty) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_95817 (h0 : functor.add_const (ring (complete_distrib_lattice unsigned)) (option (option unsigned))) : @strong_rank_condition.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} unsigned)) (option.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_95818 (h0 : complete_lattice (boolean_algebra (finset linarith.comp))) : complete_lattice.is_Sup_finite_compact (boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_95819 (h0 : topological_space (normed_comm_ring (option (option ennreal)))) : preirreducible_space (normed_comm_ring (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_95820 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) (ring (has_Inf (has_Inf Type)))) : @path_connected_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} pos)) (ring.{1} (has_Inf.{1} (has_Inf.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_95821 (h0 : functor.comp list mul_zero_class Type) : list.nodup (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_95822 (h0 : functor.comp uniform_space cancel_monoid environment.implicit_infer_kind) : @separated_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} uniform_space.{0} cancel_monoid.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_95823 (h0 : functor.add_const (topological_space (has_to_string unsigned)) pos) : @path_connected_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_95824 (h0 : function.extfun (finset Type) (has_mem.mem (semiring empty))) : @group.fg.{0} (semiring.{0} empty) (@finset.pi.empty.{1 0} Type group.{0} (semiring.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_95825 (h0 : ring (ring (ring Type))) : is_domain (ring (ring Type)) := sorry --non-trivial
lemma new_lemma_95826 (h0 : functor.add_const (filter (mul_zero_class Type)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_95827 (h0 : topological_space (has_bot (has_Inf (has_bot (has_bot (has_Inf real)))))) : irreducible_space (has_bot (has_Inf (has_bot (has_bot (has_Inf real))))) := sorry --non-trivial
lemma new_lemma_95828 (h0 : functor.add_const (topological_space (complete_distrib_lattice empty)) empty) : @locally_compact_space.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_95829 (h0 : functor.add_const (ordered_comm_monoid (normed_comm_ring pos)) (has_to_string environment.implicit_infer_kind)) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (normed_comm_ring.{0} pos)) (has_to_string.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_95830 (h0 : ring (ordered_add_comm_group string_imp)) : rank_condition (ordered_add_comm_group string_imp) := sorry --non-trivial
lemma new_lemma_95831 (h0 : topological_space (semiring (has_top (has_top linarith.comp_source)))) : totally_separated_space (semiring (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_95832 (h0 : functor.add_const (ring (generalized_boolean_algebra linarith.comp)) pos) : @is_domain.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (generalized_boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_95833 (h0 : ring (generalized_boolean_algebra (has_add linarith.comp))) : strong_rank_condition (generalized_boolean_algebra (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_95834 (h0 : topological_space (with_bot (has_top (random_gen fun_info)))) : irreducible_space (with_bot (has_top (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_95835 (h0 : functor.comp ordered_add_comm_monoid comm_group name) : @archimedean.{0} (comm_group.{0} name) (@functor.comp.run.{0 0 0} ordered_add_comm_monoid.{0} comm_group.{0} name h0)  := sorry --non-trivial
lemma new_lemma_95836 (h0 : fin has_zero.zero) : @t1_space.{0} (canonically_ordered_monoid.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_95837 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (linear_ordered_field.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} num))  := sorry --non-trivial
lemma new_lemma_95838 (h1 : topological_space (normed_group char)) : totally_disconnected_space (normed_group char) := sorry --non-trivial
lemma new_lemma_95839 (h0 : group (normed_field (comm_ring (has_nnnorm linarith.comp_source)))) : is_cyclic (normed_field (comm_ring (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_95840 (h0 : topological_space (has_norm (distrib string_imp))) : path_connected_space (has_norm (distrib string_imp)) := sorry --non-trivial
lemma new_lemma_95841 (h0 : ring (ring (boolean_algebra (boolean_algebra Type)))) : is_domain (ring (boolean_algebra (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_95842 (h0 : filter (left_cancel_semigroup (semiring (semiring (semiring unsigned))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_95843 (h2 : add_group (has_ssubset reducibility_hints)) : is_add_cyclic (has_ssubset reducibility_hints) := sorry --non-trivial
lemma new_lemma_95844 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_95845 (h0 : functor.add_const (function.extfun Type group) (has_neg (has_neg Type))) : @is_cyclic.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) (has_neg.{1} (has_neg.{1} Type)) h0) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_95846 (h0 : topological_space (semiring (semiring (with_bot empty)))) : totally_disconnected_space (semiring (semiring (with_bot empty))) := sorry --non-trivial
lemma new_lemma_95847 (h0 : ring (has_append linarith.comp_source)) : strong_rank_condition (has_append linarith.comp_source) := sorry --non-trivial
lemma new_lemma_95848 (h0 : filter (random_gen (random_gen (random_gen to_additive.value_type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_95849 (h0 : not (uniform_space (metric_space empty) -> false)) : @separated_space.{0} (metric_space.{0} empty) (@classical.by_contradiction'.{1} (uniform_space.{0} (metric_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_95850 (h0 : functor.add_const (add_group (measurable_space.dynkin_system empty)) num) : @is_add_cyclic.{0} (measurable_space.dynkin_system.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (measurable_space.dynkin_system.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_95851 (h0 : add_group (has_ssubset (random_gen to_additive.value_type))) : is_add_cyclic (has_ssubset (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_95852 (h0 : group (has_add (comm_semigroup (has_bot (sub_neg_monoid pos))))) : normalizer_condition (has_add (comm_semigroup (has_bot (sub_neg_monoid pos)))) := sorry --non-trivial
lemma new_lemma_95853 (h0 : not (add_group (linear_ordered_add_comm_group to_additive.value_type) -> false)) : @is_add_cyclic.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (add_group.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_95854 (h0 : ring (has_neg unsigned)) : is_principal_ideal_ring (has_neg unsigned) := sorry --non-trivial
lemma new_lemma_95855 (h0 : set (uniform_space reducibility_hints)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_95856 (h0 : ring (has_nndist pos)) : rank_condition (has_nndist pos) := sorry --non-trivial
lemma new_lemma_95857 (h0 : topological_space (semigroup (cancel_monoid pos))) : t0_space (semigroup (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_95858 (h0 : ring (non_unital_non_assoc_semiring string.iterator_imp)) : rank_condition (non_unital_non_assoc_semiring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_95859 (h0 : topological_space (boolean_algebra Type)) : path_connected_space (boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_95860 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_simple_group.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (group.{1} (canonically_linear_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_95861 (h0 : functor.add_const (group (filter empty)) empty) : @normalizer_condition.{0} (filter.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (filter.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_95862 (h0 : topological_space (with_bot (has_norm linarith.comp_source))) : t0_space (with_bot (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_95863 (h0 : ring (finset (has_add ennreal))) : rank_condition (finset (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_95864 (h0 : fin (nat.succ has_zero.zero)) (h1 : ne h0 has_zero.zero) : matrix.vec_empty (fin.pred h0 h1) := sorry --non-trivial
lemma new_lemma_95865 (h0 : ring (cancel_monoid (has_add (has_add pos)))) : strong_rank_condition (cancel_monoid (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_95866 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_95867 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_95868 (h0 : ring (option num)) : rank_condition (option num) := sorry --non-trivial
lemma new_lemma_95869 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_95870 (h0 : topological_space (complete_linear_order (semiring (has_top (semiring empty))))) : locally_compact_space (complete_linear_order (semiring (has_top (semiring empty)))) := sorry --non-trivial
lemma new_lemma_95871 (h0 : pseudo_metric_space (has_dist ennreal)) (h1 : add_monoid (has_dist ennreal)) : has_lipschitz_add (has_dist ennreal) := sorry --non-trivial
lemma new_lemma_95872 (h0 : topological_space (has_nndist (linear_ordered_semiring name))) : t0_space (has_nndist (linear_ordered_semiring name)) := sorry --non-trivial
lemma new_lemma_95873 (h0 : prod (add_comm_monoid (option (option ennreal))) (add_comm_monoid (option (option ennreal)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_95874 (h0 : complete_lattice (normed_group empty)) : is_compactly_generated (normed_group empty) := sorry --non-trivial
lemma new_lemma_95875 (h0 : complete_lattice (semigroup environment.implicit_infer_kind)) : is_atomistic (semigroup environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_95876 (h0 : topological_space (has_top (random_gen linarith.comp))) : locally_compact_space (has_top (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_95877 (h0 : topological_space (random_gen (has_top (semiring unsigned)))) : discrete_topology (random_gen (has_top (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_95878 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @archimedean.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ordered_add_comm_monoid.{1}) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_95879 (h2 : topological_space (add_comm_semigroup (add_comm_semigroup ereal))) : totally_disconnected_space (add_comm_semigroup (add_comm_semigroup ereal)) := sorry --non-trivial
lemma new_lemma_95880 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_95881 (h0 : uniform_space std_gen) : complete_space std_gen := sorry --non-trivial
lemma new_lemma_95882 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_top.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} char))  := sorry --non-trivial
lemma new_lemma_95883 (h0 : group (has_Inf name)) : is_simple_group (has_Inf name) := sorry --non-trivial
lemma new_lemma_95884 (h0 : list (has_Inf pos)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_95885 (h0 : not (list linarith.comp_source -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_95886 (h0 : functor.add_const (topological_space (partial_order num)) empty) : @t1_space.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_95887 (h0 : filter (simple_graph empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_95888 (h0 : uniform_space (has_emptyc (random_gen linarith.comp))) : separated_space (has_emptyc (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_95889 (h0 : functor.add_const (add_group (generalized_boolean_algebra linarith.comp)) (has_Inf linarith.comp)) : @is_add_cyclic.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (generalized_boolean_algebra.{0} linarith.comp)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_95890 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_95891 (h0 : uniform_space (linear_ordered_add_comm_group (with_bot string_imp))) : complete_space (linear_ordered_add_comm_group (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_95892 (h0 : topological_space (normed_comm_ring (has_add environment.implicit_infer_kind))) : path_connected_space (normed_comm_ring (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_95893 (h0 : topological_space (mul_zero_class (has_add (finset name)))) : path_connected_space (mul_zero_class (has_add (finset name))) := sorry --non-trivial
lemma new_lemma_95894 (h0 : topological_space (monoid (option empty))) : totally_disconnected_space (monoid (option empty)) := sorry --non-trivial
lemma new_lemma_95895 (h0 : finset (cancel_monoid pos)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_95896 (h0 : pnat) (h1 : fin has_zero.zero) : pnat.coprime h0 (matrix.vec_empty (matrix.vec_empty (matrix.vec_empty (matrix.vec_empty h1)))) := sorry --non-trivial
lemma new_lemma_95897 (h0 : function.extfun (Type 1) ordered_add_comm_monoid) : @archimedean.{1} (canonically_linear_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} h0 (canonically_linear_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_95898 (h0 : not (group (linear_ordered_semiring linarith.ineq) -> false)) : @normalizer_condition.{0} (linear_ordered_semiring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_semiring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_95899 (h0 : topological_space (normed_comm_ring (ring unsigned))) : topological_space.separable_space (normed_comm_ring (ring unsigned)) := sorry --non-trivial
lemma new_lemma_95900 (h0 : uniform_space (comm_monoid empty)) : complete_space (comm_monoid empty) := sorry --non-trivial
lemma new_lemma_95901 (h0 : topological_space (has_neg_part (has_neg_part pos))) : totally_separated_space (has_neg_part (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_95902 (h0 : functor.add_const (topological_space (semigroup num)) empty) : @topological_space.separable_space.{0} (semigroup.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_95903 (h0 : function.extfun Type (functor.comp topological_space cancel_monoid)) : @t0_space.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} cancel_monoid.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_95904 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) name) : @unique_factorization_monoid.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) name h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_95905 (h0 : complete_lattice (ring (boolean_algebra.core linarith.comp))) : is_atomistic (ring (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_95906 (h0 : topological_space (has_Sup empty)) : loc_path_connected_space (has_Sup empty) := sorry --non-trivial
lemma new_lemma_95907 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_add unsigned)) Type) : @unique_factorization_monoid.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (has_add.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_95908 (h0 : group (distrib_lattice (with_bot string_imp))) : normalizer_condition (distrib_lattice (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_95909 (h0 : functor.add_const (ordered_comm_monoid (add_cancel_monoid Type)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (add_cancel_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_95910 (h0 : function.extfun Type ring) : @is_domain.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_95911 (h0 : topological_space (has_zero (has_to_string (has_to_string environment.implicit_infer_kind)))) : irreducible_space (has_zero (has_to_string (has_to_string environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_95912 (h0 : not (ring (simple_graph reducibility_hints) -> false)) : @rank_condition.{0} (simple_graph.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (simple_graph.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_95913 (h1 : topological_space (mul_one_class (add_comm_semigroup fun_info))) : t0_space (mul_one_class (add_comm_semigroup fun_info)) := sorry --non-trivial
lemma new_lemma_95914 (h0 : functor.add_const (group (ordered_comm_monoid name)) linarith.comp) : @is_simple_group.{0} (ordered_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (ordered_comm_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_95915 (h0 : functor.add_const (functor.add_const (ring (ring name)) (has_nndist (has_Inf name))) name) : @strong_rank_condition.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} name)) (has_nndist.{0} (has_Inf.{0} name)) (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ring.{0} (ring.{0} name)) (has_nndist.{0} (has_Inf.{0} name))) name h0))  := sorry --non-trivial
lemma new_lemma_95916 (h1 : uniform_space (metric_space linarith.comp)) : complete_space (metric_space linarith.comp) := sorry --non-trivial
lemma new_lemma_95917 (h0 : topological_space (mul_zero_class (has_add environment.implicit_infer_kind))) : preconnected_space (mul_zero_class (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_95918 (h0 : functor.add_const (topological_space (has_to_string name)) name) : @regular_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_95919 (h1 : ring (comm_ring char)) : is_domain (comm_ring char) := sorry --non-trivial
lemma new_lemma_95920 (h0 : topological_space (linear_order unsigned)) : preirreducible_space (linear_order unsigned) := sorry --non-trivial
lemma new_lemma_95921 (h0 : ring (has_bot (has_neg (has_neg (has_Inf name))))) : strong_rank_condition (has_bot (has_neg (has_neg (has_Inf name)))) := sorry --non-trivial
lemma new_lemma_95922 (h0 : topological_space (measurable_space (semiring congr_arg_kind))) : preirreducible_space (measurable_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_95923 (h0 : topological_space (semilattice_inf num)) : preirreducible_space (semilattice_inf num) := sorry --non-trivial
lemma new_lemma_95924 (h0 : uniform_space (canonically_ordered_add_monoid (option (option empty)))) : complete_space (canonically_ordered_add_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_95925 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (has_add.{0} pos) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (has_add.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_95926 (h0 : functor.add_const (complete_lattice (ring linarith.comp)) pos) : @is_atomistic.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_95927 (h0 : monoid (measurable_space (has_top (has_top num)))) : monoid.fg (measurable_space (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_95928 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) name) : @preconnected_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_95929 (h0 : functor.comp ring comm_group name) : @strong_rank_condition.{0} (comm_group.{0} name) (@functor.comp.run.{0 0 0} ring.{0} comm_group.{0} name h0)  := sorry --non-trivial
lemma new_lemma_95930 (h0 : function.extfun Type uniform_space) : @separated_space.{0} num (@function.extfun_app.{2 1} Type uniform_space.{0} h0 num)  := sorry --non-trivial
lemma new_lemma_95931 (h0 : functor.add_const (topological_space (boolean_algebra Type)) pos) : @loc_path_connected_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_95932 (h0 : ring (boolean_algebra.core (finset (finset name)))) : strong_rank_condition (boolean_algebra.core (finset (finset name))) := sorry --non-trivial
lemma new_lemma_95933 (h0 : not (complete_lattice (option congr_arg_kind) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (option.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (option.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_95934 (h0 : monoid (finset (has_add linarith.comp))) : monoid.fg (finset (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_95935 (h0 : filter (has_edist (option (option (option (option unsigned)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_95936 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @irreducible_space.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_95937 (h0 : topological_space (add_cancel_comm_monoid (has_nnnorm char))) : t0_space (add_cancel_comm_monoid (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_95938 (h0 : uniform_space (comm_group linarith.comp)) : separated_space (comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_95939 (h0 : topological_space (as_linear_order congr_arg_kind)) : discrete_topology (as_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_95940 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_95941 (h0 : prod (has_nndist (option (option num))) (has_nndist (option (option num)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_95942 (h0 : topological_space num) : preconnected_space num := sorry --non-trivial
lemma new_lemma_95943 (h0 : not (topological_space (measure_theory.measure_space congr_arg_kind) -> false)) : @totally_disconnected_space.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (measure_theory.measure_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_95944 (h0 : complete_lattice (has_norm (random_gen (random_gen to_additive.value_type)))) : is_atomistic (has_norm (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_95945 (h1 : semiring (add_comm_semigroup (mul_one_class std_gen))) (h2 : ideal (add_comm_semigroup (mul_one_class std_gen))) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_95946 (h0 : topological_space (has_neg_part linarith.comp)) : normal_space (has_neg_part linarith.comp) := sorry --non-trivial
lemma new_lemma_95947 (h0 : fin has_zero.zero) : @preconnected_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_95948 (h0 : functor.add_const (list (has_dist unsigned)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_95949 (h0 : topological_space (ring (has_Inf linarith.comp))) : locally_compact_space (ring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_95950 (h2 : topological_space (has_div to_additive.value_type)) : t0_space (has_div to_additive.value_type) := sorry --non-trivial
lemma new_lemma_95951 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @topological_space.separable_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_95952 (h0 : function.extfun Type topological_space) : @t1_space.{0} (linear_ordered_field.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} num))  := sorry --non-trivial
lemma new_lemma_95953 (h1 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_95954 (h0 : ring (boolean_algebra.core (semigroup (add_comm_monoid environment.implicit_infer_kind)))) : is_domain (boolean_algebra.core (semigroup (add_comm_monoid environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_95955 (h0 : topological_space (canonically_ordered_comm_semiring (option name))) : t1_space (canonically_ordered_comm_semiring (option name)) := sorry --non-trivial
lemma new_lemma_95956 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_nnnorm.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nnnorm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_95957 (h0 : complete_lattice (group_with_zero ennreal)) : complete_lattice.is_Sup_finite_compact (group_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_95958 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) pos) : @path_connected_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_95959 (h0 : topological_space (has_bot (has_add real))) : totally_disconnected_space (has_bot (has_add real)) := sorry --non-trivial
lemma new_lemma_95960 (h0 : function.extfun Type (prod (ordered_ring num))) : id_rel (function.extfun_app h0 (ordered_ring num)) := sorry --non-trivial
lemma new_lemma_95961 (h0 : topological_space (with_zero (distrib_lattice string_imp))) : t0_space (with_zero (distrib_lattice string_imp)) := sorry --non-trivial
lemma new_lemma_95962 (h0 : not (ring (add_left_cancel_monoid linarith.comp_source) -> false)) : @is_domain.{0} (add_left_cancel_monoid.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (add_left_cancel_monoid.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_95963 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @is_simple_group.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_95964 (h0 : list (comm_monoid empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_95965 (h0 : topological_space (linear_ordered_field (has_neg_part Type))) : loc_path_connected_space (linear_ordered_field (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_95966 (h0 : functor.add_const (list (has_edist unsigned)) num) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_95967 (h0 : group (metric_space (metric_space num))) : group.fg (metric_space (metric_space num)) := sorry --non-trivial
lemma new_lemma_95968 (h0 : topological_space (comm_semigroup (has_add real))) : sequential_space (comm_semigroup (has_add real)) := sorry --non-trivial
lemma new_lemma_95969 (h0 : list (ring (ring (ring pos)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_95970 (h1 : monoid (has_emptyc to_additive.value_type)) : monoid.fg (has_emptyc to_additive.value_type) := sorry --non-trivial
lemma new_lemma_95971 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_95972 (h0 : not (topological_space (linear_ordered_semiring num) -> false)) : @discrete_topology.{0} (linear_ordered_semiring.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_95973 (h0 : functor.add_const (complete_lattice (linear_order empty)) empty) : @is_atomistic.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_95974 (h0 : function.extfun Type (functor.add_const (complete_lattice (ring ennreal)))) : @is_atomistic.{0} (ring.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} ennreal)) ennreal (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (ring.{0} ennreal))) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_95975 (h0 : topological_space (lattice (option unsigned))) : path_connected_space (lattice (option unsigned)) := sorry --non-trivial
lemma new_lemma_95976 (h0 : functor.add_const (group (complete_distrib_lattice empty)) (option (option (option empty)))) : @is_cyclic.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} empty)) (option.{0} (option.{0} (option.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_95977 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_95978 (h0 : topological_space (semiring (random_gen num))) : totally_separated_space (semiring (random_gen num)) := sorry --non-trivial
lemma new_lemma_95979 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_95980 (h0 : functor.add_const (complete_lattice (has_neg Type)) (has_neg linarith.comp)) : @complete_lattice.is_Sup_finite_compact.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_neg.{1} Type)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_95981 (h0 : function.extfun (Type 1) group) : @is_cyclic.{1} (plift.{1} num) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (plift.{1} num))  := sorry --non-trivial
lemma new_lemma_95982 (h0 : topological_space (semi_normed_comm_ring reducibility_hints)) : path_connected_space (semi_normed_comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_95983 (h0 : functor.add_const (function.extfun Type group) name) : @is_cyclic.{0} (has_nndist.{0} (option.{0} name)) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) name h0) (has_nndist.{0} (option.{0} name)))  := sorry --non-trivial
lemma new_lemma_95984 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_95985 (h0 : function.extfun (Type 1) (functor.comp topological_space has_neg_part)) : @sequential_space.{1} (has_neg_part.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_neg_part.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} has_neg_part.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_95986 (h0 : monoid (semiring (has_norm congr_arg_kind))) : monoid.fg (semiring (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_95987 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring linarith.comp)) pos) : @loc_path_connected_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_95988 (h0 : topological_space (with_one (semiring (semiring (semiring unsigned))))) : normal_space (with_one (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_95989 (h0 : function.extfun Type group) : @is_simple_group.{0} (add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_95990 (h0 : list (has_zero (has_to_string linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_95991 (h0 : function.extfun Type group) : @group.fg.{0} (topological_space.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (topological_space.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_95992 (h0 : not (topological_space unsigned -> false)) : @t1_space.{0} unsigned (@classical.by_contradiction'.{1} (topological_space.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_95993 (h0 : function.extfun (Type 1) group) : @is_simple_group.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_95994 (h0 : uniform_space (random_gen (mul_one_class linarith.comp_source))) : complete_space (random_gen (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_95995 (h0 : topological_space (has_add (has_add unsigned))) : regular_space (has_add (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_95996 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_add num)) := sorry --non-trivial
lemma new_lemma_95997 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (left_cancel_monoid.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (left_cancel_monoid.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_95998 (h0 : group (semigroup (has_add Type))) : normalizer_condition (semigroup (has_add Type)) := sorry --non-trivial
lemma new_lemma_95999 (h0 : topological_space (boolean_algebra (ordered_comm_monoid name))) : locally_compact_space (boolean_algebra (ordered_comm_monoid name)) := sorry --non-trivial
