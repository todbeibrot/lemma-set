import imports
lemma new_lemma_136000 (h0 : functor.comp topological_space mul_zero_class pos) : @discrete_topology.{0} (mul_zero_class.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_136001 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @group.fg.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_136002 (h0 : topological_space (has_to_string (semigroup Type))) : totally_disconnected_space (has_to_string (semigroup Type)) := sorry --non-trivial
lemma new_lemma_136003 (h0 : list (has_inner (distrib_lattice empty) unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_136004 (h0 : cancel_comm_monoid_with_zero (add_cancel_comm_monoid (option (option unsigned)))) : unique_factorization_monoid (add_cancel_comm_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_136005 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) Type) : @totally_separated_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_136006 (h0 : not (topological_space (denumerable string_imp) -> false)) : @t0_space.{0} (denumerable.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_136007 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_136008 (h0 : functor.add_const (monoid (finset linarith.comp)) linarith.comp) : @monoid.fg.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (finset.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_136009 (h0 : ring (complete_distrib_lattice Type)) : strong_rank_condition (complete_distrib_lattice Type) := sorry --non-trivial
lemma new_lemma_136010 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (@id.{2} Type linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} h0 (@id.{2} Type linarith.ineq))  := sorry --non-trivial
lemma new_lemma_136011 (h0 : function.extfun Type topological_space) : @t1_space.{0} (filter.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (filter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_136012 (h0 : uniform_space (measurable_space (has_inv linarith.comp_source))) : complete_space (measurable_space (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_136013 (h0 : group (ring (has_neg name))) : is_simple_group (ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_136014 (h0 : functor.comp uniform_space pseudo_metric_space (option pos)) : @separated_space.{0} (pseudo_metric_space.{0} (option.{0} pos)) (@functor.comp.run.{0 0 0} uniform_space.{0} pseudo_metric_space.{0} (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_136015 (h0 : functor.add_const (topological_space (semigroup empty)) (option empty)) : @normal_space.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_136016 (h0 : topological_space (encodable (dlist (has_norm to_additive.value_type)))) : totally_disconnected_space (encodable (dlist (has_norm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_136017 (h0 : topological_space (add_cancel_monoid (finset (has_add Type)))) : sequential_space (add_cancel_monoid (finset (has_add Type))) := sorry --non-trivial
lemma new_lemma_136018 (h0 : functor.add_const (topological_space (ordered_cancel_add_comm_monoid empty)) (option num)) : @discrete_topology.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_cancel_add_comm_monoid.{0} empty)) (option.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_136019 (h0 : uniform_space (non_unital_non_assoc_semiring char)) : complete_space (non_unital_non_assoc_semiring char) := sorry --non-trivial
lemma new_lemma_136020 (h0 : not (topological_space (semiring linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_136021 (h1 : ring (topological_space (has_ssubset (random_gen string_imp)))) : strong_rank_condition (topological_space (has_ssubset (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_136022 (h0 : prod (mul_zero_class (option pos)) (mul_zero_class (option pos))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_136023 (h0 : functor.add_const (add_group (free_add_monoid unsigned)) empty) : @is_add_cyclic.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (free_add_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_136024 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_136025 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @loc_path_connected_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_136026 (h0 : topological_space (semigroup environment.implicit_infer_kind)) : path_connected_space (semigroup environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_136027 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @separated_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 uniform_space.{1}) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_136028 (h0 : uniform_space (normed_field (mul_one_class linarith.ineq))) : complete_space (normed_field (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_136029 (h0 : group (has_to_string (has_zero linarith.comp))) : normalizer_condition (has_to_string (has_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_136030 (h0 : function.extfun (finset Type) (has_mem.mem (with_one num))) : @rank_condition.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (with_one.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_136031 (h0 : ring (normed_field environment.projection_info)) : is_domain (normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_136032 (h0 : topological_space (has_to_string (cancel_monoid linarith.comp))) : preirreducible_space (has_to_string (cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_136033 (h0 : functor.add_const (topological_space (semigroup unsigned)) pos) : @sequential_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_136034 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @loc_path_connected_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_136035 (h0 : function.extfun (Type 1) ordered_add_comm_monoid) : @archimedean.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} h0 (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_136036 (h0 : add_group (finset (has_add (has_add linarith.comp)))) : is_add_cyclic (finset (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_136037 (h3 : ring (normed_field to_additive.value_type)) : strong_rank_condition (normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_136038 (h0 : has_mem.mem (with_bot linarith.comp) has_emptyc.emptyc) : @strong_rank_condition.{0} (with_bot.{0} linarith.comp) (@finset.pi.empty.{1 0} Type ring.{0} (with_bot.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_136039 (h1 : not (add_group (uniform_space string_imp) -> false)) : @is_add_cyclic.{0} (uniform_space.{0} string_imp) (@classical.by_contradiction'.{1} (add_group.{0} (uniform_space.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_136040 (h0 : topological_space (generalized_boolean_algebra (has_neg Type))) : discrete_topology (generalized_boolean_algebra (has_neg Type)) := sorry --non-trivial
lemma new_lemma_136041 (h0 : functor.add_const (complete_lattice (canonically_ordered_monoid Type)) pos) : @is_compactly_generated.{1} (canonically_ordered_monoid.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (canonically_ordered_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_136042 (h0 : function.extfun Type (functor.add_const (topological_space (generalized_boolean_algebra empty)))) : @normal_space.{0} (generalized_boolean_algebra.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} empty)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} empty))) h0 num))  := sorry --non-trivial
lemma new_lemma_136043 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (has_sub.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_sub.{0} num))  := sorry --non-trivial
lemma new_lemma_136044 (h0 : topological_space (measurable_space (random_gen fun_info))) : irreducible_space (measurable_space (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_136045 (h0 : not (function.extfun (finset Type) (has_mem.mem (complete_semilattice_Sup fun_info)) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (complete_semilattice_Sup.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} fun_info)) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} fun_info))) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_136046 (h0 : functor.add_const (add_monoid (generalized_boolean_algebra Type)) (has_nndist Type)) : @add_monoid.fg.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (add_monoid.{1} (generalized_boolean_algebra.{1} Type)) (has_nndist.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_136047 (h0 : complete_lattice (has_top (has_norm (has_norm linarith.comp)))) : complete_lattice.is_Sup_finite_compact (has_top (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_136048 (h0 : topological_space (has_Inf (ring linarith.comp))) : regular_space (has_Inf (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_136049 (h0 : topological_space (cancel_monoid (boolean_algebra name))) : locally_compact_space (cancel_monoid (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_136050 (h0 : functor.add_const (cancel_comm_monoid_with_zero pos) Type) : @unique_factorization_monoid.{0} pos (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} pos) Type h0)  := sorry --non-trivial
lemma new_lemma_136051 (h0 : functor.comp topological_space finset pos) : @sequential_space.{0} (finset.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_136052 (h0 : list (normed_group (has_inv (has_inv (has_inv (has_inv (has_inv (has_inv (has_inv to_additive.value_type))))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_136053 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_136054 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @is_simple_group.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_136055 (h0 : topological_space (ring (has_neg environment.implicit_infer_kind))) : regular_space (ring (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_136056 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_inter.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} num))  := sorry --non-trivial
lemma new_lemma_136057 (h1 : has_lt (mul_one_class environment.projection_info)) : no_max_order (mul_one_class environment.projection_info) := sorry --non-trivial
lemma new_lemma_136058 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_136059 (h0 : semiring (ring (has_add (has_add linarith.comp)))) : is_noetherian_ring (ring (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_136060 (h0 : topological_space (comm_monoid (semiring (semiring (semiring (semiring (semiring (semiring unsigned)))))))) : t0_space (comm_monoid (semiring (semiring (semiring (semiring (semiring (semiring unsigned))))))) := sorry --non-trivial
lemma new_lemma_136061 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @rank_condition.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (complete_distrib_lattice.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_136062 (h0 : monoid (id (has_top (has_top fun_info)))) : monoid.fg (id (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_136063 (h0 : functor.add_const (ring (boolean_algebra.core environment.implicit_infer_kind)) (has_neg_part pos)) : @rank_condition.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) (has_neg_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_136064 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @preirreducible_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_136065 (h1 : topological_space (add_left_cancel_monoid bool)) : t0_space (add_left_cancel_monoid bool) := sorry --non-trivial
lemma new_lemma_136066 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) h0) (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_136067 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (linear_ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_136068 (h0 : functor.add_const (topological_space (has_neg name)) Type) : @totally_disconnected_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_136069 (h0 : set (has_add ennreal)) (h1 : set.infinite h0 -> set.infinite h0 -> Prop) : reflexive h1 := sorry --non-trivial
lemma new_lemma_136070 (h0 : topological_space (cancel_monoid (mul_zero_class Type))) : totally_disconnected_space (cancel_monoid (mul_zero_class Type)) := sorry --non-trivial
lemma new_lemma_136071 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) environment.implicit_infer_kind) : @loc_path_connected_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_136072 (h0 : group (has_star (semiring empty))) : normalizer_condition (has_star (semiring empty)) := sorry --non-trivial
lemma new_lemma_136073 (h0 : functor.add_const (topological_space (has_neg_part pos)) pos) : @topological_space.separable_space.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_136074 (h2 : has_lt (nondiscrete_normed_field linarith.ineq)) : no_max_order (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_136075 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) (has_add name)) : @irreducible_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_136076 (h0 : topological_space (linear_ordered_comm_group (option (option ennreal)))) : preconnected_space (linear_ordered_comm_group (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_136077 (h0 : functor.add_const (ordered_add_comm_monoid (has_nndist Type)) linarith.comp) : @archimedean.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (has_nndist.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_136078 (h0 : topological_space (has_ssubset to_additive.value_type)) (h1 : preorder (has_ssubset to_additive.value_type)) : order_closed_topology (has_ssubset to_additive.value_type) := sorry --non-trivial
lemma new_lemma_136079 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_136080 (h0 : topological_space (has_zero (option ennreal))) : preirreducible_space (has_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_136081 (h0 : not (ring (has_lt string.iterator_imp) -> false)) : @strong_rank_condition.{0} (has_lt.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (ring.{0} (has_lt.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_136082 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_136083 (h1 : group (has_lt char)) : is_cyclic (has_lt char) := sorry --non-trivial
lemma new_lemma_136084 (h0 : semiring (has_neg (ring environment.implicit_infer_kind))) : is_noetherian_ring (has_neg (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_136085 (h1 : ring (complete_semilattice_Sup linarith.comp)) : strong_rank_condition (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_136086 (h0 : topological_space (has_nnnorm std_gen)) : path_connected_space (has_nnnorm std_gen) := sorry --non-trivial
lemma new_lemma_136087 (h0 : list (normed_comm_ring (finset (ring linarith.comp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_136088 (h0 : functor.add_const (function.extfun Type finset) linarith.comp) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_136089 (h0 : add_group (has_nnnorm environment.projection_info)) : is_add_cyclic (has_nnnorm environment.projection_info) := sorry --non-trivial
lemma new_lemma_136090 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} linarith.ineq (@function.extfun_app.{2 1} Type topological_space.{0} h0 linarith.ineq)  := sorry --non-trivial
lemma new_lemma_136091 (h0 : functor.add_const (add_group (finset pos)) pos) : @is_add_cyclic.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (finset.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_136092 (h0 : topological_space (comm_ring (has_ssubset fun_info))) : t0_space (comm_ring (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_136093 (h0 : topological_space (canonically_ordered_comm_semiring (option pos))) : t0_space (canonically_ordered_comm_semiring (option pos)) := sorry --non-trivial
lemma new_lemma_136094 (h0 : list unsigned) : palindrome h0 := sorry --non-trivial
lemma new_lemma_136095 (h0 : not (ring (has_append fun_info) -> false)) : @strong_rank_condition.{0} (has_append.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (has_append.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_136096 (h0 : topological_space (has_le linarith.ineq)) : path_connected_space (has_le linarith.ineq) := sorry --non-trivial
lemma new_lemma_136097 (h0 : functor.add_const (topological_space (has_nndist name)) name) : @normal_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_136098 (h0 : has_mem.mem finset has_emptyc.emptyc) : finset.nonempty (function.extfun_app (finset.pi.empty (function.extfun Type) finset h0) (id empty)) := sorry --non-trivial
lemma new_lemma_136099 (h0 : functor.add_const (topological_space (semiring num)) (semiring (semiring empty))) : @loc_path_connected_space.{0} (semiring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} num)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_136100 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_136101 (h0 : ring (has_neg (finset (has_zero pos)))) : rank_condition (has_neg (finset (has_zero pos))) := sorry --non-trivial
lemma new_lemma_136102 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (finset.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (finset.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_136103 (h0 : fin has_zero.zero) : @t0_space.{1} (has_Inf.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_Inf.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_136104 (h0 : not (add_group (complete_semilattice_Sup empty) -> false)) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} empty) (@classical.by_contradiction'.{1} (add_group.{0} (complete_semilattice_Sup.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_136105 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_star.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_star.{0} num))  := sorry --non-trivial
lemma new_lemma_136106 (h0 : function.extfun (Type 1) topological_space) : @totally_separated_space.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_136107 (h0 : topological_space (has_pos_part (has_add (has_Inf pos)))) : preconnected_space (has_pos_part (has_add (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_136108 (h0 : functor.add_const (ordered_comm_monoid (canonically_ordered_monoid linarith.comp)) pos) : @has_exists_mul_of_le.{0} (canonically_ordered_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (canonically_ordered_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_136109 (h0 : functor.add_const (complete_lattice (free_add_monoid congr_arg_kind)) congr_arg_kind) : @complete_lattice.is_Sup_finite_compact.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (free_add_monoid.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_136110 (h2 : topological_space (has_ssubset to_additive.value_type)) : path_connected_space (has_ssubset to_additive.value_type) := sorry --non-trivial
lemma new_lemma_136111 (h0 : ring (linear_ordered_semiring (semiring (semiring linarith.comp)))) : strong_rank_condition (linear_ordered_semiring (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_136112 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (dlist.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (dlist.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_136113 (h0 : group (has_union (semiring congr_arg_kind))) : group.fg (has_union (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_136114 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (denumerable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (denumerable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_136115 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_136116 (h0 : add_group (uniform_space (random_gen string.iterator_imp))) : is_add_cyclic (uniform_space (random_gen string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_136117 (h0 : functor.add_const (topological_space (monoid unsigned)) num) : @irreducible_space.{0} (monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_136118 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_136119 (h0 : functor.add_const (group (bin_tree congr_arg_kind)) (comm_monoid congr_arg_kind)) : @is_cyclic.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (bin_tree.{0} congr_arg_kind)) (comm_monoid.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_136120 (h0 : topological_space (normed_comm_ring (comm_group (comm_group pos)))) : loc_path_connected_space (normed_comm_ring (comm_group (comm_group pos))) := sorry --non-trivial
lemma new_lemma_136121 (h0 : ordered_add_comm_monoid (normed_lattice_add_comm_group (has_add real))) : archimedean (normed_lattice_add_comm_group (has_add real)) := sorry --non-trivial
lemma new_lemma_136122 (h2 : add_group empty) : is_add_cyclic empty := sorry --non-trivial
lemma new_lemma_136123 (h0 : functor.comp ring comm_group name) : @is_domain.{0} (comm_group.{0} name) (@functor.comp.run.{0 0 0} ring.{0} comm_group.{0} name h0)  := sorry --non-trivial
lemma new_lemma_136124 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (normed_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (normed_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_136125 (h0 : functor.add_const (function.extfun Type group) (has_add linarith.comp)) : @is_simple_group.{0} pos (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) (has_add.{0} linarith.comp) h0) pos)  := sorry --non-trivial
lemma new_lemma_136126 (h0 : topological_space (random_gen empty)) : normal_space (random_gen empty) := sorry --non-trivial
lemma new_lemma_136127 (h0 : topological_space (linear_ordered_field (option (option pos)))) : normal_space (linear_ordered_field (option (option pos))) := sorry --non-trivial
lemma new_lemma_136128 (h0 : topological_space (normed_group (random_gen char))) : t0_space (normed_group (random_gen char)) := sorry --non-trivial
lemma new_lemma_136129 (h0 : topological_space (nondiscrete_normed_field environment.projection_info)) : path_connected_space (nondiscrete_normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_136130 (h0 : set (enat -> string.iterator_imp)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_136131 (h0 : function.extfun (Type 1) topological_space) : @topological_space.separable_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_136132 (h0 : ring (has_edist unsigned)) : strong_rank_condition (has_edist unsigned) := sorry --non-trivial
lemma new_lemma_136133 (h0 : list (add_semigroup (option empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_136134 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (generalized_boolean_algebra.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} empty))  := sorry --non-trivial
lemma new_lemma_136135 (h0 : not (ring (topological_space (has_ssubset (has_ssubset linarith.comp_source))) -> false)) : @strong_rank_condition.{0} (topological_space.{0} (has_ssubset.{0} (has_ssubset.{0} linarith.comp_source))) (@classical.by_contradiction'.{1} (ring.{0} (topological_space.{0} (has_ssubset.{0} (has_ssubset.{0} linarith.comp_source)))) h0)  := sorry --non-trivial
lemma new_lemma_136136 (h0 : set (has_div (mul_one_class linarith.comp_source))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_136137 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) num)  := sorry --non-trivial
lemma new_lemma_136138 (h0 : group (has_to_string (finset (finset Type)))) : is_simple_group (has_to_string (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_136139 (h0 : filter (add_cancel_monoid (has_neg linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_136140 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space unsigned))) : @rank_condition.{0} (measurable_space.{0} unsigned) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} unsigned) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} unsigned)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_136141 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) pos) : @regular_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_136142 (h0 : group (has_div char)) : is_cyclic (has_div char) := sorry --non-trivial
lemma new_lemma_136143 (h0 : ring (canonically_linear_ordered_monoid (has_neg name))) : rank_condition (canonically_linear_ordered_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_136144 (h0 : functor.add_const (function.extfun Type group) Type) : @normalizer_condition.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_136145 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_to_string pos)) name) : @unique_factorization_monoid.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_to_string.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_136146 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) (finset (finset linarith.comp))) : @normal_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) (finset.{0} (finset.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_136147 (h1 : add_group (has_compl std_gen)) : is_add_cyclic (has_compl std_gen) := sorry --non-trivial
lemma new_lemma_136148 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_136149 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_136150 (h0 : semiring (ring (has_neg (ring Type)))) : is_noetherian_ring (ring (has_neg (ring Type))) := sorry --non-trivial
lemma new_lemma_136151 (h0 : ring (filter unsigned)) : is_domain (filter unsigned) := sorry --non-trivial
lemma new_lemma_136152 (h0 : functor.add_const (function.extfun (Type 1) semiring) pos) : @is_noetherian_ring.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) semiring.{1}) pos h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_136153 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_to_string.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_to_string.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_136154 (h1 : group (normed_group (random_gen (has_inv string_imp)))) : group.fg (normed_group (random_gen (has_inv string_imp))) := sorry --non-trivial
lemma new_lemma_136155 (h0 : function.extfun Type topological_space) : @normal_space.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_136156 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) pos) : @sequential_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_136157 (h0 : functor.add_const (group (id num)) (semiring num)) : @is_cyclic.{0} (@id.{2} Type num) (@functor.add_const.run.{0 0} (group.{0} (@id.{2} Type num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_136158 (h0 : topological_space (ordered_comm_monoid (has_neg (has_neg (has_neg pos))))) : topological_space.separable_space (ordered_comm_monoid (has_neg (has_neg (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_136159 (h0 : topological_space (boolean_algebra.core (has_nndist Type))) : totally_disconnected_space (boolean_algebra.core (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_136160 (h0 : list (normed_comm_ring (boolean_algebra linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_136161 (h0 : topological_space (has_norm (semiring (semiring empty)))) : locally_compact_space (has_norm (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_136162 (h0 : filter (add_cancel_comm_monoid empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_136163 (h0 : fin has_zero.zero) : @separated_space.{0} (complete_distrib_lattice.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (complete_distrib_lattice.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_136164 (h0 : ring (boolean_algebra.core unsigned)) : is_principal_ideal_ring (boolean_algebra.core unsigned) := sorry --non-trivial
lemma new_lemma_136165 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} string_imp (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) string_imp)  := sorry --non-trivial
lemma new_lemma_136166 (h0 : not (complete_lattice (denumerable linarith.comp_source) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (denumerable.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (denumerable.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_136167 (h0 : ordered_add_comm_monoid (finset (finset (has_pos_part pos)))) : archimedean (finset (finset (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_136168 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @path_connected_space.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_136169 (h0 : topological_space (has_sub empty)) : totally_disconnected_space (has_sub empty) := sorry --non-trivial
lemma new_lemma_136170 (h1 : topological_space (complete_semilattice_Sup (complete_semilattice_Sup linarith.ineq))) : locally_compact_space (complete_semilattice_Sup (complete_semilattice_Sup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_136171 (h2 : complete_lattice (has_div (mul_one_class to_additive.value_type))) : is_compactly_generated (has_div (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_136172 (h0 : functor.add_const (list (ring pos)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_136173 (h0 : ring (linear_order (semiring unsigned))) : strong_rank_condition (linear_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_136174 (h1 : set (mul_one_class enat)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_136175 (h0 : topological_space (has_neg (has_add unsigned))) : preconnected_space (has_neg (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_136176 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_136177 (h0 : topological_space (has_inv (random_gen to_additive.value_type))) : totally_separated_space (has_inv (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_136178 (h2 : topological_space (linear_ordered_add_comm_group (random_gen linarith.ineq))) : t0_space (linear_ordered_add_comm_group (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_136179 (h0 : filter (filter (has_zero pos))) : filter.ne_bot (filter.Limsup h0) := sorry --non-trivial
lemma new_lemma_136180 (h0 : uniform_space (comm_monoid (semiring empty))) : complete_space (comm_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_136181 (h1 : complete_lattice (comm_ring (random_gen (has_top string_imp)))) : is_compactly_generated (comm_ring (random_gen (has_top string_imp))) := sorry --non-trivial
lemma new_lemma_136182 (h0 : complete_lattice (canonically_ordered_monoid (has_bot real))) : complete_lattice.is_Sup_finite_compact (canonically_ordered_monoid (has_bot real)) := sorry --non-trivial
lemma new_lemma_136183 (h0 : fin has_zero.zero) : @path_connected_space.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_136184 (h0 : ring (cancel_monoid (add_comm_monoid (ring Type)))) : is_principal_ideal_ring (cancel_monoid (add_comm_monoid (ring Type))) := sorry --non-trivial
lemma new_lemma_136185 (h0 : add_group (semigroup (finset environment.implicit_infer_kind))) : is_add_cyclic (semigroup (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_136186 (h0 : topological_space (has_zero (option pos))) : totally_separated_space (has_zero (option pos)) := sorry --non-trivial
lemma new_lemma_136187 (h1 : add_group (add_comm_semigroup ereal)) : is_add_cyclic (add_comm_semigroup ereal) := sorry --non-trivial
lemma new_lemma_136188 (h0 : topological_space (semigroup linarith.comp)) : normal_space (semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_136189 (h0 : group (random_gen (random_gen (random_gen (random_gen (random_gen char)))))) : is_cyclic (random_gen (random_gen (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_136190 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (option unsigned)) := sorry --non-trivial
lemma new_lemma_136191 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) pos) : @t0_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_136192 (h0 : topological_space (complete_distrib_lattice unsigned)) : preirreducible_space (complete_distrib_lattice unsigned) := sorry --non-trivial
lemma new_lemma_136193 (h0 : functor.comp topological_space ring name) : @preconnected_space.{0} (ring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_136194 (h0 : ring (has_nnnorm std_gen)) : is_domain (has_nnnorm std_gen) := sorry --non-trivial
lemma new_lemma_136195 (h0 : finset (has_zero (has_Inf Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_136196 (h0 : functor.add_const (topological_space (has_to_string Type)) pos) : @irreducible_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_136197 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_136198 (h0 : topological_space (finset pos)) : normal_space (finset pos) := sorry --non-trivial
lemma new_lemma_136199 (h0 : add_group linarith.ineq) (h1 : uniform_space (filter (add_subgroup linarith.ineq))) : complete_space (filter (add_subgroup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_136200 (h0 : function.extfun Type topological_space) : @t0_space.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_136201 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_136202 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_136203 (h0 : ring (boolean_algebra.core (has_neg (has_pos_part (has_add pos))))) : rank_condition (boolean_algebra.core (has_neg (has_pos_part (has_add pos)))) := sorry --non-trivial
lemma new_lemma_136204 (h0 : complete_lattice (semigroup name)) : is_atomistic (semigroup name) := sorry --non-trivial
lemma new_lemma_136205 (h0 : function.extfun Type topological_space) : @normal_space.{0} (linear_ordered_field.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} num))  := sorry --non-trivial
lemma new_lemma_136206 (h1 : complete_lattice (comm_ring (has_ssubset (fintype to_additive.value_type)))) : is_compactly_generated (comm_ring (has_ssubset (fintype to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_136207 (h0 : group (normed_linear_ordered_group empty)) : is_cyclic (normed_linear_ordered_group empty) := sorry --non-trivial
lemma new_lemma_136208 (h0 : has_mem.mem group has_emptyc.emptyc) : @is_cyclic.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_136209 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_top.{0} (has_inv.{0} linarith.ineq)) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_top.{0} (has_inv.{0} linarith.ineq)))  := sorry --non-trivial
lemma new_lemma_136210 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (canonically_ordered_add_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_136211 (h0 : functor.add_const (function.extfun Type complete_lattice) name) : @complete_lattice.is_Sup_finite_compact.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) name h0) (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_136212 (h0 : topological_space (normed_group (semiring (has_norm (random_gen linarith.comp_source))))) : totally_disconnected_space (normed_group (semiring (has_norm (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_136213 (h0 : function.extfun Type topological_space) : @normal_space.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_136214 (h0 : topological_space (mul_zero_class (finset ennreal))) : locally_compact_space (mul_zero_class (finset ennreal)) := sorry --non-trivial
lemma new_lemma_136215 (h0 : functor.add_const (topological_space (normed_linear_ordered_group congr_arg_kind)) num) : @t0_space.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_136216 (h0 : topological_space (ordered_comm_monoid (has_bot (has_bot (has_bot (has_bot real)))))) : totally_separated_space (ordered_comm_monoid (has_bot (has_bot (has_bot (has_bot real))))) := sorry --non-trivial
lemma new_lemma_136217 (h0 : not (ring (uniform_space to_additive.value_type) -> false)) : @strong_rank_condition.{0} (uniform_space.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (uniform_space.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_136218 (h0 : topological_space (has_ssubset (random_gen (has_ssubset fun_info)))) : t0_space (has_ssubset (random_gen (has_ssubset fun_info))) := sorry --non-trivial
lemma new_lemma_136219 (h0 : functor.add_const (function.extfun Type topological_space) (finset pos)) : @sequential_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (finset.{0} pos) h0) (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_136220 (h1 : ring (id (has_top congr_arg_kind))) : strong_rank_condition (id (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_136221 (h0 : ring (measurable_space (has_top linarith.comp_source))) : strong_rank_condition (measurable_space (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_136222 (h0 : functor.add_const (topological_space (simple_graph linarith.comp)) (has_Inf (finset linarith.comp))) : @path_connected_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} linarith.comp)) (has_Inf.{0} (finset.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_136223 (h0 : functor.add_const (function.extfun Type ring) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) environment.implicit_infer_kind h0) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_136224 (h0 : topological_space (linear_ordered_comm_monoid_with_zero (option empty))) : loc_path_connected_space (linear_ordered_comm_monoid_with_zero (option empty)) := sorry --non-trivial
lemma new_lemma_136225 (h1 : function.extfun (finset Type) (has_mem.mem linarith.comp)) : @totally_separated_space.{0} linarith.comp (@finset.pi.empty.{1 0} Type topological_space.{0} linarith.comp (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp) h1 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_136226 (h0 : topological_space (ring (has_neg pos))) : normal_space (ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_136227 (h0 : cancel_comm_monoid_with_zero (has_neg (finset Type))) : unique_factorization_monoid (has_neg (finset Type)) := sorry --non-trivial
lemma new_lemma_136228 (h0 : set (group_with_zero char -> fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_136229 (h0 : functor.add_const (add_monoid (left_cancel_monoid unsigned)) unsigned) : @add_monoid.fg.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (left_cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_136230 (h0 : topological_space (complete_distrib_lattice (option name))) : t0_space (complete_distrib_lattice (option name)) := sorry --non-trivial
lemma new_lemma_136231 (h0 : functor.add_const (finset (mul_zero_class linarith.comp)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_136232 (h0 : not (topological_space (mul_one_class char) -> false)) : @path_connected_space.{0} (mul_one_class.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (mul_one_class.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_136233 (h0 : prod (id congr_arg_kind) (id congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_136234 (h0 : topological_space (has_zero (has_neg_part Type))) : path_connected_space (has_zero (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_136235 (h0 : ring (simple_graph (mul_one_class (mul_one_class (mul_one_class linarith.ineq))))) : is_domain (simple_graph (mul_one_class (mul_one_class (mul_one_class linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_136236 (h0 : functor.add_const (semiring (has_pos_part real)) (sub_neg_monoid Type)) : @is_noetherian_ring.{0} (has_pos_part.{0} real) (@functor.add_const.run.{0 1} (semiring.{0} (has_pos_part.{0} real)) (sub_neg_monoid.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_136237 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_136238 (h0 : group (linear_ordered_add_comm_monoid_with_top string_imp)) : group.fg (linear_ordered_add_comm_monoid_with_top string_imp) := sorry --non-trivial
lemma new_lemma_136239 (h0 : char -> char -> Prop) (h1 : set char) : directed_on h0 h1 := sorry --non-trivial
lemma new_lemma_136240 (h0 : functor.add_const (topological_space (ring Type)) pos) : @t1_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_136241 (h0 : functor.add_const (ordered_comm_monoid (canonically_ordered_comm_semiring pos)) pos) : @has_exists_mul_of_le.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (canonically_ordered_comm_semiring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_136242 (h0 : topological_space (non_assoc_semiring (semiring empty))) : discrete_topology (non_assoc_semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_136243 (h0 : functor.add_const (semiring (has_neg pos)) unsigned) : @is_noetherian_ring.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (has_neg.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_136244 (h0 : fin has_zero.zero) : @path_connected_space.{0} (normed_lattice_add_comm_group.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (normed_lattice_add_comm_group.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_136245 (h0 : functor.comp ring add_cancel_monoid pos) : @strong_rank_condition.{0} (add_cancel_monoid.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} add_cancel_monoid.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_136246 (h0 : prod (add_cancel_monoid (option (option ennreal))) (add_cancel_monoid (option (option ennreal)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_136247 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @regular_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_136248 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_136249 (h0 : topological_space (linear_ordered_field (has_to_string ennreal))) : irreducible_space (linear_ordered_field (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_136250 (h1 : nat) (h2 : add_monoid (add_comm_semigroup char)) (h3 : has_one (add_comm_semigroup char)) : char_p (add_comm_semigroup char) h1 := sorry --non-trivial
lemma new_lemma_136251 (h0 : not (topological_space (has_norm to_additive.value_type) -> false)) : @locally_compact_space.{0} (has_norm.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_136252 (h0 : semiring (free_add_monoid unsigned)) : is_noetherian_ring (free_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_136253 (h0 : complete_lattice (add_cancel_monoid (normed_comm_ring name))) : is_compactly_generated (add_cancel_monoid (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_136254 (h0 : topological_space (has_bot (ordered_comm_monoid (has_add (has_bot pos))))) : locally_compact_space (has_bot (ordered_comm_monoid (has_add (has_bot pos)))) := sorry --non-trivial
lemma new_lemma_136255 (h0 : set (add_comm_semigroup (add_comm_semigroup enat) -> ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_136256 (h0 : not (group (with_bot unsigned) -> false)) : @normalizer_condition.{0} (with_bot.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (with_bot.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_136257 (h0 : functor.add_const (list (bin_tree unsigned)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_136258 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_add_comm_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_136259 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) pos) : @t0_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_136260 (h0 : not (topological_space (complete_semilattice_Sup linarith.comp_source) -> false)) : @irreducible_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_136261 (h1 : add_group (semi_normed_comm_ring (random_gen (random_gen char)))) : is_add_cyclic (semi_normed_comm_ring (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_136262 (h0 : topological_space (non_unital_non_assoc_semiring (mul_one_class char))) : path_connected_space (non_unital_non_assoc_semiring (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_136263 (h0 : topological_space (has_nndist (has_neg name))) : topological_space.separable_space (has_nndist (has_neg name)) := sorry --non-trivial
lemma new_lemma_136264 (h0 : topological_space (has_to_string ennreal)) : normal_space (has_to_string ennreal) := sorry --non-trivial
lemma new_lemma_136265 (h0 : function.extfun (Type -> Type) (function.extfun Type)) (h1 : set (finset ennreal)) : @is_totally_separated.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} ennreal)) h1  := sorry --non-trivial
lemma new_lemma_136266 (h0 : ring (linear_ordered_comm_group_with_zero std_gen)) : strong_rank_condition (linear_ordered_comm_group_with_zero std_gen) := sorry --non-trivial
lemma new_lemma_136267 (h0 : functor.add_const (ring (finset pos)) (has_pos_part pos)) : @is_domain.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} pos)) (has_pos_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_136268 (h0 : functor.add_const (functor.add_const (list (has_zero unsigned)) linarith.comp) (has_neg pos)) : palindrome (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_136269 (h1 : uniform_space (distrib string_imp)) : complete_space (distrib string_imp) := sorry --non-trivial
lemma new_lemma_136270 (h0 : ring (has_zero (has_to_string Type))) : strong_rank_condition (has_zero (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_136271 (h0 : functor.add_const (functor.comp group cancel_monoid pos) linarith.comp) : @group.fg.{0} (cancel_monoid.{0} pos) (@functor.comp.run.{0 0 0} group.{0} cancel_monoid.{0} pos (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} group.{0} cancel_monoid.{0} pos) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_136272 (h0 : add_group (is_R_or_C (option unsigned))) : is_add_cyclic (is_R_or_C (option unsigned)) := sorry --non-trivial
lemma new_lemma_136273 (h0 : topological_space (boolean_algebra real)) : t1_space (boolean_algebra real) := sorry --non-trivial
lemma new_lemma_136274 (h0 : topological_space (mul_zero_class (boolean_algebra.core (has_add Type)))) : t1_space (mul_zero_class (boolean_algebra.core (has_add Type))) := sorry --non-trivial
lemma new_lemma_136275 (h0 : topological_space (has_nndist (add_comm_monoid (normed_comm_ring Type)))) : topological_space.separable_space (has_nndist (add_comm_monoid (normed_comm_ring Type))) := sorry --non-trivial
lemma new_lemma_136276 (h0 : ring (distrib (has_nnnorm (random_gen char)))) : rank_condition (distrib (has_nnnorm (random_gen char))) := sorry --non-trivial
lemma new_lemma_136277 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_136278 (h0 : uniform_space (semiring (has_top (random_gen fun_info)))) : complete_space (semiring (has_top (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_136279 (h0 : topological_space (canonically_ordered_comm_semiring (has_Inf (has_Inf linarith.comp)))) : preirreducible_space (canonically_ordered_comm_semiring (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_136280 (h0 : ring (has_zero (finset (has_pos_part (finset (finset linarith.comp)))))) : rank_condition (has_zero (finset (has_pos_part (finset (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_136281 (h0 : cancel_comm_monoid_with_zero (has_nndist (boolean_algebra.core environment.implicit_infer_kind))) : unique_factorization_monoid (has_nndist (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_136282 (h0 : uniform_space (mul_one_class (mul_one_class to_additive.value_type))) : complete_space (mul_one_class (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_136283 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} h0 (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_136284 (h0 : not (has_mem.mem (random_gen fun_info) has_emptyc.emptyc -> false)) : @discrete_topology.{0} (random_gen.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_136285 (h0 : list (has_top (has_top (has_inv linarith.ineq)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_136286 (h0 : monoid (random_gen (has_top (random_gen linarith.ineq)))) : monoid.fg (random_gen (has_top (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_136287 (h0 : not (topological_space (complete_semilattice_Sup linarith.comp) -> false)) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_136288 (h0 : function.extfun Type ring) : @is_domain.{0} linarith.comp_source (@function.extfun_app.{2 1} Type ring.{0} h0 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_136289 (h0 : functor.add_const (topological_space (has_pos_part Type)) linarith.comp) : @sequential_space.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_pos_part.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_136290 (h0 : functor.add_const (topological_space pos) unsigned) : @regular_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) unsigned h0)  := sorry --non-trivial
lemma new_lemma_136291 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_136292 (h0 : functor.add_const (list (semigroup name)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_136293 (h0 : ring (with_bot linarith.comp_source)) : strong_rank_condition (with_bot linarith.comp_source) := sorry --non-trivial
lemma new_lemma_136294 (h0 : topological_space std_gen) : preirreducible_space std_gen := sorry --non-trivial
lemma new_lemma_136295 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (distrib_lattice.{0} (has_inv.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (distrib_lattice.{0} (has_inv.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_136296 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_136297 (h0 : fin has_zero.zero) : @complete_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@matrix.vec_empty.{0} (uniform_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_136298 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_compactly_generated.{1} (plift.{1} (semiring.{0} num)) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) (plift.{1} (semiring.{0} num)))  := sorry --non-trivial
lemma new_lemma_136299 (h0 : ordered_comm_monoid (has_pos_part Type)) : has_exists_mul_of_le (has_pos_part Type) := sorry --non-trivial
lemma new_lemma_136300 (h0 : functor.add_const (topological_space (normed_linear_ordered_group unsigned)) empty) : @t0_space.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_136301 (h1 : add_group (uniform_space string.iterator_imp)) : is_add_cyclic (uniform_space string.iterator_imp) := sorry --non-trivial
lemma new_lemma_136302 (h0 : topological_space (has_neg (boolean_algebra name))) : topological_space.separable_space (has_neg (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_136303 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_136304 (h0 : topological_space (comm_group (option (mul_zero_class (boolean_algebra.core ennreal))))) : sequential_space (comm_group (option (mul_zero_class (boolean_algebra.core ennreal)))) := sorry --non-trivial
lemma new_lemma_136305 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preconnected_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_136306 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (denumerable.{0} string_imp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (denumerable.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_136307 (h0 : complete_lattice (is_R_or_C (option (option unsigned)))) : is_compactly_generated (is_R_or_C (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_136308 (h0 : topological_space (boolean_algebra.core char)) : totally_disconnected_space (boolean_algebra.core char) := sorry --non-trivial
lemma new_lemma_136309 (h0 : functor.add_const (topological_space (semigroup empty)) num) : @t0_space.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_136310 (h0 : group (finset (has_neg linarith.comp))) : is_cyclic (finset (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_136311 (h1 : group (encodable linarith.ineq)) : group.fg (encodable linarith.ineq) := sorry --non-trivial
lemma new_lemma_136312 (h0 : function.extfun Type topological_space) : @t0_space.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_136313 (h0 : group (ordered_comm_monoid (ring Type))) : group.fg (ordered_comm_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_136314 (h1 : topological_space (has_top char)) : totally_disconnected_space (has_top char) := sorry --non-trivial
lemma new_lemma_136315 (h0 : ring (has_to_string (finset (finset Type)))) : is_principal_ideal_ring (has_to_string (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_136316 (h0 : function.extfun Type topological_space) : @normal_space.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type topological_space.{0} h0 environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_136317 (h0 : has_neg string) (h1 : measurable_space string) : has_measurable_neg string := sorry --non-trivial
lemma new_lemma_136318 (h0 : functor.add_const (topological_space (cancel_monoid empty)) empty) : @totally_separated_space.{0} (cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_136319 (h0 : functor.add_const (topological_space (ordered_comm_group unsigned)) unsigned) : @t0_space.{0} (ordered_comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_136320 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_136321 (h0 : prod (normed_linear_ordered_group num) (normed_linear_ordered_group num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_136322 (h0 : list (distrib_lattice (has_ssubset (has_ssubset fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_136323 (h0 : group (linear_ordered_comm_monoid_with_zero congr_arg_kind)) : is_cyclic (linear_ordered_comm_monoid_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_136324 (h0 : not (ring (has_norm linarith.comp) -> false)) : @rank_condition.{0} (has_norm.{0} linarith.comp) (@classical.by_contradiction'.{1} (ring.{0} (has_norm.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_136325 (h0 : complete_lattice (distrib (has_nnnorm to_additive.value_type))) : is_compactly_generated (distrib (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_136326 (h0 : random_gen (id linarith.comp_source)) (h1 : set (random_gen (id linarith.comp_source))) : set.mem h0 h1 := sorry --non-trivial
lemma new_lemma_136327 (h0 : functor.add_const (functor.add_const (topological_space nnreal) num) congr_arg_kind) : locally_compact_space nnreal := sorry --non-trivial
lemma new_lemma_136328 (h0 : complete_lattice (normed_comm_ring (has_neg_part pos))) : is_atomistic (normed_comm_ring (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_136329 (h2 : complete_lattice (normed_group fun_info)) : is_compactly_generated (normed_group fun_info) := sorry --non-trivial
lemma new_lemma_136330 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_136331 (h0 : function.extfun Type topological_space) : @t0_space.{0} (option.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_136332 (h0 : add_group (linear_ordered_comm_ring empty)) : is_add_cyclic (linear_ordered_comm_ring empty) := sorry --non-trivial
lemma new_lemma_136333 (h0 : ring (random_gen (mul_one_class (mul_one_class char)))) : rank_condition (random_gen (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_136334 (h0 : not (uniform_space (linear_ordered_semiring num) -> false)) : @separated_space.{0} (linear_ordered_semiring.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (linear_ordered_semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_136335 (h0 : group (has_bot (option empty))) : is_cyclic (has_bot (option empty)) := sorry --non-trivial
lemma new_lemma_136336 (h0 : function.extfun Type (functor.comp topological_space canonically_ordered_comm_semiring)) : @t0_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_136337 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (lex.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (lex.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_136338 (h0 : topological_space (boolean_algebra (has_add (finset (has_add pos))))) : regular_space (boolean_algebra (has_add (finset (has_add pos)))) := sorry --non-trivial
lemma new_lemma_136339 (h0 : ring (add_group congr_arg_kind)) : strong_rank_condition (add_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_136340 (h0 : function.extfun Type group) : @is_cyclic.{0} (free_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (free_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_136341 (h0 : filter (comm_ring (random_gen (has_ssubset (random_gen (random_gen linarith.ineq)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_136342 (h0 : functor.add_const (group (has_to_string name)) linarith.comp) : @is_simple_group.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_136343 (h0 : topological_space (has_add (finset (finset Type)))) : regular_space (has_add (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_136344 (h0 : function.extfun Type ring) : @is_domain.{0} (canonically_ordered_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_136345 (h0 : uniform_space (ordered_cancel_add_comm_monoid (option (option unsigned)))) : separated_space (ordered_cancel_add_comm_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_136346 (h0 : topological_space (plift congr_arg_kind)) : t1_space (plift congr_arg_kind) := sorry --non-trivial
lemma new_lemma_136347 (h0 : function.extfun nat fin) : @is_domain.{0} (canonically_linear_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (canonically_linear_ordered_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_136348 (h0 : semiring (comm_group (has_add (boolean_algebra pos)))) : is_noetherian_ring (comm_group (has_add (boolean_algebra pos))) := sorry --non-trivial
lemma new_lemma_136349 (h0 : group (comm_group (has_add name))) : group.fg (comm_group (has_add name)) := sorry --non-trivial
lemma new_lemma_136350 (h0 : not (topological_space (non_assoc_semiring congr_arg_kind) -> false)) : @totally_separated_space.{0} (non_assoc_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (non_assoc_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_136351 (h0 : topological_space (div_inv_monoid (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) : path_connected_space (div_inv_monoid (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_136352 (h0 : add_monoid (monoid (comm_monoid unsigned))) : add_monoid.fg (monoid (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_136353 (h0 : group (linear_ordered_add_comm_group (random_gen (random_gen linarith.ineq)))) : normalizer_condition (linear_ordered_add_comm_group (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_136354 (h0 : group (finset (has_to_string linarith.comp))) : group.fg (finset (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_136355 (h0 : group (preorder (option unsigned))) : is_cyclic (preorder (option unsigned)) := sorry --non-trivial
lemma new_lemma_136356 (h0 : functor.add_const (topological_space (partial_order congr_arg_kind)) (semiring empty)) : @irreducible_space.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} congr_arg_kind)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_136357 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (measurable_space.{0} (semiring.{0} (has_norm.{0} (semiring.{0} empty)))) (@function.extfun_app.{2 1} Type monoid.{0} h0 (measurable_space.{0} (semiring.{0} (has_norm.{0} (semiring.{0} empty)))))  := sorry --non-trivial
lemma new_lemma_136358 (h0 : functor.add_const (ring (has_add Type)) name) : @is_principal_ideal_ring.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_add.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_136359 (h1 : topological_space (has_top (has_top fun_info))) : totally_disconnected_space (has_top (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_136360 (h1 : topological_space (has_nnnorm std_gen)) (h2 : preorder (has_nnnorm std_gen)) : order_closed_topology (has_nnnorm std_gen) := sorry --non-trivial
lemma new_lemma_136361 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) (has_zero (has_to_string pos))) : @regular_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) (has_zero.{0} (has_to_string.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_136362 (h0 : group (complete_semilattice_Sup (random_gen (has_nnnorm linarith.comp_source)))) : group.fg (complete_semilattice_Sup (random_gen (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_136363 (h0 : functor.add_const (complete_lattice (comm_monoid empty)) empty) : @is_compactly_generated.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_136364 (h0 : topological_space (canonically_linear_ordered_monoid (option (option (option ennreal))))) : loc_path_connected_space (canonically_linear_ordered_monoid (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_136365 (h0 : not (monoid (has_norm fun_info) -> false)) : @monoid.fg.{0} (has_norm.{0} fun_info) (@classical.by_contradiction'.{1} (monoid.{0} (has_norm.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_136366 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_136367 (h0 : ring (id (semiring unsigned))) : is_domain (id (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_136368 (h0 : function.extfun Type group) : @group.fg.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_136369 (h0 : complete_lattice (has_mul (has_add linarith.comp))) : is_compactly_generated (has_mul (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_136370 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type semiring.{0}) h0) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_136371 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (left_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (left_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_136372 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_136373 (h0 : group (has_emptyc (has_top linarith.ineq))) : is_cyclic (has_emptyc (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_136374 (h0 : monoid (complete_distrib_lattice (option empty))) : monoid.fg (complete_distrib_lattice (option empty)) := sorry --non-trivial
lemma new_lemma_136375 (h0 : ring (boolean_algebra.core (has_add Type))) : is_principal_ideal_ring (boolean_algebra.core (has_add Type)) := sorry --non-trivial
lemma new_lemma_136376 (h1 : has_neg (add_comm_semigroup fun_info)) (h2 : measurable_space (add_comm_semigroup fun_info)) : has_measurable_neg (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_136377 (h0 : functor.add_const (monoid (has_neg environment.implicit_infer_kind)) linarith.comp) : @monoid.fg.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (has_neg.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_136378 (h0 : group (has_top (has_ssubset string_imp))) : group.fg (has_top (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_136379 (h0 : functor.add_const (topological_space (has_nndist pos)) ennreal) : @path_connected_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_136380 (h0 : topological_space (has_zero ennreal)) : preirreducible_space (has_zero ennreal) := sorry --non-trivial
lemma new_lemma_136381 (h0 : topological_space (semiring congr_arg_kind)) : totally_separated_space (semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_136382 (h0 : topological_space (comm_monoid (option empty))) : locally_compact_space (comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_136383 (h1 : complete_lattice (has_top num)) : is_atomistic (has_top num) := sorry --non-trivial
lemma new_lemma_136384 (h0 : functor.comp complete_lattice canonically_ordered_comm_semiring name) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.comp.run.{0 0 0} complete_lattice.{0} canonically_ordered_comm_semiring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_136385 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_to_string.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} empty))  := sorry --non-trivial
lemma new_lemma_136386 (h0 : group (has_pos_part (has_neg (has_Inf name)))) : normalizer_condition (has_pos_part (has_neg (has_Inf name))) := sorry --non-trivial
lemma new_lemma_136387 (h0 : add_monoid (has_nndist (has_to_string pos))) : add_monoid.fg (has_nndist (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_136388 (h0 : topological_space (has_bot (has_Inf (has_Inf (has_Inf Type))))) : t0_space (has_bot (has_Inf (has_Inf (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_136389 (h0 : finset (has_dist ennreal)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_136390 (h0 : group (has_zero (has_neg (semigroup (finset (has_neg environment.implicit_infer_kind)))))) : is_cyclic (has_zero (has_neg (semigroup (finset (has_neg environment.implicit_infer_kind))))) := sorry --non-trivial
lemma new_lemma_136391 (h1 : function.extfun Type topological_space) : @path_connected_space.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_136392 (h0 : group (add_comm_monoid (comm_group (add_cancel_monoid (comm_group (comm_group pos)))))) : group.fg (add_comm_monoid (comm_group (add_cancel_monoid (comm_group (comm_group pos))))) := sorry --non-trivial
lemma new_lemma_136393 (h0 : not (group (metric_space unsigned) -> false)) : @is_cyclic.{0} (metric_space.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (metric_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_136394 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_136395 (h1 : topological_space (has_lt (random_gen reducibility_hints))) : t0_space (has_lt (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_136396 (h0 : complete_lattice (has_div (mul_one_class std_gen))) : is_compactly_generated (has_div (mul_one_class std_gen)) := sorry --non-trivial
lemma new_lemma_136397 (h0 : not (topological_space (linear_ordered_comm_ring congr_arg_kind) -> false)) : @preirreducible_space.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_ring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_136398 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_136399 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_136400 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_136401 (h0 : ring (has_star (semiring (semiring (semiring (semiring (semiring unsigned))))))) : strong_rank_condition (has_star (semiring (semiring (semiring (semiring (semiring unsigned)))))) := sorry --non-trivial
lemma new_lemma_136402 (h0 : topological_space (ordered_comm_ring (has_neg Type))) : t1_space (ordered_comm_ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_136403 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @group.fg.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_136404 (h0 : fin has_zero.zero) : @regular_space.{0} (simple_graph.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (simple_graph.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_136405 (h0 : monoid (sub_neg_monoid (ordered_comm_monoid (has_neg name)))) : monoid.fg (sub_neg_monoid (ordered_comm_monoid (has_neg name))) := sorry --non-trivial
lemma new_lemma_136406 (h1 : has_mem.mem (with_bot empty) has_emptyc.emptyc) : @is_domain.{0} (with_bot.{0} empty) (@finset.pi.empty.{1 0} Type ring.{0} (with_bot.{0} empty) h1)  := sorry --non-trivial
lemma new_lemma_136407 (h0 : functor.add_const (semiring (semigroup empty)) (semiring empty)) : @is_noetherian_ring.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (semigroup.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_136408 (h0 : monoid (comm_group (has_to_string name))) : monoid.fg (comm_group (has_to_string name)) := sorry --non-trivial
lemma new_lemma_136409 (h0 : set (set (has_inv linarith.ineq))) : is_countably_spanning h0 := sorry --non-trivial
lemma new_lemma_136410 (h0 : topological_space (nondiscrete_normed_field enat)) (h1 : preorder (nondiscrete_normed_field enat)) : order_closed_topology (nondiscrete_normed_field enat) := sorry --non-trivial
lemma new_lemma_136411 (h0 : functor.add_const (topological_space (option num)) empty) : @preirreducible_space.{0} (option.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_136412 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_dist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_dist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_136413 (h0 : add_group (sub_neg_monoid (has_add pos))) : is_add_cyclic (sub_neg_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_136414 (h0 : fin has_zero.zero) : @sequential_space.{0} (sub_neg_monoid.{0} (ordered_comm_monoid.{0} linarith.comp)) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} (ordered_comm_monoid.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_136415 (h0 : topological_space (denumerable linarith.comp_source)) : locally_compact_space (denumerable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_136416 (h0 : functor.add_const (topological_space (left_cancel_monoid unsigned)) (semiring (semiring (semiring empty)))) : @irreducible_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) (semiring.{0} (semiring.{0} (semiring.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_136417 (h1 : set (nondiscrete_normed_field environment.projection_info)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_136418 (h0 : topological_space (has_to_string (has_to_string name))) : t1_space (has_to_string (has_to_string name)) := sorry --non-trivial
lemma new_lemma_136419 (h0 : functor.add_const (filter (has_add name)) (option (option (option name)))) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_136420 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_136421 (h3 : add_group linarith.ineq) : is_add_cyclic linarith.ineq := sorry --non-trivial
lemma new_lemma_136422 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @group.fg.{0} name (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) name)  := sorry --non-trivial
lemma new_lemma_136423 (h0 : topological_space (has_nnnorm (random_gen reducibility_hints))) : t0_space (has_nnnorm (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_136424 (h0 : ring (has_compl (mul_one_class (mul_one_class string.iterator_imp)))) : rank_condition (has_compl (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_136425 (h0 : has_mem.mem (linear_ordered_semiring (has_norm empty)) has_emptyc.emptyc) : @totally_disconnected_space.{0} (linear_ordered_semiring.{0} (has_norm.{0} empty)) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} (has_norm.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_136426 (h0 : finset (omega_complete_partial_order congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_136427 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (canonically_ordered_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_136428 (h0 : functor.add_const (uniform_space znum) empty) : @complete_space.{0} znum (@functor.add_const.run.{0 0} (uniform_space.{0} znum) empty h0)  := sorry --non-trivial
lemma new_lemma_136429 (h0 : group (semigroup (has_neg_part Type))) : normalizer_condition (semigroup (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_136430 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_136431 (h0 : function.extfun (Type 1) topological_space) : @topological_space.separable_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_136432 (h0 : function.extfun (Type 1) cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} h0 (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_136433 (h0 : functor.add_const (complete_lattice pos) name) : @complete_lattice.is_Sup_finite_compact.{0} pos (@functor.add_const.run.{0 0} (complete_lattice.{0} pos) name h0)  := sorry --non-trivial
lemma new_lemma_136434 (h0 : functor.add_const (complete_lattice (has_neg_part unsigned)) (has_add Type)) : @is_atomistic.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_neg_part.{0} unsigned)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_136435 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} pos (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) pos)  := sorry --non-trivial
lemma new_lemma_136436 (h0 : char) (h1 : sym2 char -> fun_info) (h2 : coe_sort (set.range h1)) : sym2.mem h0 (set.range_splitting h1 h2) := sorry --non-trivial
lemma new_lemma_136437 (h0 : functor.add_const (list (free_add_monoid empty)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_136438 (h0 : topological_space (ordered_comm_ring (has_pos_part Type))) : path_connected_space (ordered_comm_ring (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_136439 (h0 : ordered_comm_monoid (has_to_string (has_to_string unsigned))) : has_exists_mul_of_le (has_to_string (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_136440 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) linarith.comp) : @locally_compact_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_136441 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) linarith.comp) : @sequential_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_136442 (h0 : topological_space (ordered_comm_monoid (has_Inf (has_pos_part linarith.comp)))) : discrete_topology (ordered_comm_monoid (has_Inf (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_136443 (h3 : not (ring congr_arg_kind -> false)) : @is_domain.{0} congr_arg_kind (@classical.by_contradiction'.{1} (ring.{0} congr_arg_kind) h3)  := sorry --non-trivial
lemma new_lemma_136444 (h0 : ordered_comm_monoid (boolean_algebra (comm_group (has_add Type)))) : has_exists_mul_of_le (boolean_algebra (comm_group (has_add Type))) := sorry --non-trivial
lemma new_lemma_136445 (h0 : group (linear_ordered_semiring (semiring (random_gen num)))) : is_cyclic (linear_ordered_semiring (semiring (random_gen num))) := sorry --non-trivial
lemma new_lemma_136446 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_136447 (h0 : topological_space (lattice num)) : locally_compact_space (lattice num) := sorry --non-trivial
lemma new_lemma_136448 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_136449 (h0 : functor.add_const (topological_space (semigroup Type)) pos) : @normal_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_136450 (h0 : uniform_space (left_cancel_semigroup (semiring empty))) : complete_space (left_cancel_semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_136451 (h0 : semiring (has_one congr_arg_kind)) : is_noetherian_ring (has_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_136452 (h0 : not (has_scalar (semiring empty) congr_arg_kind -> false)) : @has_faithful_scalar.{0 0} (semiring.{0} empty) congr_arg_kind (@classical.by_contradiction'.{1} (has_scalar.{0 0} (semiring.{0} empty) congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_136453 (h0 : functor.add_const (topological_space (finset pos)) Type) : @t0_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_136454 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (with_bot.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_136455 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_136456 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_neg_part.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg_part.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_136457 (h0 : not (add_monoid (normed_group unsigned) -> false)) : @add_monoid.fg.{0} (normed_group.{0} unsigned) (@classical.by_contradiction'.{1} (add_monoid.{0} (normed_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_136458 (h0 : topological_space (left_cancel_monoid (option (option (option (option empty)))))) : preirreducible_space (left_cancel_monoid (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_136459 (h1 : topological_space empty) : totally_disconnected_space empty := sorry --non-trivial
lemma new_lemma_136460 (h1 : add_group (ordered_comm_semiring (has_nnnorm (random_gen to_additive.value_type)))) : is_add_cyclic (ordered_comm_semiring (has_nnnorm (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_136461 (h0 : complete_lattice (has_emptyc (random_gen (random_gen to_additive.value_type)))) : is_atomistic (has_emptyc (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_136462 (h0 : complete_lattice (normed_group (has_inv (has_inv (has_inv linarith.comp_source))))) : is_atomistic (normed_group (has_inv (has_inv (has_inv linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_136463 (h0 : functor.add_const (group (comm_group pos)) (comm_group Type)) : @is_simple_group.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (comm_group.{0} pos)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_136464 (h0 : topological_space (complete_distrib_lattice (ordered_comm_group unsigned))) : normal_space (complete_distrib_lattice (ordered_comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_136465 (h0 : complete_lattice (has_compl (mul_one_class fun_info))) : is_compactly_generated (has_compl (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_136466 (h0 : semiring (is_R_or_C unsigned)) : is_noetherian_ring (is_R_or_C unsigned) := sorry --non-trivial
lemma new_lemma_136467 (h0 : not (group (normed_field reducibility_hints) -> false)) : @is_cyclic.{0} (normed_field.{0} reducibility_hints) (@classical.by_contradiction'.{1} (group.{0} (normed_field.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_136468 (h0 : functor.add_const (function.extfun Type topological_space) (finset Type)) : @irreducible_space.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (finset.{1} Type) h0) (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_136469 (h0 : has_mem.mem (with_bot empty) has_emptyc.emptyc) : @totally_disconnected_space.{0} (with_bot.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_136470 (h2 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} h2 (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_136471 (h0 : ring (measurable_space (random_gen fun_info))) : rank_condition (measurable_space (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_136472 (h0 : fin has_zero.zero) : @preconnected_space.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_136473 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm empty))) : @t0_space.{0} (has_norm.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_136474 (h0 : function.extfun Type ring) : @rank_condition.{0} (canonically_ordered_comm_semiring.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_comm_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_136475 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_136476 (h0 : functor.add_const (ring pos) pos) : @strong_rank_condition.{0} pos (@functor.add_const.run.{0 0} (ring.{0} pos) pos h0)  := sorry --non-trivial
lemma new_lemma_136477 (h0 : function.extfun Type group) : @is_cyclic.{0} (topological_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (topological_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_136478 (h0 : monoid (boolean_algebra.core (measurable_space unsigned))) : monoid.fg (boolean_algebra.core (measurable_space unsigned)) := sorry --non-trivial
lemma new_lemma_136479 (h0 : topological_space (add_comm_semigroup fun_info)) (h2 : preorder (add_comm_semigroup fun_info)) : order_closed_topology (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_136480 (h0 : topological_space (has_nndist (has_neg_part Type))) : normal_space (has_nndist (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_136481 (h0 : ring auto.case_option) : rank_condition auto.case_option := sorry --non-trivial
lemma new_lemma_136482 (h0 : ring (ring (normed_comm_ring Type))) : is_domain (ring (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_136483 (h0 : not (add_group (uniform_space (has_ssubset linarith.ineq)) -> false)) : @is_add_cyclic.{0} (uniform_space.{0} (has_ssubset.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (add_group.{0} (uniform_space.{0} (has_ssubset.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_136484 (h0 : not (complete_lattice (linear_ordered_semiring congr_arg_kind) -> false)) : @is_atomistic.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_136485 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_136486 (h0 : topological_space (normed_lattice_add_comm_group (has_neg (has_neg name)))) : normal_space (normed_lattice_add_comm_group (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_136487 (h0 : topological_space (complete_distrib_lattice (option name))) : loc_path_connected_space (complete_distrib_lattice (option name)) := sorry --non-trivial
lemma new_lemma_136488 (h0 : topological_space (has_nnnorm (boolean_algebra.core linarith.ineq))) : totally_disconnected_space (has_nnnorm (boolean_algebra.core linarith.ineq)) := sorry --non-trivial
lemma new_lemma_136489 (h0 : topological_space (ordered_comm_ring Type)) : preconnected_space (ordered_comm_ring Type) := sorry --non-trivial
lemma new_lemma_136490 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (complete_linear_order.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (complete_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_136491 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (has_add.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_136492 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (has_pos_part.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_pos_part.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_136493 (h0 : has_mem.mem (has_top congr_arg_kind) has_emptyc.emptyc) : @is_compactly_generated.{0} (has_top.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_top.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_136494 (h0 : functor.add_const (ring (add_comm_monoid Type)) Type) : @is_domain.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (add_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_136495 (h0 : functor.add_const (ring (left_cancel_monoid num)) congr_arg_kind) : @is_domain.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_136496 (h0 : functor.comp filter add_comm_monoid environment.implicit_infer_kind) : countable_Inter_filter (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_136497 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (canonically_linear_ordered_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_136498 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) (has_pos_part pos)) : @totally_disconnected_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) (has_pos_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_136499 (h0 : topological_space (has_Inf (has_add Type))) : normal_space (has_Inf (has_add Type)) := sorry --non-trivial
lemma new_lemma_136500 (h0 : functor.add_const (group (add_comm_monoid empty)) congr_arg_kind) : @is_cyclic.{0} (add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_136501 (h0 : ring (linear_ordered_field num)) : is_principal_ideal_ring (linear_ordered_field num) := sorry --non-trivial
lemma new_lemma_136502 (h0 : function.extfun Type group) : @is_cyclic.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_136503 (h0 : topological_space (generalized_boolean_algebra (has_nndist (has_Inf linarith.comp)))) : t0_space (generalized_boolean_algebra (has_nndist (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_136504 (h0 : add_group (comm_ring fun_info)) : is_add_cyclic (comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_136505 (h2 : topological_space (encodable to_additive.value_type)) : path_connected_space (encodable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_136506 (h0 : ordered_add_comm_monoid (has_neg_part name)) : archimedean (has_neg_part name) := sorry --non-trivial
lemma new_lemma_136507 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm congr_arg_kind))) : @strong_rank_condition.{0} (has_norm.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type ring.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_136508 (h0 : topological_space (boolean_algebra (has_to_string (semigroup (finset (finset Type)))))) : regular_space (boolean_algebra (has_to_string (semigroup (finset (finset Type))))) := sorry --non-trivial
lemma new_lemma_136509 (h0 : add_group (ordered_ring (option unsigned))) : is_add_cyclic (ordered_ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_136510 (h0 : topological_space (monoid (option empty))) : topological_space.separable_space (monoid (option empty)) := sorry --non-trivial
lemma new_lemma_136511 (h0 : list (comm_group (has_neg_part (has_neg linarith.comp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_136512 (h0 : filter (has_to_string (has_to_string name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_136513 (h0 : add_monoid (ring (finset name))) : add_monoid.fg (ring (finset name)) := sorry --non-trivial
lemma new_lemma_136514 (h0 : function.extfun Type topological_space) : @t0_space.{0} (bin_tree.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} empty))  := sorry --non-trivial
lemma new_lemma_136515 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_136516 (h0 : function.extfun Type group) : @normalizer_condition.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_136517 (h0 : topological_space (has_div reducibility_hints)) : path_connected_space (has_div reducibility_hints) := sorry --non-trivial
lemma new_lemma_136518 (h0 : functor.add_const (list (has_to_string name)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_136519 (h3 : complete_lattice (random_gen (random_gen fun_info))) : complete_lattice.is_Sup_finite_compact (random_gen (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_136520 (h0 : functor.add_const (function.extfun (Type 1) ring) Type) : @rank_condition.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) Type h0) (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_136521 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (encodable.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (encodable.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_136522 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_136523 (h0 : filter (has_add (has_neg (finset (has_neg (has_neg (has_add Type))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_136524 (h0 : pos_num) (h1 : tree Type) (h2 : topological_space (tree.get_or_else h0 h1 to_additive.value_type)) : totally_disconnected_space (tree.get_or_else h0 h1 to_additive.value_type) := sorry --non-trivial
lemma new_lemma_136525 (h0 : uniform_space (normed_comm_ring (option empty))) : separated_space (normed_comm_ring (option empty)) := sorry --non-trivial
lemma new_lemma_136526 (h0 : with_bot (complete_lattice (with_one linarith.comp))) (h1 : function.extfun (eq h0 has_bot.bot) (fun (x : eq h0 has_bot.bot), false)) : @is_atomistic.{0} (with_one.{0} linarith.comp) (@with_bot.unbot.{0} (complete_lattice.{0} (with_one.{0} linarith.comp)) h0 (@function.extfun_app.{0 0} (@eq.{1} (with_bot.{0} (complete_lattice.{0} (with_one.{0} linarith.comp))) h0 (@has_bot.bot.{0} (with_bot.{0} (complete_lattice.{0} (with_one.{0} linarith.comp))) (@with_bot.has_bot.{0} (complete_lattice.{0} (with_one.{0} linarith.comp))))) (λ (x : @eq.{1} (with_bot.{0} (complete_lattice.{0} (with_one.{0} linarith.comp))) h0 (@has_bot.bot.{0} (with_bot.{0} (complete_lattice.{0} (with_one.{0} linarith.comp))) (@with_bot.has_bot.{0} (complete_lattice.{0} (with_one.{0} linarith.comp))))), false) h1))  := sorry --non-trivial
lemma new_lemma_136527 (h0 : add_group (finset (canonically_ordered_comm_semiring Type))) : is_add_cyclic (finset (canonically_ordered_comm_semiring Type)) := sorry --non-trivial
lemma new_lemma_136528 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_136529 (h0 : monoid (canonically_ordered_monoid real)) : monoid.fg (canonically_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_136530 (h0 : functor.add_const (finset (pseudo_metric_space unsigned)) (option unsigned)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_136531 (h0 : functor.add_const (uniform_space (has_add linarith.comp)) name) : @separated_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_add.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_136532 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) pos) : @has_exists_mul_of_le.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) pos h0) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_136533 (h0 : not (ring (semiring congr_arg_kind) -> false)) : @rank_condition.{0} (semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (ring.{0} (semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_136534 (h0 : functor.add_const (topological_space (mul_zero_class name)) unsigned) : @topological_space.separable_space.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_136535 (h0 : functor.add_const (topological_space (has_Inf Type)) Type) : @discrete_topology.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_Inf.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_136536 (h0 : topological_space (add_comm_monoid (option unsigned))) : loc_path_connected_space (add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_136537 (h0 : not (complete_lattice (normed_field reducibility_hints) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (normed_field.{0} reducibility_hints) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_field.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_136538 (h0 : not (topological_space (with_one unsigned) -> false)) : @totally_separated_space.{0} (with_one.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_136539 (h0 : topological_space (has_inter (option (option ennreal)))) : loc_path_connected_space (has_inter (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_136540 (h0 : topological_space (finset unsigned)) : preconnected_space (finset unsigned) := sorry --non-trivial
lemma new_lemma_136541 (h0 : list (has_to_string num)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_136542 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_136543 (h0 : filter (with_one (semiring unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_136544 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (add_cancel_monoid.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_136545 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (linear_ordered_add_comm_group.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_add_comm_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_136546 (h1 : not (complete_lattice (non_unital_non_assoc_semiring string_imp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (non_unital_non_assoc_semiring.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (non_unital_non_assoc_semiring.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_136547 (h0 : topological_space (has_neg (finset (cancel_monoid Type)))) : irreducible_space (has_neg (finset (cancel_monoid Type))) := sorry --non-trivial
lemma new_lemma_136548 (h0 : topological_space (cancel_monoid empty)) : t1_space (cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_136549 (h0 : function.extfun (Type 1) topological_space) : @totally_disconnected_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_136550 (h0 : monoid (measurable_space (has_inv (has_inv (random_gen to_additive.value_type))))) : monoid.fg (measurable_space (has_inv (has_inv (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_136551 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_136552 (h0 : ring (add_comm_semigroup (add_comm_semigroup (has_one reducibility_hints)))) : is_domain (add_comm_semigroup (add_comm_semigroup (has_one reducibility_hints))) := sorry --non-trivial
lemma new_lemma_136553 (h0 : add_group (measurable_space (has_norm fun_info))) : is_add_cyclic (measurable_space (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_136554 (h2 : topological_space (comm_ring fun_info)) : t0_space (comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_136555 (h0 : monoid (ordered_comm_monoid Type)) : monoid.fg (ordered_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_136556 (h0 : topological_space (linear_ordered_add_comm_group (has_inv (comm_ring linarith.ineq)))) : locally_compact_space (linear_ordered_add_comm_group (has_inv (comm_ring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_136557 (h0 : complete_lattice (canonically_ordered_comm_semiring (has_add name))) : is_atomistic (canonically_ordered_comm_semiring (has_add name)) := sorry --non-trivial
lemma new_lemma_136558 (h0 : complete_lattice (normed_lattice_add_comm_group linarith.comp)) : is_compactly_generated (normed_lattice_add_comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_136559 (h0 : ring (semiring num)) : is_domain (semiring num) := sorry --non-trivial
lemma new_lemma_136560 (h0 : topological_space (semigroup (finset (semigroup environment.implicit_infer_kind)))) : normal_space (semigroup (finset (semigroup environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_136561 (h0 : topological_space (generalized_boolean_algebra (has_add Type))) : topological_space.separable_space (generalized_boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_136562 (h0 : topological_space (semiring (has_top num))) : irreducible_space (semiring (has_top num)) := sorry --non-trivial
lemma new_lemma_136563 (h0 : add_group (has_one (semiring empty))) : is_add_cyclic (has_one (semiring empty)) := sorry --non-trivial
lemma new_lemma_136564 (h0 : functor.add_const (topological_space (ring linarith.comp)) pos) : @discrete_topology.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_136565 (h0 : complete_lattice (ring (option ennreal))) : is_atomistic (ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_136566 (h0 : function.extfun (finset Type) (has_mem.mem (semiring linarith.comp_source))) : @complete_space.{0} (semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type uniform_space.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_136567 (h0 : list (has_norm (has_ssubset (comm_ring linarith.comp_source)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_136568 (h0 : not (has_mem.mem monoid has_emptyc.emptyc -> false)) : @monoid.fg.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) monoid.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_136569 (h0 : ordered_add_comm_monoid (linear_ordered_cancel_comm_monoid (option (option empty)))) : archimedean (linear_ordered_cancel_comm_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_136570 (h0 : topological_space (sub_neg_monoid (sub_neg_monoid linarith.comp))) : preconnected_space (sub_neg_monoid (sub_neg_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_136571 (h0 : group (comm_ring (comm_ring char))) : is_cyclic (comm_ring (comm_ring char)) := sorry --non-trivial
lemma new_lemma_136572 (h0 : topological_space (comm_semigroup (has_bot (has_bot name)))) : path_connected_space (comm_semigroup (has_bot (has_bot name))) := sorry --non-trivial
lemma new_lemma_136573 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_136574 (h0 : topological_space (ring (ring (ring Type)))) : locally_compact_space (ring (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_136575 (h0 : set (prod (has_nnnorm linarith.ineq) (has_nnnorm linarith.ineq))) : symmetric_rel h0 := sorry --non-trivial
lemma new_lemma_136576 (h0 : ring (has_top num)) : rank_condition (has_top num) := sorry --non-trivial
lemma new_lemma_136577 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_one unsigned)) := sorry --non-trivial
lemma new_lemma_136578 (h0 : functor.add_const (topological_space (boolean_algebra Type)) Type) : @regular_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_136579 (h0 : finset to_additive.value_type) (h1 : finset.nonempty h0) (h2 : to_additive.value_type -> Prop) : @finset.sup'.{0 0} Prop to_additive.value_type (@lattice.to_semilattice_sup.{0} Prop (@conditionally_complete_lattice.to_lattice.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice))) h0 h1 h2  := sorry --non-trivial
lemma new_lemma_136580 (h0 : add_group (has_top linarith.comp_source)) (h1 : function.extfun (finset (add_group (has_top linarith.comp_source))) (has_mem.mem h0)) : @add_subgroup.normal.{0} (has_top.{0} linarith.comp_source) h0 (@finset.pi.empty.{0 0} (add_group.{0} (has_top.{0} linarith.comp_source)) (@add_subgroup.{0} (has_top.{0} linarith.comp_source)) h0 (@function.extfun_app.{1 0} (finset.{0} (add_group.{0} (has_top.{0} linarith.comp_source))) (@has_mem.mem.{0 0} (add_group.{0} (has_top.{0} linarith.comp_source)) (finset.{0} (add_group.{0} (has_top.{0} linarith.comp_source))) (@finset.has_mem.{0} (add_group.{0} (has_top.{0} linarith.comp_source))) h0) h1 (@has_emptyc.emptyc.{0} (finset.{0} (add_group.{0} (has_top.{0} linarith.comp_source))) (@finset.has_emptyc.{0} (add_group.{0} (has_top.{0} linarith.comp_source))))))  := sorry --non-trivial
lemma new_lemma_136581 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (linear_ordered_add_comm_group.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_add_comm_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_136582 (h0 : uniform_space (boolean_algebra (has_neg_part (has_add Type)))) : complete_space (boolean_algebra (has_neg_part (has_add Type))) := sorry --non-trivial
lemma new_lemma_136583 (h0 : topological_space (has_nndist (complete_distrib_lattice (normed_comm_ring Type)))) : sequential_space (has_nndist (complete_distrib_lattice (normed_comm_ring Type))) := sorry --non-trivial
lemma new_lemma_136584 (h0 : functor.add_const (list (add_comm_monoid linarith.comp)) (finset Type)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_136585 (h0 : has_inv (has_inv to_additive.value_type) -> Prop) : Exists h0 := sorry --non-trivial
lemma new_lemma_136586 (h0 : function.extfun (Type 1) complete_lattice) : @is_compactly_generated.{1} (normed_lattice_add_comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (normed_lattice_add_comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_136587 (h0 : filter (has_neg (option (option unsigned)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_136588 (h0 : filter (measurable_space (has_norm empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_136589 (h0 : topological_space real) : topological_space.separable_space real := sorry --non-trivial
lemma new_lemma_136590 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) name) : @locally_compact_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_136591 (h0 : functor.comp ordered_add_comm_monoid mul_zero_class Type) : @archimedean.{1} (mul_zero_class.{1} Type) (@functor.comp.run.{1 1 1} ordered_add_comm_monoid.{1} mul_zero_class.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_136592 (h0 : complete_lattice (has_add (has_neg Type))) : is_compactly_generated (has_add (has_neg Type)) := sorry --non-trivial
lemma new_lemma_136593 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra pos)) (ring pos)) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.{0} pos)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_136594 (h1 : not (topological_space (id congr_arg_kind) -> false)) : @t0_space.{0} (@id.{2} Type congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type congr_arg_kind)) h1)  := sorry --non-trivial
lemma new_lemma_136595 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (@id.{2} Type string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type string_imp))  := sorry --non-trivial
lemma new_lemma_136596 (h0 : functor.add_const (filter (complete_distrib_lattice Type)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_136597 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @regular_space.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (simple_graph.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_136598 (h0 : semiring (non_assoc_semiring (semiring (semiring empty)))) : is_noetherian_ring (non_assoc_semiring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_136599 (h0 : topological_space (plift (semiring unsigned))) : irreducible_space (plift (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_136600 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_136601 (h0 : functor.add_const (topological_space (normed_linear_ordered_group num)) empty) : @t1_space.{0} (normed_linear_ordered_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_136602 (h1 : set (has_nnnorm linarith.comp_source)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_136603 (h0 : filter (canonically_ordered_comm_semiring (option ennreal))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_136604 (h0 : add_group (complete_semilattice_Sup (random_gen to_additive.value_type))) : is_add_cyclic (complete_semilattice_Sup (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_136605 (h0 : topological_space (has_one (has_norm (has_norm linarith.comp)))) : totally_separated_space (has_one (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_136606 (h0 : monoid (ordered_comm_ring pos)) : monoid.fg (ordered_comm_ring pos) := sorry --non-trivial
lemma new_lemma_136607 (h0 : topological_space (has_nndist (finset name))) : locally_compact_space (has_nndist (finset name)) := sorry --non-trivial
lemma new_lemma_136608 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_136609 (h0 : functor.add_const (topological_space (has_neg unsigned)) pos) : @locally_compact_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_136610 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_136611 (h1 : linarith.comp) (h2 : sym2 linarith.comp) : sym2.mem h1 h2 := sorry --non-trivial
lemma new_lemma_136612 (h0 : list (has_top (random_gen linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_136613 (h0 : functor.add_const (list (has_neg pos)) (add_comm_monoid (has_add name))) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_136614 (h0 : topological_space (non_assoc_semiring unsigned)) : normal_space (non_assoc_semiring unsigned) := sorry --non-trivial
lemma new_lemma_136615 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_136616 (h0 : functor.add_const (function.extfun Type uniform_space) num) : @complete_space.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) num h0) (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_136617 (h0 : group (simple_graph (ring linarith.comp))) : normalizer_condition (simple_graph (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_136618 (h0 : functor.comp group has_nnnorm (has_top (random_gen (random_gen (random_gen fun_info))))) : @group.fg.{0} (has_nnnorm.{0} (has_top.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} fun_info))))) (@functor.comp.run.{0 0 0} group.{0} has_nnnorm.{0} (has_top.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} fun_info)))) h0)  := sorry --non-trivial
lemma new_lemma_136619 (h0 : functor.add_const (filter (cancel_monoid unsigned)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_136620 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_136621 (h0 : set (has_le char)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_136622 (h0 : ring (complete_semilattice_Sup empty)) : rank_condition (complete_semilattice_Sup empty) := sorry --non-trivial
lemma new_lemma_136623 (h1 : uniform_space (normed_field string_imp)) : complete_space (normed_field string_imp) := sorry --non-trivial
lemma new_lemma_136624 (h0 : prod (mul_zero_class num) (mul_zero_class num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_136625 (h0 : topological_space (semiring (has_norm num))) : totally_separated_space (semiring (has_norm num)) := sorry --non-trivial
lemma new_lemma_136626 (h0 : topological_space (has_bot (has_Inf Type))) : regular_space (has_bot (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_136627 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (option pos)) := sorry --non-trivial
lemma new_lemma_136628 (h0 : ring (comm_semigroup (has_bot (sub_neg_monoid real)))) : rank_condition (comm_semigroup (has_bot (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_136629 (h0 : ring (complete_semilattice_Sup (has_nnnorm linarith.comp_source))) : strong_rank_condition (complete_semilattice_Sup (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_136630 (h0 : ring (has_lt (metric_space (random_gen char)))) : rank_condition (has_lt (metric_space (random_gen char))) := sorry --non-trivial
lemma new_lemma_136631 (h0 : list (add_comm_monoid (has_to_string pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_136632 (h0 : list (non_assoc_semiring congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_136633 (h0 : group (comm_group (option pos))) : is_cyclic (comm_group (option pos)) := sorry --non-trivial
lemma new_lemma_136634 (h0 : topological_space (semigroup (boolean_algebra name))) : locally_compact_space (semigroup (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_136635 (h0 : functor.add_const (filter (canonically_ordered_comm_semiring unsigned)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_136636 (h0 : ring (mul_zero_class (semiring (semiring (semiring congr_arg_kind))))) : is_domain (mul_zero_class (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_136637 (h1 h2 : multiset (has_ssubset linarith.ineq)) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_136638 (h0 : functor.add_const (complete_lattice (normed_comm_ring Type)) pos) : @is_compactly_generated.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (normed_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_136639 (h0 : group (add_cancel_monoid (has_nndist linarith.comp))) : group.fg (add_cancel_monoid (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_136640 (h0 : functor.add_const (add_monoid (finset pos)) Type) : @add_monoid.fg.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (add_monoid.{0} (finset.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_136641 (h0 : group (ordered_comm_monoid (has_neg (has_Inf name)))) : normalizer_condition (ordered_comm_monoid (has_neg (has_Inf name))) := sorry --non-trivial
lemma new_lemma_136642 (h0 : topological_space (linear_ordered_add_comm_group (pseudo_metric_space fun_info))) : path_connected_space (linear_ordered_add_comm_group (pseudo_metric_space fun_info)) := sorry --non-trivial
lemma new_lemma_136643 (h0 : functor.add_const (topological_space (finset name)) pos) : @t0_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_136644 (h0 : group (ordered_comm_ring (has_Inf pos))) : normalizer_condition (ordered_comm_ring (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_136645 (h0 : topological_space (mul_one_class std_gen)) (h1 : add_group (mul_one_class std_gen)) : topological_add_group (mul_one_class std_gen) := sorry --non-trivial
lemma new_lemma_136646 (h0 : monoid (has_add (has_add pos))) : monoid.fg (has_add (has_add pos)) := sorry --non-trivial
lemma new_lemma_136647 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_136648 (h0 : topological_space (boolean_algebra.core (boolean_algebra.core Type))) : loc_path_connected_space (boolean_algebra.core (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_136649 (h0 : semiring (mul_zero_class (semiring congr_arg_kind))) : is_noetherian_ring (mul_zero_class (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_136650 (h0 : topological_space (canonically_ordered_comm_semiring congr_arg_kind)) : preirreducible_space (canonically_ordered_comm_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_136651 (h0 : ring (comm_group (comm_group unsigned))) : strong_rank_condition (comm_group (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_136652 (h0 : topological_space (has_neg_part environment.implicit_infer_kind)) : normal_space (has_neg_part environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_136653 (h0 : filter (denumerable linarith.ineq)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_136654 (h0 : ring (normed_group (random_gen string_imp))) : rank_condition (normed_group (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_136655 (h1 : topological_space (add_comm_semigroup (add_comm_semigroup char))) (h2 : preorder (add_comm_semigroup (add_comm_semigroup char))) : order_closed_topology (add_comm_semigroup (add_comm_semigroup char)) := sorry --non-trivial
lemma new_lemma_136656 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_136657 (h0 : complete_lattice (non_unital_non_assoc_semiring (mul_one_class to_additive.value_type))) : is_compactly_generated (non_unital_non_assoc_semiring (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_136658 (h0 : semiring (monoid (option empty))) : is_noetherian_ring (monoid (option empty)) := sorry --non-trivial
lemma new_lemma_136659 (h1 : ring (complete_semilattice_Sup congr_arg_kind)) : rank_condition (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_136660 (h0 : not (topological_space (linear_ordered_comm_ring congr_arg_kind) -> false)) : @locally_compact_space.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_ring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_136661 (h0 : not (ring (denumerable linarith.comp_source) -> false)) : @rank_condition.{0} (denumerable.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (denumerable.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_136662 (h0 : complete_lattice (linear_ordered_comm_group_with_zero fun_info)) : is_compactly_generated (linear_ordered_comm_group_with_zero fun_info) := sorry --non-trivial
lemma new_lemma_136663 (h0 : topological_space (ordered_comm_ring (has_pos_part linarith.comp))) : loc_path_connected_space (ordered_comm_ring (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_136664 (h0 : not (topological_space (normed_group complex) -> false)) : @normal_space.{0} (normed_group.{0} complex) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} complex)) h0)  := sorry --non-trivial
lemma new_lemma_136665 (h0 : ring (add_monoid char)) : is_domain (add_monoid char) := sorry --non-trivial
lemma new_lemma_136666 (h0 : topological_space (has_top (random_gen to_additive.value_type))) : totally_disconnected_space (has_top (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_136667 (h0 : topological_space (mul_zero_class (has_nndist pos))) : totally_separated_space (mul_zero_class (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_136668 (h0 : functor.add_const (topological_space (linear_ordered_field empty)) unsigned) : @path_connected_space.{0} (linear_ordered_field.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_136669 (h3 : topological_space ereal) : topological_space.first_countable_topology ereal := sorry --non-trivial
lemma new_lemma_136670 (h0 : complete_lattice (complete_distrib_lattice num)) : is_compactly_generated (complete_distrib_lattice num) := sorry --non-trivial
lemma new_lemma_136671 (h0 : topological_space (canonically_linear_ordered_monoid (has_neg (has_Inf real)))) : preconnected_space (canonically_linear_ordered_monoid (has_neg (has_Inf real))) := sorry --non-trivial
lemma new_lemma_136672 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf real))) : irreducible_space (normed_lattice_add_comm_group (has_Inf real)) := sorry --non-trivial
lemma new_lemma_136673 (h0 : function.extfun Type topological_space) : @t0_space.{0} linarith.ineq (@function.extfun_app.{2 1} Type topological_space.{0} h0 linarith.ineq)  := sorry --non-trivial
lemma new_lemma_136674 (h0 : functor.add_const (filter (boolean_algebra Type)) environment.implicit_infer_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_136675 (h0 : set (string.iterator_imp -> reducibility_hints)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_136676 (h0 : functor.add_const (complete_lattice (finset pos)) name) : @complete_lattice.is_Sup_finite_compact.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_136677 (h2 : set string.iterator_imp) : set.finite h2 := sorry --non-trivial
lemma new_lemma_136678 (h0 : group (finset (ring (ring (finset environment.implicit_infer_kind))))) : is_simple_group (finset (ring (ring (finset environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_136679 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (add_cancel_monoid.{0} (option.{0} (option.{0} (option.{0} ennreal)))) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_cancel_monoid.{0} (option.{0} (option.{0} (option.{0} ennreal)))))  := sorry --non-trivial
lemma new_lemma_136680 (h0 : complete_lattice (has_neg (finset environment.implicit_infer_kind))) : is_compactly_generated (has_neg (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_136681 (h0 : empty) : @multiset.sup.{0} Prop (@lattice.to_semilattice_sup.{0} Prop (@conditionally_complete_lattice.to_lattice.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice))) (@generalized_boolean_algebra.to_order_bot.{0} Prop (@boolean_algebra.to_generalized_boolean_algebra.{0} Prop Prop.boolean_algebra)) (@matrix.vec_empty.{0} (multiset.{0} Prop) (@empty.elim.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@id.{1} empty h0)))  := sorry --non-trivial
lemma new_lemma_136682 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_136683 (h0 : complete_lattice (add_cancel_monoid (finset Type))) : is_compactly_generated (add_cancel_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_136684 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (canonically_ordered_monoid.{0} (has_Inf.{0} pos)) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_monoid.{0} (has_Inf.{0} pos)))  := sorry --non-trivial
lemma new_lemma_136685 (h0 : functor.add_const (group (complete_distrib_lattice empty)) unsigned) : @normalizer_condition.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_136686 (h0 : topological_space (complete_distrib_lattice (has_pos_part linarith.comp))) : totally_disconnected_space (complete_distrib_lattice (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_136687 (h0 : filter (has_add congr_arg_kind)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_136688 (h0 : functor.comp filter add_comm_monoid Type) : filter.ne_bot (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_136689 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @path_connected_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_136690 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_136691 (h0 : topological_space (has_to_string (has_add pos))) : irreducible_space (has_to_string (has_add pos)) := sorry --non-trivial
lemma new_lemma_136692 (h0 : group (semigroup (comm_group Type))) : group.fg (semigroup (comm_group Type)) := sorry --non-trivial
lemma new_lemma_136693 (h0 : add_monoid (cancel_monoid (filter unsigned))) : add_monoid.fg (cancel_monoid (filter unsigned)) := sorry --non-trivial
lemma new_lemma_136694 (h0 : topological_space (finset (option ennreal))) : preconnected_space (finset (option ennreal)) := sorry --non-trivial
lemma new_lemma_136695 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @irreducible_space.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_136696 (h1 : set (nondiscrete_normed_field linarith.ineq)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_136697 (h0 : functor.add_const (group (has_nndist congr_arg_kind)) num) : @is_cyclic.{0} (has_nndist.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_136698 (h0 : functor.add_const (uniform_space (has_nndist linarith.comp)) (finset pos)) : @separated_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_nndist.{0} linarith.comp)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_136699 (h0 : functor.add_const (list (boolean_algebra.core Type)) (add_comm_monoid environment.implicit_infer_kind)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_136700 (h0 : functor.add_const (topological_space (preorder unsigned)) empty) : @t1_space.{0} (preorder.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_136701 (h0 : finset (option (semiring num))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_136702 (h0 : functor.add_const (uniform_space (boolean_algebra pos)) Type) : @separated_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_136703 (h0 : uniform_space (id to_additive.value_type)) : complete_space (id to_additive.value_type) := sorry --non-trivial
lemma new_lemma_136704 (h0 : not (topological_space (has_ssubset reducibility_hints) -> false)) : @t0_space.{0} (has_ssubset.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_136705 (h0 : not (setoid Prop -> false)) (h1 : quotient (classical.by_contradiction' h0)) : quotient.out' h1 := sorry --non-trivial
lemma new_lemma_136706 (h0 : functor.add_const (ordered_add_comm_monoid (has_pos_part pos)) (generalized_boolean_algebra pos)) : @archimedean.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_pos_part.{0} pos)) (generalized_boolean_algebra.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_136707 (h0 : functor.add_const (monoid (add_cancel_monoid Type)) name) : @monoid.fg.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (add_cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_136708 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (dlist.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (dlist.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_136709 (h0 : set (set char)) (h1 : set char) : measurable_space.dynkin_system.generate_has h0 h1 := sorry --non-trivial
lemma new_lemma_136710 (h0 : filter (has_zero (has_neg environment.implicit_infer_kind))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_136711 (h0 : complete_lattice (distrib_lattice fun_info)) (h1 : option (complete_lattice (distrib_lattice fun_info))) : complete_lattice.is_Sup_finite_compact (distrib_lattice fun_info) := sorry --non-trivial
lemma new_lemma_136712 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_136713 (h0 : topological_space (has_nndist (finset name))) : regular_space (has_nndist (finset name)) := sorry --non-trivial
lemma new_lemma_136714 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (comm_group pos)) := sorry --non-trivial
lemma new_lemma_136715 (h0 : group (has_compl (has_ssubset linarith.ineq))) : group.fg (has_compl (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_136716 (h0 : ring rat) : strong_rank_condition rat := sorry --non-trivial
lemma new_lemma_136717 (h1 : topological_space (nondiscrete_normed_field (normed_field reducibility_hints))) (h2 : add_group (nondiscrete_normed_field (normed_field reducibility_hints))) : topological_add_group (nondiscrete_normed_field (normed_field reducibility_hints)) := sorry --non-trivial
lemma new_lemma_136718 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) (boolean_algebra environment.implicit_infer_kind)) : @topological_space.separable_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) (boolean_algebra.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_136719 (h0 : topological_space (has_nndist (ring environment.implicit_infer_kind))) : regular_space (has_nndist (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_136720 (h3 : ring (normed_field string_imp)) : is_domain (normed_field string_imp) := sorry --non-trivial
lemma new_lemma_136721 (h0 : ring (canonically_ordered_add_monoid congr_arg_kind)) : is_principal_ideal_ring (canonically_ordered_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_136722 (h0 : uniform_space (complete_distrib_lattice (add_comm_monoid Type))) : separated_space (complete_distrib_lattice (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_136723 (h0 : functor.add_const (topological_space (semigroup pos)) linarith.comp) : @regular_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_136724 (h0 : group (canonically_linear_ordered_monoid real)) : is_cyclic (canonically_linear_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_136725 (h0 : topological_space (add_cancel_monoid (has_add (has_add (has_add (has_to_string pos)))))) : path_connected_space (add_cancel_monoid (has_add (has_add (has_add (has_to_string pos))))) := sorry --non-trivial
lemma new_lemma_136726 (h0 : ring (has_ssubset (random_gen (has_nnnorm linarith.comp_source)))) : rank_condition (has_ssubset (random_gen (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_136727 (h0 : functor.add_const (topological_space (has_star empty)) num) : @t1_space.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_136728 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (semi_normed_comm_ring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (semi_normed_comm_ring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_136729 (h1 : add_group stieltjes_function) : is_add_cyclic stieltjes_function := sorry --non-trivial
lemma new_lemma_136730 (h0 : monoid (sub_neg_monoid linarith.comp)) : monoid.fg (sub_neg_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_136731 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_136732 (h0 : add_group (has_le environment.projection_info)) : is_add_cyclic (has_le environment.projection_info) := sorry --non-trivial
lemma new_lemma_136733 (h0 : topological_space (with_bot (has_inv (has_inv (has_inv (has_inv fun_info)))))) : locally_compact_space (with_bot (has_inv (has_inv (has_inv (has_inv fun_info))))) := sorry --non-trivial
lemma new_lemma_136734 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_136735 (h0 : topological_space (linear_order (add_left_cancel_semigroup (add_left_cancel_semigroup unsigned)))) : preirreducible_space (linear_order (add_left_cancel_semigroup (add_left_cancel_semigroup unsigned))) := sorry --non-trivial
lemma new_lemma_136736 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm fun_info))) : @monoid.fg.{0} (has_norm.{0} fun_info) (@finset.pi.empty.{1 0} Type monoid.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_136737 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (linear_ordered_field.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} num))  := sorry --non-trivial
lemma new_lemma_136738 (h0 : ring (normed_group (has_top (has_top (has_top fun_info))))) : rank_condition (normed_group (has_top (has_top (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_136739 (h0 : complete_lattice (has_bot (has_add Type))) : is_compactly_generated (has_bot (has_add Type)) := sorry --non-trivial
lemma new_lemma_136740 (h0 : function.extfun Type ring) : @invariant_basis_number.{0} (linear_ordered_cancel_comm_monoid.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_cancel_comm_monoid.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_136741 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) pos) : @sequential_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_136742 (h0 : functor.add_const (function.extfun Type uniform_space) pos) : @separated_space.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) pos h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_136743 (h3 : topological_space (nondiscrete_normed_field fun_info)) (h4 : set (nondiscrete_normed_field fun_info)) : is_path_connected h4 := sorry --non-trivial
lemma new_lemma_136744 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_136745 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_compactly_generated.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_136746 (h0 : finset (generalized_boolean_algebra (has_pos_part (has_add (has_pos_part (has_add Type)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_136747 (h0 : topological_space (measure_theory.measure_space congr_arg_kind)) : preirreducible_space (measure_theory.measure_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_136748 (h0 : add_group (distrib_lattice (has_nnnorm (has_nnnorm fun_info)))) : is_add_cyclic (distrib_lattice (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_136749 (h0 : topological_space (has_neg (has_nndist name))) : topological_space.separable_space (has_neg (has_nndist name)) := sorry --non-trivial
lemma new_lemma_136750 (h0 : topological_space (complete_distrib_lattice (option (option (option (option ennreal)))))) : discrete_topology (complete_distrib_lattice (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_136751 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_136752 (h0 : functor.add_const (ordered_comm_monoid (has_to_string Type)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (has_to_string.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_136753 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (complete_linear_order empty)) := sorry --non-trivial
lemma new_lemma_136754 (h0 : functor.add_const (topological_space pos) unsigned) : @t1_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) unsigned h0)  := sorry --non-trivial
lemma new_lemma_136755 (h0 : not (topological_space (random_gen num) -> false)) : @totally_disconnected_space.{0} (random_gen.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_136756 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_disconnected_space.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_136757 (h0 : topological_space (has_one (id linarith.comp))) : irreducible_space (has_one (id linarith.comp)) := sorry --non-trivial
lemma new_lemma_136758 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) (boolean_algebra (boolean_algebra (has_neg Type)))) : @discrete_topology.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} pos)) (boolean_algebra.{1} (boolean_algebra.{1} (has_neg.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_136759 (h0 : ring (complete_distrib_lattice pos)) : is_principal_ideal_ring (complete_distrib_lattice pos) := sorry --non-trivial
lemma new_lemma_136760 (h0 : function.extfun Type topological_space) : @normal_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_136761 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_add.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} num))  := sorry --non-trivial
lemma new_lemma_136762 (h0 : monoid (has_dist congr_arg_kind)) : monoid.fg (has_dist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_136763 (h0 : topological_space (has_one empty)) : discrete_topology (has_one empty) := sorry --non-trivial
lemma new_lemma_136764 (h0 : ring (left_cancel_monoid (semiring (semiring (semiring (semiring empty)))))) : rank_condition (left_cancel_monoid (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_136765 (h0 : group (ordered_comm_monoid (ring (ring name)))) : group.fg (ordered_comm_monoid (ring (ring name))) := sorry --non-trivial
lemma new_lemma_136766 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (complete_distrib_lattice Type)) := sorry --non-trivial
lemma new_lemma_136767 (h0 : functor.add_const (topological_space (has_neg pos)) name) : @totally_disconnected_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_136768 (h0 : functor.add_const (functor.add_const (topological_space Type) Type) Type) : @totally_disconnected_space.{1} Type (@functor.add_const.run.{1 1} (topological_space.{1} Type) Type (@functor.add_const.run.{1 1} (functor.add_const.{1 1} (topological_space.{1} Type) Type) Type h0))  := sorry --non-trivial
lemma new_lemma_136769 (h0 : pnat) (h1 : fin has_zero.zero) : pnat.coprime (id h0) (matrix.vec_empty h1) := sorry --non-trivial
lemma new_lemma_136770 (h0 : complete_lattice (has_nnnorm (has_nnnorm char))) : complete_lattice.is_Sup_finite_compact (has_nnnorm (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_136771 (h0 : uniform_space (option empty)) : separated_space (option empty) := sorry --non-trivial
lemma new_lemma_136772 (h1 : topological_space (semiring congr_arg_kind)) : totally_disconnected_space (semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_136773 (h0 : functor.add_const (ring (semigroup linarith.comp)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_136774 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (mul_zero_class empty)) := sorry --non-trivial
lemma new_lemma_136775 (h0 : has_coe std_gen Prop) (h2 : std_gen) : @coe_b.{1 1} std_gen Prop h0 h2  := sorry --non-trivial
lemma new_lemma_136776 (h0 : list (plift (preorder congr_arg_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_136777 (h1 : group (random_gen (comm_ring (comm_ring char)))) : is_cyclic (random_gen (comm_ring (comm_ring char))) := sorry --non-trivial
lemma new_lemma_136778 (h0 : functor.add_const (group (boolean_algebra name)) (boolean_algebra name)) : @is_simple_group.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} name)) (boolean_algebra.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_136779 (h0 : has_mem.mem (has_top linarith.comp_source) has_emptyc.emptyc) : @is_add_cyclic.{0} (has_top.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type add_group.{0} (has_top.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_136780 (h0 : functor.add_const (group (comm_group linarith.comp)) (has_to_string (has_to_string (has_neg linarith.comp)))) : @is_simple_group.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} linarith.comp)) (has_to_string.{0} (has_to_string.{0} (has_neg.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_136781 (h0 : topological_space (semigroup (normed_comm_ring (mul_one_class pos)))) : t0_space (semigroup (normed_comm_ring (mul_one_class pos))) := sorry --non-trivial
lemma new_lemma_136782 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (linear_ordered_field.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (linear_ordered_field.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_136783 (h0 : topological_space (has_append reducibility_hints)) : totally_disconnected_space (has_append reducibility_hints) := sorry --non-trivial
lemma new_lemma_136784 (h0 : functor.add_const (list (has_to_string Type)) (ring (has_to_string linarith.comp))) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_136785 (h0 : topological_space (semigroup (has_to_string (has_Inf linarith.comp)))) : normal_space (semigroup (has_to_string (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_136786 (h0 : fin has_zero.zero) : @separated_space.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_136787 (h0 : functor.add_const (functor.comp monoid mul_zero_class pos) Type) : @monoid.fg.{0} (mul_zero_class.{0} pos) (@functor.comp.run.{0 0 0} monoid.{0} mul_zero_class.{0} pos (@functor.add_const.run.{0 1} (functor.comp.{0 0 0} monoid.{0} mul_zero_class.{0} pos) Type h0))  := sorry --non-trivial
lemma new_lemma_136788 (h0 : functor.add_const (complete_lattice (has_neg Type)) pos) : @complete_lattice.is_Sup_finite_compact.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_neg.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_136789 (h0 : functor.add_const (semiring (normed_comm_ring Type)) linarith.comp) : @is_noetherian_ring.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (normed_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_136790 (h0 : topological_space (div_inv_monoid to_additive.value_type)) : locally_compact_space (div_inv_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_136791 (h0 : functor.add_const (uniform_space (has_edist empty)) empty) : @complete_space.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_edist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_136792 (h0 : topological_space (comm_group (semigroup (has_add Type)))) : locally_compact_space (comm_group (semigroup (has_add Type))) := sorry --non-trivial
lemma new_lemma_136793 (h0 : topological_space (partial_order (semiring num))) : normal_space (partial_order (semiring num)) := sorry --non-trivial
lemma new_lemma_136794 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (non_unital_non_assoc_ring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (non_unital_non_assoc_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_136795 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (canonically_ordered_comm_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (canonically_ordered_comm_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_136796 (h0 : topological_space (id (has_inv (has_top linarith.comp_source)))) : path_connected_space (id (has_inv (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_136797 (h0 : filter (has_to_string (option (option ennreal)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_136798 (h0 : function.extfun nat fin) : @regular_space.{0} (simple_graph.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (simple_graph.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_136799 (h0 : add_monoid (has_add (has_Inf (has_add (finset pos))))) : add_monoid.fg (has_add (has_Inf (has_add (finset pos)))) := sorry --non-trivial
lemma new_lemma_136800 (h0 : topological_space (boolean_algebra.core (has_nndist (finset ennreal)))) : t1_space (boolean_algebra.core (has_nndist (finset ennreal))) := sorry --non-trivial
lemma new_lemma_136801 (h0 : monoid ennreal -> monoid ennreal -> Prop) : is_symm (monoid ennreal) h0 := sorry --non-trivial
lemma new_lemma_136802 (h0 : group (has_top linarith.ineq)) : is_cyclic (has_top linarith.ineq) := sorry --non-trivial
lemma new_lemma_136803 (h0 : set (semi_normed_comm_ring (mul_one_class (mul_one_class (mul_one_class (mul_one_class fun_info)))))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_136804 (h0 : ring (ring (comm_group environment.implicit_infer_kind))) : rank_condition (ring (comm_group environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_136805 (h0 : not (complete_lattice (has_top num) -> false)) : @is_compactly_generated.{0} (has_top.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_top.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_136806 (h0 : ring (comm_group (option (option (option (ring pos)))))) : is_domain (comm_group (option (option (option (ring pos))))) := sorry --non-trivial
lemma new_lemma_136807 (h0 : functor.add_const (ring (has_nndist linarith.comp)) Type) : @strong_rank_condition.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (has_nndist.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_136808 (h0 : complete_lattice (cancel_monoid (normed_comm_ring environment.implicit_infer_kind))) : is_atomistic (cancel_monoid (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_136809 (h0 : ring (semi_normed_comm_ring fun_info)) : is_domain (semi_normed_comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_136810 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h1 filter) empty) := sorry --non-trivial
lemma new_lemma_136811 (h0 : function.extfun Type group) : @normalizer_condition.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_136812 (h0 : uniform_space (has_add (option ennreal))) : complete_space (has_add (option ennreal)) := sorry --non-trivial
lemma new_lemma_136813 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra.core Type)) name) : @has_exists_mul_of_le.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (boolean_algebra.core.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_136814 (h0 : functor.add_const (ring (canonically_ordered_monoid pos)) Type) : @is_principal_ideal_ring.{0} (canonically_ordered_monoid.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (canonically_ordered_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_136815 (h0 : functor.add_const (topological_space (free_add_monoid unsigned)) num) : @preirreducible_space.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_136816 (h1 : ring (has_lt string_imp)) : is_domain (has_lt string_imp) := sorry --non-trivial
lemma new_lemma_136817 (h1 : not (topological_space (with_one linarith.comp_source) -> false)) : @path_connected_space.{0} (with_one.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_136818 (h0 : semiring (omega_complete_partial_order (option unsigned))) : is_noetherian_ring (omega_complete_partial_order (option unsigned)) := sorry --non-trivial
lemma new_lemma_136819 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_nnnorm.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nnnorm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_136820 (h0 : ring (semi_normed_ring string_imp)) : is_domain (semi_normed_ring string_imp) := sorry --non-trivial
lemma new_lemma_136821 (h0 : topological_space (ordered_comm_ring (has_neg (has_neg name)))) : discrete_topology (ordered_comm_ring (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_136822 (h0 : monoid (has_top (has_inv (has_inv to_additive.value_type)))) : monoid.fg (has_top (has_inv (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_136823 (h0 : add_group (has_emptyc (has_ssubset fun_info))) : is_add_cyclic (has_emptyc (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_136824 (h0 : functor.comp topological_space option pos) : @t1_space.{0} (option.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} option.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_136825 (h0 : functor.add_const (ring (ring linarith.comp)) (has_neg Type)) : @rank_condition.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (ring.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_136826 (h0 : functor.add_const (ring (has_star empty)) empty) : @rank_condition.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (has_star.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_136827 (h0 : function.extfun nat fin) : @path_connected_space.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (sub_neg_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_136828 (h0 : fin has_zero.zero) : @add_monoid.fg.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (add_monoid.{1} (sub_neg_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_136829 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_sub.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_sub.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_136830 (h0 : ring (random_gen (random_gen linarith.ineq))) : strong_rank_condition (random_gen (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_136831 (h0 : complete_lattice (measurable_space linarith.comp_source)) : is_atomistic (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_136832 (h1 : not (ring linarith.ineq -> false)) : @is_domain.{0} linarith.ineq (@classical.by_contradiction'.{1} (ring.{0} linarith.ineq) h1)  := sorry --non-trivial
lemma new_lemma_136833 (h0 : topological_space (semigroup (complete_distrib_lattice environment.implicit_infer_kind))) : t1_space (semigroup (complete_distrib_lattice environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_136834 (h0 : functor.add_const (function.extfun Type complete_lattice) name) : @is_compactly_generated.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) name h0) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_136835 (h2 : ring (has_nnnorm to_additive.value_type)) : strong_rank_condition (has_nnnorm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_136836 (h0 : ring (dlist to_additive.value_type)) : strong_rank_condition (dlist to_additive.value_type) := sorry --non-trivial
lemma new_lemma_136837 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (normed_lattice_add_comm_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_136838 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_136839 (h0 : functor.comp cancel_comm_monoid_with_zero complete_distrib_lattice unsigned) : @unique_factorization_monoid.{0} (complete_distrib_lattice.{0} unsigned) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} complete_distrib_lattice.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_136840 (h0 : functor.add_const (group (add_comm_monoid pos)) Type) : @is_simple_group.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (add_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_136841 (h0 : functor.add_const (topological_space (ordered_ring empty)) num) : @path_connected_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_136842 (h0 : topological_space (simple_graph (has_add Type))) : preconnected_space (simple_graph (has_add Type)) := sorry --non-trivial
lemma new_lemma_136843 (h0 : topological_space (canonically_ordered_comm_semiring (option (pseudo_metric_space ennreal)))) : discrete_topology (canonically_ordered_comm_semiring (option (pseudo_metric_space ennreal))) := sorry --non-trivial
lemma new_lemma_136844 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_136845 (h0 : not (topological_space (fintype fun_info) -> false)) : @totally_disconnected_space.{0} (fintype.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (fintype.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_136846 (h0 : add_monoid (omega_complete_partial_order (option (option (option unsigned))))) : add_monoid.fg (omega_complete_partial_order (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_136847 (h0 : functor.add_const (add_monoid (complete_distrib_lattice name)) (semigroup unsigned)) : @add_monoid.fg.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (complete_distrib_lattice.{0} name)) (semigroup.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_136848 (h0 : list (with_one (random_gen (has_ssubset linarith.ineq)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_136849 (h0 : topological_space (comm_ring (random_gen (linear_ordered_add_comm_group string_imp)))) : irreducible_space (comm_ring (random_gen (linear_ordered_add_comm_group string_imp))) := sorry --non-trivial
lemma new_lemma_136850 (h0 : not (filter (add_monoid linarith.ineq) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_136851 (h1 : ring (has_append (random_gen char))) : strong_rank_condition (has_append (random_gen char)) := sorry --non-trivial
lemma new_lemma_136852 (h0 : filter (normed_comm_ring (finset (has_neg linarith.comp)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_136853 (h1 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_136854 (h0 : uniform_space (has_neg_part (semigroup (mul_zero_class name)))) : separated_space (has_neg_part (semigroup (mul_zero_class name))) := sorry --non-trivial
lemma new_lemma_136855 (h0 : topological_space (boolean_algebra (ring (has_Inf (ring environment.implicit_infer_kind))))) : irreducible_space (boolean_algebra (ring (has_Inf (ring environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_136856 (h0 : function.extfun Type topological_space) : @regular_space.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type topological_space.{0} h0 environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_136857 (h0 : function.extfun Type topological_space) : @normal_space.{0} (semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_136858 (h0 : topological_space (plift (semiring (semiring congr_arg_kind)))) : topological_space.separable_space (plift (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_136859 (h0 : monoid (random_gen (comm_ring (comm_ring (random_gen linarith.ineq))))) : monoid.fg (random_gen (comm_ring (comm_ring (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_136860 (h0 : functor.add_const (uniform_space (has_zero unsigned)) Type) : @complete_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_zero.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_136861 (h1 : uniform_space (measurable_space (random_gen (random_gen (with_bot to_additive.value_type))))) : complete_space (measurable_space (random_gen (random_gen (with_bot to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_136862 (h0 : topological_space (add_cancel_monoid (has_neg (has_Inf pos)))) : regular_space (add_cancel_monoid (has_neg (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_136863 (h0 : monoid (mul_zero_class environment.implicit_infer_kind)) : monoid.fg (mul_zero_class environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_136864 (h0 : add_group (random_gen (has_ssubset linarith.ineq))) : is_add_cyclic (random_gen (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_136865 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_136866 (h0 : uniform_space (simple_graph (ring linarith.comp))) : complete_space (simple_graph (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_136867 (h0 : complete_lattice (generalized_boolean_algebra (finset name))) : is_compactly_generated (generalized_boolean_algebra (finset name)) := sorry --non-trivial
lemma new_lemma_136868 (h2 : set (string.iterator_imp -> ereal)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_136869 (h0 : not (function.extfun (finset Type) (has_mem.mem num) -> false)) : @is_add_cyclic.{0} num (@finset.pi.empty.{1 0} Type add_group.{0} num (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num)) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_136870 (h0 : add_group (topological_space (has_nnnorm (denumerable (has_nnnorm char))))) : is_add_cyclic (topological_space (has_nnnorm (denumerable (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_136871 (h0 : cancel_comm_monoid_with_zero (comm_group ennreal)) : unique_factorization_monoid (comm_group ennreal) := sorry --non-trivial
lemma new_lemma_136872 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @regular_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_136873 (h0 : finset (linear_ordered_comm_group (option unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_136874 (h0 : group (finset (finset (finset (finset (finset pos)))))) : is_simple_group (finset (finset (finset (finset (finset pos))))) := sorry --non-trivial
lemma new_lemma_136875 (h0 : functor.add_const Prop (canonically_ordered_comm_semiring pos)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_136876 (h0 : complete_lattice (has_inv (random_gen to_additive.value_type))) : is_compactly_generated (has_inv (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_136877 (h0 : uniform_space (has_Inf (has_Inf (has_pos_part name)))) : separated_space (has_Inf (has_Inf (has_pos_part name))) := sorry --non-trivial
lemma new_lemma_136878 (h0 : functor.add_const (topological_space (has_nndist ennreal)) name) : @irreducible_space.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_136879 (h0 : monoid (normed_group (has_norm num))) : monoid.fg (normed_group (has_norm num)) := sorry --non-trivial
lemma new_lemma_136880 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (normed_linear_ordered_group.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (normed_linear_ordered_group.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_136881 (h0 : uniform_space (boolean_algebra (finset (has_add (has_add (finset (has_pos_part Type))))))) : complete_space (boolean_algebra (finset (has_add (has_add (finset (has_pos_part Type)))))) := sorry --non-trivial
lemma new_lemma_136882 (h0 : ring (dlist (has_nnnorm (random_gen (has_nnnorm (has_inv linarith.comp_source)))))) : rank_condition (dlist (has_nnnorm (random_gen (has_nnnorm (has_inv linarith.comp_source))))) := sorry --non-trivial
lemma new_lemma_136883 (h0 : functor.add_const Prop (has_nndist (option (option ennreal)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_136884 (h0 : functor.add_const (function.extfun Type (functor.add_const Prop)) linarith.comp) : functor.add_const.run (function.extfun_app (functor.add_const.run h0) (has_zero name)) := sorry --non-trivial
lemma new_lemma_136885 (h0 : complete_lattice (add_cancel_monoid (finset (boolean_algebra linarith.comp)))) : is_compactly_generated (add_cancel_monoid (finset (boolean_algebra linarith.comp))) := sorry --non-trivial
lemma new_lemma_136886 (h0 : not (topological_space (partial_order empty) -> false)) : @totally_separated_space.{0} (partial_order.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (partial_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_136887 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_136888 (h0 : group (semiring (has_top (random_gen linarith.ineq)))) : group.fg (semiring (has_top (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_136889 (h0 : functor.add_const (monoid (add_cancel_monoid pos)) linarith.comp) : @monoid.fg.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (add_cancel_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_136890 (h0 : functor.add_const (topological_space (boolean_algebra pos)) linarith.comp) : @preconnected_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_136891 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_136892 (h0 : uniform_space (id (semiring congr_arg_kind))) : complete_space (id (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_136893 (h0 : ordered_add_comm_monoid (finset pos)) : archimedean (finset pos) := sorry --non-trivial
lemma new_lemma_136894 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_inter.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_inter.{0} num))  := sorry --non-trivial
lemma new_lemma_136895 (h0 : functor.add_const (topological_space (has_star empty)) empty) : @normal_space.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_136896 (h2 : add_group (uniform_space string.iterator_imp)) : is_add_cyclic (uniform_space string.iterator_imp) := sorry --non-trivial
lemma new_lemma_136897 (h0 : functor.add_const (monoid (has_to_string name)) unsigned) : @monoid.fg.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (has_to_string.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_136898 (h0 : functor.add_const (group (comm_group pos)) environment.implicit_infer_kind) : @group.fg.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_136899 (h0 : group (metric_space (random_gen string_imp))) : is_cyclic (metric_space (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_136900 (h0 : topological_space (has_neg (has_nndist (has_add (finset (finset pos)))))) : path_connected_space (has_neg (has_nndist (has_add (finset (finset pos))))) := sorry --non-trivial
lemma new_lemma_136901 (h0 : add_group (linear_ordered_comm_group num)) : is_add_cyclic (linear_ordered_comm_group num) := sorry --non-trivial
lemma new_lemma_136902 (h0 : functor.add_const (complete_lattice (has_dist num)) unsigned) : @is_atomistic.{0} (has_dist.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_dist.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_136903 (h0 : functor.add_const (topological_space (has_star num)) congr_arg_kind) : @path_connected_space.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_136904 (h0 : filter (cancel_monoid (has_add Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_136905 (h0 : functor.add_const (group (has_to_string pos)) pos) : @is_cyclic.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_136906 (h0 : topological_space (ring environment.implicit_infer_kind)) : preconnected_space (ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_136907 (h0 : group (canonically_linear_ordered_monoid (option (option ennreal)))) : normalizer_condition (canonically_linear_ordered_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_136908 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_bot.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_136909 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) linarith.comp) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_136910 (h0 : set (has_div (mul_one_class (mul_one_class linarith.ineq)))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_136911 (h0 : list (mul_zero_class (has_add ennreal))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_136912 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) pos) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_136913 (h0 : ring (has_emptyc (random_gen linarith.ineq))) : strong_rank_condition (has_emptyc (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_136914 (h0 : semiring (has_union (semiring (semiring (add_group congr_arg_kind))))) : is_noetherian_ring (has_union (semiring (semiring (add_group congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_136915 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_136916 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (add_right_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (add_right_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_136917 (h0 : functor.add_const (topological_space (non_assoc_semiring empty)) unsigned) : @t1_space.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_136918 (h0 : uniform_space (sub_neg_monoid (canonically_linear_ordered_monoid name))) : complete_space (sub_neg_monoid (canonically_linear_ordered_monoid name)) := sorry --non-trivial
lemma new_lemma_136919 (h0 : complete_lattice (has_pos_part (has_pos_part (has_add linarith.comp)))) : is_compactly_generated (has_pos_part (has_pos_part (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_136920 (h0 : finset (boolean_algebra (add_comm_monoid pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_136921 (h0 : add_group (ring (finset linarith.comp))) : is_add_cyclic (ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_136922 (h2 : complete_lattice (has_div enat)) : complete_lattice.is_Sup_finite_compact (has_div enat) := sorry --non-trivial
lemma new_lemma_136923 (h2 : complete_lattice (semi_normed_ring string_imp)) : complete_lattice.is_Sup_finite_compact (semi_normed_ring string_imp) := sorry --non-trivial
lemma new_lemma_136924 (h0 : topological_space (has_pos_part (ring Type))) : totally_separated_space (has_pos_part (ring Type)) := sorry --non-trivial
lemma new_lemma_136925 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_star.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_star.{0} empty))  := sorry --non-trivial
lemma new_lemma_136926 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (random_gen.{0} string_imp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (random_gen.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_136927 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_136928 (h0 : topological_space (add_right_cancel_monoid unsigned)) : locally_compact_space (add_right_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_136929 (h0 : topological_space (has_Inf pos)) : regular_space (has_Inf pos) := sorry --non-trivial
lemma new_lemma_136930 (h0 : function.extfun Type group) : @normalizer_condition.{0} (measurable_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_136931 (h0 : uniform_space (id (random_gen linarith.ineq))) : complete_space (id (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_136932 (h0 : has_lt (has_nnnorm linarith.comp_source)) : no_max_order (has_nnnorm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_136933 (h0 : char -> char -> Prop) (h1 h2 : char) : relation.refl_trans_gen h0 h1 h2 := sorry --non-trivial
lemma new_lemma_136934 (h0 : not (filter (distrib to_additive.value_type) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_136935 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_136936 (h0 : topological_space (add_group (semiring (semiring empty)))) : irreducible_space (add_group (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_136937 (h0 : complete_lattice (has_ssubset (random_gen (random_gen (has_top to_additive.value_type))))) : is_compactly_generated (has_ssubset (random_gen (random_gen (has_top to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_136938 (h0 : has_lt linarith.comp_source) : no_max_order linarith.comp_source := sorry --non-trivial
lemma new_lemma_136939 (h0 : function.extfun Type group) : @group.fg.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_136940 (h0 : ring (dlist (has_nnnorm (random_gen fun_info)))) : strong_rank_condition (dlist (has_nnnorm (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_136941 (h0 : functor.add_const (add_monoid (ring Type)) (ring pos)) : @add_monoid.fg.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (ring.{1} Type)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_136942 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra environment.implicit_infer_kind)) Type) : @has_exists_mul_of_le.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_136943 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (normed_group linarith.ineq)) := sorry --non-trivial
lemma new_lemma_136944 (h0 : functor.add_const (group (boolean_algebra linarith.comp)) (has_neg name)) : @normalizer_condition.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} linarith.comp)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_136945 (h0 : ring (canonically_ordered_monoid pos)) : is_domain (canonically_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_136946 (h0 : complete_lattice (has_top linarith.comp_source)) : is_atomistic (has_top linarith.comp_source) := sorry --non-trivial
lemma new_lemma_136947 (h0 : add_group (ordered_comm_ring linarith.comp)) : is_add_cyclic (ordered_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_136948 (h0 : topological_space (plift (option (semiring num)))) : t0_space (plift (option (semiring num))) := sorry --non-trivial
lemma new_lemma_136949 (h0 : has_lt (mul_one_class environment.projection_info)) : no_max_order (mul_one_class environment.projection_info) := sorry --non-trivial
lemma new_lemma_136950 (h0 : not (ring (has_ssubset linarith.comp_source) -> false)) : @rank_condition.{0} (has_ssubset.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_136951 (h0 : topological_space (ordered_comm_monoid (ring (ring linarith.comp)))) : topological_space.separable_space (ordered_comm_monoid (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_136952 (h0 : ring (has_one (semiring (has_norm congr_arg_kind)))) : is_domain (has_one (semiring (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_136953 (h0 : complete_lattice (canonically_ordered_comm_semiring environment.implicit_infer_kind)) : is_compactly_generated (canonically_ordered_comm_semiring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_136954 (h0 : topological_space (ring (add_comm_monoid environment.implicit_infer_kind))) : locally_compact_space (ring (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_136955 (h0 : filter (linear_ordered_comm_group (option num))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_136956 (h0 : list (boolean_algebra (finset environment.implicit_infer_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_136957 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) environment.implicit_infer_kind) : @irreducible_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_136958 (h0 : filter (finset name)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_136959 (h0 : fin has_zero.zero) : @regular_space.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_136960 (h0 : semiring (non_assoc_semiring empty)) : is_noetherian_ring (non_assoc_semiring empty) := sorry --non-trivial
lemma new_lemma_136961 (h0 : fin has_zero.zero) : @group.fg.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (group.{0} (canonically_ordered_monoid.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))))))  := sorry --non-trivial
lemma new_lemma_136962 (h0 : complete_lattice (measure_theory.measure_space empty)) : complete_lattice.is_Sup_finite_compact (measure_theory.measure_space empty) := sorry --non-trivial
lemma new_lemma_136963 (h0 : functor.add_const (complete_lattice (has_zero pos)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_136964 (h0 : functor.add_const (ring (semigroup pos)) (has_neg pos)) : @strong_rank_condition.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} pos)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_136965 (h0 : not (uniform_space (measure_theory.measure_space num) -> false)) : @separated_space.{0} (measure_theory.measure_space.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (measure_theory.measure_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_136966 (h0 : topological_space (random_gen (has_ssubset reducibility_hints))) : totally_disconnected_space (random_gen (has_ssubset reducibility_hints)) := sorry --non-trivial
lemma new_lemma_136967 (h0 : function.extfun Type (functor.add_const (topological_space auto.case_option))) : @totally_separated_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} auto.case_option)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_136968 (h0 : topological_space std_gen) : path_connected_space std_gen := sorry --non-trivial
lemma new_lemma_136969 (h0 : list (semi_normed_comm_ring fun_info)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_136970 (h1 : function.extfun Type ring) : @strong_rank_condition.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h1 (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_136971 (h0 : add_monoid (bin_tree (semiring unsigned))) : add_monoid.fg (bin_tree (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_136972 (h0 : function.extfun Type group) : @is_simple_group.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_136973 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_136974 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_nndist empty)) := sorry --non-trivial
lemma new_lemma_136975 (h0 : functor.add_const (topological_space (simple_graph linarith.comp)) (has_neg (has_neg (has_neg (has_neg pos))))) : @normal_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} linarith.comp)) (has_neg.{0} (has_neg.{0} (has_neg.{0} (has_neg.{0} pos)))) h0)  := sorry --non-trivial
lemma new_lemma_136976 (h0 : functor.add_const (topological_space (has_to_string environment.implicit_infer_kind)) linarith.comp) : @preirreducible_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_136977 (h0 : function.extfun nat fin) : @t1_space.{0} (add_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_136978 (h0 : complete_lattice (pseudo_metric_space (finset ennreal))) : is_atomistic (pseudo_metric_space (finset ennreal)) := sorry --non-trivial
lemma new_lemma_136979 (h2 : ring (has_lt (random_gen char))) : is_domain (has_lt (random_gen char)) := sorry --non-trivial
lemma new_lemma_136980 (h0 : complete_lattice (has_top (has_top fun_info))) : is_compactly_generated (has_top (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_136981 (h1 : topological_space (dlist to_additive.value_type)) : totally_disconnected_space (dlist to_additive.value_type) := sorry --non-trivial
lemma new_lemma_136982 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (@id.{2} Type string_imp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 uniform_space.{0}) (@id.{2} Type string_imp))  := sorry --non-trivial
lemma new_lemma_136983 (h0 : topological_space auto.case_option) : preirreducible_space auto.case_option := sorry --non-trivial
lemma new_lemma_136984 (h0 : topological_space (mul_zero_class (semiring num))) : totally_separated_space (mul_zero_class (semiring num)) := sorry --non-trivial
lemma new_lemma_136985 (h0 : topological_space (has_one complex)) : locally_compact_space (has_one complex) := sorry --non-trivial
lemma new_lemma_136986 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_nnnorm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nnnorm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_136987 (h2 : ring (random_gen fun_info)) : rank_condition (random_gen fun_info) := sorry --non-trivial
lemma new_lemma_136988 (h0 : ring (with_zero (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) : rank_condition (with_zero (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_136989 (h0 : topological_space (has_norm string_imp)) : totally_separated_space (has_norm string_imp) := sorry --non-trivial
lemma new_lemma_136990 (h0 : ring (add_cancel_monoid (has_pos_part (has_add linarith.comp)))) : is_principal_ideal_ring (add_cancel_monoid (has_pos_part (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_136991 (h0 : function.extfun Type ring) : @is_domain.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_136992 (h0 : ring (add_cancel_monoid (has_to_string linarith.comp))) : strong_rank_condition (add_cancel_monoid (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_136993 (h0 : monoid (has_one (semiring unsigned))) : monoid.fg (has_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_136994 (h0 : functor.add_const (topological_space (normed_linear_ordered_group unsigned)) num) : @discrete_topology.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_136995 (h0 : functor.add_const (finset (boolean_algebra.core ennreal)) ennreal) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_136996 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_136997 (h0 : group (ring (has_Inf Type))) : is_cyclic (ring (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_136998 (h0 : functor.add_const (topological_space (finset linarith.comp)) linarith.comp) : @t1_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_136999 (h0 : topological_space (complete_distrib_lattice (ordered_comm_monoid Type))) : preconnected_space (complete_distrib_lattice (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_137000 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) Type) : @t0_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_137001 (h0 : add_group (linear_ordered_cancel_comm_monoid (option (option unsigned)))) : is_add_cyclic (linear_ordered_cancel_comm_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_137002 (h0 : list (has_norm (random_gen (random_gen (random_gen char))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_137003 (h0 : topological_space (normed_comm_ring (option unsigned))) : irreducible_space (normed_comm_ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_137004 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen linarith.comp))) : @add_monoid.fg.{0} (random_gen.{0} linarith.comp) (@finset.pi.empty.{1 0} Type add_monoid.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_137005 (h0 : has_mem.mem (normed_group unsigned) has_emptyc.emptyc) : @rank_condition.{0} (normed_group.{0} unsigned) (@finset.pi.empty.{1 0} Type ring.{0} (normed_group.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_137006 (h0 : not (complete_lattice (random_gen (has_ssubset to_additive.value_type)) -> false)) : @is_compactly_generated.{0} (random_gen.{0} (has_ssubset.{0} to_additive.value_type)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (random_gen.{0} (has_ssubset.{0} to_additive.value_type))) h0)  := sorry --non-trivial
lemma new_lemma_137007 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_137008 (h2 : has_lt (mul_one_class fun_info)) : no_max_order (mul_one_class fun_info) := sorry --non-trivial
lemma new_lemma_137009 (h0 : add_monoid (normed_comm_ring (comm_group (has_to_string (add_comm_monoid Type))))) : add_monoid.fg (normed_comm_ring (comm_group (has_to_string (add_comm_monoid Type)))) := sorry --non-trivial
lemma new_lemma_137010 (h0 : uniform_space (boolean_algebra name)) : complete_space (boolean_algebra name) := sorry --non-trivial
lemma new_lemma_137011 (h0 : uniform_space (generalized_boolean_algebra (has_Inf (has_add (has_Inf pos))))) : separated_space (generalized_boolean_algebra (has_Inf (has_add (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_137012 (h0 : topological_space (linear_ordered_comm_group empty)) : t1_space (linear_ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_137013 : nonempty (add_left_cancel_monoid char) := sorry --non-trivial
lemma new_lemma_137014 (h0 : measurable_space (nondiscrete_normed_field linarith.ineq)) (h1 : set (nondiscrete_normed_field linarith.ineq)) : measurable_set h1 := sorry --non-trivial
lemma new_lemma_137015 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_137016 (h0 : topological_space (topological_space (distrib (comm_ring reducibility_hints)))) : totally_disconnected_space (topological_space (distrib (comm_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_137017 (h0 : complete_lattice (topological_space (comm_ring fun_info))) : is_compactly_generated (topological_space (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_137018 (h0 : uniform_space (add_cancel_monoid (has_Inf (has_pos_part linarith.comp)))) : separated_space (add_cancel_monoid (has_Inf (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_137019 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (partial_order.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_137020 (h0 : topological_space (add_comm_monoid (has_add Type))) : irreducible_space (add_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_137021 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_137022 (h0 : function.extfun Type topological_space) : @t1_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_137023 (h0 : topological_space (cancel_monoid (option ennreal))) : t1_space (cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_137024 (h0 : topological_space (has_Inf (has_pos_part (has_add (finset pos))))) : locally_compact_space (has_Inf (has_pos_part (has_add (finset pos)))) := sorry --non-trivial
lemma new_lemma_137025 (h1 : topological_space to_additive.value_type) : totally_separated_space to_additive.value_type := sorry --non-trivial
lemma new_lemma_137026 (h1 : ring (denumerable (random_gen char))) : is_domain (denumerable (random_gen char)) := sorry --non-trivial
lemma new_lemma_137027 (h0 : group (add_comm_monoid (cancel_monoid (has_add name)))) : group.fg (add_comm_monoid (cancel_monoid (has_add name))) := sorry --non-trivial
lemma new_lemma_137028 (h0 : semiring (plift congr_arg_kind)) : is_noetherian_ring (plift congr_arg_kind) := sorry --non-trivial
lemma new_lemma_137029 (h0 : complete_lattice (semiring (semiring (semiring (semiring empty))))) : is_atomistic (semiring (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_137030 (h0 : add_group (distrib_lattice (has_nnnorm fun_info))) : is_add_cyclic (distrib_lattice (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_137031 (h0 : topological_space (fintype (comm_ring to_additive.value_type))) : totally_disconnected_space (fintype (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_137032 (h0 : topological_space (mul_zero_class (finset (has_add (has_add ennreal))))) : preconnected_space (mul_zero_class (finset (has_add (has_add ennreal)))) := sorry --non-trivial
lemma new_lemma_137033 (h0 : has_mem.mem (normed_group (has_top num)) has_emptyc.emptyc) : @is_compactly_generated.{0} (normed_group.{0} (has_top.{0} num)) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (normed_group.{0} (has_top.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_137034 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_137035 (h0 : function.extfun Type complete_lattice) : is_atomistic (measurable_space unsigned) := sorry --non-trivial
lemma new_lemma_137036 (h0 : ring (free_add_monoid (random_gen to_additive.value_type))) : is_domain (free_add_monoid (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_137037 (h0 : topological_space (with_bot (random_gen linarith.comp))) : t0_space (with_bot (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_137038 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_137039 (h0 : group (has_nnnorm (has_nnnorm linarith.comp_source))) : is_cyclic (has_nnnorm (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_137040 (h0 : topological_space (add_semigroup num)) : t1_space (add_semigroup num) := sorry --non-trivial
lemma new_lemma_137041 (h0 h1 : multiset (has_ssubset ereal)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_137042 (h0 : not (list (has_emptyc linarith.ineq) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_137043 (h0 : group (simple_graph unsigned)) : is_cyclic (simple_graph unsigned) := sorry --non-trivial
lemma new_lemma_137044 (h0 : functor.add_const (topological_space (mul_zero_class Type)) Type) : @discrete_topology.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (mul_zero_class.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_137045 (h0 : finset (has_to_string (has_nndist (has_nndist (has_nndist pos))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_137046 (h1 : uniform_space (mul_one_class (add_comm_semigroup string.iterator_imp))) : complete_space (mul_one_class (add_comm_semigroup string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_137047 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_dist.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} num))  := sorry --non-trivial
lemma new_lemma_137048 (h0 : functor.add_const (topological_space (has_nndist Type)) linarith.comp) : @totally_separated_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_137049 (h0 : topological_space (ring pos)) : locally_compact_space (ring pos) := sorry --non-trivial
lemma new_lemma_137050 (h0 : functor.add_const (topological_space (finset name)) pos) : @normal_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_137051 (h1 : set (encodable (has_add string_imp) -> char)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_137052 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_sub.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_sub.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_137053 (h0 : functor.add_const (topological_space (has_add Type)) (has_Inf (has_Inf (has_add Type)))) : @locally_compact_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_add.{1} Type)) (has_Inf.{1} (has_Inf.{1} (has_add.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_137054 (h0 : add_group (distrib (comm_ring (has_nnnorm char)))) : is_add_cyclic (distrib (comm_ring (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_137055 (h0 : ring (monoid_with_zero (option unsigned))) : rank_condition (monoid_with_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_137056 (h0 : group (has_norm (random_gen (normed_group fun_info)))) : group.fg (has_norm (random_gen (normed_group fun_info))) := sorry --non-trivial
lemma new_lemma_137057 (h0 : list (ring (ring (ring environment.implicit_infer_kind)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_137058 (h0 : complete_lattice (boolean_algebra.core (has_add (has_add Type)))) : is_compactly_generated (boolean_algebra.core (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_137059 (h0 : ring (plift (semiring num))) : strong_rank_condition (plift (semiring num)) := sorry --non-trivial
lemma new_lemma_137060 (h0 : topological_space (ordered_comm_ring (has_Inf (has_Inf Type)))) : preconnected_space (ordered_comm_ring (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_137061 (h0 : topological_space (comm_ring linarith.ineq)) : t0_space (comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_137062 (h0 : function.extfun (finset Type) (has_mem.mem (has_top linarith.comp_source))) : @locally_compact_space.{0} (has_top.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_137063 (h0 : complete_lattice (random_gen (random_gen (random_gen (random_gen linarith.comp_source))))) : is_atomistic (random_gen (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_137064 (h0 : topological_space (complete_distrib_lattice (semiring empty))) : irreducible_space (complete_distrib_lattice (semiring empty)) := sorry --non-trivial
lemma new_lemma_137065 : infinite linarith.comp := sorry --non-trivial
lemma new_lemma_137066 (h0 : filter (has_pos_part (finset (has_add pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_137067 (h0 : complete_lattice (has_top (semiring unsigned))) : is_compactly_generated (has_top (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_137068 (h0 : cancel_comm_monoid_with_zero enat) : unique_factorization_monoid enat := sorry --non-trivial
lemma new_lemma_137069 (h0 : has_mem.mem (has_top empty) has_emptyc.emptyc) : @strong_rank_condition.{0} (has_top.{0} empty) (@finset.pi.empty.{1 0} Type ring.{0} (has_top.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_137070 (h0 : topological_space (finset (option unsigned))) : totally_separated_space (finset (option unsigned)) := sorry --non-trivial
lemma new_lemma_137071 (h0 : not (uniform_space (with_one linarith.comp) -> false)) : @separated_space.{0} (with_one.{0} linarith.comp) (@classical.by_contradiction'.{1} (uniform_space.{0} (with_one.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_137072 (h0 : list (has_zero (ring linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_137073 (h0 : linear_ordered_field ennreal -> linear_ordered_field ennreal -> Prop) : is_irrefl (linear_ordered_field ennreal) h0 := sorry --non-trivial
lemma new_lemma_137074 (h1 : topological_space (has_norm linarith.comp_source)) : totally_disconnected_space (has_norm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_137075 (h0 : functor.add_const (functor.add_const (topological_space name) congr_arg_kind) congr_arg_kind) : @topological_space.separable_space.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) congr_arg_kind (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} name) congr_arg_kind) congr_arg_kind h0))  := sorry --non-trivial
lemma new_lemma_137076 (h0 : uniform_space (has_emptyc (has_norm empty))) : complete_space (has_emptyc (has_norm empty)) := sorry --non-trivial
lemma new_lemma_137077 (h0 : topological_space (with_bot (semiring (semiring unsigned)))) : totally_disconnected_space (with_bot (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_137078 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_137079 (h0 : monoid (boolean_algebra (has_neg (finset Type)))) : monoid.fg (boolean_algebra (has_neg (finset Type))) := sorry --non-trivial
lemma new_lemma_137080 (h1 : set (add_comm_semigroup fun_info -> empty)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_137081 (h1 : add_group (distrib (has_nnnorm char))) : is_add_cyclic (distrib (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_137082 (h0 : topological_space (add_cancel_monoid (finset (finset (has_to_string (finset linarith.comp)))))) : t0_space (add_cancel_monoid (finset (finset (has_to_string (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_137083 (h0 : functor.add_const (functor.add_const (topological_space (linear_order empty)) num) num) : @discrete_topology.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_order.{0} empty)) num (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} (linear_order.{0} empty)) num) num h0))  := sorry --non-trivial
lemma new_lemma_137084 (h0 : topological_space (denumerable linarith.comp_source)) : t0_space (denumerable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_137085 (h0 : group (has_add (has_Inf real))) : group.fg (has_add (has_Inf real)) := sorry --non-trivial
lemma new_lemma_137086 (h0 : complete_lattice (comm_monoid empty)) : is_compactly_generated (comm_monoid empty) := sorry --non-trivial
lemma new_lemma_137087 (h0 : functor.comp topological_space ring Type) : @t1_space.{1} (ring.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} ring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_137088 (h0 : functor.add_const (topological_space (boolean_algebra pos)) environment.implicit_infer_kind) : @loc_path_connected_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_137089 (h0 : functor.add_const (group (has_zero linarith.comp)) pos) : @is_cyclic.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_137090 (h1 : filter (denumerable to_additive.value_type)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_137091 (h0 : topological_space (has_edist (option unsigned))) : loc_path_connected_space (has_edist (option unsigned)) := sorry --non-trivial
lemma new_lemma_137092 (h0 : complete_lattice (free_add_monoid unsigned)) : is_atomistic (free_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_137093 (h0 : topological_space (add_cancel_monoid (has_add Type))) : totally_separated_space (add_cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_137094 (h0 : function.extfun (Type 1) ordered_add_comm_monoid) : @archimedean.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} h0 (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_137095 (h0 : topological_space real.angle -> Prop) : @t0_space.{0} real.angle (@classical.epsilon.{1} (topological_space.{0} real.angle) (@nonempty_of_inhabited.{1} (topological_space.{0} real.angle) (@inhabited_topological_space.{0} real.angle)) h0)  := sorry --non-trivial
lemma new_lemma_137096 (h0 : functor.add_const (topological_space (has_neg_part pos)) linarith.comp) : @totally_separated_space.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_137097 (h0 : complete_lattice (complete_distrib_lattice (finset (has_add (finset (has_add (finset (finset name)))))))) : is_atomistic (complete_distrib_lattice (finset (has_add (finset (has_add (finset (finset name))))))) := sorry --non-trivial
lemma new_lemma_137098 (h0 : has_norm linarith.comp -> has_norm linarith.comp -> Prop) : reflexive h0 := sorry --non-trivial
lemma new_lemma_137099 (h0 : ulower pnat) (h1 : list (ulower pnat)) : pnat.coprime (ulower.up h0) (id (ulower.up (list.head h1))) := sorry --non-trivial
lemma new_lemma_137100 (h0 : add_group (with_one (random_gen (random_gen to_additive.value_type)))) : is_add_cyclic (with_one (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_137101 (h0 : ring (random_gen (normed_field fun_info))) : is_domain (random_gen (normed_field fun_info)) := sorry --non-trivial
lemma new_lemma_137102 (h0 : function.extfun Type (functor.add_const (ring (add_group num)))) : @rank_condition.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (add_group.{0} num)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (add_group.{0} num))) h0 empty))  := sorry --non-trivial
lemma new_lemma_137103 (h0 : functor.add_const (topological_space (complete_distrib_lattice unsigned)) congr_arg_kind) : @totally_separated_space.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_137104 (h0 : ordered_comm_monoid (cancel_monoid (boolean_algebra.core (boolean_algebra.core unsigned)))) : has_exists_mul_of_le (cancel_monoid (boolean_algebra.core (boolean_algebra.core unsigned))) := sorry --non-trivial
lemma new_lemma_137105 (h0 : group (canonically_linear_ordered_monoid (option (cancel_monoid pos)))) : is_simple_group (canonically_linear_ordered_monoid (option (cancel_monoid pos))) := sorry --non-trivial
lemma new_lemma_137106 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 uniform_space.{0}) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_137107 (h0 : topological_space (has_add (semigroup (has_neg (finset environment.implicit_infer_kind))))) : path_connected_space (has_add (semigroup (has_neg (finset environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_137108 (h0 : nat -> filter string_imp -> filter string_imp) (h1 : nat) (h2 : not (filter string_imp -> false)) (h3 : not (uniform_space (filter.germ (nat.repeat h0 h1 (classical.by_contradiction' h2)) char) -> false)) : @complete_space.{0} (@filter.germ.{0 0} string_imp (@nat.repeat.{0} (filter.{0} string_imp) h0 h1 (@classical.by_contradiction'.{1} (filter.{0} string_imp) h2)) char) (@classical.by_contradiction'.{1} (uniform_space.{0} (@filter.germ.{0 0} string_imp (@nat.repeat.{0} (filter.{0} string_imp) h0 h1 (@classical.by_contradiction'.{1} (filter.{0} string_imp) h2)) char)) h3)  := sorry --non-trivial
lemma new_lemma_137109 (h0 : ring (has_one (has_top congr_arg_kind))) : strong_rank_condition (has_one (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_137110 (h0 : functor.add_const (add_monoid (linear_ordered_field num)) unsigned) : @add_monoid.fg.{0} (linear_ordered_field.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (linear_ordered_field.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_137111 (h0 : functor.add_const (ring (has_add linarith.comp)) (has_zero linarith.comp)) : @is_domain.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} linarith.comp)) (has_zero.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_137112 (h0 : topological_space (dlist (has_nnnorm char))) : totally_disconnected_space (dlist (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_137113 (h0 : functor.add_const (ring (has_zero environment.implicit_infer_kind)) pos) : @is_principal_ideal_ring.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_137114 (h0 : complete_lattice (semiring (has_top (has_top (has_top linarith.comp_source))))) : complete_lattice.is_Sup_finite_compact (semiring (has_top (has_top (has_top linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_137115 (h0 : functor.add_const (group (semigroup name)) (mul_zero_class (option (option unsigned)))) : @is_simple_group.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} name)) (mul_zero_class.{0} (option.{0} (option.{0} unsigned))) h0)  := sorry --non-trivial
lemma new_lemma_137116 (h0 : topological_space (set.set_semiring ereal)) : path_connected_space (set.set_semiring ereal) := sorry --non-trivial
lemma new_lemma_137117 (h0 : complete_lattice (denumerable string_imp)) (h1 : denumerable string_imp) : complete_lattice.is_compact_element h1 := sorry --non-trivial
lemma new_lemma_137118 (h0 : functor.add_const (function.extfun (Type 1) add_group) name) : @is_add_cyclic.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_group.{1}) name h0) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_137119 (h0 : ring (normed_field linarith.comp_source)) : rank_condition (normed_field linarith.comp_source) := sorry --non-trivial
lemma new_lemma_137120 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (measurable_space num)) := sorry --non-trivial
lemma new_lemma_137121 (h0 : monoid (complete_linear_order unsigned)) : monoid.fg (complete_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_137122 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_137123 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_137124 (h0 : option (ordered_comm_monoid (has_zero (has_neg_part ennreal)))) (h1 : ordered_comm_monoid (has_zero (has_neg_part ennreal))) : has_exists_mul_of_le (has_zero (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_137125 (h1 : uniform_space (id (has_top (has_top linarith.comp_source)))) : complete_space (id (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_137126 (h0 : set (simple_graph ereal)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_137127 (h0 : complete_lattice (ring (has_add (has_add (has_add (has_add Type)))))) : is_compactly_generated (ring (has_add (has_add (has_add (has_add Type))))) := sorry --non-trivial
lemma new_lemma_137128 (h0 : ordered_add_comm_monoid (ordered_comm_ring (ring linarith.comp))) : archimedean (ordered_comm_ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_137129 (h0 : function.extfun Type group) : @group.fg.{0} (normed_group.{0} char) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_group.{0} char))  := sorry --non-trivial
lemma new_lemma_137130 (h0 : functor.add_const (topological_space (linear_ordered_comm_group empty)) num) : @normal_space.{0} (linear_ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_group.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_137131 (h0 : ring (monoid pos)) : is_principal_ideal_ring (monoid pos) := sorry --non-trivial
lemma new_lemma_137132 (h0 : filter (denumerable (has_lt char))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_137133 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} h0 (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_137134 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) (has_neg linarith.comp)) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_137135 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) linarith.comp) : @sequential_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_137136 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) (finset pos)) : @path_connected_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_137137 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_137138 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_137139 (h0 : function.extfun Type topological_space) : @normal_space.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_137140 (h0 : function.extfun Type topological_space) : @t1_space.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_137141 (h0 : function.extfun nat fin) : @regular_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_137142 (h0 : topological_space (ordered_comm_monoid (has_bot linarith.comp))) : discrete_topology (ordered_comm_monoid (has_bot linarith.comp)) := sorry --non-trivial
lemma new_lemma_137143 (h0 : topological_space (has_nndist (has_to_string Type))) : totally_separated_space (has_nndist (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_137144 (h0 : filter (normed_comm_ring unsigned)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_137145 (h0 : not (nat -> false)) (h1 : fin (nat.succ (classical.by_contradiction' h0)) -> Prop) (h2 : fin (classical.by_contradiction' h0)) : matrix.vec_tail h1 h2 := sorry --non-trivial
lemma new_lemma_137146 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) linarith.comp) : @loc_path_connected_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_137147 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_137148 (h0 : functor.add_const (topological_space (finset Type)) Type) : @preirreducible_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (finset.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_137149 (h0 : complete_lattice (mul_zero_class pos)) : is_atomistic (mul_zero_class pos) := sorry --non-trivial
lemma new_lemma_137150 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_137151 (h0 : topological_space (has_zero num)) : totally_separated_space (has_zero num) := sorry --non-trivial
lemma new_lemma_137152 (h0 : complete_lattice (has_lt (mul_one_class (mul_one_class (mul_one_class linarith.comp_source))))) : is_compactly_generated (has_lt (mul_one_class (mul_one_class (mul_one_class linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_137153 (h1 : complete_lattice (mul_one_class ereal)) : complete_lattice.is_Sup_finite_compact (mul_one_class ereal) := sorry --non-trivial
lemma new_lemma_137154 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @locally_compact_space.{0} string_imp (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) string_imp)  := sorry --non-trivial
lemma new_lemma_137155 (h0 : not (topological_space (has_one num) -> false)) : @t0_space.{0} (has_one.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_one.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_137156 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @irreducible_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_137157 (h0 : ring (has_emptyc empty)) : is_domain (has_emptyc empty) := sorry --non-trivial
lemma new_lemma_137158 (h0 : topological_space (has_norm (has_norm num))) : preirreducible_space (has_norm (has_norm num)) := sorry --non-trivial
lemma new_lemma_137159 (h1 : topological_space (ordered_add_comm_monoid (mul_one_class reducibility_hints))) : totally_disconnected_space (ordered_add_comm_monoid (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_137160 (h0 : complete_lattice (random_gen (has_norm fun_info))) : is_compactly_generated (random_gen (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_137161 (h0 : ring (random_gen (random_gen (random_gen num)))) : strong_rank_condition (random_gen (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_137162 (h0 : topological_space (nondiscrete_normed_field enat)) : path_connected_space (nondiscrete_normed_field enat) := sorry --non-trivial
lemma new_lemma_137163 (h1 : group (random_gen fun_info)) : group.fg (random_gen fun_info) := sorry --non-trivial
lemma new_lemma_137164 (h1 : function.extfun Type topological_space) : @totally_separated_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_137165 (h1 : ring (distrib fun_info)) : is_domain (distrib fun_info) := sorry --non-trivial
lemma new_lemma_137166 (h1 : not (add_group (distrib_lattice string_imp) -> false)) : @is_add_cyclic.{0} (distrib_lattice.{0} string_imp) (@classical.by_contradiction'.{1} (add_group.{0} (distrib_lattice.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_137167 (h0 : topological_space (has_zero (finset (ring linarith.comp)))) : totally_disconnected_space (has_zero (finset (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_137168 (h0 : ordered_add_comm_monoid (has_to_string unsigned)) : archimedean (has_to_string unsigned) := sorry --non-trivial
lemma new_lemma_137169 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @strong_rank_condition.{0} linarith.comp_source (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_137170 (h0 : group (has_neg_part (has_nndist (finset (finset Type))))) : is_cyclic (has_neg_part (has_nndist (finset (finset Type)))) := sorry --non-trivial
lemma new_lemma_137171 (h0 : topological_space (add_comm_monoid (option (option unsigned)))) : locally_compact_space (add_comm_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_137172 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (add_left_cancel_semigroup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_left_cancel_semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_137173 (h0 : topological_space (has_le ereal)) (h1 : preorder (has_le ereal)) : order_closed_topology (has_le ereal) := sorry --non-trivial
lemma new_lemma_137174 (h0 : ring (normed_group (random_gen (comm_ring fun_info)))) : is_domain (normed_group (random_gen (comm_ring fun_info))) := sorry --non-trivial
lemma new_lemma_137175 (h0 : topological_space (has_one (semiring unsigned))) : irreducible_space (has_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_137176 (h0 : functor.add_const (group (semigroup pos)) environment.implicit_infer_kind) : @is_simple_group.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_137177 (h0 : list (has_emptyc congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_137178 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @path_connected_space.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_137179 (h0 : complete_lattice (measure_theory.measure_space num)) : is_compactly_generated (measure_theory.measure_space num) := sorry --non-trivial
lemma new_lemma_137180 (h0 : group (canonically_linear_ordered_monoid (option name))) : is_cyclic (canonically_linear_ordered_monoid (option name)) := sorry --non-trivial
lemma new_lemma_137181 (h0 : ring (add_monoid (comm_ring fun_info))) : is_domain (add_monoid (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_137182 (h0 : ordered_cancel_add_comm_monoid ennreal -> ordered_cancel_add_comm_monoid ennreal -> Prop) : is_symm (ordered_cancel_add_comm_monoid ennreal) h0 := sorry --non-trivial
lemma new_lemma_137183 (h0 : filter (mul_zero_class (comm_group Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_137184 (h0 : function.extfun Type topological_space) : @t1_space.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_137185 (h0 : ring (has_nndist (has_nndist (option (has_add name))))) : is_principal_ideal_ring (has_nndist (has_nndist (option (has_add name)))) := sorry --non-trivial
lemma new_lemma_137186 (h0 : topological_space (has_emptyc (random_gen linarith.comp_source))) : totally_separated_space (has_emptyc (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_137187 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @t0_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_137188 (h1 : group (distrib_lattice (random_gen linarith.ineq))) : group.fg (distrib_lattice (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_137189 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (partial_order.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_137190 (h0 : complete_lattice (has_top (has_nnnorm fun_info))) : is_compactly_generated (has_top (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_137191 (h0 : functor.add_const (function.extfun Type filter) (ring Type)) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_137192 (h1 : uniform_space (normed_field char)) : complete_space (normed_field char) := sorry --non-trivial
lemma new_lemma_137193 (h0 : has_bot real -> has_bot real -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_137194 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) linarith.comp) : @irreducible_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_137195 (h0 : filter (has_add (option name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_137196 (h0 : function.extfun Type topological_space) : @regular_space.{0} pos (@function.extfun_app.{2 1} Type topological_space.{0} h0 pos)  := sorry --non-trivial
lemma new_lemma_137197 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (partial_order.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_137198 (h0 : not (add_group (distrib linarith.ineq) -> false)) : @is_add_cyclic.{0} (distrib.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (distrib.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_137199 (h0 : function.extfun (Type 1) cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} h0 (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_137200 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) empty) : @unique_factorization_monoid.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) empty h0) (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_137201 (h1 : filter empty) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_137202 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_137203 (h0 : ring (boolean_algebra (mul_one_class (mul_one_class linarith.comp)))) : strong_rank_condition (boolean_algebra (mul_one_class (mul_one_class linarith.comp))) := sorry --non-trivial
lemma new_lemma_137204 (h0 : add_monoid (boolean_algebra (has_to_string Type))) : add_monoid.fg (boolean_algebra (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_137205 (h0 : function.extfun Type (functor.comp topological_space semigroup)) : @t1_space.{0} (semigroup.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} semigroup.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_137206 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_137207 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_137208 (h0 : complete_lattice (with_one (semiring num))) : is_atomistic (with_one (semiring num)) := sorry --non-trivial
lemma new_lemma_137209 (h0 : list (normed_linear_ordered_group (option unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_137210 (h0 : functor.add_const (group (has_nndist pos)) pos) : @is_simple_group.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_137211 (h0 : add_group (has_top (with_bot linarith.comp))) : is_add_cyclic (has_top (with_bot linarith.comp)) := sorry --non-trivial
lemma new_lemma_137212 (h0 : not (ring (complete_linear_order num) -> false)) : @is_domain.{0} (complete_linear_order.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (complete_linear_order.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_137213 (h0 : monoid (semiring (semiring (random_gen empty)))) : monoid.fg (semiring (semiring (random_gen empty))) := sorry --non-trivial
lemma new_lemma_137214 (h1 : ring (denumerable (random_gen string_imp))) : rank_condition (denumerable (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_137215 (h0 : topological_space (normed_comm_ring pos)) : discrete_topology (normed_comm_ring pos) := sorry --non-trivial
lemma new_lemma_137216 (h0 : not (complete_lattice (bin_tree empty) -> false)) : @is_atomistic.{0} (bin_tree.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (bin_tree.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_137217 (h0 : group (add_group num)) : normalizer_condition (add_group num) := sorry --non-trivial
lemma new_lemma_137218 (h0 : ring (has_zero (comm_group Type))) : is_principal_ideal_ring (has_zero (comm_group Type)) := sorry --non-trivial
lemma new_lemma_137219 (h0 : not (filter (measurable_space.dynkin_system linarith.comp) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_137220 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (dlist.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (dlist.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_137221 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_137222 (h0 : semiring (mul_one_class (mul_one_class enat))) (h1 : ideal (mul_one_class (mul_one_class enat))) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_137223 (h0 : functor.add_const (complete_lattice (boolean_algebra pos)) (boolean_algebra (cancel_monoid name))) : @is_atomistic.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} pos)) (boolean_algebra.{0} (cancel_monoid.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_137224 (h0 : semiring (has_add (finset (has_add (mul_one_class pos))))) : is_noetherian_ring (has_add (finset (has_add (mul_one_class pos)))) := sorry --non-trivial
lemma new_lemma_137225 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (distrib_lattice.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (distrib_lattice.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_137226 (h0 : with_bot (ring (add_cancel_comm_monoid reducibility_hints))) (h1 : ne h0 has_bot.bot) : @rank_condition.{0} (add_cancel_comm_monoid.{0} reducibility_hints) (@with_bot.unbot.{0} (ring.{0} (add_cancel_comm_monoid.{0} reducibility_hints)) h0 h1)  := sorry --non-trivial
lemma new_lemma_137227 (h0 : ring (has_to_string (finset linarith.comp))) : is_domain (has_to_string (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_137228 (h0 : complete_lattice (semiring (semiring (has_norm unsigned)))) : is_atomistic (semiring (semiring (has_norm unsigned))) := sorry --non-trivial
lemma new_lemma_137229 (h0 : functor.add_const (group (finset linarith.comp)) (boolean_algebra Type)) : @is_cyclic.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (finset.{0} linarith.comp)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_137230 (h0 : monoid (partial_order (add_right_cancel_monoid empty))) : monoid.fg (partial_order (add_right_cancel_monoid empty)) := sorry --non-trivial
lemma new_lemma_137231 (h0 : topological_space (semiring (semiring (has_norm linarith.comp)))) : discrete_topology (semiring (semiring (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_137232 (h0 : ring (has_one (semiring empty))) : strong_rank_condition (has_one (semiring empty)) := sorry --non-trivial
lemma new_lemma_137233 (h0 : list (pseudo_metric_space (finset name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_137234 (h0 : not (ring (has_nnnorm reducibility_hints) -> false)) : @is_domain.{0} (has_nnnorm.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (has_nnnorm.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_137235 (h0 : not (function.extfun Type topological_space -> false)) : @t1_space.{0} (bin_tree.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (bin_tree.{0} num))  := sorry --non-trivial
lemma new_lemma_137236 (h0 : ring (with_bot (has_norm (has_norm (has_norm (has_norm congr_arg_kind)))))) : is_domain (with_bot (has_norm (has_norm (has_norm (has_norm congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_137237 (h0 : not (topological_space (random_gen empty) -> false)) : @t0_space.{0} (random_gen.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_137238 (h0 : ordered_add_comm_monoid (normed_comm_ring (has_add (has_add (has_add pos))))) : archimedean (normed_comm_ring (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_137239 (h0 : functor.add_const (topological_space (comm_group pos)) (add_comm_monoid pos)) : @preirreducible_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) (add_comm_monoid.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_137240 (h0 : ring (semigroup (has_neg (boolean_algebra Type)))) : is_domain (semigroup (has_neg (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_137241 (h0 : topological_space (has_inv (random_gen linarith.ineq))) : irreducible_space (has_inv (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_137242 (h0 : add_group (complete_distrib_lattice ennreal)) : is_add_cyclic (complete_distrib_lattice ennreal) := sorry --non-trivial
lemma new_lemma_137243 (h0 : topological_space (canonically_ordered_add_monoid (option (option empty)))) : preirreducible_space (canonically_ordered_add_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_137244 (h0 : not (ring (distrib (bin_tree (metric_space (metric_space linarith.comp_source)))) -> false)) : @strong_rank_condition.{0} (distrib.{0} (bin_tree.{0} (metric_space.{0} (metric_space.{0} linarith.comp_source)))) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} (bin_tree.{0} (metric_space.{0} (metric_space.{0} linarith.comp_source))))) h0)  := sorry --non-trivial
lemma new_lemma_137245 (h0 : topological_space (finset (finset (finset linarith.comp)))) : loc_path_connected_space (finset (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_137246 (h0 : topological_space (mul_zero_class (finset Type))) : preirreducible_space (mul_zero_class (finset Type)) := sorry --non-trivial
lemma new_lemma_137247 (h0 : functor.add_const (list (boolean_algebra environment.implicit_infer_kind)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_137248 (h0 : topological_space (ordered_comm_group (option empty))) : normal_space (ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_137249 (h0 : not (group (fintype linarith.ineq) -> false)) : @group.fg.{0} (fintype.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (fintype.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_137250 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @totally_separated_space.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_137251 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_137252 (h0 : topological_space (has_le (normed_field enat))) : path_connected_space (has_le (normed_field enat)) := sorry --non-trivial
lemma new_lemma_137253 (h0 : topological_space (mul_one_class fun_info)) : t0_space (mul_one_class fun_info) := sorry --non-trivial
lemma new_lemma_137254 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_137255 (h0 : has_top empty -> has_top empty -> Prop) : is_strict_order (has_top empty) h0 := sorry --non-trivial
lemma new_lemma_137256 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @is_cyclic.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_137257 (h0 : functor.comp topological_space semigroup ennreal) : @t1_space.{0} (semigroup.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_137258 (h0 : functor.add_const (group (finset environment.implicit_infer_kind)) name) : @is_cyclic.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_137259 (h0 : finset (complete_distrib_lattice (finset linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_137260 (h0 : topological_space (complete_distrib_lattice (has_add (has_Inf pos)))) : regular_space (complete_distrib_lattice (has_add (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_137261 (h0 : uniform_space (semi_normed_comm_ring (has_ssubset linarith.ineq))) : complete_space (semi_normed_comm_ring (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_137262 (h0 : function.extfun Type topological_space) : @t1_space.{0} (pseudo_metric_space.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_137263 (h0 : group (encodable (has_ssubset fun_info))) : is_cyclic (encodable (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_137264 (h0 : not (list Prop -> false)) : list.tfae (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_137265 (h0 : topological_space (has_nnnorm linarith.comp_source)) (h1 : preorder (has_nnnorm linarith.comp_source)) : order_topology (has_nnnorm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_137266 (h0 : functor.add_const (semiring (boolean_algebra Type)) unsigned) : @is_noetherian_ring.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (boolean_algebra.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_137267 (h0 : topological_space (canonically_linear_ordered_monoid (has_neg (has_Inf real)))) : preirreducible_space (canonically_linear_ordered_monoid (has_neg (has_Inf real))) := sorry --non-trivial
lemma new_lemma_137268 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra Type)) linarith.comp) : @has_exists_mul_of_le.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_137269 (h0 : nat -> Prop -> Prop) (h1 : nat) (h2 : false) (h3 : eq (false.elim h2) has_zero.zero -> Prop) (h4 : Pi (m : nat), eq (false.elim h2) (nat.succ m) -> Prop) : nat.repeat h0 h1 (nat.discriminate h3 h4) := sorry --trivial
lemma new_lemma_137270 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_137271 (h0 : topological_space (preorder (semiring (semiring unsigned)))) : preirreducible_space (preorder (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_137272 (h0 : functor.add_const (functor.add_const Prop Type) Type) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_137273 (h0 : functor.add_const (functor.add_const (topological_space linarith.comp) name) name) : @sequential_space.{0} linarith.comp (@functor.add_const.run.{0 0} (topological_space.{0} linarith.comp) name (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} linarith.comp) name) name h0))  := sorry --non-trivial
lemma new_lemma_137274 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) (has_neg Type)) : @has_exists_mul_of_le.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) (has_neg.{1} Type) h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_137275 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) (has_neg Type)) : @preirreducible_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_137276 (h0 : cancel_comm_monoid_with_zero string_imp) (h1 : add_monoid (normalization_monoid string_imp)) (h2 : topological_space (star_add_monoid (normalization_monoid string_imp))) : t0_space (star_add_monoid (normalization_monoid string_imp)) := sorry --non-trivial
lemma new_lemma_137277 (h0 : filter (ordered_comm_group (option (option unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_137278 (h0 : list (has_Inf (finset linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_137279 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_137280 (h0 : complete_lattice (complete_distrib_lattice ennreal)) : is_atomistic (complete_distrib_lattice ennreal) := sorry --non-trivial
lemma new_lemma_137281 (h0 : not (function.extfun (finset Type) (has_mem.mem (measurable_space empty)) -> false)) : is_atomistic (measurable_space empty) := sorry --non-trivial
lemma new_lemma_137282 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (has_one.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (has_one.{0} num))  := sorry --non-trivial
lemma new_lemma_137283 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (ordered_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_137284 (h0 : topological_space (has_pos_part real)) : loc_path_connected_space (has_pos_part real) := sorry --non-trivial
lemma new_lemma_137285 (h0 : topological_space (topological_space (has_nnnorm string.iterator_imp))) : totally_disconnected_space (topological_space (has_nnnorm string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_137286 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_137287 (h0 : complete_lattice (has_compl (has_ssubset (has_ssubset (has_ssubset to_additive.value_type))))) : is_compactly_generated (has_compl (has_ssubset (has_ssubset (has_ssubset to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_137288 (h0 : ring (finset congr_arg_kind)) : is_principal_ideal_ring (finset congr_arg_kind) := sorry --non-trivial
lemma new_lemma_137289 (h0 : group (comm_semigroup real)) : is_simple_group (comm_semigroup real) := sorry --non-trivial
lemma new_lemma_137290 (h0 : functor.comp add_monoid has_nndist ennreal) : @add_monoid.fg.{0} (has_nndist.{0} ennreal) (@functor.comp.run.{0 0 0} add_monoid.{0} has_nndist.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_137291 (h0 : uniform_space (has_append complex)) : complete_space (has_append complex) := sorry --non-trivial
lemma new_lemma_137292 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_137293 (h0 : complete_lattice (has_norm (has_top (has_norm fun_info)))) : is_atomistic (has_norm (has_top (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_137294 (h1 : filter (with_one (has_inv (random_gen string_imp)))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_137295 (h0 : functor.add_const (function.extfun (Type 1) add_group) name) : @is_add_cyclic.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_group.{1}) name h0) (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_137296 (h0 : prod (normed_linear_ordered_group congr_arg_kind) (normed_linear_ordered_group congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_137297 (h0 : ring (denumerable (has_ssubset (random_gen char)))) : is_domain (denumerable (has_ssubset (random_gen char))) := sorry --non-trivial
lemma new_lemma_137298 (h0 : functor.add_const (list (preorder num)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_137299 (h0 : filter (has_to_string (finset linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_137300 (h0 : topological_space (complete_distrib_lattice (comm_group environment.implicit_infer_kind))) : t0_space (complete_distrib_lattice (comm_group environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_137301 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) name) : @archimedean.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) name h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_137302 (h0 : group (has_top linarith.comp)) : group.fg (has_top linarith.comp) := sorry --non-trivial
lemma new_lemma_137303 (h1 : function.extfun Type topological_space) : @path_connected_space.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_137304 (h0 : ring (has_top (has_top to_additive.value_type))) : rank_condition (has_top (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_137305 (h2 : ring (random_gen fun_info)) : is_domain (random_gen fun_info) := sorry --non-trivial
lemma new_lemma_137306 (h0 : topological_space (boolean_algebra.core (has_add (has_neg (boolean_algebra Type))))) : loc_path_connected_space (boolean_algebra.core (has_add (has_neg (boolean_algebra Type)))) := sorry --non-trivial
lemma new_lemma_137307 (h0 : complete_lattice (has_emptyc (has_top linarith.ineq))) : is_compactly_generated (has_emptyc (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_137308 (h0 : topological_space (has_compl to_additive.value_type)) : totally_disconnected_space (has_compl to_additive.value_type) := sorry --non-trivial
lemma new_lemma_137309 (h0 : ring (measurable_space (semiring linarith.comp))) : strong_rank_condition (measurable_space (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_137310 (h0 : group (has_norm linarith.comp_source)) : group.fg (has_norm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_137311 (h0 : topological_space (has_union empty)) : locally_compact_space (has_union empty) := sorry --non-trivial
lemma new_lemma_137312 (h0 : monoid (cancel_monoid Type)) : monoid.fg (cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_137313 (h0 : complete_lattice (has_neg (option congr_arg_kind))) : is_atomistic (has_neg (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_137314 (h0 : functor.add_const Prop (has_neg (option ennreal))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_137315 (h0 : field char) : is_alg_closed char := sorry --non-trivial
lemma new_lemma_137316 (h0 : group (has_nnnorm (random_gen (random_gen (random_gen (random_gen char)))))) : group.fg (has_nnnorm (random_gen (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_137317 (h0 : functor.add_const (complete_lattice (has_star unsigned)) empty) : @is_atomistic.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_star.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_137318 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_sub.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_sub.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_137319 (h0 : ring (distrib_lattice (mul_zero_one_class (random_gen (random_gen char))))) : is_domain (distrib_lattice (mul_zero_one_class (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_137320 (h0 : has_mem.mem (has_emptyc (random_gen to_additive.value_type)) has_emptyc.emptyc) : @is_domain.{0} (has_emptyc.{0} (random_gen.{0} to_additive.value_type)) (@finset.pi.empty.{1 0} Type ring.{0} (has_emptyc.{0} (random_gen.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_137321 (h0 : list (has_to_string (has_to_string (has_to_string pos)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_137322 (h0 : ring (boolean_algebra (has_neg (normed_comm_ring (has_bot pos))))) : rank_condition (boolean_algebra (has_neg (normed_comm_ring (has_bot pos)))) := sorry --non-trivial
lemma new_lemma_137323 (h0 : group (sub_neg_monoid (has_Inf (has_add real)))) : normalizer_condition (sub_neg_monoid (has_Inf (has_add real))) := sorry --non-trivial
lemma new_lemma_137324 (h0 : function.extfun (finset Type) (has_mem.mem (semiring to_additive.value_type))) : @is_atomistic.{0} (semiring.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} to_additive.value_type)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_137325 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_137326 (h0 : function.extfun Type topological_space) : @normal_space.{0} (group_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_137327 (h0 : fin has_zero.zero) : @add_monoid.fg.{0} (boolean_algebra.{0} linarith.comp) (@matrix.vec_empty.{0} (add_monoid.{0} (boolean_algebra.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_137328 (h0 : group (with_bot (semiring (has_top empty)))) : normalizer_condition (with_bot (semiring (has_top empty))) := sorry --non-trivial
lemma new_lemma_137329 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (sub_neg_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_137330 (h0 : not (complete_lattice (distrib_lattice fun_info) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (distrib_lattice.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (distrib_lattice.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_137331 (h0 : topological_space (comm_group (linear_ordered_comm_monoid_with_zero ennreal))) : totally_disconnected_space (comm_group (linear_ordered_comm_monoid_with_zero ennreal)) := sorry --non-trivial
lemma new_lemma_137332 (h0 : ring (comm_group (has_to_string Type))) : rank_condition (comm_group (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_137333 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_137334 (h0 : add_group (random_gen (random_gen (random_gen (with_bot to_additive.value_type))))) : is_add_cyclic (random_gen (random_gen (random_gen (with_bot to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_137335 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_137336 (h0 : group (boolean_algebra.core (finset (has_add (has_add (finset linarith.comp)))))) : normalizer_condition (boolean_algebra.core (finset (has_add (has_add (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_137337 (h0 : fin has_zero.zero) : @preirreducible_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) h0) (@has_zero.zero.{0} nat nat.has_zero))) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_137338 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_137339 (h0 : complete_lattice (cancel_monoid (cancel_monoid pos))) : is_atomistic (cancel_monoid (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_137340 (h0 : filter (has_one (semiring (has_top empty)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_137341 (h2 : set (enat -> ereal)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_137342 (h0 : functor.add_const (complete_lattice (finset name)) Type) : @is_compactly_generated.{0} (finset.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (finset.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_137343 (h0 : semiring (boolean_algebra.core ennreal)) : is_noetherian_ring (boolean_algebra.core ennreal) := sorry --non-trivial
lemma new_lemma_137344 (h0 : topological_space (normed_comm_ring (option ennreal))) : discrete_topology (normed_comm_ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_137345 (h0 : topological_space (non_assoc_semiring (semiring (semiring empty)))) : irreducible_space (non_assoc_semiring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_137346 (h0 : ring (boolean_algebra name)) : is_principal_ideal_ring (boolean_algebra name) := sorry --non-trivial
lemma new_lemma_137347 (h0 : functor.add_const (complete_lattice (add_comm_monoid unsigned)) (ring Type)) : @is_atomistic.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 1} (complete_lattice.{0} (add_comm_monoid.{0} unsigned)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_137348 (h0 : functor.add_const (ring (semigroup Type)) Type) : @rank_condition.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (semigroup.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_137349 (h0 : finset (has_inter num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_137350 (h0 : ordered_comm_monoid (has_add (sub_neg_monoid Type))) : has_exists_mul_of_le (has_add (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_137351 (h1 : ring (has_inv (random_gen (random_gen (random_gen linarith.ineq))))) : rank_condition (has_inv (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_137352 (h0 : topological_space (has_zero (has_nndist (ring (has_neg linarith.comp))))) : t0_space (has_zero (has_nndist (ring (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_137353 (h0 : topological_space (topological_space (denumerable linarith.ineq))) : totally_disconnected_space (topological_space (denumerable linarith.ineq)) := sorry --non-trivial
lemma new_lemma_137354 (h0 : topological_space (free_add_monoid num)) : discrete_topology (free_add_monoid num) := sorry --non-trivial
lemma new_lemma_137355 (h0 : group (linear_ordered_field (option (option (option (option unsigned)))))) : is_cyclic (linear_ordered_field (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_137356 (h0 : complete_lattice (has_emptyc (has_top (has_top linarith.comp_source)))) : complete_lattice.is_Sup_finite_compact (has_emptyc (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_137357 (h0 : ring (has_to_string (finset Type))) : is_principal_ideal_ring (has_to_string (finset Type)) := sorry --non-trivial
lemma new_lemma_137358 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) Type) : @loc_path_connected_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_137359 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type semiring.{0} h0 (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_137360 (h0 : order_hom nat (topological_space (option congr_arg_kind))) : @discrete_topology.{0} (option.{0} congr_arg_kind) (@monotonic_sequence_limit.{0} (topological_space.{0} (option.{0} congr_arg_kind)) (@topological_space.partial_order.{0} (option.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_137361 (h0 : topological_space (linear_ordered_semiring unsigned)) : totally_disconnected_space (linear_ordered_semiring unsigned) := sorry --non-trivial
lemma new_lemma_137362 (h0 : functor.add_const (topological_space (semiring num)) num) : @normal_space.{0} (semiring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_137363 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_137364 (h1 : complete_lattice (has_ssubset (random_gen string_imp))) : is_compactly_generated (has_ssubset (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_137365 (h0 : list (has_zero (has_scalar ennreal name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_137366 (h0 : monoid (complete_semilattice_Sup (has_top (has_top linarith.comp_source)))) : monoid.fg (complete_semilattice_Sup (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_137367 (h0 : function.extfun nat fin) : @discrete_topology.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_ring.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_137368 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) linarith.comp) : @totally_disconnected_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_137369 (h0 : topological_space (linear_ordered_semiring (semiring congr_arg_kind))) : topological_space.separable_space (linear_ordered_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_137370 (h1 : add_group (distrib string.iterator_imp)) : is_add_cyclic (distrib string.iterator_imp) := sorry --non-trivial
lemma new_lemma_137371 (h0 : topological_space (measure_theory.measure_space (complete_semilattice_Sup empty))) : path_connected_space (measure_theory.measure_space (complete_semilattice_Sup empty)) := sorry --non-trivial
lemma new_lemma_137372 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_top.{0} (semiring.{0} congr_arg_kind)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} (semiring.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_137373 (h2 : topological_space ereal) : totally_disconnected_space ereal := sorry --non-trivial
lemma new_lemma_137374 (h0 : topological_space (has_neg (semigroup (semigroup (has_neg environment.implicit_infer_kind))))) : irreducible_space (has_neg (semigroup (semigroup (has_neg environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_137375 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_137376 (h0 : topological_space (has_zero (mul_one_class (has_pos_part linarith.comp)))) : preirreducible_space (has_zero (mul_one_class (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_137377 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_137378 (h0 : complete_lattice (normed_linear_ordered_group (semiring unsigned))) : is_compactly_generated (normed_linear_ordered_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_137379 (h0 : ordered_add_comm_monoid (mv_power_series unsigned unsigned)) : archimedean (mv_power_series unsigned unsigned) := sorry --non-trivial
lemma new_lemma_137380 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_137381 (h0 : functor.add_const (semiring (preorder num)) num) : @is_noetherian_ring.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (semiring.{0} (preorder.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_137382 (h1 : topological_space (non_unital_non_assoc_semiring linarith.comp_source)) : totally_disconnected_space (non_unital_non_assoc_semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_137383 (h0 : topological_space (semiring (has_norm (has_top (has_norm linarith.comp))))) : locally_compact_space (semiring (has_norm (has_top (has_norm linarith.comp)))) := sorry --non-trivial
lemma new_lemma_137384 (h0 : functor.add_const (topological_space (add_comm_monoid unsigned)) environment.implicit_infer_kind) : @topological_space.separable_space.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_137385 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_compactly_generated.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_137386 (h0 : functor.add_const Prop (sub_neg_monoid (sub_neg_monoid linarith.comp))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_137387 (h0 : functor.add_const (ring (left_cancel_monoid empty)) unsigned) : @is_domain.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_137388 (h0 : filter (has_neg_part (boolean_algebra.core ennreal))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_137389 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_add.{0} num) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_add.{0} num))  := sorry --non-trivial
lemma new_lemma_137390 (h0 : topological_space (has_zero unsigned)) : discrete_topology (has_zero unsigned) := sorry --non-trivial
lemma new_lemma_137391 (h1 : topological_space (with_one char)) : path_connected_space (with_one char) := sorry --non-trivial
lemma new_lemma_137392 (h1 : function.extfun Type uniform_space) : @complete_space.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} h1 (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_137393 (h0 : has_mem.mem (semiring linarith.comp) has_emptyc.emptyc) : @discrete_topology.{0} (semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_137394 (h1 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h1) (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_137395 (h0 : generalized_boolean_algebra real -> generalized_boolean_algebra real -> Prop) : is_refl (generalized_boolean_algebra real) h0 := sorry --non-trivial
lemma new_lemma_137396 (h0 : function.extfun Type (functor.add_const (topological_space (has_Sup unsigned)))) : @totally_separated_space.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} unsigned)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_Sup.{0} unsigned))) h0 empty))  := sorry --non-trivial
lemma new_lemma_137397 (h1 : uniform_space (has_append linarith.ineq)) : separated_space (has_append linarith.ineq) := sorry --non-trivial
lemma new_lemma_137398 (h0 : semiring (add_comm_semigroup (add_comm_monoid std_gen))) (h1 : add_comm_semigroup (add_comm_monoid std_gen)) : even h1 := sorry --non-trivial
lemma new_lemma_137399 (h0 : topological_space (has_inv string_imp)) : locally_compact_space (has_inv string_imp) := sorry --non-trivial
lemma new_lemma_137400 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_137401 (h0 : group (has_nndist (has_add name))) : group.fg (has_nndist (has_add name)) := sorry --non-trivial
lemma new_lemma_137402 (h0 : topological_space (encodable (random_gen (random_gen to_additive.value_type)))) : t0_space (encodable (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_137403 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_137404 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_137405 (h0 : topological_space (cancel_monoid (option (option (option ennreal))))) : totally_separated_space (cancel_monoid (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_137406 (h0 : complete_lattice (with_one (add_left_cancel_monoid linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (with_one (add_left_cancel_monoid linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_137407 (h0 : group (semiring congr_arg_kind)) : is_cyclic (semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_137408 (h0 : functor.add_const (group (has_nndist Type)) Type) : @is_simple_group.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (has_nndist.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_137409 (h0 : group (monoid unsigned)) : group.fg (monoid unsigned) := sorry --non-trivial
lemma new_lemma_137410 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_137411 (h0 : complete_lattice (measurable_space (has_norm linarith.ineq))) : is_atomistic (measurable_space (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_137412 (h0 : functor.add_const (topological_space (has_neg_part environment.implicit_infer_kind)) linarith.comp) : @totally_separated_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_137413 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_atomistic.{0} fun_info (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) fun_info)  := sorry --non-trivial
lemma new_lemma_137414 (h1 : function.extfun Type topological_space) : @locally_compact_space.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_137415 (h0 : ring (has_to_string (option ennreal))) : rank_condition (has_to_string (option ennreal)) := sorry --non-trivial
lemma new_lemma_137416 (h0 : topological_space (encodable linarith.comp_source)) : locally_compact_space (encodable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_137417 (h0 : has_mem.mem (function.extfun Type) has_emptyc.emptyc) : @locally_compact_space.{0} (measurable_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) h0) topological_space.{0}) (measurable_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_137418 (h0 : add_group (has_to_string ennreal)) : is_add_cyclic (has_to_string ennreal) := sorry --non-trivial
lemma new_lemma_137419 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_separated_space.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) linarith.comp)  := sorry --non-trivial
lemma new_lemma_137420 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) h0) (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_137421 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (semiring.{0} (has_add.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_137422 (h0 : uniform_space (has_nndist (has_Inf name))) : complete_space (has_nndist (has_Inf name)) := sorry --non-trivial
lemma new_lemma_137423 (h0 : functor.add_const (function.extfun (Type 1) add_monoid) (finset pos)) : @add_monoid.fg.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_monoid.{1}) (finset.{0} pos) h0) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_137424 (h0 : topological_space (has_nnnorm reducibility_hints)) : totally_disconnected_space (has_nnnorm reducibility_hints) := sorry --non-trivial
lemma new_lemma_137425 (h0 : functor.comp ring has_lt linarith.comp_source) : @is_domain.{0} (has_lt.{0} linarith.comp_source) (@functor.comp.run.{0 0 0} ring.{0} has_lt.{0} linarith.comp_source h0)  := sorry --non-trivial
lemma new_lemma_137426 (h0 : complete_lattice (ordered_comm_ring (sub_neg_monoid real))) : is_compactly_generated (ordered_comm_ring (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_137427 (h0 : list (add_cancel_monoid (has_neg_part Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_137428 (h0 : complete_lattice (has_neg (add_comm_monoid pos))) : is_atomistic (has_neg (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_137429 (h0 : functor.add_const (topological_space (has_to_string unsigned)) Type) : @loc_path_connected_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_137430 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} pos (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) pos)  := sorry --non-trivial
lemma new_lemma_137431 (h0 : fin has_zero.zero) : @add_monoid.fg.{0} (canonically_ordered_comm_semiring.{0} pos) (@matrix.vec_empty.{0} (add_monoid.{0} (canonically_ordered_comm_semiring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_137432 (h0 : ring (id (random_gen (has_inv linarith.ineq)))) : rank_condition (id (random_gen (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_137433 (h0 : functor.add_const (monoid (has_Inf pos)) pos) : @monoid.fg.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (has_Inf.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_137434 (h1 : ring (topological_space (random_gen (random_gen string_imp)))) : rank_condition (topological_space (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_137435 (h0 : functor.add_const (function.extfun (Type 1) list) environment.implicit_infer_kind) : palindrome (function.extfun_app (functor.add_const.run h0) (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_137436 (h0 : topological_space (measurable_space (random_gen (random_gen fun_info)))) : discrete_topology (measurable_space (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_137437 (h0 : not (topological_space (distrib (has_nnnorm (random_gen (has_nnnorm char)))) -> false)) : @totally_disconnected_space.{0} (distrib.{0} (has_nnnorm.{0} (random_gen.{0} (has_nnnorm.{0} char)))) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib.{0} (has_nnnorm.{0} (random_gen.{0} (has_nnnorm.{0} char))))) h0)  := sorry --non-trivial
lemma new_lemma_137438 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_137439 (h0 : complete_lattice (preorder (semiring (semiring empty)))) : is_compactly_generated (preorder (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_137440 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_137441 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_137442 (h0 : functor.add_const (ring (has_neg linarith.comp)) linarith.comp) : @strong_rank_condition.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_137443 (h0 : topological_space (has_nnnorm (has_nnnorm (has_nnnorm (has_div enat))))) : path_connected_space (has_nnnorm (has_nnnorm (has_nnnorm (has_div enat)))) := sorry --non-trivial
lemma new_lemma_137444 (h0 : functor.add_const (group (add_comm_monoid unsigned)) Type) : @normalizer_condition.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 1} (group.{0} (add_comm_monoid.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_137445 (h0 : filter (add_left_cancel_monoid fun_info)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_137446 (h0 : topological_space (has_add (has_neg pos))) : sequential_space (has_add (has_neg pos)) := sorry --non-trivial
lemma new_lemma_137447 (h0 : uniform_space (canonically_linear_ordered_monoid Type)) : separated_space (canonically_linear_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_137448 (h0 : topological_space (has_pos_part Type)) : totally_disconnected_space (has_pos_part Type) := sorry --non-trivial
lemma new_lemma_137449 (h0 : functor.add_const (topological_space (complete_distrib_lattice linarith.comp)) linarith.comp) : @sequential_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_137450 (h0 : complete_lattice (has_nndist (has_add environment.implicit_infer_kind))) : is_compactly_generated (has_nndist (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_137451 (h0 : functor.add_const (topological_space (normed_comm_ring environment.implicit_infer_kind)) linarith.comp) : @loc_path_connected_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_137452 (h0 : not (filter (add_monoid char) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_137453 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_inter num)) := sorry --non-trivial
lemma new_lemma_137454 (h0 : topological_space (add_group (has_norm (semiring (has_norm (semiring (semiring unsigned))))))) : locally_compact_space (add_group (has_norm (semiring (has_norm (semiring (semiring unsigned)))))) := sorry --non-trivial
lemma new_lemma_137455 (h0 : ring (has_nnnorm (random_gen (random_gen (random_gen char))))) : rank_condition (has_nnnorm (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_137456 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_137457 (h0 : topological_space (boolean_algebra.core (add_cancel_monoid Type))) : sequential_space (boolean_algebra.core (add_cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_137458 (h0 : has_mem.mem (linear_ordered_semiring linarith.comp) has_emptyc.emptyc) : @discrete_topology.{0} (linear_ordered_semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_137459 (h0 : topological_space (add_cancel_monoid (has_pos_part (has_pos_part name)))) : loc_path_connected_space (add_cancel_monoid (has_pos_part (has_pos_part name))) := sorry --non-trivial
lemma new_lemma_137460 (h0 : functor.add_const (complete_lattice (comm_group linarith.comp)) pos) : @is_compactly_generated.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_137461 (h1 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @path_connected_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h1 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_137462 (h0 : ring (simple_graph (has_Inf linarith.comp))) : rank_condition (simple_graph (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_137463 (h0 : group (add_cancel_monoid (has_add Type))) : is_simple_group (add_cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_137464 (h0 : functor.add_const (group (comm_group pos)) (boolean_algebra.core name)) : @is_cyclic.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} pos)) (boolean_algebra.core.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_137465 (h0 : topological_space (semigroup (has_add (boolean_algebra.core linarith.comp)))) : preirreducible_space (semigroup (has_add (boolean_algebra.core linarith.comp))) := sorry --non-trivial
lemma new_lemma_137466 (h0 : functor.add_const (function.extfun nat fin) real) : @is_noetherian_ring.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (semiring.{1} (has_pos_part.{1} Type)) (@function.extfun_app.{1 1} nat fin (@functor.add_const.run.{0 0} (function.extfun.{1 1} nat fin) real h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_137467 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_137468 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_disconnected_space.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_137469 (h0 : functor.add_const (add_monoid (has_add name)) Type) : @add_monoid.fg.{0} (has_add.{0} name) (@functor.add_const.run.{0 1} (add_monoid.{0} (has_add.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_137470 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_137471 (h0 : topological_space (normed_group (random_gen fun_info))) : path_connected_space (normed_group (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_137472 (h0 : topological_space (has_pos_part (has_add linarith.comp))) : totally_separated_space (has_pos_part (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_137473 (h0 : group (semigroup (semigroup pos))) : group.fg (semigroup (semigroup pos)) := sorry --non-trivial
lemma new_lemma_137474 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} num (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 num)  := sorry --non-trivial
lemma new_lemma_137475 (h0 : add_group (topological_space (topological_space string_imp))) : is_add_cyclic (topological_space (topological_space string_imp)) := sorry --non-trivial
lemma new_lemma_137476 (h2 : ring (topological_space to_additive.value_type)) : rank_condition (topological_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_137477 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_137478 (h0 : function.extfun Type (prod (add_right_cancel_monoid (semiring empty)))) : id_rel (function.extfun_app h0 (add_right_cancel_monoid (semiring empty))) := sorry --non-trivial
lemma new_lemma_137479 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf real))) : t1_space (canonically_linear_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_137480 (h0 : topological_space (comm_group (cancel_monoid ennreal))) : discrete_topology (comm_group (cancel_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_137481 (h0 : topological_space (has_zero (ring (ring Type)))) : t1_space (has_zero (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_137482 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) pos) : @locally_compact_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_137483 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_137484 (h0 : char -> mul_one_class fun_info -> mul_one_class fun_info) (h2 : mul_one_class fun_info -> Prop) : contravariant_class char (mul_one_class fun_info) h0 (fun (h1 : mul_one_class fun_info), h2) := sorry --non-trivial
lemma new_lemma_137485 (h0 : complete_lattice (has_ssubset (random_gen string_imp))) : is_compactly_generated (has_ssubset (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_137486 (h0 : not (group (bin_tree unsigned) -> false)) : @group.fg.{0} (bin_tree.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (bin_tree.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_137487 (h0 : functor.add_const (topological_space (comm_group Type)) linarith.comp) : @path_connected_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_137488 (h0 : ring (random_gen (random_gen char))) : rank_condition (random_gen (random_gen char)) := sorry --non-trivial
lemma new_lemma_137489 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_bot empty)) := sorry --non-trivial
lemma new_lemma_137490 (h1 : topological_space (with_one (random_gen to_additive.value_type))) : path_connected_space (with_one (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_137491 (h1 : ring (complete_semilattice_Sup num)) : rank_condition (complete_semilattice_Sup num) := sorry --non-trivial
lemma new_lemma_137492 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_137493 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) linarith.comp) : @locally_compact_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_137494 (h0 : topological_space (measurable_space.dynkin_system unsigned)) : normal_space (measurable_space.dynkin_system unsigned) := sorry --non-trivial
lemma new_lemma_137495 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf pos))) : t0_space (canonically_linear_ordered_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_137496 (h0 : topological_space (measurable_space (random_gen (random_gen num)))) : totally_disconnected_space (measurable_space (random_gen (random_gen num))) := sorry --non-trivial
lemma new_lemma_137497 (h0 : not (topological_space (normed_field char) -> false)) : @t0_space.{0} (normed_field.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_field.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_137498 (h0 : not (group (has_ssubset (metric_space reducibility_hints)) -> false)) : @is_cyclic.{0} (has_ssubset.{0} (metric_space.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (group.{0} (has_ssubset.{0} (metric_space.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_137499 (h0 : add_group (has_star (semiring (semiring unsigned)))) : is_add_cyclic (has_star (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_137500 (h0 : ordered_add_comm_monoid (has_to_string Type)) : archimedean (has_to_string Type) := sorry --non-trivial
lemma new_lemma_137501 (h0 : functor.add_const (ring (has_zero name)) name) : @strong_rank_condition.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_137502 (h0 : functor.add_const (semiring (has_zero environment.implicit_infer_kind)) environment.implicit_infer_kind) : @is_noetherian_ring.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (semiring.{0} (has_zero.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_137503 (h0 : cancel_comm_monoid_with_zero (has_edist (option (option (option empty))))) : unique_factorization_monoid (has_edist (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_137504 (h0 : functor.add_const (function.extfun Type group) Type) : @group.fg.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_137505 (h2 : topological_space (semi_normed_ring (comm_ring char))) : totally_disconnected_space (semi_normed_ring (comm_ring char)) := sorry --non-trivial
lemma new_lemma_137506 (h0 : ring (has_bot (has_neg name))) : rank_condition (has_bot (has_neg name)) := sorry --non-trivial
lemma new_lemma_137507 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (has_sub.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (has_sub.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_137508 (h0 : topological_space (has_nndist (boolean_algebra.core Type))) : totally_disconnected_space (has_nndist (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_137509 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_137510 (h0 : functor.add_const (topological_space (has_nndist Type)) unsigned) : @totally_separated_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_137511 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_disconnected_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_137512 (h0 : group (has_nndist congr_arg_kind)) : is_simple_group (has_nndist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_137513 (h0 : function.extfun nat fin) : @is_cyclic.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (group.{0} (comm_semigroup.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_137514 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_inv.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_inv.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_137515 (h0 : not (topological_space (has_norm linarith.ineq) -> false)) : @path_connected_space.{0} (has_norm.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_137516 (h0 : topological_space (cancel_monoid num)) : normal_space (cancel_monoid num) := sorry --non-trivial
lemma new_lemma_137517 (h0 : functor.add_const (group (complete_distrib_lattice pos)) Type) : @normalizer_condition.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (complete_distrib_lattice.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_137518 (h0 : ring (boolean_algebra (has_neg_part name))) : is_principal_ideal_ring (boolean_algebra (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_137519 (h0 : filter (has_neg (normed_comm_ring Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_137520 (h0 : functor.add_const (function.extfun Type topological_space) (mul_one_class Type)) : @t0_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (mul_one_class.{1} Type) h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_137521 (h0 : generalized_boolean_algebra (sub_neg_monoid real) -> generalized_boolean_algebra (sub_neg_monoid real) -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_137522 (h0 : topological_space (normed_field (has_div linarith.ineq))) : t0_space (normed_field (has_div linarith.ineq)) := sorry --non-trivial
lemma new_lemma_137523 (h0 : complete_lattice (canonically_ordered_monoid (has_add (has_Inf real)))) : is_atomistic (canonically_ordered_monoid (has_add (has_Inf real))) := sorry --non-trivial
lemma new_lemma_137524 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) linarith.comp) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_137525 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_inner.{0 0} unsigned unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inner.{0 0} unsigned unsigned))  := sorry --non-trivial
lemma new_lemma_137526 (h0 : functor.add_const (monoid (has_to_string environment.implicit_infer_kind)) name) : @monoid.fg.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (has_to_string.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_137527 (h0 : ring (complete_semilattice_Sup (has_top linarith.comp_source))) : strong_rank_condition (complete_semilattice_Sup (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_137528 (h1 : function.extfun Type group) : @normalizer_condition.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h1 (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_137529 (h0 : ring (has_pos_part (has_Inf pos))) : rank_condition (has_pos_part (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_137530 (h2 : monoid (complete_semilattice_Sup linarith.comp_source)) : monoid.fg (complete_semilattice_Sup linarith.comp_source) := sorry --non-trivial
lemma new_lemma_137531 (h0 : functor.add_const (function.extfun Type semiring) (has_neg (add_cancel_monoid name))) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) (has_neg.{0} (add_cancel_monoid.{0} name)) h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_137532 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_137533 (h0 : topological_space (complete_distrib_lattice num)) : discrete_topology (complete_distrib_lattice num) := sorry --non-trivial
lemma new_lemma_137534 (h0 : ordered_add_comm_monoid (filter (option unsigned))) : archimedean (filter (option unsigned)) := sorry --non-trivial
lemma new_lemma_137535 (h0 : not (complete_lattice (semi_normed_ring to_additive.value_type) -> false)) : @is_compactly_generated.{0} (semi_normed_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semi_normed_ring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_137536 (h0 : ring (boolean_algebra.core pos)) : strong_rank_condition (boolean_algebra.core pos) := sorry --non-trivial
lemma new_lemma_137537 (h0 : not (list (has_inv char) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_137538 (h2 : ring (semi_normed_comm_ring to_additive.value_type)) : strong_rank_condition (semi_normed_comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_137539 (h0 : complete_lattice (has_nndist empty)) : is_atomistic (has_nndist empty) := sorry --non-trivial
lemma new_lemma_137540 (h0 : add_monoid congr_arg_kind) : add_monoid.fg congr_arg_kind := sorry --non-trivial
lemma new_lemma_137541 (h0 : functor.add_const (function.extfun Type uniform_space) linarith.comp) : @separated_space.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) linarith.comp h0) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_137542 (h0 : functor.add_const (list (has_nndist environment.implicit_infer_kind)) (has_add name)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_137543 (h0 : group (has_neg_part (comm_group Type))) : is_cyclic (has_neg_part (comm_group Type)) := sorry --non-trivial
lemma new_lemma_137544 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_137545 (h0 : topological_space (with_one (has_top (semiring unsigned)))) : totally_disconnected_space (with_one (has_top (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_137546 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_137547 (h0 : group (add_cancel_comm_monoid (has_nnnorm (random_gen (has_nnnorm linarith.comp_source))))) : is_cyclic (add_cancel_comm_monoid (has_nnnorm (random_gen (has_nnnorm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_137548 (h0 : add_group (has_zero (finset environment.implicit_infer_kind))) : is_add_cyclic (has_zero (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_137549 (h0 : topological_space (add_right_cancel_monoid num)) : regular_space (add_right_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_137550 (h0 : uniform_space environment.projection_info) : complete_space environment.projection_info := sorry --non-trivial
lemma new_lemma_137551 (h0 : has_lt (has_nnnorm string.iterator_imp)) : no_max_order (has_nnnorm string.iterator_imp) := sorry --non-trivial
lemma new_lemma_137552 (h1 : prod enat enat) : set.diagonal enat h1 := sorry --non-trivial
lemma new_lemma_137553 (h0 : has_lt (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup enat)))) : no_max_order (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup enat))) := sorry --non-trivial
lemma new_lemma_137554 (h0 : topological_space (has_inter (option (option (option (option unsigned)))))) : t1_space (has_inter (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_137555 (h0 : complete_lattice (has_compl (mul_one_class enat))) : is_compactly_generated (has_compl (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_137556 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_137557 (h0 : functor.add_const (semiring (has_neg pos)) (has_neg name)) : @is_noetherian_ring.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (has_neg.{0} pos)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_137558 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @rank_condition.{0} (add_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ring.{0}) (add_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_137559 (h0 : functor.add_const (topological_space (complete_distrib_lattice unsigned)) linarith.comp) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_137560 (h0 : add_group (has_ssubset (has_nnnorm char))) : is_add_cyclic (has_ssubset (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_137561 (h0 : functor.add_const (function.extfun (Type 1) add_group) pos) : @is_add_cyclic.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_group.{1}) pos h0) (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_137562 (h0 : functor.add_const (complete_lattice (complete_distrib_lattice empty)) empty) : @is_atomistic.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (complete_distrib_lattice.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_137563 (h0 : ring (measurable_space (has_norm (has_norm (has_norm linarith.comp_source))))) : is_domain (measurable_space (has_norm (has_norm (has_norm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_137564 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen linarith.comp))) : @t0_space.{0} (random_gen.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_137565 (h0 : functor.add_const (ring (ordered_comm_monoid pos)) pos) : @rank_condition.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_137566 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (comm_semigroup.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_137567 (h0 : uniform_space (has_union (has_top (semiring linarith.comp)))) : complete_space (has_union (has_top (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_137568 (h0 : group (ordered_comm_monoid (ring pos))) : group.fg (ordered_comm_monoid (ring pos)) := sorry --non-trivial
lemma new_lemma_137569 (h0 : ring (semigroup (add_comm_monoid pos))) : strong_rank_condition (semigroup (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_137570 (h0 : set (add_comm_semigroup ereal -> fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_137571 (h0 : topological_space (has_mul (mul_one_class (mul_one_class environment.projection_info)))) : totally_disconnected_space (has_mul (mul_one_class (mul_one_class environment.projection_info))) := sorry --non-trivial
lemma new_lemma_137572 (h0 : topological_space (comm_semigroup (has_neg name))) : preirreducible_space (comm_semigroup (has_neg name)) := sorry --non-trivial
lemma new_lemma_137573 (h0 : ordered_comm_monoid (has_norm (has_neg pos))) : has_exists_mul_of_le (has_norm (has_neg pos)) := sorry --non-trivial
lemma new_lemma_137574 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_137575 (h0 : topological_space (ring (option ennreal))) : preirreducible_space (ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_137576 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type semiring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type semiring.{0}) h0) (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_137577 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_137578 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_137579 (h0 : list (monoid (add_comm_monoid (add_comm_monoid congr_arg_kind)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_137580 (h0 : filter (canonically_ordered_comm_semiring (has_add (has_add (cancel_monoid (ring pos)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_137581 (h0 : functor.add_const (ordered_add_comm_monoid (ring Type)) environment.implicit_infer_kind) : @archimedean.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (ring.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_137582 (h0 : topological_space (id (random_gen (with_bot to_additive.value_type)))) : totally_separated_space (id (random_gen (with_bot to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_137583 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (has_bot.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_137584 (h0 : complete_lattice (has_inv (has_ssubset linarith.comp_source))) : is_compactly_generated (has_inv (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_137585 (h0 : ring (finset (finset (finset (finset (finset (finset pos))))))) : is_principal_ideal_ring (finset (finset (finset (finset (finset (finset pos)))))) := sorry --non-trivial
lemma new_lemma_137586 (h1 : ring (distrib (has_ssubset (has_ssubset char)))) : rank_condition (distrib (has_ssubset (has_ssubset char))) := sorry --non-trivial
lemma new_lemma_137587 (h0 : topological_space (mul_zero_class pos)) : sequential_space (mul_zero_class pos) := sorry --non-trivial
lemma new_lemma_137588 (h0 : not (topological_space (measurable_space unsigned) -> false)) : @normal_space.{0} (measurable_space.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_137589 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_137590 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_137591 (h0 : uniform_space (complete_linear_order (semiring num))) : separated_space (complete_linear_order (semiring num)) := sorry --non-trivial
lemma new_lemma_137592 (h0 : ring (dlist (has_nnnorm linarith.ineq))) : rank_condition (dlist (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_137593 (h0 : functor.add_const (topological_space (has_neg_part linarith.comp)) environment.implicit_infer_kind) : @path_connected_space.{0} (has_neg_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_137594 (h0 : group (dlist (random_gen (random_gen to_additive.value_type)))) : is_cyclic (dlist (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_137595 (h0 : group (boolean_algebra (add_comm_monoid (has_add Type)))) : group.fg (boolean_algebra (add_comm_monoid (has_add Type))) := sorry --non-trivial
lemma new_lemma_137596 (h0 : complete_lattice (complete_linear_order (semiring (semiring (semiring unsigned))))) : is_compactly_generated (complete_linear_order (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_137597 (h0 : not (has_mem.mem (has_emptyc linarith.comp_source) has_emptyc.emptyc -> false)) : @is_compactly_generated.{0} (has_emptyc.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_emptyc.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_137598 (h0 : functor.add_const (topological_space (boolean_algebra.core linarith.comp)) linarith.comp) : @topological_space.separable_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_137599 (h0 : function.extfun Type (functor.add_const (topological_space (simple_graph name)))) : @discrete_topology.{0} (simple_graph.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} name)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (simple_graph.{0} name))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_137600 (h1 : group char) : is_cyclic char := sorry --non-trivial
lemma new_lemma_137601 (h0 : functor.add_const (ring (canonically_linear_ordered_monoid pos)) name) : @is_principal_ideal_ring.{0} (canonically_linear_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (canonically_linear_ordered_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_137602 (h0 : ring (plift (semiring (semiring (semiring empty))))) : is_principal_ideal_ring (plift (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_137603 (h1 : cancel_comm_monoid_with_zero linarith.ineq) (h2 : topological_space (gcd_monoid linarith.ineq)) : topological_space.first_countable_topology (gcd_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_137604 (h0 : not (add_group (has_compl string.iterator_imp) -> false)) : @is_add_cyclic.{0} (has_compl.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (add_group.{0} (has_compl.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_137605 (h0 : list (option pos)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_137606 (h0 : functor.add_const (topological_space (has_Inf pos)) Type) : @totally_disconnected_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_137607 (h0 : group (semigroup (measurable_space.dynkin_system pos))) : is_cyclic (semigroup (measurable_space.dynkin_system pos)) := sorry --non-trivial
lemma new_lemma_137608 (h0 : functor.add_const (uniform_space (comm_group Type)) (finset (finset linarith.comp))) : @complete_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (comm_group.{1} Type)) (finset.{0} (finset.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_137609 (h0 : functor.comp ring complete_distrib_lattice linarith.comp) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.comp.run.{0 0 0} ring.{0} complete_distrib_lattice.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_137610 (h2 : ring (has_ssubset linarith.ineq)) : strong_rank_condition (has_ssubset linarith.ineq) := sorry --non-trivial
lemma new_lemma_137611 (h0 : function.extfun Type group) : @group.fg.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_137612 (h0 : topological_space (boolean_algebra.core (has_add linarith.comp))) : preconnected_space (boolean_algebra.core (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_137613 (h0 : ring (with_one num)) : is_principal_ideal_ring (with_one num) := sorry --non-trivial
lemma new_lemma_137614 (h1 : has_mem.mem (has_one linarith.comp) has_emptyc.emptyc) : @totally_separated_space.{0} (has_one.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_one.{0} linarith.comp) h1)  := sorry --non-trivial
lemma new_lemma_137615 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_137616 (h0 : functor.add_const (group (sub_neg_monoid pos)) name) : @is_simple_group.{0} (sub_neg_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (sub_neg_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_137617 (h0 : functor.add_const (group (boolean_algebra.core Type)) pos) : @normalizer_condition.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (boolean_algebra.core.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_137618 (h0 : topological_space (semigroup (semigroup name))) : preirreducible_space (semigroup (semigroup name)) := sorry --non-trivial
lemma new_lemma_137619 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_pos_part.{0} (has_Inf.{0} linarith.comp)) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_pos_part.{0} (has_Inf.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_137620 (h0 : filter (boolean_algebra.core ennreal)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_137621 (h0 : group (with_bot (random_gen (has_norm (random_gen (measurable_space empty)))))) : group.fg (with_bot (random_gen (has_norm (random_gen (measurable_space empty))))) := sorry --non-trivial
lemma new_lemma_137622 (h0 : topological_space (has_zero (option num))) : locally_compact_space (has_zero (option num)) := sorry --non-trivial
lemma new_lemma_137623 (h0 : topological_space (boolean_algebra linarith.comp)) : path_connected_space (boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_137624 (h0 : functor.add_const (group (has_add Type)) Type) : @normalizer_condition.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (has_add.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_137625 (h0 : topological_space (add_comm_monoid (has_Inf Type))) : discrete_topology (add_comm_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_137626 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) Type) : @normal_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_137627 (h0 : functor.add_const (function.extfun Type topological_space) (has_to_string Type)) : @t1_space.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (has_to_string.{1} Type) h0) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_137628 (h0 : not (group (has_compl linarith.comp_source) -> false)) : @group.fg.{0} (has_compl.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (has_compl.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_137629 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_137630 (h0 : ring (distrib char)) : is_domain (distrib char) := sorry --non-trivial
lemma new_lemma_137631 (h0 : functor.add_const (topological_space (finset linarith.comp)) (finset pos)) : @topological_space.separable_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_137632 (h0 : functor.add_const (finset (semigroup environment.implicit_infer_kind)) (finset Type)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_137633 (h0 : fin has_zero.zero) : @t1_space.{0} (has_add.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_137634 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @path_connected_space.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_137635 (h0 : functor.add_const (function.extfun Type ring) (mul_zero_class (has_nndist (add_comm_monoid name)))) : @rank_condition.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (mul_zero_class.{0} (has_nndist.{0} (add_comm_monoid.{0} name))) h0) (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_137636 (h2 : complete_lattice (has_ssubset char)) : complete_lattice.is_Sup_finite_compact (has_ssubset char) := sorry --non-trivial
lemma new_lemma_137637 (h0 : topological_space (has_to_string (boolean_algebra Type))) : totally_separated_space (has_to_string (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_137638 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_star unsigned)) := sorry --non-trivial
lemma new_lemma_137639 (h0 : list (add_cancel_monoid (has_pos_part linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_137640 (h0 : functor.add_const (topological_space (preorder num)) unsigned) : @t0_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_137641 (h0 : functor.comp add_group has_neg name) : @is_add_cyclic.{0} (has_neg.{0} name) (@functor.comp.run.{0 0 0} add_group.{0} has_neg.{0} name (@functor.comp.run.{0 0 0} add_group.{0} has_neg.{0} name h0))  := sorry --non-trivial
lemma new_lemma_137642 (h0 : ring (has_emptyc linarith.comp)) : strong_rank_condition (has_emptyc linarith.comp) := sorry --non-trivial
lemma new_lemma_137643 (h0 : topological_space (has_norm num)) : path_connected_space (has_norm num) := sorry --non-trivial
lemma new_lemma_137644 (h0 : has_compl (has_ssubset string_imp) -> has_compl (has_ssubset string_imp) -> Prop) : is_order_connected (has_compl (has_ssubset string_imp)) h0 := sorry --non-trivial
lemma new_lemma_137645 (h0 : group (semi_normed_comm_ring fun_info)) : is_cyclic (semi_normed_comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_137646 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_137647 (h0 : topological_space (has_to_string (option congr_arg_kind))) : totally_disconnected_space (has_to_string (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_137648 (h0 : fin has_zero.zero) : @regular_space.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (normed_lattice_add_comm_group.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_137649 (h0 : add_group (cancel_monoid empty)) : is_add_cyclic (cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_137650 (h0 : functor.add_const (functor.add_const (function.extfun Type ring) pos) (finset pos)) : @is_principal_ideal_ring.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (function.extfun.{2 1} Type ring.{0}) pos) (finset.{0} pos) h0)) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_137651 (h0 : semiring (has_top num)) : is_noetherian_ring (has_top num) := sorry --non-trivial
lemma new_lemma_137652 (h0 : function.extfun Type topological_space) : @normal_space.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_137653 (h0 : functor.add_const (ring (cancel_monoid Type)) name) : @is_domain.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_137654 (h0 : topological_space (boolean_algebra.core (add_comm_monoid Type))) : regular_space (boolean_algebra.core (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_137655 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} subsingleton_info (@function.extfun_app.{2 1} Type topological_space.{0} h0 subsingleton_info)  := sorry --non-trivial
lemma new_lemma_137656 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (linear_ordered_comm_ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_137657 (h0 : not (add_group (semiring num) -> false)) : @is_add_cyclic.{0} (semiring.{0} num) (@classical.by_contradiction'.{1} (add_group.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_137658 (h0 : ring (linear_ordered_semiring (has_top (has_top num)))) : is_domain (linear_ordered_semiring (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_137659 (h0 : not (complete_lattice (semi_normed_comm_ring to_additive.value_type) -> false)) : @is_compactly_generated.{0} (semi_normed_comm_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semi_normed_comm_ring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_137660 (h0 : uniform_space (complete_semilattice_Sup (with_bot (with_bot string_imp)))) : complete_space (complete_semilattice_Sup (with_bot (with_bot string_imp))) := sorry --non-trivial
lemma new_lemma_137661 (h0 : functor.add_const (list auto.case_option) (option unsigned)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_137662 (h0 : not (uniform_space unsigned -> false)) : @separated_space.{0} unsigned (@classical.by_contradiction'.{1} (uniform_space.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_137663 (h0 : finset (add_cancel_monoid (has_pos_part Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_137664 (h0 : topological_space (id (has_top fun_info))) : locally_compact_space (id (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_137665 (h0 : topological_space (finset (has_to_string linarith.comp))) : topological_space.separable_space (finset (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_137666 (h0 : functor.add_const (topological_space (bin_tree num)) congr_arg_kind) : @normal_space.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_137667 (h0 : ring (random_gen (random_gen (random_gen (comm_ring linarith.ineq))))) : rank_condition (random_gen (random_gen (random_gen (comm_ring linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_137668 (h0 : complete_lattice (pseudo_metric_space unsigned)) : complete_lattice.is_Sup_finite_compact (pseudo_metric_space unsigned) := sorry --non-trivial
lemma new_lemma_137669 (h0 : topological_space (has_pos_part (sub_neg_monoid Type))) : normal_space (has_pos_part (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_137670 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @path_connected_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_137671 (h0 : group (finset (semigroup (semigroup Type)))) : normalizer_condition (finset (semigroup (semigroup Type))) := sorry --non-trivial
lemma new_lemma_137672 (h0 : topological_space (monoid (option (as_linear_order (option (option unsigned)))))) : path_connected_space (monoid (option (as_linear_order (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_137673 (h0 : topological_space (boolean_algebra.core congr_arg_kind)) : totally_separated_space (boolean_algebra.core congr_arg_kind) := sorry --non-trivial
lemma new_lemma_137674 (h0 : group (has_top (has_inv linarith.comp_source))) : normalizer_condition (has_top (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_137675 (h0 : topological_space (has_pos_part Type)) : topological_space.separable_space (has_pos_part Type) := sorry --non-trivial
lemma new_lemma_137676 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_137677 (h0 : topological_space (linear_ordered_comm_ring (semiring num))) : locally_compact_space (linear_ordered_comm_ring (semiring num)) := sorry --non-trivial
lemma new_lemma_137678 (h0 : functor.add_const (add_monoid (boolean_algebra.core environment.implicit_infer_kind)) pos) : @add_monoid.fg.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_137679 (h0 : topological_space (generalized_boolean_algebra Type)) : irreducible_space (generalized_boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_137680 (h0 : topological_space (comm_group (comm_group unsigned))) : preirreducible_space (comm_group (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_137681 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_noetherian_ring.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 semiring.{1}) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_137682 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_137683 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_137684 (h0 : ring (has_nnnorm (mul_one_class linarith.ineq))) : is_domain (has_nnnorm (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_137685 (h0 : ring (ordered_comm_ring linarith.comp_source)) : is_domain (ordered_comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_137686 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_137687 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_137688 (h0 : functor.add_const (group (has_neg_part ennreal)) name) : @normalizer_condition.{0} (has_neg_part.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (has_neg_part.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_137689 (h0 : not (group (random_gen empty) -> false)) : @normalizer_condition.{0} (random_gen.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (random_gen.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_137690 (h0 : set (has_compl (mul_one_class string.iterator_imp))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_137691 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (denumerable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (denumerable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_137692 (h0 : cancel_comm_monoid_with_zero (non_assoc_semiring (option empty))) : unique_factorization_monoid (non_assoc_semiring (option empty)) := sorry --non-trivial
lemma new_lemma_137693 (h0 : topological_space (bin_tree (semiring (semiring num)))) : topological_space.separable_space (bin_tree (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_137694 (h0 : topological_space (ring (has_Inf pos))) : totally_disconnected_space (ring (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_137695 (h0 : topological_space (linear_ordered_comm_group unsigned)) : preirreducible_space (linear_ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_137696 (h0 : filter (finset (has_add ennreal))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_137697 (h0 : topological_space (normed_field enat)) (h1 : preorder (normed_field enat)) : order_topology (normed_field enat) := sorry --non-trivial
lemma new_lemma_137698 (h0 : topological_space (has_zero (has_pos_part (has_Inf (semigroup linarith.comp))))) : regular_space (has_zero (has_pos_part (has_Inf (semigroup linarith.comp)))) := sorry --non-trivial
lemma new_lemma_137699 (h2 : ring (has_div linarith.ineq)) : strong_rank_condition (has_div linarith.ineq) := sorry --non-trivial
lemma new_lemma_137700 (h0 : topological_space (bin_tree (non_assoc_semiring empty))) : topological_space.separable_space (bin_tree (non_assoc_semiring empty)) := sorry --non-trivial
lemma new_lemma_137701 (h0 : has_bot unsigned -> has_bot unsigned -> Prop) : is_symm (has_bot unsigned) h0 := sorry --non-trivial
lemma new_lemma_137702 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : is_atomistic (measurable_space string_imp) := sorry --non-trivial
lemma new_lemma_137703 (h0 : not (topological_space (random_gen num) -> false)) : @preirreducible_space.{0} (random_gen.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_137704 (h0 : functor.add_const (add_monoid (has_zero name)) pos) : @add_monoid.fg.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_zero.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_137705 (h0 : functor.add_const (uniform_space (boolean_algebra Type)) (finset pos)) : @separated_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (boolean_algebra.{1} Type)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_137706 (h0 : functor.add_const (function.extfun Type uniform_space) (mul_one_class (finset linarith.comp))) : @separated_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) (mul_one_class.{0} (finset.{0} linarith.comp)) h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_137707 (h0 : functor.add_const (add_monoid (semigroup pos)) name) : @add_monoid.fg.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (semigroup.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_137708 (h0 : topological_space (complete_distrib_lattice (ring linarith.comp))) : totally_disconnected_space (complete_distrib_lattice (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_137709 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_137710 (h0 : topological_space (has_union unsigned)) : locally_compact_space (has_union unsigned) := sorry --non-trivial
lemma new_lemma_137711 (h0 : topological_space (measurable_space (has_norm (has_norm congr_arg_kind)))) : totally_disconnected_space (measurable_space (has_norm (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_137712 (h0 : ring (measurable_space fun_info)) : is_domain (measurable_space fun_info) := sorry --non-trivial
lemma new_lemma_137713 (h0 : not (complete_lattice (topological_space reducibility_hints) -> false)) : complete_lattice.is_Sup_finite_compact (topological_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_137714 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) linarith.comp) : @preirreducible_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_137715 (h0 : functor.add_const (fin has_zero.zero) name) : @is_add_cyclic.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (add_group.{1} (canonically_linear_ordered_monoid.{1} Type)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) name h0))  := sorry --non-trivial
lemma new_lemma_137716 (h0 : filter (ring (has_add pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_137717 (h0 : filter (ordered_comm_ring name)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_137718 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @topological_space.separable_space.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_137719 (h0 : functor.add_const (function.extfun Type add_group) Type) : @is_add_cyclic.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_group.{0}) Type h0) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_137720 (h0 : group (measurable_space (has_inv (random_gen to_additive.value_type)))) : group.fg (measurable_space (has_inv (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_137721 (h0 : not (ring (random_gen linarith.ineq) -> false)) : @rank_condition.{0} (random_gen.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_137722 (h0 : complete_lattice (add_cancel_monoid unsigned)) : is_compactly_generated (add_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_137723 (h0 : topological_space (ring (has_Inf Type))) : locally_compact_space (ring (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_137724 (h0 : uniform_space (distrib enat)) : complete_space (distrib enat) := sorry --non-trivial
lemma new_lemma_137725 (h0 : uniform_space (non_assoc_semiring (semiring empty))) : complete_space (non_assoc_semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_137726 (h1 : ring (fintype (random_gen (random_gen char)))) : is_domain (fintype (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_137727 (h0 : topological_space (normed_comm_ring (has_neg (has_add Type)))) : sequential_space (normed_comm_ring (has_neg (has_add Type))) := sorry --non-trivial
lemma new_lemma_137728 (h0 : complete_lattice (complete_semilattice_Sup (random_gen fun_info))) : complete_lattice.is_Sup_finite_compact (complete_semilattice_Sup (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_137729 (h0 : functor.comp topological_space finset environment.implicit_infer_kind) : @sequential_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_137730 (h0 : ring (has_neg (has_to_string congr_arg_kind))) : strong_rank_condition (has_neg (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_137731 (h0 : topological_space (boolean_algebra.core (ordered_ring pos))) : normal_space (boolean_algebra.core (ordered_ring pos)) := sorry --non-trivial
lemma new_lemma_137732 (h0 : not (topological_space (semi_normed_ring string_imp) -> false)) : @path_connected_space.{0} (semi_normed_ring.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_ring.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_137733 (h0 : functor.add_const (complete_lattice (plift empty)) num) : @is_compactly_generated.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (complete_lattice.{1} (plift.{1} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_137734 (h0 : topological_space (generalized_boolean_algebra (ordered_ring linarith.comp))) : t0_space (generalized_boolean_algebra (ordered_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_137735 (h0 : list (is_R_or_C congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_137736 (h0 : complete_lattice (semigroup environment.implicit_infer_kind)) : is_compactly_generated (semigroup environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_137737 (h0 : function.extfun Type ring) : @rank_condition.{0} (add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_137738 (h0 : functor.add_const (uniform_space (boolean_algebra Type)) name) : @complete_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (boolean_algebra.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_137739 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (has_emptyc.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_emptyc.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_137740 (h0 : filter Prop) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@id.{1} (filter.{0} Prop) (@id.{1} (filter.{0} Prop) h0))  := sorry --non-trivial
lemma new_lemma_137741 (h0 : pnat) (h1 : set nat) (h2 : has_subset.subset h1 (fun (x : nat), nat.less_than_or_equal (nat.succ has_zero.zero) x)) (h3 : coe_sort h1) : pnat.coprime h0 (set.inclusion h2 h3) := sorry --non-trivial
lemma new_lemma_137742 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (filter.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (filter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_137743 (h0 : topological_space (distrib_lattice (random_gen (random_gen (random_gen linarith.ineq))))) : t0_space (distrib_lattice (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_137744 (h0 : set (nondiscrete_normed_field (mul_one_class ereal))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_137745 (h0 : uniform_space (ordered_comm_ring (has_add (has_neg Type)))) : separated_space (ordered_comm_ring (has_add (has_neg Type))) := sorry --non-trivial
lemma new_lemma_137746 (h0 : not (topological_space (measurable_space.dynkin_system congr_arg_kind) -> false)) : @locally_compact_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_137747 (h0 : functor.add_const (topological_space (has_to_string empty)) num) : @path_connected_space.{0} (has_to_string.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_137748 (h0 : topological_space (linear_ordered_semiring (has_norm num))) : irreducible_space (linear_ordered_semiring (has_norm num)) := sorry --non-trivial
lemma new_lemma_137749 (h1 : rel enat (fun_info -> char)) (h2 : set enat) : set.separates_points (rel.image h1 h2) := sorry --non-trivial
lemma new_lemma_137750 (h0 : uniform_space (comm_group to_additive.value_type)) : complete_space (comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_137751 (h0 : complete_lattice (add_semigroup empty)) : is_compactly_generated (add_semigroup empty) := sorry --non-trivial
lemma new_lemma_137752 (h0 : Prop) (h1 : not h0) (h2 : h0) : @complete_lattice.is_Sup_finite_compact.{0} (nondiscrete_normed_field.{0} ereal) (@not.elim.{1} h0 (complete_lattice.{0} (nondiscrete_normed_field.{0} ereal)) h1 h2)  := sorry --trivial
lemma new_lemma_137753 (h0 : finset (linear_ordered_comm_group (option num))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_137754 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_137755 (h0 : ring (omega_complete_partial_order congr_arg_kind)) : rank_condition (omega_complete_partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_137756 (h0 : functor.add_const (add_group (ring Type)) linarith.comp) : @is_add_cyclic.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_137757 (h0 : functor.add_const (uniform_space (normed_comm_ring environment.implicit_infer_kind)) Type) : @separated_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (uniform_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_137758 (h0 : cancel_comm_monoid_with_zero (ring name)) : unique_factorization_monoid (ring name) := sorry --non-trivial
lemma new_lemma_137759 (h0 : uniform_space (with_bot unsigned)) : complete_space (with_bot unsigned) := sorry --non-trivial
lemma new_lemma_137760 (h0 : topological_space (simple_graph (has_Inf (has_add pos)))) : preirreducible_space (simple_graph (has_Inf (has_add pos))) := sorry --non-trivial
lemma new_lemma_137761 (h2 : filter (comm_ring fun_info)) : filter.ne_bot h2 := sorry --non-trivial
lemma new_lemma_137762 (h0 : functor.add_const (topological_space (normed_comm_ring environment.implicit_infer_kind)) pos) : @topological_space.separable_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_137763 (h0 : topological_space (add_cancel_monoid (finset environment.implicit_infer_kind))) : regular_space (add_cancel_monoid (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_137764 (h0 : topological_space (semigroup (mul_zero_class (mul_zero_class (mul_zero_class name))))) : normal_space (semigroup (mul_zero_class (mul_zero_class (mul_zero_class name)))) := sorry --non-trivial
lemma new_lemma_137765 (h0 : monoid (ring num)) : monoid.fg (ring num) := sorry --non-trivial
lemma new_lemma_137766 (h0 : functor.add_const (semiring (has_nndist pos)) unsigned) : @is_noetherian_ring.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (has_nndist.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_137767 (h0 : functor.add_const (topological_space environment.implicit_infer_kind) name) : @totally_separated_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (topological_space.{0} environment.implicit_infer_kind) name h0)  := sorry --non-trivial
lemma new_lemma_137768 (h0 : functor.add_const (group (has_nndist environment.implicit_infer_kind)) pos) : @is_simple_group.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_137769 (h0 : functor.add_const (ring (has_Sup empty)) empty) : @strong_rank_condition.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (has_Sup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_137770 (h1 : has_mem.mem linarith.comp_source has_emptyc.emptyc) : @path_connected_space.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type topological_space.{0} linarith.comp_source h1)  := sorry --non-trivial
lemma new_lemma_137771 (h0 : ring (add_cancel_comm_monoid (has_nnnorm (has_nnnorm (has_nnnorm char))))) : is_domain (add_cancel_comm_monoid (has_nnnorm (has_nnnorm (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_137772 (h0 : topological_space (has_inner (option unsigned) num)) : t0_space (has_inner (option unsigned) num) := sorry --non-trivial
lemma new_lemma_137773 (h0 : functor.add_const (topological_space (normed_comm_ring environment.implicit_infer_kind)) name) : @t0_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_137774 (h1 : topological_space (random_gen congr_arg_kind)) : irreducible_space (random_gen congr_arg_kind) := sorry --non-trivial
lemma new_lemma_137775 (h0 : functor.add_const (topological_space (generalized_boolean_algebra name)) linarith.comp) : @preirreducible_space.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_137776 (h0 : functor.add_const (function.extfun Type uniform_space) empty) : @separated_space.{0} (as_linear_order.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) empty h0) (as_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_137777 (h0 : group (ordered_comm_monoid (finset linarith.comp))) : group.fg (ordered_comm_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_137778 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_137779 (h0 : topological_space (measurable_space (semiring (semiring num)))) : totally_disconnected_space (measurable_space (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_137780 (h0 : semiring (boolean_algebra (finset (finset (finset (finset linarith.comp)))))) : is_noetherian_ring (boolean_algebra (finset (finset (finset (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_137781 (h0 : functor.add_const (function.extfun (Type 1) filter) linarith.comp) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (semigroup Type)) := sorry --non-trivial
lemma new_lemma_137782 (h0 : topological_space (add_group num)) : t0_space (add_group num) := sorry --non-trivial
lemma new_lemma_137783 (h0 : list (has_pos_part (has_pos_part (has_add linarith.comp)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_137784 (h0 : ordered_comm_monoid (has_Inf (finset (has_add pos)))) : has_exists_mul_of_le (has_Inf (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_137785 (h2 : topological_space (has_inf linarith.ineq)) : topological_space.first_countable_topology (has_inf linarith.ineq) := sorry --non-trivial
lemma new_lemma_137786 (h0 : topological_space (distrib (simple_graph environment.projection_info))) : totally_disconnected_space (distrib (simple_graph environment.projection_info)) := sorry --non-trivial
lemma new_lemma_137787 (h0 : topological_space (finset (fintype (has_add environment.implicit_infer_kind)))) : topological_space.separable_space (finset (fintype (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_137788 (h0 : functor.add_const (monoid (semigroup unsigned)) (has_to_string Type)) : @monoid.fg.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 1} (monoid.{0} (semigroup.{0} unsigned)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_137789 (h1 : has_neg (nondiscrete_normed_field (mul_one_class string.iterator_imp))) (h2 : measurable_space (nondiscrete_normed_field (mul_one_class string.iterator_imp))) : has_measurable_neg (nondiscrete_normed_field (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_137790 (h0 : functor.add_const (ring (semigroup linarith.comp)) Type) : @strong_rank_condition.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (semigroup.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_137791 (h1 : topological_space (uniform_space (mul_one_class linarith.comp_source))) : t0_space (uniform_space (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_137792 (h0 : topological_space (distrib linarith.ineq)) (h1 : preorder (distrib linarith.ineq)) : order_topology (distrib linarith.ineq) := sorry --non-trivial
lemma new_lemma_137793 (h0 : complete_lattice (denumerable (semi_normed_ring char))) : is_compactly_generated (denumerable (semi_normed_ring char)) := sorry --non-trivial
lemma new_lemma_137794 (h0 : group (sub_neg_monoid (finset (finset Type)))) : normalizer_condition (sub_neg_monoid (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_137795 (h0 : complete_lattice (has_norm (semiring (semiring (has_norm (has_norm empty)))))) : complete_lattice.is_Sup_finite_compact (has_norm (semiring (semiring (has_norm (has_norm empty))))) := sorry --non-trivial
lemma new_lemma_137796 (h0 : functor.add_const (topological_space (has_zero name)) name) : @normal_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_137797 (h0 : has_mem.mem (measurable_space empty) has_emptyc.emptyc) : @is_domain.{0} (measurable_space.{0} empty) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_137798 (h0 : functor.add_const (functor.add_const (functor.add_const Prop environment.implicit_infer_kind) name) (has_add pos)) : functor.add_const.run (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_137799 (h0 : group (has_neg (has_pos_part (has_pos_part linarith.comp)))) : is_cyclic (has_neg (has_pos_part (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_137800 (h0 : ring (distrib (mul_one_class (uniform_space enat)))) : rank_condition (distrib (mul_one_class (uniform_space enat))) := sorry --non-trivial
lemma new_lemma_137801 (h0 : function.extfun (set Type) (fun (x : set Type), Prop)) : is_countably_spanning (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_137802 (h0 : function.extfun Type group) : @group.fg.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_137803 (h0 : complete_lattice (mul_zero_class (finset (has_neg unsigned)))) : complete_lattice.is_Sup_finite_compact (mul_zero_class (finset (has_neg unsigned))) := sorry --non-trivial
lemma new_lemma_137804 (h0 : functor.add_const (cancel_comm_monoid_with_zero (normed_comm_ring Type)) Type) : @unique_factorization_monoid.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (cancel_comm_monoid_with_zero.{1} (normed_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_137805 (h0 : functor.add_const (topological_space (has_star empty)) empty) : @t0_space.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_137806 (h0 : semiring (normed_lattice_add_comm_group name)) : is_noetherian_ring (normed_lattice_add_comm_group name) := sorry --non-trivial
lemma new_lemma_137807 (h0 : list (add_comm_monoid (has_to_string (ring Type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_137808 (h0 : functor.add_const (topological_space (ordered_comm_monoid Type)) Type) : @totally_disconnected_space.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_137809 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_137810 (h0 : group (add_cancel_monoid name)) : group.fg (add_cancel_monoid name) := sorry --non-trivial
lemma new_lemma_137811 (h0 : complete_lattice (has_div (cancel_monoid (has_compl (has_nnnorm linarith.comp_source))))) : is_compactly_generated (has_div (cancel_monoid (has_compl (has_nnnorm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_137812 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_137813 (h0 : topological_space (ordered_comm_ring (has_add (has_add real)))) : normal_space (ordered_comm_ring (has_add (has_add real))) := sorry --non-trivial
lemma new_lemma_137814 (h0 : topological_space (has_add linarith.comp)) : t1_space (has_add linarith.comp) := sorry --non-trivial
lemma new_lemma_137815 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_137816 (h0 : functor.comp topological_space add_cancel_monoid Type) : @totally_separated_space.{1} (add_cancel_monoid.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} add_cancel_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_137817 (h0 : topological_space (has_emptyc (random_gen (random_gen linarith.comp_source)))) : totally_disconnected_space (has_emptyc (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_137818 (h0 : ring (normed_comm_ring environment.implicit_infer_kind)) : rank_condition (normed_comm_ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_137819 (h2 : uniform_space (mul_one_class linarith.ineq)) : complete_space (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_137820 (h0 : functor.add_const (topological_space (cancel_monoid unsigned)) pos) : @sequential_space.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_137821 (h0 : topological_space (measure_theory.measure_space (left_cancel_monoid empty))) : loc_path_connected_space (measure_theory.measure_space (left_cancel_monoid empty)) := sorry --non-trivial
lemma new_lemma_137822 (h0 : functor.add_const Prop (ordered_comm_ring (has_add (has_neg (has_neg linarith.comp))))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_137823 (h0 : ordered_comm_monoid (ring (has_to_string Type))) : has_exists_mul_of_le (ring (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_137824 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_Sup congr_arg_kind)) empty) : @unique_factorization_monoid.{0} (has_Sup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_Sup.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_137825 (h0 : function.extfun Type group) : @group.fg.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_137826 (h0 : filter (has_neg (finset linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_137827 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) linarith.comp) : @topological_space.separable_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_137828 (h0 : has_mem.mem (measurable_space (has_top fun_info)) has_emptyc.emptyc) : @irreducible_space.{0} (measurable_space.{0} (has_top.{0} fun_info)) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} (has_top.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_137829 (h1 h2 : multiset linarith.ineq) : multiset.le h1 h2 := sorry --non-trivial
lemma new_lemma_137830 (h0 : functor.add_const (group (normed_comm_ring unsigned)) name) : @is_simple_group.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_137831 (h0 : functor.add_const (complete_lattice (ordered_comm_ring linarith.comp)) linarith.comp) : @is_compactly_generated.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_137832 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (linear_ordered_comm_group num)) := sorry --non-trivial
lemma new_lemma_137833 (h0 : topological_space (pseudo_metric_space (option empty))) : topological_space.separable_space (pseudo_metric_space (option empty)) := sorry --non-trivial
lemma new_lemma_137834 (h0 : ring (has_bot real)) : strong_rank_condition (has_bot real) := sorry --non-trivial
lemma new_lemma_137835 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm num))) : @complete_space.{0} (has_norm.{0} num) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_norm.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_137836 (h0 : function.extfun nat fin) : @totally_separated_space.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_137837 (h0 : functor.add_const (topological_space (complete_distrib_lattice environment.implicit_infer_kind)) linarith.comp) : @locally_compact_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_137838 (h0 : list (boolean_algebra (has_pos_part (semigroup (has_Inf (has_add linarith.comp)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_137839 (h0 : list (measurable_space.dynkin_system (semiring (semiring unsigned)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_137840 (h0 : functor.add_const (add_monoid (semigroup linarith.comp)) Type) : @add_monoid.fg.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_monoid.{0} (semigroup.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_137841 (h0 : semiring (finset (option pos))) : is_noetherian_ring (finset (option pos)) := sorry --non-trivial
lemma new_lemma_137842 (h0 : functor.add_const (topological_space (ring linarith.comp)) Type) : @discrete_topology.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_137843 (h0 : functor.add_const (complete_lattice (has_to_string linarith.comp)) Type) : @is_compactly_generated.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_to_string.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_137844 (h0 : not (monoid (measure_theory.measure_space empty) -> false)) : @monoid.fg.{0} (measure_theory.measure_space.{0} empty) (@classical.by_contradiction'.{1} (monoid.{0} (measure_theory.measure_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_137845 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (canonically_ordered_comm_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_137846 (h0 : topological_space (has_to_string (boolean_algebra (uniform_space Type)))) : totally_separated_space (has_to_string (boolean_algebra (uniform_space Type))) := sorry --non-trivial
lemma new_lemma_137847 (h0 : semiring (complete_distrib_lattice congr_arg_kind)) : is_noetherian_ring (complete_distrib_lattice congr_arg_kind) := sorry --non-trivial
lemma new_lemma_137848 (h0 : comm_ring (semi_normed_ring linarith.comp_source)) (h1 : polynomial (semi_normed_ring linarith.comp_source)) (h2 : set (non_unital_non_assoc_semiring (mul_one_class (adjoin_root h1)))) : set.finite h2 := sorry --non-trivial
lemma new_lemma_137849 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (free_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (free_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_137850 (h0 : topological_space (has_nndist (finset (finset linarith.comp)))) : locally_compact_space (has_nndist (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_137851 (h0 : group (dlist (random_gen (has_nnnorm (random_gen to_additive.value_type))))) : is_cyclic (dlist (random_gen (has_nnnorm (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_137852 (h0 : not (ring (normed_field fun_info) -> false)) : @rank_condition.{0} (normed_field.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (normed_field.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_137853 (h0 : topological_space (boolean_algebra pos)) : loc_path_connected_space (boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_137854 (h0 : topological_space (has_nndist (has_neg_part unsigned))) : irreducible_space (has_nndist (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_137855 (h0 : topological_space (normed_comm_ring linarith.comp)) : totally_separated_space (normed_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_137856 (h0 : uniform_space (add_left_cancel_monoid (linear_ordered_add_comm_group linarith.ineq))) : complete_space (add_left_cancel_monoid (linear_ordered_add_comm_group linarith.ineq)) := sorry --non-trivial
lemma new_lemma_137857 (h0 : topological_space (ordered_comm_monoid (has_bot name))) : totally_disconnected_space (ordered_comm_monoid (has_bot name)) := sorry --non-trivial
lemma new_lemma_137858 (h0 : complete_lattice (semigroup (has_zero Type))) : is_compactly_generated (semigroup (has_zero Type)) := sorry --non-trivial
lemma new_lemma_137859 (h0 : topological_space (has_pos_part pos)) : t0_space (has_pos_part pos) := sorry --non-trivial
lemma new_lemma_137860 (h0 : ring (has_nndist (has_add pos))) : strong_rank_condition (has_nndist (has_add pos)) := sorry --non-trivial
lemma new_lemma_137861 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} linarith.comp_source (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_137862 (h0 : group (normed_comm_ring Type)) : group.fg (normed_comm_ring Type) := sorry --non-trivial
lemma new_lemma_137863 (h0 : functor.add_const (group (has_nndist linarith.comp)) Type) : @is_cyclic.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (has_nndist.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_137864 (h1 : function.extfun (finset Type) (has_mem.mem linarith.comp)) : @monoid.fg.{0} linarith.comp (@finset.pi.empty.{1 0} Type monoid.{0} linarith.comp (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp) h1 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_137865 (h1 : topological_space (add_comm_semigroup enat)) : totally_disconnected_space (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_137866 (h0 : not (topological_space (normed_group (has_norm congr_arg_kind)) -> false)) : @locally_compact_space.{0} (normed_group.{0} (has_norm.{0} congr_arg_kind)) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} (has_norm.{0} congr_arg_kind))) h0)  := sorry --non-trivial
lemma new_lemma_137867 (h0 : semiring (complete_distrib_lattice ennreal)) : is_noetherian_ring (complete_distrib_lattice ennreal) := sorry --non-trivial
lemma new_lemma_137868 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_edist.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_edist.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_137869 (h0 : complete_lattice (non_assoc_semiring (semiring congr_arg_kind))) : is_compactly_generated (non_assoc_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_137870 (h0 : not (complete_lattice (uniform_space (mul_one_class char)) -> false)) : is_compactly_generated (uniform_space (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_137871 (h0 : uniform_space (has_pos_part (has_add (has_pos_part name)))) : separated_space (has_pos_part (has_add (has_pos_part name))) := sorry --non-trivial
lemma new_lemma_137872 (h0 : filter (has_top (has_norm to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_137873 (h0 : functor.add_const (topological_space (has_zero ennreal)) unsigned) : @totally_disconnected_space.{0} (has_zero.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_137874 (h0 : not (add_group (normed_field char) -> false)) : @is_add_cyclic.{0} (normed_field.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (normed_field.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_137875 (h0 : functor.add_const (topological_space (has_Inf name)) name) : @sequential_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_137876 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_137877 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg_part.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_137878 (h0 : group (linear_ordered_add_comm_group (has_ssubset linarith.ineq))) : group.fg (linear_ordered_add_comm_group (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_137879 (h0 : set (set enat)) (h1 : set enat) : measurable_space.dynkin_system.generate_has h0 h1 := sorry --non-trivial
lemma new_lemma_137880 (h3 : pseudo_metric_space (has_append char)) (h4 : monoid (has_append char)) : has_lipschitz_mul (has_append char) := sorry --non-trivial
lemma new_lemma_137881 (h0 : uniform_space (random_gen (random_gen (random_gen (random_gen (random_gen linarith.ineq)))))) : complete_space (random_gen (random_gen (random_gen (random_gen (random_gen linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_137882 (h0 : topological_space (sub_neg_monoid (has_Inf pos))) : normal_space (sub_neg_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_137883 (h0 : function.extfun (semiring (semiring num)) (fun (x : semiring (semiring num)), Prop)) : zzz_forall (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_137884 (h0 : add_monoid (plift (semiring (semiring (semiring (semiring empty)))))) : add_monoid.fg (plift (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_137885 (h0 : complete_lattice (with_bot (has_top (has_inv linarith.ineq)))) : is_compactly_generated (with_bot (has_top (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_137886 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) name) : @path_connected_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_137887 (h0 : ring (has_union (has_norm num))) : strong_rank_condition (has_union (has_norm num)) := sorry --non-trivial
lemma new_lemma_137888 (h0 : functor.add_const (complete_lattice (boolean_algebra pos)) pos) : @is_compactly_generated.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_137889 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_137890 (h0 : list (pseudo_metric_space (option pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_137891 (h0 : complete_lattice (has_top (random_gen char))) : complete_lattice.is_Sup_finite_compact (has_top (random_gen char)) := sorry --non-trivial
lemma new_lemma_137892 (h0 : functor.add_const (uniform_space (has_Inf linarith.comp)) (has_pos_part pos)) : @complete_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_Inf.{0} linarith.comp)) (has_pos_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_137893 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} h0 (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_137894 (h0 : ring (linear_order empty)) : is_domain (linear_order empty) := sorry --non-trivial
lemma new_lemma_137895 (h0 : topological_space (has_to_string (has_pos_part (has_pos_part environment.implicit_infer_kind)))) : regular_space (has_to_string (has_pos_part (has_pos_part environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_137896 (h1 h2 : list string.iterator_imp) : list.subset h1 h2 := sorry --non-trivial
lemma new_lemma_137897 (h0 : not (ring (has_div (mul_one_class reducibility_hints)) -> false)) : @is_domain.{0} (has_div.{0} (mul_one_class.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (ring.{0} (has_div.{0} (mul_one_class.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_137898 (h0 : functor.add_const (ring (has_star congr_arg_kind)) unsigned) : @strong_rank_condition.{0} (has_star.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_star.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_137899 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_137900 (h0 : topological_space (has_bot (sub_neg_monoid (sub_neg_monoid real)))) : normal_space (has_bot (sub_neg_monoid (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_137901 (h0 : uniform_space (semi_normed_comm_ring (mul_one_class string_imp))) : complete_space (semi_normed_comm_ring (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_137902 (h0 : topological_space (boolean_algebra (has_pos_part (boolean_algebra.core (finset pos))))) : locally_compact_space (boolean_algebra (has_pos_part (boolean_algebra.core (finset pos)))) := sorry --non-trivial
lemma new_lemma_137903 (h0 : topological_space (has_add (finset Type))) : discrete_topology (has_add (finset Type)) := sorry --non-trivial
lemma new_lemma_137904 (h0 : functor.add_const (ring (plift empty)) num) : @is_principal_ideal_ring.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (ring.{1} (plift.{1} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_137905 (h0 : filter (distrib_lattice (random_gen linarith.comp_source))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_137906 (h0 : semiring (normed_comm_ring (option (option (option (option ennreal)))))) : is_noetherian_ring (normed_comm_ring (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_137907 (h1 : topological_space (id linarith.comp)) : totally_disconnected_space (id linarith.comp) := sorry --non-trivial
lemma new_lemma_137908 (h0 : functor.add_const (topological_space (boolean_algebra.core linarith.comp)) linarith.comp) : @loc_path_connected_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_137909 (h0 : filter (has_Inf (has_add (finset linarith.comp)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_137910 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_137911 (h0 : function.extfun Type topological_space) : @t0_space.{0} subsingleton_info (@function.extfun_app.{2 1} Type topological_space.{0} h0 subsingleton_info)  := sorry --non-trivial
lemma new_lemma_137912 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_137913 (h0 : topological_space (has_pos_part (ring pos))) : totally_separated_space (has_pos_part (ring pos)) := sorry --non-trivial
lemma new_lemma_137914 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_137915 (h0 : topological_space (plift (option num))) : totally_separated_space (plift (option num)) := sorry --non-trivial
lemma new_lemma_137916 (h0 : group (has_add (ring Type))) : group.fg (has_add (ring Type)) := sorry --non-trivial
lemma new_lemma_137917 (h0 : topological_space (ordered_comm_group unsigned)) : irreducible_space (ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_137918 (h0 : add_monoid (has_nndist (option (option empty)))) : add_monoid.fg (has_nndist (option (option empty))) := sorry --non-trivial
lemma new_lemma_137919 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_137920 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_137921 (h0 : functor.add_const (topological_space (finset pos)) Type) : @irreducible_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_137922 (h0 : topological_space (semigroup (has_add name))) : totally_disconnected_space (semigroup (has_add name)) := sorry --non-trivial
lemma new_lemma_137923 (h0 : topological_space (linear_ordered_semiring unsigned)) : path_connected_space (linear_ordered_semiring unsigned) := sorry --non-trivial
lemma new_lemma_137924 (h0 : group (partial_order (semiring (semiring empty)))) : is_cyclic (partial_order (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_137925 (h0 : ring (linear_ordered_semiring (has_norm (has_norm (random_gen fun_info))))) : rank_condition (linear_ordered_semiring (has_norm (has_norm (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_137926 (h0 : function.extfun Type (functor.comp complete_lattice comm_group)) : @is_atomistic.{0} (comm_group.{0} (option.{0} name)) (@functor.comp.run.{0 0 0} complete_lattice.{0} comm_group.{0} (option.{0} name) (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} complete_lattice.{0} comm_group.{0}) h0 (option.{0} name)))  := sorry --non-trivial
lemma new_lemma_137927 (h0 : set (non_unital_non_assoc_semiring (mul_one_class linarith.ineq))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_137928 (h0 : group (semigroup (has_Inf Type))) : is_cyclic (semigroup (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_137929 (h0 : ordered_comm_monoid (has_neg_part (option (option (option (option unsigned)))))) : has_exists_mul_of_le (has_neg_part (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_137930 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_137931 (h0 : topological_space (has_add (finset (has_nndist (has_nndist pos))))) : path_connected_space (has_add (finset (has_nndist (has_nndist pos)))) := sorry --non-trivial
lemma new_lemma_137932 (h0 : functor.add_const (ring (has_nndist environment.implicit_infer_kind)) (finset (finset pos))) : @rank_condition.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} environment.implicit_infer_kind)) (finset.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_137933 (h0 : not (uniform_space (distrib to_additive.value_type) -> false)) : @complete_space.{0} (distrib.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (uniform_space.{0} (distrib.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_137934 (h0 : filter (has_zero ennreal)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_137935 (h0 : topological_space (comm_ring fun_info)) : locally_compact_space (comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_137936 (h0 : ring (dlist (has_ssubset to_additive.value_type))) : is_domain (dlist (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_137937 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_137938 (h0 : uniform_space (measure_theory.measure_space unsigned)) : complete_space (measure_theory.measure_space unsigned) := sorry --non-trivial
lemma new_lemma_137939 (h0 : add_group (add_comm_semigroup (mul_one_class (normed_field char)))) : is_add_cyclic (add_comm_semigroup (mul_one_class (normed_field char))) := sorry --non-trivial
lemma new_lemma_137940 (h0 : functor.add_const Prop (comm_group environment.implicit_infer_kind)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_137941 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_137942 (h2 : not (ring (linear_ordered_add_comm_group to_additive.value_type) -> false)) : @strong_rank_condition.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type)) h2)  := sorry --non-trivial
lemma new_lemma_137943 (h0 : functor.add_const (ring (linear_ordered_field ennreal)) ennreal) : @is_domain.{0} (linear_ordered_field.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (linear_ordered_field.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_137944 (h1 h2 : multiset (has_ssubset linarith.ineq)) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_137945 (h0 : ring (linear_ordered_comm_group_with_zero (mul_one_class fun_info))) : strong_rank_condition (linear_ordered_comm_group_with_zero (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_137946 (h0 : topological_space (linear_ordered_comm_group (option ennreal))) : loc_path_connected_space (linear_ordered_comm_group (option ennreal)) := sorry --non-trivial
lemma new_lemma_137947 (h0 : add_group (add_cancel_monoid (division_ring string_imp))) : is_add_cyclic (add_cancel_monoid (division_ring string_imp)) := sorry --non-trivial
lemma new_lemma_137948 (h0 : functor.add_const (functor.add_const (topological_space nnreal) empty) (option empty)) : topological_space.separable_space nnreal := sorry --non-trivial
lemma new_lemma_137949 (h0 : ordered_add_comm_monoid (comm_semigroup (has_add real))) : archimedean (comm_semigroup (has_add real)) := sorry --non-trivial
lemma new_lemma_137950 (h0 : topological_space (has_neg_part (add_comm_monoid (has_nndist environment.implicit_infer_kind)))) : t1_space (has_neg_part (add_comm_monoid (has_nndist environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_137951 (h0 : complete_lattice (normed_linear_ordered_group num)) : is_compactly_generated (normed_linear_ordered_group num) := sorry --non-trivial
lemma new_lemma_137952 (h0 : measurable_space (add_group linarith.comp)) (h1 : not (filter (add_group linarith.comp) -> false)) : filter.is_measurably_generated (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_137953 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_137954 (h0 : not (ring (complete_semilattice_Sup unsigned) -> false)) : @is_domain.{0} (complete_semilattice_Sup.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (complete_semilattice_Sup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_137955 (h1 : group congr_arg_kind) : is_cyclic congr_arg_kind := sorry --non-trivial
lemma new_lemma_137956 (h0 : complete_lattice (semiring (random_gen fun_info))) : is_atomistic (semiring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_137957 (h0 : fin has_zero.zero) : @preconnected_space.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_137958 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_137959 (h0 : functor.add_const (filter (boolean_algebra name)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_137960 (h0 : not (ring (with_zero linarith.ineq) -> false)) : @is_domain.{0} (with_zero.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (with_zero.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_137961 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) unsigned) : @topological_space.separable_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_137962 (h3 : ring congr_arg_kind) : is_domain congr_arg_kind := sorry --non-trivial
lemma new_lemma_137963 (h0 : uniform_space (sub_neg_monoid linarith.comp)) : separated_space (sub_neg_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_137964 (h3 : uniform_space (mul_one_class (add_comm_semigroup string.iterator_imp))) : complete_space (mul_one_class (add_comm_semigroup string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_137965 (h0 : cancel_comm_monoid_with_zero (generalized_boolean_algebra linarith.comp)) : unique_factorization_monoid (generalized_boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_137966 (h0 : complete_lattice (has_norm (has_norm empty))) : complete_lattice.is_Sup_finite_compact (has_norm (has_norm empty)) := sorry --non-trivial
lemma new_lemma_137967 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_137968 (h2 : complete_lattice (has_div string_imp)) : is_compactly_generated (has_div string_imp) := sorry --non-trivial
lemma new_lemma_137969 (h0 : function.extfun Type group) : @group.fg.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_137970 (h0 : group (bin_tree (semiring (semiring congr_arg_kind)))) : group.fg (bin_tree (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_137971 (h0 : set (prod (has_neg Type) (has_neg Type))) (h1 : prod (has_neg Type) (has_neg Type)) : symmetrize_rel h0 h1 := sorry --non-trivial
lemma new_lemma_137972 (h0 : topological_space (boolean_algebra (has_Inf (has_Inf (has_Inf linarith.comp))))) : regular_space (boolean_algebra (has_Inf (has_Inf (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_137973 (h0 : ring (with_one (semiring congr_arg_kind))) : strong_rank_condition (with_one (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_137974 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) name) : @has_exists_mul_of_le.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) name h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_137975 (h0 : list (option (option (option pos)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_137976 (h0 : topological_space (has_dist congr_arg_kind)) : irreducible_space (has_dist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_137977 (h0 : functor.add_const (ordered_add_comm_monoid pos) Type) : @archimedean.{0} pos (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} pos) Type h0)  := sorry --non-trivial
lemma new_lemma_137978 (h0 : functor.add_const (complete_lattice (mul_zero_class pos)) pos) : @is_compactly_generated.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (mul_zero_class.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_137979 (h0 : complete_lattice (canonically_ordered_comm_semiring name)) : is_atomistic (canonically_ordered_comm_semiring name) := sorry --non-trivial
lemma new_lemma_137980 (h0 : functor.add_const (topological_space (semigroup pos)) linarith.comp) : @irreducible_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_137981 (h0 : semiring (as_linear_order unsigned)) : is_noetherian_ring (as_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_137982 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_neg.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_neg.{0} num))  := sorry --non-trivial
lemma new_lemma_137983 (h0 : topological_space (has_nnnorm (mul_one_class (mul_one_class linarith.ineq)))) (h1 : preorder (has_nnnorm (mul_one_class (mul_one_class linarith.ineq)))) : order_closed_topology (has_nnnorm (mul_one_class (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_137984 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (finset Type)) : @t0_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) (finset.{1} Type) h0) Type)  := sorry --non-trivial
lemma new_lemma_137985 (h0 : add_group (partial_order (semiring empty))) (h1 : add_subgroup (partial_order (semiring empty))) : add_subgroup.is_commutative h1 := sorry --non-trivial
lemma new_lemma_137986 (h0 : functor.add_const (topological_space (boolean_algebra.core environment.implicit_infer_kind)) name) : @sequential_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_137987 (h0 : functor.comp complete_lattice comm_group (option name)) : @is_atomistic.{0} (comm_group.{0} (option.{0} name)) (@functor.comp.run.{0 0 0} complete_lattice.{0} comm_group.{0} (option.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_137988 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_137989 (h0 : functor.add_const (complete_lattice (ring Type)) (has_neg Type)) : @is_compactly_generated.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (ring.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_137990 (h0 : function.extfun (finset Type) (has_mem.mem (metric_space unsigned))) : @normalizer_condition.{0} (metric_space.{0} unsigned) (@finset.pi.empty.{1 0} Type group.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (metric_space.{0} unsigned)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_137991 (h0 : complete_lattice (distrib_lattice (random_gen fun_info))) : complete_lattice.is_Sup_finite_compact (distrib_lattice (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_137992 (h0 : topological_space (with_one empty)) : preirreducible_space (with_one empty) := sorry --non-trivial
lemma new_lemma_137993 (h2 : has_le linarith.comp_source) (h3 : not (bounded_order linarith.comp_source -> false)) : @is_simple_order.{0} linarith.comp_source h2 (@classical.by_contradiction'.{1} (@bounded_order.{0} linarith.comp_source h2) h3)  := sorry --non-trivial
lemma new_lemma_137994 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (semi_normed_ring.{0} string.iterator_imp) (@function.extfun_app.{2 1} Type ring.{0} h0 (semi_normed_ring.{0} string.iterator_imp))  := sorry --non-trivial
lemma new_lemma_137995 (h0 : function.extfun (((Type -> Type) -> Type 1) -> Type 1) (function.extfun ((Type -> Type) -> Type 1))) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (@function.extfun_app.{3 3} (((Type → Type) → Type 1) → Type 1) (function.extfun.{3 2} ((Type → Type) → Type 1)) h0 (function.extfun.{2 2} (Type → Type))) (function.extfun.{2 1} Type)) complete_lattice.{0}) (with_one.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_137996 (h0 : ring (add_left_cancel_monoid (random_gen fun_info))) : rank_condition (add_left_cancel_monoid (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_137997 (h0 : complete_lattice (generalized_boolean_algebra linarith.comp)) : is_compactly_generated (generalized_boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_137998 (h0 : has_mem.mem (has_emptyc to_additive.value_type) has_emptyc.emptyc) : @path_connected_space.{0} (has_emptyc.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_137999 (h0 : topological_space (fintype (random_gen string_imp))) : t0_space (fintype (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_138000 (h0 : topological_space (semigroup pos)) : t0_space (semigroup pos) := sorry --non-trivial
lemma new_lemma_138001 (h0 : has_mem.mem (complete_semilattice_Sup congr_arg_kind) has_emptyc.emptyc) : @monoid.fg.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type monoid.{0} (complete_semilattice_Sup.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_138002 (h1 : not (ring (linear_ordered_comm_group_with_zero string_imp) -> false)) : @rank_condition.{0} (linear_ordered_comm_group_with_zero.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_comm_group_with_zero.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_138003 (h0 : complete_lattice (comm_semigroup (has_add real))) : is_atomistic (comm_semigroup (has_add real)) := sorry --non-trivial
lemma new_lemma_138004 (h0 : functor.add_const (ring (finset environment.implicit_infer_kind)) Type) : @is_principal_ideal_ring.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ring.{0} (finset.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_138005 (h0 : functor.add_const (complete_lattice (filter unsigned)) congr_arg_kind) : is_compactly_generated (filter unsigned) := sorry --non-trivial
lemma new_lemma_138006 (h0 : group (normed_lattice_add_comm_group name)) : normalizer_condition (normed_lattice_add_comm_group name) := sorry --non-trivial
lemma new_lemma_138007 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_Inf name)) := sorry --non-trivial
lemma new_lemma_138008 (h0 : complete_lattice (complete_distrib_lattice (boolean_algebra linarith.comp))) : is_compactly_generated (complete_distrib_lattice (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_138009 (h0 : not (topological_space (has_star unsigned) -> false)) : @totally_disconnected_space.{0} (has_star.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_star.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_138010 (h0 : group (complete_distrib_lattice name)) : is_simple_group (complete_distrib_lattice name) := sorry --non-trivial
lemma new_lemma_138011 (h0 : topological_space (normed_comm_ring (option ennreal))) : locally_compact_space (normed_comm_ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_138012 (h0 : group (semiring (has_norm (has_norm linarith.comp_source)))) : is_cyclic (semiring (has_norm (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_138013 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_138014 (h0 : functor.add_const (add_group (generalized_boolean_algebra linarith.comp)) (has_neg (has_add name))) : @is_add_cyclic.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (generalized_boolean_algebra.{0} linarith.comp)) (has_neg.{0} (has_add.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_138015 (h0 : function.extfun Type topological_space) : @t0_space.{0} (@id.{2} Type linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_138016 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) (semigroup linarith.comp)) : @totally_disconnected_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) (semigroup.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_138017 (h0 : topological_space (ordered_comm_monoid name)) : totally_separated_space (ordered_comm_monoid name) := sorry --non-trivial
lemma new_lemma_138018 (h0 : semiring (canonically_ordered_comm_semiring Type)) : is_noetherian_ring (canonically_ordered_comm_semiring Type) := sorry --non-trivial
lemma new_lemma_138019 (h0 : semiring (has_bot (has_bot empty))) : is_noetherian_ring (has_bot (has_bot empty)) := sorry --non-trivial
lemma new_lemma_138020 (h0 : list (boolean_algebra (has_pos_part (finset (ring Type))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_138021 (h0 : add_monoid (cancel_monoid (has_add environment.implicit_infer_kind))) : add_monoid.fg (cancel_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_138022 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @path_connected_space.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (linear_ordered_add_comm_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_138023 (h0 : ring (boolean_algebra pos)) : strong_rank_condition (boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_138024 (h0 : functor.add_const (function.extfun Type finset) (has_Inf (has_pos_part (has_pos_part linarith.comp)))) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (generalized_boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_138025 (h0 : functor.add_const (function.extfun Type ring) (ring Type)) : @rank_condition.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) (ring.{1} Type) h0) (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_138026 (h0 : topological_space (measurable_space fun_info)) : locally_compact_space (measurable_space fun_info) := sorry --non-trivial
lemma new_lemma_138027 (h0 : finset (complete_linear_order (semiring (semiring (semiring empty))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_138028 (h0 : ring (has_append (has_nnnorm string.iterator_imp))) : is_domain (has_append (has_nnnorm string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_138029 (h0 : complete_lattice (measurable_space.dynkin_system empty)) : complete_lattice.is_Sup_finite_compact (measurable_space.dynkin_system empty) := sorry --non-trivial
lemma new_lemma_138030 (h1 : topological_space ereal) (h2 : set (set ereal)) : topological_space.is_topological_basis h2 := sorry --non-trivial
lemma new_lemma_138031 (h1 : topological_space (random_gen (ordered_cancel_comm_monoid (uniform_space char)))) : t0_space (random_gen (ordered_cancel_comm_monoid (uniform_space char))) := sorry --non-trivial
lemma new_lemma_138032 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) pos) : @has_exists_mul_of_le.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) pos h0) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_138033 (h0 : cancel_comm_monoid_with_zero (ordered_cancel_add_comm_monoid ennreal)) : unique_factorization_monoid (ordered_cancel_add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_138034 (h0 : finset Prop) (h1 : finset.nonempty (id h0)) : @finset.max'.{0} Prop Prop.linear_order (@id.{1} (finset.{0} Prop) h0) h1  := sorry --non-trivial
lemma new_lemma_138035 (h0 : functor.add_const (functor.comp topological_space has_nndist unsigned) unsigned) : @totally_disconnected_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} unsigned)) unsigned (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} unsigned (@functor.add_const.run.{0 0} (functor.comp.{0 0 0} topological_space.{0} has_nndist.{0} unsigned) unsigned h0)))  := sorry --non-trivial
lemma new_lemma_138036 (h0 : ring (ring (has_neg_part linarith.comp))) : rank_condition (ring (has_neg_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_138037 (h0 : cancel_comm_monoid_with_zero (cancel_monoid (has_add (cancel_monoid (cancel_monoid unsigned))))) : unique_factorization_monoid (cancel_monoid (has_add (cancel_monoid (cancel_monoid unsigned)))) := sorry --non-trivial
lemma new_lemma_138038 (h0 : functor.add_const (uniform_space (boolean_algebra.core pos)) linarith.comp) : @separated_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.core.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_138039 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_138040 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (pseudo_metric_space.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (pseudo_metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_138041 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) linarith.comp) : @topological_space.separable_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_138042 (h0 : ordered_add_comm_monoid (add_cancel_monoid (option (option empty)))) : archimedean (add_cancel_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_138043 (h0 : group (with_bot congr_arg_kind)) : group.fg (with_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_138044 (h0 : set (linear_ordered_comm_group_with_zero (mul_one_class enat))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_138045 (h0 : complete_lattice (normed_group (random_gen (has_ssubset fun_info)))) : is_compactly_generated (normed_group (random_gen (has_ssubset fun_info))) := sorry --non-trivial
lemma new_lemma_138046 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_138047 (h0 : ring (distrib (has_ssubset char))) : is_domain (distrib (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_138048 (h0 : add_group (sub_neg_monoid (has_Inf pos))) : is_add_cyclic (sub_neg_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_138049 (h0 : complete_lattice (has_emptyc (has_norm empty))) : is_compactly_generated (has_emptyc (has_norm empty)) := sorry --non-trivial
lemma new_lemma_138050 (h0 : monoid (normed_comm_ring empty)) : monoid.fg (normed_comm_ring empty) := sorry --non-trivial
lemma new_lemma_138051 (h0 : functor.add_const (function.extfun (Type 1) ring) (finset pos)) : @rank_condition.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) (finset.{0} pos) h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_138052 (h0 : topological_space (comm_group (has_to_string (cancel_monoid pos)))) : regular_space (comm_group (has_to_string (cancel_monoid pos))) := sorry --non-trivial
lemma new_lemma_138053 (h0 : uniform_space (normed_field (denumerable char))) : complete_space (normed_field (denumerable char)) := sorry --non-trivial
lemma new_lemma_138054 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) linarith.comp) : @path_connected_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_138055 (h0 : functor.add_const (topological_space (has_edist unsigned)) unsigned) : @preirreducible_space.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_138056 (h0 : has_ssubset (has_ssubset char) -> has_ssubset (has_ssubset char) -> has_ssubset (has_ssubset char)) : is_idempotent (has_ssubset (has_ssubset char)) h0 := sorry --non-trivial
lemma new_lemma_138057 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (simple_graph pos)) := sorry --non-trivial
lemma new_lemma_138058 (h0 : functor.add_const Prop (has_to_string Type)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_138059 (h1 : filter (with_one to_additive.value_type)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_138060 (h0 : fin has_zero.zero) : @is_cyclic.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (group.{1} (ordered_comm_monoid.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_138061 (h0 : topological_space (has_dist congr_arg_kind)) : locally_compact_space (has_dist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_138062 (h0 : functor.add_const (topological_space (has_add ennreal)) ennreal) : @locally_compact_space.{0} (has_add.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_138063 (h0 : group (measurable_space (has_norm empty))) : is_cyclic (measurable_space (has_norm empty)) := sorry --non-trivial
lemma new_lemma_138064 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @preirreducible_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_138065 (h0 : functor.add_const (filter (boolean_algebra name)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_138066 (h0 : set (uniform_space fun_info -> linarith.ineq)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_138067 (h0 : ring (add_left_cancel_monoid (random_gen linarith.ineq))) : strong_rank_condition (add_left_cancel_monoid (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_138068 (h0 : function.extfun nat fin) : @is_compactly_generated.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (has_pos_part.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_138069 (h0 : ring (ordered_comm_semiring linarith.ineq)) : strong_rank_condition (ordered_comm_semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_138070 (h0 : ring (ordered_comm_group congr_arg_kind)) : strong_rank_condition (ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_138071 (h0 : ring (add_cancel_monoid (ring environment.implicit_infer_kind))) : rank_condition (add_cancel_monoid (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_138072 (h0 : list (pseudo_metric_space pos)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_138073 (h0 : topological_space (normed_group (has_top linarith.comp_source))) : totally_separated_space (normed_group (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_138074 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @t0_space.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_138075 (h0 : uniform_space (cancel_monoid (option pos))) : separated_space (cancel_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_138076 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (linear_ordered_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_138077 (h0 : group (has_norm (linear_ordered_add_comm_group fun_info))) : group.fg (has_norm (linear_ordered_add_comm_group fun_info)) := sorry --non-trivial
lemma new_lemma_138078 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_138079 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_inter.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_inter.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_138080 (h4 : set (normed_field environment.projection_info)) : set.finite h4 := sorry --non-trivial
lemma new_lemma_138081 (h0 : semiring (pseudo_metric_space (option num))) : is_noetherian_ring (pseudo_metric_space (option num)) := sorry --non-trivial
lemma new_lemma_138082 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_top.{0} (random_gen.{0} (has_norm.{0} (has_norm.{0} fun_info)))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} (random_gen.{0} (has_norm.{0} (has_norm.{0} fun_info)))))  := sorry --non-trivial
lemma new_lemma_138083 (h0 : group (has_scalar Type name)) : is_simple_group (has_scalar Type name) := sorry --non-trivial
lemma new_lemma_138084 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) (finset (finset linarith.comp))) : @irreducible_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) (finset.{0} (finset.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_138085 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_138086 (h0 : group (has_nnnorm (normed_field linarith.comp_source))) : is_cyclic (has_nnnorm (normed_field linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_138087 (h1 : ring (comm_ring (metric_space (random_gen (random_gen reducibility_hints))))) : is_domain (comm_ring (metric_space (random_gen (random_gen reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_138088 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_138089 (h0 : functor.add_const (ring (boolean_algebra linarith.comp)) pos) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_138090 (h0 : topological_space (add_comm_monoid (has_add pos))) : regular_space (add_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_138091 (h0 : ring (boolean_algebra.core (option unsigned))) : is_domain (boolean_algebra.core (option unsigned)) := sorry --non-trivial
lemma new_lemma_138092 (h0 : functor.add_const (ring (add_left_cancel_semigroup unsigned)) empty) : @is_domain.{0} (add_left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (add_left_cancel_semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_138093 (h0 : functor.add_const (topological_space (ring (has_add pos))) name) : @preirreducible_space.{0} (ring.{0} (has_add.{0} pos)) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} (has_add.{0} pos))) name h0)  := sorry --non-trivial
lemma new_lemma_138094 (h0 : functor.add_const (topological_space (mul_zero_class empty)) (semiring (semiring (semiring (semiring empty))))) : @discrete_topology.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} empty)) (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} empty)))) h0)  := sorry --non-trivial
lemma new_lemma_138095 (h1 : function.extfun Type group) : @is_cyclic.{0} (has_emptyc.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h1 (has_emptyc.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_138096 (h0 : uniform_space (canonically_ordered_add_monoid (option empty))) : separated_space (canonically_ordered_add_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_138097 (h0 : group (ordered_comm_ring pos)) : is_cyclic (ordered_comm_ring pos) := sorry --non-trivial
lemma new_lemma_138098 (h0 : functor.add_const (function.extfun Type ring) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) environment.implicit_infer_kind h0) (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_138099 (h0 : ring (has_one (semiring unsigned))) : rank_condition (has_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_138100 (h0 : topological_space (metric_space (semiring num))) : totally_separated_space (metric_space (semiring num)) := sorry --non-trivial
lemma new_lemma_138101 (h0 : functor.add_const (functor.add_const Prop (add_cancel_monoid pos)) (has_Inf name)) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_138102 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_138103 (h0 : topological_space (ring (option (option (option empty))))) : discrete_topology (ring (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_138104 (h1 : finset string.iterator_imp) (h2 : string.iterator_imp -> topological_space (nondiscrete_normed_field (add_comm_semigroup fun_info))) : @path_connected_space.{0} (nondiscrete_normed_field.{0} (add_comm_semigroup.{0} fun_info)) (@finset.inf.{0 0} (topological_space.{0} (nondiscrete_normed_field.{0} (add_comm_semigroup.{0} fun_info))) string.iterator_imp (@lattice.to_semilattice_inf.{0} (topological_space.{0} (nondiscrete_normed_field.{0} (add_comm_semigroup.{0} fun_info))) (@conditionally_complete_lattice.to_lattice.{0} (topological_space.{0} (nondiscrete_normed_field.{0} (add_comm_semigroup.{0} fun_info))) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (nondiscrete_normed_field.{0} (add_comm_semigroup.{0} fun_info))) (@topological_space.complete_lattice.{0} (nondiscrete_normed_field.{0} (add_comm_semigroup.{0} fun_info)))))) (@bounded_order.to_order_top.{0} (topological_space.{0} (nondiscrete_normed_field.{0} (add_comm_semigroup.{0} fun_info))) (@preorder.to_has_le.{0} (topological_space.{0} (nondiscrete_normed_field.{0} (add_comm_semigroup.{0} fun_info))) (@partial_order.to_preorder.{0} (topological_space.{0} (nondiscrete_normed_field.{0} (add_comm_semigroup.{0} fun_info))) (@semilattice_inf.to_partial_order.{0} (topological_space.{0} (nondiscrete_normed_field.{0} (add_comm_semigroup.{0} fun_info))) (@lattice.to_semilattice_inf.{0} (topological_space.{0} (nondiscrete_normed_field.{0} (add_comm_semigroup.{0} fun_info))) (@conditionally_complete_lattice.to_lattice.{0} (topological_space.{0} (nondiscrete_normed_field.{0} (add_comm_semigroup.{0} fun_info))) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (nondiscrete_normed_field.{0} (add_comm_semigroup.{0} fun_info))) (@topological_space.complete_lattice.{0} (nondiscrete_normed_field.{0} (add_comm_semigroup.{0} fun_info))))))))) (@complete_lattice.to_bounded_order.{0} (topological_space.{0} (nondiscrete_normed_field.{0} (add_comm_semigroup.{0} fun_info))) (@topological_space.complete_lattice.{0} (nondiscrete_normed_field.{0} (add_comm_semigroup.{0} fun_info))))) h1 h2)  := sorry --non-trivial
lemma new_lemma_138105 (h0 : topological_space (has_Sup (semiring (semiring (semiring congr_arg_kind))))) : loc_path_connected_space (has_Sup (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_138106 (h0 : not (group (complete_semilattice_Sup linarith.comp_source) -> false)) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (complete_semilattice_Sup.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_138107 (h0 : topological_space (div_inv_monoid linarith.comp_source)) : totally_disconnected_space (div_inv_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_138108 (h0 : functor.add_const (topological_space (has_neg pos)) (boolean_algebra name)) : @topological_space.separable_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) (boolean_algebra.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_138109 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_138110 (h0 : functor.add_const Prop (comm_group (add_comm_monoid Type))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_138111 (h0 : list (boolean_algebra (has_add (has_add (has_add (has_pos_part linarith.comp)))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_138112 (h0 : functor.add_const (ring (has_add environment.implicit_infer_kind)) (has_to_string Type)) : @is_domain.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ring.{0} (has_add.{0} environment.implicit_infer_kind)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_138113 (h0 : functor.add_const (function.extfun Type topological_space) (has_add Type)) : @loc_path_connected_space.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (has_add.{1} Type) h0) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_138114 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_monoid_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_138115 (h0 : topological_space (with_one linarith.comp)) : totally_disconnected_space (with_one linarith.comp) := sorry --non-trivial
lemma new_lemma_138116 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @add_monoid.fg.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (add_monoid.{0} (has_add.{0} real)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_138117 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_138118 (h0 : function.extfun (finset Type) (has_mem.mem (semiring linarith.comp_source))) : @is_add_cyclic.{0} (semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type add_group.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_138119 (h0 : topological_space (finset (has_add (has_to_string name)))) : regular_space (finset (has_add (has_to_string name))) := sorry --non-trivial
lemma new_lemma_138120 (h0 : cancel_comm_monoid_with_zero (has_neg_part (option unsigned))) : unique_factorization_monoid (has_neg_part (option unsigned)) := sorry --non-trivial
lemma new_lemma_138121 (h0 : uniform_space (has_Inf (has_add real))) : separated_space (has_Inf (has_add real)) := sorry --non-trivial
lemma new_lemma_138122 (h0 : ring (boolean_algebra unsigned)) : is_domain (boolean_algebra unsigned) := sorry --non-trivial
lemma new_lemma_138123 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (comm_monoid.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_monoid.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_138124 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (canonically_ordered_monoid.{0} (has_Inf.{0} pos)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} (has_Inf.{0} pos)))  := sorry --non-trivial
lemma new_lemma_138125 (h0 : topological_space (division_ring congr_arg_kind)) : normal_space (division_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_138126 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_138127 (h0 : ring (cancel_monoid (option (option (option ennreal))))) : strong_rank_condition (cancel_monoid (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_138128 (h0 : topological_space (add_group (linear_ordered_semiring (semiring (semiring congr_arg_kind))))) : irreducible_space (add_group (linear_ordered_semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_138129 (h1 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_138130 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @t0_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_138131 (h0 : function.extfun Type (functor.add_const (topological_space (generalized_boolean_algebra name)))) : @locally_compact_space.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} name)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} name))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_138132 (h0 : fin has_zero.zero) : @monoid.fg.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (monoid.{0} (ordered_comm_ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_138133 (h0 : functor.add_const (topological_space (has_nndist pos)) unsigned) : @normal_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_138134 (h0 : list (has_norm (random_gen (random_gen linarith.comp_source)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_138135 (h1 : filter (fintype (distrib (add_monoid (random_gen to_additive.value_type))))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_138136 (h0 : topological_space (free_add_monoid congr_arg_kind)) : t0_space (free_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_138137 (h0 : add_group (topological_space (has_nnnorm reducibility_hints))) : is_add_cyclic (topological_space (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_138138 (h1 : complete_lattice (has_nnnorm fun_info)) : complete_lattice.is_Sup_finite_compact (has_nnnorm fun_info) := sorry --non-trivial
lemma new_lemma_138139 (h0 : complete_lattice (add_cancel_monoid name)) : complete_lattice.is_Sup_finite_compact (add_cancel_monoid name) := sorry --non-trivial
lemma new_lemma_138140 (h0 : finset (canonically_ordered_add_monoid unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_138141 (h1 : function.extfun Type topological_space) : @totally_disconnected_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} h1 congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_138142 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (bin_tree unsigned)) := sorry --non-trivial
lemma new_lemma_138143 (h0 : function.extfun Type topological_space) : @normal_space.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_138144 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_138145 (h0 : group (distrib_lattice (has_inv linarith.comp_source))) : normalizer_condition (distrib_lattice (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_138146 (h0 : functor.add_const (ring (finset Type)) (has_nndist Type)) : @rank_condition.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (finset.{1} Type)) (has_nndist.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_138147 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @complete_space.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (ordered_comm_ring.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_138148 (h0 : topological_space (left_cancel_monoid (option congr_arg_kind))) : path_connected_space (left_cancel_monoid (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_138149 (h1 : has_lt (has_div (simple_graph enat))) : no_max_order (has_div (simple_graph enat)) := sorry --non-trivial
lemma new_lemma_138150 (h0 : topological_space (distrib_lattice fun_info)) : totally_separated_space (distrib_lattice fun_info) := sorry --non-trivial
lemma new_lemma_138151 (h0 : topological_space (complete_semilattice_Sup linarith.comp)) : totally_disconnected_space (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_138152 (h0 : monoid (has_nndist (has_neg (has_add (has_neg linarith.comp))))) : monoid.fg (has_nndist (has_neg (has_add (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_138153 (h0 : group std_gen) (h1 : has_lt (group_topology std_gen)) : no_max_order (group_topology std_gen) := sorry --non-trivial
lemma new_lemma_138154 (h0 : functor.add_const (finset (has_zero environment.implicit_infer_kind)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_138155 (h0 : functor.add_const (group (normed_comm_ring environment.implicit_infer_kind)) environment.implicit_infer_kind) : @is_simple_group.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_138156 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (generalized_boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (generalized_boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_138157 (h0 : group (has_nndist (finset (finset pos)))) : normalizer_condition (has_nndist (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_138158 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_138159 (h0 : monoid (linear_ordered_semiring (semiring unsigned))) : monoid.fg (linear_ordered_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_138160 (h0 : topological_space (comm_group (option (has_add pos)))) : sequential_space (comm_group (option (has_add pos))) := sorry --non-trivial
lemma new_lemma_138161 (h1 : filter (fintype (random_gen (add_monoid (add_monoid to_additive.value_type))))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_138162 (h0 : add_group (has_nndist (has_neg_part (has_to_string name)))) : is_add_cyclic (has_nndist (has_neg_part (has_to_string name))) := sorry --non-trivial
lemma new_lemma_138163 (h1 : ring (has_compl (normed_field string_imp))) : rank_condition (has_compl (normed_field string_imp)) := sorry --non-trivial
lemma new_lemma_138164 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_one.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_138165 (h0 : measurable_space name) (h1 : has_div name) : has_measurable_div₂ name := sorry --non-trivial
lemma new_lemma_138166 (h0 : not (complete_lattice (plift empty) -> false)) : @complete_lattice.is_Sup_finite_compact.{1} (plift.{1} empty) (@classical.by_contradiction'.{2} (complete_lattice.{1} (plift.{1} empty)) h0)  := sorry --non-trivial
lemma new_lemma_138167 (h0 : functor.add_const (monoid (canonically_ordered_monoid linarith.comp)) pos) : @monoid.fg.{0} (canonically_ordered_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (canonically_ordered_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_138168 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_138169 (h0 : ordered_add_comm_monoid (normed_comm_ring congr_arg_kind)) : archimedean (normed_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_138170 (h0 : topological_space (has_top to_additive.value_type)) : locally_compact_space (has_top to_additive.value_type) := sorry --non-trivial
lemma new_lemma_138171 (h0 : filter (simple_graph (option empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_138172 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_138173 (h0 : topological_space (add_cancel_monoid (ordered_ring (ring (has_pos_part (has_nndist Type)))))) : locally_compact_space (add_cancel_monoid (ordered_ring (ring (has_pos_part (has_nndist Type))))) := sorry --non-trivial
lemma new_lemma_138174 (h0 : topological_space (has_nndist (has_nndist (has_nndist (has_add (finset name)))))) : regular_space (has_nndist (has_nndist (has_nndist (has_add (finset name))))) := sorry --non-trivial
lemma new_lemma_138175 (h0 : topological_space (id (random_gen (random_gen (random_gen linarith.ineq))))) : totally_separated_space (id (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_138176 (h0 : functor.add_const (topological_space (generalized_boolean_algebra Type)) pos) : @t1_space.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_138177 (h0 : topological_space (has_norm (random_gen (has_ssubset fun_info)))) : totally_disconnected_space (has_norm (random_gen (has_ssubset fun_info))) := sorry --non-trivial
lemma new_lemma_138178 (h0 : topological_space (has_bot (has_neg pos))) : discrete_topology (has_bot (has_neg pos)) := sorry --non-trivial
lemma new_lemma_138179 (h0 : topological_space (generalized_boolean_algebra (has_add pos))) : discrete_topology (generalized_boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_138180 (h0 : filter (normed_comm_ring (option unsigned))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_138181 (h0 : topological_space (boolean_algebra (has_add (has_add pos)))) : locally_compact_space (boolean_algebra (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_138182 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_add name)) : @t1_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_add.{0} name) h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_138183 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) environment.implicit_infer_kind) : @t1_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_138184 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_138185 (h0 : group (ring (has_neg Type))) : normalizer_condition (ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_138186 (h0 : list (has_add name)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_138187 (h0 : not (function.extfun (finset Type) (has_mem.mem to_additive.value_type) -> false)) : @path_connected_space.{0} to_additive.value_type (@finset.pi.empty.{1 0} Type topological_space.{0} to_additive.value_type (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) to_additive.value_type) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) to_additive.value_type)) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_138188 (h0 : functor.add_const (add_group (generalized_boolean_algebra Type)) Type) : @is_add_cyclic.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (add_group.{1} (generalized_boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_138189 (h0 : topological_space (ring congr_arg_kind)) : preconnected_space (ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_138190 (h0 : ordered_add_comm_monoid (add_left_cancel_semigroup (semiring congr_arg_kind))) : archimedean (add_left_cancel_semigroup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_138191 (h0 : uniform_space (measurable_space (semiring (has_union empty)))) : complete_space (measurable_space (semiring (has_union empty))) := sorry --non-trivial
lemma new_lemma_138192 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (normed_group num)) := sorry --non-trivial
lemma new_lemma_138193 (h0 : group (has_Inf (has_Inf Type))) : is_cyclic (has_Inf (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_138194 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_138195 (h0 : functor.add_const (topological_space (cancel_monoid Type)) (has_add (has_add name))) : @regular_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (cancel_monoid.{1} Type)) (has_add.{0} (has_add.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_138196 (h0 : not (cancel_comm_monoid_with_zero (has_union num) -> false)) : @unique_factorization_monoid.{0} (has_union.{0} num) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (has_union.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_138197 (h0 : topological_space (has_pos_part (finset linarith.comp))) : irreducible_space (has_pos_part (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_138198 (h0 : add_group (has_star empty)) : add_group.fg (has_star empty) := sorry --non-trivial
lemma new_lemma_138199 (h0 : functor.add_const (topological_space (normed_comm_ring environment.implicit_infer_kind)) pos) : @normal_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_138200 (h0 : functor.add_const (topological_space (has_edist empty)) (has_edist empty)) : @totally_separated_space.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} empty)) (has_edist.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_138201 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra pos)) environment.implicit_infer_kind) : @archimedean.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (boolean_algebra.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_138202 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_138203 (h0 : functor.add_const (topological_space (finset unsigned)) Type) : @t1_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_138204 (h0 : topological_space (linear_ordered_comm_ring (semiring congr_arg_kind))) : totally_disconnected_space (linear_ordered_comm_ring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_138205 (h0 : add_group (complete_semilattice_Sup (has_norm empty))) : is_add_cyclic (complete_semilattice_Sup (has_norm empty)) := sorry --non-trivial
lemma new_lemma_138206 (h0 : group (semi_normed_ring (comm_ring reducibility_hints))) : is_cyclic (semi_normed_ring (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_138207 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (has_nnnorm.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_nnnorm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_138208 (h0 : ring (normed_group (comm_ring fun_info))) : rank_condition (normed_group (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_138209 (h0 : list (left_cancel_semigroup (ordered_cancel_comm_monoid unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_138210 (h0 : functor.add_const (topological_space (option unsigned)) unsigned) : @totally_separated_space.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_138211 (h0 : equiv.perm enat) : equiv.perm.is_cycle h0 := sorry --non-trivial
lemma new_lemma_138212 (h0 : functor.add_const (function.extfun Type add_monoid) (has_add (has_neg Type))) : @add_monoid.fg.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_monoid.{0}) (has_add.{1} (has_neg.{1} Type)) h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_138213 (h0 : functor.add_const (topological_space (has_add linarith.comp)) Type) : @totally_disconnected_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_138214 (h1 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_138215 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (group_with_zero unsigned)) := sorry --non-trivial
lemma new_lemma_138216 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_138217 (h0 : ring (has_nndist (comm_monoid unsigned))) : rank_condition (has_nndist (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_138218 (h0 : functor.add_const (list (cancel_monoid name)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_138219 (h0 : functor.add_const (finset nnreal) congr_arg_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_138220 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (has_ssubset.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_ssubset.{0} char))  := sorry --non-trivial
lemma new_lemma_138221 (h0 : ring (denumerable (comm_ring linarith.ineq))) : rank_condition (denumerable (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_138222 (h0 : group (canonically_ordered_monoid (has_neg Type))) : is_cyclic (canonically_ordered_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_138223 (h0 : uniform_space (id linarith.comp)) : separated_space (id linarith.comp) := sorry --non-trivial
lemma new_lemma_138224 (h0 : prod (ordered_ring empty) (ordered_ring empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_138225 (h0 : topological_space (distrib_lattice (has_nnnorm linarith.ineq))) : totally_disconnected_space (distrib_lattice (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_138226 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_138227 (h0 : functor.add_const (group (boolean_algebra name)) Type) : @normalizer_condition.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (group.{0} (boolean_algebra.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_138228 (h0 : group (has_emptyc linarith.comp)) : normalizer_condition (has_emptyc linarith.comp) := sorry --non-trivial
lemma new_lemma_138229 (h0 : topological_space (has_sub (semiring (semiring (semiring (semiring unsigned)))))) : t0_space (has_sub (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_138230 (h0 : topological_space (canonically_linear_ordered_add_monoid (has_add real))) : loc_path_connected_space (canonically_linear_ordered_add_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_138231 (h0 : topological_space (has_Inf (has_add (has_add linarith.comp)))) : totally_separated_space (has_Inf (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_138232 (h0 : functor.comp uniform_space has_neg environment.implicit_infer_kind) : @separated_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} uniform_space.{0} has_neg.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_138233 (h0 : complete_lattice (has_add (has_Inf linarith.comp))) : is_compactly_generated (has_add (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_138234 (h0 : functor.add_const (function.extfun Type list) pos) : list.nodup (function.extfun_app (functor.add_const.run h0) (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_138235 (h0 : uniform_space (distrib (random_gen (random_gen (random_gen (random_gen (random_gen char))))))) : complete_space (distrib (random_gen (random_gen (random_gen (random_gen (random_gen char)))))) := sorry --non-trivial
lemma new_lemma_138236 (h0 : monoid (has_dist (option unsigned))) : monoid.fg (has_dist (option unsigned)) := sorry --non-trivial
lemma new_lemma_138237 (h0 : ring (semigroup (finset environment.implicit_infer_kind))) : rank_condition (semigroup (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_138238 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_138239 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_inter.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_138240 (h1 : set (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup enat)) -> enat)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_138241 (h0 : topological_space (mul_zero_class (has_top empty))) : discrete_topology (mul_zero_class (has_top empty)) := sorry --non-trivial
lemma new_lemma_138242 (h0 : functor.add_const (topological_space (comm_semigroup pos)) (has_neg (has_bot (has_neg (has_neg (has_neg pos)))))) : @path_connected_space.{0} (comm_semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_semigroup.{0} pos)) (has_neg.{0} (has_bot.{0} (has_neg.{0} (has_neg.{0} (has_neg.{0} pos))))) h0)  := sorry --non-trivial
lemma new_lemma_138243 (h0 : complete_lattice (add_comm_monoid (option (option (option (option (option (option pos)))))))) : is_compactly_generated (add_comm_monoid (option (option (option (option (option (option pos))))))) := sorry --non-trivial
lemma new_lemma_138244 (h0 : functor.add_const (topological_space (ring linarith.comp)) (has_nndist linarith.comp)) : @totally_separated_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) (has_nndist.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_138245 (h0 : functor.add_const (topological_space (has_neg unsigned)) pos) : @path_connected_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_138246 (h0 : ring (uniform_space (semi_normed_ring string_imp))) : is_domain (uniform_space (semi_normed_ring string_imp)) := sorry --non-trivial
lemma new_lemma_138247 (h0 : list (has_Inf Type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_138248 (h0 : functor.add_const (add_monoid (ordered_comm_monoid real)) real) : @add_monoid.fg.{0} (ordered_comm_monoid.{0} real) (@functor.add_const.run.{0 0} (add_monoid.{0} (ordered_comm_monoid.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_138249 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_138250 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_138251 (h0 : cancel_comm_monoid_with_zero (left_cancel_semigroup num)) : unique_factorization_monoid (left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_138252 (h0 : group (has_Inf (has_Inf real))) : is_simple_group (has_Inf (has_Inf real)) := sorry --non-trivial
lemma new_lemma_138253 (h0 : functor.add_const (uniform_space (has_pos_part pos)) pos) : @complete_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_pos_part.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_138254 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @irreducible_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_138255 (h0 : ring (has_add (comm_group (option pos)))) : is_domain (has_add (comm_group (option pos))) := sorry --non-trivial
lemma new_lemma_138256 (h1 : topological_space (has_nnnorm linarith.ineq)) : totally_disconnected_space (has_nnnorm linarith.ineq) := sorry --non-trivial
lemma new_lemma_138257 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_138258 (h0 : functor.add_const (ring (has_Inf pos)) linarith.comp) : @is_domain.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_Inf.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_138259 (h0 : uniform_space (linear_ordered_add_comm_group_with_top name)) : complete_space (linear_ordered_add_comm_group_with_top name) := sorry --non-trivial
lemma new_lemma_138260 (h5 : not (topological_space (uniform_space char) -> false)) : @totally_disconnected_space.{0} (uniform_space.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} char)) h5)  := sorry --non-trivial
lemma new_lemma_138261 (h0 : topological_space (cancel_monoid (has_add (has_add (has_neg linarith.comp))))) : t1_space (cancel_monoid (has_add (has_add (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_138262 (h0 : function.extfun nat fin) : @discrete_topology.{0} (canonically_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_138263 (h1 : ring (add_comm_semigroup environment.projection_info)) : is_domain (add_comm_semigroup environment.projection_info) := sorry --non-trivial
lemma new_lemma_138264 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_138265 (h0 : group (linear_ordered_field (option (option ennreal)))) : is_simple_group (linear_ordered_field (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_138266 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (ordered_comm_ring.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (ordered_comm_ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_138267 (h0 : add_monoid (has_norm (has_norm (semiring num)))) : add_monoid.fg (has_norm (has_norm (semiring num))) := sorry --non-trivial
lemma new_lemma_138268 (h0 : functor.add_const (add_group (left_cancel_semigroup empty)) num) : @is_add_cyclic.{0} (left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (left_cancel_semigroup.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_138269 (h0 : add_group (mul_one_class (add_comm_monoid reducibility_hints))) : is_add_cyclic (mul_one_class (add_comm_monoid reducibility_hints)) := sorry --non-trivial
lemma new_lemma_138270 (h0 : functor.add_const (has_lt (pseudo_metric_space pos)) unsigned) : @no_min_order.{0} (pseudo_metric_space.{0} pos) (@functor.add_const.run.{0 0} (has_lt.{0} (pseudo_metric_space.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_138271 (h0 : topological_space (normed_comm_ring (option pos))) : regular_space (normed_comm_ring (option pos)) := sorry --non-trivial
lemma new_lemma_138272 (h0 : function.extfun Type group) : @is_cyclic.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_138273 (h1 : function.extfun (finset Type) (has_mem.mem (id fun_info))) : @is_atomistic.{0} (@id.{2} Type fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (@id.{2} Type fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (@id.{2} Type fun_info)) h1 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_138274 (h0 : set (linarith.ineq -> mul_one_class enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_138275 (h0 : finset (linear_ordered_comm_ring congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_138276 (h0 : functor.add_const (topological_space (semigroup name)) pos) : @preirreducible_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_138277 (h0 : function.extfun Type ring) : @is_domain.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_138278 (h0 : uniform_space (has_to_string (finset (finset Type)))) : complete_space (has_to_string (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_138279 (h0 : linarith.comp -> Prop) : id (zzz_forall h0) := sorry --non-trivial
lemma new_lemma_138280 (h0 : topological_space (has_add (has_ssubset stieltjes_function))) : t0_space (has_add (has_ssubset stieltjes_function)) := sorry --non-trivial
lemma new_lemma_138281 (h0 : pnat) (h1 : list pnat) (h2 : thunk nat) : pnat.coprime h0 (@list.head.{0} pnat pnat.inhabited (@list.rotate'.{0} pnat h1 (@trace_call_stack.{0} nat h2)))  := sorry --non-trivial
lemma new_lemma_138282 (h0 : not (uniform_space (plift congr_arg_kind) -> false)) : @separated_space.{1} (plift.{1} congr_arg_kind) (@classical.by_contradiction'.{2} (uniform_space.{1} (plift.{1} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_138283 (h0 : functor.add_const (functor.add_const (monoid (boolean_algebra linarith.comp)) pos) linarith.comp) : @monoid.fg.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (boolean_algebra.{0} linarith.comp)) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (monoid.{0} (boolean_algebra.{0} linarith.comp)) pos) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_138284 (h0 : functor.add_const (monoid (has_add linarith.comp)) (has_neg linarith.comp)) : @monoid.fg.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (has_add.{0} linarith.comp)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_138285 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_138286 (h0 : functor.add_const (topological_space (has_zero unsigned)) pos) : @t1_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_138287 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{0} (add_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (add_comm_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_138288 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : functor.add_const.run (function.extfun_app (function.extfun_app h0 (functor.add_const Prop)) empty) := sorry --non-trivial
lemma new_lemma_138289 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_138290 (h0 : topological_space (ordered_comm_group (option unsigned))) : discrete_topology (ordered_comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_138291 (h0 : topological_space (measurable_space (has_top (has_top fun_info)))) : path_connected_space (measurable_space (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_138292 (h0 : topological_space (has_emptyc (has_norm linarith.comp))) : t0_space (has_emptyc (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_138293 (h2 : add_group (mul_one_class linarith.ineq)) : is_add_cyclic (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_138294 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (left_cancel_semigroup.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (left_cancel_semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_138295 (h0 : topological_space (complete_distrib_lattice (mul_zero_class name))) : locally_compact_space (complete_distrib_lattice (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_138296 (h0 : group (has_nnnorm (has_compl (has_compl fun_info)))) : is_cyclic (has_nnnorm (has_compl (has_compl fun_info))) := sorry --non-trivial
lemma new_lemma_138297 (h0 : functor.add_const (function.extfun (Type 1) ring) Type) : @is_principal_ideal_ring.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) Type h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_138298 (h3 : add_group (with_one (random_gen fun_info))) : is_add_cyclic (with_one (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_138299 (h0 : not (filter (div_inv_monoid to_additive.value_type) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_138300 (h0 : group (is_R_or_C (semiring (semiring num)))) : is_cyclic (is_R_or_C (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_138301 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) complete_lattice.{0}) (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_138302 (h0 : group (ring (ring pos))) : is_cyclic (ring (ring pos)) := sorry --non-trivial
lemma new_lemma_138303 (h0 : topological_space (linear_ordered_add_comm_group (has_inv to_additive.value_type))) : totally_separated_space (linear_ordered_add_comm_group (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_138304 (h0 : functor.add_const (filter (boolean_algebra name)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_138305 (h0 : topological_space (add_comm_monoid (option unsigned))) : preirreducible_space (add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_138306 (h0 : complete_lattice linarith.comp_source) : is_atomistic linarith.comp_source := sorry --non-trivial
lemma new_lemma_138307 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (linear_ordered_comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (linear_ordered_comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_138308 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_138309 (h0 : filter (has_neg (has_neg pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_138310 (h0 : uniform_space (boolean_algebra (normed_comm_ring name))) : separated_space (boolean_algebra (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_138311 (h0 : add_monoid (with_bot unsigned)) : add_monoid.fg (with_bot unsigned) := sorry --non-trivial
lemma new_lemma_138312 (h0 : functor.add_const (ordered_add_comm_monoid (ordered_comm_group empty)) (option (option (option (option empty))))) : @archimedean.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ordered_comm_group.{0} empty)) (option.{0} (option.{0} (option.{0} (option.{0} empty)))) h0)  := sorry --non-trivial
lemma new_lemma_138313 (h0 : topological_space (normed_comm_ring (has_add (finset (has_neg Type))))) : locally_compact_space (normed_comm_ring (has_add (finset (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_138314 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_138315 (h0 : functor.comp group complete_distrib_lattice pos) : @group.fg.{0} (complete_distrib_lattice.{0} pos) (@functor.comp.run.{0 0 0} group.{0} complete_distrib_lattice.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_138316 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (left_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (left_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_138317 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_138318 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @preconnected_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_138319 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @has_exists_mul_of_le.{0} (has_to_string.{0} real) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero))) (has_to_string.{0} real))  := sorry --non-trivial
lemma new_lemma_138320 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (add_left_cancel_monoid.{0} (has_inv.{0} fun_info)) (@function.extfun_app.{2 1} Type add_group.{0} h0 (add_left_cancel_monoid.{0} (has_inv.{0} fun_info)))  := sorry --non-trivial
lemma new_lemma_138321 (h3 : complete_lattice char) : complete_lattice.is_Sup_finite_compact char := sorry --non-trivial
lemma new_lemma_138322 (h0 : functor.add_const (topological_space (ordered_ring congr_arg_kind)) num) : @irreducible_space.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_138323 (h0 : functor.add_const (function.extfun Type ring) name) : @strong_rank_condition.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name h0) (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_138324 (h0 : ring (boolean_algebra.core (has_add unsigned))) : is_principal_ideal_ring (boolean_algebra.core (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_138325 (h0 : not (topological_space (uniform_space to_additive.value_type) -> false)) : @path_connected_space.{0} (uniform_space.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_138326 (h0 : functor.add_const (topological_space (has_to_string pos)) name) : @irreducible_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_138327 (h0 : functor.add_const (monoid linarith.comp) (ring (ordered_ring pos))) : @monoid.fg.{0} linarith.comp (@functor.add_const.run.{0 0} (monoid.{0} linarith.comp) (ring.{0} (ordered_ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_138328 (h0 : topological_space (has_top (normed_group linarith.comp_source))) : irreducible_space (has_top (normed_group linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_138329 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_dist.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_dist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_138330 (h0 : functor.add_const (ring (normed_comm_ring name)) environment.implicit_infer_kind) : @strong_rank_condition.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_138331 (h0 : function.extfun Type topological_space) : @t0_space.{0} (ring.{0} (has_Inf.{0} linarith.comp)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} (has_Inf.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_138332 (h1 : ring (linear_ordered_comm_group_with_zero linarith.comp_source)) : strong_rank_condition (linear_ordered_comm_group_with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_138333 (h0 : Prop) (h2 : list Prop) : list.ilast' h0 h2 := sorry --non-trivial
lemma new_lemma_138334 (h0 : has_mem.mem (complete_semilattice_Sup linarith.comp_source) has_emptyc.emptyc) : @path_connected_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_138335 (h0 : not (uniform_space (comm_ring fun_info) -> false)) : @complete_space.{0} (comm_ring.{0} fun_info) (@classical.by_contradiction'.{1} (uniform_space.{0} (comm_ring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_138336 (h0 : cancel_comm_monoid_with_zero (normed_lattice_add_comm_group Type)) : unique_factorization_monoid (normed_lattice_add_comm_group Type) := sorry --non-trivial
lemma new_lemma_138337 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_domain.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_138338 (h0 : complete_lattice (random_gen (random_gen linarith.ineq))) : is_atomistic (random_gen (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_138339 (h0 : functor.add_const (function.extfun Type monoid) linarith.comp) : @monoid.fg.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) linarith.comp h0) (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_138340 (h2 : topological_space (has_compl fun_info)) : totally_disconnected_space (has_compl fun_info) := sorry --non-trivial
lemma new_lemma_138341 (h0 : ordered_add_comm_monoid (left_cancel_monoid (semiring empty))) : archimedean (left_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_138342 (h0 : topological_space (with_one (semiring fun_info))) : discrete_topology (with_one (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_138343 (h0 : group (normed_lattice_add_comm_group (sub_neg_monoid pos))) : is_cyclic (normed_lattice_add_comm_group (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_138344 (h0 : functor.add_const (add_group (has_zero linarith.comp)) Type) : @is_add_cyclic.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_group.{0} (has_zero.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_138345 (h0 : topological_space (has_nnnorm (has_nnnorm fun_info))) : locally_compact_space (has_nnnorm (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_138346 (h0 : functor.add_const (list (has_pos_part linarith.comp)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_138347 (h0 : functor.add_const (uniform_space (ring environment.implicit_infer_kind)) environment.implicit_infer_kind) : @separated_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (ring.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_138348 (h0 : set (has_neg char -> string.iterator_imp)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_138349 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_138350 (h0 : ring (boolean_algebra (has_add (finset pos)))) : strong_rank_condition (boolean_algebra (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_138351 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_138352 (h0 : topological_space (normed_group (with_one (random_gen fun_info)))) : path_connected_space (normed_group (with_one (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_138353 (h0 : topological_space (has_union (linear_ordered_semiring empty))) : totally_disconnected_space (has_union (linear_ordered_semiring empty)) := sorry --non-trivial
lemma new_lemma_138354 (h0 : finset (partial_order (semiring (semiring (semiring (semiring (semiring empty))))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_138355 (h0 : group (linear_ordered_field (has_to_string (has_to_string congr_arg_kind)))) : group.fg (linear_ordered_field (has_to_string (has_to_string congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_138356 (h0 : finset (normed_linear_ordered_group (semiring empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_138357 (h0 : list (ordered_comm_ring (has_neg pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_138358 (h0 : topological_space (has_div enat)) (h1 : preorder (has_div enat)) : order_topology (has_div enat) := sorry --non-trivial
lemma new_lemma_138359 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (@id.{2} Type linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_138360 (h0 : list (boolean_algebra (comm_group Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_138361 (h0 : complete_lattice (has_neg (comm_group (comm_group (comm_group (comm_group Type)))))) : is_atomistic (has_neg (comm_group (comm_group (comm_group (comm_group Type))))) := sorry --non-trivial
lemma new_lemma_138362 (h0 : topological_space (topological_space (random_gen string_imp))) : t0_space (topological_space (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_138363 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_138364 (h0 : ring (ring (pseudo_metric_space pos))) : is_principal_ideal_ring (ring (pseudo_metric_space pos)) := sorry --non-trivial
lemma new_lemma_138365 (h0 : ring (has_emptyc (random_gen (random_gen (random_gen linarith.ineq))))) : strong_rank_condition (has_emptyc (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_138366 (h0 : group (mul_zero_class ennreal)) : group.fg (mul_zero_class ennreal) := sorry --non-trivial
lemma new_lemma_138367 (h0 : topological_space (complete_distrib_lattice (semiring empty))) : t1_space (complete_distrib_lattice (semiring empty)) := sorry --non-trivial
lemma new_lemma_138368 (h0 : fin has_zero.zero) : @irreducible_space.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_138369 (h0 : add_group (add_comm_semigroup ereal)) : is_add_cyclic (add_comm_semigroup ereal) := sorry --non-trivial
lemma new_lemma_138370 (h3 : ring (fintype to_additive.value_type)) : is_domain (fintype to_additive.value_type) := sorry --non-trivial
lemma new_lemma_138371 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (has_ssubset.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_ssubset.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_138372 (h0 : functor.add_const (function.extfun Type uniform_space) linarith.comp) : @separated_space.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) linarith.comp h0) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_138373 (h0 : function.extfun (finset Type) (has_mem.mem (with_one linarith.comp))) : @normal_space.{0} (with_one.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_138374 (h0 : functor.add_const (group (complete_distrib_lattice linarith.comp)) Type) : @normalizer_condition.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (complete_distrib_lattice.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_138375 (h0 : uniform_space (distrib_lattice (div_inv_monoid (random_gen linarith.comp_source)))) : complete_space (distrib_lattice (div_inv_monoid (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_138376 (h0 : complete_lattice (has_norm to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (has_norm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_138377 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (finset.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (finset.{0} empty))  := sorry --non-trivial
lemma new_lemma_138378 (h0 : functor.add_const (filter (add_cancel_monoid congr_arg_kind)) congr_arg_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_138379 (h2 : topological_space (complete_semilattice_Sup string_imp)) : totally_disconnected_space (complete_semilattice_Sup string_imp) := sorry --non-trivial
lemma new_lemma_138380 (h0 : semiring (ordered_comm_ring (has_neg (has_neg name)))) : is_noetherian_ring (ordered_comm_ring (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_138381 (h0 : prod (has_nndist empty) (has_nndist empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_138382 (h0 : topological_space (normed_field (has_nnnorm (topological_space linarith.comp_source)))) : t0_space (normed_field (has_nnnorm (topological_space linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_138383 (h0 : monoid (has_emptyc (has_emptyc (has_norm linarith.comp_source)))) : monoid.fg (has_emptyc (has_emptyc (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_138384 (h0 : functor.add_const (finset (normed_linear_ordered_group unsigned)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_138385 (h0 : add_group (left_cancel_semigroup (semiring (add_right_cancel_monoid (option empty))))) : is_add_cyclic (left_cancel_semigroup (semiring (add_right_cancel_monoid (option empty)))) := sorry --non-trivial
lemma new_lemma_138386 (h0 : ring (has_inner unsigned congr_arg_kind)) : rank_condition (has_inner unsigned congr_arg_kind) := sorry --non-trivial
lemma new_lemma_138387 (h0 : list (semi_normed_comm_ring (with_one linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_138388 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_138389 (h0 : functor.add_const (topological_space (complete_linear_order unsigned)) congr_arg_kind) : @discrete_topology.{0} (complete_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_linear_order.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_138390 (h0 : functor.add_const (function.extfun (Type 1) add_group) ennreal) : @is_add_cyclic.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_group.{1}) ennreal h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_138391 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_138392 (h0 : complete_lattice (canonically_linear_ordered_monoid (option ennreal))) : is_atomistic (canonically_linear_ordered_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_138393 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_138394 (h0 : topological_space (has_nndist (boolean_algebra.core pos))) : totally_disconnected_space (has_nndist (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_138395 (h0 : not (ring (semiring num) -> false)) : @strong_rank_condition.{0} (semiring.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_138396 (h1 : complete_lattice (measurable_space (random_gen (random_gen (random_gen linarith.ineq))))) : is_atomistic (measurable_space (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_138397 (h4 : function.extfun Type uniform_space) : @complete_space.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} h4 (semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_138398 (h0 : ring (has_ssubset (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source))))) : strong_rank_condition (has_ssubset (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_138399 (h0 : topological_space (normed_group (comm_ring linarith.comp_source))) : irreducible_space (normed_group (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_138400 (h0 : function.extfun (Type 1) complete_lattice) : @complete_lattice.is_Sup_finite_compact.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_138401 (h0 : filter (semigroup (add_comm_monoid Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_138402 (h0 : functor.add_const (ordered_add_comm_monoid (has_neg num)) unsigned) : @archimedean.{0} (has_neg.{0} num) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_neg.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_138403 (h0 : topological_space (has_Inf (finset (has_pos_part linarith.comp)))) : t0_space (has_Inf (finset (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_138404 (h0 : topological_space (measurable_space (semiring empty))) : totally_disconnected_space (measurable_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_138405 (h0 : group (has_neg_part pos)) : group.fg (has_neg_part pos) := sorry --non-trivial
lemma new_lemma_138406 (h1 : topological_space (has_nnnorm linarith.ineq)) : t0_space (has_nnnorm linarith.ineq) := sorry --non-trivial
lemma new_lemma_138407 (h0 : ordered_add_comm_monoid (cancel_monoid environment.implicit_infer_kind)) : archimedean (cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_138408 (h0 : ordered_add_comm_monoid (semigroup (has_neg_part unsigned))) : archimedean (semigroup (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_138409 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @topological_space.separable_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_138410 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring num))) : @rank_condition.{0} (linear_ordered_semiring.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_138411 (h0 : fin has_zero.zero) : @discrete_topology.{0} (simple_graph.{0} (has_add.{0} linarith.comp)) (@matrix.vec_empty.{0} (topological_space.{0} (simple_graph.{0} (has_add.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_138412 (h0 : topological_space (plift (semiring num))) : discrete_topology (plift (semiring num)) := sorry --non-trivial
lemma new_lemma_138413 (h0 : not (topological_space (fintype linarith.ineq) -> false)) : @totally_disconnected_space.{0} (fintype.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (fintype.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_138414 (h0 : ring (add_comm_semigroup environment.projection_info)) : rank_condition (add_comm_semigroup environment.projection_info) := sorry --non-trivial
lemma new_lemma_138415 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc linarith.ineq))) : @is_domain.{0} (has_emptyc.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type ring.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} linarith.ineq)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_138416 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_138417 (h0 : monoid (ring (option (option (option unsigned))))) : monoid.fg (ring (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_138418 (h0 : complete_lattice (add_cancel_monoid (has_neg (has_neg_part pos)))) : is_compactly_generated (add_cancel_monoid (has_neg (has_neg_part pos))) := sorry --non-trivial
lemma new_lemma_138419 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_138420 (h0 : function.extfun Type uniform_space) : complete_space empty := sorry --non-trivial
lemma new_lemma_138421 (h0 : semiring name -> semiring name -> Prop) : is_strict_order (semiring name) h0 := sorry --non-trivial
lemma new_lemma_138422 (h0 : ring (has_nndist (comm_group pos))) : rank_condition (has_nndist (comm_group pos)) := sorry --non-trivial
lemma new_lemma_138423 (h0 : list (semigroup empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_138424 (h0 : complete_lattice (linear_ordered_field name)) : is_compactly_generated (linear_ordered_field name) := sorry --non-trivial
lemma new_lemma_138425 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_138426 (h0 : topological_space (has_nndist num)) : t1_space (has_nndist num) := sorry --non-trivial
lemma new_lemma_138427 (h0 : functor.add_const (function.extfun Type topological_space) (boolean_algebra (has_add pos))) : @topological_space.separable_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (boolean_algebra.{0} (has_add.{0} pos)) h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_138428 (h0 : topological_space (linear_ordered_field (option num))) : topological_space.separable_space (linear_ordered_field (option num)) := sorry --non-trivial
lemma new_lemma_138429 (h0 : topological_space (normed_lattice_add_comm_group (sub_neg_monoid real))) : t0_space (normed_lattice_add_comm_group (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_138430 (h0 : uniform_space (non_unital_non_assoc_semiring (comm_ring (metric_space to_additive.value_type)))) : complete_space (non_unital_non_assoc_semiring (comm_ring (metric_space to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_138431 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) name) : @sequential_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_138432 (h0 : functor.add_const (function.extfun (Type 1) ring) pos) : @strong_rank_condition.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) pos h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_138433 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_138434 (h0 : topological_space (has_Inf (ring Type))) : path_connected_space (has_Inf (ring Type)) := sorry --non-trivial
lemma new_lemma_138435 (h0 : topological_space (id num)) : totally_disconnected_space (id num) := sorry --non-trivial
lemma new_lemma_138436 (h0 : group (boolean_algebra (has_neg (has_neg (add_cancel_monoid (has_neg Type)))))) : group.fg (boolean_algebra (has_neg (has_neg (add_cancel_monoid (has_neg Type))))) := sorry --non-trivial
lemma new_lemma_138437 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_138438 (h0 : functor.add_const (group (filter unsigned)) (option empty)) : @is_cyclic.{0} (filter.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (filter.{0} unsigned)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_138439 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_138440 (h0 : topological_space (normed_group (with_bot (has_inv linarith.comp_source)))) : totally_separated_space (normed_group (with_bot (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_138441 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_138442 (h0 : filter (has_norm (has_norm (id congr_arg_kind)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_138443 (h0 : complete_lattice (ordered_comm_monoid Type)) : complete_lattice.is_Sup_finite_compact (ordered_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_138444 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @t0_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_138445 (h0 : complete_lattice (simple_graph (metric_space string_imp))) : is_compactly_generated (simple_graph (metric_space string_imp)) := sorry --non-trivial
lemma new_lemma_138446 (h2 : group (with_one to_additive.value_type)) : normalizer_condition (with_one to_additive.value_type) := sorry --non-trivial
lemma new_lemma_138447 (h0 : functor.add_const (ring (has_pos_part pos)) (has_Inf name)) : @strong_rank_condition.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_pos_part.{0} pos)) (has_Inf.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_138448 (h0 : group (non_assoc_semiring (semiring empty))) : group.fg (non_assoc_semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_138449 (h0 : has_mem.mem (has_one empty) has_emptyc.emptyc) : @is_add_cyclic.{0} (has_one.{0} empty) (@finset.pi.empty.{1 0} Type add_group.{0} (has_one.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_138450 (h0 : functor.add_const (function.extfun nat fin) Type) : @complete_space.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (generalized_boolean_algebra.{1} Type)) (@function.extfun_app.{1 1} nat fin (@functor.add_const.run.{0 1} (function.extfun.{1 1} nat fin) Type h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_138451 (h0 : not (uniform_space (has_div enat) -> false)) : @complete_space.{0} (has_div.{0} enat) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_div.{0} enat)) h0)  := sorry --non-trivial
lemma new_lemma_138452 (h0 : uniform_space (normed_group string_imp)) : complete_space (normed_group string_imp) := sorry --non-trivial
lemma new_lemma_138453 (h0 : complete_lattice (has_add (ring (has_neg name)))) : complete_lattice.is_Sup_finite_compact (has_add (ring (has_neg name))) := sorry --non-trivial
lemma new_lemma_138454 (h0 : functor.add_const (ring (has_zero linarith.comp)) Type) : @rank_condition.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (has_zero.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_138455 (h0 : prod (cancel_monoid congr_arg_kind) (cancel_monoid congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_138456 (h0 : functor.add_const (function.extfun (Type 1) list) Type) : palindrome (function.extfun_app (functor.add_const.run h0) (has_add Type)) := sorry --non-trivial
lemma new_lemma_138457 (h0 : functor.add_const (ring (add_cancel_monoid empty)) empty) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_138458 (h0 : function.extfun Type (functor.add_const (add_monoid (comm_group unsigned)))) : @add_monoid.fg.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (comm_group.{0} unsigned)) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_monoid.{0} (comm_group.{0} unsigned))) h0 pos))  := sorry --non-trivial
lemma new_lemma_138459 (h0 : filter (random_gen (id linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_138460 (h0 : group (add_comm_monoid (has_neg_part (has_add linarith.comp)))) : normalizer_condition (add_comm_monoid (has_neg_part (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_138461 (h0 : has_mem.mem group has_emptyc.emptyc) : @normalizer_condition.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_138462 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @normalizer_condition.{0} unsigned (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) unsigned)  := sorry --non-trivial
lemma new_lemma_138463 (h0 : add_group (ordered_comm_group (option (option unsigned)))) : is_add_cyclic (ordered_comm_group (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_138464 (h0 : group (has_add (has_add linarith.comp))) : is_cyclic (has_add (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_138465 (h0 : topological_space (canonically_ordered_monoid (has_add real))) : t1_space (canonically_ordered_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_138466 (h0 : topological_space (has_Inf (has_Inf (has_add (has_Inf pos))))) : preirreducible_space (has_Inf (has_Inf (has_add (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_138467 (h0 : ring (has_add (has_nndist (has_pos_part Type)))) : rank_condition (has_add (has_nndist (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_138468 (h0 : list (group_with_zero (option (option ennreal)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_138469 (h0 : ordered_add_comm_monoid (has_Inf (has_Inf Type))) : archimedean (has_Inf (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_138470 (h1 : group (linear_ordered_add_comm_group string_imp)) : group.fg (linear_ordered_add_comm_group string_imp) := sorry --non-trivial
lemma new_lemma_138471 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_138472 (h0 : not (ring (comm_ring string_imp) -> false)) : @strong_rank_condition.{0} (comm_ring.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (comm_ring.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_138473 (h0 : list (topological_space (random_gen string_imp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_138474 (h0 : topological_space (omega_complete_partial_order empty)) : topological_space.separable_space (omega_complete_partial_order empty) := sorry --non-trivial
lemma new_lemma_138475 (h1 : topological_space (semi_normed_comm_ring (has_nnnorm fun_info))) : totally_disconnected_space (semi_normed_comm_ring (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_138476 (h0 : uniform_space (has_pos_part linarith.comp)) : separated_space (has_pos_part linarith.comp) := sorry --non-trivial
lemma new_lemma_138477 (h0 : not (topological_space (measurable_space.dynkin_system congr_arg_kind) -> false)) : @normal_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_138478 (h0 : function.extfun Type (functor.comp ordered_comm_monoid has_nndist)) : @has_exists_mul_of_le.{0} (has_nndist.{0} (option.{0} pos)) (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} has_nndist.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ordered_comm_monoid.{0} has_nndist.{0}) h0 (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_138479 (h0 : topological_space (linear_ordered_comm_ring (has_top (has_top (has_top num))))) : preirreducible_space (linear_ordered_comm_ring (has_top (has_top (has_top num)))) := sorry --non-trivial
lemma new_lemma_138480 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_138481 (h0 : functor.add_const (ordered_comm_monoid (has_pos_part name)) Type) : @has_exists_mul_of_le.{0} (has_pos_part.{0} name) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (has_pos_part.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_138482 (h0 : decidable_eq (mul_one_class enat)) (h1 : equiv.perm (mul_one_class enat)) : equiv.perm.is_swap h1 := sorry --non-trivial
lemma new_lemma_138483 (h0 : functor.add_const (prod (non_assoc_semiring unsigned) (non_assoc_semiring unsigned)) empty) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_138484 (h0 : ring (distrib std_gen)) : is_domain (distrib std_gen) := sorry --non-trivial
lemma new_lemma_138485 (h0 : functor.add_const (ring (has_edist num)) empty) : @is_principal_ideal_ring.{0} (has_edist.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (has_edist.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_138486 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_138487 (h0 : ring (semi_normed_comm_ring (has_nnnorm reducibility_hints))) : is_domain (semi_normed_comm_ring (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_138488 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) Type) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_138489 (h0 : has_lt (has_ssubset fun_info)) : no_max_order (has_ssubset fun_info) := sorry --non-trivial
lemma new_lemma_138490 (h0 : uniform_space (has_norm (complete_distrib_lattice to_additive.value_type))) : complete_space (has_norm (complete_distrib_lattice to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_138491 (h0 : topological_space (boolean_algebra (normed_comm_ring name))) : loc_path_connected_space (boolean_algebra (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_138492 (h0 : topological_space (finset (has_to_string (has_to_string congr_arg_kind)))) : totally_separated_space (finset (has_to_string (has_to_string congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_138493 (h0 : functor.add_const (topological_space Type) (has_nndist linarith.comp)) : @path_connected_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) (has_nndist.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_138494 (h0 : topological_space (id congr_arg_kind)) : locally_compact_space (id congr_arg_kind) := sorry --non-trivial
lemma new_lemma_138495 (h0 : functor.add_const (function.extfun Type ring) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (add_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) environment.implicit_infer_kind h0) (add_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_138496 (h0 : not (has_mem.mem (has_top linarith.comp_source) has_emptyc.emptyc -> false)) : @totally_separated_space.{0} (has_top.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_138497 (h0 : add_group (linear_ordered_comm_group_with_zero (normed_field linarith.comp_source))) : is_add_cyclic (linear_ordered_comm_group_with_zero (normed_field linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_138498 (h0 : functor.add_const (complete_lattice (ordered_comm_ring pos)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (ordered_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_138499 (h0 : function.extfun Type (functor.add_const (ring (has_Sup num)))) : @strong_rank_condition.{0} (has_Sup.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (has_Sup.{0} num)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (has_Sup.{0} num))) h0 empty))  := sorry --non-trivial
lemma new_lemma_138500 (h0 h1 : multiset (has_div fun_info)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_138501 (h0 : function.extfun Type (functor.add_const (function.extfun Type monoid))) : @monoid.fg.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) environment.implicit_infer_kind (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type monoid.{0})) h0 environment.implicit_infer_kind)) (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_138502 (h1 : uniform_space (normed_field (normed_field (normed_field reducibility_hints)))) : complete_space (normed_field (normed_field (normed_field reducibility_hints))) := sorry --non-trivial
lemma new_lemma_138503 (h0 : topological_space (normed_comm_ring ennreal)) : totally_separated_space (normed_comm_ring ennreal) := sorry --non-trivial
lemma new_lemma_138504 (h0 : topological_space (semigroup (has_nndist (ring linarith.comp)))) : locally_compact_space (semigroup (has_nndist (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_138505 (h0 : ring (finset (comm_group name))) : rank_condition (finset (comm_group name)) := sorry --non-trivial
lemma new_lemma_138506 (h0 : function.extfun Type group) : @group.fg.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_138507 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_138508 (h0 : topological_space (add_cancel_monoid (option (option (option unsigned))))) : t0_space (add_cancel_monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_138509 (h0 : functor.add_const (topological_space (add_left_cancel_semigroup empty)) (option empty)) : @loc_path_connected_space.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_138510 (h0 : functor.add_const (group (finset linarith.comp)) Type) : @group.fg.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (finset.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_138511 (h0 : topological_space (has_Inf (has_add (has_neg Type)))) : locally_compact_space (has_Inf (has_add (has_neg Type))) := sorry --non-trivial
lemma new_lemma_138512 (h0 : topological_space (ordered_comm_ring (has_neg Type))) : loc_path_connected_space (ordered_comm_ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_138513 (h0 : functor.add_const (add_group (has_add pos)) environment.implicit_infer_kind) : @is_add_cyclic.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_add.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_138514 (h0 : ring (canonically_ordered_comm_semiring name)) : is_domain (canonically_ordered_comm_semiring name) := sorry --non-trivial
lemma new_lemma_138515 (h0 : filter (boolean_algebra (finset environment.implicit_infer_kind))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_138516 (h0 : functor.add_const (topological_space (ordered_comm_group empty)) (option empty)) : @totally_disconnected_space.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_group.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_138517 (h0 : topological_space environment.implicit_infer_kind) : preirreducible_space environment.implicit_infer_kind := sorry --non-trivial
lemma new_lemma_138518 (h0 : topological_space (monoid_with_zero (option (option unsigned)))) : totally_disconnected_space (monoid_with_zero (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_138519 (h0 : group (semi_normed_comm_ring (has_nnnorm linarith.ineq))) : group.fg (semi_normed_comm_ring (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_138520 (h0 : add_group (pseudo_metric_space congr_arg_kind)) : is_add_cyclic (pseudo_metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_138521 (h0 : semiring (left_cancel_monoid (semiring (semiring unsigned)))) : is_noetherian_ring (left_cancel_monoid (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_138522 (h0 : not (ring (random_gen reducibility_hints) -> false)) : @rank_condition.{0} (random_gen.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_138523 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_138524 (h0 : functor.add_const (ring (has_neg environment.implicit_infer_kind)) name) : @strong_rank_condition.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_138525 (h0 : topological_space (mul_one_class (mul_one_class (mul_one_class (mul_one_class fun_info))))) : path_connected_space (mul_one_class (mul_one_class (mul_one_class (mul_one_class fun_info)))) := sorry --non-trivial
lemma new_lemma_138526 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (option.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} num))  := sorry --non-trivial
lemma new_lemma_138527 (h0 : topological_space (finset (has_Inf (finset linarith.comp)))) : topological_space.separable_space (finset (has_Inf (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_138528 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) linarith.comp) : @archimedean.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) linarith.comp h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_138529 (h0 : not (topological_space (add_group linarith.comp) -> false)) : @path_connected_space.{0} (add_group.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_138530 (h0 : not (has_mem.mem (has_norm num) has_emptyc.emptyc -> false)) : @normalizer_condition.{0} (has_norm.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (has_norm.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_138531 (h0 : topological_space (boolean_algebra environment.implicit_infer_kind)) : path_connected_space (boolean_algebra environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_138532 (h0 : topological_space (has_neg pos)) : loc_path_connected_space (has_neg pos) := sorry --non-trivial
lemma new_lemma_138533 (h0 : functor.add_const (function.extfun Type list) pos) : list.nodup (function.extfun_app (functor.add_const.run h0) (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_138534 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) pos) : @sequential_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_138535 (h0 : topological_space (boolean_algebra (has_add (has_add name)))) : irreducible_space (boolean_algebra (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_138536 (h0 : topological_space (topological_space (has_ssubset (has_ssubset string_imp)))) : path_connected_space (topological_space (has_ssubset (has_ssubset string_imp))) := sorry --non-trivial
lemma new_lemma_138537 (h0 : functor.add_const (group (has_neg Type)) linarith.comp) : @group.fg.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_neg.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_138538 (h0 : topological_space (normed_field (has_nnnorm (has_dist char)))) : totally_disconnected_space (normed_field (has_nnnorm (has_dist char))) := sorry --non-trivial
lemma new_lemma_138539 (h0 : functor.add_const (add_monoid (semiring empty)) num) : @add_monoid.fg.{0} (semiring.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (semiring.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_138540 (h0 : ring (has_to_string (finset (has_add Type)))) : strong_rank_condition (has_to_string (finset (has_add Type))) := sorry --non-trivial
lemma new_lemma_138541 (h0 : topological_space (has_neg (has_Inf Type))) : locally_compact_space (has_neg (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_138542 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_nnnorm.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_nnnorm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_138543 (h1 : uniform_space (with_bot linarith.comp)) : complete_space (with_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_138544 (h0 : list (ring (has_neg linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_138545 (h0 : topological_space (ring (has_add linarith.comp))) : locally_compact_space (ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_138546 (h0 : group (add_group congr_arg_kind)) : is_cyclic (add_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_138547 (h0 : topological_space (with_one (random_gen string_imp))) : totally_disconnected_space (with_one (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_138548 (h0 : complete_lattice (linear_ordered_comm_ring (semiring unsigned))) : is_compactly_generated (linear_ordered_comm_ring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_138549 (h0 : functor.add_const (ordered_comm_monoid (sub_neg_monoid pos)) pos) : @has_exists_mul_of_le.{0} (sub_neg_monoid.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (sub_neg_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_138550 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc fun_info))) : @irreducible_space.{0} (has_emptyc.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_138551 (h0 : functor.add_const (ordered_add_comm_monoid (has_nndist ennreal)) name) : @archimedean.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_nndist.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_138552 (h0 : topological_space (comm_ring (random_gen (has_ssubset to_additive.value_type)))) : totally_disconnected_space (comm_ring (random_gen (has_ssubset to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_138553 (h0 : semiring (has_add (has_neg environment.implicit_infer_kind))) : is_noetherian_ring (has_add (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_138554 (h0 : semiring enat) (h3 : ideal enat) : ideal.is_prime h3 := sorry --non-trivial
lemma new_lemma_138555 (h0 : list (ordered_comm_ring (has_nndist (ring Type)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_138556 (h0 : function.extfun Type group) : @group.fg.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_138557 (h0 : topological_space (pseudo_metric_space (option (option pos)))) : preconnected_space (pseudo_metric_space (option (option pos))) := sorry --non-trivial
lemma new_lemma_138558 (h0 : finset (boolean_algebra (has_neg linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_138559 (h0 : complete_lattice (has_inter num)) : is_atomistic (has_inter num) := sorry --non-trivial
lemma new_lemma_138560 (h0 : topological_space (has_neg (finset (has_add (has_pos_part pos))))) : locally_compact_space (has_neg (finset (has_add (has_pos_part pos)))) := sorry --non-trivial
lemma new_lemma_138561 (h0 : group (has_Inf (has_add (has_Inf (has_add (has_add Type)))))) : group.fg (has_Inf (has_add (has_Inf (has_add (has_add Type))))) := sorry --non-trivial
lemma new_lemma_138562 (h0 : fin has_zero.zero) : @sequential_space.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))) (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_138563 (h0 : functor.add_const (semiring (canonically_ordered_comm_semiring unsigned)) (has_neg_part (has_add pos))) : @is_noetherian_ring.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (canonically_ordered_comm_semiring.{0} unsigned)) (has_neg_part.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_138564 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (normed_group unsigned)) := sorry --non-trivial
lemma new_lemma_138565 (h0 : ring (add_cancel_comm_monoid (metric_space (metric_space to_additive.value_type)))) : rank_condition (add_cancel_comm_monoid (metric_space (metric_space to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_138566 (h0 : ordered_comm_monoid (mul_zero_class (has_neg_part (has_add Type)))) : has_exists_mul_of_le (mul_zero_class (has_neg_part (has_add Type))) := sorry --non-trivial
lemma new_lemma_138567 (h0 : topological_space (canonically_ordered_monoid (has_neg (has_add Type)))) : preconnected_space (canonically_ordered_monoid (has_neg (has_add Type))) := sorry --non-trivial
lemma new_lemma_138568 (h0 : ordered_comm_monoid (generalized_boolean_algebra (has_Inf (has_Inf (has_add Type))))) : has_exists_mul_of_le (generalized_boolean_algebra (has_Inf (has_Inf (has_add Type)))) := sorry --non-trivial
lemma new_lemma_138569 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} pos (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 pos)  := sorry --non-trivial
lemma new_lemma_138570 (h0 : topological_space (ordered_cancel_add_comm_monoid (option empty))) : irreducible_space (ordered_cancel_add_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_138571 (h0 : ring (with_one (random_gen fun_info))) : strong_rank_condition (with_one (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_138572 (h0 : functor.add_const (topological_space (free_add_monoid congr_arg_kind)) unsigned) : @totally_separated_space.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_138573 (h0 : uniform_space (add_group (has_union linarith.comp))) : complete_space (add_group (has_union linarith.comp)) := sorry --non-trivial
lemma new_lemma_138574 (h0 : topological_space (has_nndist empty)) : totally_disconnected_space (has_nndist empty) := sorry --non-trivial
lemma new_lemma_138575 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_simple_group.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_138576 (h0 : topological_space (has_emptyc (has_top num))) : discrete_topology (has_emptyc (has_top num)) := sorry --non-trivial
lemma new_lemma_138577 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_138578 (h0 : functor.add_const (ordered_add_comm_monoid (ordered_comm_ring linarith.comp)) Type) : @archimedean.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (ordered_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_138579 (h0 : fin has_zero.zero) : @monoid.fg.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type monoid.{0}) h0) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_138580 (h0 : topological_space (has_norm empty)) : locally_compact_space (has_norm empty) := sorry --non-trivial
lemma new_lemma_138581 (h0 : group (cancel_monoid (option (option (option (option (option empty))))))) : is_cyclic (cancel_monoid (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_138582 (h0 : ring (with_one (random_gen char))) : is_domain (with_one (random_gen char)) := sorry --non-trivial
lemma new_lemma_138583 (h0 : topological_space (normed_group (has_top (has_top fun_info)))) : t0_space (normed_group (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_138584 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_138585 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (ordered_cancel_add_comm_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_138586 (h0 : functor.add_const (ordered_add_comm_monoid (comm_group unsigned)) unsigned) : @archimedean.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (comm_group.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_138587 (h1 : has_mem.mem (id linarith.comp) has_emptyc.emptyc) : @totally_disconnected_space.{0} (@id.{2} Type linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (@id.{2} Type linarith.comp) h1)  := sorry --non-trivial
lemma new_lemma_138588 (h0 : functor.add_const (group (finset Type)) (finset (has_add ennreal))) : @is_cyclic.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (finset.{1} Type)) (finset.{0} (has_add.{0} ennreal)) h0)  := sorry --non-trivial
lemma new_lemma_138589 (h0 : topological_space (has_neg (option ennreal))) : discrete_topology (has_neg (option ennreal)) := sorry --non-trivial
lemma new_lemma_138590 (h0 : functor.add_const (functor.add_const (complete_lattice linarith.comp) Type) pos) : @complete_lattice.is_Sup_finite_compact.{0} linarith.comp (@functor.add_const.run.{0 1} (complete_lattice.{0} linarith.comp) Type (@functor.add_const.run.{0 0} (functor.add_const.{0 1} (complete_lattice.{0} linarith.comp) Type) pos h0))  := sorry --non-trivial
lemma new_lemma_138591 (h0 : functor.add_const (add_monoid (as_linear_order unsigned)) empty) : @add_monoid.fg.{0} (as_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (as_linear_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_138592 (h0 : topological_space (add_comm_monoid (comm_group name))) : t0_space (add_comm_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_138593 (h0 : set (has_compl string.iterator_imp)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_138594 (h0 : not (topological_space (semiring linarith.ineq) -> false)) : @irreducible_space.{0} (semiring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_138595 (h0 : functor.add_const (ring (has_edist unsigned)) unsigned) : @rank_condition.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_edist.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_138596 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_edist.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_edist.{0} num))  := sorry --non-trivial
lemma new_lemma_138597 (h0 : functor.add_const (topological_space (ordered_ring empty)) num) : @normal_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_138598 (h0 : functor.add_const (ordered_comm_monoid (add_cancel_monoid unsigned)) linarith.comp) : @has_exists_mul_of_le.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (add_cancel_monoid.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_138599 (h0 : ring (boolean_algebra (finset linarith.comp))) : is_principal_ideal_ring (boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_138600 (h0 : not (topological_space (semiring empty) -> false)) : @locally_compact_space.{0} (semiring.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_138601 (h0 : ring (add_comm_semigroup (mul_one_class linarith.ineq))) : strong_rank_condition (add_comm_semigroup (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_138602 (h0 : uniform_space (mul_zero_class environment.implicit_infer_kind)) : complete_space (mul_zero_class environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_138603 (h0 : list (semigroup (has_Inf Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_138604 (h1 : not (ring (add_monoid fun_info) -> false)) : @rank_condition.{0} (add_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (add_monoid.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_138605 (h0 : functor.add_const (functor.add_const (function.extfun Type ring) Type) Type) : @strong_rank_condition.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type (@functor.add_const.run.{1 1} (functor.add_const.{1 1} (function.extfun.{2 1} Type ring.{0}) Type) Type h0)) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_138606 (h0 : functor.add_const (topological_space (ordered_comm_monoid real)) (has_neg real)) : @preirreducible_space.{0} (ordered_comm_monoid.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} real)) (has_neg.{0} real) h0)  := sorry --non-trivial
lemma new_lemma_138607 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_138608 (h1 : topological_space (mul_one_class (add_comm_semigroup string.iterator_imp))) : t0_space (mul_one_class (add_comm_semigroup string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_138609 (h0 : ring (has_pos_part (ring (has_add (finset (has_add pos)))))) : rank_condition (has_pos_part (ring (has_add (finset (has_add pos))))) := sorry --non-trivial
lemma new_lemma_138610 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_138611 (h0 : topological_space (has_Inf (has_add (has_add (has_add pos))))) : totally_separated_space (has_Inf (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_138612 (h0 : functor.add_const (topological_space (semigroup name)) (comm_group Type)) : @normal_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} name)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_138613 (h1 : uniform_space linarith.comp) : complete_space linarith.comp := sorry --non-trivial
lemma new_lemma_138614 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) Type) : @totally_separated_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_138615 (h0 : group (boolean_algebra.core empty)) : is_cyclic (boolean_algebra.core empty) := sorry --non-trivial
lemma new_lemma_138616 (h0 : ring (with_bot to_additive.value_type)) : strong_rank_condition (with_bot to_additive.value_type) := sorry --non-trivial
lemma new_lemma_138617 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (linear_ordered_comm_monoid_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_138618 (h0 : functor.add_const (list (has_neg linarith.comp)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_138619 (h0 : topological_space (preorder unsigned)) : t1_space (preorder unsigned) := sorry --non-trivial
lemma new_lemma_138620 (h0 : ring (has_compl (has_nnnorm (has_inv (normed_group linarith.ineq))))) : is_domain (has_compl (has_nnnorm (has_inv (normed_group linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_138621 (h0 : add_group (has_nnnorm (mul_one_class (mul_one_class (mul_one_class reducibility_hints))))) : is_add_cyclic (has_nnnorm (mul_one_class (mul_one_class (mul_one_class reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_138622 (h0 : not (monoid (left_cancel_semigroup unsigned) -> false)) : @monoid.fg.{0} (left_cancel_semigroup.{0} unsigned) (@classical.by_contradiction'.{1} (monoid.{0} (left_cancel_semigroup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_138623 (h0 : topological_space (canonically_ordered_comm_semiring (has_neg_part Type))) : sequential_space (canonically_ordered_comm_semiring (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_138624 (h0 : ring (has_union (has_norm linarith.comp))) : is_domain (has_union (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_138625 (h1 : ring num) : is_domain num := sorry --non-trivial
lemma new_lemma_138626 (h0 : functor.add_const (topological_space (comm_group ennreal)) unsigned) : @loc_path_connected_space.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_138627 (h0 : topological_space (simple_graph empty)) : t0_space (simple_graph empty) := sorry --non-trivial
lemma new_lemma_138628 (h0 : not (ring (non_assoc_semiring num) -> false)) : @is_principal_ideal_ring.{0} (non_assoc_semiring.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (non_assoc_semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_138629 (h1 : function.extfun Type topological_space) : @totally_separated_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_138630 (h0 : filter (complete_distrib_lattice (has_Inf (boolean_algebra.core linarith.comp)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_138631 (h0 : functor.add_const (topological_space (has_neg environment.implicit_infer_kind)) environment.implicit_infer_kind) : @totally_disconnected_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_138632 (h0 : list (has_Sup empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_138633 (h0 : complete_lattice (semigroup (has_add Type))) : is_compactly_generated (semigroup (has_add Type)) := sorry --non-trivial
lemma new_lemma_138634 (h0 : topological_space (nondiscrete_normed_field enat)) (h1 : set (set (nondiscrete_normed_field enat))) : topological_space.is_topological_basis h1 := sorry --non-trivial
lemma new_lemma_138635 (h0 : topological_space (non_assoc_semiring (semiring (semiring empty)))) : preirreducible_space (non_assoc_semiring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_138636 (h0 : not (add_monoid (measure_theory.measure_space unsigned) -> false)) : @add_monoid.fg.{0} (measure_theory.measure_space.{0} unsigned) (@classical.by_contradiction'.{1} (add_monoid.{0} (measure_theory.measure_space.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_138637 (h0 : ring (has_Sup (option unsigned))) : is_principal_ideal_ring (has_Sup (option unsigned)) := sorry --non-trivial
lemma new_lemma_138638 (h0 : function.extfun nat fin) : @locally_compact_space.{0} (has_to_string.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_to_string.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_138639 (h0 : ereal -> ereal -> Prop) : is_equiv ereal h0 := sorry --non-trivial
lemma new_lemma_138640 (h0 : list (ordered_cancel_add_comm_monoid (option (option empty)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_138641 (h0 : function.extfun Type group) : @is_cyclic.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_138642 (h0 : group (ring environment.implicit_infer_kind)) : is_cyclic (ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_138643 (h0 : add_group (has_zero (has_pos_part (finset linarith.comp)))) : is_add_cyclic (has_zero (has_pos_part (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_138644 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_138645 (h0 : complete_lattice (pseudo_metric_space (finset name))) : complete_lattice.is_Sup_finite_compact (pseudo_metric_space (finset name)) := sorry --non-trivial
lemma new_lemma_138646 (h0 : semiring (add_comm_monoid Type)) : is_noetherian_ring (add_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_138647 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (comm_semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_138648 (h0 : ring (has_emptyc linarith.ineq)) : rank_condition (has_emptyc linarith.ineq) := sorry --non-trivial
lemma new_lemma_138649 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @normal_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_138650 (h0 : topological_space (normed_group (random_gen (random_gen (random_gen linarith.ineq))))) : totally_separated_space (normed_group (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_138651 (h0 : function.extfun Type (functor.add_const (ring (normed_linear_ordered_group empty)))) : @is_domain.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (normed_linear_ordered_group.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (normed_linear_ordered_group.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_138652 (h0 : function.extfun Type (functor.comp topological_space ring)) : @totally_disconnected_space.{0} (ring.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} ring.{0}) h0 (normed_comm_ring.{0} environment.implicit_infer_kind)))  := sorry --non-trivial
lemma new_lemma_138653 (h0 : topological_space (has_sub empty)) : path_connected_space (has_sub empty) := sorry --non-trivial
lemma new_lemma_138654 (h0 : functor.add_const (list (plift empty)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_138655 (h0 : ring (mul_one_class enat)) : strong_rank_condition (mul_one_class enat) := sorry --non-trivial
lemma new_lemma_138656 (h1 : topological_space (distrib_lattice (has_inv (has_nnnorm linarith.ineq)))) : path_connected_space (distrib_lattice (has_inv (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_138657 (h0 : group (ordered_comm_ring (has_add (has_add (has_neg linarith.comp))))) : normalizer_condition (ordered_comm_ring (has_add (has_add (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_138658 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_138659 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_138660 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) (has_to_string Type)) : @regular_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} pos)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_138661 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (ring unsigned)) := sorry --non-trivial
lemma new_lemma_138662 (h0 : functor.add_const (add_group (canonically_ordered_comm_semiring ennreal)) (mul_zero_class unsigned)) : @is_add_cyclic.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (add_group.{0} (canonically_ordered_comm_semiring.{0} ennreal)) (mul_zero_class.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_138663 (h0 : ring (has_to_string (normed_comm_ring pos))) : is_domain (has_to_string (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_138664 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_138665 (h0 : complete_lattice (with_one (complete_semilattice_Sup num))) : is_atomistic (with_one (complete_semilattice_Sup num)) := sorry --non-trivial
lemma new_lemma_138666 (h0 : ring (normed_group (has_add string_imp))) : strong_rank_condition (normed_group (has_add string_imp)) := sorry --non-trivial
lemma new_lemma_138667 (h0 : functor.add_const (group (has_pos_part Type)) (has_neg pos)) : @is_cyclic.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_pos_part.{1} Type)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_138668 (h0 : uniform_space (add_comm_monoid (has_neg name))) : complete_space (add_comm_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_138669 (h2 : uniform_space (encodable linarith.comp_source)) : complete_space (encodable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_138670 (h0 : ring (boolean_algebra (comm_group name))) : is_domain (boolean_algebra (comm_group name)) := sorry --non-trivial
lemma new_lemma_138671 (h0 : complete_lattice (sub_neg_monoid linarith.comp)) : complete_lattice.is_Sup_finite_compact (sub_neg_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_138672 (h0 : functor.add_const (topological_space (add_left_cancel_semigroup unsigned)) (option unsigned)) : @topological_space.separable_space.{0} (add_left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_138673 (h0 : ring (normed_field (has_nnnorm (mul_one_class (mul_one_class char))))) : rank_condition (normed_field (has_nnnorm (mul_one_class (mul_one_class char)))) := sorry --non-trivial
lemma new_lemma_138674 (h0 : topological_space (has_div (mul_one_class (mul_one_class linarith.ineq)))) : t0_space (has_div (mul_one_class (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_138675 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_inter.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_inter.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_138676 (h0 : topological_space (has_nndist ennreal)) : path_connected_space (has_nndist ennreal) := sorry --non-trivial
lemma new_lemma_138677 (h0 : topological_space (semiring (has_norm fun_info))) : normal_space (semiring (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_138678 (h0 : fin has_zero.zero) : @separated_space.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (sub_neg_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_138679 (h0 : functor.add_const (filter (cancel_monoid ennreal)) ennreal) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_138680 (h0 : group (add_cancel_monoid (has_Inf (finset linarith.comp)))) : normalizer_condition (add_cancel_monoid (has_Inf (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_138681 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) linarith.comp) : @archimedean.{0} (add_cancel_monoid.{0} (ring.{0} linarith.comp)) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) linarith.comp h0) (add_cancel_monoid.{0} (ring.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_138682 (h0 : ring (ordered_comm_monoid (has_add (has_add Type)))) : rank_condition (ordered_comm_monoid (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_138683 (h0 : functor.add_const (ordered_comm_monoid (has_zero pos)) real) : @has_exists_mul_of_le.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_zero.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_138684 (h0 : function.extfun Type (functor.comp add_group has_add)) : @is_add_cyclic.{0} (has_add.{0} name) (@functor.comp.run.{0 0 0} add_group.{0} has_add.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} add_group.{0} has_add.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_138685 (h0 : list (finset (finset name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_138686 (h0 : functor.add_const (ring (complete_distrib_lattice name)) environment.implicit_infer_kind) : @strong_rank_condition.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_138687 (h0 : topological_space (has_add (has_Inf Type))) : preirreducible_space (has_add (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_138688 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_138689 (h0 : complete_lattice (linear_ordered_comm_group num)) : is_atomistic (linear_ordered_comm_group num) := sorry --non-trivial
lemma new_lemma_138690 (h0 : functor.add_const (add_group (semigroup unsigned)) name) : @is_add_cyclic.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_138691 (h0 : uniform_space (semiring (semiring (semiring (semiring congr_arg_kind))))) : separated_space (semiring (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_138692 (h0 : topological_space (has_Inf (has_Inf pos))) : t1_space (has_Inf (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_138693 (h0 : semiring (ordered_cancel_add_comm_monoid congr_arg_kind)) : is_noetherian_ring (ordered_cancel_add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_138694 (h0 : topological_space (semiring linarith.comp)) : discrete_topology (semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_138695 (h0 : uniform_space (has_inter unsigned)) : complete_space (has_inter unsigned) := sorry --non-trivial
lemma new_lemma_138696 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_add num)) := sorry --non-trivial
lemma new_lemma_138697 (h0 : topological_space (has_pos_part (has_add Type))) : t1_space (has_pos_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_138698 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_138699 (h0 : monoid (ring (boolean_algebra (has_add (boolean_algebra name))))) : monoid.fg (ring (boolean_algebra (has_add (boolean_algebra name)))) := sorry --non-trivial
lemma new_lemma_138700 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (with_bot.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (with_bot.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_138701 (h0 : topological_space (has_to_string (has_add unsigned))) : preirreducible_space (has_to_string (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_138702 (h0 : function.extfun Type topological_space) : @normal_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_138703 (h0 : function.extfun Type ring) : @is_domain.{0} (normed_group.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} num)))))) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_group.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} (has_norm.{0} num)))))))  := sorry --non-trivial
lemma new_lemma_138704 (h0 : fin has_zero.zero) : @normal_space.{0} (normed_lattice_add_comm_group.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (normed_lattice_add_comm_group.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_138705 (h0 : uniform_space char) (h1 h2 : multiset (uniform_space.separation_quotient char)) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_138706 (h0 : ring (semi_normed_comm_ring enat)) : rank_condition (semi_normed_comm_ring enat) := sorry --non-trivial
lemma new_lemma_138707 (h0 : topological_space (complete_distrib_lattice (ring Type))) : topological_space.separable_space (complete_distrib_lattice (ring Type)) := sorry --non-trivial
lemma new_lemma_138708 (h0 : ordered_add_comm_monoid (has_Inf (has_add (has_add linarith.comp)))) : archimedean (has_Inf (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_138709 (h0 : fin has_zero.zero) : @group.fg.{0} (group_with_zero.{0} pos) (@matrix.vec_empty.{0} (group.{0} (group_with_zero.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_138710 (h0 : topological_space (ordered_comm_monoid (has_Inf Type))) : regular_space (ordered_comm_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_138711 (h0 : complete_lattice (canonically_ordered_comm_semiring (option pos))) : complete_lattice.is_Sup_finite_compact (canonically_ordered_comm_semiring (option pos)) := sorry --non-trivial
lemma new_lemma_138712 (h0 : complete_lattice (linear_ordered_semiring (semiring num))) : is_compactly_generated (linear_ordered_semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_138713 (h0 : function.extfun Type ring) : @is_domain.{0} (ring.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (ring.{0} num))  := sorry --non-trivial
lemma new_lemma_138714 (h0 : ring (has_to_string (has_Inf Type))) : is_principal_ideal_ring (has_to_string (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_138715 (h0 : topological_space (linear_ordered_field (option name))) : preconnected_space (linear_ordered_field (option name)) := sorry --non-trivial
lemma new_lemma_138716 (h1 : has_lt (has_div linarith.comp_source)) : no_max_order (has_div linarith.comp_source) := sorry --non-trivial
lemma new_lemma_138717 (h0 : group (left_cancel_monoid char)) : is_cyclic (left_cancel_monoid char) := sorry --non-trivial
lemma new_lemma_138718 (h0 : function.extfun Type group) : @group.fg.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_138719 (h0 : topological_space (finset (add_comm_monoid (add_comm_monoid name)))) : locally_compact_space (finset (add_comm_monoid (add_comm_monoid name))) := sorry --non-trivial
lemma new_lemma_138720 (h0 : functor.add_const (function.extfun (Type 1) monoid) environment.implicit_infer_kind) : @monoid.fg.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) monoid.{1}) environment.implicit_infer_kind h0) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_138721 (h0 : uniform_space (simple_graph (finset linarith.comp))) : complete_space (simple_graph (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_138722 (h0 : complete_lattice (finset (option name))) : is_compactly_generated (finset (option name)) := sorry --non-trivial
lemma new_lemma_138723 (h0 : add_group (add_cancel_monoid (semigroup linarith.comp))) : is_add_cyclic (add_cancel_monoid (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_138724 (h0 : group (add_cancel_monoid (comm_group (comm_group (comm_group name))))) : group.fg (add_cancel_monoid (comm_group (comm_group (comm_group name)))) := sorry --non-trivial
lemma new_lemma_138725 (h1 : topological_space reducibility_hints) : t0_space reducibility_hints := sorry --non-trivial
lemma new_lemma_138726 (h0 : ring (cancel_monoid (semigroup (has_add unsigned)))) : rank_condition (cancel_monoid (semigroup (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_138727 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_138728 (h0 : functor.add_const (uniform_space (add_cancel_monoid linarith.comp)) pos) : @separated_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_138729 (h0 : ring (distrib_lattice reducibility_hints)) : is_domain (distrib_lattice reducibility_hints) := sorry --non-trivial
lemma new_lemma_138730 (h0 : topological_space (has_zero (finset pos))) : totally_disconnected_space (has_zero (finset pos)) := sorry --non-trivial
lemma new_lemma_138731 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_138732 (h0 : group (boolean_algebra (has_to_string unsigned))) : normalizer_condition (boolean_algebra (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_138733 (h0 : group (has_union (semiring congr_arg_kind))) : is_cyclic (has_union (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_138734 (h0 : filter (has_zero (has_neg_part Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_138735 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (is_R_or_C.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (is_R_or_C.{0} empty))  := sorry --non-trivial
lemma new_lemma_138736 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : functor.add_const.run (function.extfun_app (function.extfun_app h0 (functor.add_const Prop)) pos) := sorry --non-trivial
lemma new_lemma_138737 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_138738 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_add num)) := sorry --non-trivial
lemma new_lemma_138739 (h0 : topological_space (has_edist (option (option (option (option unsigned)))))) : topological_space.separable_space (has_edist (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_138740 (h0 : functor.add_const (add_group (generalized_boolean_algebra Type)) pos) : @is_add_cyclic.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (generalized_boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_138741 (h0 : topological_space (ordered_comm_monoid (has_neg pos))) : t0_space (ordered_comm_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_138742 (h0 : topological_space (add_cancel_monoid (option ennreal))) : locally_compact_space (add_cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_138743 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (non_assoc_semiring unsigned)) := sorry --non-trivial
lemma new_lemma_138744 (h0 : ring (with_bot (random_gen (comm_ring linarith.comp_source)))) : is_domain (with_bot (random_gen (comm_ring linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_138745 (h0 : complete_lattice (simple_graph (has_pos_part linarith.comp))) : is_compactly_generated (simple_graph (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_138746 (h0 : functor.add_const (topological_space (left_cancel_monoid empty)) empty) : @totally_disconnected_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_138747 (h0 : complete_lattice (has_bot (has_Inf name))) : complete_lattice.is_Sup_finite_compact (has_bot (has_Inf name)) := sorry --non-trivial
lemma new_lemma_138748 (h0 : function.extfun Type group) : @group.fg.{0} (encodable.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (encodable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_138749 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @monoid.fg.{0} (linear_ordered_field.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) monoid.{0}) (linear_ordered_field.{0} num))  := sorry --non-trivial
lemma new_lemma_138750 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (linear_ordered_add_comm_group_with_top.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_ordered_add_comm_group_with_top.{0} pos))  := sorry --non-trivial
lemma new_lemma_138751 (h0 : filter (comm_semigroup Type)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_138752 (h1 : group (normed_group string_imp)) : group.fg (normed_group string_imp) := sorry --non-trivial
lemma new_lemma_138753 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_star.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_star.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_138754 (h0 : complete_lattice (has_div linarith.ineq)) : complete_lattice.is_Sup_finite_compact (has_div linarith.ineq) := sorry --non-trivial
lemma new_lemma_138755 (h1 : ring (distrib_lattice char)) : rank_condition (distrib_lattice char) := sorry --non-trivial
lemma new_lemma_138756 (h0 : topological_space (ring pos)) : topological_space.separable_space (ring pos) := sorry --non-trivial
lemma new_lemma_138757 (h0 : cancel_comm_monoid_with_zero (complete_linear_order congr_arg_kind)) : unique_factorization_monoid (complete_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_138758 (h0 : group (distrib_lattice (random_gen (has_top linarith.ineq)))) : is_cyclic (distrib_lattice (random_gen (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_138759 (h0 : fin has_zero.zero) : @is_simple_group.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) h0) (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_138760 (h0 : complete_lattice (dlist (with_zero linarith.ineq))) : is_compactly_generated (dlist (with_zero linarith.ineq)) := sorry --non-trivial
lemma new_lemma_138761 (h0 : topological_space (distrib_lattice (random_gen (random_gen linarith.comp_source)))) : locally_compact_space (distrib_lattice (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_138762 (h0 : topological_space (has_add (normed_comm_ring name))) : locally_compact_space (has_add (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_138763 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_neg.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_138764 (h0 : topological_space (has_nndist (add_comm_monoid Type))) : preirreducible_space (has_nndist (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_138765 (h0 : semiring (has_sub (semiring empty))) : is_noetherian_ring (has_sub (semiring empty)) := sorry --non-trivial
lemma new_lemma_138766 (h0 : list (comm_group (has_add name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_138767 (h0 : functor.add_const (ordered_comm_monoid (comm_group unsigned)) (option (option unsigned))) : @has_exists_mul_of_le.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (comm_group.{0} unsigned)) (option.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_138768 (h0 : topological_space (ordered_comm_ring name)) : t0_space (ordered_comm_ring name) := sorry --non-trivial
lemma new_lemma_138769 (h0 : functor.add_const (functor.add_const (functor.add_const (ring nnreal) num) (semiring (semiring empty))) empty) : @rank_condition.{0} nnreal (@functor.add_const.run.{0 0} (ring.{0} nnreal) num (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ring.{0} nnreal) num) (semiring.{0} (semiring.{0} empty)) (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (functor.add_const.{0 0} (ring.{0} nnreal) num) (semiring.{0} (semiring.{0} empty))) empty h0)))  := sorry --non-trivial
lemma new_lemma_138770 (h0 : functor.add_const (complete_lattice (has_neg ennreal)) (option (option ennreal))) : @is_atomistic.{0} (has_neg.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} ennreal)) (option.{0} (option.{0} ennreal)) h0)  := sorry --non-trivial
lemma new_lemma_138771 (h0 : filter (has_to_string (has_nndist (has_add (finset pos))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_138772 (h0 : functor.add_const (semiring (complete_linear_order num)) (semiring (semiring (semiring unsigned)))) : @is_noetherian_ring.{0} (complete_linear_order.{0} num) (@functor.add_const.run.{0 0} (semiring.{0} (complete_linear_order.{0} num)) (semiring.{0} (semiring.{0} (semiring.{0} unsigned))) h0)  := sorry --non-trivial
lemma new_lemma_138773 (h0 : set (distrib char)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_138774 (h0 : group (has_to_string (add_comm_monoid (finset (finset (finset (finset Type))))))) : group.fg (has_to_string (add_comm_monoid (finset (finset (finset (finset Type)))))) := sorry --non-trivial
lemma new_lemma_138775 (h0 : uniform_space (has_edist empty)) : separated_space (has_edist empty) := sorry --non-trivial
lemma new_lemma_138776 (h0 : ring (has_div (mul_one_class char))) : rank_condition (has_div (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_138777 (h0 : topological_space (ordered_comm_ring (has_add (has_Inf real)))) : loc_path_connected_space (ordered_comm_ring (has_add (has_Inf real))) := sorry --non-trivial
lemma new_lemma_138778 (h0 : function.extfun Type (functor.add_const (uniform_space (ordered_ring empty)))) : @separated_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_ring.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (ordered_ring.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_138779 (h0 : ring (normed_field (mul_one_class to_additive.value_type))) : rank_condition (normed_field (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_138780 (h0 : topological_space (ordered_comm_monoid (has_add real))) : discrete_topology (ordered_comm_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_138781 (h0 : topological_space (simple_graph (has_add (has_add (has_Inf Type))))) : irreducible_space (simple_graph (has_add (has_add (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_138782 (h0 : topological_space (has_nndist (has_add (has_add (has_add (has_add (option ennreal))))))) : preirreducible_space (has_nndist (has_add (has_add (has_add (has_add (option ennreal)))))) := sorry --non-trivial
lemma new_lemma_138783 (h0 : topological_space (simple_graph environment.projection_info)) (h1 : add_group (simple_graph environment.projection_info)) : topological_add_group (simple_graph environment.projection_info) := sorry --non-trivial
lemma new_lemma_138784 (h0 : group (simple_graph name)) : is_cyclic (simple_graph name) := sorry --non-trivial
lemma new_lemma_138785 (h0 : topological_space (linear_ordered_semiring empty)) : totally_disconnected_space (linear_ordered_semiring empty) := sorry --non-trivial
lemma new_lemma_138786 (h0 : ordered_comm_monoid (cancel_monoid environment.implicit_infer_kind)) : has_exists_mul_of_le (cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_138787 (h1 : add_group (simple_graph string.iterator_imp)) : is_add_cyclic (simple_graph string.iterator_imp) := sorry --non-trivial
lemma new_lemma_138788 (h0 : fin has_zero.zero) : @preconnected_space.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_138789 (h0 : functor.add_const (complete_lattice (finset unsigned)) Type) : @is_compactly_generated.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 1} (complete_lattice.{0} (finset.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_138790 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_138791 (h0 : function.extfun Type topological_space) : @normal_space.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_138792 (h0 : list (boolean_algebra (simple_graph Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_138793 (h0 : topological_space (semigroup (cancel_monoid pos))) : totally_separated_space (semigroup (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_138794 (h0 : filter (left_cancel_semigroup (semiring (semiring num)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_138795 (h0 : functor.add_const (topological_space (mul_zero_class name)) name) : @locally_compact_space.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_138796 (h1 : monoid (add_monoid string_imp)) (h2 : topological_space (star_monoid (add_monoid string_imp))) : t0_space (star_monoid (add_monoid string_imp)) := sorry --non-trivial
lemma new_lemma_138797 (h0 : group (add_comm_monoid (has_to_string pos))) : group.fg (add_comm_monoid (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_138798 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (add_group.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_group.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_138799 (h1 : complete_lattice (normed_group fun_info)) : complete_lattice.is_Sup_finite_compact (normed_group fun_info) := sorry --non-trivial
lemma new_lemma_138800 (h0 : topological_space (ring (option (option (option (option (option ennreal))))))) : totally_separated_space (ring (option (option (option (option (option ennreal)))))) := sorry --non-trivial
lemma new_lemma_138801 (h0 : functor.add_const (complete_lattice linarith.comp) (normed_comm_ring linarith.comp)) : @is_compactly_generated.{0} linarith.comp (@functor.add_const.run.{0 0} (complete_lattice.{0} linarith.comp) (normed_comm_ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_138802 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} linarith.comp_source (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_138803 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (semigroup.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_138804 (h0 : filter (semi_normed_comm_ring (encodable fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_138805 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_138806 (h0 : list (uniform_space (semi_normed_comm_ring string_imp))) (h1 : nat) (h2 : has_lt.lt h1 (list.length h0)) : @complete_space.{0} (semi_normed_comm_ring.{0} string_imp) (@list.nth_le.{0} (uniform_space.{0} (semi_normed_comm_ring.{0} string_imp)) h0 h1 h2)  := sorry --non-trivial
lemma new_lemma_138807 (h0 : not (add_monoid (measurable_space.dynkin_system linarith.comp) -> false)) : @add_monoid.fg.{0} (measurable_space.dynkin_system.{0} linarith.comp) (@classical.by_contradiction'.{1} (add_monoid.{0} (measurable_space.dynkin_system.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_138808 (h0 : functor.add_const (topological_space (option ennreal)) num) : @normal_space.{0} (option.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_138809 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @totally_disconnected_space.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_138810 (h0 : ring (has_union (semiring (metric_space (has_one (has_one unsigned)))))) : is_domain (has_union (semiring (metric_space (has_one (has_one unsigned))))) := sorry --non-trivial
lemma new_lemma_138811 (h0 : uniform_space (monoid_with_zero ennreal)) : separated_space (monoid_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_138812 (h0 : topological_space (has_union (semiring num))) : normal_space (has_union (semiring num)) := sorry --non-trivial
lemma new_lemma_138813 (h0 : topological_space (add_comm_semigroup fun_info)) : topological_space.first_countable_topology (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_138814 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_138815 (h0 : functor.add_const (topological_space (mul_zero_class environment.implicit_infer_kind)) ennreal) : @totally_separated_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} environment.implicit_infer_kind)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_138816 (h0 : functor.add_const (group (has_to_string pos)) pos) : @group.fg.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_138817 (h0 : uniform_space (has_nndist environment.implicit_infer_kind)) : complete_space (has_nndist environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_138818 (h0 : functor.add_const Prop (boolean_algebra (comm_group (has_to_string (has_add Type))))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_138819 (h0 : topological_space (add_group linarith.ineq)) : t0_space (add_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_138820 (h0 : topological_space (complete_semilattice_Sup (has_nnnorm fun_info))) : t0_space (complete_semilattice_Sup (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_138821 (h0 : ring (semigroup name)) : is_domain (semigroup name) := sorry --non-trivial
lemma new_lemma_138822 (h0 : functor.add_const Prop Type) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_138823 (h0 : topological_space (has_lt linarith.comp_source)) (h1 : add_group (has_lt linarith.comp_source)) : topological_add_group (has_lt linarith.comp_source) := sorry --non-trivial
lemma new_lemma_138824 (h0 : filter (add_cancel_comm_monoid (option unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_138825 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_138826 (h0 : topological_space (has_star (option (option (option unsigned))))) : locally_compact_space (has_star (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_138827 (h0 : uniform_space (measurable_space (random_gen linarith.comp))) : complete_space (measurable_space (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_138828 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_138829 (h0 : functor.add_const (topological_space (monoid_with_zero linarith.comp)) linarith.comp) : @sequential_space.{0} (monoid_with_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid_with_zero.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_138830 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (topological_space.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (topological_space.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_138831 (h0 : group (has_norm (has_nnnorm (has_nnnorm linarith.comp_source)))) : is_cyclic (has_norm (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_138832 (h0 : list (complete_semilattice_Sup (random_gen (has_inv fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_138833 (h0 : topological_space (has_emptyc (has_norm fun_info))) : path_connected_space (has_emptyc (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_138834 (h0 : functor.add_const (list (finset name)) (ring Type)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_138835 (h0 : functor.add_const (complete_lattice (normed_comm_ring Type)) linarith.comp) : @is_atomistic.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (normed_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_138836 (h0 : uniform_space (monoid_with_zero (add_comm_semigroup string.iterator_imp))) : complete_space (monoid_with_zero (add_comm_semigroup string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_138837 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_138838 (h0 : list (ordered_comm_ring (boolean_algebra.core linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_138839 (h0 : ordered_add_comm_monoid (boolean_algebra.core (semigroup Type))) : archimedean (boolean_algebra.core (semigroup Type)) := sorry --non-trivial
lemma new_lemma_138840 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @regular_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_138841 (h0 : functor.comp topological_space complete_distrib_lattice name) : @irreducible_space.{0} (complete_distrib_lattice.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} name h0)  := sorry --non-trivial
lemma new_lemma_138842 (h0 : topological_space (comm_group (finset pos))) : path_connected_space (comm_group (finset pos)) := sorry --non-trivial
lemma new_lemma_138843 (h0 : list (simple_graph (ring (ring (ring Type))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_138844 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (monoid_with_zero.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid_with_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_138845 (h0 : uniform_space (has_union (has_norm (has_norm (has_norm unsigned))))) : separated_space (has_union (has_norm (has_norm (has_norm unsigned)))) := sorry --non-trivial
lemma new_lemma_138846 (h0 : topological_space (boolean_algebra.core pos)) : t0_space (boolean_algebra.core pos) := sorry --non-trivial
lemma new_lemma_138847 (h1 h2 : multiset string.iterator_imp) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_138848 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_138849 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_138850 (h0 : topological_space (option (semiring (semiring congr_arg_kind)))) : totally_separated_space (option (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_138851 (h0 : cancel_comm_monoid_with_zero (complete_distrib_lattice name)) : unique_factorization_monoid (complete_distrib_lattice name) := sorry --non-trivial
lemma new_lemma_138852 (h0 : topological_space (has_pos_part (has_Inf real))) : totally_disconnected_space (has_pos_part (has_Inf real)) := sorry --non-trivial
lemma new_lemma_138853 (h0 : functor.add_const (topological_space (finset unsigned)) unsigned) : @topological_space.separable_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_138854 (h0 : monoid (rel name name)) : monoid.fg (rel name name) := sorry --non-trivial
lemma new_lemma_138855 (h0 : topological_space (finset (ordered_ring Type))) : preconnected_space (finset (ordered_ring Type)) := sorry --non-trivial
lemma new_lemma_138856 (h0 : filter (ring (has_neg_part Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_138857 (h0 : uniform_space (linear_ordered_semiring (has_top unsigned))) : separated_space (linear_ordered_semiring (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_138858 (h0 : add_group (semiring (semiring (semiring (has_norm num))))) : is_add_cyclic (semiring (semiring (semiring (has_norm num)))) := sorry --non-trivial
lemma new_lemma_138859 (h0 : not (ring (measurable_space linarith.comp) -> false)) : @strong_rank_condition.{0} (measurable_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_138860 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_138861 (h0 : function.extfun Type topological_space) : @t0_space.{0} (comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_138862 (h0 : topological_space (boolean_algebra name)) : totally_disconnected_space (boolean_algebra name) := sorry --non-trivial
lemma new_lemma_138863 (h0 : function.extfun (Type 1) topological_space) : @topological_space.separable_space.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_138864 (h0 : functor.add_const (complete_lattice (left_cancel_monoid unsigned)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_138865 (h0 : ordered_add_comm_monoid (group_with_zero (has_zero ennreal))) : archimedean (group_with_zero (has_zero ennreal)) := sorry --non-trivial
lemma new_lemma_138866 (h0 : ordered_add_comm_monoid (bin_tree (option (option (option empty))))) : archimedean (bin_tree (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_138867 (h1 : not (nat -> false)) (h2 : group (nat.partition (classical.by_contradiction' h1))) : is_cyclic (nat.partition (classical.by_contradiction' h1)) := sorry --non-trivial
lemma new_lemma_138868 (h0 : function.extfun Type ring) : @rank_condition.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h0 (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_138869 (h0 : function.extfun Type group) : @is_simple_group.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_138870 (h0 : functor.add_const (finset (mul_zero_class pos)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_138871 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf (has_bot (sub_neg_monoid real))))) : t0_space (normed_lattice_add_comm_group (has_Inf (has_bot (sub_neg_monoid real)))) := sorry --non-trivial
lemma new_lemma_138872 (h0 : uniform_space (complete_linear_order (semiring congr_arg_kind))) : complete_space (complete_linear_order (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_138873 (h0 : topological_space (cancel_monoid (option num))) : t1_space (cancel_monoid (option num)) := sorry --non-trivial
lemma new_lemma_138874 (h0 : complete_lattice (has_to_string (cancel_monoid (option name)))) : is_atomistic (has_to_string (cancel_monoid (option name))) := sorry --non-trivial
lemma new_lemma_138875 (h0 : topological_space (canonically_ordered_comm_semiring empty)) : totally_separated_space (canonically_ordered_comm_semiring empty) := sorry --non-trivial
lemma new_lemma_138876 (h0 : add_monoid (add_cancel_monoid (comm_group name))) : add_monoid.fg (add_cancel_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_138877 (h1 : topological_space (distrib (random_gen (random_gen char)))) : totally_disconnected_space (distrib (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_138878 (h0 : ring (cancel_monoid (option (option (option ennreal))))) : rank_condition (cancel_monoid (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_138879 (h0 : group (comm_semigroup (has_add real))) : is_cyclic (comm_semigroup (has_add real)) := sorry --non-trivial
lemma new_lemma_138880 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_dist empty)) := sorry --non-trivial
lemma new_lemma_138881 (h0 : ordered_comm_monoid (semigroup (ring Type))) : has_exists_mul_of_le (semigroup (ring Type)) := sorry --non-trivial
lemma new_lemma_138882 (h0 : prod (has_nndist (finset pos)) (has_nndist (finset pos))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_138883 (h0 : topological_space (dlist char)) : locally_compact_space (dlist char) := sorry --non-trivial
lemma new_lemma_138884 (h1 : complete_lattice (uniform_space to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (uniform_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_138885 (h0 : topological_space (monoid_with_zero (option (option (option ennreal))))) : t1_space (monoid_with_zero (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_138886 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @is_cyclic.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_138887 (h0 : not (ring (has_ssubset fun_info) -> false)) : @is_domain.{0} (has_ssubset.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_138888 (h0 : monoid (ordered_comm_ring (has_add linarith.comp))) : monoid.fg (ordered_comm_ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_138889 (h0 : functor.add_const (function.extfun Type monoid) environment.implicit_infer_kind) : @monoid.fg.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) environment.implicit_infer_kind h0) (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_138890 (h0 : topological_space (cancel_monoid pos)) : t1_space (cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_138891 (h0 : list (mul_zero_class unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_138892 (h0 : complete_lattice (complete_semilattice_Sup (has_top (has_top (has_top linarith.comp_source))))) : is_compactly_generated (complete_semilattice_Sup (has_top (has_top (has_top linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_138893 (h0 : list (comm_group linarith.comp)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_138894 (h0 : topological_space (ring (option (option unsigned)))) : sequential_space (ring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_138895 (h0 : group (comm_group Type)) : normalizer_condition (comm_group Type) := sorry --non-trivial
lemma new_lemma_138896 (h0 : topological_space (has_zero (boolean_algebra name))) : sequential_space (has_zero (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_138897 (h0 : add_group (option (semiring (semiring (semiring (semiring empty)))))) : is_add_cyclic (option (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_138898 (h0 : not (list (has_norm to_additive.value_type) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_138899 (h0 : function.extfun Type group) : @normalizer_condition.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_138900 (h1 : topological_space (topological_space (has_nnnorm (random_gen (comm_ring linarith.ineq))))) : t0_space (topological_space (has_nnnorm (random_gen (comm_ring linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_138901 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) environment.implicit_infer_kind) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_138902 (h0 : add_group (has_add (finset Type))) : is_add_cyclic (has_add (finset Type)) := sorry --non-trivial
lemma new_lemma_138903 (h0 : topological_space (has_zero (has_neg Type))) : totally_separated_space (has_zero (has_neg Type)) := sorry --non-trivial
lemma new_lemma_138904 (h0 : add_group (boolean_algebra.core (option (option (option empty))))) : is_add_cyclic (boolean_algebra.core (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_138905 (h0 : functor.add_const (complete_lattice (bin_tree unsigned)) congr_arg_kind) : @complete_lattice.is_Sup_finite_compact.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (bin_tree.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_138906 (h0 : group (has_nndist num)) : is_simple_group (has_nndist num) := sorry --non-trivial
lemma new_lemma_138907 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_138908 (h0 : topological_space (has_union (semiring (semiring unsigned)))) : t0_space (has_union (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_138909 (h0 : functor.comp topological_space has_add (ring (option unsigned))) : @preconnected_space.{0} (has_add.{0} (ring.{0} (option.{0} unsigned))) (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} (ring.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_138910 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_138911 (h0 : functor.add_const (ring (left_cancel_monoid unsigned)) empty) : @is_domain.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_138912 (h0 : has_to_string (option ennreal) -> has_to_string (option ennreal) -> Prop) : is_symm (has_to_string (option ennreal)) h0 := sorry --non-trivial
lemma new_lemma_138913 (h0 : function.extfun Type group) : @normalizer_condition.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_138914 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_138915 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_138916 (h1 : not (topological_space (add_cancel_comm_monoid reducibility_hints) -> false)) : @path_connected_space.{0} (add_cancel_comm_monoid.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (add_cancel_comm_monoid.{0} reducibility_hints)) h1)  := sorry --non-trivial
lemma new_lemma_138917 (h0 : group (linear_ordered_add_comm_group (with_one (has_norm to_additive.value_type)))) : group.fg (linear_ordered_add_comm_group (with_one (has_norm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_138918 (h0 : add_group (complete_distrib_lattice (has_neg (finset pos)))) : is_add_cyclic (complete_distrib_lattice (has_neg (finset pos))) := sorry --non-trivial
lemma new_lemma_138919 (h0 : topological_space (has_add name)) : normal_space (has_add name) := sorry --non-trivial
lemma new_lemma_138920 (h0 : topological_space (metric_space (semiring congr_arg_kind))) : discrete_topology (metric_space (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_138921 (h0 : list (has_neg_part (option (ring pos)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_138922 (h0 : left_cancel_semigroup empty -> left_cancel_semigroup empty -> Prop) (h1 : group (linear_ordered_comm_ring (semiring (plift (well_founded h0))))) : group.fg (linear_ordered_comm_ring (semiring (plift (well_founded h0)))) := sorry --non-trivial
lemma new_lemma_138923 (h0 : topological_space (has_append (mul_one_class reducibility_hints))) : totally_disconnected_space (has_append (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_138924 (h0 : ring (has_ssubset (has_inv linarith.ineq))) : strong_rank_condition (has_ssubset (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_138925 (h0 : finset (left_cancel_semigroup unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_138926 (h0 : topological_space (has_neg_part (finset ennreal))) : t1_space (has_neg_part (finset ennreal)) := sorry --non-trivial
lemma new_lemma_138927 (h0 : function.extfun Type topological_space) : @regular_space.{0} (pseudo_metric_space.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} name))  := sorry --non-trivial
lemma new_lemma_138928 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (partial_order congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_138929 (h0 : functor.add_const (topological_space (free_add_monoid congr_arg_kind)) (semiring (semiring congr_arg_kind))) : @locally_compact_space.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} congr_arg_kind)) (semiring.{0} (semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_138930 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_nnnorm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (has_nnnorm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_138931 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_138932 (h0 : functor.add_const (topological_space (mul_zero_class empty)) congr_arg_kind) : @t0_space.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_138933 (h0 : function.extfun Type topological_space) : @t1_space.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_138934 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_138935 (h0 : functor.add_const (topological_space (normed_linear_ordered_group unsigned)) congr_arg_kind) : @totally_separated_space.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_138936 (h0 : functor.comp topological_space boolean_algebra name) : @normal_space.{0} (boolean_algebra.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.{0} name h0)  := sorry --non-trivial
lemma new_lemma_138937 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_neg ennreal)) := sorry --non-trivial
lemma new_lemma_138938 (h0 : functor.add_const Prop (has_add (option pos))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_138939 (h0 : functor.add_const (topological_space (linear_ordered_field pos)) linarith.comp) : @discrete_topology.{0} (linear_ordered_field.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_138940 (h0 : functor.add_const (topological_space (omega_complete_partial_order empty)) empty) : @loc_path_connected_space.{0} (omega_complete_partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (omega_complete_partial_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_138941 (h0 : topological_space (semigroup (has_neg (has_neg (has_zero Type))))) : totally_separated_space (semigroup (has_neg (has_neg (has_zero Type)))) := sorry --non-trivial
lemma new_lemma_138942 (h0 : group (option (add_cancel_monoid pos))) : normalizer_condition (option (add_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_138943 (h0 : cancel_comm_monoid_with_zero (has_star pos)) : unique_factorization_monoid (has_star pos) := sorry --non-trivial
lemma new_lemma_138944 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_138945 (h0 : topological_space (generalized_boolean_algebra (has_neg (has_add (ordered_ring Type))))) : discrete_topology (generalized_boolean_algebra (has_neg (has_add (ordered_ring Type)))) := sorry --non-trivial
lemma new_lemma_138946 (h0 : functor.add_const (ring (normed_linear_ordered_group num)) congr_arg_kind) : @is_principal_ideal_ring.{0} (normed_linear_ordered_group.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (normed_linear_ordered_group.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_138947 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @strong_rank_condition.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_138948 (h0 : uniform_space (generalized_boolean_algebra real)) : separated_space (generalized_boolean_algebra real) := sorry --non-trivial
lemma new_lemma_138949 (h0 : ring (has_add (has_Inf (ordered_comm_monoid real)))) : is_domain (has_add (has_Inf (ordered_comm_monoid real))) := sorry --non-trivial
lemma new_lemma_138950 (h0 : topological_space (linear_ordered_semiring (semiring (semiring (semiring empty))))) : normal_space (linear_ordered_semiring (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_138951 (h1 : not (ring (has_compl string_imp) -> false)) : @strong_rank_condition.{0} (has_compl.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_138952 (h0 : uniform_space (has_append (has_nnnorm (has_nnnorm (has_nnnorm char))))) : complete_space (has_append (has_nnnorm (has_nnnorm (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_138953 (h0 : functor.add_const (semiring (has_zero linarith.comp)) linarith.comp) : @is_noetherian_ring.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (has_zero.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_138954 (h0 : topological_space (comm_monoid (semiring empty))) : discrete_topology (comm_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_138955 (h0 : topological_space (comm_group (semigroup unsigned))) : irreducible_space (comm_group (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_138956 (h0 : functor.add_const (complete_lattice (boolean_algebra Type)) (semigroup ennreal)) : @is_atomistic.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (boolean_algebra.{1} Type)) (semigroup.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_138957 (h0 : function.extfun Type (prod (has_Sup (semiring empty)))) : id_rel (function.extfun_app h0 (has_Sup (semiring empty))) := sorry --non-trivial
lemma new_lemma_138958 (h1 : not (complete_lattice (has_top fun_info) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_top.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_138959 (h0 : topological_space (semiring (semiring empty))) : normal_space (semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_138960 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_inter.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_inter.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_138961 (h0 : complete_lattice (add_cancel_monoid (ring Type))) : is_compactly_generated (add_cancel_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_138962 (h0 : filter (add_group (has_norm fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_138963 (h0 : fin has_zero.zero) : @is_compactly_generated.{0} (generalized_boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (complete_lattice.{0} (generalized_boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_138964 (h0 : topological_space (has_neg (normed_comm_ring Type))) : sequential_space (has_neg (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_138965 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_one.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} num))  := sorry --non-trivial
lemma new_lemma_138966 (h0 : topological_space (id (has_one num))) : preirreducible_space (id (has_one num)) := sorry --non-trivial
lemma new_lemma_138967 (h0 : functor.add_const (topological_space (has_to_string unsigned)) unsigned) : @totally_separated_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_138968 (h0 : ring (has_div (mul_one_class (mul_one_class enat)))) : strong_rank_condition (has_div (mul_one_class (mul_one_class enat))) := sorry --non-trivial
lemma new_lemma_138969 (h0 : functor.add_const (topological_space (left_cancel_monoid congr_arg_kind)) unsigned) : @topological_space.separable_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_138970 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (add_cancel_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_138971 (h0 : functor.add_const (topological_space (add_cancel_monoid empty)) empty) : @normal_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_138972 (h0 : not (topological_space (linear_ordered_comm_ring empty) -> false)) : @normal_space.{0} (linear_ordered_comm_ring.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_ring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_138973 (h0 : topological_space (complete_semilattice_Sup (has_top congr_arg_kind))) : irreducible_space (complete_semilattice_Sup (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_138974 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_138975 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (generalized_boolean_algebra.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (generalized_boolean_algebra.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_138976 (h0 : filter (has_edist (option empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_138977 (h0 : functor.add_const (function.extfun Type list) name) : palindrome (function.extfun_app (functor.add_const.run h0) (has_pos_part name)) := sorry --non-trivial
lemma new_lemma_138978 (h0 : functor.add_const (group (linear_ordered_field ennreal)) name) : @group.fg.{0} (linear_ordered_field.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (linear_ordered_field.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_138979 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) (has_to_string Type)) : @totally_disconnected_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_138980 (h0 : functor.add_const (ring (has_inter empty)) empty) : @strong_rank_condition.{0} (has_inter.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (has_inter.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_138981 (h0 : group (ordered_cancel_add_comm_monoid (option ennreal))) : normalizer_condition (ordered_cancel_add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_138982 (h0 : topological_space (has_nndist (option (mul_zero_class (mul_zero_class Type))))) : totally_disconnected_space (has_nndist (option (mul_zero_class (mul_zero_class Type)))) := sorry --non-trivial
lemma new_lemma_138983 (h0 : functor.add_const (topological_space (omega_complete_partial_order unsigned)) unsigned) : @t0_space.{0} (omega_complete_partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (omega_complete_partial_order.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_138984 (h0 : uniform_space (has_star (semiring (semiring num)))) : complete_space (has_star (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_138985 (h0 : fin has_zero.zero) : @is_simple_group.{0} (has_Inf.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (has_Inf.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_138986 (h1 : topological_space (uniform_space reducibility_hints)) (h2 : preorder (uniform_space reducibility_hints)) : order_topology (uniform_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_138987 (h0 : topological_space (left_cancel_semigroup num)) : totally_separated_space (left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_138988 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (left_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_138989 (h0 : functor.add_const (filter (has_add pos)) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_138990 (h0 : functor.add_const (ring (has_neg_part pos)) name) : @is_principal_ideal_ring.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_neg_part.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_138991 (h0 : group (complete_distrib_lattice (has_neg Type))) : is_simple_group (complete_distrib_lattice (has_neg Type)) := sorry --non-trivial
lemma new_lemma_138992 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} unsigned (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) unsigned)  := sorry --non-trivial
lemma new_lemma_138993 (h0 : monoid (id (random_gen (random_gen (has_top linarith.comp_source))))) : monoid.fg (id (random_gen (random_gen (has_top linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_138994 (h0 : functor.add_const (ordered_comm_monoid (comm_group linarith.comp)) pos) : @has_exists_mul_of_le.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (comm_group.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_138995 (h0 : topological_space (boolean_algebra (has_neg (has_pos_part (has_pos_part (has_Inf pos)))))) : t0_space (boolean_algebra (has_neg (has_pos_part (has_pos_part (has_Inf pos))))) := sorry --non-trivial
lemma new_lemma_138996 (h0 : topological_space (semigroup pos)) : preirreducible_space (semigroup pos) := sorry --non-trivial
lemma new_lemma_138997 (h0 : has_mem.mem group has_emptyc.emptyc) : @group.fg.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_138998 (h0 : function.extfun Type topological_space) : @t0_space.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_138999 (h0 : ordered_add_comm_monoid (canonically_ordered_monoid (sub_neg_monoid name))) : archimedean (canonically_ordered_monoid (sub_neg_monoid name)) := sorry --non-trivial
lemma new_lemma_139000 (h0 : functor.add_const (topological_space (generalized_boolean_algebra Type)) Type) : @totally_disconnected_space.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_139001 (h0 : function.extfun (Type 1) ordered_comm_monoid) : @has_exists_mul_of_le.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} h0 (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_139002 (h0 : group (has_zero (mul_one_class (has_neg linarith.comp)))) : is_simple_group (has_zero (mul_one_class (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_139003 (h0 : fin has_zero.zero) : @monoid.fg.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (monoid.{1} (ordered_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_139004 (h0 : ring (div_inv_monoid (random_gen (random_gen (has_ssubset to_additive.value_type))))) : is_domain (div_inv_monoid (random_gen (random_gen (has_ssubset to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_139005 (h0 : topological_space (with_one (has_ssubset fun_info))) : totally_disconnected_space (with_one (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_139006 (h0 : functor.add_const (ring (boolean_algebra Type)) environment.implicit_infer_kind) : @rank_condition.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_139007 (h0 : functor.add_const (semiring (add_cancel_monoid pos)) linarith.comp) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (add_cancel_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_139008 (h0 : complete_lattice (normed_group (has_inv fun_info))) : is_atomistic (normed_group (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_139009 (h1 : function.extfun Type add_group) : @is_add_cyclic.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h1 (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_139010 (h0 : pseudo_metric_space std_gen) (h1 : set std_gen) : metric.bounded h1 := sorry --non-trivial
lemma new_lemma_139011 (h0 : not (ring (uniform_space fun_info) -> false)) : @strong_rank_condition.{0} (uniform_space.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (uniform_space.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_139012 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (linear_ordered_comm_ring empty)) := sorry --non-trivial
lemma new_lemma_139013 (h0 : uniform_space (add_comm_monoid (has_neg name))) : separated_space (add_comm_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_139014 (h0 : functor.add_const (uniform_space (has_Inf pos)) (ring pos)) : @separated_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_Inf.{0} pos)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_139015 (h0 : functor.add_const (list (add_cancel_monoid linarith.comp)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_139016 (h1 : has_emptyc congr_arg_kind -> Prop) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) (has_emptyc.{0} congr_arg_kind) h1  := sorry --non-trivial
lemma new_lemma_139017 (h0 : set (simple_graph environment.projection_info)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_139018 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_neg_part name)) name) : @unique_factorization_monoid.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_neg_part.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_139019 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) linarith.comp) : @irreducible_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_139020 (h0 : topological_space (semigroup (add_comm_monoid Type))) : t0_space (semigroup (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_139021 (h0 : functor.add_const (group (finset linarith.comp)) (finset (finset (finset (has_Inf pos))))) : @normalizer_condition.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} linarith.comp)) (finset.{0} (finset.{0} (finset.{0} (has_Inf.{0} pos)))) h0)  := sorry --non-trivial
lemma new_lemma_139022 (h0 : topological_space (monoid_with_zero name)) : t1_space (monoid_with_zero name) := sorry --non-trivial
lemma new_lemma_139023 (h0 : functor.add_const (uniform_space (has_zero pos)) Type) : @separated_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_zero.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_139024 (h0 : topological_space (mul_one_class (mul_one_class std_gen))) : t0_space (mul_one_class (mul_one_class std_gen)) := sorry --non-trivial
lemma new_lemma_139025 (h0 : not (complete_lattice (normed_field (random_gen char)) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (normed_field.{0} (random_gen.{0} char)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_field.{0} (random_gen.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_139026 (h0 : topological_space (measurable_space.dynkin_system (option (option (option (option empty)))))) : irreducible_space (measurable_space.dynkin_system (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_139027 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_repr.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_repr.{0} num))  := sorry --non-trivial
lemma new_lemma_139028 (h0 : not (nat -> false)) (h1 : topological_space (nat.partition (classical.by_contradiction' h0))) : t0_space (nat.partition (classical.by_contradiction' h0)) := sorry --non-trivial
lemma new_lemma_139029 (h0 : has_mem.mem (has_top linarith.comp_source) has_emptyc.emptyc) : @monoid.fg.{0} (has_top.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type monoid.{0} (has_top.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_139030 (h0 : group (bin_tree (has_top (semiring empty)))) : normalizer_condition (bin_tree (has_top (semiring empty))) := sorry --non-trivial
lemma new_lemma_139031 (h1 : complete_lattice (random_gen to_additive.value_type)) : is_atomistic (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_139032 (h0 : function.extfun Type (functor.comp filter has_neg)) : countable_Inter_filter (functor.comp.run (function.extfun_app h0 pos)) := sorry --non-trivial
lemma new_lemma_139033 (h0 : functor.add_const (topological_space (canonically_ordered_monoid pos)) (has_add (has_add name))) : @preconnected_space.{0} (canonically_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_monoid.{0} pos)) (has_add.{0} (has_add.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_139034 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_139035 (h0 : ring (linear_ordered_cancel_comm_monoid (semiring empty))) : strong_rank_condition (linear_ordered_cancel_comm_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_139036 (h0 : complete_lattice (add_right_cancel_monoid (semiring (semiring num)))) : is_atomistic (add_right_cancel_monoid (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_139037 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (canonically_ordered_add_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_add_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_139038 (h0 : ring (has_nndist (finset linarith.comp))) : is_domain (has_nndist (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_139039 (h0 : topological_space (add_cancel_monoid (finset Type))) : topological_space.separable_space (add_cancel_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_139040 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_139041 (h0 : functor.comp ring mul_zero_class name) : @is_domain.{0} (mul_zero_class.{0} name) (@functor.comp.run.{0 0 0} ring.{0} mul_zero_class.{0} name h0)  := sorry --non-trivial
lemma new_lemma_139042 (h1 : topological_space (metric_space to_additive.value_type)) : path_connected_space (metric_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_139043 (h0 : filter (ring (has_to_string unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_139044 (h0 : topological_space (has_union (has_norm empty))) : normal_space (has_union (has_norm empty)) := sorry --non-trivial
lemma new_lemma_139045 (h0 : complete_lattice (simple_graph string.iterator_imp)) : is_compactly_generated (simple_graph string.iterator_imp) := sorry --non-trivial
lemma new_lemma_139046 (h0 : topological_space (boolean_algebra.core (comm_group Type))) : path_connected_space (boolean_algebra.core (comm_group Type)) := sorry --non-trivial
lemma new_lemma_139047 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @normalizer_condition.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_139048 (h0 h1 : multiset (has_nnnorm string.iterator_imp)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_139049 (h0 : function.extfun Type (functor.add_const (topological_space (ordered_comm_ring linarith.comp)))) : @t0_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_139050 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_139051 (h0 : complete_lattice (finset (option (option ennreal)))) : is_atomistic (finset (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_139052 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @topological_space.separable_space.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_139053 (h0 : topological_space (add_comm_monoid (has_neg (has_neg name)))) : irreducible_space (add_comm_monoid (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_139054 (h0 : topological_space (has_zero (has_to_string pos))) : t0_space (has_zero (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_139055 (h0 : add_monoid (complete_linear_order (semiring (semiring (semiring (semiring (semiring empty))))))) : add_monoid.fg (complete_linear_order (semiring (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_139056 (h0 : complete_lattice (non_assoc_semiring (option unsigned))) : complete_lattice.is_Sup_finite_compact (non_assoc_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_139057 (h0 : ring (has_compl (mul_one_class enat))) : strong_rank_condition (has_compl (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_139058 (h0 : topological_space (comm_ring (metric_space linarith.comp_source))) : path_connected_space (comm_ring (metric_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_139059 (h0 : not (ring (has_compl (denumerable linarith.ineq)) -> false)) : @is_domain.{0} (has_compl.{0} (denumerable.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} (denumerable.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_139060 (h0 : ordered_add_comm_monoid (plift (option unsigned))) : archimedean (plift (option unsigned)) := sorry --non-trivial
lemma new_lemma_139061 (h0 : group (has_inner (with_bot (has_bot (has_inv linarith.comp_source))) linarith.ineq)) : group.fg (has_inner (with_bot (has_bot (has_inv linarith.comp_source))) linarith.ineq) := sorry --non-trivial
lemma new_lemma_139062 (h0 : functor.add_const (function.extfun (Type 1) group) pos) : @normalizer_condition.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) pos h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_139063 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_139064 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (ordered_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_139065 (h0 : topological_space (add_cancel_monoid (ring (ring (ring linarith.comp))))) : totally_disconnected_space (add_cancel_monoid (ring (ring (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_139066 (h0 : semiring (has_Inf (has_pos_part name))) : is_noetherian_ring (has_Inf (has_pos_part name)) := sorry --non-trivial
lemma new_lemma_139067 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) environment.implicit_infer_kind) : @regular_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_139068 (h0 : semiring (boolean_algebra.core (option pos))) : is_noetherian_ring (boolean_algebra.core (option pos)) := sorry --non-trivial
lemma new_lemma_139069 (h0 : functor.add_const (list (add_cancel_monoid num)) num) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_139070 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_139071 (h0 : functor.add_const (function.extfun Type complete_lattice) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) linarith.comp h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_139072 (h0 : monoid (canonically_linear_ordered_monoid ennreal)) : monoid.fg (canonically_linear_ordered_monoid ennreal) := sorry --non-trivial
lemma new_lemma_139073 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (ordered_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_139074 (h0 : group (has_add (finset (has_add (finset pos))))) : group.fg (has_add (finset (has_add (finset pos)))) := sorry --non-trivial
lemma new_lemma_139075 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (semi_normed_comm_ring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semi_normed_comm_ring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_139076 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (linear_ordered_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_139077 (h0 : topological_space (left_cancel_monoid (semiring unsigned))) : normal_space (left_cancel_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_139078 (h1 : not (ring (linear_ordered_add_comm_group fun_info) -> false)) : @is_domain.{0} (linear_ordered_add_comm_group.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_add_comm_group.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_139079 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_139080 (h0 : group (cancel_monoid (has_add ennreal))) : is_cyclic (cancel_monoid (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_139081 (h0 : add_monoid (metric_space (semiring linarith.comp))) : add_monoid.fg (metric_space (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_139082 (h1 : add_group (nondiscrete_normed_field ereal)) : is_add_cyclic (nondiscrete_normed_field ereal) := sorry --non-trivial
lemma new_lemma_139083 (h0 : functor.add_const (add_group (add_cancel_monoid linarith.comp)) name) : @is_add_cyclic.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (add_cancel_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_139084 (h0 : topological_space (linear_ordered_comm_group_with_zero enat)) (h1 : add_group (linear_ordered_comm_group_with_zero enat)) : topological_add_group (linear_ordered_comm_group_with_zero enat) := sorry --non-trivial
lemma new_lemma_139085 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_139086 (h0 : topological_space (add_group unsigned)) : t0_space (add_group unsigned) := sorry --non-trivial
lemma new_lemma_139087 (h0 : ring (has_neg (mul_zero_class name))) : is_principal_ideal_ring (has_neg (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_139088 (h1 : topological_space (semi_normed_comm_ring (random_gen to_additive.value_type))) : t0_space (semi_normed_comm_ring (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_139089 (h0 : complete_lattice (has_top (random_gen (random_gen fun_info)))) : complete_lattice.is_Sup_finite_compact (has_top (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_139090 (h0 : functor.add_const (monoid (has_to_string pos)) (has_neg_part name)) : @monoid.fg.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (has_to_string.{0} pos)) (has_neg_part.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_139091 (h0 : functor.add_const (function.extfun Type group) Type) : @group.fg.{0} (has_add.{0} (has_neg.{0} name)) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (has_add.{0} (has_neg.{0} name)))  := sorry --non-trivial
lemma new_lemma_139092 (h0 : group (metric_space empty)) : is_cyclic (metric_space empty) := sorry --non-trivial
lemma new_lemma_139093 (h0 : topological_space (has_bot (option (option (option empty))))) : preirreducible_space (has_bot (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_139094 (h0 : filter (has_to_string (has_to_string (has_to_string (has_to_string pos))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_139095 (h0 : function.extfun Type (functor.add_const (function.extfun Type complete_lattice))) : @is_compactly_generated.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) empty (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type complete_lattice.{0})) h0 empty)) (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_139096 (h0 : topological_space (ring num)) : t1_space (ring num) := sorry --non-trivial
lemma new_lemma_139097 (h0 : complete_lattice (linear_ordered_semiring fun_info)) : is_compactly_generated (linear_ordered_semiring fun_info) := sorry --non-trivial
lemma new_lemma_139098 (h0 : finset (bin_tree num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_139099 (h0 : functor.add_const (group (preorder congr_arg_kind)) empty) : @is_cyclic.{0} (preorder.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (preorder.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_139100 (h0 : topological_space (semiring (has_top to_additive.value_type))) : totally_separated_space (semiring (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_139101 (h0 : functor.add_const (uniform_space (has_neg environment.implicit_infer_kind)) name) : @complete_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_neg.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_139102 (h0 : topological_space (has_nndist (has_Inf (has_Inf Type)))) : totally_disconnected_space (has_nndist (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_139103 (h0 : add_zero_class enat) (h1 : set (add_submonoid enat)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_139104 (h0 : functor.add_const (ring (linear_order congr_arg_kind)) empty) : @is_domain.{0} (linear_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (linear_order.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_139105 (h2 : set (add_comm_semigroup ereal -> add_comm_semigroup ereal)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_139106 (h0 : fin has_zero.zero) : @add_monoid.fg.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (add_monoid.{1} (comm_semigroup.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_139107 (h0 : functor.add_const (topological_space (finset linarith.comp)) (ring pos)) : @totally_disconnected_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_139108 (h0 : function.extfun (has_inv linarith.comp_source) (fun (x : has_inv linarith.comp_source), Prop)) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) (has_inv.{0} linarith.comp_source) (@function.extfun_app.{1 1} (has_inv.{0} linarith.comp_source) (λ (x : has_inv.{0} linarith.comp_source), Prop) h0)  := sorry --non-trivial
lemma new_lemma_139109 (h0 : ring (left_cancel_monoid (option (option (option (option empty)))))) : rank_condition (left_cancel_monoid (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_139110 (h0 : functor.add_const (topological_space (has_edist empty)) empty) : @locally_compact_space.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_139111 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (finset.{0} pos) (@matrix.vec_empty.{0} (add_group.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_139112 (h0 : topological_space (semigroup name)) : normal_space (semigroup name) := sorry --non-trivial
lemma new_lemma_139113 (h0 : ordered_comm_monoid (has_zero (ring pos))) : has_exists_mul_of_le (has_zero (ring pos)) := sorry --non-trivial
lemma new_lemma_139114 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) (has_Inf Type)) : @path_connected_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} pos)) (has_Inf.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_139115 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (has_sub.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_sub.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_139116 (h0 : add_group (linear_ordered_add_comm_group char)) : is_add_cyclic (linear_ordered_add_comm_group char) := sorry --non-trivial
lemma new_lemma_139117 (h0 : not (group (measure_theory.measure_space congr_arg_kind) -> false)) : @normalizer_condition.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (measure_theory.measure_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_139118 (h0 : semiring (has_neg_part (finset (boolean_algebra.core pos)))) : is_noetherian_ring (has_neg_part (finset (boolean_algebra.core pos))) := sorry --non-trivial
lemma new_lemma_139119 (h0 : complete_lattice (mul_zero_class (mul_zero_class name))) : complete_lattice.is_Sup_finite_compact (mul_zero_class (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_139120 (h0 : ring (has_top (has_ssubset (random_gen (random_gen (random_gen linarith.ineq)))))) : rank_condition (has_top (has_ssubset (random_gen (random_gen (random_gen linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_139121 (h0 : filter (comm_group (option (option (option pos))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_139122 (h0 : group (measurable_space congr_arg_kind)) : is_cyclic (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_139123 (h0 : ring (ring pos)) : is_principal_ideal_ring (ring pos) := sorry --non-trivial
lemma new_lemma_139124 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (simple_graph.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_139125 (h0 : ring (canonically_ordered_monoid real)) : strong_rank_condition (canonically_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_139126 (h0 : topological_space (left_cancel_monoid congr_arg_kind)) : topological_space.separable_space (left_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_139127 (h0 : topological_space (has_Inf (has_add pos))) : irreducible_space (has_Inf (has_add pos)) := sorry --non-trivial
lemma new_lemma_139128 (h0 : add_group (ordered_comm_ring (has_nnnorm linarith.ineq))) : is_add_cyclic (ordered_comm_ring (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_139129 (h1 : has_mem.mem (semiring linarith.ineq) has_emptyc.emptyc) : @is_compactly_generated.{0} (semiring.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (semiring.{0} linarith.ineq) h1)  := sorry --non-trivial
lemma new_lemma_139130 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) (has_add pos)) : @loc_path_connected_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_139131 (h0 : functor.add_const (cancel_comm_monoid_with_zero (linear_ordered_field ennreal)) ennreal) : @unique_factorization_monoid.{0} (linear_ordered_field.{0} ennreal) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (linear_ordered_field.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_139132 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (monoid.{0} num) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_139133 (h0 : ring (has_pos_part (has_add (has_Inf linarith.comp)))) : is_domain (has_pos_part (has_add (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_139134 (h0 : functor.add_const (monoid (boolean_algebra.core name)) name) : @monoid.fg.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (boolean_algebra.core.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_139135 (h0 : functor.add_const (finset (has_add linarith.comp)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_139136 (h0 : group (add_comm_semigroup enat)) (h1 : subgroup (add_comm_semigroup enat)) : subgroup.fg h1 := sorry --non-trivial
lemma new_lemma_139137 (h0 : functor.add_const (group (has_neg environment.implicit_infer_kind)) Type) : @is_simple_group.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (group.{0} (has_neg.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_139138 (h0 : filter (add_right_cancel_monoid (semiring congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_139139 (h0 : filter (finset (has_nndist pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_139140 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (dlist.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (dlist.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_139141 (h0 : topological_space (has_top (has_nnnorm (has_nnnorm fun_info)))) : t0_space (has_top (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_139142 (h0 : functor.add_const (list (has_add pos)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_139143 (h0 : fin has_zero.zero) : @discrete_topology.{0} (has_pos_part.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_pos_part.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_139144 (h0 : group (generalized_boolean_algebra (ring pos))) : group.fg (generalized_boolean_algebra (ring pos)) := sorry --non-trivial
lemma new_lemma_139145 (h0 : complete_lattice (option nnreal)) : is_compactly_generated (option nnreal) := sorry --non-trivial
lemma new_lemma_139146 (h0 : complete_lattice (has_nndist (option (option (option (option unsigned)))))) : is_compactly_generated (has_nndist (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_139147 (h0 : functor.comp complete_lattice canonically_ordered_comm_semiring pos) : @is_compactly_generated.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.comp.run.{0 0 0} complete_lattice.{0} canonically_ordered_comm_semiring.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_139148 (h0 : filter (add_cancel_monoid (pseudo_metric_space ennreal))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_139149 (h0 : function.extfun (finset Type) (has_mem.mem (with_one num))) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_one.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_139150 (h0 : topological_space (has_add (has_bot (boolean_algebra real)))) : t0_space (has_add (has_bot (boolean_algebra real))) := sorry --non-trivial
lemma new_lemma_139151 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} congr_arg_kind (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_139152 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_ordered_cancel_comm_monoid.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_cancel_comm_monoid.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_139153 (h0 : add_group (nondiscrete_normed_field char)) : is_add_cyclic (nondiscrete_normed_field char) := sorry --non-trivial
lemma new_lemma_139154 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_139155 (h0 : add_group (comm_ring (mul_one_class (random_gen reducibility_hints)))) : is_add_cyclic (comm_ring (mul_one_class (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_139156 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @loc_path_connected_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_139157 (h0 : complete_lattice (linear_ordered_semiring (has_top (random_gen linarith.comp)))) : is_compactly_generated (linear_ordered_semiring (has_top (random_gen linarith.comp))) := sorry --non-trivial
lemma new_lemma_139158 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (topological_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (topological_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_139159 (h0 : functor.add_const (function.extfun Type topological_space) (has_zero pos)) : @path_connected_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_zero.{0} pos) h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_139160 (h0 : add_monoid (has_star (option (option unsigned)))) : add_monoid.fg (has_star (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_139161 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_139162 (h0 : ring (has_pos_part (ordered_comm_monoid real))) : strong_rank_condition (has_pos_part (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_139163 (h0 : topological_space (has_to_string (mul_one_class (ring linarith.comp)))) : topological_space.separable_space (has_to_string (mul_one_class (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_139164 (h0 : not (topological_space (random_gen char) -> false)) (h1 : add_group (random_gen char)) : @topological_add_group.{0} (random_gen.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} char)) h0) h1  := sorry --non-trivial
lemma new_lemma_139165 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) (has_neg_part Type)) : @irreducible_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} linarith.comp)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_139166 (h0 : complete_lattice (normed_lattice_add_comm_group (sub_neg_monoid Type))) : is_compactly_generated (normed_lattice_add_comm_group (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_139167 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_139168 (h0 : ring (normed_group linarith.comp_source)) : is_domain (normed_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_139169 (h0 : add_group (distrib_lattice (random_gen string_imp))) : is_add_cyclic (distrib_lattice (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_139170 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_139171 (h0 : topological_space (dlist linarith.ineq)) : locally_compact_space (dlist linarith.ineq) := sorry --non-trivial
lemma new_lemma_139172 (h0 : list (left_cancel_semigroup (semiring unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_139173 (h0 : topological_space (with_one (has_nnnorm (has_nnnorm to_additive.value_type)))) : totally_disconnected_space (with_one (has_nnnorm (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_139174 (h0 : add_monoid (ring (has_add (has_add environment.implicit_infer_kind)))) : add_monoid.fg (ring (has_add (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_139175 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} empty (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) empty)  := sorry --non-trivial
lemma new_lemma_139176 (h0 : topological_space (canonically_ordered_monoid real)) : discrete_topology (canonically_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_139177 (h0 : not (cancel_comm_monoid_with_zero (complete_linear_order empty) -> false)) : @unique_factorization_monoid.{0} (complete_linear_order.{0} empty) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (complete_linear_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_139178 (h0 : group (with_one (with_bot (with_bot linarith.comp_source)))) : is_cyclic (with_one (with_bot (with_bot linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_139179 (h1 : function.extfun Type uniform_space) : @complete_space.{0} (random_gen.{0} string_imp) (@function.extfun_app.{2 1} Type uniform_space.{0} h1 (random_gen.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_139180 (h0 : group (comm_group (has_add (add_cancel_monoid pos)))) : is_simple_group (comm_group (has_add (add_cancel_monoid pos))) := sorry --non-trivial
lemma new_lemma_139181 (h0 : fin has_zero.zero) : @preconnected_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_139182 (h0 : not (has_mem.mem uniform_space has_emptyc.emptyc -> false)) : @complete_space.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) uniform_space.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_139183 (h0 : functor.comp topological_space comm_group environment.implicit_infer_kind) : @topological_space.separable_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_139184 (h0 : filter (distrib_lattice (has_norm linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_139185 (h0 : functor.add_const (uniform_space (has_pos_part linarith.comp)) pos) : @separated_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_pos_part.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_139186 (h0 : functor.add_const (add_group (has_neg_part linarith.comp)) Type) : @is_add_cyclic.{0} (has_neg_part.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_group.{0} (has_neg_part.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_139187 (h1 : group (has_one (semiring (semiring linarith.comp)))) : normalizer_condition (has_one (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_139188 (h0 : topological_space (complete_linear_order (semiring num))) : locally_compact_space (complete_linear_order (semiring num)) := sorry --non-trivial
lemma new_lemma_139189 (h0 : list (encodable char)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_139190 (h0 : has_neg (has_lt fun_info)) (h1 : measurable_space (has_lt fun_info)) : has_measurable_neg (has_lt fun_info) := sorry --non-trivial
lemma new_lemma_139191 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : totally_separated_space empty := sorry --non-trivial
lemma new_lemma_139192 (h0 : ring (has_append (denumerable linarith.comp_source))) : strong_rank_condition (has_append (denumerable linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_139193 (h1 : add_group (has_nnnorm ereal)) : is_add_cyclic (has_nnnorm ereal) := sorry --non-trivial
lemma new_lemma_139194 (h0 : topological_space (normed_ring (order_dual (option (option congr_arg_kind))))) : totally_separated_space (normed_ring (order_dual (option (option congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_139195 (h0 : add_monoid (has_one (has_union linarith.comp))) : add_monoid.fg (has_one (has_union linarith.comp)) := sorry --non-trivial
lemma new_lemma_139196 (h0 : add_group (id (semiring fun_info))) : is_add_cyclic (id (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_139197 (h0 : ordered_add_comm_monoid (partial_order (option unsigned))) : archimedean (partial_order (option unsigned)) := sorry --non-trivial
lemma new_lemma_139198 (h0 : complete_lattice (has_append (metric_space to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (has_append (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_139199 (h0 : topological_space (ordered_comm_ring (canonically_linear_ordered_monoid (has_Inf (has_Inf real))))) : irreducible_space (ordered_comm_ring (canonically_linear_ordered_monoid (has_Inf (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_139200 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_139201 (h0 : prod (ordered_ring unsigned) (ordered_ring unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_139202 (h0 : simple_graph (normed_field std_gen)) (h1 : normed_field std_gen) (h2 : sym2 (normed_field std_gen)) : simple_graph.incidence_set h0 h1 h2 := sorry --non-trivial
lemma new_lemma_139203 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @discrete_topology.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero))))))) (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_139204 (h1 : topological_space (with_one string_imp)) : totally_disconnected_space (with_one string_imp) := sorry --non-trivial
lemma new_lemma_139205 (h0 : function.extfun Type (functor.add_const (ordered_add_comm_monoid (partial_order empty)))) : @archimedean.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (partial_order.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} (partial_order.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_139206 (h1 : ring (with_bot linarith.ineq)) : rank_condition (with_bot linarith.ineq) := sorry --non-trivial
lemma new_lemma_139207 (h2 : topological_space (dlist to_additive.value_type)) : path_connected_space (dlist to_additive.value_type) := sorry --non-trivial
lemma new_lemma_139208 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_139209 (h0 : ordered_add_comm_monoid (ring (has_add (ring (has_add name))))) : archimedean (ring (has_add (ring (has_add name)))) := sorry --non-trivial
lemma new_lemma_139210 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_139211 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) environment.implicit_infer_kind) : @irreducible_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_139212 (h0 : function.extfun Type topological_space) : @t1_space.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_139213 (h0 : not (topological_space (with_bot fun_info) -> false)) : @path_connected_space.{0} (with_bot.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_139214 (h0 : topological_space (has_add (finset Type))) : preirreducible_space (has_add (finset Type)) := sorry --non-trivial
lemma new_lemma_139215 (h1 : add_group (add_cancel_comm_monoid (random_gen linarith.comp_source))) : is_add_cyclic (add_cancel_comm_monoid (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_139216 (h0 : ordered_comm_monoid (canonically_ordered_comm_semiring (comm_group unsigned))) : has_exists_mul_of_le (canonically_ordered_comm_semiring (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_139217 (h0 : ring (monoid_with_zero pos)) : is_domain (monoid_with_zero pos) := sorry --non-trivial
lemma new_lemma_139218 (h0 : ring (linear_ordered_field to_additive.value_type)) : is_domain (linear_ordered_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_139219 (h0 : monoid (has_to_string name)) : monoid.fg (has_to_string name) := sorry --non-trivial
lemma new_lemma_139220 (h0 : add_monoid (complete_distrib_lattice unsigned)) : add_monoid.fg (complete_distrib_lattice unsigned) := sorry --non-trivial
lemma new_lemma_139221 (h0 : functor.add_const (topological_space (semiring unsigned)) unsigned) : @locally_compact_space.{0} (semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_139222 (h0 : not (topological_space (measurable_space to_additive.value_type) -> false)) : @locally_compact_space.{0} (measurable_space.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_139223 (h0 : group (with_zero char)) : is_cyclic (with_zero char) := sorry --non-trivial
lemma new_lemma_139224 (h0 : functor.add_const (topological_space (comm_group name)) linarith.comp) : @t0_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_139225 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_139226 (h0 : topological_space (normed_group (linear_ordered_semiring (semiring (semiring congr_arg_kind))))) : locally_compact_space (normed_group (linear_ordered_semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_139227 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type monoid.{0} h0 (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_139228 (h0 : topological_space (canonically_linear_ordered_monoid (sub_neg_monoid pos))) : locally_compact_space (canonically_linear_ordered_monoid (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_139229 (h0 : monoid (normed_group (has_top congr_arg_kind))) : monoid.fg (normed_group (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_139230 (h0 : topological_space (has_top (random_gen string_imp))) : t0_space (has_top (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_139231 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (comm_group.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (comm_group.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_139232 (h0 : ring (semigroup (has_to_string name))) : is_domain (semigroup (has_to_string name)) := sorry --non-trivial
lemma new_lemma_139233 (h0 : functor.add_const (topological_space (semigroup Type)) (has_to_string pos)) : @preirreducible_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) (has_to_string.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_139234 (h1 : ring (mul_one_class (mul_one_class reducibility_hints))) : rank_condition (mul_one_class (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_139235 (h0 : complete_lattice (ordered_comm_semiring num)) : is_atomistic (ordered_comm_semiring num) := sorry --non-trivial
lemma new_lemma_139236 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_139237 (h0 : functor.add_const (function.extfun Type group) pos) : @is_cyclic.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_139238 (h0 : functor.add_const (topological_space (ordered_comm_monoid Type)) Type) : @preirreducible_space.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_139239 (h0 : functor.add_const (ordered_add_comm_monoid (comm_group linarith.comp)) linarith.comp) : @archimedean.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (comm_group.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_139240 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_139241 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_139242 (h0 : complete_lattice (filter congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (filter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_139243 (h0 : ring (semi_normed_comm_ring (has_nnnorm (has_lt (has_nnnorm linarith.ineq))))) : is_domain (semi_normed_comm_ring (has_nnnorm (has_lt (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_139244 (h3 : set (add_comm_semigroup string.iterator_imp -> enat)) : set.separates_points h3 := sorry --non-trivial
lemma new_lemma_139245 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_139246 (h0 : functor.comp (functor.comp uniform_space semigroup) option pos) : @complete_space.{0} (semigroup.{0} (option.{0} pos)) (@functor.comp.run.{0 0 0} uniform_space.{0} semigroup.{0} (option.{0} pos) (@functor.comp.run.{0 0 0} (functor.comp.{0 0 0} uniform_space.{0} semigroup.{0}) option.{0} pos (@functor.comp.run.{0 0 0} (functor.comp.{0 0 0} uniform_space.{0} semigroup.{0}) option.{0} pos h0)))  := sorry --non-trivial
lemma new_lemma_139247 (h0 : group (finset (option (mul_zero_class name)))) : is_simple_group (finset (option (mul_zero_class name))) := sorry --non-trivial
lemma new_lemma_139248 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_139249 (h0 : ring (measurable_space (random_gen num))) : is_domain (measurable_space (random_gen num)) := sorry --non-trivial
lemma new_lemma_139250 (h0 : functor.add_const (topological_space (boolean_algebra Type)) (finset (finset Type))) : @discrete_topology.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (boolean_algebra.{1} Type)) (finset.{1} (finset.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_139251 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @normal_space.{0} (measurable_space.{0} (has_top.{0} congr_arg_kind)) (@matrix.vec_empty.{0} (topological_space.{0} (measurable_space.{0} (has_top.{0} congr_arg_kind))) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_139252 (h0 : ring (distrib (metric_space linarith.comp_source))) : is_domain (distrib (metric_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_139253 (h0 : functor.add_const (topological_space (has_add Type)) Type) : @discrete_topology.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_add.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_139254 (h0 : uniform_space (has_Inf (comm_semigroup pos))) : separated_space (has_Inf (comm_semigroup pos)) := sorry --non-trivial
lemma new_lemma_139255 (h0 : uniform_space (has_to_string Type)) : complete_space (has_to_string Type) := sorry --non-trivial
lemma new_lemma_139256 (h0 : functor.comp topological_space cancel_monoid ennreal) : @locally_compact_space.{0} (cancel_monoid.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_139257 (h1 : topological_space (random_gen (random_gen (random_gen (random_gen (random_gen char)))))) : path_connected_space (random_gen (random_gen (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_139258 (h0 : functor.add_const (monoid (finset name)) pos) : @monoid.fg.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (finset.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_139259 (h0 : functor.add_const (uniform_space (has_to_string Type)) (ring pos)) : @complete_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_to_string.{1} Type)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_139260 (h0 : topological_space (random_gen (semiring num))) : locally_compact_space (random_gen (semiring num)) := sorry --non-trivial
lemma new_lemma_139261 (h0 : functor.add_const (ring (add_comm_monoid unsigned)) pos) : @rank_condition.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_139262 (h0 : topological_space (normed_group (has_inv (random_gen linarith.comp_source)))) : t0_space (normed_group (has_inv (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_139263 (h0 : functor.add_const (add_group (has_Inf name)) linarith.comp) : @is_add_cyclic.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (has_Inf.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_139264 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} h0 (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_139265 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_139266 (h0 : monoid (has_nndist (option (option (option ennreal))))) : monoid.fg (has_nndist (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_139267 (h0 : functor.add_const (topological_space (has_add unsigned)) name) : @topological_space.separable_space.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_139268 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_139269 (h0 : functor.add_const (complete_lattice (mul_zero_class unsigned)) num) : @complete_lattice.is_Sup_finite_compact.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (mul_zero_class.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_139270 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @normal_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_139271 (h0 : complete_lattice (add_right_cancel_monoid num)) : is_atomistic (add_right_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_139272 (h0 : topological_space (generalized_boolean_algebra (has_add Type))) : locally_compact_space (generalized_boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_139273 (h0 : complete_lattice (finset (add_cancel_monoid pos))) : is_atomistic (finset (add_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_139274 (h0 : complete_lattice (random_gen (random_gen string_imp))) : complete_lattice.is_Sup_finite_compact (random_gen (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_139275 (h0 : functor.add_const Prop (cancel_monoid (boolean_algebra environment.implicit_infer_kind))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_139276 (h1 : ring fun_info) : strong_rank_condition fun_info := sorry --non-trivial
lemma new_lemma_139277 (h0 : filter (ring (has_nndist (has_to_string environment.implicit_infer_kind)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_139278 (h0 : uniform_space (has_sub (has_top (has_norm unsigned)))) : separated_space (has_sub (has_top (has_norm unsigned))) := sorry --non-trivial
lemma new_lemma_139279 (h0 : group (with_zero (has_inv char))) : is_cyclic (with_zero (has_inv char)) := sorry --non-trivial
lemma new_lemma_139280 (h0 : topological_space (random_gen (random_gen num))) : totally_separated_space (random_gen (random_gen num)) := sorry --non-trivial
lemma new_lemma_139281 (h0 : add_monoid (free_add_monoid (semiring (semiring num)))) : add_monoid.fg (free_add_monoid (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_139282 (h0 : functor.add_const (filter (has_Inf linarith.comp)) (has_neg (has_neg Type))) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_139283 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (semiring.{0} (has_top.{0} (has_top.{0} (has_top.{0} (random_gen.{0} fun_info))))) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (semiring.{0} (has_top.{0} (has_top.{0} (has_top.{0} (random_gen.{0} fun_info))))))  := sorry --non-trivial
lemma new_lemma_139284 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_139285 (h0 : topological_space (bin_tree (semiring (semiring empty)))) : preirreducible_space (bin_tree (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_139286 (h0 : ordered_add_comm_monoid (normed_comm_ring unsigned)) : archimedean (normed_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_139287 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_139288 (h0 : functor.add_const (topological_space (has_neg name)) name) : @discrete_topology.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_139289 (h0 : functor.comp group cancel_monoid Type) : @is_cyclic.{1} (cancel_monoid.{1} Type) (@functor.comp.run.{1 1 1} group.{1} cancel_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_139290 (h0 : functor.add_const (semiring (normed_comm_ring linarith.comp)) Type) : @is_noetherian_ring.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (semiring.{0} (normed_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_139291 (h0 : topological_space (linear_ordered_semiring (semiring empty))) : locally_compact_space (linear_ordered_semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_139292 (h0 : ring (complete_semilattice_Sup (random_gen (has_norm (has_norm (has_top fun_info)))))) : rank_condition (complete_semilattice_Sup (random_gen (has_norm (has_norm (has_top fun_info))))) := sorry --non-trivial
lemma new_lemma_139293 (h1 : topological_space (complete_semilattice_Sup (has_top (has_top linarith.comp_source)))) : totally_separated_space (complete_semilattice_Sup (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_139294 (h0 : topological_space (ordered_comm_monoid (has_Inf Type))) : preirreducible_space (ordered_comm_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_139295 (h0 : functor.add_const (list (normed_comm_ring linarith.comp)) (finset pos)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_139296 (h0 : group (has_nnnorm (random_gen (has_compl (monoid_with_zero (has_nnnorm string_imp)))))) : is_cyclic (has_nnnorm (random_gen (has_compl (monoid_with_zero (has_nnnorm string_imp))))) := sorry --non-trivial
lemma new_lemma_139297 (h0 : complete_lattice linarith.ineq) : is_compactly_generated linarith.ineq := sorry --non-trivial
lemma new_lemma_139298 (h0 : ring (has_pos_part pos)) : is_domain (has_pos_part pos) := sorry --non-trivial
lemma new_lemma_139299 (h0 : topological_space (has_compl char)) (h1 : preorder (has_compl char)) : order_topology (has_compl char) := sorry --non-trivial
lemma new_lemma_139300 (h0 : list (boolean_algebra.core (option pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_139301 (h0 : topological_space (canonically_linear_ordered_monoid (option name))) : loc_path_connected_space (canonically_linear_ordered_monoid (option name)) := sorry --non-trivial
lemma new_lemma_139302 (h0 : topological_space (uniform_space to_additive.value_type)) : t0_space (uniform_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_139303 (h0 : complete_lattice (has_one (has_norm (has_norm congr_arg_kind)))) : complete_lattice.is_Sup_finite_compact (has_one (has_norm (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_139304 (h2 : ring num) : strong_rank_condition num := sorry --non-trivial
lemma new_lemma_139305 (h0 : group (has_nnnorm (random_gen (random_gen (has_nnnorm char))))) : is_cyclic (has_nnnorm (random_gen (random_gen (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_139306 (h0 : topological_space (cancel_monoid environment.implicit_infer_kind)) : discrete_topology (cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_139307 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_139308 (h0 : uniform_space linarith.comp_source) : complete_space linarith.comp_source := sorry --non-trivial
lemma new_lemma_139309 (h1 : filter reducibility_hints) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_139310 (h0 : topological_space (boolean_algebra (has_add name))) : topological_space.separable_space (boolean_algebra (has_add name)) := sorry --non-trivial
lemma new_lemma_139311 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (boolean_algebra real)) := sorry --non-trivial
lemma new_lemma_139312 (h0 : functor.add_const (group (complete_distrib_lattice congr_arg_kind)) empty) : @group.fg.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_139313 (h0 : not (has_mem.mem (linear_ordered_semiring congr_arg_kind) has_emptyc.emptyc -> false)) : @normalizer_condition.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type group.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} congr_arg_kind) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_139314 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (ordered_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_139315 (h0 : topological_space (has_one unsigned)) : topological_space.separable_space (has_one unsigned) := sorry --non-trivial
lemma new_lemma_139316 (h0 : group (boolean_algebra (semigroup Type))) : group.fg (boolean_algebra (semigroup Type)) := sorry --non-trivial
lemma new_lemma_139317 (h0 : ring (semigroup (semiring empty))) : rank_condition (semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_139318 (h0 : add_monoid (comm_group (ring pos))) : add_monoid.fg (comm_group (ring pos)) := sorry --non-trivial
lemma new_lemma_139319 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) complete_lattice.{0}) (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_139320 (h0 : topological_space (simple_graph (option empty))) : preconnected_space (simple_graph (option empty)) := sorry --non-trivial
lemma new_lemma_139321 (h0 : topological_space (has_to_string (finset unsigned))) : discrete_topology (has_to_string (finset unsigned)) := sorry --non-trivial
lemma new_lemma_139322 (h0 : semiring (has_neg (finset (has_neg linarith.comp)))) : is_noetherian_ring (has_neg (finset (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_139323 (h0 : functor.add_const (group (boolean_algebra.core name)) name) : @is_simple_group.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.core.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_139324 (h0 : functor.add_const (group (boolean_algebra Type)) (ring Type)) : @normalizer_condition.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (boolean_algebra.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_139325 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_139326 (h0 : functor.add_const (function.extfun (Type 1) ring) (ring Type)) : @rank_condition.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) (ring.{1} Type) h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_139327 (h0 : ordered_comm_monoid (has_to_string (comm_group Type))) : has_exists_mul_of_le (has_to_string (comm_group Type)) := sorry --non-trivial
lemma new_lemma_139328 (h0 : topological_space (generalized_boolean_algebra (has_Inf Type))) : normal_space (generalized_boolean_algebra (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_139329 (h0 : list (ordered_comm_monoid (has_Inf name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_139330 (h0 : topological_space (linear_ordered_add_comm_group (has_ssubset (has_norm (has_inv linarith.ineq))))) : t0_space (linear_ordered_add_comm_group (has_ssubset (has_norm (has_inv linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_139331 (h2 : add_group (normed_field char)) : is_add_cyclic (normed_field char) := sorry --non-trivial
lemma new_lemma_139332 (h0 : not (complete_lattice (with_one to_additive.value_type) -> false)) : @is_compactly_generated.{0} (with_one.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_one.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_139333 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring pos)) Type) : @is_domain.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (canonically_ordered_comm_semiring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_139334 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_139335 (h0 : group (uniform_space (metric_space to_additive.value_type))) : is_cyclic (uniform_space (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_139336 (h0 : ring (comm_group (cancel_monoid ennreal))) : strong_rank_condition (comm_group (cancel_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_139337 (h0 : fin has_zero.zero) : @preirreducible_space.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (normed_lattice_add_comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_139338 (h0 : ring reducibility_hints) : is_domain reducibility_hints := sorry --non-trivial
lemma new_lemma_139339 (h0 : topological_space (add_comm_semigroup (add_comm_semigroup enat))) : path_connected_space (add_comm_semigroup (add_comm_semigroup enat)) := sorry --non-trivial
lemma new_lemma_139340 (h0 : functor.add_const (ring (has_to_string name)) (ring environment.implicit_infer_kind)) : @rank_condition.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} name)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_139341 (h0 : topological_space (has_dist (option num))) : totally_disconnected_space (has_dist (option num)) := sorry --non-trivial
lemma new_lemma_139342 (h1 : function.extfun Type uniform_space) : @complete_space.{0} (@id.{2} Type linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} h1 (@id.{2} Type linarith.ineq))  := sorry --non-trivial
lemma new_lemma_139343 (h0 : finset (has_nndist (has_add linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_139344 (h0 : topological_space (id (semiring linarith.comp))) : t0_space (id (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_139345 (h0 : group (ordered_comm_monoid (has_nndist (finset Type)))) : group.fg (ordered_comm_monoid (has_nndist (finset Type))) := sorry --non-trivial
lemma new_lemma_139346 (h1 : not (add_group (has_append to_additive.value_type) -> false)) : @is_add_cyclic.{0} (has_append.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (add_group.{0} (has_append.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_139347 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_139348 (h0 : function.extfun Type (functor.comp topological_space has_to_string)) : @discrete_topology.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_to_string.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_139349 (h0 : topological_space (semigroup (ring name))) : preconnected_space (semigroup (ring name)) := sorry --non-trivial
lemma new_lemma_139350 (h0 : function.extfun Type group) : @is_cyclic.{0} (semigroup.{0} (comm_monoid.{0} (option.{0} pos))) (@function.extfun_app.{2 1} Type group.{0} h0 (semigroup.{0} (comm_monoid.{0} (option.{0} pos))))  := sorry --non-trivial
lemma new_lemma_139351 (h0 : set (has_div (mul_one_class (mul_one_class enat)))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_139352 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) linarith.comp) : @preconnected_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_139353 (h0 : functor.add_const (topological_space (has_Inf name)) name) : @t1_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_139354 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_139355 (h0 : uniform_space (has_neg (ring pos))) : separated_space (has_neg (ring pos)) := sorry --non-trivial
lemma new_lemma_139356 (h0 : cancel_comm_monoid_with_zero (has_pos_part (option empty))) : unique_factorization_monoid (has_pos_part (option empty)) := sorry --non-trivial
lemma new_lemma_139357 (h1 : uniform_space (has_lt string_imp)) : complete_space (has_lt string_imp) := sorry --non-trivial
lemma new_lemma_139358 (h0 : topological_space (option (has_norm empty))) : irreducible_space (option (has_norm empty)) := sorry --non-trivial
lemma new_lemma_139359 (h0 : complete_lattice (linear_ordered_add_comm_group_with_top unsigned)) : is_compactly_generated (linear_ordered_add_comm_group_with_top unsigned) := sorry --non-trivial
lemma new_lemma_139360 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_139361 (h0 : complete_lattice (measure_theory.measure_space (semiring empty))) : is_atomistic (measure_theory.measure_space (semiring empty)) := sorry --non-trivial
lemma new_lemma_139362 (h0 : group (cancel_monoid (option unsigned))) : is_cyclic (cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_139363 (h0 : not (topological_space (denumerable to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (denumerable.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_139364 (h2 : add_group (add_monoid (has_nnnorm (has_nnnorm to_additive.value_type)))) : is_add_cyclic (add_monoid (has_nnnorm (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_139365 (h0 : functor.add_const (filter (complete_distrib_lattice Type)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_139366 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_139367 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (measurable_space linarith.comp)) := sorry --non-trivial
lemma new_lemma_139368 (h0 : uniform_space (has_nnnorm char)) : complete_space (has_nnnorm char) := sorry --non-trivial
lemma new_lemma_139369 (h0 : ring (non_unital_non_assoc_semiring (distrib string.iterator_imp))) : rank_condition (non_unital_non_assoc_semiring (distrib string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_139370 (h0 : monoid (semigroup (finset pos))) : monoid.fg (semigroup (finset pos)) := sorry --non-trivial
lemma new_lemma_139371 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (pseudo_metric_space.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (pseudo_metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_139372 (h2 : ring (has_div linarith.ineq)) : rank_condition (has_div linarith.ineq) := sorry --non-trivial
lemma new_lemma_139373 (h0 : set (linear_ordered_comm_group_with_zero char)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_139374 (h0 : filter (group_with_zero num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_139375 (h0 : functor.add_const (complete_lattice (mul_zero_class num)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (mul_zero_class.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_139376 (h0 : list (finset (boolean_algebra (normed_comm_ring (mul_one_class Type))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_139377 (h0 : ring (has_neg (has_neg Type))) : strong_rank_condition (has_neg (has_neg Type)) := sorry --non-trivial
lemma new_lemma_139378 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_139379 (h0 : functor.add_const (finset (add_right_cancel_monoid unsigned)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_139380 (h0 : topological_space (has_add linarith.comp_source)) : path_connected_space (has_add linarith.comp_source) := sorry --non-trivial
lemma new_lemma_139381 (h1 : group (complete_semilattice_Sup string_imp)) : normalizer_condition (complete_semilattice_Sup string_imp) := sorry --non-trivial
lemma new_lemma_139382 (h0 : topological_space (ordered_comm_ring (has_neg name))) : preirreducible_space (ordered_comm_ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_139383 (h0 : add_group (mul_zero_class (finset environment.implicit_infer_kind))) : is_add_cyclic (mul_zero_class (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_139384 (h0 : functor.comp topological_space ring pos) : @totally_separated_space.{0} (ring.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_139385 (h0 : topological_space (mul_zero_class (semiring (semiring num)))) : irreducible_space (mul_zero_class (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_139386 (h0 : monoid (linear_ordered_semiring (random_gen linarith.comp_source))) : monoid.fg (linear_ordered_semiring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_139387 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_139388 (h0 : functor.add_const (ordered_add_comm_monoid (has_add Type)) (ring pos)) : @archimedean.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (has_add.{1} Type)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_139389 (h0 : function.extfun Type group) : @is_cyclic.{0} (omega_complete_partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (omega_complete_partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_139390 (h0 : functor.add_const (ordered_add_comm_monoid (pseudo_metric_space ennreal)) ennreal) : @archimedean.{0} (pseudo_metric_space.{0} ennreal) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (pseudo_metric_space.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_139391 (h0 : finset (generalized_boolean_algebra (ordered_comm_ring Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_139392 (h0 : topological_space (has_nndist (option (mul_zero_class (mul_zero_class ennreal))))) : topological_space.separable_space (has_nndist (option (mul_zero_class (mul_zero_class ennreal)))) := sorry --non-trivial
lemma new_lemma_139393 (h0 : list (normed_comm_ring (finset Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_139394 (h0 : list (boolean_algebra (has_add linarith.comp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_139395 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_principal_ideal_ring.{0} (generalized_boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (generalized_boolean_algebra.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_139396 (h0 : topological_space (has_neg (option (option (option pos))))) : preconnected_space (has_neg (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_139397 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_139398 (h0 : add_group (uniform_space (mul_one_class string.iterator_imp))) : is_add_cyclic (uniform_space (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_139399 (h0 : topological_space (encodable (comm_ring to_additive.value_type))) : t0_space (encodable (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_139400 (h0 : functor.add_const (function.extfun Type semiring) pos) : @is_noetherian_ring.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) pos h0) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_139401 (h0 : topological_space (has_pos_part (has_neg (has_add Type)))) : normal_space (has_pos_part (has_neg (has_add Type))) := sorry --non-trivial
lemma new_lemma_139402 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_139403 (h0 : complete_lattice (has_nndist (linear_ordered_comm_group ennreal))) : complete_lattice.is_Sup_finite_compact (has_nndist (linear_ordered_comm_group ennreal)) := sorry --non-trivial
lemma new_lemma_139404 (h0 : function.extfun Type (functor.add_const (function.extfun Type topological_space))) : @irreducible_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type topological_space.{0})) h0 environment.implicit_infer_kind)) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_139405 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_139406 (h0 : ring (add_semigroup (has_bot (option empty)))) : is_principal_ideal_ring (add_semigroup (has_bot (option empty))) := sorry --non-trivial
lemma new_lemma_139407 (h0 : topological_space (ordered_comm_ring (has_bot real))) : t1_space (ordered_comm_ring (has_bot real)) := sorry --non-trivial
lemma new_lemma_139408 (h0 : topological_space (has_nndist (has_add (has_add pos)))) : t1_space (has_nndist (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_139409 (h0 : not (complete_lattice (with_bot linarith.ineq) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_bot.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_139410 (h0 h1 : multiset (has_le (mul_one_class char))) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_139411 (h0 : complete_lattice (option num)) : complete_lattice.is_Sup_finite_compact (option num) := sorry --non-trivial
lemma new_lemma_139412 (h0 : complete_lattice (with_zero linarith.ineq)) : complete_lattice.is_Sup_finite_compact (with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_139413 (h0 : functor.add_const (topological_space (linear_ordered_comm_group empty)) (option unsigned)) : @preconnected_space.{0} (linear_ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_group.{0} empty)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_139414 (h0 : function.extfun Type add_monoid) (h1 : has_one (mul_zero_class ennreal)) : @char_zero.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (mul_zero_class.{0} ennreal)) h1  := sorry --non-trivial
lemma new_lemma_139415 (h0 : function.extfun Type topological_space) : @normal_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_139416 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) Type) : @normal_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_139417 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (has_nnnorm.{0} int) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_nnnorm.{0} int))  := sorry --non-trivial
lemma new_lemma_139418 (h0 : group (has_nndist (has_neg (has_neg (has_neg pos))))) : group.fg (has_nndist (has_neg (has_neg (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_139419 (h0 : topological_space (complete_distrib_lattice linarith.comp)) : discrete_topology (complete_distrib_lattice linarith.comp) := sorry --non-trivial
lemma new_lemma_139420 (h0 : functor.add_const (ring (ordered_comm_ring real)) pos) : @strong_rank_condition.{0} (ordered_comm_ring.{0} real) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} real)) pos h0)  := sorry --non-trivial
lemma new_lemma_139421 (h0 : topological_space (random_gen (semiring congr_arg_kind))) : totally_disconnected_space (random_gen (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_139422 (h0 : topological_space (add_cancel_monoid (has_add linarith.comp))) : sequential_space (add_cancel_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_139423 (h0 : functor.add_const (ring (ordered_ring empty)) num) : @rank_condition.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (ordered_ring.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_139424 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) pos) : @totally_separated_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_139425 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring name)) linarith.comp) : @discrete_topology.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_139426 (h0 : topological_space (add_comm_monoid (has_neg_part (has_neg (ring linarith.comp))))) : irreducible_space (add_comm_monoid (has_neg_part (has_neg (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_139427 (h0 : functor.add_const (finset (finset Type)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_139428 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm empty))) : @group.fg.{0} (has_norm.{0} empty) (@finset.pi.empty.{1 0} Type group.{0} (has_norm.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_139429 (h0 : function.extfun Type group) : @is_cyclic.{0} (complete_semilattice_Sup.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_semilattice_Sup.{0} num))  := sorry --non-trivial
lemma new_lemma_139430 (h2 : ring (add_monoid (add_monoid (has_inv to_additive.value_type)))) : rank_condition (add_monoid (add_monoid (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_139431 (h0 : topological_space (has_bot (option (has_bot (option unsigned)))) -> Prop) (h1 : Exists (fun (x : topological_space (has_bot (option (has_bot (option unsigned))))), h0 x)) : @normal_space.{0} (has_bot.{0} (option.{0} (has_bot.{0} (option.{0} unsigned)))) (@classical.some.{1} (topological_space.{0} (has_bot.{0} (option.{0} (has_bot.{0} (option.{0} unsigned))))) h0 h1)  := sorry --non-trivial
lemma new_lemma_139432 (h0 : functor.add_const (function.extfun (Type 1) ring) (has_neg linarith.comp)) : @is_principal_ideal_ring.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) (has_neg.{0} linarith.comp) h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_139433 (h0 : add_group (has_ssubset (has_nnnorm (has_nnnorm linarith.ineq)))) : is_add_cyclic (has_ssubset (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_139434 (h0 : function.extfun (finset Type) (has_mem.mem (has_top empty))) : @discrete_topology.{0} (has_top.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_139435 (h0 : topological_space (has_bot real)) : totally_disconnected_space (has_bot real) := sorry --non-trivial
lemma new_lemma_139436 (h0 : ring (normed_linear_ordered_group num)) : is_domain (normed_linear_ordered_group num) := sorry --non-trivial
lemma new_lemma_139437 (h0 : not (group (has_norm linarith.comp) -> false)) : @normalizer_condition.{0} (has_norm.{0} linarith.comp) (@classical.by_contradiction'.{1} (group.{0} (has_norm.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_139438 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) (has_neg name)) : @preconnected_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_139439 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_139440 (h0 : functor.add_const (topological_space (has_neg Type)) name) : @t1_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_139441 (h0 : ring (has_norm fun_info)) (h1 : function.extfun Type uniform_space) : @complete_space.{0} (@subring.{0} (has_norm.{0} fun_info) h0) (@function.extfun_app.{2 1} Type uniform_space.{0} h1 (@subring.{0} (has_norm.{0} fun_info) h0))  := sorry --non-trivial
lemma new_lemma_139442 (h0 : functor.add_const (topological_space (left_cancel_monoid unsigned)) congr_arg_kind) : @totally_separated_space.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_139443 (h0 : topological_space (partial_order (semiring (semiring congr_arg_kind)))) : totally_separated_space (partial_order (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_139444 (h0 : topological_space (option (semiring (semiring (semiring (semiring empty)))))) : totally_separated_space (option (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_139445 (h0 : function.extfun Type group) : @group.fg.{0} (topological_space.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (topological_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_139446 (h0 : fin has_zero.zero) : @complete_space.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (has_bot.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_139447 (h0 : topological_space (has_inter num)) : preirreducible_space (has_inter num) := sorry --non-trivial
lemma new_lemma_139448 (h0 : ring (boolean_algebra.core (finset pos))) : strong_rank_condition (boolean_algebra.core (finset pos)) := sorry --non-trivial
lemma new_lemma_139449 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_139450 (h1 : add_group (ordered_comm_monoid to_additive.value_type)) : is_add_cyclic (ordered_comm_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_139451 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_139452 (h0 : semiring (has_Inf (has_Inf pos))) : is_noetherian_ring (has_Inf (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_139453 (h0 : not (topological_space (complete_semilattice_Sup empty) -> false)) : @preirreducible_space.{0} (complete_semilattice_Sup.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_139454 (h0 : semiring (bin_tree (semiring (semiring congr_arg_kind)))) : is_noetherian_ring (bin_tree (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_139455 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} h0 (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_139456 (h0 : not (ring (has_union linarith.comp) -> false)) : @rank_condition.{0} (has_union.{0} linarith.comp) (@classical.by_contradiction'.{1} (ring.{0} (has_union.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_139457 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @totally_separated_space.{0} (@id.{2} Type linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (@id.{2} Type linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_139458 (h0 : topological_space (dlist linarith.comp_source)) (h1 : preorder (dlist linarith.comp_source)) : order_topology (dlist linarith.comp_source) := sorry --non-trivial
lemma new_lemma_139459 (h0 : topological_space (monoid empty)) : loc_path_connected_space (monoid empty) := sorry --non-trivial
lemma new_lemma_139460 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (left_cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_139461 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_139462 (h0 : ring (semi_normed_comm_ring (random_gen linarith.comp_source))) : strong_rank_condition (semi_normed_comm_ring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_139463 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_139464 (h0 : add_group (random_gen (semiring (semiring (semiring congr_arg_kind))))) : is_add_cyclic (random_gen (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_139465 (h0 : functor.add_const (filter (finset linarith.comp)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_139466 (h0 : semiring (has_neg ennreal)) : is_noetherian_ring (has_neg ennreal) := sorry --non-trivial
lemma new_lemma_139467 (h0 : add_monoid (ordered_cancel_add_comm_monoid num)) : add_monoid.fg (ordered_cancel_add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_139468 (h0 : functor.add_const (topological_space (has_to_string environment.implicit_infer_kind)) name) : @locally_compact_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_139469 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) unsigned) : @discrete_topology.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_139470 (h0 : functor.add_const (function.extfun (Type 1) semiring) Type) : @is_noetherian_ring.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) semiring.{1}) Type h0) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_139471 (h0 : complete_lattice (left_cancel_semigroup (preorder num))) : is_atomistic (left_cancel_semigroup (preorder num)) := sorry --non-trivial
lemma new_lemma_139472 (h0 : add_monoid (has_add (ordered_comm_monoid real))) : add_monoid.fg (has_add (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_139473 (h0 : add_group (add_comm_semigroup (mul_one_class (add_comm_semigroup enat)))) : is_add_cyclic (add_comm_semigroup (mul_one_class (add_comm_semigroup enat))) := sorry --non-trivial
lemma new_lemma_139474 (h0 : prod environment.projection_info environment.projection_info) : set.diagonal environment.projection_info h0 := sorry --non-trivial
lemma new_lemma_139475 (h0 : not (with_bot (topological_space (has_nnnorm fun_info)) -> false)) (h1 : ne (classical.by_contradiction' h0) has_bot.bot) : @path_connected_space.{0} (has_nnnorm.{0} fun_info) (@with_bot.unbot.{0} (topological_space.{0} (has_nnnorm.{0} fun_info)) (@classical.by_contradiction'.{1} (with_bot.{0} (topological_space.{0} (has_nnnorm.{0} fun_info))) h0) h1)  := sorry --non-trivial
lemma new_lemma_139476 (h0 : not (topological_space (with_bot congr_arg_kind) -> false)) : @normal_space.{0} (with_bot.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_139477 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_139478 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) pos) : @totally_separated_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_139479 (h0 : group (ring (normed_comm_ring Type))) : normalizer_condition (ring (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_139480 (h0 : functor.add_const (topological_space (has_nndist name)) name) : @loc_path_connected_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_139481 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @sequential_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_139482 (h0 : functor.add_const (function.extfun Type complete_lattice) (option (option pos))) : @is_compactly_generated.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) (option.{0} (option.{0} pos)) h0) (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_139483 (h0 : topological_space (has_nndist (has_to_string (has_add pos)))) : preirreducible_space (has_nndist (has_to_string (has_add pos))) := sorry --non-trivial
lemma new_lemma_139484 (h0 : real -> real -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_139485 (h0 : function.extfun (Type -> Type) (function.extfun Type)) (h1 : not (has_sub num -> false)) : @is_top.{0} (has_sub.{0} num) (@function.extfun_app.{2 1} Type has_le.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 has_le.{0}) (has_sub.{0} num)) (@classical.by_contradiction'.{1} (has_sub.{0} num) h1)  := sorry --non-trivial
lemma new_lemma_139486 (h0 : group (has_ssubset (random_gen fun_info))) : is_cyclic (has_ssubset (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_139487 (h2 : topological_space (has_nnnorm enat)) : totally_disconnected_space (has_nnnorm enat) := sorry --non-trivial
lemma new_lemma_139488 (h0 : preorder environment.implicit_infer_kind) (h1 : add_group (omega_complete_partial_order.chain environment.implicit_infer_kind)) : is_add_cyclic (omega_complete_partial_order.chain environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_139489 (h0 : ring (boolean_algebra.core (boolean_algebra.core name))) : rank_condition (boolean_algebra.core (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_139490 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (comm_semigroup.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (comm_semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_139491 (h0 : topological_space (bin_tree (has_top linarith.comp_source))) : path_connected_space (bin_tree (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_139492 (h0 : group (has_add (has_add (has_add pos)))) : is_simple_group (has_add (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_139493 (h0 : list (complete_linear_order empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_139494 (h0 : functor.add_const (function.extfun Type group) Type) : @normalizer_condition.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_139495 (h0 : not (function.extfun Type topological_space -> false)) : normal_space empty := sorry --non-trivial
lemma new_lemma_139496 (h0 : ordered_comm_monoid (simple_graph (has_add (has_add pos)))) : has_exists_mul_of_le (simple_graph (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_139497 (h0 : topological_space (linear_ordered_comm_monoid_with_zero unsigned)) : topological_space.separable_space (linear_ordered_comm_monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_139498 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_139499 (h0 : not (group (has_nnnorm fun_info) -> false)) : @is_cyclic.{0} (has_nnnorm.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (has_nnnorm.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_139500 (h0 : functor.comp topological_space complete_distrib_lattice name) : @preirreducible_space.{0} (complete_distrib_lattice.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} name h0)  := sorry --non-trivial
lemma new_lemma_139501 (h1 : ring (metric_space linarith.comp_source)) : strong_rank_condition (metric_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_139502 (h1 : topological_space (has_emptyc (random_gen (with_bot congr_arg_kind)))) : locally_compact_space (has_emptyc (random_gen (with_bot congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_139503 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_139504 (h0 : functor.add_const (ring (omega_complete_partial_order empty)) empty) : @strong_rank_condition.{0} (omega_complete_partial_order.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (omega_complete_partial_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_139505 (h0 : topological_space (add_comm_semigroup (has_neg char))) : totally_disconnected_space (add_comm_semigroup (has_neg char)) := sorry --non-trivial
lemma new_lemma_139506 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) linarith.comp) : @loc_path_connected_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_139507 (h0 : set (canonically_ordered_add_monoid char -> linarith.ineq)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_139508 (h0 : fin has_zero.zero) : @normal_space.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_139509 (h0 : has_mem.mem (semiring linarith.comp) has_emptyc.emptyc) : @totally_separated_space.{0} (semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_139510 (h0 : ring (has_nndist (option ennreal))) : is_domain (has_nndist (option ennreal)) := sorry --non-trivial
lemma new_lemma_139511 (h0 : ring (comm_group (has_to_string (has_to_string name)))) : rank_condition (comm_group (has_to_string (has_to_string name))) := sorry --non-trivial
lemma new_lemma_139512 (h0 : functor.add_const (list (finset Type)) (has_neg linarith.comp)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_139513 (h0 : monoid (pseudo_metric_space num)) : monoid.fg (pseudo_metric_space num) := sorry --non-trivial
lemma new_lemma_139514 (h0 : function.extfun Type topological_space) : @normal_space.{0} (random_gen.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_139515 (h0 : uniform_space (semiring (has_top num))) : separated_space (semiring (has_top num)) := sorry --non-trivial
lemma new_lemma_139516 (h0 : not (ring (fintype fun_info) -> false)) : @strong_rank_condition.{0} (fintype.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (fintype.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_139517 (h0 : topological_space (linear_ordered_comm_group (option ennreal))) : preconnected_space (linear_ordered_comm_group (option ennreal)) := sorry --non-trivial
lemma new_lemma_139518 (h0 : topological_space (linear_order (option (option (option (option unsigned)))))) : normal_space (linear_order (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_139519 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (omega_complete_partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (omega_complete_partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_139520 (h0 : function.extfun (Type 1) uniform_space) : @separated_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_139521 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (comm_monoid_with_zero unsigned)) := sorry --non-trivial
lemma new_lemma_139522 (h0 : functor.add_const (topological_space (ordered_ring empty)) congr_arg_kind) : @topological_space.separable_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_139523 (h0 : not (topological_space ennreal -> false)) : path_connected_space ennreal := sorry --non-trivial
lemma new_lemma_139524 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} h0 (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_139525 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (has_nnnorm.{0} char) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_nnnorm.{0} char))  := sorry --non-trivial
lemma new_lemma_139526 (h0 : uniform_space (has_append (denumerable (denumerable reducibility_hints)))) : complete_space (has_append (denumerable (denumerable reducibility_hints))) := sorry --non-trivial
lemma new_lemma_139527 (h0 : topological_space (has_pos_part (has_add (sub_neg_monoid Type)))) : sequential_space (has_pos_part (has_add (sub_neg_monoid Type))) := sorry --non-trivial
lemma new_lemma_139528 (h0 : not (uniform_space (has_ssubset (has_lt linarith.ineq)) -> false)) : @complete_space.{0} (has_ssubset.{0} (has_lt.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_ssubset.{0} (has_lt.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_139529 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_139530 (h0 : group (add_cancel_monoid name)) : normalizer_condition (add_cancel_monoid name) := sorry --non-trivial
lemma new_lemma_139531 (h1 : ring (denumerable (random_gen (random_gen to_additive.value_type)))) : is_domain (denumerable (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_139532 (h0 : complete_lattice (has_neg (has_nndist name))) : complete_lattice.is_Sup_finite_compact (has_neg (has_nndist name)) := sorry --non-trivial
lemma new_lemma_139533 (h0 : topological_space (linear_ordered_comm_group num)) : irreducible_space (linear_ordered_comm_group num) := sorry --non-trivial
lemma new_lemma_139534 (h0 : functor.add_const (topological_space (simple_graph pos)) Type) : @topological_space.separable_space.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (simple_graph.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_139535 (h0 : functor.add_const (topological_space (has_edist empty)) empty) : @discrete_topology.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_139536 (h0 : uniform_space (comm_group ennreal)) : complete_space (comm_group ennreal) := sorry --non-trivial
lemma new_lemma_139537 (h0 : topological_space (monoid pos)) : irreducible_space (monoid pos) := sorry --non-trivial
lemma new_lemma_139538 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) environment.implicit_infer_kind) : @discrete_topology.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_139539 (h0 : topological_space (id (semiring linarith.comp))) : discrete_topology (id (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_139540 (h0 : filter (comm_ring (has_nnnorm linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_139541 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) Type) : @totally_disconnected_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_139542 (h0 : ring (linear_ordered_field ennreal)) : is_domain (linear_ordered_field ennreal) := sorry --non-trivial
lemma new_lemma_139543 (h0 : filter (has_neg (has_neg (has_neg (has_Inf Type))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_139544 (h0 : ring (has_compl (random_gen (random_gen to_additive.value_type)))) : rank_condition (has_compl (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_139545 (h0 : topological_space (normed_lattice_add_comm_group real)) : discrete_topology (normed_lattice_add_comm_group real) := sorry --non-trivial
lemma new_lemma_139546 (h0 : topological_space (id (has_norm (has_norm linarith.comp)))) : totally_disconnected_space (id (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_139547 (h0 : topological_space (has_le to_additive.value_type)) (h1 : preorder (has_le to_additive.value_type)) : order_topology (has_le to_additive.value_type) := sorry --non-trivial
lemma new_lemma_139548 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_139549 (h0 : functor.add_const (function.extfun Type list) (add_comm_monoid pos)) : list.nodup (function.extfun_app (functor.add_const.run h0) (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_139550 (h0 : topological_space (has_compl (has_compl enat))) : t0_space (has_compl (has_compl enat)) := sorry --non-trivial
lemma new_lemma_139551 (h0 : functor.add_const (function.extfun (Type 1) group) name) : @group.fg.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) name h0) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_139552 (h0 : group (has_neg (has_neg (has_Inf Type)))) : is_cyclic (has_neg (has_neg (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_139553 (h0 : functor.add_const (topological_space (has_neg Type)) name) : @discrete_topology.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_139554 (h0 : functor.add_const (uniform_space (ring Type)) environment.implicit_infer_kind) : @separated_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (ring.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_139555 (h0 : has_mem.mem (normed_group linarith.ineq) has_emptyc.emptyc) : @path_connected_space.{0} (normed_group.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_139556 (h0 : complete_lattice (topological_space (comm_ring (has_nnnorm fun_info)))) : is_compactly_generated (topological_space (comm_ring (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_139557 (h0 : ring (has_one (semiring (semiring (semiring fun_info))))) : is_domain (has_one (semiring (semiring (semiring fun_info)))) := sorry --non-trivial
lemma new_lemma_139558 (h0 : functor.add_const (ring (has_neg_part Type)) linarith.comp) : @is_domain.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_neg_part.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_139559 (h0 : functor.add_const (function.extfun Type topological_space) name) : @totally_disconnected_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_139560 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (complete_distrib_lattice pos)) := sorry --non-trivial
lemma new_lemma_139561 (h0 : function.extfun Type topological_space) : @t1_space.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_139562 (h0 : functor.add_const (ring (has_Inf Type)) Type) : @is_domain.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (has_Inf.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_139563 (h0 : topological_space (has_Inf (has_add pos))) : preirreducible_space (has_Inf (has_add pos)) := sorry --non-trivial
lemma new_lemma_139564 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} h0 (lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_139565 (h0 : functor.comp topological_space pseudo_metric_space pos) : @preirreducible_space.{0} (pseudo_metric_space.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} pseudo_metric_space.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_139566 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_139567 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_139568 (h0 : list (has_norm (has_nnnorm (has_nnnorm to_additive.value_type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_139569 (h0 : topological_space (finset (has_to_string name))) : t1_space (finset (has_to_string name)) := sorry --non-trivial
lemma new_lemma_139570 (h0 : Prop) (h1 : not (setoid (id (id h0)) -> false)) : quotient (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_139571 (h0 : ordered_add_comm_monoid (simple_graph (option (option (has_dist (option empty)))))) : archimedean (simple_graph (option (option (has_dist (option empty))))) := sorry --non-trivial
lemma new_lemma_139572 (h0 : topological_space (ordered_comm_ring (boolean_algebra.core linarith.comp))) : loc_path_connected_space (ordered_comm_ring (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_139573 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_add_cyclic.{0} (@id.{2} Type string_imp) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) add_group.{0}) (@id.{2} Type string_imp))  := sorry --non-trivial
lemma new_lemma_139574 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (complete_distrib_lattice.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_139575 (h0 : has_zero (has_zero num) -> Prop) : zzz_forall h0 := sorry --non-trivial
lemma new_lemma_139576 (h0 : uniform_space (has_to_string (ring linarith.comp))) : separated_space (has_to_string (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_139577 (h0 : semiring (sub_neg_monoid Type)) : is_noetherian_ring (sub_neg_monoid Type) := sorry --non-trivial
lemma new_lemma_139578 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (canonically_ordered_comm_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_139579 (h0 : add_monoid (partial_order (semiring unsigned))) : add_monoid.fg (partial_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_139580 (h0 : topological_space (complete_semilattice_Sup (semiring (semiring congr_arg_kind)))) : irreducible_space (complete_semilattice_Sup (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_139581 (h0 : group (with_one empty)) : group.fg (with_one empty) := sorry --non-trivial
lemma new_lemma_139582 (h0 : filter (has_neg (normed_comm_ring name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_139583 (h0 : functor.add_const (function.extfun Type filter) Type) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_139584 (h0 : not (add_group (comm_ring string_imp) -> false)) : @is_add_cyclic.{0} (comm_ring.{0} string_imp) (@classical.by_contradiction'.{1} (add_group.{0} (comm_ring.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_139585 (h0 : functor.add_const (topological_space (partial_order num)) empty) : @totally_disconnected_space.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_139586 (h0 : group (has_Sup (semiring (semiring empty)))) : is_cyclic (has_Sup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_139587 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (normed_lattice_add_comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_139588 (h1 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_139589 (h0 : functor.add_const (list (has_nndist Type)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_139590 (h0 : ring (canonically_ordered_monoid (has_Inf linarith.comp))) : rank_condition (canonically_ordered_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_139591 (h0 : add_group (dlist (has_nnnorm (has_nnnorm linarith.comp_source)))) : is_add_cyclic (dlist (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_139592 (h0 : function.extfun (Type 1) topological_space) : @normal_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_139593 (h0 : functor.add_const (fin has_zero.zero) real) : @sequential_space.{0} (add_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) real h0))  := sorry --non-trivial
lemma new_lemma_139594 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_139595 (h1 : topological_space (has_inf fun_info)) : path_connected_space (has_inf fun_info) := sorry --non-trivial
lemma new_lemma_139596 (h0 : ordered_add_comm_monoid (boolean_algebra (add_cancel_monoid pos))) : archimedean (boolean_algebra (add_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_139597 (h0 : topological_space (dlist to_additive.value_type)) : locally_compact_space (dlist to_additive.value_type) := sorry --non-trivial
lemma new_lemma_139598 (h0 : not (uniform_space (has_ssubset fun_info) -> false)) : @complete_space.{0} (has_ssubset.{0} fun_info) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_ssubset.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_139599 (h0 : complete_lattice (non_unital_non_assoc_semiring linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (non_unital_non_assoc_semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_139600 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_139601 (h0 : functor.add_const (topological_space auto.case_option) unsigned) : @totally_disconnected_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) unsigned h0)  := sorry --non-trivial
lemma new_lemma_139602 (h0 : functor.add_const (topological_space (has_zero name)) linarith.comp) : @irreducible_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_139603 (h0 : group (linear_ordered_semiring (semiring (semiring empty)))) : is_cyclic (linear_ordered_semiring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_139604 (h0 : ring (comm_group (has_add pos))) : is_domain (comm_group (has_add pos)) := sorry --non-trivial
lemma new_lemma_139605 (h0 : set (ereal -> ordering)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_139606 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @rank_condition.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_139607 (h0 : topological_space (distrib reducibility_hints)) : path_connected_space (distrib reducibility_hints) := sorry --non-trivial
lemma new_lemma_139608 (h1 : ring (dlist linarith.comp_source)) : strong_rank_condition (dlist linarith.comp_source) := sorry --non-trivial
lemma new_lemma_139609 (h0 : functor.add_const (list (finset pos)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_139610 (h0 : uniform_space (group_with_zero (option pos))) : complete_space (group_with_zero (option pos)) := sorry --non-trivial
lemma new_lemma_139611 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_139612 (h0 : functor.add_const (function.extfun Type topological_space) (finset (normed_comm_ring (normed_comm_ring pos)))) : @totally_separated_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (finset.{0} (normed_comm_ring.{0} (normed_comm_ring.{0} pos))) h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_139613 (h0 : finset (distrib_lattice unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_139614 (h0 : functor.add_const (ordered_comm_monoid (simple_graph pos)) (has_neg (ring Type))) : @has_exists_mul_of_le.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (simple_graph.{0} pos)) (has_neg.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_139615 (h0 : topological_space (semigroup congr_arg_kind)) : preirreducible_space (semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_139616 (h1 : filter (linear_ordered_add_comm_group (has_inv char))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_139617 (h0 : monoid (linear_order (option (option empty)))) : monoid.fg (linear_order (option (option empty))) := sorry --non-trivial
lemma new_lemma_139618 (h0 : functor.add_const (ring (mul_zero_class num)) (semiring num)) : @is_principal_ideal_ring.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_139619 (h0 : filter (with_bot (semiring (semiring (normed_group congr_arg_kind))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_139620 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_139621 (h0 : monoid (plift (semiring (semiring congr_arg_kind)))) : monoid.fg (plift (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_139622 (h0 : topological_space (comm_group (finset linarith.comp))) : discrete_topology (comm_group (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_139623 (h0 : topological_space (has_to_string (finset ennreal))) : totally_separated_space (has_to_string (finset ennreal)) := sorry --non-trivial
lemma new_lemma_139624 (h0 : not (topological_space (metric_space num) -> false)) : @totally_separated_space.{0} (metric_space.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_139625 (h0 : topological_space (has_Inf (has_Inf (has_Inf real)))) : path_connected_space (has_Inf (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_139626 (h0 : ring (has_add (boolean_algebra.core linarith.comp))) : is_domain (has_add (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_139627 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_139628 (h0 : complete_lattice (preorder empty)) : is_compactly_generated (preorder empty) := sorry --non-trivial
lemma new_lemma_139629 (h0 : not (topological_space (with_bot num) -> false)) : @totally_separated_space.{0} (with_bot.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_139630 (h0 : topological_space (add_cancel_monoid (has_to_string congr_arg_kind))) : irreducible_space (add_cancel_monoid (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_139631 (h0 : functor.add_const (topological_space (ordered_cancel_add_comm_monoid empty)) (option (option num))) : @preirreducible_space.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_cancel_add_comm_monoid.{0} empty)) (option.{0} (option.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_139632 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (add_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (add_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_139633 (h0 : not (uniform_space (id congr_arg_kind) -> false)) : @separated_space.{0} (@id.{2} Type congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (@id.{2} Type congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_139634 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_139635 (h0 : ordered_semiring std_gen) (h1 : add_comm_monoid (has_append std_gen)) (h2 : has_scalar std_gen (has_append std_gen)) (h3 : set (convex_cone std_gen (has_append std_gen))) : set.subsingleton h3 := sorry --non-trivial
lemma new_lemma_139636 (h0 : topological_space (linear_ordered_comm_monoid_with_zero empty)) : discrete_topology (linear_ordered_comm_monoid_with_zero empty) := sorry --non-trivial
lemma new_lemma_139637 (h0 : functor.add_const (topological_space (plift congr_arg_kind)) empty) : @loc_path_connected_space.{1} (plift.{1} congr_arg_kind) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_139638 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (simple_graph.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (simple_graph.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_139639 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 nnreal) := sorry --non-trivial
lemma new_lemma_139640 (h0 : add_group (has_Sup (option (option (option unsigned))))) : is_add_cyclic (has_Sup (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_139641 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_sub.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_sub.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_139642 (h0 : topological_space (plift (semiring (semiring (semiring (semiring unsigned)))))) : totally_disconnected_space (plift (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_139643 (h0 : topological_space (normed_comm_ring (has_to_string pos))) : loc_path_connected_space (normed_comm_ring (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_139644 (h0 : functor.add_const (finset (normed_comm_ring pos)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_139645 (h0 : has_mul linarith.ineq) (h1 : not (ring (con linarith.ineq) -> false)) : @is_domain.{0} (@con.{0} linarith.ineq h0) (@classical.by_contradiction'.{1} (ring.{0} (@con.{0} linarith.ineq h0)) h1)  := sorry --non-trivial
lemma new_lemma_139646 (h0 : topological_space (metric_space (semiring num))) : irreducible_space (metric_space (semiring num)) := sorry --non-trivial
lemma new_lemma_139647 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) pos) : @normal_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_139648 (h1 : filter (linear_ordered_add_comm_group (has_nnnorm (has_nnnorm char)))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_139649 (h0 : prod (linear_ordered_field Type) (linear_ordered_field Type)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_139650 (h0 : monoid (has_Inf (canonically_linear_ordered_monoid real))) : monoid.fg (has_Inf (canonically_linear_ordered_monoid real)) := sorry --non-trivial
lemma new_lemma_139651 (h0 : has_add ennreal -> has_add ennreal -> Prop) : is_extensional (has_add ennreal) h0 := sorry --non-trivial
lemma new_lemma_139652 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (denumerable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (denumerable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_139653 (h0 : topological_space (simple_graph (has_Inf name))) : loc_path_connected_space (simple_graph (has_Inf name)) := sorry --non-trivial
lemma new_lemma_139654 (h0 : functor.add_const (topological_space (add_comm_monoid unsigned)) unsigned) : @locally_compact_space.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_139655 (h0 : functor.add_const (function.extfun Type monoid) pos) : @monoid.fg.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type monoid.{0}) pos h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_139656 (h0 : functor.add_const (finset (has_nndist empty)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_139657 (h1 : group (has_append (random_gen reducibility_hints))) : is_cyclic (has_append (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_139658 (h0 : not (uniform_space (non_assoc_semiring num) -> false)) : @separated_space.{0} (non_assoc_semiring.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (non_assoc_semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_139659 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_nndist.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_nndist.{0} real))  := sorry --non-trivial
lemma new_lemma_139660 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_139661 (h0 : functor.add_const (list (monoid empty)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_139662 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_139663 (h0 : group (measurable_space linarith.ineq)) : normalizer_condition (measurable_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_139664 (h0 : group (metric_space linarith.comp)) : group.fg (metric_space linarith.comp) := sorry --non-trivial
lemma new_lemma_139665 (h0 : functor.add_const (ring (linear_order empty)) congr_arg_kind) : @strong_rank_condition.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (linear_order.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_139666 (h0 : topological_space (simple_graph (finset Type))) : sequential_space (simple_graph (finset Type)) := sorry --non-trivial
lemma new_lemma_139667 (h0 : add_group (add_left_cancel_monoid string_imp)) : is_add_cyclic (add_left_cancel_monoid string_imp) := sorry --non-trivial
lemma new_lemma_139668 (h2 : group (random_gen char)) : is_cyclic (random_gen char) := sorry --non-trivial
lemma new_lemma_139669 (h0 : add_group (ring Type)) : is_add_cyclic (ring Type) := sorry --non-trivial
lemma new_lemma_139670 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc empty))) : @complete_space.{0} (has_emptyc.{0} empty) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_emptyc.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_139671 (h0 : has_le (comm_ring (random_gen char))) (h1 : ring (has_nnnorm (bounded_order (comm_ring (random_gen char))))) : rank_condition (has_nnnorm (bounded_order (comm_ring (random_gen char)))) := sorry --non-trivial
lemma new_lemma_139672 (h0 : topological_space (simple_graph char)) (h1 : set (simple_graph char)) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_139673 (h0 : functor.add_const (ring (left_cancel_monoid congr_arg_kind)) num) : @rank_condition.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_139674 (h0 : functor.add_const (complete_lattice (has_pos_part real)) Type) : @is_compactly_generated.{0} (has_pos_part.{0} real) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_pos_part.{0} real)) Type h0)  := sorry --non-trivial
lemma new_lemma_139675 (h0 : functor.comp topological_space boolean_algebra.core ennreal) : @t0_space.{0} (boolean_algebra.core.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_139676 (h0 : complete_lattice (comm_group (comm_group pos))) : is_compactly_generated (comm_group (comm_group pos)) := sorry --non-trivial
lemma new_lemma_139677 (h0 : topological_space (has_to_string (finset unsigned))) : topological_space.separable_space (has_to_string (finset unsigned)) := sorry --non-trivial
lemma new_lemma_139678 (h1 : topological_space (normed_field (random_gen linarith.ineq))) : path_connected_space (normed_field (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_139679 (h0 : ring (id (semiring empty))) : rank_condition (id (semiring empty)) := sorry --non-trivial
lemma new_lemma_139680 (h0 : functor.add_const (add_group (boolean_algebra.core pos)) (has_neg Type)) : @is_add_cyclic.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 1} (add_group.{0} (boolean_algebra.core.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_139681 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @t1_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_139682 (h0 : ordered_add_comm_monoid (ring (has_neg pos))) : archimedean (ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_139683 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (add_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (add_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_139684 (h0 : functor.add_const (filter (boolean_algebra Type)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_139685 (h0 : functor.add_const (topological_space (normed_comm_ring environment.implicit_infer_kind)) pos) : @locally_compact_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_139686 (h0 : monoid (linear_ordered_semiring unsigned)) : monoid.fg (linear_ordered_semiring unsigned) := sorry --non-trivial
lemma new_lemma_139687 (h0 : ring (denumerable ereal)) : is_domain (denumerable ereal) := sorry --non-trivial
lemma new_lemma_139688 (h0 : functor.add_const (topological_space (is_R_or_C num)) empty) : @path_connected_space.{0} (is_R_or_C.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (is_R_or_C.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_139689 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_nndist Type)) Type) : @unique_factorization_monoid.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 1} (cancel_comm_monoid_with_zero.{1} (has_nndist.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_139690 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_139691 (h0 : complete_lattice (has_zero (has_neg_part (boolean_algebra unsigned)))) : is_compactly_generated (has_zero (has_neg_part (boolean_algebra unsigned))) := sorry --non-trivial
lemma new_lemma_139692 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) linarith.comp) : @totally_disconnected_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_139693 (h0 : group (generalized_boolean_algebra (has_Inf real))) : is_simple_group (generalized_boolean_algebra (has_Inf real)) := sorry --non-trivial
lemma new_lemma_139694 (h0 : complete_lattice (boolean_algebra (ring name))) : is_compactly_generated (boolean_algebra (ring name)) := sorry --non-trivial
lemma new_lemma_139695 (h0 : set (has_compl (non_unital_non_assoc_semiring char))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_139696 (h0 : topological_space (finset congr_arg_kind)) : locally_compact_space (finset congr_arg_kind) := sorry --non-trivial
lemma new_lemma_139697 (h0 : uniform_space (simple_graph (has_pos_part linarith.comp))) : complete_space (simple_graph (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_139698 (h0 : ring (normed_comm_ring (ring environment.implicit_infer_kind))) : strong_rank_condition (normed_comm_ring (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_139699 (h0 : function.extfun (finset Type) (has_mem.mem (partial_order linarith.comp))) : @totally_disconnected_space.{0} (partial_order.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (partial_order.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (partial_order.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_139700 (h0 : uniform_space (measurable_space (random_gen fun_info))) : complete_space (measurable_space (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_139701 (h0 : complete_lattice (linear_ordered_semiring (has_top fun_info))) : complete_lattice.is_Sup_finite_compact (linear_ordered_semiring (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_139702 (h0 : topological_space (complete_semilattice_Sup empty)) : totally_disconnected_space (complete_semilattice_Sup empty) := sorry --non-trivial
lemma new_lemma_139703 (h0 : enat) (h1 : sym2 enat) : sym2.mem h0 h1 := sorry --non-trivial
lemma new_lemma_139704 (h0 : semiring (normed_comm_ring (finset (finset linarith.comp)))) : is_noetherian_ring (normed_comm_ring (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_139705 (h0 : ring (boolean_algebra (finset pos))) : is_principal_ideal_ring (boolean_algebra (finset pos)) := sorry --non-trivial
lemma new_lemma_139706 (h0 : functor.add_const (group (cancel_monoid pos)) environment.implicit_infer_kind) : @group.fg.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (cancel_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_139707 (h0 : ring (semiring (has_norm (random_gen linarith.comp_source)))) : strong_rank_condition (semiring (has_norm (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_139708 (h0 : complete_lattice (has_nndist (semigroup name))) : is_compactly_generated (has_nndist (semigroup name)) := sorry --non-trivial
lemma new_lemma_139709 (h0 : topological_space (has_neg_part (option (has_to_string name)))) : totally_disconnected_space (has_neg_part (option (has_to_string name))) := sorry --non-trivial
lemma new_lemma_139710 (h0 : group (denumerable (random_gen (random_gen (random_gen (random_gen (random_gen string_imp))))))) : group.fg (denumerable (random_gen (random_gen (random_gen (random_gen (random_gen string_imp)))))) := sorry --non-trivial
lemma new_lemma_139711 (h0 : complete_lattice (boolean_algebra (comm_group (comm_group (comm_group (comm_group (comm_group pos))))))) : is_atomistic (boolean_algebra (comm_group (comm_group (comm_group (comm_group (comm_group pos)))))) := sorry --non-trivial
lemma new_lemma_139712 (h0 : group (add_cancel_monoid (ring (finset (has_neg pos))))) : normalizer_condition (add_cancel_monoid (ring (finset (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_139713 (h0 : ring (omega_complete_partial_order (semiring unsigned))) : rank_condition (omega_complete_partial_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_139714 (h0 : topological_space (canonically_ordered_comm_semiring (has_add ennreal))) : t0_space (canonically_ordered_comm_semiring (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_139715 (h0 : topological_space (add_group (random_gen fun_info))) : irreducible_space (add_group (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_139716 (h0 : semiring (generalized_boolean_algebra (has_neg Type))) : is_noetherian_ring (generalized_boolean_algebra (has_neg Type)) := sorry --non-trivial
lemma new_lemma_139717 (h0 : ring (sub_neg_monoid pos)) : is_domain (sub_neg_monoid pos) := sorry --non-trivial
lemma new_lemma_139718 (h0 : functor.add_const (function.extfun Type topological_space) (has_pos_part (has_pos_part linarith.comp))) : @path_connected_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_pos_part.{0} (has_pos_part.{0} linarith.comp)) h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_139719 (h0 : functor.add_const (topological_space (has_zero Type)) Type) : @totally_disconnected_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_zero.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_139720 (h0 : uniform_space (has_norm (random_gen (random_gen linarith.ineq)))) : complete_space (has_norm (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_139721 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_139722 (h0 : functor.add_const (group (has_zero Type)) (has_neg (ring linarith.comp))) : @normalizer_condition.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_zero.{1} Type)) (has_neg.{0} (ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_139723 (h0 : functor.add_const (function.extfun Type list) (mul_one_class linarith.comp)) : list.nodup (function.extfun_app (functor.add_const.run h0) (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_139724 (h0 : functor.add_const (function.extfun Type add_group) pos) : @is_add_cyclic.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) pos h0) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_139725 (h0 : functor.add_const (ring (finset pos)) (ring linarith.comp)) : @is_domain.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} pos)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_139726 (h0 : topological_space (sub_neg_monoid Type)) : totally_separated_space (sub_neg_monoid Type) := sorry --non-trivial
lemma new_lemma_139727 (h0 : function.extfun Type topological_space) : @t0_space.{0} (add_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_139728 (h0 : functor.add_const (functor.add_const (topological_space linarith.comp) pos) Type) : @preirreducible_space.{0} linarith.comp (@functor.add_const.run.{0 0} (topological_space.{0} linarith.comp) pos (@functor.add_const.run.{0 1} (functor.add_const.{0 0} (topological_space.{0} linarith.comp) pos) Type h0))  := sorry --non-trivial
lemma new_lemma_139729 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (simple_graph.{0} (has_Inf.{0} (has_add.{0} (finset.{0} (has_add.{0} (has_add.{0} (has_neg.{0} linarith.comp))))))) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (simple_graph.{0} (has_Inf.{0} (has_add.{0} (finset.{0} (has_add.{0} (has_add.{0} (has_neg.{0} linarith.comp))))))))  := sorry --non-trivial
lemma new_lemma_139730 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} h0 (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_139731 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @locally_compact_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_139732 (h0 : topological_space (has_norm (semiring (has_norm empty)))) : normal_space (has_norm (semiring (has_norm empty))) := sorry --non-trivial
lemma new_lemma_139733 (h0 : functor.add_const Prop (pseudo_metric_space Type)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_139734 (h0 : complete_lattice (dlist fun_info)) : complete_lattice.is_Sup_finite_compact (dlist fun_info) := sorry --non-trivial
lemma new_lemma_139735 (h0 : topological_space (has_union (semiring (semiring congr_arg_kind)))) : path_connected_space (has_union (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_139736 (h0 : functor.add_const (group (has_to_string unsigned)) (ring Type)) : @group.fg.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 1} (group.{0} (has_to_string.{0} unsigned)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_139737 (h0 : ring (complete_semilattice_Sup (semiring linarith.comp))) : rank_condition (complete_semilattice_Sup (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_139738 (h0 : uniform_space (has_ssubset string.iterator_imp)) : complete_space (has_ssubset string.iterator_imp) := sorry --non-trivial
lemma new_lemma_139739 (h0 : topological_space (add_comm_monoid ennreal)) : locally_compact_space (add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_139740 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_139741 (h0 : topological_space (measurable_space (random_gen fun_info))) : t0_space (measurable_space (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_139742 (h0 : uniform_space (has_sub num)) : complete_space (has_sub num) := sorry --non-trivial
lemma new_lemma_139743 (h0 : topological_space (ordered_comm_ring (ring (has_neg linarith.comp)))) : t1_space (ordered_comm_ring (ring (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_139744 (h0 : has_lt (nondiscrete_normed_field reducibility_hints)) : no_max_order (nondiscrete_normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_139745 (h0 : functor.add_const (finset pos) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_139746 (h0 : functor.add_const (ring (has_nndist Type)) environment.implicit_infer_kind) : @is_domain.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_nndist.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_139747 (h0 : functor.add_const (monoid (canonically_ordered_monoid linarith.comp)) linarith.comp) : @monoid.fg.{0} (canonically_ordered_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (canonically_ordered_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_139748 (h0 : list (semigroup (boolean_algebra.core pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_139749 (h0 : topological_space (has_ssubset (has_pos_part (random_gen (random_gen linarith.ineq))))) : totally_disconnected_space (has_ssubset (has_pos_part (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_139750 (h0 : ring (has_to_string (has_add (add_comm_monoid (has_add pos))))) : rank_condition (has_to_string (has_add (add_comm_monoid (has_add pos)))) := sorry --non-trivial
lemma new_lemma_139751 (h0 : functor.add_const (ordered_comm_monoid (has_pos_part name)) (finset linarith.comp)) : @has_exists_mul_of_le.{0} (has_pos_part.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_pos_part.{0} name)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_139752 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_sub.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_sub.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_139753 (h0 : not (group (has_nnnorm to_additive.value_type) -> false)) : @group.fg.{0} (has_nnnorm.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (has_nnnorm.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_139754 (h0 : list (has_inner empty num)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_139755 (h0 : topological_space (uniform_space congr_arg_kind)) : t0_space (uniform_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_139756 (h0 : topological_space (finset Type)) : totally_disconnected_space (finset Type) := sorry --non-trivial
lemma new_lemma_139757 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_139758 (h0 : group (has_star (semiring empty))) : is_simple_group (has_star (semiring empty)) := sorry --non-trivial
lemma new_lemma_139759 (h0 : monoid (normed_group (partial_order (partial_order congr_arg_kind)))) : monoid.fg (normed_group (partial_order (partial_order congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_139760 (h1 : function.extfun Type topological_space) : @t0_space.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_139761 (h1 : not (ring (metric_space char) -> false)) : @strong_rank_condition.{0} (metric_space.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (metric_space.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_139762 (h0 : functor.add_const (uniform_space (has_to_string Type)) pos) : @separated_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_to_string.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_139763 (h1 : topological_space (has_append linarith.comp_source)) : totally_disconnected_space (has_append linarith.comp_source) := sorry --non-trivial
lemma new_lemma_139764 (h0 : topological_space (ordered_comm_group (option empty))) : t0_space (ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_139765 (h2 : has_mem.mem (with_one num) has_emptyc.emptyc) : @totally_disconnected_space.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} num) h2)  := sorry --non-trivial
lemma new_lemma_139766 (h0 : filter (has_zero (has_to_string pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_139767 (h0 : complete_lattice (normed_group (has_norm (random_gen congr_arg_kind)))) : complete_lattice.is_Sup_finite_compact (normed_group (has_norm (random_gen congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_139768 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @normalizer_condition.{0} real (@matrix.vec_empty.{0} (group.{0} real) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_139769 (h0 : topological_space (ordered_comm_group congr_arg_kind)) : locally_compact_space (ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_139770 (h0 : topological_space (semigroup Type)) : discrete_topology (semigroup Type) := sorry --non-trivial
lemma new_lemma_139771 (h0 : add_group (option num)) : is_add_cyclic (option num) := sorry --non-trivial
lemma new_lemma_139772 (h1 : monoid (measurable_space num)) : monoid.fg (measurable_space num) := sorry --non-trivial
lemma new_lemma_139773 (h0 : fin has_zero.zero) : @separated_space.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (normed_lattice_add_comm_group.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_139774 (h0 : uniform_space (boolean_algebra.core num)) : complete_space (boolean_algebra.core num) := sorry --non-trivial
lemma new_lemma_139775 (h0 : functor.comp semiring has_add name) : @is_noetherian_ring.{0} (has_add.{0} name) (@functor.comp.run.{0 0 0} semiring.{0} has_add.{0} name h0)  := sorry --non-trivial
lemma new_lemma_139776 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (linear_ordered_comm_monoid_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_139777 (h0 : topological_space (canonically_ordered_comm_semiring (ring pos))) : sequential_space (canonically_ordered_comm_semiring (ring pos)) := sorry --non-trivial
lemma new_lemma_139778 (h0 : functor.add_const (filter (boolean_algebra linarith.comp)) (has_neg pos)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_139779 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_139780 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_139781 (h0 : complete_lattice (add_comm_monoid (complete_distrib_lattice (has_add Type)))) : is_atomistic (add_comm_monoid (complete_distrib_lattice (has_add Type))) := sorry --non-trivial
lemma new_lemma_139782 (h0 : topological_space (random_gen (semiring num))) : path_connected_space (random_gen (semiring num)) := sorry --non-trivial
lemma new_lemma_139783 (h0 : list (finset (finset (has_nndist ennreal)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_139784 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_edist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_edist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_139785 (h0 : group (add_cancel_monoid (semigroup ennreal))) : normalizer_condition (add_cancel_monoid (semigroup ennreal)) := sorry --non-trivial
lemma new_lemma_139786 (h0 : complete_lattice (ordered_comm_ring (has_Inf (has_add Type)))) : complete_lattice.is_Sup_finite_compact (ordered_comm_ring (has_Inf (has_add Type))) := sorry --non-trivial
lemma new_lemma_139787 (h0 : topological_space (simple_graph enat)) (h1 : preorder (simple_graph enat)) : order_closed_topology (simple_graph enat) := sorry --non-trivial
lemma new_lemma_139788 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (as_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (as_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_139789 (h0 : group (has_top (has_inv (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))))) : is_cyclic (has_top (has_inv (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))))) := sorry --non-trivial
lemma new_lemma_139790 (h0 : not (topological_space (metric_space congr_arg_kind) -> false)) : @totally_separated_space.{0} (metric_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_139791 (h0 : set (has_le linarith.ineq)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_139792 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_repr.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_repr.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_139793 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (dlist.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (dlist.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_139794 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (linear_order num)) := sorry --non-trivial
lemma new_lemma_139795 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_neg.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_neg.{0} empty))  := sorry --non-trivial
lemma new_lemma_139796 (h0 : functor.add_const (functor.add_const (complete_lattice nnreal) empty) empty) : @is_compactly_generated.{0} nnreal (@functor.add_const.run.{0 0} (complete_lattice.{0} nnreal) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (complete_lattice.{0} nnreal) empty) empty h0))  := sorry --non-trivial
lemma new_lemma_139797 (h0 : fin has_zero.zero) : @is_cyclic.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (group.{1} (generalized_boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_139798 (h0 : topological_space (add_comm_monoid (has_add name))) : t0_space (add_comm_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_139799 (h0 : not (list (semi_normed_comm_ring fun_info) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_139800 (h0 : functor.add_const (monoid (has_to_string ennreal)) (boolean_algebra.core (complete_distrib_lattice Type))) : @monoid.fg.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 1} (monoid.{0} (has_to_string.{0} ennreal)) (boolean_algebra.core.{1} (complete_distrib_lattice.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_139801 (h0 : topological_space (has_to_string (has_to_string (has_to_string unsigned)))) : path_connected_space (has_to_string (has_to_string (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_139802 (h0 : list (finset (finset (finset linarith.comp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_139803 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (has_top num)) := sorry --non-trivial
lemma new_lemma_139804 (h0 : function.extfun (Type 1) topological_space) : @t1_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_139805 (h0 : ulower (fin has_zero.zero)) : matrix.vec_empty (ulower.up h0) := sorry --non-trivial
lemma new_lemma_139806 (h0 : has_mem.mem fun_info has_emptyc.emptyc) : @is_domain.{0} fun_info (@finset.pi.empty.{1 0} Type ring.{0} fun_info h0)  := sorry --non-trivial
lemma new_lemma_139807 (h0 : topological_space (has_inter empty)) : totally_separated_space (has_inter empty) := sorry --non-trivial
lemma new_lemma_139808 (h0 : functor.add_const (function.extfun (Type 1) topological_space) environment.implicit_infer_kind) : @t0_space.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) environment.implicit_infer_kind h0) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_139809 (h0 : cancel_comm_monoid_with_zero (simple_graph (ring pos))) : unique_factorization_monoid (simple_graph (ring pos)) := sorry --non-trivial
lemma new_lemma_139810 (h0 : uniform_space (add_cancel_monoid (has_neg (semigroup environment.implicit_infer_kind)))) : separated_space (add_cancel_monoid (has_neg (semigroup environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_139811 (h0 : function.extfun Type group) : @group.fg.{0} (non_assoc_semiring.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (non_assoc_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_139812 (h0 : functor.add_const (list (normed_linear_ordered_group unsigned)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_139813 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_dist.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} num))  := sorry --non-trivial
lemma new_lemma_139814 (h0 : complete_lattice (ordered_ring (option (option (option (option unsigned)))))) : complete_lattice.is_Sup_finite_compact (ordered_ring (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_139815 (h0 : not (function.extfun Type topological_space -> false)) (h1 : function.extfun Type measurable_space) : @opens_measurable_space.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} num)) (@function.extfun_app.{2 1} Type measurable_space.{0} h1 (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_139816 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_139817 (h0 : topological_space (ordered_ring congr_arg_kind)) : path_connected_space (ordered_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_139818 (h0 : functor.add_const (semiring (boolean_algebra unsigned)) pos) : @is_noetherian_ring.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (boolean_algebra.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_139819 (h1 : group (dlist (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) : is_cyclic (dlist (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_139820 (h0 : semiring (has_union (semiring (semiring (semiring empty))))) : is_noetherian_ring (has_union (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_139821 (h0 : topological_space (has_Sup unsigned)) : locally_compact_space (has_Sup unsigned) := sorry --non-trivial
lemma new_lemma_139822 (h0 : functor.add_const (ring (partial_order unsigned)) congr_arg_kind) : @is_domain.{0} (partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (partial_order.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_139823 (h1 : complete_lattice (semiring (has_top fun_info))) : complete_lattice.is_Sup_finite_compact (semiring (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_139824 (h0 : topological_space (boolean_algebra (has_pos_part (finset pos)))) : path_connected_space (boolean_algebra (has_pos_part (finset pos))) := sorry --non-trivial
lemma new_lemma_139825 (h0 : group (boolean_algebra.core (option (option (option (option (option (option empty)))))))) : is_simple_group (boolean_algebra.core (option (option (option (option (option (option empty))))))) := sorry --non-trivial
lemma new_lemma_139826 (h0 : topological_space (mul_one_class ereal)) (h1 : set (mul_one_class ereal)) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_139827 (h0 : group (normed_group (denumerable (has_top linarith.ineq)))) : normalizer_condition (normed_group (denumerable (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_139828 (h0 : has_coe (normed_field (mul_one_class (mul_one_class enat))) Prop) (h1 : normed_field (mul_one_class (mul_one_class enat))) : @coe_b.{1 1} (normed_field.{0} (mul_one_class.{0} (mul_one_class.{0} enat))) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_139829 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_139830 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) Type) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) Type h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_139831 (h0 : function.extfun Type ring) : @is_domain.{0} (comm_ring.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_ring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_139832 (h0 : complete_lattice (comm_semigroup (has_add real))) : is_compactly_generated (comm_semigroup (has_add real)) := sorry --non-trivial
lemma new_lemma_139833 (h0 : functor.add_const (topological_space (ordered_ring num)) num) : @totally_separated_space.{0} (ordered_ring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_139834 (h0 : group (has_top (has_top to_additive.value_type))) : group.fg (has_top (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_139835 (h0 : not (list (topological_space fun_info) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_139836 (h0 : functor.add_const (topological_space (has_to_string name)) linarith.comp) : @regular_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_139837 (h0 : fin has_zero.zero) : @path_connected_space.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_139838 (h0 : filter (has_neg (option (option (option (option ennreal)))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_139839 (h0 : complete_lattice (simple_graph empty)) : complete_lattice.is_Sup_finite_compact (simple_graph empty) := sorry --non-trivial
lemma new_lemma_139840 (h0 : not (complete_lattice (linear_ordered_comm_ring empty) -> false)) : @is_atomistic.{0} (linear_ordered_comm_ring.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_comm_ring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_139841 (h0 : not (ring (comm_ring to_additive.value_type) -> false)) : @strong_rank_condition.{0} (comm_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (comm_ring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_139842 (h0 : functor.add_const (monoid (add_comm_monoid linarith.comp)) linarith.comp) : @monoid.fg.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (add_comm_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_139843 (h0 : finset (has_bot (has_pos_part Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_139844 (h0 : ring (simple_graph (option (option (option (option empty)))))) : strong_rank_condition (simple_graph (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_139845 (h0 : function.extfun Type (functor.add_const (group (linear_ordered_cancel_comm_monoid empty)))) : @normalizer_condition.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} (linear_ordered_cancel_comm_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_139846 (h0 : ring (has_nndist (comm_group name))) : is_domain (has_nndist (comm_group name)) := sorry --non-trivial
lemma new_lemma_139847 (h0 : not (topological_space (id congr_arg_kind) -> false)) : @discrete_topology.{0} (@id.{2} Type congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_139848 (h0 : uniform_space (add_comm_semigroup (mul_one_class string.iterator_imp))) : complete_space (add_comm_semigroup (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_139849 (h0 : topological_space (complete_distrib_lattice (has_neg (has_neg name)))) : locally_compact_space (complete_distrib_lattice (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_139850 (h0 : fin has_zero.zero) : @is_cyclic.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (group.{1} (canonically_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_139851 (h0 : ring (simple_graph (mul_one_class linarith.ineq))) : rank_condition (simple_graph (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_139852 (h0 : topological_space (normed_comm_ring (has_to_string (has_to_string (has_to_string pos))))) : regular_space (normed_comm_ring (has_to_string (has_to_string (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_139853 (h0 : topological_space (random_gen (random_gen (random_gen (has_nnnorm linarith.comp_source))))) : totally_disconnected_space (random_gen (random_gen (random_gen (has_nnnorm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_139854 (h0 : cancel_comm_monoid_with_zero (has_norm (has_top (has_top (has_top (has_top unsigned)))))) : unique_factorization_monoid (has_norm (has_top (has_top (has_top (has_top unsigned))))) := sorry --non-trivial
lemma new_lemma_139855 (h0 : functor.add_const (topological_space (non_assoc_semiring unsigned)) congr_arg_kind) : @topological_space.separable_space.{0} (non_assoc_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_139856 (h0 : add_group (ring name)) : is_add_cyclic (ring name) := sorry --non-trivial
lemma new_lemma_139857 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_139858 (h0 : monoid (add_cancel_monoid congr_arg_kind)) : monoid.fg (add_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_139859 (h0 : group (normed_lattice_add_comm_group Type)) : normalizer_condition (normed_lattice_add_comm_group Type) := sorry --non-trivial
lemma new_lemma_139860 (h2 : topological_space (has_inv string_imp)) : t0_space (has_inv string_imp) := sorry --non-trivial
lemma new_lemma_139861 (h0 : group (has_union (semiring (semiring (semiring congr_arg_kind))))) : is_cyclic (has_union (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_139862 (h0 : function.extfun (Type 1) (functor.add_const (function.extfun Type group))) : @normalizer_condition.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type (@function.extfun_app.{3 2} (Type 1) (functor.add_const.{1 1} (function.extfun.{2 1} Type group.{0})) h0 Type)) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_139863 (h3 : topological_space (topological_space char)) : t0_space (topological_space char) := sorry --non-trivial
lemma new_lemma_139864 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_139865 (h0 : function.extfun Type (functor.add_const (topological_space (has_Inf linarith.comp)))) : @totally_disconnected_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_139866 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_separated_space.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_139867 (h0 : topological_space (has_neg (finset (finset (finset (has_to_string linarith.comp)))))) : normal_space (has_neg (finset (finset (finset (has_to_string linarith.comp))))) := sorry --non-trivial
lemma new_lemma_139868 (h0 : functor.add_const (topological_space (has_star unsigned)) num) : @topological_space.separable_space.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_139869 (h0 : functor.add_const (filter (has_neg environment.implicit_infer_kind)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_139870 (h0 : monoid (semigroup (finset (has_pos_part (has_add (mul_one_class Type)))))) : monoid.fg (semigroup (finset (has_pos_part (has_add (mul_one_class Type))))) := sorry --non-trivial
lemma new_lemma_139871 (h0 : topological_space (add_comm_monoid (has_add environment.implicit_infer_kind))) : path_connected_space (add_comm_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_139872 (h0 : fin has_zero.zero) : @strong_rank_condition.{0} (mul_one_class.{0} ereal) (@matrix.vec_empty.{0} (ring.{0} (mul_one_class.{0} ereal)) h0)  := sorry --non-trivial
lemma new_lemma_139873 (h0 : uniform_space (normed_linear_ordered_group (semiring congr_arg_kind))) : complete_space (normed_linear_ordered_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_139874 (h0 : ordered_comm_monoid (comm_group pos)) : has_exists_mul_of_le (comm_group pos) := sorry --non-trivial
lemma new_lemma_139875 (h0 : functor.add_const (function.extfun (Type 1) add_group) linarith.comp) : @is_add_cyclic.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) add_group.{1}) linarith.comp h0) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_139876 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (free_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (free_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_139877 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_139878 (h0 : uniform_space (has_nnnorm fun_info) -> fun_info) (h1 : coe_sort (set.range h0)) : @complete_space.{0} (has_nnnorm.{0} fun_info) (@set.range_splitting.{0 0} (uniform_space.{0} (has_nnnorm.{0} fun_info)) fun_info h0 h1)  := sorry --non-trivial
lemma new_lemma_139879 (h0 : functor.comp filter has_neg_part name) : countable_Inter_filter (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_139880 (h0 : functor.add_const (topological_space (has_add Type)) (finset pos)) : @regular_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_139881 (h0 : topological_space (ring pos)) : irreducible_space (ring pos) := sorry --non-trivial
lemma new_lemma_139882 (h0 : topological_space (ordered_comm_group (option (option num)))) : totally_disconnected_space (ordered_comm_group (option (option num))) := sorry --non-trivial
lemma new_lemma_139883 (h0 : ring (left_cancel_semigroup (semiring unsigned))) : is_domain (left_cancel_semigroup (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_139884 (h0 : semiring (semigroup (has_neg (has_neg pos)))) : is_noetherian_ring (semigroup (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_139885 (h0 : list (measurable_space (has_norm fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_139886 (h0 : not (add_group (with_zero linarith.ineq) -> false)) : @is_add_cyclic.{0} (with_zero.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (with_zero.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_139887 (h0 : functor.comp add_group has_nndist pos) : @is_add_cyclic.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} add_group.{0} has_nndist.{0} pos (@functor.comp.run.{0 0 0} add_group.{0} has_nndist.{0} pos (@functor.comp.run.{0 0 0} add_group.{0} has_nndist.{0} pos (@functor.comp.run.{0 0 0} add_group.{0} has_nndist.{0} pos (@functor.comp.run.{0 0 0} add_group.{0} has_nndist.{0} pos (@functor.comp.run.{0 0 0} add_group.{0} has_nndist.{0} pos (@functor.comp.run.{0 0 0} add_group.{0} has_nndist.{0} pos (@functor.comp.run.{0 0 0} add_group.{0} has_nndist.{0} pos (@functor.comp.run.{0 0 0} add_group.{0} has_nndist.{0} pos h0)))))))))  := sorry --non-trivial
lemma new_lemma_139888 (h0 : topological_space (denumerable (has_nnnorm (has_nnnorm linarith.ineq)))) : t0_space (denumerable (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_139889 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_star.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_star.{0} num))  := sorry --non-trivial
lemma new_lemma_139890 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_139891 (h0 : topological_space (semi_normed_ring (uniform_space to_additive.value_type))) : t0_space (semi_normed_ring (uniform_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_139892 (h0 : not (topological_space (semiring num) -> false)) : @locally_compact_space.{0} (semiring.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_139893 (h0 : ordered_comm_monoid (boolean_algebra.core pos)) : has_exists_mul_of_le (boolean_algebra.core pos) := sorry --non-trivial
lemma new_lemma_139894 (h0 : ring (measure_theory.measure_space (semiring (semiring unsigned)))) : is_domain (measure_theory.measure_space (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_139895 (h0 : has_to_string (add_cancel_monoid Type) -> has_to_string (add_cancel_monoid Type) -> Prop) : is_extensional (has_to_string (add_cancel_monoid Type)) h0 := sorry --non-trivial
lemma new_lemma_139896 (h0 : topological_space (normed_comm_ring environment.implicit_infer_kind)) : irreducible_space (normed_comm_ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_139897 (h0 : function.extfun Type (functor.add_const (topological_space (partial_order unsigned)))) : @irreducible_space.{0} (partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} unsigned)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (partial_order.{0} unsigned))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_139898 (h0 : topological_space (has_neg (has_neg_part name))) : totally_separated_space (has_neg (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_139899 (h0 : topological_space (has_top (semiring (semiring empty)))) : totally_disconnected_space (has_top (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_139900 (h0 : complete_lattice (add_cancel_monoid (mul_one_class linarith.comp))) : is_compactly_generated (add_cancel_monoid (mul_one_class linarith.comp)) := sorry --non-trivial
lemma new_lemma_139901 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_139902 (h0 : uniform_space (add_cancel_monoid (has_add Type))) : separated_space (add_cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_139903 (h0 : ring (bin_tree (semiring unsigned))) : is_principal_ideal_ring (bin_tree (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_139904 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_139905 (h0 : topological_space (semi_normed_comm_ring linarith.comp_source)) : path_connected_space (semi_normed_comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_139906 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_139907 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (add_left_cancel_monoid.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_left_cancel_monoid.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_139908 (h0 : fin std.prec.max) : matrix.vec_tail set.univ h0 := sorry --trivial
lemma new_lemma_139909 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (measurable_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_139910 (h1 : topological_space (normed_field ereal)) (h2 : preorder (normed_field ereal)) : order_closed_topology (normed_field ereal) := sorry --non-trivial
lemma new_lemma_139911 (h0 : topological_space (has_neg (has_add environment.implicit_infer_kind))) : normal_space (has_neg (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_139912 (h0 : functor.add_const (function.extfun Type group) Type) : @is_cyclic.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_139913 (h0 : fin has_zero.zero) : @regular_space.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)) (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_139914 (h0 : topological_space (linear_ordered_comm_monoid_with_zero (option unsigned))) : path_connected_space (linear_ordered_comm_monoid_with_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_139915 (h0 : topological_space (has_inner unsigned congr_arg_kind)) : t0_space (has_inner unsigned congr_arg_kind) := sorry --non-trivial
lemma new_lemma_139916 (h1 : complete_lattice (has_inv (has_ssubset (has_ssubset (random_gen string_imp))))) : is_compactly_generated (has_inv (has_ssubset (has_ssubset (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_139917 (h0 : functor.add_const (topological_space empty) unsigned) : discrete_topology empty := sorry --non-trivial
lemma new_lemma_139918 (h0 : multiset (semigroup num)) : multiset.nodup h0 := sorry --non-trivial
lemma new_lemma_139919 (h0 : monoid (boolean_algebra.core (finset (finset (has_add ennreal))))) : monoid.fg (boolean_algebra.core (finset (finset (has_add ennreal)))) := sorry --non-trivial
lemma new_lemma_139920 (h0 : topological_space (normed_comm_ring (option ennreal))) : irreducible_space (normed_comm_ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_139921 (h0 : ordered_add_comm_monoid (boolean_algebra (has_add Type))) : archimedean (boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_139922 (h0 : topological_space (ring (mul_one_class (has_add (mul_one_class pos))))) : preirreducible_space (ring (mul_one_class (has_add (mul_one_class pos)))) := sorry --non-trivial
lemma new_lemma_139923 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_139924 (h0 : topological_space (complete_semilattice_Sup (random_gen fun_info))) : totally_separated_space (complete_semilattice_Sup (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_139925 (h0 : group (comm_group (option name))) : normalizer_condition (comm_group (option name)) := sorry --non-trivial
lemma new_lemma_139926 (h0 : ring (has_star (semiring (semiring empty)))) : strong_rank_condition (has_star (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_139927 (h0 : topological_space (semigroup (has_Inf linarith.comp))) : regular_space (semigroup (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_139928 (h0 : list (dlist (has_nnnorm (has_norm fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_139929 (h0 : group (has_inv (random_gen linarith.ineq))) : normalizer_condition (has_inv (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_139930 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_139931 (h0 : functor.comp topological_space add_cancel_monoid name) : @normal_space.{0} (add_cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_139932 (h2 : ring (linear_ordered_add_comm_group char)) : is_domain (linear_ordered_add_comm_group char) := sorry --non-trivial
lemma new_lemma_139933 (h0 : ring (bin_tree (semiring (semiring (semiring num))))) : strong_rank_condition (bin_tree (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_139934 (h2 : add_group enat) : is_add_cyclic enat := sorry --non-trivial
lemma new_lemma_139935 (h0 : functor.comp topological_space add_cancel_monoid pos) : @sequential_space.{0} (add_cancel_monoid.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_139936 (h0 : finset (filter congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_139937 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) Type) : @totally_disconnected_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg_part.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_139938 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (linear_ordered_comm_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} num))  := sorry --non-trivial
lemma new_lemma_139939 (h0 : topological_space (generalized_boolean_algebra (finset name))) : preirreducible_space (generalized_boolean_algebra (finset name)) := sorry --non-trivial
lemma new_lemma_139940 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) linarith.comp) : @normal_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_139941 (h0 : topological_space (add_comm_monoid (has_to_string pos))) : normal_space (add_comm_monoid (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_139942 (h0 : monoid (has_emptyc (random_gen fun_info))) : monoid.fg (has_emptyc (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_139943 (h0 : functor.add_const (topological_space (has_Sup unsigned)) empty) : @normal_space.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_139944 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_neg_part.{0} (has_add.{0} name)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} (has_add.{0} name)))  := sorry --non-trivial
lemma new_lemma_139945 (h0 : functor.add_const (topological_space (ordered_ring unsigned)) unsigned) : @irreducible_space.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_139946 (h0 : ring (semi_normed_comm_ring (semi_normed_comm_ring linarith.comp_source))) : rank_condition (semi_normed_comm_ring (semi_normed_comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_139947 (h0 : ring (has_to_string (boolean_algebra linarith.comp))) : rank_condition (has_to_string (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_139948 (h0 : function.extfun Type (functor.comp uniform_space has_add)) : @complete_space.{0} (has_add.{0} pos) (@functor.comp.run.{0 0 0} uniform_space.{0} has_add.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} uniform_space.{0} has_add.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_139949 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @group.fg.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_139950 (h0 : has_mul char) (h1 : char) : is_right_regular h1 := sorry --non-trivial
lemma new_lemma_139951 (h0 : ring (cancel_monoid fun_info)) : is_domain (cancel_monoid fun_info) := sorry --non-trivial
lemma new_lemma_139952 (h0 : group (has_nnnorm (topological_space linarith.ineq))) : is_cyclic (has_nnnorm (topological_space linarith.ineq)) := sorry --non-trivial
lemma new_lemma_139953 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_139954 (h0 : topological_space (denumerable (has_nnnorm (has_nnnorm linarith.comp_source)))) : totally_disconnected_space (denumerable (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_139955 (h0 : list (cancel_monoid (option (option unsigned)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_139956 (h0 : complete_lattice (has_inv linarith.ineq)) : is_compactly_generated (has_inv linarith.ineq) := sorry --non-trivial
lemma new_lemma_139957 (h0 : semiring (has_add (ring (ring Type)))) : is_noetherian_ring (has_add (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_139958 (h0 : ordered_add_comm_monoid (omega_complete_partial_order Type)) : archimedean (omega_complete_partial_order Type) := sorry --non-trivial
lemma new_lemma_139959 (h0 : topological_space (metric_space fun_info)) : normal_space (metric_space fun_info) := sorry --non-trivial
lemma new_lemma_139960 (h0 : topological_space (complete_semilattice_Sup (has_nnnorm char))) : path_connected_space (complete_semilattice_Sup (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_139961 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_139962 (h0 : complete_lattice (has_neg (has_neg (finset Type)))) : is_compactly_generated (has_neg (has_neg (finset Type))) := sorry --non-trivial
lemma new_lemma_139963 (h0 : functor.add_const (topological_space (has_to_string Type)) linarith.comp) : @regular_space.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_139964 (h0 : uniform_space (has_emptyc (has_inv (random_gen linarith.comp_source)))) : complete_space (has_emptyc (has_inv (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_139965 (h0 : topological_space (add_comm_monoid (option unsigned))) : normal_space (add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_139966 (h0 : functor.add_const (add_monoid (boolean_algebra name)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (boolean_algebra.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_139967 (h0 : topological_space (has_ssubset (has_ssubset linarith.comp_source))) : totally_disconnected_space (has_ssubset (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_139968 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_139969 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_139970 (h0 : functor.add_const (ordered_add_comm_monoid (generalized_boolean_algebra Type)) (has_nndist Type)) : @archimedean.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (ordered_add_comm_monoid.{1} (generalized_boolean_algebra.{1} Type)) (has_nndist.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_139971 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_139972 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} h0 (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_139973 (h0 : ring (canonically_linear_ordered_monoid pos)) : is_domain (canonically_linear_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_139974 (h0 : uniform_space (monoid empty)) : complete_space (monoid empty) := sorry --non-trivial
lemma new_lemma_139975 (h0 : group (ring (normed_comm_ring (has_to_string name)))) : normalizer_condition (ring (normed_comm_ring (has_to_string name))) := sorry --non-trivial
lemma new_lemma_139976 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) Type) : @regular_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (normed_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_139977 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (partial_order.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_139978 (h0 : group (boolean_algebra.core (comm_group pos))) : group.fg (boolean_algebra.core (comm_group pos)) := sorry --non-trivial
lemma new_lemma_139979 (h0 : list (cancel_monoid (option num))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_139980 (h0 : ring (has_zero (ring name))) : rank_condition (has_zero (ring name)) := sorry --non-trivial
lemma new_lemma_139981 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (ordered_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_139982 (h0 : functor.add_const (complete_lattice (has_zero name)) pos) : @is_compactly_generated.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_139983 (h0 : topological_space (has_nndist (has_Inf (ring (has_Inf (has_pos_part (has_add Type))))))) : totally_separated_space (has_nndist (has_Inf (ring (has_Inf (has_pos_part (has_add Type)))))) := sorry --non-trivial
lemma new_lemma_139984 (h0 : topological_space (complete_distrib_lattice (ordered_comm_ring (has_pos_part pos)))) : preirreducible_space (complete_distrib_lattice (ordered_comm_ring (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_139985 (h0 : topological_space (has_neg_part (has_add ennreal))) : t1_space (has_neg_part (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_139986 (h0 : functor.add_const Prop (has_neg_part (has_add Type))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_139987 (h0 : topological_space (canonically_ordered_comm_semiring (add_comm_monoid Type))) : preirreducible_space (canonically_ordered_comm_semiring (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_139988 (h0 : ring (ordered_cancel_add_comm_monoid (has_to_string (has_to_string ennreal)))) : is_principal_ideal_ring (ordered_cancel_add_comm_monoid (has_to_string (has_to_string ennreal))) := sorry --non-trivial
lemma new_lemma_139989 (h0 : functor.add_const (group (has_bot real)) pos) : @is_simple_group.{0} (has_bot.{0} real) (@functor.add_const.run.{0 0} (group.{0} (has_bot.{0} real)) pos h0)  := sorry --non-trivial
lemma new_lemma_139990 (h1 : group (distrib to_additive.value_type)) : is_cyclic (distrib to_additive.value_type) := sorry --non-trivial
lemma new_lemma_139991 (h0 : add_group (has_star congr_arg_kind)) : is_add_cyclic (has_star congr_arg_kind) := sorry --non-trivial
lemma new_lemma_139992 (h0 : topological_space (as_linear_order (option (option (comm_monoid unsigned))))) : t0_space (as_linear_order (option (option (comm_monoid unsigned)))) := sorry --non-trivial
lemma new_lemma_139993 (h0 : function.extfun Type group) : @group.fg.{0} (non_assoc_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (non_assoc_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_139994 (h0 : topological_space (has_one (has_top num))) : discrete_topology (has_one (has_top num)) := sorry --non-trivial
lemma new_lemma_139995 (h0 : functor.add_const (ordered_comm_monoid (has_pos_part linarith.comp)) (has_Inf pos)) : @has_exists_mul_of_le.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_pos_part.{0} linarith.comp)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_139996 (h0 : functor.comp ordered_comm_monoid boolean_algebra.core Type) : @has_exists_mul_of_le.{1} (boolean_algebra.core.{1} Type) (@functor.comp.run.{1 1 1} ordered_comm_monoid.{1} boolean_algebra.core.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_139997 (h0 : topological_space (has_pos_part (has_Inf linarith.comp))) : preconnected_space (has_pos_part (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_139998 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_neg Type)) := sorry --non-trivial
lemma new_lemma_139999 (h2 : ring (has_nnnorm to_additive.value_type)) : rank_condition (has_nnnorm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_140000 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_140001 (h0 : cancel_comm_monoid_with_zero (left_cancel_monoid (semiring (semiring num)))) : unique_factorization_monoid (left_cancel_monoid (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_140002 (h0 : functor.add_const (ring (ordered_comm_monoid pos)) Type) : @rank_condition.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (ordered_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_140003 (h0 : function.extfun Type (functor.add_const (topological_space (mul_zero_class empty)))) : @discrete_topology.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (mul_zero_class.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_140004 (h0 : functor.add_const (group (mul_zero_class num)) num) : @normalizer_condition.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (group.{0} (mul_zero_class.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_140005 (h0 : topological_space (comm_group (has_neg_part ordering))) : t0_space (comm_group (has_neg_part ordering)) := sorry --non-trivial
lemma new_lemma_140006 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @normal_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_140007 (h0 : monoid string_imp) : monoid.fg string_imp := sorry --non-trivial
lemma new_lemma_140008 (h0 : ring (with_one (has_norm (semiring (semiring congr_arg_kind))))) : strong_rank_condition (with_one (has_norm (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_140009 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_zero Type)) name) : @unique_factorization_monoid.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (has_zero.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_140010 (h0 : topological_space (boolean_algebra linarith.comp_source)) : totally_disconnected_space (boolean_algebra linarith.comp_source) := sorry --non-trivial
lemma new_lemma_140011 (h0 : functor.add_const (topological_space (comm_group Type)) (has_neg (has_neg linarith.comp))) : @regular_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) (has_neg.{0} (has_neg.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_140012 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_140013 (h0 : prod (has_neg_part (semigroup unsigned)) (has_neg_part (semigroup unsigned))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_140014 (h0 : list (with_bot fun_info)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_140015 (h0 : uniform_space (sub_neg_monoid (has_Inf (has_Inf name)))) : separated_space (sub_neg_monoid (has_Inf (has_Inf name))) := sorry --non-trivial
lemma new_lemma_140016 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_cancel_monoid environment.implicit_infer_kind)) (finset Type)) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_140017 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_star.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_star.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_140018 (h0 : set (has_nnnorm enat)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_140019 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_140020 (h0 : topological_space (ring (has_add name))) : preconnected_space (ring (has_add name)) := sorry --non-trivial
lemma new_lemma_140021 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_140022 (h0 : ring (has_pos_part (ring Type))) : rank_condition (has_pos_part (ring Type)) := sorry --non-trivial
lemma new_lemma_140023 (h0 : topological_space (finset (has_neg (has_add name)))) : t1_space (finset (has_neg (has_add name))) := sorry --non-trivial
lemma new_lemma_140024 (h0 : group (measurable_space linarith.ineq)) : is_cyclic (measurable_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_140025 (h0 : monoid (has_inter num)) : monoid.fg (has_inter num) := sorry --non-trivial
lemma new_lemma_140026 (h0 : topological_space (has_dist num)) : irreducible_space (has_dist num) := sorry --non-trivial
lemma new_lemma_140027 (h0 : functor.add_const (finset (ordered_comm_monoid pos)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_140028 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) (finset pos)) : @sequential_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_140029 (h0 : not (function.extfun (Type 1) ring -> false)) : @strong_rank_condition.{1} (plift.{1} num) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@classical.by_contradiction'.{3} (function.extfun.{3 2} (Type 1) ring.{1}) h0) (plift.{1} num))  := sorry --non-trivial
lemma new_lemma_140030 (h0 : complete_lattice (simple_graph (has_add (has_to_string Type)))) : complete_lattice.is_Sup_finite_compact (simple_graph (has_add (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_140031 (h0 : function.extfun nat fin) : @monoid.fg.{0} (add_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (monoid.{0} (add_comm_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_140032 (h1 : has_mem.mem znum has_emptyc.emptyc) : @is_domain.{0} znum (@finset.pi.empty.{1 0} Type ring.{0} znum h1)  := sorry --non-trivial
lemma new_lemma_140033 (h0 : topological_space char) : t0_space char := sorry --non-trivial
lemma new_lemma_140034 (h0 : functor.add_const (functor.add_const (topological_space linarith.comp) pos) (has_neg Type)) : @path_connected_space.{0} linarith.comp (@functor.add_const.run.{0 0} (topological_space.{0} linarith.comp) pos (@functor.add_const.run.{0 1} (functor.add_const.{0 0} (topological_space.{0} linarith.comp) pos) (has_neg.{1} Type) h0))  := sorry --non-trivial
lemma new_lemma_140035 (h0 : topological_space (comm_semigroup name)) : path_connected_space (comm_semigroup name) := sorry --non-trivial
lemma new_lemma_140036 (h0 : group (has_neg (option pos))) : group.fg (has_neg (option pos)) := sorry --non-trivial
lemma new_lemma_140037 (h0 : option (ring (linear_ordered_comm_group_with_zero (mul_one_class linarith.ineq)))) (h1 : coe_sort (option.is_some h0)) : @rank_condition.{0} (linear_ordered_comm_group_with_zero.{0} (mul_one_class.{0} linarith.ineq)) (@option.get.{0} (ring.{0} (linear_ordered_comm_group_with_zero.{0} (mul_one_class.{0} linarith.ineq))) h0 h1)  := sorry --non-trivial
lemma new_lemma_140038 (h0 : topological_space (mul_zero_class (finset ennreal))) : normal_space (mul_zero_class (finset ennreal)) := sorry --non-trivial
lemma new_lemma_140039 (h0 : functor.add_const (ring (complete_distrib_lattice pos)) Type) : @rank_condition.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (complete_distrib_lattice.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_140040 (h0 : function.extfun (Type 1) semiring) : @is_noetherian_ring.{1} (sub_neg_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} h0 (sub_neg_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_140041 (h0 : complete_lattice (has_add (sub_neg_monoid pos))) : is_compactly_generated (has_add (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_140042 (h0 : group (has_to_string (has_pos_part linarith.comp))) : normalizer_condition (has_to_string (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_140043 (h0 : ring (dlist to_additive.value_type)) : rank_condition (dlist to_additive.value_type) := sorry --non-trivial
lemma new_lemma_140044 (h0 : filter (canonically_ordered_comm_semiring (ring linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_140045 (h0 : functor.add_const (group (add_right_cancel_monoid num)) num) : @group.fg.{0} (add_right_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (group.{0} (add_right_cancel_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_140046 (h0 : filter (semiring (semiring unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_140047 (h0 : topological_space (canonically_ordered_monoid (has_add name))) : totally_separated_space (canonically_ordered_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_140048 (h0 : group (add_cancel_monoid (has_neg (has_neg (finset linarith.comp))))) : group.fg (add_cancel_monoid (has_neg (has_neg (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_140049 (h0 : not (topological_space (has_sub num) -> false)) : @totally_disconnected_space.{0} (has_sub.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_140050 (h0 : has_mem.mem (random_gen num) has_emptyc.emptyc) : @complete_space.{0} (random_gen.{0} num) (@finset.pi.empty.{1 0} Type uniform_space.{0} (random_gen.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_140051 (h0 : topological_space (cancel_monoid environment.implicit_infer_kind)) : totally_separated_space (cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_140052 (h0 : topological_space (measurable_space (has_norm linarith.comp))) : totally_separated_space (measurable_space (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_140053 (h0 : functor.add_const (topological_space (has_nndist unsigned)) linarith.comp) : @topological_space.separable_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_140054 (h0 : finset (has_top (semiring num))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_140055 (h0 h1 : multiset (has_le std_gen)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_140056 (h0 : topological_space (comm_ring (random_gen (has_ssubset (random_gen fun_info))))) : totally_disconnected_space (comm_ring (random_gen (has_ssubset (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_140057 (h2 : complete_lattice nnreal) : is_compactly_generated nnreal := sorry --non-trivial
lemma new_lemma_140058 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @irreducible_space.{0} linarith.ineq (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) linarith.ineq)  := sorry --non-trivial
lemma new_lemma_140059 (h0 : unsigned -> unsigned -> Prop) : is_preorder unsigned h0 := sorry --non-trivial
lemma new_lemma_140060 (h0 : ring (linear_ordered_semiring (random_gen fun_info))) : rank_condition (linear_ordered_semiring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_140061 (h3 : semiring (nondiscrete_normed_field char)) (h4 : ideal (nondiscrete_normed_field char)) : ideal.is_prime h4 := sorry --non-trivial
lemma new_lemma_140062 (h0 : char -> char) : function.involutive h0 := sorry --non-trivial
lemma new_lemma_140063 (h0 : functor.add_const (function.extfun (Type 1) ring) Type) : @is_domain.{1} Type (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) Type h0) Type)  := sorry --non-trivial
lemma new_lemma_140064 (h0 : group (linear_ordered_add_comm_monoid_with_top congr_arg_kind)) : is_simple_group (linear_ordered_add_comm_monoid_with_top congr_arg_kind) := sorry --non-trivial
lemma new_lemma_140065 (h0 : functor.add_const (function.extfun Type list) (has_add linarith.comp)) : palindrome (function.extfun_app (functor.add_const.run h0) (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_140066 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @strong_rank_condition.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_140067 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (linear_ordered_comm_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} num))  := sorry --non-trivial
lemma new_lemma_140068 (h2 : has_mem.mem to_additive.value_type has_emptyc.emptyc) : @is_atomistic.{0} to_additive.value_type (@finset.pi.empty.{1 0} Type complete_lattice.{0} to_additive.value_type h2)  := sorry --non-trivial
lemma new_lemma_140069 (h0 : topological_space (non_assoc_semiring (semiring (semiring congr_arg_kind)))) : t0_space (non_assoc_semiring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_140070 (h0 : functor.add_const (ring (has_to_string Type)) Type) : @strong_rank_condition.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (has_to_string.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_140071 (h0 : group (linear_ordered_add_comm_group (random_gen (random_gen linarith.ineq)))) : is_cyclic (linear_ordered_add_comm_group (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_140072 (h1 : group (id (id (random_gen linarith.ineq)))) : normalizer_condition (id (id (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_140073 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (has_Inf.{0} name) (@matrix.vec_empty.{0} (ring.{0} (has_Inf.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_140074 (h0 : topological_space (has_neg_part (has_add (comm_group name)))) : sequential_space (has_neg_part (has_add (comm_group name))) := sorry --non-trivial
lemma new_lemma_140075 (h0 : has_mem.mem (normed_group num) has_emptyc.emptyc) : @is_cyclic.{0} (normed_group.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (normed_group.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_140076 (h0 : topological_space (measurable_space (random_gen (has_top fun_info)))) : totally_separated_space (measurable_space (random_gen (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_140077 (h0 : function.extfun Type group) : @group.fg.{0} (bin_tree.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (bin_tree.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_140078 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (denumerable.{0} string_imp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (denumerable.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_140079 (h0 : group rat) : is_cyclic rat := sorry --non-trivial
lemma new_lemma_140080 (h2 : ring (distrib reducibility_hints)) : rank_condition (distrib reducibility_hints) := sorry --non-trivial
lemma new_lemma_140081 (h0 : group (ordered_comm_ring (has_add (has_add Type)))) : normalizer_condition (ordered_comm_ring (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_140082 (h0 : ring (finset (finset ennreal))) : rank_condition (finset (finset ennreal)) := sorry --non-trivial
lemma new_lemma_140083 (h0 : topological_space (comm_semigroup (has_bot real))) : totally_separated_space (comm_semigroup (has_bot real)) := sorry --non-trivial
lemma new_lemma_140084 (h0 : add_group (ordered_comm_monoid (ring Type))) : is_add_cyclic (ordered_comm_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_140085 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) pos) : @sequential_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_140086 (h0 : set (add_comm_semigroup ereal)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_140087 (h0 : complete_lattice (cancel_monoid name)) : is_compactly_generated (cancel_monoid name) := sorry --non-trivial
lemma new_lemma_140088 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc empty))) : @is_cyclic.{0} (has_emptyc.{0} empty) (@finset.pi.empty.{1 0} Type group.{0} (has_emptyc.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_140089 (h0 : function.extfun Type group) : @normalizer_condition.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_140090 (h0 : functor.comp ring has_zero Type) : @is_principal_ideal_ring.{1} (has_zero.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} has_zero.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_140091 (h0 : topological_space (ordered_cancel_add_comm_monoid (option empty))) : discrete_topology (ordered_cancel_add_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_140092 (h0 : function.extfun Type (functor.comp topological_space semigroup)) : @topological_space.separable_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} semigroup.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} semigroup.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_140093 (h0 : topological_space (non_assoc_semiring (semiring empty))) : t1_space (non_assoc_semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_140094 (h0 : functor.add_const (monoid (boolean_algebra pos)) Type) : @monoid.fg.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (monoid.{0} (boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_140095 (h0 : list (dlist (has_ssubset (random_gen (has_ssubset (has_nnnorm (random_gen char))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_140096 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (div_inv_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (div_inv_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_140097 (h0 : topological_space (has_top unsigned)) : t0_space (has_top unsigned) := sorry --non-trivial
lemma new_lemma_140098 (h0 : complete_lattice (semiring (has_norm num))) : complete_lattice.is_Sup_finite_compact (semiring (has_norm num)) := sorry --non-trivial
lemma new_lemma_140099 (h1 : topological_space (has_compl string_imp)) : totally_disconnected_space (has_compl string_imp) := sorry --non-trivial
lemma new_lemma_140100 (h0 : functor.add_const (finset (complete_distrib_lattice linarith.comp)) (has_nndist linarith.comp)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_140101 (h1 : ring (semi_normed_comm_ring string_imp)) : rank_condition (semi_normed_comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_140102 (h0 : functor.comp topological_space mul_zero_class Type) : @normal_space.{1} (mul_zero_class.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} mul_zero_class.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_140103 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @sequential_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_140104 (h0 : finset (measurable_space.dynkin_system (semiring (semiring (semiring (semiring empty)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_140105 (h0 : add_group (has_nndist (option pos))) : is_add_cyclic (has_nndist (option pos)) := sorry --non-trivial
lemma new_lemma_140106 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @totally_separated_space.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_140107 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_140108 (h0 : topological_space (has_norm (semiring (has_top (has_top empty))))) : normal_space (has_norm (semiring (has_top (has_top empty)))) := sorry --non-trivial
lemma new_lemma_140109 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @separated_space.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 uniform_space.{1}) (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_140110 (h0 : functor.add_const (complete_lattice (semigroup name)) pos) : @is_atomistic.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_140111 (h0 : finset (add_semigroup unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_140112 (h0 : list (semiring (option unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_140113 (h0 : group (has_top (distrib_lattice to_additive.value_type))) : is_cyclic (has_top (distrib_lattice to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_140114 (h0 : function.extfun Type group) : @group.fg.{0} (has_one.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (has_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_140115 (h0 : add_group (simple_graph Type)) : is_add_cyclic (simple_graph Type) := sorry --non-trivial
lemma new_lemma_140116 (h0 : topological_space (add_cancel_comm_monoid linarith.comp_source)) : path_connected_space (add_cancel_comm_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_140117 (h0 : functor.add_const (filter (boolean_algebra pos)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_140118 (h0 : functor.add_const (finset (add_cancel_comm_monoid empty)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_140119 (h0 : has_neg (has_pos_part (has_pos_part name))) (h1 : measurable_space (has_pos_part (has_pos_part name))) : has_measurable_neg (has_pos_part (has_pos_part name)) := sorry --non-trivial
lemma new_lemma_140120 (h0 : functor.add_const (topological_space (ring linarith.comp)) (has_neg environment.implicit_infer_kind)) : @locally_compact_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_140121 (h0 : topological_space (boolean_algebra (comm_group (has_add (has_add Type))))) : normal_space (boolean_algebra (comm_group (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_140122 (h0 : list (has_Inf (has_Inf pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_140123 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_140124 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_inner.{0 0} empty empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_inner.{0 0} empty empty))  := sorry --non-trivial
lemma new_lemma_140125 (h0 : group (has_add (ring (has_neg Type)))) : is_cyclic (has_add (ring (has_neg Type))) := sorry --non-trivial
lemma new_lemma_140126 (h0 : functor.add_const (filter (ring pos)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_140127 (h0 : has_mem.mem (measurable_space num) has_emptyc.emptyc) : filter.ne_bot (finset.pi.empty filter (measurable_space num) h0) := sorry --non-trivial
lemma new_lemma_140128 (h0 : functor.add_const (topological_space (mul_zero_class unsigned)) Type) : @preconnected_space.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (mul_zero_class.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_140129 (h0 : topological_space (normed_group (has_inv (has_inv linarith.comp_source)))) : totally_separated_space (normed_group (has_inv (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_140130 (h0 : topological_space (has_to_string environment.implicit_infer_kind)) : topological_space.separable_space (has_to_string environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_140131 (h0 : has_mem.mem (has_top linarith.comp_source) has_emptyc.emptyc) : @rank_condition.{0} (has_top.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (has_top.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_140132 (h0 : function.extfun Type monoid) : @monoid.fg.{0} to_additive.value_type (@function.extfun_app.{2 1} Type monoid.{0} h0 to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_140133 (h2 : complete_lattice (distrib (mul_one_class linarith.ineq))) : is_compactly_generated (distrib (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_140134 (h0 : uniform_space (cancel_monoid (option (option (option unsigned))))) : complete_space (cancel_monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_140135 (h0 : set (linear_ordered_comm_monoid_with_zero (normed_field (normed_field linarith.ineq)))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_140136 (h0 : measurable_space (power_series (complete_lattice congr_arg_kind))) (h1 : topological_space (power_series (complete_lattice congr_arg_kind))) (h2 : measure_theory.measure (power_series (complete_lattice congr_arg_kind))) : measure_theory.measure.regular h2 := sorry --non-trivial
lemma new_lemma_140137 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_140138 (h0 : functor.add_const (ordered_comm_monoid (has_zero name)) Type) : @has_exists_mul_of_le.{0} (has_zero.{0} name) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (has_zero.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_140139 (h0 : cancel_comm_monoid_with_zero (has_Sup empty)) : unique_factorization_monoid (has_Sup empty) := sorry --non-trivial
lemma new_lemma_140140 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @path_connected_space.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_140141 (h0 : topological_space (boolean_algebra (has_add Type))) : preconnected_space (boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_140142 (h0 : functor.add_const (functor.add_const (topological_space pos) pos) pos) : @t1_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} pos) pos) pos h0))  := sorry --non-trivial
lemma new_lemma_140143 (h0 : functor.add_const (add_group (ring linarith.comp)) (has_pos_part (finset linarith.comp))) : @is_add_cyclic.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (ring.{0} linarith.comp)) (has_pos_part.{0} (finset.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_140144 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (encodable.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (encodable.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_140145 (h0 : topological_space (linear_ordered_comm_group (finset (finset (finset (finset linarith.comp)))))) : discrete_topology (linear_ordered_comm_group (finset (finset (finset (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_140146 (h0 : topological_space (canonically_ordered_monoid (has_Inf (has_Inf (has_add (has_Inf (has_Inf pos))))))) : regular_space (canonically_ordered_monoid (has_Inf (has_Inf (has_add (has_Inf (has_Inf pos)))))) := sorry --non-trivial
lemma new_lemma_140147 (h0 : functor.add_const (function.extfun Type uniform_space) Type) : @separated_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) Type h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_140148 (h0 : topological_space (free_add_monoid (semiring (semiring num)))) : path_connected_space (free_add_monoid (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_140149 (h0 : topological_space (pseudo_metric_space congr_arg_kind)) : locally_compact_space (pseudo_metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_140150 (h0 : topological_space (random_gen (semiring (semiring (semiring empty))))) : path_connected_space (random_gen (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_140151 (h0 : not (topological_space (dlist (random_gen (random_gen (has_nnnorm fun_info)))) -> false)) : @t0_space.{0} (dlist.{0} (random_gen.{0} (random_gen.{0} (has_nnnorm.{0} fun_info)))) (@classical.by_contradiction'.{1} (topological_space.{0} (dlist.{0} (random_gen.{0} (random_gen.{0} (has_nnnorm.{0} fun_info))))) h0)  := sorry --non-trivial
lemma new_lemma_140152 (h0 : group (linear_ordered_comm_group ennreal)) : is_simple_group (linear_ordered_comm_group ennreal) := sorry --non-trivial
lemma new_lemma_140153 (h0 : functor.add_const (ring (generalized_boolean_algebra Type)) name) : @rank_condition.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (generalized_boolean_algebra.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_140154 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) Type) : @totally_disconnected_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_140155 (h1 : uniform_space (add_comm_semigroup (add_comm_semigroup linarith.ineq))) : complete_space (add_comm_semigroup (add_comm_semigroup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_140156 (h0 : ordered_semiring (has_bot real)) (h1 : topological_space (add_comm_monoid (floor_semiring (has_bot real)))) : preirreducible_space (add_comm_monoid (floor_semiring (has_bot real))) := sorry --non-trivial
lemma new_lemma_140157 (h0 : topological_space (has_pos_part (has_add (has_Inf real)))) : irreducible_space (has_pos_part (has_add (has_Inf real))) := sorry --non-trivial
lemma new_lemma_140158 (h0 : functor.add_const (filter (ring name)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_140159 (h1 : list (topological_space (semi_normed_ring char))) (h2 : ne h1 list.nil) : @t0_space.{0} (semi_normed_ring.{0} char) (@list.last.{0} (topological_space.{0} (semi_normed_ring.{0} char)) h1 h2)  := sorry --non-trivial
lemma new_lemma_140160 (h0 : fin has_zero.zero) : @is_simple_group.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (group.{0} (has_bot.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_140161 (h0 : finset (ordered_comm_ring (ring pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_140162 (h0 : functor.add_const (topological_space (add_comm_monoid environment.implicit_infer_kind)) Type) : @loc_path_connected_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_140163 (h1 : ring (random_gen linarith.comp)) : strong_rank_condition (random_gen linarith.comp) := sorry --non-trivial
lemma new_lemma_140164 (h0 : topological_space (partial_order (semiring num))) : topological_space.separable_space (partial_order (semiring num)) := sorry --non-trivial
lemma new_lemma_140165 (h0 : topological_space ereal) (h1 : measurable_space ereal) : opens_measurable_space ereal := sorry --non-trivial
lemma new_lemma_140166 (h0 : ring (linear_ordered_semiring (semiring (semiring (semiring (semiring empty)))))) : rank_condition (linear_ordered_semiring (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_140167 (h0 : ring (linear_ordered_add_comm_group (has_inv linarith.comp_source))) : rank_condition (linear_ordered_add_comm_group (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_140168 (h0 : topological_space (with_one (semiring num))) : preirreducible_space (with_one (semiring num)) := sorry --non-trivial
lemma new_lemma_140169 (h0 : topological_space (normed_group linarith.comp)) : normal_space (normed_group linarith.comp) := sorry --non-trivial
lemma new_lemma_140170 (h0 : topological_space (has_Inf (has_add (has_pos_part Type)))) : t1_space (has_Inf (has_add (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_140171 (h0 : topological_space (semigroup (semigroup (semigroup name)))) : preconnected_space (semigroup (semigroup (semigroup name))) := sorry --non-trivial
lemma new_lemma_140172 (h0 : not (topological_space (non_assoc_semiring num) -> false)) : @t0_space.{0} (non_assoc_semiring.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (non_assoc_semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_140173 (h0 : function.extfun Type filter) : @filter.Limsup.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice) (@function.extfun_app.{2 1} Type filter.{0} h0 Prop)  := sorry --non-trivial
lemma new_lemma_140174 (h0 : functor.add_const (list (generalized_boolean_algebra pos)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_140175 (h0 : topological_space (boolean_algebra (has_neg_part (add_comm_monoid (has_neg_part pos))))) : locally_compact_space (boolean_algebra (has_neg_part (add_comm_monoid (has_neg_part pos)))) := sorry --non-trivial
lemma new_lemma_140176 (h0 : add_group (has_zero (finset (has_nndist Type)))) : is_add_cyclic (has_zero (finset (has_nndist Type))) := sorry --non-trivial
lemma new_lemma_140177 (h1 : not (group (linear_ordered_add_comm_group fun_info) -> false)) : @is_cyclic.{0} (linear_ordered_add_comm_group.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_add_comm_group.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_140178 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_140179 (h0 : topological_space (with_bot (has_norm unsigned))) : path_connected_space (with_bot (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_140180 (h0 : topological_space bool) : locally_compact_space bool := sorry --non-trivial
lemma new_lemma_140181 (h0 : group (has_zero ennreal)) : normalizer_condition (has_zero ennreal) := sorry --non-trivial
lemma new_lemma_140182 (h0 : ordered_comm_monoid (add_cancel_monoid (finset (has_add pos)))) : has_exists_mul_of_le (add_cancel_monoid (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_140183 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (add_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_140184 (h0 : not (group (normed_group (random_gen fun_info)) -> false)) : @is_cyclic.{0} (normed_group.{0} (random_gen.{0} fun_info)) (@classical.by_contradiction'.{1} (group.{0} (normed_group.{0} (random_gen.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_140185 (h0 : functor.add_const (ring (has_zero linarith.comp)) pos) : @rank_condition.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_140186 (h0 : topological_space (random_gen string_imp)) (h1 : preorder (random_gen string_imp)) : order_closed_topology (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_140187 (h0 : ring (non_unital_non_assoc_semiring (has_div to_additive.value_type))) : rank_condition (non_unital_non_assoc_semiring (has_div to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_140188 (h0 : ring (ring (add_comm_monoid (has_add pos)))) : is_principal_ideal_ring (ring (add_comm_monoid (has_add pos))) := sorry --non-trivial
lemma new_lemma_140189 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_140190 (h0 : list (complete_distrib_lattice Type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_140191 (h0 : group (has_inv (has_nnnorm (has_nnnorm linarith.ineq)))) : group.fg (has_inv (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_140192 (h0 : functor.add_const (topological_space (has_nndist unsigned)) Type) : @preirreducible_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_140193 (h0 : functor.add_const (add_group (boolean_algebra name)) environment.implicit_infer_kind) : @is_add_cyclic.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (boolean_algebra.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_140194 (h0 : complete_lattice (id unsigned)) : complete_lattice.is_Sup_finite_compact (id unsigned) := sorry --non-trivial
lemma new_lemma_140195 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (left_cancel_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_140196 (h0 : functor.add_const (topological_space (free_add_monoid empty)) unsigned) : @locally_compact_space.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_140197 (h0 : functor.add_const (function.extfun Type topological_space) name) : @preconnected_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_140198 (h0 : function.extfun (Type 1) group) : @is_cyclic.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_140199 (h0 : set (nondiscrete_normed_field ereal)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_140200 (h0 : finset (finset pos)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_140201 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (sub_neg_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_140202 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) (has_neg linarith.comp)) : @normal_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_140203 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @totally_disconnected_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_140204 (h0 : uniform_space (ordered_ring (semiring empty))) : separated_space (ordered_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_140205 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring linarith.comp))) : @irreducible_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_140206 (h0 : uniform_space (ring (ordered_ring linarith.comp))) : separated_space (ring (ordered_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_140207 (h0 : functor.add_const (ring (has_pos_part Type)) pos) : @is_domain.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_pos_part.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_140208 (h0 : filter (cancel_monoid unsigned)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_140209 (h0 : not (topological_space (normed_group fun_info) -> false)) : @t0_space.{0} (normed_group.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_140210 (h0 : not (has_mem.mem (normed_group num) has_emptyc.emptyc -> false)) : @path_connected_space.{0} (normed_group.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_140211 (h0 : list (canonically_ordered_add_monoid empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_140212 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (comm_ring.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (comm_ring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_140213 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_140214 (h0 : group (has_nndist (option unsigned))) : normalizer_condition (has_nndist (option unsigned)) := sorry --non-trivial
lemma new_lemma_140215 (h0 : topological_space (is_R_or_C num)) : locally_compact_space (is_R_or_C num) := sorry --non-trivial
lemma new_lemma_140216 (h0 : ring (denumerable (normed_field char))) : strong_rank_condition (denumerable (normed_field char)) := sorry --non-trivial
lemma new_lemma_140217 (h0 : topological_space (boolean_algebra (has_neg (has_add (mul_one_class Type))))) : discrete_topology (boolean_algebra (has_neg (has_add (mul_one_class Type)))) := sorry --non-trivial
lemma new_lemma_140218 (h0 : functor.add_const (topological_space (add_comm_monoid name)) Type) : @t0_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_140219 (h2 : not (topological_space (normed_field linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (normed_field.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_field.{0} linarith.comp_source)) h2)  := sorry --non-trivial
lemma new_lemma_140220 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_140221 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_140222 (h0 : topological_space (has_top (semiring (semiring (semiring (semiring congr_arg_kind)))))) : irreducible_space (has_top (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_140223 (h0 : topological_space (linear_order empty)) : loc_path_connected_space (linear_order empty) := sorry --non-trivial
lemma new_lemma_140224 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_140225 (h0 : topological_space (semi_normed_ring (has_ssubset linarith.ineq))) : t0_space (semi_normed_ring (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_140226 (h2 : complete_lattice (nondiscrete_normed_field std_gen)) : complete_lattice.is_Sup_finite_compact (nondiscrete_normed_field std_gen) := sorry --non-trivial
lemma new_lemma_140227 (h0 : topological_space (has_add (sub_neg_monoid Type))) : totally_disconnected_space (has_add (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_140228 (h0 : filter (with_one (with_bot num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_140229 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_140230 (h0 : topological_space (has_nndist (has_neg_part (has_neg_part Type)))) : loc_path_connected_space (has_nndist (has_neg_part (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_140231 (h0 : topological_space (group enat)) : totally_disconnected_space (group enat) := sorry --non-trivial
lemma new_lemma_140232 (h0 : uniform_space (ordered_comm_monoid Type)) : separated_space (ordered_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_140233 (h0 : functor.add_const (topological_space (has_star empty)) congr_arg_kind) : @t1_space.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_140234 (h0 : group (normed_field (has_nnnorm (has_nnnorm (random_gen (has_nnnorm char)))))) : is_cyclic (normed_field (has_nnnorm (has_nnnorm (random_gen (has_nnnorm char))))) := sorry --non-trivial
lemma new_lemma_140235 (h0 : functor.add_const (uniform_space (mul_zero_class pos)) Type) : @separated_space.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (mul_zero_class.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_140236 (h0 : topological_space (linear_ordered_semiring (semiring empty))) : totally_separated_space (linear_ordered_semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_140237 (h0 : functor.add_const (function.extfun Type semiring) environment.implicit_infer_kind) : @is_noetherian_ring.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) environment.implicit_infer_kind h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_140238 (h0 : filter (with_one linarith.comp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_140239 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_140240 (h0 : uniform_space (non_unital_non_assoc_semiring (mul_one_class char))) : complete_space (non_unital_non_assoc_semiring (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_140241 (h1 : finset (linear_ordered_add_comm_group to_additive.value_type)) : finset.nonempty h1 := sorry --non-trivial
lemma new_lemma_140242 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @totally_separated_space.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_140243 (h0 : functor.add_const (add_monoid Type) (has_add environment.implicit_infer_kind)) : @add_monoid.fg.{1} Type (@functor.add_const.run.{1 0} (add_monoid.{1} Type) (has_add.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_140244 (h0 : group (normed_group (has_norm (has_norm fun_info)))) : normalizer_condition (normed_group (has_norm (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_140245 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (denumerable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (denumerable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_140246 (h0 : not (topological_space (has_norm num) -> false)) : @preirreducible_space.{0} (has_norm.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_140247 (h0 : functor.add_const (topological_space pos) (finset (finset (has_neg pos)))) : @regular_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) (finset.{0} (finset.{0} (has_neg.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_140248 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : multiset.nodup (function.extfun_app (function.extfun_app h0 multiset) (has_star empty)) := sorry --non-trivial
lemma new_lemma_140249 (h0 : complete_lattice (has_nndist (mul_zero_class (mul_zero_class ennreal)))) : is_compactly_generated (has_nndist (mul_zero_class (mul_zero_class ennreal))) := sorry --non-trivial
lemma new_lemma_140250 (h0 : functor.add_const (semiring (ring linarith.comp)) (has_pos_part linarith.comp)) : @is_noetherian_ring.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (ring.{0} linarith.comp)) (has_pos_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_140251 (h0 : filter (has_norm (has_emptyc (with_bot (with_bot string_imp))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_140252 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_nndist.{0} int) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} int))  := sorry --non-trivial
lemma new_lemma_140253 (h0 : topological_space (boolean_algebra (has_add (has_add environment.implicit_infer_kind)))) : preconnected_space (boolean_algebra (has_add (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_140254 (h0 : ring (has_add pos)) : rank_condition (has_add pos) := sorry --non-trivial
lemma new_lemma_140255 (h0 : topological_space (has_add (mul_one_class pos))) : regular_space (has_add (mul_one_class pos)) := sorry --non-trivial
lemma new_lemma_140256 (h0 : function.extfun Type group) : @group.fg.{0} (pseudo_metric_space.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type group.{0} h0 (pseudo_metric_space.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_140257 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (semigroup Type)) := sorry --non-trivial
lemma new_lemma_140258 (h5 : ring linarith.ineq) : rank_condition linarith.ineq := sorry --non-trivial
lemma new_lemma_140259 (h0 : list (has_to_string congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_140260 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring environment.implicit_infer_kind)) name) : @loc_path_connected_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_140261 (h0 : topological_space (has_compl (has_ssubset linarith.comp_source))) : t0_space (has_compl (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_140262 (h0 : functor.add_const (topological_space (plift num)) empty) : @discrete_topology.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_140263 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_inter.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_140264 (h0 h1 : simple_graph std_gen) : simple_graph.is_subgraph h0 h1 := sorry --non-trivial
lemma new_lemma_140265 (h0 : filter (with_zero (has_inv linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_140266 (h0 : topological_space (has_bot (has_pos_part (has_Inf Type)))) : preirreducible_space (has_bot (has_pos_part (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_140267 (h0 : topological_space (comm_group (finset (comm_group linarith.comp)))) : preirreducible_space (comm_group (finset (comm_group linarith.comp))) := sorry --non-trivial
lemma new_lemma_140268 (h0 : monoid (measure_theory.measure_space (semiring unsigned))) : monoid.fg (measure_theory.measure_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_140269 (h0 : topological_space (with_bot (comm_ring (comm_ring (comm_ring fun_info))))) : path_connected_space (with_bot (comm_ring (comm_ring (comm_ring fun_info)))) := sorry --non-trivial
lemma new_lemma_140270 (h0 : functor.add_const (add_monoid (linear_ordered_field name)) name) : @add_monoid.fg.{0} (linear_ordered_field.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (linear_ordered_field.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_140271 (h0 : topological_space (nondiscrete_normed_field reducibility_hints)) : totally_disconnected_space (nondiscrete_normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_140272 (h0 : group (boolean_algebra.core (has_add (has_add Type)))) : normalizer_condition (boolean_algebra.core (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_140273 (h0 : filter (ordered_cancel_add_comm_monoid unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_140274 (h0 : topological_space (linear_ordered_comm_group (has_neg ennreal))) : t0_space (linear_ordered_comm_group (has_neg ennreal)) := sorry --non-trivial
lemma new_lemma_140275 (h0 : ring (add_cancel_monoid (add_cancel_monoid name))) : rank_condition (add_cancel_monoid (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_140276 (h0 : has_lt enat) : no_min_order enat := sorry --non-trivial
lemma new_lemma_140277 (h0 : not (topological_space (semiring congr_arg_kind) -> false)) : @irreducible_space.{0} (semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_140278 (h0 : add_group (complete_distrib_lattice (ring pos))) : is_add_cyclic (complete_distrib_lattice (ring pos)) := sorry --non-trivial
lemma new_lemma_140279 (h0 : group (distrib_lattice (has_top to_additive.value_type))) : is_cyclic (distrib_lattice (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_140280 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_140281 (h0 : add_monoid (has_edist unsigned)) : add_monoid.fg (has_edist unsigned) := sorry --non-trivial
lemma new_lemma_140282 (h0 : topological_space (has_zero ennreal)) : path_connected_space (has_zero ennreal) := sorry --non-trivial
lemma new_lemma_140283 (h0 : functor.add_const (add_group (has_nndist ennreal)) unsigned) : @is_add_cyclic.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (add_group.{0} (has_nndist.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_140284 (h1 : ring (topological_space (denumerable to_additive.value_type))) : rank_condition (topological_space (denumerable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_140285 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @totally_disconnected_space.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_140286 (h0 : functor.add_const (topological_space (finset unsigned)) (option empty)) : @topological_space.separable_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} unsigned)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_140287 (h0 : functor.add_const (list (ordered_comm_ring linarith.comp)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_140288 (h0 : topological_space (mul_zero_class (finset name))) : t1_space (mul_zero_class (finset name)) := sorry --non-trivial
lemma new_lemma_140289 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_140290 (h1 : not (topological_space congr_arg_kind -> false)) : @irreducible_space.{0} congr_arg_kind (@classical.by_contradiction'.{1} (topological_space.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_140291 (h0 : functor.add_const (topological_space (comm_group name)) name) : @sequential_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_140292 (h0 : function.extfun nat fin) : @path_connected_space.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_140293 (h0 : functor.add_const (list (complete_distrib_lattice pos)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_140294 (h0 : functor.add_const (topological_space (has_star congr_arg_kind)) empty) : @t0_space.{0} (has_star.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_140295 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_140296 (h0 : function.extfun nat fin) : @preconnected_space.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_140297 (h1 : complete_lattice (has_append (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm string_imp)))))) (h2 : set (has_append (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm string_imp)))))) : complete_lattice.set_independent h2 := sorry --non-trivial
lemma new_lemma_140298 (h0 : topological_space (semigroup (finset (ring linarith.comp)))) : topological_space.separable_space (semigroup (finset (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_140299 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_140300 (h0 : function.extfun Type list) (h1 : nat) (h2 : has_lt.lt h1 (list.length (function.extfun_app h0 Prop))) : list.nth_le (function.extfun_app h0 Prop) h1 h2 := sorry --non-trivial
lemma new_lemma_140301 (h0 : topological_space (with_one (has_top (has_top to_additive.value_type)))) : irreducible_space (with_one (has_top (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_140302 (h0 : function.extfun Type complete_lattice) : complete_lattice.is_Sup_finite_compact (measurable_space (has_top num)) := sorry --non-trivial
lemma new_lemma_140303 (h0 : topological_space (add_cancel_monoid (ring name))) : irreducible_space (add_cancel_monoid (ring name)) := sorry --non-trivial
lemma new_lemma_140304 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (linear_ordered_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (linear_ordered_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_140305 (h0 : not (add_group (has_div reducibility_hints) -> false)) : @is_add_cyclic.{0} (has_div.{0} reducibility_hints) (@classical.by_contradiction'.{1} (add_group.{0} (has_div.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_140306 (h0 : topological_space (normed_lattice_add_comm_group (has_bot (has_add (has_add real))))) : path_connected_space (normed_lattice_add_comm_group (has_bot (has_add (has_add real)))) := sorry --non-trivial
lemma new_lemma_140307 (h0 : group (has_Inf (sub_neg_monoid name))) : group.fg (has_Inf (sub_neg_monoid name)) := sorry --non-trivial
lemma new_lemma_140308 (h0 : functor.add_const (topological_space (linear_ordered_comm_group ennreal)) ennreal) : @t0_space.{0} (linear_ordered_comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_group.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_140309 (h1 : complete_lattice (div_inv_monoid (has_nnnorm char))) : complete_lattice.is_Sup_finite_compact (div_inv_monoid (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_140310 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) fun_info) := sorry --non-trivial
lemma new_lemma_140311 (h0 : topological_space (cancel_monoid Type)) : preirreducible_space (cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_140312 (h0 : monoid (complete_semilattice_Sup (has_inv (random_gen (has_top linarith.comp_source))))) : monoid.fg (complete_semilattice_Sup (has_inv (random_gen (has_top linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_140313 (h2 : group (with_one linarith.comp_source)) : group.fg (with_one linarith.comp_source) := sorry --non-trivial
lemma new_lemma_140314 (h0 : topological_space (has_ssubset (has_nnnorm string.iterator_imp))) : t0_space (has_ssubset (has_nnnorm string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_140315 (h0 : topological_space (canonically_ordered_monoid (has_Inf Type))) : t1_space (canonically_ordered_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_140316 (h0 : group (canonically_ordered_comm_semiring (has_nndist (ring linarith.comp)))) : group.fg (canonically_ordered_comm_semiring (has_nndist (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_140317 (h0 : topological_space (metric_space (semiring unsigned))) : t0_space (metric_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_140318 (h1 : ring (dlist to_additive.value_type)) : strong_rank_condition (dlist to_additive.value_type) := sorry --non-trivial
lemma new_lemma_140319 (h0 : ring (semigroup (option unsigned))) : rank_condition (semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_140320 (h0 : functor.add_const Prop (has_zero Type)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_140321 (h0 : not (add_monoid (measurable_space linarith.comp) -> false)) : @add_monoid.fg.{0} (measurable_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (add_monoid.{0} (measurable_space.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_140322 (h0 : topological_space (normed_field std_gen)) : path_connected_space (normed_field std_gen) := sorry --non-trivial
lemma new_lemma_140323 (h0 : group (boolean_algebra unsigned)) : is_simple_group (boolean_algebra unsigned) := sorry --non-trivial
lemma new_lemma_140324 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (normed_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_140325 (h0 : topological_space (plift (free_add_monoid unsigned))) : loc_path_connected_space (plift (free_add_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_140326 (h0 : uniform_space (is_R_or_C (semiring unsigned))) : separated_space (is_R_or_C (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_140327 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} to_additive.value_type (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_140328 (h0 : topological_space (generalized_boolean_algebra name)) : sequential_space (generalized_boolean_algebra name) := sorry --non-trivial
lemma new_lemma_140329 (h0 : topological_space (partial_order empty)) : normal_space (partial_order empty) := sorry --non-trivial
lemma new_lemma_140330 (h0 : functor.add_const (ordered_comm_monoid (canonically_ordered_comm_semiring pos)) name) : @has_exists_mul_of_le.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (canonically_ordered_comm_semiring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_140331 (h0 : functor.add_const (ring (canonically_linear_ordered_monoid name)) ennreal) : @is_domain.{0} (canonically_linear_ordered_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (canonically_linear_ordered_monoid.{0} name)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_140332 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_140333 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_to_string empty)) := sorry --non-trivial
lemma new_lemma_140334 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_Inf pos)) (has_add (generalized_boolean_algebra name))) : @unique_factorization_monoid.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_Inf.{0} pos)) (has_add.{0} (generalized_boolean_algebra.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_140335 (h0 : not (topological_space (comm_ring fun_info) -> false)) : @path_connected_space.{0} (comm_ring.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (comm_ring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_140336 (h0 : topological_space (finset pos)) : preconnected_space (finset pos) := sorry --non-trivial
lemma new_lemma_140337 (h0 : topological_space (has_bot (comm_group unsigned))) : preconnected_space (has_bot (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_140338 (h0 : functor.add_const (group (canonically_ordered_comm_semiring ennreal)) (option (cancel_monoid (has_nndist name)))) : @is_cyclic.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_comm_semiring.{0} ennreal)) (option.{0} (cancel_monoid.{0} (has_nndist.{0} name))) h0)  := sorry --non-trivial
lemma new_lemma_140339 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_140340 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_140341 (h0 : functor.add_const (filter (add_cancel_monoid pos)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_140342 (h0 : topological_space (linear_ordered_semiring (has_top (has_top fun_info)))) : discrete_topology (linear_ordered_semiring (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_140343 (h0 : add_monoid (normed_comm_ring unsigned)) : add_monoid.fg (normed_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_140344 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (with_zero.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_zero.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_140345 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (semi_normed_comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_140346 (h0 : ordered_add_comm_monoid (boolean_algebra (finset Type))) : archimedean (boolean_algebra (finset Type)) := sorry --non-trivial
lemma new_lemma_140347 (h0 : topological_space (semigroup (finset pos))) : locally_compact_space (semigroup (finset pos)) := sorry --non-trivial
lemma new_lemma_140348 (h0 : topological_space (metric_space (has_top num))) : path_connected_space (metric_space (has_top num)) := sorry --non-trivial
lemma new_lemma_140349 (h0 : unsigned -> has_one (has_union empty) -> Prop) : relator.bi_total h0 := sorry --non-trivial
lemma new_lemma_140350 (h0 : topological_space (has_bot congr_arg_kind)) : preirreducible_space (has_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_140351 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_140352 (h0 : topological_space (bin_tree (semiring (semiring (semiring (semiring num)))))) : normal_space (bin_tree (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_140353 (h0 : functor.add_const (group (add_cancel_monoid Type)) unsigned) : @is_cyclic.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (add_cancel_monoid.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_140354 (h0 : complete_lattice (has_inner empty unsigned)) : complete_lattice.is_Sup_finite_compact (has_inner empty unsigned) := sorry --non-trivial
lemma new_lemma_140355 (h2 : topological_space (distrib_lattice fun_info)) : t0_space (distrib_lattice fun_info) := sorry --non-trivial
lemma new_lemma_140356 (h0 : topological_space (has_one (semiring (semiring (semiring empty))))) : normal_space (has_one (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_140357 (h0 : functor.add_const (topological_space (finset linarith.comp)) pos) : @sequential_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_140358 (h0 : functor.add_const (topological_space (pseudo_metric_space num)) num) : @locally_compact_space.{0} (pseudo_metric_space.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_140359 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (left_cancel_monoid.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type add_group.{0} h0 (left_cancel_monoid.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_140360 (h0 : function.extfun Type ring) : @rank_condition.{0} (denumerable.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} h0 (denumerable.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_140361 (h0 : functor.add_const (filter znum) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_140362 (h0 : not (topological_space (ordered_comm_ring linarith.comp_source) -> false)) : @t0_space.{0} (ordered_comm_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_140363 (h0 : functor.add_const (topological_space (ring unsigned)) linarith.comp) : @totally_separated_space.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_140364 (h0 : list (canonically_linear_ordered_monoid pos)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_140365 (h0 : uniform_space (linear_ordered_comm_ring (semiring (semiring congr_arg_kind)))) : separated_space (linear_ordered_comm_ring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_140366 (h0 : complete_lattice (has_one (has_norm (has_top (has_top empty))))) : is_compactly_generated (has_one (has_norm (has_top (has_top empty)))) := sorry --non-trivial
lemma new_lemma_140367 (h0 : int) (h1 : ordered_semiring int) (h2 : fintype int) : std_simplex int int (int.rem h0) := sorry --non-trivial
lemma new_lemma_140368 (h0 : functor.add_const (topological_space (semigroup Type)) Type) : @topological_space.separable_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (semigroup.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_140369 (h2 : ring (mul_one_class enat)) : strong_rank_condition (mul_one_class enat) := sorry --non-trivial
lemma new_lemma_140370 (h0 : group (dlist (random_gen (random_gen char)))) : is_cyclic (dlist (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_140371 (h2 : topological_space (linear_ordered_add_comm_group char)) : totally_disconnected_space (linear_ordered_add_comm_group char) := sorry --non-trivial
lemma new_lemma_140372 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (has_nndist num)) := sorry --non-trivial
lemma new_lemma_140373 (h1 : topological_space (distrib linarith.ineq)) : path_connected_space (distrib linarith.ineq) := sorry --non-trivial
lemma new_lemma_140374 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) Type) : @totally_disconnected_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (normed_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_140375 (h0 : functor.add_const (ring (comm_group linarith.comp)) Type) : @strong_rank_condition.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (comm_group.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_140376 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen linarith.comp_source))) : @rank_condition.{0} (random_gen.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_140377 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_140378 (h0 : functor.comp ring comm_ring fun_info) : @is_domain.{0} (comm_ring.{0} fun_info) (@functor.comp.run.{0 0 0} ring.{0} comm_ring.{0} fun_info h0)  := sorry --non-trivial
lemma new_lemma_140379 (h0 : functor.add_const (group (bin_tree unsigned)) unsigned) : @group.fg.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (bin_tree.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_140380 (h0 : uniform_space (ring (has_Inf (has_add Type)))) : separated_space (ring (has_Inf (has_add Type))) := sorry --non-trivial
lemma new_lemma_140381 (h1 : topological_space (has_top linarith.comp)) : totally_disconnected_space (has_top linarith.comp) := sorry --non-trivial
lemma new_lemma_140382 (h0 : topological_space (has_bot (has_bot Type))) : locally_compact_space (has_bot (has_bot Type)) := sorry --non-trivial
lemma new_lemma_140383 (h0 : filter (has_one (semiring (semiring num)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_140384 (h0 : functor.add_const (topological_space (finset pos)) Type) : @preconnected_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_140385 (h0 : topological_space (has_Inf (has_neg (has_Inf Type)))) : totally_disconnected_space (has_Inf (has_neg (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_140386 (h0 : functor.add_const (ordered_add_comm_monoid (ring name)) Type) : @archimedean.{0} (ring.{0} name) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_140387 (h1 : complete_lattice (has_norm (random_gen string_imp))) : is_atomistic (has_norm (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_140388 (h0 h1 : real) : real.is_conjugate_exponent h0 h1 := sorry --non-trivial
lemma new_lemma_140389 (h0 : fin has_zero.zero) : @regular_space.{0} (has_Inf.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_Inf.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_140390 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) name) : @normal_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_140391 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_140392 (h1 : topological_space (has_append to_additive.value_type)) : totally_disconnected_space (has_append to_additive.value_type) := sorry --non-trivial
lemma new_lemma_140393 (h0 : group (has_pos_part (finset linarith.comp))) : is_cyclic (has_pos_part (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_140394 (h0 : function.extfun Type group) : @group.fg.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (normed_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_140395 (h0 : fin has_zero.zero) : @path_connected_space.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_140396 (h0 : group (has_top (has_inv to_additive.value_type))) : normalizer_condition (has_top (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_140397 (h0 : group (add_group (semiring linarith.comp))) : group.fg (add_group (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_140398 (h0 : topological_space (has_top (has_norm congr_arg_kind))) : totally_disconnected_space (has_top (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_140399 (h0 : not (topological_space (has_append (metric_space to_additive.value_type)) -> false)) : @totally_disconnected_space.{0} (has_append.{0} (metric_space.{0} to_additive.value_type)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_append.{0} (metric_space.{0} to_additive.value_type))) h0)  := sorry --non-trivial
lemma new_lemma_140400 (h0 : functor.add_const (complete_lattice (as_linear_order empty)) num) : @is_atomistic.{0} (as_linear_order.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (as_linear_order.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_140401 (h0 : functor.add_const (filter (add_cancel_monoid Type)) environment.implicit_infer_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_140402 (h0 : topological_space (comm_group (semigroup pos))) : regular_space (comm_group (semigroup pos)) := sorry --non-trivial
lemma new_lemma_140403 (h0 : ring (cancel_monoid empty)) : is_principal_ideal_ring (cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_140404 (h1 : not (ring (measurable_space string_imp) -> false)) : @is_domain.{0} (measurable_space.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_140405 (h0 : functor.comp ordered_comm_monoid complete_distrib_lattice name) : @has_exists_mul_of_le.{0} (complete_distrib_lattice.{0} name) (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} complete_distrib_lattice.{0} name (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} complete_distrib_lattice.{0} name (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} complete_distrib_lattice.{0} name h0)))  := sorry --non-trivial
lemma new_lemma_140406 (h0 : fin has_zero.zero) : @archimedean.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (ordered_add_comm_monoid.{1} (ordered_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_140407 (h0 : semiring (has_dist (option unsigned))) : is_noetherian_ring (has_dist (option unsigned)) := sorry --non-trivial
lemma new_lemma_140408 (h0 : ring (has_neg name)) : strong_rank_condition (has_neg name) := sorry --non-trivial
lemma new_lemma_140409 (h0 : topological_space (measurable_space (with_bot string_imp))) : locally_compact_space (measurable_space (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_140410 (h0 : finset (pseudo_metric_space (option (option num)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_140411 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (with_bot.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_bot.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_140412 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_140413 (h0 : ring (is_R_or_C congr_arg_kind)) : strong_rank_condition (is_R_or_C congr_arg_kind) := sorry --non-trivial
lemma new_lemma_140414 (h0 : uniform_space (with_one (has_top (has_top num)))) : separated_space (with_one (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_140415 (h1 : has_lt (nondiscrete_normed_field char)) : no_max_order (nondiscrete_normed_field char) := sorry --non-trivial
lemma new_lemma_140416 (h0 : not (topological_space string -> false)) : @t0_space.{0} string (@classical.by_contradiction'.{1} (topological_space.{0} string) h0)  := sorry --non-trivial
lemma new_lemma_140417 (h0 : filter (ordered_comm_group congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_140418 (h0 : functor.add_const (group (has_to_string Type)) environment.implicit_infer_kind) : @normalizer_condition.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_to_string.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_140419 (h0 : uniform_space (random_gen (with_bot string_imp))) : complete_space (random_gen (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_140420 (h0 : topological_space (add_comm_monoid (option (option (monoid num))))) : t0_space (add_comm_monoid (option (option (monoid num)))) := sorry --non-trivial
lemma new_lemma_140421 (h0 : complete_lattice (monoid_with_zero pos)) : is_atomistic (monoid_with_zero pos) := sorry --non-trivial
lemma new_lemma_140422 (h0 : not (group (has_ssubset (random_gen fun_info)) -> false)) : @is_cyclic.{0} (has_ssubset.{0} (random_gen.{0} fun_info)) (@classical.by_contradiction'.{1} (group.{0} (has_ssubset.{0} (random_gen.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_140423 (h0 : topological_space (with_one (has_norm unsigned))) : normal_space (with_one (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_140424 (h0 : topological_space (metric_space (semiring num))) : topological_space.separable_space (metric_space (semiring num)) := sorry --non-trivial
lemma new_lemma_140425 (h0 : functor.add_const (group (has_to_string Type)) Type) : @group.fg.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (has_to_string.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_140426 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @locally_compact_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_140427 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_140428 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @normalizer_condition.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_140429 (h0 : topological_space (ordered_ring (semiring num))) : irreducible_space (ordered_ring (semiring num)) := sorry --non-trivial
lemma new_lemma_140430 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (left_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (left_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_140431 (h0 : topological_space (add_left_cancel_semigroup (option unsigned))) : totally_separated_space (add_left_cancel_semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_140432 (h0 : ring (linear_ordered_comm_group_with_zero enat)) : is_domain (linear_ordered_comm_group_with_zero enat) := sorry --non-trivial
lemma new_lemma_140433 (h0 : topological_space (comm_group (has_to_string (comm_group (cancel_monoid ennreal))))) : totally_separated_space (comm_group (has_to_string (comm_group (cancel_monoid ennreal)))) := sorry --non-trivial
lemma new_lemma_140434 (h1 : filter (topological_space string_imp)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_140435 (h0 : ring (has_append (metric_space reducibility_hints))) : rank_condition (has_append (metric_space reducibility_hints)) := sorry --non-trivial
lemma new_lemma_140436 (h0 : complete_lattice (ordered_ring empty)) : is_compactly_generated (ordered_ring empty) := sorry --non-trivial
lemma new_lemma_140437 (h0 : functor.add_const (add_monoid (ring pos)) pos) : @add_monoid.fg.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_140438 (h0 : group (add_group (has_norm num))) : group.fg (add_group (has_norm num)) := sorry --non-trivial
lemma new_lemma_140439 (h0 : functor.add_const (uniform_space (linear_ordered_cancel_comm_monoid empty)) empty) : @separated_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_140440 (h0 : functor.add_const (finset (measurable_space.dynkin_system unsigned)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_140441 (h0 : functor.comp filter has_nndist pos) : countable_Inter_filter (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_140442 (h0 : topological_space (normed_group (has_top fun_info))) : locally_compact_space (normed_group (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_140443 (h0 : functor.comp semiring has_add pos) : @is_noetherian_ring.{0} (has_add.{0} pos) (@functor.comp.run.{0 0 0} semiring.{0} has_add.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_140444 (h0 : monoid (finset (normed_comm_ring Type))) : monoid.fg (finset (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_140445 (h0 : function.extfun Type group) : @group.fg.{0} (left_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (left_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_140446 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_140447 (h0 : ordered_add_comm_monoid (has_to_string (option congr_arg_kind))) : archimedean (has_to_string (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_140448 (h0 : topological_space (linear_ordered_semiring to_additive.value_type)) : totally_separated_space (linear_ordered_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_140449 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (preorder.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (preorder.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_140450 (h0 : topological_space (ordered_ring (add_left_cancel_semigroup unsigned))) : normal_space (ordered_ring (add_left_cancel_semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_140451 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (finset name)) := sorry --non-trivial
lemma new_lemma_140452 (h0 : functor.add_const (group (has_add linarith.comp)) pos) : @is_cyclic.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_140453 (h0 : num -> linarith.comp_source -> num) : right_commutative h0 := sorry --non-trivial
lemma new_lemma_140454 (h0 : function.extfun Type (functor.comp list finset)) : palindrome (functor.comp.run (function.extfun_app h0 name)) := sorry --non-trivial
lemma new_lemma_140455 (h0 : list (has_Inf name)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_140456 (h0 : topological_space (measurable_space empty)) : discrete_topology (measurable_space empty) := sorry --non-trivial
lemma new_lemma_140457 (h1 : topological_space (normed_group to_additive.value_type)) : locally_compact_space (normed_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_140458 (h0 : pnat) (h1 : fin has_zero.zero) : pnat.coprime (id (id (id (id (id h0))))) (id (id (id (matrix.vec_empty (id (id (id h1))))))) := sorry --non-trivial
lemma new_lemma_140459 (h1 : complete_lattice (fintype string_imp)) : is_compactly_generated (fintype string_imp) := sorry --non-trivial
lemma new_lemma_140460 (h0 : topological_space (ordered_comm_ring (has_neg (has_Inf linarith.comp)))) : t0_space (ordered_comm_ring (has_neg (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_140461 (h0 : functor.add_const (filter pos) (option name)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_140462 (h0 : filter (has_inv (has_inv (random_gen linarith.ineq)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_140463 (h0 : topological_space (has_add (has_to_string environment.implicit_infer_kind))) : t0_space (has_add (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_140464 (h0 : not (complete_lattice (non_unital_non_assoc_semiring linarith.ineq) -> false)) : @is_compactly_generated.{0} (non_unital_non_assoc_semiring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (non_unital_non_assoc_semiring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_140465 (h1 : function.extfun Type topological_space) : @irreducible_space.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_140466 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) (finset (finset linarith.comp))) : @archimedean.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) (finset.{0} (finset.{0} linarith.comp)) h0) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_140467 (h0 : functor.add_const (complete_lattice (linear_order congr_arg_kind)) congr_arg_kind) : @is_atomistic.{0} (linear_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (linear_order.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_140468 (h0 : group (has_ssubset (with_one (has_ssubset linarith.ineq)))) : group.fg (has_ssubset (with_one (has_ssubset linarith.ineq))) := sorry --non-trivial
lemma new_lemma_140469 (h0 : not (topological_space (has_lt string_imp) -> false)) : @totally_disconnected_space.{0} (has_lt.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_lt.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_140470 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_140471 (h0 : ring (semigroup (option unsigned))) : is_principal_ideal_ring (semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_140472 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (ordered_comm_monoid.{1} (generalized_boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_140473 (h0 : group (complete_distrib_lattice pos)) : normalizer_condition (complete_distrib_lattice pos) := sorry --non-trivial
lemma new_lemma_140474 (h0 : finset (semigroup (has_add (option (has_add name))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_140475 (h0 : ulower (ulower pnat)) (h1 : ulower (fin has_zero.zero)) : pnat.coprime (ulower.up (ulower.up h0)) (id (matrix.vec_empty (ulower.up h1))) := sorry --non-trivial
lemma new_lemma_140476 (h0 : functor.add_const (cancel_comm_monoid_with_zero (linear_ordered_comm_group num)) num) : @unique_factorization_monoid.{0} (linear_ordered_comm_group.{0} num) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (linear_ordered_comm_group.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_140477 (h1 : uniform_space (semiring (has_norm (has_top congr_arg_kind)))) : separated_space (semiring (has_norm (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_140478 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (normed_linear_ordered_group empty)) := sorry --non-trivial
lemma new_lemma_140479 (h0 : topological_space (ordered_comm_group (option (option (option (option unsigned)))))) : totally_disconnected_space (ordered_comm_group (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_140480 (h1 : topological_space (topological_space (comm_ring char))) : t0_space (topological_space (comm_ring char)) := sorry --non-trivial
lemma new_lemma_140481 (h0 : complete_lattice (pseudo_metric_space (option empty))) : complete_lattice.is_Sup_finite_compact (pseudo_metric_space (option empty)) := sorry --non-trivial
lemma new_lemma_140482 (h2 : group (with_one string_imp)) : group.fg (with_one string_imp) := sorry --non-trivial
lemma new_lemma_140483 (h0 : ring (with_one (has_top fun_info))) : rank_condition (with_one (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_140484 (h0 : list (has_inner unsigned unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_140485 (h0 : prod (semiring empty) (semiring empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_140486 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_140487 (h0 : ordered_comm_monoid (canonically_ordered_comm_semiring (has_neg_part Type))) : has_exists_mul_of_le (canonically_ordered_comm_semiring (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_140488 (h2 : set char) : set.finite h2 := sorry --non-trivial
lemma new_lemma_140489 (h0 : function.extfun Type topological_space) : @t0_space.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_140490 (h0 : topological_space (has_pos_part (has_zero Type))) : preirreducible_space (has_pos_part (has_zero Type)) := sorry --non-trivial
lemma new_lemma_140491 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_140492 (h0 : Prop) (h1 : setoid h0) : quotient (id (id (id h1))) := sorry --non-trivial
lemma new_lemma_140493 (h1 : set (has_inf ereal -> linarith.ineq)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_140494 (h0 : group (option (semiring congr_arg_kind))) : normalizer_condition (option (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_140495 (h0 : topological_space (preorder (semiring num))) : preirreducible_space (preorder (semiring num)) := sorry --non-trivial
lemma new_lemma_140496 (h0 : functor.comp topological_space comm_group name) : @irreducible_space.{0} (comm_group.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} name h0)  := sorry --non-trivial
lemma new_lemma_140497 (h0 : functor.add_const (semiring (has_add Type)) name) : @is_noetherian_ring.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (has_add.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_140498 (h0 : uniform_space (has_neg (option (option ennreal)))) : separated_space (has_neg (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_140499 (h0 : ereal -> ereal -> Prop) (h1 : filter ereal) : filter.is_bounded h0 h1 := sorry --non-trivial
lemma new_lemma_140500 (h0 : functor.add_const (uniform_space (cancel_monoid pos)) name) : @complete_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (cancel_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_140501 (h0 : uniform_space (as_linear_order (option (option (option (option (option unsigned))))))) : separated_space (as_linear_order (option (option (option (option (option unsigned)))))) := sorry --non-trivial
lemma new_lemma_140502 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_140503 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) Type) : @normal_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_140504 (h0 : topological_space (has_emptyc (has_top linarith.comp_source))) : path_connected_space (has_emptyc (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_140505 (h1 : ring (has_append linarith.comp_source)) : strong_rank_condition (has_append linarith.comp_source) := sorry --non-trivial
lemma new_lemma_140506 (h0 : topological_space (ordered_comm_ring linarith.comp)) : topological_space.separable_space (ordered_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_140507 (h0 : topological_space (ordered_comm_monoid (finset Type))) : normal_space (ordered_comm_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_140508 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_140509 (h0 : add_group (has_emptyc (semiring empty))) : is_add_cyclic (has_emptyc (semiring empty)) := sorry --non-trivial
lemma new_lemma_140510 (h0 : functor.add_const (filter (has_neg Type)) (has_add pos)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_140511 (h0 : group (ordered_comm_monoid (has_Inf (has_neg name)))) : normalizer_condition (ordered_comm_monoid (has_Inf (has_neg name))) := sorry --non-trivial
lemma new_lemma_140512 (h0 : group (has_inv (has_nnnorm (has_nnnorm fun_info)))) : group.fg (has_inv (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_140513 (h1 : ring (measurable_space (with_bot to_additive.value_type))) : is_domain (measurable_space (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_140514 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_140515 (h0 : functor.add_const (complete_lattice (comm_group name)) Type) : @is_compactly_generated.{0} (comm_group.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (comm_group.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_140516 (h0 : topological_space (add_cancel_monoid (boolean_algebra.core (comm_group name)))) : locally_compact_space (add_cancel_monoid (boolean_algebra.core (comm_group name))) := sorry --non-trivial
lemma new_lemma_140517 (h0 : functor.add_const (semiring (canonically_ordered_comm_semiring pos)) unsigned) : @is_noetherian_ring.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (canonically_ordered_comm_semiring.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_140518 (h0 : functor.add_const Prop (group_with_zero (option ennreal))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_140519 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (generalized_boolean_algebra.{0} linarith.comp) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (generalized_boolean_algebra.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_140520 (h0 : functor.add_const (ordered_add_comm_monoid (generalized_boolean_algebra name)) linarith.comp) : @archimedean.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (generalized_boolean_algebra.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_140521 (h0 : group (has_bot (has_add linarith.comp))) : group.fg (has_bot (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_140522 (h0 : Prop -> std_gen) (h1 : coe_sort (set.range h0) -> ereal) (h2 : coe_sort (set.range h1)) : set.range_splitting h0 (set.range_splitting h1 h2) := sorry --non-trivial
lemma new_lemma_140523 (h0 : functor.add_const (function.extfun Type add_monoid) Type) : @add_monoid.fg.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_monoid.{0}) Type h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_140524 (h1 : not (topological_space (uniform_space to_additive.value_type) -> false)) : @t0_space.{0} (uniform_space.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_140525 (h0 : function.extfun (finset Type) (has_mem.mem (with_one fun_info))) : @rank_condition.{0} (with_one.{0} fun_info) (@finset.pi.empty.{1 0} Type ring.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_140526 (h0 : cancel_comm_monoid_with_zero (cancel_monoid (option unsigned))) : unique_factorization_monoid (cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_140527 (h0 : finset (canonically_ordered_monoid linarith.comp)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_140528 (h0 : function.extfun (Type 1) topological_space) : @totally_separated_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_140529 (h0 : uniform_space (ordered_cancel_add_comm_monoid pos)) : separated_space (ordered_cancel_add_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_140530 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} pos (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) pos)  := sorry --non-trivial
lemma new_lemma_140531 (h0 : topological_space (has_nndist Type)) : path_connected_space (has_nndist Type) := sorry --non-trivial
lemma new_lemma_140532 (h0 : monoid (canonically_linear_ordered_monoid (normed_lattice_add_comm_group real))) : monoid.fg (canonically_linear_ordered_monoid (normed_lattice_add_comm_group real)) := sorry --non-trivial
lemma new_lemma_140533 (h1 : set (normed_field to_additive.value_type)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_140534 (h0 : functor.add_const (topological_space (finset Type)) (boolean_algebra Type)) : @loc_path_connected_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (finset.{1} Type)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_140535 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) Type) : @topological_space.separable_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_140536 (h0 : ordered_add_comm_monoid (add_semigroup (option (semiring (option empty))))) : archimedean (add_semigroup (option (semiring (option empty)))) := sorry --non-trivial
lemma new_lemma_140537 (h0 : topological_space (has_bot (has_neg Type))) : loc_path_connected_space (has_bot (has_neg Type)) := sorry --non-trivial
lemma new_lemma_140538 (h0 : ring (ordered_ring (semiring empty))) : strong_rank_condition (ordered_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_140539 (h0 : topological_space bool) (h1 : preorder bool) : order_closed_topology bool := sorry --non-trivial
lemma new_lemma_140540 (h0 : complete_lattice (comm_semigroup (has_Inf pos))) : complete_lattice.is_Sup_finite_compact (comm_semigroup (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_140541 (h0 : set (mul_one_class fun_info -> fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_140542 (h1 : uniform_space (uniform_space reducibility_hints)) : complete_space (uniform_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_140543 (h0 : filter (canonically_ordered_comm_semiring fun_info)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_140544 (h0 : functor.add_const (topological_space (has_add name)) name) : @regular_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_140545 (h0 : function.extfun (Type 1) ordered_add_comm_monoid) : @archimedean.{1} (sub_neg_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} h0 (sub_neg_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_140546 (h0 : topological_space (ring (has_neg_part (has_add name)))) : path_connected_space (ring (has_neg_part (has_add name))) := sorry --non-trivial
lemma new_lemma_140547 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) Type) : @regular_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_140548 (h0 : finset (has_norm linarith.comp)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_140549 (h0 : fin has_zero.zero) : @is_noetherian_ring.{1} (finset.{1} Type) (@matrix.vec_empty.{1} (semiring.{1} (finset.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_140550 (h0 : functor.add_const (ring (add_cancel_monoid environment.implicit_infer_kind)) pos) : @strong_rank_condition.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_140551 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (add_comm_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_140552 (h0 : not (topological_space (add_right_cancel_monoid empty) -> false)) : @normal_space.{0} (add_right_cancel_monoid.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (add_right_cancel_monoid.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_140553 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_dist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_140554 (h0 : functor.add_const (topological_space (normed_comm_ring ennreal)) Type) : @sequential_space.{0} (normed_comm_ring.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_140555 (h0 : functor.add_const (function.extfun Type add_group) name) : @is_add_cyclic.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) name h0) (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_140556 (h2 : ring (denumerable (has_ssubset linarith.comp_source))) : strong_rank_condition (denumerable (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_140557 (h0 : ring (distrib_lattice (has_norm string_imp))) : is_domain (distrib_lattice (has_norm string_imp)) := sorry --non-trivial
lemma new_lemma_140558 (h0 : group (has_one (has_top (has_top (has_top linarith.comp))))) : normalizer_condition (has_one (has_top (has_top (has_top linarith.comp)))) := sorry --non-trivial
lemma new_lemma_140559 (h0 : functor.add_const (uniform_space (has_zero environment.implicit_infer_kind)) Type) : @separated_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_zero.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_140560 (h0 : fin has_zero.zero) : @is_atomistic.{0} (has_add.{0} pos) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_add.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_140561 (h0 : list (encodable (random_gen (random_gen (random_gen (random_gen (random_gen string_imp))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_140562 (h0 : functor.add_const (ordered_add_comm_monoid (has_zero name)) name) : @archimedean.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_zero.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_140563 (h1 : not (complete_lattice (partial_order char) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (partial_order.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (partial_order.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_140564 (h0 : functor.add_const (topological_space (mul_zero_class unsigned)) congr_arg_kind) : @topological_space.separable_space.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_140565 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_140566 (h0 : functor.comp topological_space comm_group pos) : @normal_space.{0} (comm_group.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_140567 (h0 : not (uniform_space (denumerable string_imp) -> false)) : @complete_space.{0} (denumerable.{0} string_imp) (@classical.by_contradiction'.{1} (uniform_space.{0} (denumerable.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_140568 (h0 : topological_space (has_zero (option (option (option name))))) : totally_disconnected_space (has_zero (option (option (option name)))) := sorry --non-trivial
lemma new_lemma_140569 (h0 : filter (complete_semilattice_Sup to_additive.value_type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_140570 (h0 : topological_space (finset (has_neg environment.implicit_infer_kind))) : discrete_topology (finset (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_140571 (h0 : functor.add_const (complete_lattice (has_star congr_arg_kind)) congr_arg_kind) : @is_compactly_generated.{0} (has_star.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_star.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_140572 (h0 : topological_space (left_cancel_semigroup (option (option (option (option num)))))) : normal_space (left_cancel_semigroup (option (option (option (option num))))) := sorry --non-trivial
lemma new_lemma_140573 (h2 : ring (has_ssubset linarith.ineq)) : rank_condition (has_ssubset linarith.ineq) := sorry --non-trivial
lemma new_lemma_140574 (h0 : functor.add_const (ring (cancel_monoid pos)) name) : @is_principal_ideal_ring.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (cancel_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_140575 (h0 : list (linear_ordered_field (option pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_140576 (h0 : functor.add_const (complete_lattice (has_to_string ennreal)) num) : @is_atomistic.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_140577 (h0 : topological_space (has_neg (finset linarith.comp))) : irreducible_space (has_neg (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_140578 (h0 : monoid (has_union num)) : monoid.fg (has_union num) := sorry --non-trivial
lemma new_lemma_140579 (h0 : group (normed_comm_ring (comm_group ennreal))) : is_cyclic (normed_comm_ring (comm_group ennreal)) := sorry --non-trivial
lemma new_lemma_140580 (h0 : fin has_zero.zero) : @rank_condition.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_140581 (h0 : function.extfun Type group) : @normalizer_condition.{0} (mul_zero_class.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (mul_zero_class.{0} num))  := sorry --non-trivial
lemma new_lemma_140582 (h0 : complete_lattice (has_nnnorm (random_gen (has_ssubset to_additive.value_type)))) : is_compactly_generated (has_nnnorm (random_gen (has_ssubset to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_140583 (h0 : functor.add_const (complete_lattice (add_comm_monoid pos)) Type) : @is_compactly_generated.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (add_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_140584 (h0 : topological_space (has_to_string linarith.comp)) : totally_disconnected_space (has_to_string linarith.comp) := sorry --non-trivial
lemma new_lemma_140585 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ring linarith.comp)) environment.implicit_infer_kind) : @unique_factorization_monoid.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ring.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_140586 (h0 : semiring (add_comm_semigroup (add_comm_semigroup fun_info))) (h1 : ideal (add_comm_semigroup (add_comm_semigroup fun_info))) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_140587 (h0 : ring (ordered_comm_ring (has_add real))) : rank_condition (ordered_comm_ring (has_add real)) := sorry --non-trivial
lemma new_lemma_140588 (h0 : not (uniform_space (uniform_space to_additive.value_type) -> false)) : @complete_space.{0} (uniform_space.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (uniform_space.{0} (uniform_space.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_140589 (h1 : topological_space (id to_additive.value_type)) : totally_disconnected_space (id to_additive.value_type) := sorry --non-trivial
lemma new_lemma_140590 (h0 : complete_lattice (has_to_string (has_to_string (has_to_string pos)))) : complete_lattice.is_Sup_finite_compact (has_to_string (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_140591 (h0 : group (has_append (random_gen (has_nnnorm (random_gen char))))) : is_cyclic (has_append (random_gen (has_nnnorm (random_gen char)))) := sorry --non-trivial
lemma new_lemma_140592 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_140593 (h0 : functor.add_const (semiring (left_cancel_monoid unsigned)) congr_arg_kind) : @is_noetherian_ring.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (left_cancel_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_140594 (h0 : functor.comp add_group finset Type) : @is_add_cyclic.{1} (finset.{1} Type) (@functor.comp.run.{1 1 1} add_group.{1} finset.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_140595 (h0 : topological_space (has_nndist (finset (has_add (has_to_string pos))))) : discrete_topology (has_nndist (finset (has_add (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_140596 (h0 : functor.add_const (topological_space (comm_group Type)) environment.implicit_infer_kind) : @topological_space.separable_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_140597 (h0 : not (ring (distrib_lattice fun_info) -> false)) : @is_domain.{0} (distrib_lattice.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (distrib_lattice.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_140598 (h0 : list (complete_distrib_lattice (has_to_string pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_140599 (h0 : ring (has_norm congr_arg_kind)) : rank_condition (has_norm congr_arg_kind) := sorry --non-trivial
lemma new_lemma_140600 (h0 : not (ring (random_gen string_imp) -> false)) : @rank_condition.{0} (random_gen.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_140601 (h0 : topological_space (semi_normed_ring (non_unital_non_assoc_semiring enat))) : t0_space (semi_normed_ring (non_unital_non_assoc_semiring enat)) := sorry --non-trivial
lemma new_lemma_140602 (h0 : functor.add_const (ring (has_neg linarith.comp)) (has_pos_part pos)) : @is_principal_ideal_ring.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} linarith.comp)) (has_pos_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_140603 (h0 : ring (linear_ordered_comm_group_with_zero environment.projection_info)) : strong_rank_condition (linear_ordered_comm_group_with_zero environment.projection_info) := sorry --non-trivial
lemma new_lemma_140604 (h0 : ring (ring ennreal)) : strong_rank_condition (ring ennreal) := sorry --non-trivial
lemma new_lemma_140605 (h0 : group (complete_distrib_lattice (right_cancel_semigroup pos))) : is_simple_group (complete_distrib_lattice (right_cancel_semigroup pos)) := sorry --non-trivial
lemma new_lemma_140606 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_140607 (h0 : set (has_nnnorm (mul_one_class ereal))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_140608 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (has_top.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (has_top.{0} empty))  := sorry --non-trivial
lemma new_lemma_140609 (h0 : group (comm_group (option (measurable_space.dynkin_system unsigned)))) : is_cyclic (comm_group (option (measurable_space.dynkin_system unsigned))) := sorry --non-trivial
lemma new_lemma_140610 (h0 : functor.add_const (ordered_comm_monoid (ring environment.implicit_infer_kind)) name) : @has_exists_mul_of_le.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_140611 (h0 : topological_space (ordered_ring empty)) : irreducible_space (ordered_ring empty) := sorry --non-trivial
lemma new_lemma_140612 (h0 : functor.add_const (ordered_comm_monoid (has_neg_part environment.implicit_infer_kind)) pos) : @has_exists_mul_of_le.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_neg_part.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_140613 (h0 : functor.add_const (add_group (measurable_space.dynkin_system num)) unsigned) : @is_add_cyclic.{0} (measurable_space.dynkin_system.{0} num) (@functor.add_const.run.{0 0} (add_group.{0} (measurable_space.dynkin_system.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_140614 (h0 : functor.add_const (topological_space (semigroup unsigned)) linarith.comp) : @sequential_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_140615 (h0 : not (group (random_gen linarith.comp) -> false)) : @group.fg.{0} (random_gen.{0} linarith.comp) (@classical.by_contradiction'.{1} (group.{0} (random_gen.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_140616 (h0 : functor.add_const (topological_space Type) name) : @topological_space.separable_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) name h0)  := sorry --non-trivial
lemma new_lemma_140617 (h0 : monoid (boolean_algebra (has_Inf (finset (has_Inf pos))))) : monoid.fg (boolean_algebra (has_Inf (finset (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_140618 (h0 : functor.add_const (semiring (left_cancel_monoid empty)) unsigned) : @is_noetherian_ring.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (left_cancel_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_140619 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_dist.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_140620 (h0 : functor.add_const (ordered_comm_monoid environment.implicit_infer_kind) (finset environment.implicit_infer_kind)) : @has_exists_mul_of_le.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} environment.implicit_infer_kind) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_140621 (h0 : filter (lex unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_140622 (h0 : function.extfun (finset Type) (has_mem.mem (id num))) : @group.fg.{0} (@id.{2} Type num) (@finset.pi.empty.{1 0} Type group.{0} (@id.{2} Type num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (@id.{2} Type num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_140623 (h0 : monoid (has_to_string Type)) : monoid.fg (has_to_string Type) := sorry --non-trivial
lemma new_lemma_140624 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (boolean_algebra.core congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_140625 (h0 : functor.add_const (topological_space (boolean_algebra Type)) (boolean_algebra Type)) : @t1_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (boolean_algebra.{1} Type)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_140626 (h1 : complete_lattice (linear_ordered_add_comm_group (random_gen (random_gen (random_gen char))))) : is_compactly_generated (linear_ordered_add_comm_group (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_140627 (h0 : topological_space (has_star (partial_order congr_arg_kind))) : t0_space (has_star (partial_order congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_140628 (h0 : ring (fintype (random_gen to_additive.value_type))) : rank_condition (fintype (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_140629 (h0 : has_mem.mem (measurable_space congr_arg_kind) has_emptyc.emptyc) : @strong_rank_condition.{0} (measurable_space.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_140630 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_140631 (h0 : fin has_zero.zero) : @topological_space.separable_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_140632 (h0 : finset (ordered_comm_monoid (finset linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_140633 (h0 : group (cancel_monoid Type)) : is_simple_group (cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_140634 (h0 : topological_space (option empty)) : irreducible_space (option empty) := sorry --non-trivial
lemma new_lemma_140635 (h0 : complete_lattice (add_cancel_comm_monoid (option (option unsigned)))) : is_compactly_generated (add_cancel_comm_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_140636 (h0 : complete_lattice (boolean_algebra.core (boolean_algebra.core ennreal))) : is_compactly_generated (boolean_algebra.core (boolean_algebra.core ennreal)) := sorry --non-trivial
lemma new_lemma_140637 (h0 : functor.add_const (ring (boolean_algebra Type)) Type) : @is_principal_ideal_ring.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_140638 (h0 : group (distrib_lattice (has_inv (has_inv (has_inv (has_inv (has_inv linarith.comp_source))))))) : is_cyclic (distrib_lattice (has_inv (has_inv (has_inv (has_inv (has_inv linarith.comp_source)))))) := sorry --non-trivial
lemma new_lemma_140639 (h0 : set (semi_normed_comm_ring environment.projection_info)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_140640 (h0 : to_additive.value_type -> fun_info -> Prop) : relator.right_unique h0 := sorry --non-trivial
lemma new_lemma_140641 (h0 : topological_space (add_comm_monoid (has_neg_part environment.implicit_infer_kind))) : sequential_space (add_comm_monoid (has_neg_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_140642 (h0 : topological_space (simple_graph unsigned)) : loc_path_connected_space (simple_graph unsigned) := sorry --non-trivial
lemma new_lemma_140643 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_140644 (h0 : topological_space (measurable_space (semiring (normed_group num)))) : discrete_topology (measurable_space (semiring (normed_group num))) := sorry --non-trivial
lemma new_lemma_140645 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @strong_rank_condition.{0} (generalized_boolean_algebra.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (generalized_boolean_algebra.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_140646 (h0 : fin has_zero.zero) : matrix.vec_empty (id (id (id (id (id (matrix.vec_empty h0)))))) := sorry --non-trivial
lemma new_lemma_140647 (h0 : topological_space (has_neg Type)) : topological_space.separable_space (has_neg Type) := sorry --non-trivial
lemma new_lemma_140648 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) pos) : @irreducible_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_140649 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_140650 (h0 : has_mem.mem fun_info has_emptyc.emptyc) : @is_add_cyclic.{0} fun_info (@finset.pi.empty.{1 0} Type add_group.{0} fun_info h0)  := sorry --non-trivial
lemma new_lemma_140651 (h0 : functor.add_const (topological_space (cancel_monoid environment.implicit_infer_kind)) name) : @regular_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_140652 (h1 : ring (has_lt environment.projection_info)) : is_domain (has_lt environment.projection_info) := sorry --non-trivial
lemma new_lemma_140653 (h0 : complete_lattice (has_norm (has_inv to_additive.value_type))) : is_compactly_generated (has_norm (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_140654 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_ssubset.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_ssubset.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_140655 (h1 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h1) (normed_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_140656 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_140657 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_140658 (h0 : semiring (has_neg_part (has_neg_part name))) : is_noetherian_ring (has_neg_part (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_140659 (h2 : not (topological_space (div_inv_monoid fun_info) -> false)) : @t0_space.{0} (div_inv_monoid.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (div_inv_monoid.{0} fun_info)) h2)  := sorry --non-trivial
lemma new_lemma_140660 (h0 : functor.add_const (add_group (has_pos_part linarith.comp)) name) : @is_add_cyclic.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (has_pos_part.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_140661 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_140662 (h0 : topological_space (normed_group (has_norm unsigned))) : normal_space (normed_group (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_140663 (h0 : fun_info -> fun_info -> Prop) : is_extensional fun_info h0 := sorry --non-trivial
lemma new_lemma_140664 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_140665 (h0 : topological_space (metric_space (random_gen (random_gen char)))) : t0_space (metric_space (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_140666 (h0 : not (function.extfun Type uniform_space -> false)) : separated_space empty := sorry --non-trivial
lemma new_lemma_140667 (h1 : topological_space (normed_group char)) : t0_space (normed_group char) := sorry --non-trivial
lemma new_lemma_140668 (h0 : list (monoid (option (option empty)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_140669 (h0 : topological_space (canonically_ordered_add_monoid (option (option (option empty))))) : locally_compact_space (canonically_ordered_add_monoid (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_140670 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) (has_add linarith.comp)) : @preirreducible_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_140671 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (dlist.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (dlist.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_140672 (h0 : complete_lattice (comm_ring (comm_ring (has_compl to_additive.value_type)))) : is_compactly_generated (comm_ring (comm_ring (has_compl to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_140673 (h0 : complete_lattice (sub_neg_monoid (has_neg name))) : is_compactly_generated (sub_neg_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_140674 (h0 : topological_space (comm_ring (mul_one_class (mul_one_class reducibility_hints)))) (h1 : topological_space (topological_space.opens (comm_ring (mul_one_class (mul_one_class reducibility_hints))))) : t0_space (topological_space.opens (comm_ring (mul_one_class (mul_one_class reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_140675 (h0 : topological_space (boolean_algebra (finset pos))) : preconnected_space (boolean_algebra (finset pos)) := sorry --non-trivial
lemma new_lemma_140676 (h0 : functor.add_const (complete_lattice (canonically_ordered_comm_semiring name)) name) : @is_atomistic.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_ordered_comm_semiring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_140677 (h0 : set (has_div (mul_one_class (has_compl fun_info)))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_140678 (h0 : filter (has_to_string (ring Type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_140679 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (measurable_space.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_140680 (h0 : topological_space (nondiscrete_normed_field (add_comm_semigroup enat))) (h1 : add_group (nondiscrete_normed_field (add_comm_semigroup enat))) : topological_add_group (nondiscrete_normed_field (add_comm_semigroup enat)) := sorry --non-trivial
lemma new_lemma_140681 (h1 : not (filter (dlist char) -> false)) : filter.ne_bot (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_140682 (h0 : functor.add_const (topological_space (has_bot real)) real) : @sequential_space.{0} (has_bot.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_140683 (h0 : topological_space (uniform_space reducibility_hints)) : totally_disconnected_space (uniform_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_140684 (h0 : ring (preorder (semiring congr_arg_kind))) : rank_condition (preorder (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_140685 (h0 : functor.add_const (group (add_cancel_monoid Type)) linarith.comp) : @normalizer_condition.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (add_cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_140686 (h0 : topological_space (measure_theory.measure_space num)) : preirreducible_space (measure_theory.measure_space num) := sorry --non-trivial
lemma new_lemma_140687 (h1 : group (distrib linarith.ineq)) : is_cyclic (distrib linarith.ineq) := sorry --non-trivial
lemma new_lemma_140688 (h0 : topological_space (semigroup (has_to_string name))) : topological_space.separable_space (semigroup (has_to_string name)) := sorry --non-trivial
lemma new_lemma_140689 (h0 : function.extfun nat fin) : @strong_rank_condition.{0} (has_add.{0} linarith.comp) (@matrix.vec_empty.{0} (ring.{0} (has_add.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_140690 (h0 : topological_space (normed_lattice_add_comm_group (has_Inf (has_add (has_Inf pos))))) : sequential_space (normed_lattice_add_comm_group (has_Inf (has_add (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_140691 (h0 : functor.add_const (function.extfun Type finset) (finset linarith.comp)) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_140692 (h0 : uniform_space (random_gen to_additive.value_type)) : separated_space (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_140693 (h0 : functor.add_const (group (linear_order num)) empty) : @is_cyclic.{0} (linear_order.{0} num) (@functor.add_const.run.{0 0} (group.{0} (linear_order.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_140694 (h0 : ring (cancel_monoid (comm_group name))) : is_domain (cancel_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_140695 (h0 : monoid (has_zero (has_to_string pos))) : monoid.fg (has_zero (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_140696 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_add linarith.comp)) pos) : @unique_factorization_monoid.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_add.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_140697 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_140698 (h0 : function.extfun Type group) : @normalizer_condition.{0} num (@function.extfun_app.{2 1} Type group.{0} h0 num)  := sorry --non-trivial
lemma new_lemma_140699 (h0 : ring (comm_monoid_with_zero (mul_one_class char))) : rank_condition (comm_monoid_with_zero (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_140700 (h0 : ring (add_cancel_comm_monoid (random_gen (has_nnnorm linarith.comp_source)))) : is_domain (add_cancel_comm_monoid (random_gen (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_140701 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (distrib_lattice.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (distrib_lattice.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_140702 (h0 : ring (ring (option num))) : rank_condition (ring (option num)) := sorry --non-trivial
lemma new_lemma_140703 (h0 : finset (monoid (option (option (option (option unsigned)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_140704 (h0 : functor.add_const (finset empty) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_140705 (h0 : topological_space (non_unital_non_assoc_semiring (mul_one_class fun_info))) : path_connected_space (non_unital_non_assoc_semiring (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_140706 (h0 : topological_space (normed_comm_ring unsigned)) : topological_space.separable_space (normed_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_140707 (h4 : ring (uniform_space linarith.comp_source)) : is_domain (uniform_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_140708 (h0 : complete_lattice (mul_one_class (random_gen string_imp))) : is_compactly_generated (mul_one_class (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_140709 (h0 : function.extfun nat fin) : @topological_space.separable_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))))  := sorry --non-trivial
lemma new_lemma_140710 (h0 : functor.add_const (uniform_space (has_neg_part Type)) pos) : @separated_space.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_neg_part.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_140711 (h0 : topological_space (mul_zero_class (has_nndist name))) : locally_compact_space (mul_zero_class (has_nndist name)) := sorry --non-trivial
lemma new_lemma_140712 (h2 : add_group (fintype fun_info)) : is_add_cyclic (fintype fun_info) := sorry --non-trivial
lemma new_lemma_140713 (h0 : cancel_comm_monoid_with_zero (monoid (option (option (option (option (option ennreal))))))) : unique_factorization_monoid (monoid (option (option (option (option (option ennreal)))))) := sorry --non-trivial
lemma new_lemma_140714 (h0 : function.extfun Type (functor.add_const (function.extfun Type topological_space))) : @topological_space.separable_space.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type topological_space.{0})) h0 environment.implicit_infer_kind)) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_140715 (h0 : monoid (linear_ordered_semiring (id (has_norm (has_norm (has_norm empty)))))) : monoid.fg (linear_ordered_semiring (id (has_norm (has_norm (has_norm empty))))) := sorry --non-trivial
lemma new_lemma_140716 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_140717 (h0 : functor.add_const (topological_space (normed_linear_ordered_group num)) (semiring num)) : @t0_space.{0} (normed_linear_ordered_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_140718 (h0 : ring (add_comm_semigroup (mul_one_class fun_info))) : strong_rank_condition (add_comm_semigroup (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_140719 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_140720 (h0 : has_lt (linear_ordered_comm_group_with_zero environment.projection_info)) : no_max_order (linear_ordered_comm_group_with_zero environment.projection_info) := sorry --non-trivial
lemma new_lemma_140721 (h0 : topological_space (complete_distrib_lattice (ring (ring linarith.comp)))) : preconnected_space (complete_distrib_lattice (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_140722 (h0 : functor.add_const (filter (has_zero linarith.comp)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_140723 (h0 : functor.add_const (add_group (complete_linear_order unsigned)) empty) : @is_add_cyclic.{0} (complete_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (complete_linear_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_140724 (h0 : topological_space (cancel_monoid (has_add (has_add (boolean_algebra.core pos))))) : path_connected_space (cancel_monoid (has_add (has_add (boolean_algebra.core pos)))) := sorry --non-trivial
lemma new_lemma_140725 (h0 : complete_lattice (with_bot num)) : complete_lattice.is_Sup_finite_compact (with_bot num) := sorry --non-trivial
lemma new_lemma_140726 (h0 : topological_space (boolean_algebra (has_Inf (has_Inf real)))) : locally_compact_space (boolean_algebra (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_140727 (h0 : functor.add_const (ring (has_nndist name)) linarith.comp) : @rank_condition.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_140728 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_140729 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_140730 (h0 : functor.add_const (topological_space (semigroup pos)) linarith.comp) : @loc_path_connected_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_140731 (h0 : topological_space (normed_group (has_norm linarith.comp_source))) : t0_space (normed_group (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_140732 (h0 : ordered_comm_monoid (finset (boolean_algebra name))) : has_exists_mul_of_le (finset (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_140733 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_140734 (h0 : topological_space (boolean_algebra (has_add (comm_group (comm_group unsigned))))) : totally_separated_space (boolean_algebra (has_add (comm_group (comm_group unsigned)))) := sorry --non-trivial
lemma new_lemma_140735 (h0 : topological_space (has_Sup (semiring empty))) : path_connected_space (has_Sup (semiring empty)) := sorry --non-trivial
lemma new_lemma_140736 (h1 : complete_lattice (metric_space char)) : is_compactly_generated (metric_space char) := sorry --non-trivial
lemma new_lemma_140737 (h0 : topological_space (normed_comm_ring (has_add Type))) : t1_space (normed_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_140738 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_140739 (h1 : topological_space (nondiscrete_normed_field linarith.ineq)) : t0_space (nondiscrete_normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_140740 (h0 : function.extfun Type (functor.add_const (topological_space (plift empty)))) : @totally_separated_space.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} empty)) empty (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (topological_space.{1} (plift.{1} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_140741 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_140742 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_140743 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_domain.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ring.{0}) (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_140744 (h0 : function.extfun Type (functor.add_const (topological_space (add_cancel_monoid linarith.comp)))) : @t1_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp))) h0 pos))  := sorry --non-trivial
lemma new_lemma_140745 (h0 : monoid (with_bot (has_inv linarith.comp_source))) : monoid.fg (with_bot (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_140746 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (has_add.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_140747 (h0 : function.extfun nat fin) : @is_add_cyclic.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (add_group.{1} (canonically_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_140748 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @totally_disconnected_space.{1} (plift.{1} congr_arg_kind) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (plift.{1} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_140749 (h0 : ring (has_neg (finset (finset (finset linarith.comp))))) : strong_rank_condition (has_neg (finset (finset (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_140750 (h1 : complete_lattice (normed_field ereal)) : complete_lattice.is_Sup_finite_compact (normed_field ereal) := sorry --non-trivial
lemma new_lemma_140751 (h0 : topological_space (partial_order (semiring num))) : preirreducible_space (partial_order (semiring num)) := sorry --non-trivial
lemma new_lemma_140752 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (boolean_algebra.core ennreal)) := sorry --non-trivial
lemma new_lemma_140753 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_140754 (h0 : not (topological_space (has_nnnorm to_additive.value_type) -> false)) : @path_connected_space.{0} (has_nnnorm.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_nnnorm.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_140755 (h0 : uniform_space (has_compl (linear_ordered_semiring (has_inv to_additive.value_type)))) : complete_space (has_compl (linear_ordered_semiring (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_140756 (h0 : topological_space (linear_ordered_field (comm_group unsigned))) : regular_space (linear_ordered_field (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_140757 (h0 : uniform_space (has_union (has_norm (has_top num)))) : separated_space (has_union (has_norm (has_top num))) := sorry --non-trivial
lemma new_lemma_140758 (h0 : add_group (random_gen (has_norm (semiring congr_arg_kind)))) : is_add_cyclic (random_gen (has_norm (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_140759 (h0 : functor.add_const (ring (has_neg Type)) (comm_group environment.implicit_infer_kind)) : @strong_rank_condition.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_neg.{1} Type)) (comm_group.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_140760 (h0 : group (complete_semilattice_Sup (has_top fun_info))) : normalizer_condition (complete_semilattice_Sup (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_140761 (h0 : semiring (has_add (finset (finset (has_neg (semigroup (finset pos))))))) : is_noetherian_ring (has_add (finset (finset (has_neg (semigroup (finset pos)))))) := sorry --non-trivial
lemma new_lemma_140762 (h0 : topological_space (has_add (random_gen to_additive.value_type))) : path_connected_space (has_add (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_140763 (h0 : functor.add_const (list (has_Inf Type)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_140764 (h0 : monoid (option (semiring (semiring (option (semiring empty)))))) : monoid.fg (option (semiring (semiring (option (semiring empty))))) := sorry --non-trivial
lemma new_lemma_140765 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_140766 (h0 : functor.add_const (add_monoid (finset Type)) Type) : @add_monoid.fg.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (add_monoid.{1} (finset.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_140767 (h0 : topological_space (with_zero (has_nnnorm to_additive.value_type))) : totally_disconnected_space (with_zero (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_140768 (h0 : functor.add_const (function.extfun Type semiring) environment.implicit_infer_kind) : @is_noetherian_ring.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) environment.implicit_infer_kind h0) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_140769 (h0 : not (complete_lattice (ordered_ring congr_arg_kind) -> false)) : @is_compactly_generated.{0} (ordered_ring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (ordered_ring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_140770 (h1 : has_mem.mem (complete_semilattice_Sup congr_arg_kind) has_emptyc.emptyc) : @monoid.fg.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type monoid.{0} (complete_semilattice_Sup.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_140771 (h1 : topological_space (complete_semilattice_Sup (random_gen (random_gen string_imp)))) : totally_disconnected_space (complete_semilattice_Sup (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_140772 (h0 : group (has_one (has_top (has_top num)))) : group.fg (has_one (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_140773 (h0 : function.extfun nat fin) : @preconnected_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_140774 (h0 : has_Inf (has_add (has_Inf Type)) -> has_Inf (has_add (has_Inf Type)) -> Prop) : is_antisymm (has_Inf (has_add (has_Inf Type))) h0 := sorry --non-trivial
lemma new_lemma_140775 (h0 : monoid (generalized_boolean_algebra (has_Inf linarith.comp))) : monoid.fg (generalized_boolean_algebra (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_140776 (h0 : function.extfun Type ring) : @is_domain.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_140777 (h0 : topological_space (normed_comm_ring (comm_group (boolean_algebra pos)))) : preirreducible_space (normed_comm_ring (comm_group (boolean_algebra pos))) := sorry --non-trivial
lemma new_lemma_140778 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_140779 (h1 : add_group (has_ssubset string_imp)) : is_add_cyclic (has_ssubset string_imp) := sorry --non-trivial
lemma new_lemma_140780 (h0 : group (has_norm fun_info)) : group.fg (has_norm fun_info) := sorry --non-trivial
lemma new_lemma_140781 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_140782 (h0 : ring (measurable_space (has_norm (has_norm empty)))) : is_domain (measurable_space (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_140783 (h0 : not (complete_lattice (has_lt to_additive.value_type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_lt.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_lt.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_140784 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_sdiff unsigned)) := sorry --non-trivial
lemma new_lemma_140785 (h0 : topological_space (has_norm (semiring (semiring (semiring unsigned))))) : totally_disconnected_space (has_norm (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_140786 (h0 : prod (finset (has_add (has_add name))) (finset (has_add (has_add name)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_140787 (h0 : complete_lattice (ring linarith.comp)) : is_compactly_generated (ring linarith.comp) := sorry --non-trivial
lemma new_lemma_140788 (h0 : functor.add_const (filter (has_neg environment.implicit_infer_kind)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_140789 (h0 : topological_space (has_edist (option empty))) : t0_space (has_edist (option empty)) := sorry --non-trivial
lemma new_lemma_140790 (h0 : topological_space (preorder congr_arg_kind)) : discrete_topology (preorder congr_arg_kind) := sorry --non-trivial
lemma new_lemma_140791 (h0 : semiring (complete_linear_order congr_arg_kind)) : is_noetherian_ring (complete_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_140792 (h0 : filter ennreal) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_140793 (h0 : complete_lattice (has_add (has_Inf (has_Inf Type)))) : complete_lattice.is_Sup_finite_compact (has_add (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_140794 (h0 : topological_space (ordered_comm_monoid (ring (has_neg (ring (ring (ring Type))))))) : totally_disconnected_space (ordered_comm_monoid (ring (has_neg (ring (ring (ring Type)))))) := sorry --non-trivial
lemma new_lemma_140795 (h0 : functor.add_const (complete_lattice (has_pos_part empty)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (has_pos_part.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_pos_part.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_140796 (h0 : function.extfun Type group) : @normalizer_condition.{0} (non_assoc_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (non_assoc_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_140797 (h0 : uniform_space (comm_semigroup (has_pos_part (has_pos_part (has_Inf pos))))) : separated_space (comm_semigroup (has_pos_part (has_pos_part (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_140798 (h5 : ring (has_nnnorm (has_nnnorm (comm_ring linarith.ineq)))) : rank_condition (has_nnnorm (has_nnnorm (comm_ring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_140799 (h0 : function.extfun (finset Type) (has_mem.mem (comm_semigroup unsigned))) : @discrete_topology.{0} (comm_semigroup.{0} unsigned) (@finset.pi.empty.{1 0} Type topological_space.{0} (comm_semigroup.{0} unsigned) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (comm_semigroup.{0} unsigned)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_140800 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_140801 (h0 : topological_space (cancel_monoid (has_add (comm_group (has_add name))))) : t0_space (cancel_monoid (has_add (comm_group (has_add name)))) := sorry --non-trivial
lemma new_lemma_140802 (h0 : list (ordered_cancel_add_comm_monoid ennreal)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_140803 (h0 : ring (option pos)) : is_principal_ideal_ring (option pos) := sorry --non-trivial
lemma new_lemma_140804 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_140805 (h0 : finset (has_pos_part (boolean_algebra.core (ring linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_140806 (h0 : group (boolean_algebra.core (has_neg_part (has_add (comm_group (has_add Type)))))) : is_simple_group (boolean_algebra.core (has_neg_part (has_add (comm_group (has_add Type))))) := sorry --non-trivial
lemma new_lemma_140807 (h0 : functor.add_const Prop (has_add (has_neg linarith.comp))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_140808 (h0 : group (has_nndist (comm_group Type))) : group.fg (has_nndist (comm_group Type)) := sorry --non-trivial
lemma new_lemma_140809 (h0 : functor.add_const (topological_space (has_to_string unsigned)) pos) : @totally_disconnected_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_140810 (h0 : functor.comp add_group add_cancel_monoid (option unsigned)) : @is_add_cyclic.{0} (add_cancel_monoid.{0} (option.{0} unsigned)) (@functor.comp.run.{0 0 0} add_group.{0} add_cancel_monoid.{0} (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_140811 (h0 : topological_space (has_append (has_ssubset linarith.comp_source))) : t0_space (has_append (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_140812 (h0 : functor.add_const (function.extfun (Type 1) topological_space) environment.implicit_infer_kind) : @preconnected_space.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) environment.implicit_infer_kind h0) (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_140813 (h0 : complete_lattice (ordered_comm_ring Type)) : is_compactly_generated (ordered_comm_ring Type) := sorry --non-trivial
lemma new_lemma_140814 (h0 : topological_space (normed_comm_ring (has_to_string (has_add (has_to_string pos))))) : regular_space (normed_comm_ring (has_to_string (has_add (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_140815 (h0 : functor.add_const (uniform_space (semigroup pos)) name) : @separated_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_140816 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) Type) : @t0_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_pos_part.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_140817 (h0 : ring (mul_zero_class (has_add Type))) : is_domain (mul_zero_class (has_add Type)) := sorry --non-trivial
lemma new_lemma_140818 (h0 : functor.add_const (ordered_add_comm_monoid (add_cancel_monoid Type)) Type) : @archimedean.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (ordered_add_comm_monoid.{1} (add_cancel_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_140819 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_140820 (h0 : functor.add_const (topological_space (has_Inf Type)) (has_neg Type)) : @totally_separated_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_Inf.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_140821 (h0 : functor.add_const (topological_space (comm_group ennreal)) ennreal) : @preirreducible_space.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_140822 (h0 : functor.add_const (ring (measure_theory.measure_space empty)) empty) : @rank_condition.{0} (measure_theory.measure_space.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (measure_theory.measure_space.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_140823 (h1 : complete_lattice ordering) : complete_lattice.is_Sup_finite_compact ordering := sorry --non-trivial
lemma new_lemma_140824 (h1 : ring (nondiscrete_normed_field (normed_field (normed_field linarith.ineq)))) : strong_rank_condition (nondiscrete_normed_field (normed_field (normed_field linarith.ineq))) := sorry --non-trivial
lemma new_lemma_140825 (h0 : add_monoid (has_to_string (finset (has_pos_part pos)))) : add_monoid.fg (has_to_string (finset (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_140826 (h0 : complete_lattice (with_one linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (with_one linarith.comp_source) := sorry --non-trivial
lemma new_lemma_140827 (h0 : list (measurable_space (random_gen (has_inv to_additive.value_type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_140828 (h0 : topological_space (cancel_monoid (option (option (option (option (option ennreal))))))) : totally_disconnected_space (cancel_monoid (option (option (option (option (option ennreal)))))) := sorry --non-trivial
lemma new_lemma_140829 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_140830 (h0 : not (complete_lattice (has_inv fun_info) -> false)) : @is_compactly_generated.{0} (has_inv.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_inv.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_140831 (h1 : set (semi_normed_ring linarith.comp_source)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_140832 (h0 : group (linear_ordered_semiring (random_gen (random_gen (random_gen linarith.ineq))))) : is_cyclic (linear_ordered_semiring (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_140833 (h0 : uniform_space (with_one (has_inv (random_gen (has_inv (random_gen linarith.ineq)))))) : complete_space (with_one (has_inv (random_gen (has_inv (random_gen linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_140834 (h0 : add_group (comm_semigroup (sub_neg_monoid (has_Inf real)))) : is_add_cyclic (comm_semigroup (sub_neg_monoid (has_Inf real))) := sorry --non-trivial
lemma new_lemma_140835 (h0 : function.extfun nat fin) : @t0_space.{0} (ordered_comm_ring.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_140836 (h0 : functor.add_const (topological_space (has_neg Type)) name) : @irreducible_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_140837 (h1 : complete_lattice (has_top to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (has_top to_additive.value_type) := sorry --non-trivial
lemma new_lemma_140838 (h0 : prod (has_neg environment.implicit_infer_kind) (has_neg environment.implicit_infer_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_140839 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) (has_neg (ring (has_add name)))) : @path_connected_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) (has_neg.{0} (ring.{0} (has_add.{0} name))) h0)  := sorry --non-trivial
lemma new_lemma_140840 (h0 : functor.comp filter cancel_monoid name) : filter.ne_bot (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_140841 (h0 : function.extfun (Type 1) (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_140842 (h0 : functor.add_const (ring (semigroup ennreal)) (option (option pos))) : @rank_condition.{0} (semigroup.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} ennreal)) (option.{0} (option.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_140843 (h0 : ordered_add_comm_monoid name) : has_exists_add_of_le name := sorry --non-trivial
lemma new_lemma_140844 (h0 : add_monoid (normed_group (semiring (semiring (has_norm (semiring empty)))))) : add_monoid.fg (normed_group (semiring (semiring (has_norm (semiring empty))))) := sorry --non-trivial
lemma new_lemma_140845 (h0 : functor.add_const (complete_lattice (boolean_algebra pos)) name) : @is_atomistic.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_140846 (h0 : complete_lattice (has_nndist congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (has_nndist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_140847 (h0 : ring (has_Inf (has_nndist (has_nndist (has_pos_part linarith.comp))))) : is_principal_ideal_ring (has_Inf (has_nndist (has_nndist (has_pos_part linarith.comp)))) := sorry --non-trivial
lemma new_lemma_140848 (h1 : has_neg (nondiscrete_normed_field enat)) (h2 : measurable_space (nondiscrete_normed_field enat)) : has_measurable_neg (nondiscrete_normed_field enat) := sorry --non-trivial
lemma new_lemma_140849 (h0 : topological_space (cancel_monoid unsigned)) : regular_space (cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_140850 (h0 : group (linear_ordered_field name)) : is_simple_group (linear_ordered_field name) := sorry --non-trivial
lemma new_lemma_140851 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_140852 (h0 : list (has_emptyc linarith.comp_source)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_140853 (h0 : uniform_space (add_cancel_monoid (option ennreal))) : complete_space (add_cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_140854 (h0 : functor.add_const (topological_space (comm_group name)) linarith.comp) : @locally_compact_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_140855 (h1 : function.extfun Type group) : @normalizer_condition.{0} (random_gen.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h1 (random_gen.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_140856 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (add_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (add_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_140857 (h0 : list (has_emptyc (with_bot to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_140858 (h0 : complete_lattice (left_cancel_semigroup (semiring congr_arg_kind))) : is_compactly_generated (left_cancel_semigroup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_140859 (h0 : topological_space (cancel_monoid (finset (complete_distrib_lattice pos)))) : preconnected_space (cancel_monoid (finset (complete_distrib_lattice pos))) := sorry --non-trivial
lemma new_lemma_140860 (h1 : complete_lattice (add_comm_semigroup ereal)) : complete_lattice.is_Sup_finite_compact (add_comm_semigroup ereal) := sorry --non-trivial
lemma new_lemma_140861 (h0 : topological_space (ordered_comm_monoid (boolean_algebra.core (ring (has_neg Type))))) : locally_compact_space (ordered_comm_monoid (boolean_algebra.core (ring (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_140862 (h3 : complete_lattice (comm_ring fun_info)) : complete_lattice.is_Sup_finite_compact (comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_140863 (h0 : ring (uniform_space (has_lt (uniform_space to_additive.value_type)))) : rank_condition (uniform_space (has_lt (uniform_space to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_140864 (h0 : group (with_bot (semiring (semiring (semiring empty))))) : normalizer_condition (with_bot (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_140865 (h0 : ring (has_append (has_le char))) : strong_rank_condition (has_append (has_le char)) := sorry --non-trivial
lemma new_lemma_140866 (h0 : list (ordered_cancel_add_comm_monoid pos)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_140867 (h0 : ordered_add_comm_monoid (mul_zero_class (boolean_algebra.core pos))) : archimedean (mul_zero_class (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_140868 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (complete_semilattice_Sup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_140869 (h0 : has_mem.mem (linear_ordered_semiring empty) has_emptyc.emptyc) : @is_cyclic.{0} (linear_ordered_semiring.{0} empty) (@finset.pi.empty.{1 0} Type group.{0} (linear_ordered_semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_140870 (h0 : add_monoid (normed_comm_ring (finset environment.implicit_infer_kind))) : add_monoid.fg (normed_comm_ring (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_140871 (h1 : topological_space reducibility_hints) (h2 : preorder reducibility_hints) : order_closed_topology reducibility_hints := sorry --non-trivial
lemma new_lemma_140872 (h0 : functor.add_const (ordered_add_comm_monoid (finset Type)) (has_neg environment.implicit_infer_kind)) : @archimedean.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (finset.{1} Type)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_140873 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (left_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (left_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_140874 (h0 : topological_space (has_neg (has_neg linarith.comp))) : locally_compact_space (has_neg (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_140875 (h0 : complete_lattice (semigroup (ring unsigned))) : is_atomistic (semigroup (ring unsigned)) := sorry --non-trivial
lemma new_lemma_140876 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_140877 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_140878 (h0 : not (has_mem.mem (has_top num) has_emptyc.emptyc -> false)) : @totally_disconnected_space.{0} (has_top.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_140879 (h0 : not (add_group (preorder num) -> false)) : @is_add_cyclic.{0} (preorder.{0} num) (@classical.by_contradiction'.{1} (add_group.{0} (preorder.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_140880 (h0 : functor.add_const (topological_space (generalized_boolean_algebra name)) pos) : @totally_separated_space.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_140881 (h0 : complete_lattice (id (has_inv fun_info))) : is_atomistic (id (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_140882 (h0 : topological_space (dlist linarith.comp_source)) (h1 : preorder (dlist linarith.comp_source)) : compact_Icc_space (dlist linarith.comp_source) := sorry --non-trivial
lemma new_lemma_140883 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_sub.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_sub.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_140884 (h0 : topological_space (option (semiring (semiring (semiring (semiring (semiring num))))))) : discrete_topology (option (semiring (semiring (semiring (semiring (semiring num)))))) := sorry --non-trivial
lemma new_lemma_140885 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type add_group.{0} h0 (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_140886 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (canonically_ordered_add_monoid.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_add_monoid.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_140887 (h0 : ring (generalized_boolean_algebra (has_add Type))) : rank_condition (generalized_boolean_algebra (has_add Type)) := sorry --non-trivial
lemma new_lemma_140888 (h0 : fin has_zero.zero) : @sequential_space.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_140889 (h0 : filter (boolean_algebra.core (option pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_140890 (h0 : topological_space (has_top (has_norm linarith.comp))) : t0_space (has_top (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_140891 (h0 : functor.add_const (ring znum) unsigned) : @strong_rank_condition.{0} znum (@functor.add_const.run.{0 0} (ring.{0} znum) unsigned h0)  := sorry --non-trivial
lemma new_lemma_140892 (h0 : function.extfun Type group) : @group.fg.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_140893 (h0 : function.extfun Type ring) : @is_domain.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_140894 (h0 : uniform_space (id empty)) : complete_space (id empty) := sorry --non-trivial
lemma new_lemma_140895 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (complete_distrib_lattice name)) := sorry --non-trivial
lemma new_lemma_140896 (h0 : topological_space (semi_normed_ring (has_nnnorm (comm_ring fun_info)))) : t0_space (semi_normed_ring (has_nnnorm (comm_ring fun_info))) := sorry --non-trivial
lemma new_lemma_140897 (h0 : group (linear_ordered_add_comm_group (random_gen string_imp))) : is_cyclic (linear_ordered_add_comm_group (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_140898 (h0 : function.extfun nat fin) : @t0_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_140899 (h0 : monoid (has_union (semiring empty))) : monoid.fg (has_union (semiring empty)) := sorry --non-trivial
lemma new_lemma_140900 (h0 : set (simple_graph linarith.comp_source)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_140901 (h0 : add_group (linear_ordered_semiring (has_norm linarith.comp_source))) : is_add_cyclic (linear_ordered_semiring (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_140902 (h0 : cancel_comm_monoid_with_zero (canonically_linear_ordered_monoid (has_bot linarith.comp))) : unique_factorization_monoid (canonically_linear_ordered_monoid (has_bot linarith.comp)) := sorry --non-trivial
lemma new_lemma_140903 (h0 : complete_lattice (boolean_algebra.core (boolean_algebra Type))) : is_atomistic (boolean_algebra.core (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_140904 (h0 : topological_space (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup fun_info)))) (h1 : preorder (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup fun_info)))) : order_closed_topology (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup fun_info))) := sorry --non-trivial
lemma new_lemma_140905 (h0 : ring (ring (has_neg linarith.comp))) : is_domain (ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_140906 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_140907 (h0 : functor.add_const (ring (sub_neg_monoid linarith.comp)) pos) : @strong_rank_condition.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (sub_neg_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_140908 (h1 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (linear_ordered_add_comm_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_140909 (h0 : functor.add_const (uniform_space (add_cancel_monoid pos)) (has_pos_part (has_Inf linarith.comp))) : @separated_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} pos)) (has_pos_part.{0} (has_Inf.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_140910 (h0 : functor.add_const (uniform_space (add_cancel_monoid pos)) (has_pos_part linarith.comp)) : @separated_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} pos)) (has_pos_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_140911 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} h0 (normed_lattice_add_comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_140912 (h0 : topological_space (has_zero (has_nndist ennreal))) : normal_space (has_zero (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_140913 (h0 : topological_space (id (semiring (semiring (semiring (semiring (has_norm unsigned))))))) : preirreducible_space (id (semiring (semiring (semiring (semiring (has_norm unsigned)))))) := sorry --non-trivial
lemma new_lemma_140914 (h0 : ring (preorder num)) : is_domain (preorder num) := sorry --non-trivial
lemma new_lemma_140915 (h0 : functor.add_const (group (has_neg name)) linarith.comp) : @normalizer_condition.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_140916 (h0 : ordered_comm_monoid (cancel_monoid (option (option (option (option pos)))))) : has_exists_mul_of_le (cancel_monoid (option (option (option (option pos))))) := sorry --non-trivial
lemma new_lemma_140917 (h0 : topological_space (has_nndist (finset ennreal))) : regular_space (has_nndist (finset ennreal)) := sorry --non-trivial
lemma new_lemma_140918 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (simple_graph.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (simple_graph.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_140919 (h2 : complete_lattice (with_one fun_info)) : complete_lattice.is_Sup_finite_compact (with_one fun_info) := sorry --non-trivial
lemma new_lemma_140920 (h0 : ring (has_compl char)) : rank_condition (has_compl char) := sorry --non-trivial
lemma new_lemma_140921 (h0 : functor.add_const (function.extfun (Type 1) ring) pos) : @is_domain.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) pos h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_140922 (h0 : functor.add_const (topological_space (semigroup name)) ennreal) : @irreducible_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_140923 (h1 : complete_lattice (random_gen linarith.comp)) : is_compactly_generated (random_gen linarith.comp) := sorry --non-trivial
lemma new_lemma_140924 (h0 : ring (option (semiring (semiring empty)))) : strong_rank_condition (option (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_140925 (h1 : has_lt (has_ssubset (comm_group reducibility_hints))) : no_max_order (has_ssubset (comm_group reducibility_hints)) := sorry --non-trivial
lemma new_lemma_140926 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} linarith.comp (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) linarith.comp)  := sorry --non-trivial
lemma new_lemma_140927 (h0 : complete_lattice (with_one linarith.comp_source)) : is_atomistic (with_one linarith.comp_source) := sorry --non-trivial
lemma new_lemma_140928 (h0 : ring (add_semigroup to_additive.value_type)) : rank_condition (add_semigroup to_additive.value_type) := sorry --non-trivial
lemma new_lemma_140929 (h0 : topological_space (denumerable (has_bot string_imp))) : path_connected_space (denumerable (has_bot string_imp)) := sorry --non-trivial
lemma new_lemma_140930 (h0 : topological_space (ordered_comm_group empty)) : totally_disconnected_space (ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_140931 (h0 : group (ring (option (option (option empty))))) : is_cyclic (ring (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_140932 (h0 : ring (has_one (semiring (semiring (semiring unsigned))))) : rank_condition (has_one (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_140933 (h0 : topological_space (has_neg_part (has_add environment.implicit_infer_kind))) : normal_space (has_neg_part (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_140934 (h0 : fin has_zero.zero) : @is_noetherian_ring.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (semiring.{1} (canonically_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_140935 (h0 : functor.add_const (uniform_space (ring ennreal)) linarith.comp) : @separated_space.{0} (ring.{0} ennreal) (@functor.add_const.run.{0 0} (uniform_space.{0} (ring.{0} ennreal)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_140936 (h0 : functor.add_const (function.extfun Type finset) pos) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_140937 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @complete_lattice.is_Sup_finite_compact.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_140938 (h0 : fin has_zero.zero) : @regular_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_140939 (h0 : add_monoid (has_top (semiring (semiring (has_norm fun_info))))) : add_monoid.fg (has_top (semiring (semiring (has_norm fun_info)))) := sorry --non-trivial
lemma new_lemma_140940 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (@id.{2} Type linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (@id.{2} Type linarith.ineq))  := sorry --non-trivial
lemma new_lemma_140941 (h2 : topological_space (random_gen linarith.comp_source)) : totally_disconnected_space (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_140942 (h0 : set (has_compl (mul_one_class enat))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_140943 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) Type) : @totally_separated_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_140944 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_140945 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (filter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (filter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_140946 (h0 : list (finset (has_neg (ring name)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_140947 (h0 : functor.add_const (topological_space (has_neg Type)) unsigned) : @regular_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_140948 (h0 : functor.add_const (ring (generalized_boolean_algebra Type)) Type) : @rank_condition.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (generalized_boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_140949 (h0 : has_mem.mem (semiring linarith.comp_source) has_emptyc.emptyc) : @locally_compact_space.{0} (semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_140950 (h0 : group (add_left_cancel_semigroup (semiring (semiring empty)))) : is_cyclic (add_left_cancel_semigroup (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_140951 (h0 : functor.add_const (filter (normed_comm_ring name)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_140952 (h0 : semiring (semiring (has_union unsigned))) : is_noetherian_ring (semiring (has_union unsigned)) := sorry --non-trivial
lemma new_lemma_140953 (h0 : ring (with_bot (semiring (semiring (semiring (semiring congr_arg_kind)))))) : strong_rank_condition (with_bot (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_140954 (h0 : add_group (cancel_monoid (has_add name))) : is_add_cyclic (cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_140955 (h0 : functor.add_const (function.extfun Type uniform_space) linarith.comp) : @complete_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) linarith.comp h0) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_140956 (h0 : filter (boolean_algebra.core (option empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_140957 (h0 : add_group (linear_ordered_add_comm_group (has_inv linarith.comp_source))) : is_add_cyclic (linear_ordered_add_comm_group (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_140958 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} h0 (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_140959 (h1 : complete_lattice (topological_space fun_info)) : complete_lattice.is_Sup_finite_compact (topological_space fun_info) := sorry --non-trivial
lemma new_lemma_140960 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_140961 (h0 : ring (has_union (has_norm (semiring (has_norm (has_norm num)))))) : is_domain (has_union (has_norm (semiring (has_norm (has_norm num))))) := sorry --non-trivial
lemma new_lemma_140962 (h0 : functor.add_const (monoid (has_nndist pos)) environment.implicit_infer_kind) : @monoid.fg.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (has_nndist.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_140963 (h0 : functor.add_const (uniform_space (ordered_ring num)) congr_arg_kind) : @separated_space.{0} (ordered_ring.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_ring.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_140964 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (normed_linear_ordered_group.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_linear_ordered_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_140965 (h2 : list (normed_group (has_norm linarith.ineq))) : list.nodup h2 := sorry --non-trivial
lemma new_lemma_140966 (h0 : topological_space (boolean_algebra.core (option num))) : irreducible_space (boolean_algebra.core (option num)) := sorry --non-trivial
lemma new_lemma_140967 (h0 : topological_space (linear_ordered_semiring (has_top to_additive.value_type))) : totally_disconnected_space (linear_ordered_semiring (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_140968 (h0 : functor.add_const (topological_space (ordered_comm_monoid pos)) linarith.comp) : @preconnected_space.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_140969 (h0 : topological_space (add_cancel_monoid (finset (has_neg (finset (finset environment.implicit_infer_kind)))))) : t0_space (add_cancel_monoid (finset (has_neg (finset (finset environment.implicit_infer_kind))))) := sorry --non-trivial
lemma new_lemma_140970 (h0 : functor.add_const (function.extfun Type semiring) name) : @is_noetherian_ring.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) name h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_140971 (h0 : group (with_one (with_bot string_imp))) : is_cyclic (with_one (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_140972 (h0 : ring (has_to_string (has_to_string (has_to_string Type)))) : is_principal_ideal_ring (has_to_string (has_to_string (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_140973 (h0 : filter (semigroup (has_add ennreal))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_140974 (h0 : functor.add_const (group (ring Type)) pos) : @is_simple_group.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_140975 (h0 : bin_tree (bin_tree empty) -> bin_tree (bin_tree empty) -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_140976 (h0 : function.extfun (Type 1) topological_space) : @totally_separated_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_140977 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_140978 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) name) : @irreducible_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_140979 (h0 : functor.add_const (monoid (complete_distrib_lattice name)) Type) : @monoid.fg.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 1} (monoid.{0} (complete_distrib_lattice.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_140980 (h0 : functor.add_const (filter (has_neg linarith.comp)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_140981 (h0 : monoid (finset (option (option empty)))) : monoid.fg (finset (option (option empty))) := sorry --non-trivial
lemma new_lemma_140982 (h0 : fin has_zero.zero) : @add_monoid.fg.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type add_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type add_monoid.{0}) h0) (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_140983 (h0 : functor.add_const (list (has_add linarith.comp)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_140984 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) Type) : @preirreducible_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_140985 (h0 : function.extfun (finset Type) (has_mem.mem (semiring fun_info))) : @is_atomistic.{0} (semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_140986 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_140987 (h0 : topological_space (canonically_ordered_monoid (has_add (has_add (has_add pos))))) : irreducible_space (canonically_ordered_monoid (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_140988 (h0 : complete_lattice (uniform_space linarith.comp_source)) : is_compactly_generated (uniform_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_140989 (h0 : not (topological_space (semi_normed_ring (mul_one_class (mul_one_class linarith.ineq))) -> false)) : @t0_space.{0} (semi_normed_ring.{0} (mul_one_class.{0} (mul_one_class.{0} linarith.ineq))) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_ring.{0} (mul_one_class.{0} (mul_one_class.{0} linarith.ineq)))) h0)  := sorry --non-trivial
lemma new_lemma_140990 (h0 : topological_space (linear_ordered_field (option unsigned))) : loc_path_connected_space (linear_ordered_field (option unsigned)) := sorry --non-trivial
lemma new_lemma_140991 (h4 : Prop) : set.separates_points (id (fun (h0 : char -> add_comm_semigroup (add_comm_semigroup enat)), h4)) := sorry --non-trivial
lemma new_lemma_140992 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_140993 (h0 : semiring (semigroup (has_Inf (mul_one_class (has_pos_part linarith.comp))))) : is_noetherian_ring (semigroup (has_Inf (mul_one_class (has_pos_part linarith.comp)))) := sorry --non-trivial
lemma new_lemma_140994 (h0 : topological_space (generalized_boolean_algebra (has_Inf real))) : totally_separated_space (generalized_boolean_algebra (has_Inf real)) := sorry --non-trivial
lemma new_lemma_140995 (h0 : functor.add_const (topological_space (semigroup congr_arg_kind)) empty) : @t1_space.{0} (semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_140996 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (has_neg (has_neg pos))) : @discrete_topology.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) (has_neg.{0} (has_neg.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_140997 (h1 : function.extfun Type ring) : @is_domain.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h1 (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_140998 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (ring Type)) : @totally_separated_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) (ring.{1} Type) h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_140999 (h0 : group (encodable (random_gen (random_gen (random_gen (random_gen char)))))) : is_cyclic (encodable (random_gen (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_141000 (h0 : add_group (linear_ordered_add_comm_group (has_top (has_top (has_top linarith.ineq))))) : is_add_cyclic (linear_ordered_add_comm_group (has_top (has_top (has_top linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_141001 (h0 : set (enat -> enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_141002 (h0 : complete_lattice (has_lt fun_info)) : is_compactly_generated (has_lt fun_info) := sorry --non-trivial
lemma new_lemma_141003 (h0 : topological_space (ordered_comm_ring (has_bot (sub_neg_monoid (has_bot (has_bot name)))))) : path_connected_space (ordered_comm_ring (has_bot (sub_neg_monoid (has_bot (has_bot name))))) := sorry --non-trivial
lemma new_lemma_141004 (h0 : not (topological_space (has_union num) -> false)) : @discrete_topology.{0} (has_union.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_141005 (h0 : topological_space (with_one (has_norm linarith.ineq))) : irreducible_space (with_one (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_141006 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normal_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_141007 (h0 : topological_space (has_to_string (semigroup pos))) : normal_space (has_to_string (semigroup pos)) := sorry --non-trivial
lemma new_lemma_141008 (h0 : ring empty) : is_principal_ideal_ring empty := sorry --non-trivial
lemma new_lemma_141009 (h0 : ring (complete_semilattice_Sup linarith.comp)) : rank_condition (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_141010 (h0 : fin has_zero.zero) : @is_atomistic.{0} (complete_distrib_lattice.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (complete_distrib_lattice.{0} real))  := sorry --non-trivial
lemma new_lemma_141011 (h0 : add_monoid (with_one empty)) : add_monoid.fg (with_one empty) := sorry --non-trivial
lemma new_lemma_141012 (h0 : group (add_monoid string_imp)) : is_cyclic (add_monoid string_imp) := sorry --non-trivial
lemma new_lemma_141013 (h0 : functor.add_const (ring (has_zero environment.implicit_infer_kind)) linarith.comp) : @is_principal_ideal_ring.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_141014 (h0 : functor.add_const (topological_space (has_neg Type)) Type) : @preconnected_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_neg.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_141015 (h0 : Prop) : id (id (id h0)) := sorry --non-trivial
lemma new_lemma_141016 (h0 : not (filter (semi_normed_comm_ring fun_info) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_141017 (h0 : not (ring (has_div reducibility_hints) -> false)) : @strong_rank_condition.{0} (has_div.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (has_div.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_141018 (h0 : topological_space (random_gen unsigned)) : preirreducible_space (random_gen unsigned) := sorry --non-trivial
lemma new_lemma_141019 (h0 : semiring (ordered_comm_ring (has_nndist (ring pos)))) : is_noetherian_ring (ordered_comm_ring (has_nndist (ring pos))) := sorry --non-trivial
lemma new_lemma_141020 (h0 : group (denumerable (has_inv linarith.comp_source))) : group.fg (denumerable (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_141021 (h0 : ring (simple_graph (mul_one_class (add_comm_semigroup string.iterator_imp)))) : rank_condition (simple_graph (mul_one_class (add_comm_semigroup string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_141022 (h0 : ring (normed_lattice_add_comm_group (has_pos_part name))) : is_principal_ideal_ring (normed_lattice_add_comm_group (has_pos_part name)) := sorry --non-trivial
lemma new_lemma_141023 (h0 : complete_lattice (add_comm_monoid empty)) : is_atomistic (add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_141024 (h0 : topological_space (has_Inf (has_add linarith.comp))) : normal_space (has_Inf (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_141025 (h0 : topological_space (finset (finset (finset name)))) : normal_space (finset (finset (finset name))) := sorry --non-trivial
lemma new_lemma_141026 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (measurable_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_141027 (h0 : ring (dlist (random_gen linarith.ineq))) : is_domain (dlist (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_141028 (h0 : uniform_space (has_norm (comm_ring linarith.ineq))) : complete_space (has_norm (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_141029 (h0 : functor.add_const (topological_space (comm_group name)) name) : @loc_path_connected_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_141030 (h1 : set (normed_field linarith.ineq)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_141031 (h0 : function.extfun Type group) : @is_cyclic.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_141032 (h0 : functor.add_const (uniform_space (preorder congr_arg_kind)) congr_arg_kind) : @complete_space.{0} (preorder.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (preorder.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_141033 (h0 : functor.add_const (topological_space (ordered_comm_group empty)) congr_arg_kind) : @totally_separated_space.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_group.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_141034 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_141035 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_141036 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_141037 (h0 : group (sub_neg_monoid (has_add (has_bot (has_add (has_add real)))))) : is_cyclic (sub_neg_monoid (has_add (has_bot (has_add (has_add real))))) := sorry --non-trivial
lemma new_lemma_141038 (h0 : not (uniform_space (with_one unsigned) -> false)) : @separated_space.{0} (with_one.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (with_one.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_141039 (h0 : ring (has_neg (option pos))) : rank_condition (has_neg (option pos)) := sorry --non-trivial
lemma new_lemma_141040 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_neg.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_neg.{0} num))  := sorry --non-trivial
lemma new_lemma_141041 (h0 : uniform_space (boolean_algebra.core (mul_zero_class (mul_zero_class name)))) : separated_space (boolean_algebra.core (mul_zero_class (mul_zero_class name))) := sorry --non-trivial
lemma new_lemma_141042 (h0 : not (uniform_space (complete_semilattice_Sup empty) -> false)) : @separated_space.{0} (complete_semilattice_Sup.{0} empty) (@classical.by_contradiction'.{1} (uniform_space.{0} (complete_semilattice_Sup.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_141043 (h0 : topological_space (ring (ring (has_neg (has_neg (ring (has_neg linarith.comp))))))) : discrete_topology (ring (ring (has_neg (has_neg (ring (has_neg linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_141044 (h0 : group (random_gen (semi_normed_ring to_additive.value_type))) : is_cyclic (random_gen (semi_normed_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_141045 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_141046 (h0 : add_monoid (with_one linarith.comp)) : add_monoid.fg (with_one linarith.comp) := sorry --non-trivial
lemma new_lemma_141047 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_Sup.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_Sup.{0} pos))  := sorry --non-trivial
lemma new_lemma_141048 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (normed_comm_ring.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_141049 (h0 : topological_space (random_gen (has_norm (has_norm (has_norm fun_info))))) : totally_separated_space (random_gen (has_norm (has_norm (has_norm fun_info)))) := sorry --non-trivial
lemma new_lemma_141050 (h0 : topological_space (normed_linear_ordered_group num)) : preirreducible_space (normed_linear_ordered_group num) := sorry --non-trivial
lemma new_lemma_141051 (h0 : functor.add_const (function.extfun Type uniform_space) pos) : @separated_space.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) pos h0) (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_141052 (h0 : ring (has_add (option unsigned))) : strong_rank_condition (has_add (option unsigned)) := sorry --non-trivial
lemma new_lemma_141053 (h0 : has_mem.mem (with_bot (has_norm (semiring fun_info))) has_emptyc.emptyc) : @totally_separated_space.{0} (with_bot.{0} (has_norm.{0} (semiring.{0} fun_info))) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} (has_norm.{0} (semiring.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_141054 (h0 : group (has_add pos)) : normalizer_condition (has_add pos) := sorry --non-trivial
lemma new_lemma_141055 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) name) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_141056 (h1 : function.extfun Type group) : @normalizer_condition.{0} to_additive.value_type (@function.extfun_app.{2 1} Type group.{0} h1 to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_141057 (h0 : functor.comp topological_space has_ssubset linarith.comp_source) : @t0_space.{0} (has_ssubset.{0} linarith.comp_source) (@functor.comp.run.{0 0 0} topological_space.{0} has_ssubset.{0} linarith.comp_source h0)  := sorry --non-trivial
lemma new_lemma_141058 (h0 : true -> true -> bool) : is_dec_refl h0 := sorry --non-trivial
lemma new_lemma_141059 (h0 : complete_lattice (has_nndist (option empty))) : is_atomistic (has_nndist (option empty)) := sorry --non-trivial
lemma new_lemma_141060 (h0 : functor.comp group finset pos) : @normalizer_condition.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} pos)) unsigned (@functor.comp.run.{0 0 0} group.{0} finset.{0} pos h0))  := sorry --non-trivial
lemma new_lemma_141061 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (random_gen.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (random_gen.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_141062 (h0 : not (topological_space (distrib_lattice to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (distrib_lattice.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib_lattice.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_141063 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_141064 (h0 : topological_space linarith.comp) : loc_path_connected_space linarith.comp := sorry --non-trivial
lemma new_lemma_141065 (h0 : topological_space (has_bot (option (option (option empty))))) : path_connected_space (has_bot (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_141066 (h0 : functor.add_const (group (canonically_ordered_monoid name)) real) : @is_simple_group.{0} (canonically_ordered_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_monoid.{0} name)) real h0)  := sorry --non-trivial
lemma new_lemma_141067 (h0 : functor.add_const (complete_lattice znum) (option (option (option unsigned)))) : @is_atomistic.{0} znum (@functor.add_const.run.{0 0} (complete_lattice.{0} znum) (option.{0} (option.{0} (option.{0} unsigned))) h0)  := sorry --non-trivial
lemma new_lemma_141068 (h0 : has_to_string num) : palindrome (list.ret h0) := sorry --non-trivial
lemma new_lemma_141069 (h0 : topological_space (with_bot (has_inv (has_inv (has_inv linarith.ineq))))) : totally_disconnected_space (with_bot (has_inv (has_inv (has_inv linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_141070 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_inter.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_inter.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_141071 (h0 : not (topological_space (bin_tree congr_arg_kind) -> false)) : @discrete_topology.{0} (bin_tree.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (bin_tree.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_141072 (h0 : filter (has_neg (finset (finset (finset (has_nndist (finset pos))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_141073 (h0 : topological_space (left_cancel_semigroup empty)) : totally_separated_space (left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_141074 (h0 : ring (comm_ring to_additive.value_type)) (h1 : complete_lattice (subring (comm_ring to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (subring (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_141075 (h0 : functor.add_const (filter (has_add pos)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_141076 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (as_linear_order.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (as_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_141077 (h0 : functor.add_const (finset (normed_comm_ring pos)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_141078 (h0 : group (normed_group (has_top (has_norm (has_norm fun_info))))) : is_cyclic (normed_group (has_top (has_norm (has_norm fun_info)))) := sorry --non-trivial
lemma new_lemma_141079 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_141080 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_141081 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (denumerable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (denumerable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_141082 (h0 : topological_space (has_sub unsigned)) : t0_space (has_sub unsigned) := sorry --non-trivial
lemma new_lemma_141083 (h0 : empty) : matrix.vec_empty (empty.elim h0) := sorry --non-trivial
lemma new_lemma_141084 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_141085 (h0 : topological_space (add_cancel_monoid (has_add name))) : preconnected_space (add_cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_141086 (h0 : topological_space Type) (h1 : preorder ereal) (h2 : Type -> ereal) : is_local_min h2 linarith.comp := sorry --non-trivial
lemma new_lemma_141087 (h0 : topological_space (measurable_space (has_norm fun_info))) : locally_compact_space (measurable_space (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_141088 (h1 : add_group (has_emptyc char)) : is_add_cyclic (has_emptyc char) := sorry --non-trivial
lemma new_lemma_141089 (h0 : topological_space (order_dual unsigned)) : path_connected_space (order_dual unsigned) := sorry --non-trivial
lemma new_lemma_141090 (h0 : functor.add_const (function.extfun Type ring) name) : @strong_rank_condition.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_141091 (h0 : functor.add_const (topological_space (pseudo_metric_space num)) num) : @loc_path_connected_space.{0} (pseudo_metric_space.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_141092 (h0 : add_monoid (has_norm fun_info)) : add_monoid.fg (has_norm fun_info) := sorry --non-trivial
lemma new_lemma_141093 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_141094 (h0 : has_mem.mem (has_top empty) has_emptyc.emptyc) : @add_monoid.fg.{0} (has_top.{0} empty) (@finset.pi.empty.{1 0} Type add_monoid.{0} (has_top.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_141095 (h1 : topological_space (has_top string_imp)) : t0_space (has_top string_imp) := sorry --non-trivial
lemma new_lemma_141096 (h0 : functor.add_const (uniform_space (ring environment.implicit_infer_kind)) pos) : @separated_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (ring.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_141097 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} string_imp (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) string_imp)  := sorry --non-trivial
lemma new_lemma_141098 (h0 : ring (with_zero (has_inv fun_info))) : rank_condition (with_zero (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_141099 (h0 : function.extfun nat fin) : @preirreducible_space.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_linear_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_141100 (h0 : filter (finset linarith.comp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_141101 (h0 : topological_space (has_nndist (option ennreal))) : t1_space (has_nndist (option ennreal)) := sorry --non-trivial
lemma new_lemma_141102 (h0 : group (has_ssubset string_imp)) : is_cyclic (has_ssubset string_imp) := sorry --non-trivial
lemma new_lemma_141103 (h0 : topological_space (has_zero (normed_comm_ring name))) : preirreducible_space (has_zero (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_141104 (h0 : topological_space (cancel_monoid (has_add environment.implicit_infer_kind))) : path_connected_space (cancel_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_141105 (h0 : functor.add_const (topological_space (ordered_ring num)) (semiring num)) : @locally_compact_space.{0} (ordered_ring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_141106 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) Type) : @complete_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) uniform_space.{1}) Type h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_141107 (h0 : group (monoid num)) : normalizer_condition (monoid num) := sorry --non-trivial
lemma new_lemma_141108 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_add_cyclic.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (add_group.{1} (ordered_comm_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_141109 (h0 : topological_space (has_Inf (has_add pos))) : preconnected_space (has_Inf (has_add pos)) := sorry --non-trivial
lemma new_lemma_141110 (h0 : functor.add_const (filter (has_pos_part linarith.comp)) (has_Inf pos)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_141111 (h0 : ring (add_group (semiring (semiring unsigned)))) : is_principal_ideal_ring (add_group (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_141112 (h0 : group (complete_distrib_lattice (ordered_comm_monoid (has_pos_part pos)))) : is_simple_group (complete_distrib_lattice (ordered_comm_monoid (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_141113 (h0 : function.extfun Type (functor.add_const (topological_space (distrib_lattice num)))) : @loc_path_connected_space.{0} (distrib_lattice.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (distrib_lattice.{0} num)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (distrib_lattice.{0} num))) h0 num))  := sorry --non-trivial
lemma new_lemma_141114 (h0 : not (topological_space (semiring to_additive.value_type) -> false)) : @path_connected_space.{0} (semiring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_141115 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_to_string pos)) : @totally_separated_space.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_to_string.{0} pos) h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_141116 (h0 : functor.add_const (complete_lattice (add_comm_monoid name)) environment.implicit_infer_kind) : @is_compactly_generated.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_comm_monoid.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_141117 (h0 : functor.add_const (ring (boolean_algebra.core environment.implicit_infer_kind)) Type) : @is_principal_ideal_ring.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ring.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_141118 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_141119 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (canonically_ordered_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_141120 (h0 : monoid (measurable_space (has_norm (has_norm num)))) : monoid.fg (measurable_space (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_141121 (h0 : ring (add_cancel_monoid (has_Inf Type))) : strong_rank_condition (add_cancel_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_141122 (h0 : uniform_space (metric_space unsigned)) : complete_space (metric_space unsigned) := sorry --non-trivial
lemma new_lemma_141123 (h0 : functor.add_const (group (measurable_space.dynkin_system num)) unsigned) : @normalizer_condition.{0} (measurable_space.dynkin_system.{0} num) (@functor.add_const.run.{0 0} (group.{0} (measurable_space.dynkin_system.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_141124 (h0 : cancel_comm_monoid_with_zero (left_cancel_monoid (canonically_ordered_add_monoid (option unsigned)))) : unique_factorization_monoid (left_cancel_monoid (canonically_ordered_add_monoid (option unsigned))) := sorry --non-trivial
lemma new_lemma_141125 (h0 : finset (has_pos_part (has_pos_part (ring Type)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_141126 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (normed_group.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_141127 (h0 : not (monoid (order_dual empty) -> false)) : @monoid.fg.{0} (order_dual.{0} empty) (@classical.by_contradiction'.{1} (monoid.{0} (order_dual.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_141128 (h0 : ring (with_one num)) : is_domain (with_one num) := sorry --non-trivial
lemma new_lemma_141129 (h0 : functor.add_const (complete_lattice (option congr_arg_kind)) congr_arg_kind) : @is_compactly_generated.{0} (option.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (option.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_141130 (h1 : complete_lattice (has_add fun_info)) : is_compactly_generated (has_add fun_info) := sorry --non-trivial
lemma new_lemma_141131 (h2 : ring num) : rank_condition num := sorry --non-trivial
lemma new_lemma_141132 (h0 : topological_space (add_left_cancel_semigroup empty)) : discrete_topology (add_left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_141133 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) (has_neg linarith.comp)) : @preconnected_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_141134 (h0 : complete_lattice (comm_ring (random_gen char))) : is_compactly_generated (comm_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_141135 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_141136 (h0 : ring (normed_lattice_add_comm_group (has_neg (has_neg (has_neg pos))))) : rank_condition (normed_lattice_add_comm_group (has_neg (has_neg (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_141137 (h0 : functor.add_const (complete_lattice (boolean_algebra pos)) (has_to_string pos)) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} pos)) (has_to_string.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_141138 (h0 : ring (complete_semilattice_Sup (with_bot fun_info))) : strong_rank_condition (complete_semilattice_Sup (with_bot fun_info)) := sorry --non-trivial
lemma new_lemma_141139 (h0 : not (has_mem.mem (has_emptyc fun_info) has_emptyc.emptyc -> false)) : @normalizer_condition.{0} (has_emptyc.{0} fun_info) (@finset.pi.empty.{1 0} Type group.{0} (has_emptyc.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_141140 (h0 : monoid (normed_lattice_add_comm_group real)) : monoid.fg (normed_lattice_add_comm_group real) := sorry --non-trivial
lemma new_lemma_141141 (h0 : ring (nondiscrete_normed_field (mul_one_class fun_info))) : strong_rank_condition (nondiscrete_normed_field (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_141142 (h0 : functor.add_const (group (has_bot empty)) empty) : @normalizer_condition.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (has_bot.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_141143 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{0} (has_bot.{0} name) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (has_bot.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_141144 (h0 : add_monoid (with_bot (semiring (semiring unsigned)))) : add_monoid.fg (with_bot (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_141145 (h0 : functor.add_const (uniform_space (as_linear_order empty)) unsigned) : @complete_space.{0} (as_linear_order.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (as_linear_order.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_141146 (h0 : topological_space (free_add_monoid unsigned)) : irreducible_space (free_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_141147 (h0 : topological_space (mul_one_class (add_comm_semigroup (add_comm_semigroup string.iterator_imp)))) : path_connected_space (mul_one_class (add_comm_semigroup (add_comm_semigroup string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_141148 (h0 : functor.add_const (topological_space (has_nndist unsigned)) environment.implicit_infer_kind) : @totally_disconnected_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_141149 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_141150 (h0 : set (add_comm_semigroup enat)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_141151 (h0 : ring (normed_group (random_gen char))) : is_domain (normed_group (random_gen char)) := sorry --non-trivial
lemma new_lemma_141152 (h0 : monoid (has_top (random_gen (has_top (random_gen to_additive.value_type))))) : monoid.fg (has_top (random_gen (has_top (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_141153 (h0 : ring (canonically_linear_ordered_monoid pos)) : is_principal_ideal_ring (canonically_linear_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_141154 (h0 : has_zero (semigroup congr_arg_kind) -> has_zero (semigroup congr_arg_kind) -> Prop) : is_symm (has_zero (semigroup congr_arg_kind)) h0 := sorry --non-trivial
lemma new_lemma_141155 (h0 : finset (add_comm_monoid (has_add (has_Inf real)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_141156 (h0 : finset (ordered_comm_ring (has_pos_part (has_add (has_add pos))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_141157 (h0 : semiring (ordered_cancel_add_comm_monoid num)) : is_noetherian_ring (ordered_cancel_add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_141158 (h0 : functor.add_const (topological_space (has_zero Type)) name) : @irreducible_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_141159 (h0 : add_group (ring (has_Inf (normed_comm_ring (normed_comm_ring linarith.comp))))) : is_add_cyclic (ring (has_Inf (normed_comm_ring (normed_comm_ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_141160 (h0 : add_group (topological_space (comm_ring (comm_ring (denumerable to_additive.value_type))))) : is_add_cyclic (topological_space (comm_ring (comm_ring (denumerable to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_141161 (h0 : ordered_add_comm_monoid num) : archimedean num := sorry --non-trivial
lemma new_lemma_141162 (h0 : prod (has_zero (option name)) (has_zero (option name))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_141163 (h0 : topological_space (generalized_boolean_algebra Type)) : t1_space (generalized_boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_141164 (h0 : cancel_comm_monoid_with_zero (comm_group (comm_group (comm_group (comm_group name))))) : unique_factorization_monoid (comm_group (comm_group (comm_group (comm_group name)))) := sorry --non-trivial
lemma new_lemma_141165 (h0 : add_comm_monoid (semigroup ennreal) -> add_comm_monoid (semigroup ennreal) -> Prop) : is_symm (add_comm_monoid (semigroup ennreal)) h0 := sorry --non-trivial
lemma new_lemma_141166 (h0 : ring (normed_comm_ring (comm_group name))) : strong_rank_condition (normed_comm_ring (comm_group name)) := sorry --non-trivial
lemma new_lemma_141167 (h0 : functor.add_const (ring (has_to_string Type)) ennreal) : @is_principal_ideal_ring.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_to_string.{1} Type)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_141168 (h0 : ring (denumerable (random_gen linarith.comp_source))) : rank_condition (denumerable (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_141169 (h0 : functor.add_const (semiring (add_comm_monoid pos)) (finset pos)) : @is_noetherian_ring.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (add_comm_monoid.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_141170 (h0 : complete_lattice (has_nnnorm (has_ssubset string_imp))) : complete_lattice.is_Sup_finite_compact (has_nnnorm (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_141171 (h3 : topological_space (uniform_space string_imp)) : t0_space (uniform_space string_imp) := sorry --non-trivial
lemma new_lemma_141172 (h3 : function.extfun Type topological_space) : @t0_space.{0} (measurable_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h3 (measurable_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_141173 (h0 : complete_lattice (add_group (semiring congr_arg_kind))) : is_compactly_generated (add_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_141174 (h0 : function.extfun Type topological_space) : @t0_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_141175 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_141176 (h0 : list (add_cancel_monoid (has_add pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_141177 (h0 : ring (linear_ordered_field congr_arg_kind)) : strong_rank_condition (linear_ordered_field congr_arg_kind) := sorry --non-trivial
lemma new_lemma_141178 (h0 : set (add_comm_semigroup ereal -> environment.implicit_infer_kind)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_141179 (h0 : functor.add_const (uniform_space (ring pos)) pos) : @complete_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_141180 (h1 : ring (simple_graph environment.projection_info)) : strong_rank_condition (simple_graph environment.projection_info) := sorry --non-trivial
lemma new_lemma_141181 (h0 : ring (measure_theory.measure_space num)) (h1 : topological_space (partial_order (subring (measure_theory.measure_space num)))) : totally_separated_space (partial_order (subring (measure_theory.measure_space num))) := sorry --non-trivial
lemma new_lemma_141182 (h0 : functor.add_const (topological_space (has_add Type)) linarith.comp) : @loc_path_connected_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_141183 (h0 h1 : multiset (uniform_space (mul_one_class to_additive.value_type))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_141184 (h0 : prod (has_neg (has_sdiff pos)) (has_neg (has_sdiff pos))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_141185 (h0 : topological_space (has_pos_part (has_add linarith.comp))) : preconnected_space (has_pos_part (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_141186 (h0 : not (topological_space (partial_order unsigned) -> false)) : @path_connected_space.{0} (partial_order.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (partial_order.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_141187 (h0 : topological_space (simple_graph (ordered_comm_monoid (has_add Type)))) : locally_compact_space (simple_graph (ordered_comm_monoid (has_add Type))) := sorry --non-trivial
lemma new_lemma_141188 (h0 : functor.add_const (functor.add_const (uniform_space linarith.comp) Type) Type) : @separated_space.{0} linarith.comp (@functor.add_const.run.{0 1} (uniform_space.{0} linarith.comp) Type (@functor.add_const.run.{0 1} (functor.add_const.{0 1} (uniform_space.{0} linarith.comp) Type) Type h0))  := sorry --non-trivial
lemma new_lemma_141189 (h0 : ring (has_top num)) : is_principal_ideal_ring (has_top num) := sorry --non-trivial
lemma new_lemma_141190 (h0 : functor.add_const (topological_space (has_to_string pos)) environment.implicit_infer_kind) : @discrete_topology.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_141191 (h0 : functor.add_const (ring (add_cancel_monoid linarith.comp)) linarith.comp) : @strong_rank_condition.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_141192 (h1 : function.extfun Type topological_space) : @discrete_topology.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_141193 (h0 : topological_space (has_Inf name)) : totally_disconnected_space (has_Inf name) := sorry --non-trivial
lemma new_lemma_141194 (h0 : has_mem.mem (left_cancel_semigroup unsigned) has_emptyc.emptyc) : @t1_space.{0} (left_cancel_semigroup.{0} unsigned) (@finset.pi.empty.{1 0} Type topological_space.{0} (left_cancel_semigroup.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_141195 (h0 : uniform_space (has_add (finset (has_to_string linarith.comp)))) : separated_space (has_add (finset (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_141196 (h0 : monoid (has_norm (has_norm empty))) : monoid.fg (has_norm (has_norm empty)) := sorry --non-trivial
lemma new_lemma_141197 (h0 : functor.add_const (ring (add_cancel_monoid name)) linarith.comp) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_141198 (h0 : group (canonically_linear_ordered_monoid unsigned)) : normalizer_condition (canonically_linear_ordered_monoid unsigned) := sorry --non-trivial
lemma new_lemma_141199 (h0 : add_monoid (has_bot (option unsigned))) : add_monoid.fg (has_bot (option unsigned)) := sorry --non-trivial
lemma new_lemma_141200 (h0 : function.extfun Type topological_space) : @t0_space.{0} (preorder.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_141201 (h0 : uniform_space (add_cancel_comm_monoid to_additive.value_type)) : complete_space (add_cancel_comm_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_141202 (h0 : uniform_space (plift (has_top num))) : separated_space (plift (has_top num)) := sorry --non-trivial
lemma new_lemma_141203 (h0 : functor.add_const (monoid (add_cancel_monoid name)) unsigned) : @monoid.fg.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (add_cancel_monoid.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_141204 (h0 : group (add_left_cancel_monoid string_imp)) : is_cyclic (add_left_cancel_monoid string_imp) := sorry --non-trivial
lemma new_lemma_141205 (h0 : topological_space (pseudo_metric_space (ring unsigned))) : normal_space (pseudo_metric_space (ring unsigned)) := sorry --non-trivial
lemma new_lemma_141206 (h0 : functor.add_const (function.extfun Type finset) environment.implicit_infer_kind) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_141207 (h0 : group (measurable_space.dynkin_system (has_top unsigned))) : group.fg (measurable_space.dynkin_system (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_141208 (h0 : ring (topological_space (has_nnnorm linarith.ineq))) : rank_condition (topological_space (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_141209 (h0 : group (fintype to_additive.value_type)) : is_cyclic (fintype to_additive.value_type) := sorry --non-trivial
lemma new_lemma_141210 (h0 : monoid (add_cancel_monoid (has_neg_part Type))) : monoid.fg (add_cancel_monoid (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_141211 (h0 : functor.add_const (cancel_comm_monoid_with_zero (linear_ordered_cancel_comm_monoid empty)) empty) : @unique_factorization_monoid.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_141212 (h0 : topological_space (add_comm_semigroup (add_comm_semigroup ereal))) : totally_disconnected_space (add_comm_semigroup (add_comm_semigroup ereal)) := sorry --non-trivial
lemma new_lemma_141213 (h0 : finset (add_cancel_monoid (add_comm_monoid (has_add name)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_141214 (h0 : group (denumerable (has_nnnorm to_additive.value_type))) : group.fg (denumerable (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_141215 (h0 : function.extfun Type topological_space) : @normal_space.{0} (ordered_cancel_add_comm_monoid.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_141216 (h0 : functor.add_const (ordered_add_comm_monoid (has_neg pos)) environment.implicit_infer_kind) : @archimedean.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_neg.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_141217 (h0 : functor.add_const (complete_lattice (mul_zero_class pos)) pos) : @is_atomistic.{0} (mul_zero_class.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (mul_zero_class.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_141218 (h0 : topological_space (has_nndist (ring (has_neg linarith.comp)))) : t0_space (has_nndist (ring (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_141219 (h0 : uniform_space (mul_zero_class (semiring empty))) : complete_space (mul_zero_class (semiring empty)) := sorry --non-trivial
lemma new_lemma_141220 (h1 : topological_space (with_one (random_gen string_imp))) : path_connected_space (with_one (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_141221 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_141222 (h0 : group (comm_semigroup pos)) : group.fg (comm_semigroup pos) := sorry --non-trivial
lemma new_lemma_141223 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring unsigned)) pos) : @path_connected_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_141224 (h0 : functor.add_const (complete_lattice (finset empty)) unsigned) : @is_atomistic.{0} (finset.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_141225 (h0 : not (complete_lattice (encodable to_additive.value_type) -> false)) : @is_compactly_generated.{0} (encodable.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (encodable.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_141226 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @unique_factorization_monoid.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 cancel_comm_monoid_with_zero.{1}) (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_141227 (h0 : topological_space (semi_normed_comm_ring linarith.comp_source)) : locally_compact_space (semi_normed_comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_141228 (h0 : functor.add_const (topological_space (has_nndist unsigned)) pos) : @totally_disconnected_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_141229 (h0 : functor.add_const (topological_space (option name)) unsigned) : @t0_space.{0} (option.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_141230 (h0 : topological_space (sub_neg_monoid (has_Inf (has_Inf (has_Inf pos))))) : sequential_space (sub_neg_monoid (has_Inf (has_Inf (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_141231 (h0 : topological_space auto.case_option) : path_connected_space auto.case_option := sorry --non-trivial
lemma new_lemma_141232 (h0 : ring (ordered_ring empty)) : is_principal_ideal_ring (ordered_ring empty) := sorry --non-trivial
lemma new_lemma_141233 (h0 : not (topological_space (add_group linarith.comp) -> false)) : @irreducible_space.{0} (add_group.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_141234 (h0 : topological_space (boolean_algebra (finset unsigned))) : discrete_topology (boolean_algebra (finset unsigned)) := sorry --non-trivial
lemma new_lemma_141235 (h0 : functor.add_const (ring (add_cancel_monoid linarith.comp)) environment.implicit_infer_kind) : @rank_condition.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_141236 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_141237 (h0 : group (has_Inf (has_add linarith.comp))) : group.fg (has_Inf (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_141238 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_141239 (h0 : topological_space (simple_graph (has_neg Type))) : preirreducible_space (simple_graph (has_neg Type)) := sorry --non-trivial
lemma new_lemma_141240 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_141241 (h0 : functor.add_const (topological_space (complete_distrib_lattice unsigned)) unsigned) : @t0_space.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_141242 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (complete_semilattice_Sup.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_semilattice_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_141243 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_141244 (h0 : finset (filter (option empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_141245 (h0 : uniform_space (partial_order (semiring (semiring num)))) : separated_space (partial_order (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_141246 (h0 : topological_space (semigroup (has_Inf (has_neg (has_nndist Type))))) : sequential_space (semigroup (has_Inf (has_neg (has_nndist Type)))) := sorry --non-trivial
lemma new_lemma_141247 (h0 : function.extfun (Type 1) topological_space) : @regular_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_141248 (h0 : group (has_union (has_top (semiring empty)))) : normalizer_condition (has_union (has_top (semiring empty))) := sorry --non-trivial
lemma new_lemma_141249 (h0 : functor.add_const (topological_space (linear_ordered_field empty)) (option num)) : @normal_space.{0} (linear_ordered_field.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} empty)) (option.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_141250 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) pos) : @discrete_topology.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_141251 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) environment.implicit_infer_kind) : @regular_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_141252 (h0 : ring (normed_group (has_norm linarith.ineq))) : is_domain (normed_group (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_141253 (h0 : ring (add_left_cancel_semigroup (has_inner (option empty) unsigned))) : is_domain (add_left_cancel_semigroup (has_inner (option empty) unsigned)) := sorry --non-trivial
lemma new_lemma_141254 (h0 : topological_space (encodable char)) : locally_compact_space (encodable char) := sorry --non-trivial
lemma new_lemma_141255 (h0 : functor.add_const (group (complete_linear_order congr_arg_kind)) (option unsigned)) : @normalizer_condition.{0} (complete_linear_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (complete_linear_order.{0} congr_arg_kind)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_141256 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_141257 (h0 : ordered_add_comm_monoid (has_zero (add_comm_monoid (has_neg linarith.comp)))) : archimedean (has_zero (add_comm_monoid (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_141258 (h0 : ring (bin_tree (semiring (semiring unsigned)))) : rank_condition (bin_tree (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_141259 (h0 : set (add_comm_semigroup enat -> enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_141260 (h0 : functor.add_const (semiring (has_add pos)) (finset pos)) : @is_noetherian_ring.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (has_add.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_141261 (h0 : cancel_comm_monoid_with_zero (semigroup (option (option pos)))) : unique_factorization_monoid (semigroup (option (option pos))) := sorry --non-trivial
lemma new_lemma_141262 (h0 : topological_space (normed_comm_ring (has_add (has_add (has_add Type))))) : preconnected_space (normed_comm_ring (has_add (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_141263 (h3 : topological_space string.iterator_imp) : t0_space string.iterator_imp := sorry --non-trivial
lemma new_lemma_141264 (h0 : functor.add_const (functor.add_const Prop (has_add linarith.comp)) (has_Inf Type)) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_141265 (h0 : group (linear_ordered_add_comm_group (random_gen linarith.ineq))) : is_cyclic (linear_ordered_add_comm_group (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_141266 (h0 : function.extfun Type (functor.add_const (function.extfun Type topological_space))) : @t0_space.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type topological_space.{0})) h0 pos)) (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_141267 (h0 : monoid (normed_group (has_inv (has_inv to_additive.value_type)))) : monoid.fg (normed_group (has_inv (has_inv to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_141268 (h0 : function.extfun Type (functor.add_const (prod (option empty) (option empty)))) : id_rel (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_141269 (h0 : functor.add_const (complete_lattice (has_neg name)) name) : @is_atomistic.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_141270 (h0 : topological_space (add_comm_monoid (sub_neg_monoid pos))) : t0_space (add_comm_monoid (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_141271 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_141272 (h0 : group (has_neg_part Type)) : group.fg (has_neg_part Type) := sorry --non-trivial
lemma new_lemma_141273 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (pseudo_metric_space.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (pseudo_metric_space.{0} name))  := sorry --non-trivial
lemma new_lemma_141274 (h0 : functor.add_const (topological_space (has_nndist unsigned)) empty) : @totally_disconnected_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_141275 (h0 : functor.add_const (topological_space pos) pos) : @locally_compact_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) pos h0)  := sorry --non-trivial
lemma new_lemma_141276 (h0 : topological_space (add_monoid string_imp)) : path_connected_space (add_monoid string_imp) := sorry --non-trivial
lemma new_lemma_141277 (h0 : functor.add_const (add_group (measure_theory.measure_space empty)) unsigned) : @is_add_cyclic.{0} (measure_theory.measure_space.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (measure_theory.measure_space.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_141278 (h0 : topological_space (plift (setoid (option unsigned)))) : t0_space (plift (setoid (option unsigned))) := sorry --non-trivial
lemma new_lemma_141279 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_141280 (h0 : list (simple_graph (has_Inf Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_141281 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_141282 (h0 : ring (linear_ordered_field unsigned)) : is_domain (linear_ordered_field unsigned) := sorry --non-trivial
lemma new_lemma_141283 (h0 : topological_space (with_bot linarith.comp)) : irreducible_space (with_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_141284 (h0 : ring (has_top (measurable_space.dynkin_system empty))) : is_domain (has_top (measurable_space.dynkin_system empty)) := sorry --non-trivial
lemma new_lemma_141285 (h1 : uniform_space num) : separated_space num := sorry --non-trivial
lemma new_lemma_141286 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra Type)) (boolean_algebra name)) : @archimedean.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (boolean_algebra.{1} Type)) (boolean_algebra.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_141287 (h0 : functor.add_const (ordered_add_comm_monoid (add_comm_monoid name)) name) : @archimedean.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_comm_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_141288 (h0 : functor.comp ring has_nndist environment.implicit_infer_kind) : @strong_rank_condition.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} ring.{0} has_nndist.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_141289 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) pos) : @preconnected_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_141290 (h0 : group (with_one (random_gen (random_gen linarith.ineq)))) : normalizer_condition (with_one (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_141291 (h0 : ring (semiring (has_top linarith.comp_source))) : rank_condition (semiring (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_141292 (h0 : has_mem.mem (measurable_space linarith.comp_source) has_emptyc.emptyc) : @path_connected_space.{0} (measurable_space.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_141293 (h0 : functor.add_const (ring (ordered_comm_ring pos)) linarith.comp) : @rank_condition.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_141294 (h0 : not (function.extfun Type cancel_comm_monoid_with_zero -> false)) : @unique_factorization_monoid.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) h0) (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_141295 (h0 : measurable_space (linear_ordered_comm_group_with_zero string.iterator_imp)) (h1 : filter (linear_ordered_comm_group_with_zero string.iterator_imp)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_141296 (h0 : topological_space (complete_distrib_lattice (ring (finset linarith.comp)))) : topological_space.separable_space (complete_distrib_lattice (ring (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_141297 (h0 : functor.add_const (function.extfun Type finset) (mul_zero_class (has_neg_part name))) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_141298 (h1 : topological_space (topological_space reducibility_hints)) : totally_disconnected_space (topological_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_141299 (h0 : topological_space (has_union (semiring linarith.comp))) : irreducible_space (has_union (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_141300 (h0 : topological_space (is_R_or_C empty)) : preirreducible_space (is_R_or_C empty) := sorry --non-trivial
lemma new_lemma_141301 (h0 : topological_space (complete_distrib_lattice (has_add (has_add name)))) : t1_space (complete_distrib_lattice (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_141302 (h0 : functor.add_const (functor.add_const Prop Type) (boolean_algebra (ring linarith.comp))) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_141303 (h0 : topological_space (normed_comm_ring (comm_group pos))) : loc_path_connected_space (normed_comm_ring (comm_group pos)) := sorry --non-trivial
lemma new_lemma_141304 (h0 : not (ring (has_norm unsigned) -> false)) : @strong_rank_condition.{0} (has_norm.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (has_norm.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_141305 (h0 : filter (has_union (semiring (has_norm unsigned)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_141306 (h0 : function.extfun Type group) : @normalizer_condition.{0} (finset.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (finset.{0} num))  := sorry --non-trivial
lemma new_lemma_141307 (h0 : functor.add_const (complete_lattice (semigroup num)) empty) : @is_atomistic.{0} (semigroup.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_141308 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_141309 (h0 : functor.add_const (topological_space (has_neg_part name)) name) : @regular_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_141310 (h0 : ordered_comm_monoid (has_neg (has_to_string Type))) : has_exists_mul_of_le (has_neg (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_141311 (h0 : fin has_zero.zero) : @is_simple_group.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type group.{0}) h0) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_141312 (h0 : function.extfun Type group) : @group.fg.{0} (measurable_space.dynkin_system.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.dynkin_system.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_141313 (h0 : functor.add_const (function.extfun Type uniform_space) name) : @complete_space.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) name h0) (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_141314 (h0 : ring (uniform_space (semi_normed_ring enat))) : rank_condition (uniform_space (semi_normed_ring enat)) := sorry --non-trivial
lemma new_lemma_141315 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_141316 (h0 : has_add (mul_one_class linarith.comp) -> mul_one_class (ring Type) -> Prop) : relator.bi_total h0 := sorry --non-trivial
lemma new_lemma_141317 (h0 : topological_space (ordered_ring unsigned)) : preirreducible_space (ordered_ring unsigned) := sorry --non-trivial
lemma new_lemma_141318 (h0 : function.extfun (Type 1) topological_space) : @preconnected_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_141319 (h0 : topological_space (measurable_space.dynkin_system (semiring num))) : discrete_topology (measurable_space.dynkin_system (semiring num)) := sorry --non-trivial
lemma new_lemma_141320 (h0 : not (complete_lattice (has_ssubset char) -> false)) : @is_compactly_generated.{0} (has_ssubset.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_ssubset.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_141321 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_union congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_141322 (h0 : ring (has_top (has_top linarith.comp))) : is_domain (has_top (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_141323 (h0 : topological_space (canonically_ordered_monoid (has_add linarith.comp))) : regular_space (canonically_ordered_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_141324 (h0 : has_mem.mem num has_emptyc.emptyc) : @monoid.fg.{0} num (@finset.pi.empty.{1 0} Type monoid.{0} num h0)  := sorry --non-trivial
lemma new_lemma_141325 (h0 : cancel_comm_monoid_with_zero (cancel_monoid (has_neg_part (has_nndist pos)))) : unique_factorization_monoid (cancel_monoid (has_neg_part (has_nndist pos))) := sorry --non-trivial
lemma new_lemma_141326 (h0 : uniform_space Type) : complete_space Type := sorry --non-trivial
lemma new_lemma_141327 (h0 : function.extfun Type (functor.add_const (topological_space (normed_linear_ordered_group unsigned)))) : @t0_space.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} unsigned)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} unsigned))) h0 num))  := sorry --non-trivial
lemma new_lemma_141328 (h0 : topological_space (normed_field (has_nnnorm char))) : t0_space (normed_field (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_141329 (h0 : not (complete_lattice (has_star congr_arg_kind) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_star.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_star.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_141330 (h0 : topological_space (has_neg num)) : loc_path_connected_space (has_neg num) := sorry --non-trivial
lemma new_lemma_141331 (h0 : functor.comp topological_space canonically_ordered_comm_semiring ennreal) : @t1_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_141332 (h0 : function.extfun Type ring) : @rank_condition.{0} (add_cancel_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_141333 (h0 : prod (linear_ordered_comm_monoid_with_zero unsigned) (linear_ordered_comm_monoid_with_zero unsigned)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_141334 (h0 : topological_space (has_top linarith.comp_source)) : discrete_topology (has_top linarith.comp_source) := sorry --non-trivial
lemma new_lemma_141335 (h0 : ring (random_gen (ordered_comm_semiring (comm_ring (comm_ring char))))) : is_domain (random_gen (ordered_comm_semiring (comm_ring (comm_ring char)))) := sorry --non-trivial
lemma new_lemma_141336 (h0 : ring (has_add (has_add (has_neg (has_neg (ring (boolean_algebra.core (has_neg Type)))))))) : rank_condition (has_add (has_add (has_neg (has_neg (ring (boolean_algebra.core (has_neg Type))))))) := sorry --non-trivial
lemma new_lemma_141337 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_141338 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @complete_space.{0} (ordered_comm_monoid.{0} real) (@matrix.vec_empty.{0} (uniform_space.{0} (ordered_comm_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_141339 (h0 : ordered_add_comm_monoid (finset (has_add pos))) : archimedean (finset (has_add pos)) := sorry --non-trivial
lemma new_lemma_141340 (h0 : function.extfun Type complete_lattice) : is_compactly_generated (measurable_space empty) := sorry --non-trivial
lemma new_lemma_141341 (h0 : topological_space (comm_semigroup linarith.comp)) : discrete_topology (comm_semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_141342 (h1 : uniform_space.core (with_one string_imp)) : @totally_separated_space.{0} (with_one.{0} string_imp) (@uniform_space.core.to_topological_space.{0} (with_one.{0} string_imp) h1)  := sorry --non-trivial
lemma new_lemma_141343 (h0 : functor.add_const (topological_space (ordered_ring unsigned)) congr_arg_kind) : @normal_space.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_141344 (h0 : topological_space (has_top (random_gen linarith.ineq))) (h1 : set (has_top (random_gen linarith.ineq))) : is_preirreducible h1 := sorry --non-trivial
lemma new_lemma_141345 (h0 : topological_space (add_left_cancel_semigroup unsigned)) : path_connected_space (add_left_cancel_semigroup unsigned) := sorry --non-trivial
lemma new_lemma_141346 (h0 : functor.add_const (group (has_star congr_arg_kind)) num) : @normalizer_condition.{0} (has_star.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (has_star.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_141347 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_141348 (h0 : topological_space (finset (finset linarith.comp))) : totally_disconnected_space (finset (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_141349 (h0 : functor.add_const (function.extfun (Type 1) group) (has_to_string Type)) : @group.fg.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) (has_to_string.{1} Type) h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_141350 (h0 : topological_space (normed_lattice_add_comm_group real)) : topological_space.separable_space (normed_lattice_add_comm_group real) := sorry --non-trivial
lemma new_lemma_141351 (h0 : complete_lattice (bin_tree (semiring (semiring empty)))) : complete_lattice.is_Sup_finite_compact (bin_tree (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_141352 (h0 : functor.add_const (finset (has_pos_part pos)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_141353 (h0 : topological_space (generalized_boolean_algebra (has_add (has_add pos)))) : normal_space (generalized_boolean_algebra (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_141354 (h0 : list (has_inter (option ennreal))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_141355 (h0 : not (group (with_bot linarith.comp) -> false)) : @group.fg.{0} (with_bot.{0} linarith.comp) (@classical.by_contradiction'.{1} (group.{0} (with_bot.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_141356 (h0 : complete_lattice (has_norm (random_gen fun_info))) : is_compactly_generated (has_norm (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_141357 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_141358 (h0 : topological_space (random_gen (random_gen (random_gen to_additive.value_type)))) : irreducible_space (random_gen (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_141359 (h0 : functor.add_const (topological_space (has_star num)) congr_arg_kind) : @preirreducible_space.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_141360 (h0 : functor.add_const (uniform_space (finset name)) name) : @complete_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (finset.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_141361 (h0 : group (canonically_ordered_monoid (has_Inf (has_Inf (has_Inf (has_Inf real)))))) : is_cyclic (canonically_ordered_monoid (has_Inf (has_Inf (has_Inf (has_Inf real))))) := sorry --non-trivial
lemma new_lemma_141362 (h0 : topological_space (has_add (mul_zero_class (cancel_monoid (has_neg_part ennreal))))) : regular_space (has_add (mul_zero_class (cancel_monoid (has_neg_part ennreal)))) := sorry --non-trivial
lemma new_lemma_141363 (h0 : functor.add_const (function.extfun Type list) (has_neg environment.implicit_infer_kind)) : palindrome (function.extfun_app (functor.add_const.run h0) (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_141364 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_separated_space.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_141365 (h0 : topological_space (finset (has_to_string Type))) : t1_space (finset (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_141366 (h0 : function.extfun Type group) : @normalizer_condition.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_141367 (h0 : semiring (add_cancel_monoid (has_neg (finset name)))) : is_noetherian_ring (add_cancel_monoid (has_neg (finset name))) := sorry --non-trivial
lemma new_lemma_141368 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra environment.implicit_infer_kind)) Type) : @archimedean.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_141369 (h0 : uniform_space (normed_lattice_add_comm_group (has_Inf (has_pos_part Type)))) : complete_space (normed_lattice_add_comm_group (has_Inf (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_141370 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_141371 (h0 : complete_lattice (div_inv_monoid (random_gen (has_nnnorm linarith.ineq)))) : complete_lattice.is_Sup_finite_compact (div_inv_monoid (random_gen (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_141372 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (monoid.{0} (option.{0} num)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} (option.{0} num)))  := sorry --non-trivial
lemma new_lemma_141373 (h0 : topological_space (has_norm (semiring congr_arg_kind))) : preirreducible_space (has_norm (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_141374 (h0 : function.extfun Type (functor.add_const (topological_space (has_Inf linarith.comp)))) : @locally_compact_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp))) h0 pos))  := sorry --non-trivial
lemma new_lemma_141375 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_141376 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_norm.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_norm.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_141377 (h0 : functor.add_const (ring (generalized_boolean_algebra linarith.comp)) name) : @is_principal_ideal_ring.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (generalized_boolean_algebra.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_141378 (h0 : group (has_union (has_top empty))) : is_cyclic (has_union (has_top empty)) := sorry --non-trivial
lemma new_lemma_141379 (h0 : dlist (linear_ordered_add_comm_group fun_info) -> dlist (linear_ordered_add_comm_group fun_info) -> bool) : is_dec_refl h0 := sorry --non-trivial
lemma new_lemma_141380 (h0 : monoid (id (random_gen linarith.ineq))) : monoid.fg (id (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_141381 (h0 : topological_space (complete_distrib_lattice (semigroup Type))) : totally_disconnected_space (complete_distrib_lattice (semigroup Type)) := sorry --non-trivial
lemma new_lemma_141382 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_141383 (h0 : ring (add_comm_monoid (ring Type))) : strong_rank_condition (add_comm_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_141384 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{0} (comm_semigroup.{0} linarith.comp) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (comm_semigroup.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_141385 (h0 : ordered_comm_monoid (has_Inf (has_neg name))) : has_exists_mul_of_le (has_Inf (has_neg name)) := sorry --non-trivial
lemma new_lemma_141386 (h1 : ring (semi_normed_ring string.iterator_imp)) : is_domain (semi_normed_ring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_141387 (h0 : add_group (has_to_string (finset linarith.comp))) : is_add_cyclic (has_to_string (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_141388 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_141389 (h0 : fin has_zero.zero) : @t1_space.{1} (canonically_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (canonically_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_141390 (h0 : topological_space (has_nndist (mul_one_class (ordered_semiring (has_to_string Type))))) : regular_space (has_nndist (mul_one_class (ordered_semiring (has_to_string Type)))) := sorry --non-trivial
lemma new_lemma_141391 (h0 : ring (linear_ordered_comm_monoid_with_zero empty)) : is_domain (linear_ordered_comm_monoid_with_zero empty) := sorry --non-trivial
lemma new_lemma_141392 (h0 : semiring (has_to_string (option num))) : is_noetherian_ring (has_to_string (option num)) := sorry --non-trivial
lemma new_lemma_141393 (h1 : complete_lattice (has_nnnorm (random_gen to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (has_nnnorm (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_141394 (h0 : function.extfun (finset Type -> Prop) (function.extfun (finset Type))) : @irreducible_space.{0} to_additive.value_type (@finset.pi.empty.{1 0} Type topological_space.{0} to_additive.value_type (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) to_additive.value_type) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) h0 (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) to_additive.value_type)) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_141395 (h0 : not (ring (has_one empty) -> false)) : @is_domain.{0} (has_one.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (has_one.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_141396 (h0 : topological_space (ordered_comm_ring (finset pos))) : totally_disconnected_space (ordered_comm_ring (finset pos)) := sorry --non-trivial
lemma new_lemma_141397 (h1 : semiring (simple_graph enat)) (h2 : ideal (simple_graph enat)) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_141398 (h0 : complete_lattice (has_neg ennreal)) : complete_lattice.is_Sup_finite_compact (has_neg ennreal) := sorry --non-trivial
lemma new_lemma_141399 (h0 : group (boolean_algebra.core num)) : is_simple_group (boolean_algebra.core num) := sorry --non-trivial
lemma new_lemma_141400 (h0 : functor.add_const (complete_lattice (finset Type)) pos) : @is_atomistic.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (finset.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_141401 (h0 : complete_lattice (simple_graph string_imp)) : complete_lattice.is_Sup_finite_compact (simple_graph string_imp) := sorry --non-trivial
lemma new_lemma_141402 (h0 : topological_space (topological_space (has_nnnorm to_additive.value_type))) : locally_compact_space (topological_space (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_141403 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_141404 (h0 : semiring (has_zero (has_add Type))) : is_noetherian_ring (has_zero (has_add Type)) := sorry --non-trivial
lemma new_lemma_141405 (h0 : functor.add_const (semiring (has_Inf real)) Type) : @is_noetherian_ring.{0} (has_Inf.{0} real) (@functor.add_const.run.{0 1} (semiring.{0} (has_Inf.{0} real)) Type h0)  := sorry --non-trivial
lemma new_lemma_141406 (h0 : metric_space linarith.comp -> metric_space linarith.comp -> Prop) : is_symm (metric_space linarith.comp) h0 := sorry --non-trivial
lemma new_lemma_141407 (h0 : monoid (generalized_boolean_algebra (finset linarith.comp))) : monoid.fg (generalized_boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_141408 (h2 : ring (random_gen (has_ssubset linarith.comp_source))) : is_domain (random_gen (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_141409 (h0 : topological_space (add_semigroup congr_arg_kind)) : locally_compact_space (add_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_141410 (h0 : pseudo_metric_space (group_with_zero (option ennreal))) (h1 : add_monoid (group_with_zero (option ennreal))) : has_lipschitz_add (group_with_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_141411 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen fun_info))) : @is_atomistic.{0} (random_gen.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_141412 (h0 : functor.add_const (add_group (has_to_string environment.implicit_infer_kind)) (has_add (has_add Type))) : @is_add_cyclic.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (add_group.{0} (has_to_string.{0} environment.implicit_infer_kind)) (has_add.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_141413 (h0 : complete_lattice (has_nndist empty)) : complete_lattice.is_Sup_finite_compact (has_nndist empty) := sorry --non-trivial
lemma new_lemma_141414 (h1 : list (has_norm (random_gen string_imp))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_141415 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_141416 (h0 : topological_space (ordered_comm_ring (has_pos_part Type))) : locally_compact_space (ordered_comm_ring (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_141417 (h0 : functor.add_const (ring (finset Type)) (ring Type)) : @rank_condition.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (finset.{1} Type)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_141418 (h0 : topological_space (denumerable (metric_space (normed_field linarith.comp_source)))) : totally_disconnected_space (denumerable (metric_space (normed_field linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_141419 (h0 : monoid (has_top unsigned)) : monoid.fg (has_top unsigned) := sorry --non-trivial
lemma new_lemma_141420 (h0 : topological_space (add_semigroup (option unsigned))) : irreducible_space (add_semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_141421 (h0 : topological_space (monoid unsigned)) : totally_separated_space (monoid unsigned) := sorry --non-trivial
lemma new_lemma_141422 (h0 : complete_lattice string_imp) : is_compactly_generated string_imp := sorry --non-trivial
lemma new_lemma_141423 (h0 : not (group (add_left_cancel_monoid linarith.ineq) -> false)) : @is_cyclic.{0} (add_left_cancel_monoid.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (add_left_cancel_monoid.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_141424 (h0 : topological_space (sub_neg_monoid (has_Inf Type))) : preirreducible_space (sub_neg_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_141425 (h0 : add_monoid (add_group unsigned)) : add_monoid.fg (add_group unsigned) := sorry --non-trivial
lemma new_lemma_141426 (h0 : list (encodable (random_gen to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_141427 (h0 : semiring (semigroup (ring (has_neg (has_neg name))))) : is_noetherian_ring (semigroup (ring (has_neg (has_neg name)))) := sorry --non-trivial
lemma new_lemma_141428 (h0 : topological_space (with_bot (semiring (has_norm linarith.comp)))) : preirreducible_space (with_bot (semiring (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_141429 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_141430 (h0 : group (comm_ring (mul_one_class reducibility_hints))) : is_cyclic (comm_ring (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_141431 (h0 : topological_space (add_group (semiring linarith.comp))) : t0_space (add_group (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_141432 (h0 : has_coe (nondiscrete_normed_field (nondiscrete_normed_field ereal)) Prop) (h1 : nondiscrete_normed_field (nondiscrete_normed_field ereal)) : @coe_b.{1 1} (nondiscrete_normed_field.{0} (nondiscrete_normed_field.{0} ereal)) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_141433 (h0 : uniform_space (add_cancel_monoid (has_neg (has_neg Type)))) : separated_space (add_cancel_monoid (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_141434 (h0 : ring (mul_zero_class (has_add (has_add pos)))) : rank_condition (mul_zero_class (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_141435 (h0 : functor.add_const (ring (partial_order empty)) empty) : @rank_condition.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (partial_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_141436 (h0 : functor.add_const (uniform_space (normed_comm_ring Type)) pos) : @separated_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (normed_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_141437 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_141438 (h0 : function.extfun Type group) : @group.fg.{0} unsigned (@function.extfun_app.{2 1} Type group.{0} h0 unsigned)  := sorry --non-trivial
lemma new_lemma_141439 (h2 : add_group (distrib string_imp)) : is_add_cyclic (distrib string_imp) := sorry --non-trivial
lemma new_lemma_141440 (h0 : uniform_space (semigroup (option (option pos)))) : separated_space (semigroup (option (option pos))) := sorry --non-trivial
lemma new_lemma_141441 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (pseudo_metric_space.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (pseudo_metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_141442 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (measure_theory.measure_space.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (measure_theory.measure_space.{0} num))  := sorry --non-trivial
lemma new_lemma_141443 (h0 : group (semigroup (has_pos_part pos))) : normalizer_condition (semigroup (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_141444 (h0 : group (simple_graph (ring Type))) : group.fg (simple_graph (ring Type)) := sorry --non-trivial
lemma new_lemma_141445 (h0 : ring (has_norm to_additive.value_type)) : rank_condition (has_norm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_141446 (h0 : group (normed_field (mul_one_class char))) : is_cyclic (normed_field (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_141447 (h1 : complete_lattice (measurable_space (has_norm linarith.comp_source))) : is_compactly_generated (measurable_space (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_141448 (h0 : group (random_gen (has_top (has_top (has_top (random_gen (has_top linarith.comp_source))))))) : is_cyclic (random_gen (has_top (has_top (has_top (random_gen (has_top linarith.comp_source)))))) := sorry --non-trivial
lemma new_lemma_141449 (h0 : ring (has_nnnorm string.iterator_imp)) : strong_rank_condition (has_nnnorm string.iterator_imp) := sorry --non-trivial
lemma new_lemma_141450 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_nndist empty)) := sorry --non-trivial
lemma new_lemma_141451 (h0 : complete_lattice (monoid to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_141452 (h0 : functor.add_const (group (left_cancel_semigroup empty)) congr_arg_kind) : @is_cyclic.{0} (left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (left_cancel_semigroup.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_141453 (h0 : set (mul_one_class (mul_one_class string.iterator_imp))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_141454 (h0 : function.extfun (Type 1) (functor.comp topological_space ring)) : @topological_space.separable_space.{1} (ring.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} ring.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} ring.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_141455 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_141456 (h0 : random_gen (random_gen (random_gen (comm_ring string_imp))) -> char) : function.bijective h0 := sorry --non-trivial
lemma new_lemma_141457 (h0 : functor.add_const (topological_space (has_nndist Type)) linarith.comp) : @irreducible_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_141458 (h0 : group (semigroup (has_Inf real))) : is_cyclic (semigroup (has_Inf real)) := sorry --non-trivial
lemma new_lemma_141459 (h0 : functor.add_const (topological_space (has_neg Type)) pos) : @locally_compact_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_141460 (h0 : functor.add_const (function.extfun Type finset) environment.implicit_infer_kind) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (finset name)) := sorry --non-trivial
lemma new_lemma_141461 (h0 : topological_space (add_comm_monoid (finset name))) : totally_separated_space (add_comm_monoid (finset name)) := sorry --non-trivial
lemma new_lemma_141462 (h0 : functor.add_const (fin has_zero.zero) name) : @is_domain.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (ordered_comm_ring.{1} Type)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) name h0))  := sorry --non-trivial
lemma new_lemma_141463 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (@id.{2} Type to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (@id.{2} Type to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_141464 (h0 : topological_space (cancel_monoid (has_add pos))) : normal_space (cancel_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_141465 (h1 : uniform_space (has_emptyc to_additive.value_type)) : complete_space (has_emptyc to_additive.value_type) := sorry --non-trivial
lemma new_lemma_141466 (h0 : topological_space (has_Inf (has_pos_part pos))) : totally_separated_space (has_Inf (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_141467 (h0 : cancel_comm_monoid_with_zero (ordered_comm_monoid (has_pos_part (has_add (has_Inf (has_add real)))))) : unique_factorization_monoid (ordered_comm_monoid (has_pos_part (has_add (has_Inf (has_add real))))) := sorry --non-trivial
lemma new_lemma_141468 (h0 : topological_space (semiring (semiring (semiring linarith.comp)))) : locally_compact_space (semiring (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_141469 (h0 : complete_lattice (semigroup unsigned)) : is_compactly_generated (semigroup unsigned) := sorry --non-trivial
lemma new_lemma_141470 (h1 : has_mem.mem (has_emptyc congr_arg_kind) has_emptyc.emptyc) : @monoid.fg.{0} (has_emptyc.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type monoid.{0} (has_emptyc.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_141471 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_141472 (h0 : topological_space (has_one fun_info)) : totally_disconnected_space (has_one fun_info) := sorry --non-trivial
lemma new_lemma_141473 (h0 : fin has_zero.zero) : @add_monoid.fg.{0} (ordered_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (add_monoid.{0} (ordered_comm_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_141474 (h0 : ring (normed_group (has_top (semiring empty)))) : is_domain (normed_group (has_top (semiring empty))) := sorry --non-trivial
lemma new_lemma_141475 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @locally_compact_space.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_141476 (h0 : not (ring (distrib to_additive.value_type) -> false)) : @rank_condition.{0} (distrib.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_141477 (h0 : functor.add_const (ring (add_cancel_monoid linarith.comp)) (has_neg name)) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} linarith.comp)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_141478 (h0 : ring (with_one empty)) : rank_condition (with_one empty) := sorry --non-trivial
lemma new_lemma_141479 (h0 : functor.add_const (topological_space (boolean_algebra Type)) linarith.comp) : @discrete_topology.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_141480 (h0 : ring (add_cancel_monoid (has_neg_part Type))) : is_principal_ideal_ring (add_cancel_monoid (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_141481 (h0 : topological_space (complete_semilattice_Sup (with_zero (has_inv (has_inv string_imp))))) : path_connected_space (complete_semilattice_Sup (with_zero (has_inv (has_inv string_imp)))) := sorry --non-trivial
lemma new_lemma_141482 (h0 : complete_lattice (normed_comm_ring (has_neg environment.implicit_infer_kind))) : is_compactly_generated (normed_comm_ring (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_141483 (h0 : functor.add_const (function.extfun Type group) (finset linarith.comp)) : @is_simple_group.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) (finset.{0} linarith.comp) h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_141484 (h0 : topological_space (has_nndist (normed_comm_ring environment.implicit_infer_kind))) : regular_space (has_nndist (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_141485 (h0 : add_group (option (semiring (semiring (semiring num))))) : is_add_cyclic (option (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_141486 (h0 : topological_space (ordered_ring num)) : t0_space (ordered_ring num) := sorry --non-trivial
lemma new_lemma_141487 (h0 : functor.add_const (topological_space (complete_linear_order congr_arg_kind)) empty) : @normal_space.{0} (complete_linear_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_linear_order.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_141488 : nonempty (add_comm_semigroup ereal) := sorry --non-trivial
lemma new_lemma_141489 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring Type)) Type) : @irreducible_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_141490 (h0 : set (uniform_space (mul_one_class linarith.ineq))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_141491 (h0 : finset (has_neg_part Type)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_141492 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (filter.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (filter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_141493 (h0 : topological_space (has_nnnorm string_imp)) : t0_space (has_nnnorm string_imp) := sorry --non-trivial
lemma new_lemma_141494 (h0 : functor.add_const (topological_space (normed_linear_ordered_group congr_arg_kind)) congr_arg_kind) : @discrete_topology.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_141495 (h0 : ring (mul_zero_class (finset environment.implicit_infer_kind))) : strong_rank_condition (mul_zero_class (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_141496 (h0 : monoid (has_sub linarith.comp)) : monoid.fg (has_sub linarith.comp) := sorry --non-trivial
lemma new_lemma_141497 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (ring (ring (ring Type)))) : @totally_separated_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) (ring.{1} (ring.{1} (ring.{1} Type))) h0) Type)  := sorry --non-trivial
lemma new_lemma_141498 (h0 : prod (measurable_space.dynkin_system (semiring empty)) (measurable_space.dynkin_system (semiring empty))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_141499 (h0 : functor.add_const (topological_space (partial_order empty)) unsigned) : @loc_path_connected_space.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_141500 (h0 : functor.add_const (topological_space (canonically_linear_ordered_monoid pos)) name) : @regular_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_141501 (h0 : ring (is_R_or_C empty)) : rank_condition (is_R_or_C empty) := sorry --non-trivial
lemma new_lemma_141502 (h0 : complete_lattice (encodable char)) : is_compactly_generated (encodable char) := sorry --non-trivial
lemma new_lemma_141503 (h0 : function.extfun (Type 1) topological_space) : @sequential_space.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_141504 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_141505 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (comm_semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (comm_semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_141506 (h0 : functor.add_const (topological_space (cancel_monoid ennreal)) ennreal) : @loc_path_connected_space.{0} (cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_141507 (h0 : functor.add_const (fin has_zero.zero) Type) : @is_domain.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (ordered_comm_ring.{1} Type)) (@functor.add_const.run.{0 1} (fin (@has_zero.zero.{0} nat nat.has_zero)) Type h0))  := sorry --non-trivial
lemma new_lemma_141508 (h0 : topological_space (measurable_space (has_norm empty))) : t0_space (measurable_space (has_norm empty)) := sorry --non-trivial
lemma new_lemma_141509 (h0 : topological_space (fintype fun_info)) : path_connected_space (fintype fun_info) := sorry --non-trivial
lemma new_lemma_141510 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc to_additive.value_type))) : @totally_separated_space.{0} (has_emptyc.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} to_additive.value_type)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_141511 (h0 : function.extfun Type (functor.add_const (ordered_comm_monoid (has_neg ennreal)))) : @has_exists_mul_of_le.{0} (has_neg.{0} ennreal) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_neg.{0} ennreal)) (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_comm_monoid.{0} (has_neg.{0} ennreal))) h0 (mul_zero_class.{0} name)))  := sorry --non-trivial
lemma new_lemma_141512 (h0 : ring (has_zero (has_add (has_add unsigned)))) : rank_condition (has_zero (has_add (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_141513 (h0 : not (topological_space (with_bot congr_arg_kind) -> false)) : @path_connected_space.{0} (with_bot.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_141514 (h0 : functor.add_const (topological_space (semigroup pos)) name) : @discrete_topology.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_141515 (h0 : cancel_comm_monoid_with_zero (complete_linear_order (semiring (semiring (semiring unsigned))))) : unique_factorization_monoid (complete_linear_order (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_141516 (h0 : complete_lattice (add_cancel_monoid (has_add Type))) : complete_lattice.is_Sup_finite_compact (add_cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_141517 (h0 : complete_lattice (has_add (cancel_monoid ennreal))) : is_atomistic (has_add (cancel_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_141518 (h0 : add_monoid (comm_group (finset linarith.comp))) : add_monoid.fg (comm_group (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_141519 (h0 : topological_space (simple_graph (has_add linarith.comp))) : preirreducible_space (simple_graph (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_141520 (h0 : set (has_compl char)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_141521 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) (boolean_algebra pos)) : @locally_compact_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) (boolean_algebra.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_141522 (h0 : uniform_space (complete_distrib_lattice (option empty))) : separated_space (complete_distrib_lattice (option empty)) := sorry --non-trivial
lemma new_lemma_141523 (h0 : ring (has_add (has_pos_part (ring (has_to_string (has_pos_part pos)))))) : strong_rank_condition (has_add (has_pos_part (ring (has_to_string (has_pos_part pos))))) := sorry --non-trivial
lemma new_lemma_141524 (h0 : topological_space congr_arg_kind) : loc_path_connected_space congr_arg_kind := sorry --non-trivial
lemma new_lemma_141525 (h0 : is_empty (ring (has_star unsigned) -> false)) : @rank_condition.{0} (has_star.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (has_star.{0} unsigned)) (@is_empty.elim'.{0 0} (ring.{0} (has_star.{0} unsigned) → false) false h0))  := sorry --non-trivial
lemma new_lemma_141526 (h0 : functor.add_const (ordered_comm_monoid (complete_distrib_lattice Type)) Type) : @has_exists_mul_of_le.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 1} (ordered_comm_monoid.{1} (complete_distrib_lattice.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_141527 (h0 : functor.add_const (topological_space (has_add name)) name) : @t0_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_141528 (h0 : ring (has_inter congr_arg_kind)) : rank_condition (has_inter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_141529 (h0 : fin has_zero.zero) : @add_monoid.fg.{0} (normed_lattice_add_comm_group.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (normed_lattice_add_comm_group.{0} pos)) linarith.comp (@matrix.vec_empty.{0} (functor.add_const.{0 0} (add_monoid.{0} (normed_lattice_add_comm_group.{0} pos)) linarith.comp) h0))  := sorry --non-trivial
lemma new_lemma_141530 (h0 : ring (finset (option ennreal))) : rank_condition (finset (option ennreal)) := sorry --non-trivial
lemma new_lemma_141531 (h0 : topological_space (canonically_ordered_monoid name)) : totally_separated_space (canonically_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_141532 (h4 : complete_lattice (add_monoid (with_one fun_info))) : complete_lattice.is_Sup_finite_compact (add_monoid (with_one fun_info)) := sorry --non-trivial
lemma new_lemma_141533 (h0 : functor.add_const (filter (monoid unsigned)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_141534 (h0 : uniform_space (has_bot (has_Inf (sub_neg_monoid Type)))) : complete_space (has_bot (has_Inf (sub_neg_monoid Type))) := sorry --non-trivial
lemma new_lemma_141535 (h0 : ring (comm_group (comm_group unsigned))) : is_domain (comm_group (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_141536 (h0 : group (comm_monoid num)) : group.fg (comm_monoid num) := sorry --non-trivial
lemma new_lemma_141537 (h0 : ring (ordered_comm_ring (has_Inf Type))) : rank_condition (ordered_comm_ring (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_141538 (h0 : uniform_space (measurable_space (has_top fun_info))) : separated_space (measurable_space (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_141539 (h0 : functor.add_const (add_monoid (add_comm_monoid pos)) name) : @add_monoid.fg.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (add_comm_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_141540 (h1 : add_group (has_emptyc (random_gen (random_gen linarith.comp_source)))) : is_add_cyclic (has_emptyc (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_141541 (h0 : complete_lattice (semi_normed_comm_ring (random_gen linarith.ineq))) : is_compactly_generated (semi_normed_comm_ring (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_141542 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_141543 (h0 : ring (non_unital_non_assoc_semiring (mul_one_class (has_compl char)))) : is_domain (non_unital_non_assoc_semiring (mul_one_class (has_compl char))) := sorry --non-trivial
lemma new_lemma_141544 (h0 : topological_space (linear_ordered_comm_ring empty)) : t1_space (linear_ordered_comm_ring empty) := sorry --non-trivial
lemma new_lemma_141545 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} pos (@function.extfun_app.{2 1} Type ring.{0} h0 pos)  := sorry --non-trivial
lemma new_lemma_141546 (h0 : topological_space (with_zero (random_gen string_imp))) : t0_space (with_zero (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_141547 (h0 : ordered_add_comm_monoid (canonically_linear_ordered_monoid unsigned)) : archimedean (canonically_linear_ordered_monoid unsigned) := sorry --non-trivial
lemma new_lemma_141548 (h0 : complete_lattice (has_star (semiring empty))) : complete_lattice.is_Sup_finite_compact (has_star (semiring empty)) := sorry --non-trivial
lemma new_lemma_141549 (h0 : topological_space (has_one (semiring num))) : t0_space (has_one (semiring num)) := sorry --non-trivial
lemma new_lemma_141550 (h0 : functor.add_const (topological_space (free_add_monoid congr_arg_kind)) empty) : @locally_compact_space.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_141551 (h1 : group (comm_ring linarith.ineq)) : is_cyclic (comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_141552 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (comm_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_141553 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (ordered_semiring.{0} real) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_semiring.{0} real))  := sorry --non-trivial
lemma new_lemma_141554 (h0 : add_group (measurable_space linarith.ineq)) : is_add_cyclic (measurable_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_141555 (h0 : topological_space (has_norm (has_norm (comm_ring (dlist (comm_ring fun_info)))))) : path_connected_space (has_norm (has_norm (comm_ring (dlist (comm_ring fun_info))))) := sorry --non-trivial
lemma new_lemma_141556 (h0 : functor.add_const (topological_space (non_assoc_semiring num)) (semiring (semiring num))) : @t0_space.{0} (non_assoc_semiring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} num)) (semiring.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_141557 (h0 : functor.add_const (list (ordered_comm_ring Type)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_141558 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_141559 (h0 : group (semigroup environment.implicit_infer_kind)) : group.fg (semigroup environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_141560 (h0 : filter (add_comm_monoid (has_to_string pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_141561 (h0 : has_lt (random_gen enat)) : no_max_order (random_gen enat) := sorry --non-trivial
lemma new_lemma_141562 (h0 : group (finset (has_add (has_add Type)))) : is_cyclic (finset (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_141563 (h0 : functor.add_const (group (generalized_boolean_algebra pos)) Type) : @group.fg.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (generalized_boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_141564 (h0 : functor.add_const (list (monoid unsigned)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_141565 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_141566 (h0 : topological_space (semigroup empty)) : topological_space.separable_space (semigroup empty) := sorry --non-trivial
lemma new_lemma_141567 (h0 : finset (normed_comm_ring (has_nndist pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_141568 (h0 : add_group (normed_field name)) : is_add_cyclic (normed_field name) := sorry --non-trivial
lemma new_lemma_141569 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} h0 (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_141570 (h0 : functor.add_const (ring (bin_tree unsigned)) empty) : @is_principal_ideal_ring.{0} (bin_tree.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (bin_tree.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_141571 (h0 : topological_space (semigroup (finset (ring (has_to_string Type))))) : discrete_topology (semigroup (finset (ring (has_to_string Type)))) := sorry --non-trivial
lemma new_lemma_141572 (h0 : group (has_top (has_inv (random_gen to_additive.value_type)))) : group.fg (has_top (has_inv (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_141573 (h0 : topological_space (ordered_comm_ring (ring (ring linarith.comp)))) : discrete_topology (ordered_comm_ring (ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_141574 (h0 : functor.add_const (topological_space (semigroup Type)) pos) : @preirreducible_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_141575 (h0 : ring (linear_ordered_comm_group_with_zero ereal)) : is_domain (linear_ordered_comm_group_with_zero ereal) := sorry --non-trivial
lemma new_lemma_141576 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_141577 (h0 : ring (random_gen (has_norm to_additive.value_type))) : rank_condition (random_gen (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_141578 (h0 : ring (complete_semilattice_Sup (has_top fun_info))) : is_domain (complete_semilattice_Sup (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_141579 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) pos) : @has_exists_mul_of_le.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) pos h0) (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_141580 (h0 : functor.add_const (topological_space (finset Type)) pos) : @locally_compact_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_141581 (h0 : topological_space (semi_normed_comm_ring (random_gen char))) : t0_space (semi_normed_comm_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_141582 (h1 : ring (semi_normed_comm_ring (has_add (random_gen linarith.ineq)))) : is_domain (semi_normed_comm_ring (has_add (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_141583 (h0 : functor.add_const (group (cancel_monoid name)) linarith.comp) : @is_cyclic.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_141584 (h0 : ring (denumerable linarith.ineq)) : is_domain (denumerable linarith.ineq) := sorry --non-trivial
lemma new_lemma_141585 (h0 : topological_space (semi_normed_ring (distrib linarith.comp_source))) : t0_space (semi_normed_ring (distrib linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_141586 (h0 : semiring (normed_lattice_add_comm_group empty)) : is_noetherian_ring (normed_lattice_add_comm_group empty) := sorry --non-trivial
lemma new_lemma_141587 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (ordered_ring.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_ring.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_141588 (h0 : group (semigroup (has_to_string (has_to_string (has_to_string congr_arg_kind))))) : normalizer_condition (semigroup (has_to_string (has_to_string (has_to_string congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_141589 (h0 : functor.add_const (group (free_add_monoid congr_arg_kind)) unsigned) : @is_cyclic.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (free_add_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_141590 (h1 : semiring (nondiscrete_normed_field (normed_field (normed_field char)))) (h2 : ideal (nondiscrete_normed_field (normed_field (normed_field char)))) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_141591 (h0 : topological_space (comm_ring fun_info)) : irreducible_space (comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_141592 (h0 : monoid (has_to_string linarith.comp)) : monoid.fg (has_to_string linarith.comp) := sorry --non-trivial
lemma new_lemma_141593 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (boolean_algebra.core congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_141594 (h0 : ring (comm_group (has_to_string (has_to_string pos)))) : rank_condition (comm_group (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_141595 (h0 : ring (has_append (metric_space string_imp))) : strong_rank_condition (has_append (metric_space string_imp)) := sorry --non-trivial
lemma new_lemma_141596 (h0 : ring (has_dist (option unsigned))) : is_principal_ideal_ring (has_dist (option unsigned)) := sorry --non-trivial
lemma new_lemma_141597 (h0 : not (topological_space string.iterator_imp -> false)) : @t0_space.{0} string.iterator_imp (@classical.by_contradiction'.{1} (topological_space.{0} string.iterator_imp) h0)  := sorry --non-trivial
lemma new_lemma_141598 (h0 : functor.add_const (topological_space (finset unsigned)) Type) : @totally_separated_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_141599 (h1 : topological_space (has_norm (semiring linarith.comp))) : totally_separated_space (has_norm (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_141600 (h0 : functor.add_const (ordered_comm_monoid (semigroup name)) pos) : @has_exists_mul_of_le.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (semigroup.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_141601 (h0 : complete_lattice (has_add (semigroup (option pos)))) : is_atomistic (has_add (semigroup (option pos))) := sorry --non-trivial
lemma new_lemma_141602 (h0 : ring (encodable (has_nnnorm fun_info))) : is_domain (encodable (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_141603 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (ring.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ring.{0} num))  := sorry --non-trivial
lemma new_lemma_141604 (h0 : has_mem.mem (with_one linarith.ineq) has_emptyc.emptyc) : @irreducible_space.{0} (with_one.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_141605 (h0 : group (has_nndist Type)) : is_simple_group (has_nndist Type) := sorry --non-trivial
lemma new_lemma_141606 (h0 : uniform_space (has_le (mul_one_class reducibility_hints))) : complete_space (has_le (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_141607 (h0 : topological_space (has_union (semiring linarith.comp))) : preirreducible_space (has_union (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_141608 (h0 : group (random_gen (random_gen to_additive.value_type))) : group.fg (random_gen (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_141609 (h0 : group (complete_semilattice_Sup (has_nnnorm (has_nnnorm char)))) : group.fg (complete_semilattice_Sup (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_141610 (h0 : not (uniform_space (has_compl to_additive.value_type) -> false)) : @complete_space.{0} (has_compl.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_compl.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_141611 (h0 : not (group (fintype fun_info) -> false)) : @is_cyclic.{0} (fintype.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (fintype.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_141612 (h1 : complete_lattice (with_zero (has_nnnorm (has_nnnorm char)))) : is_compactly_generated (with_zero (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_141613 (h0 : ordered_add_comm_monoid (ordered_comm_ring (has_Inf real))) : archimedean (ordered_comm_ring (has_Inf real)) := sorry --non-trivial
lemma new_lemma_141614 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_141615 (h0 : complete_lattice (has_emptyc fun_info)) : is_atomistic (has_emptyc fun_info) := sorry --non-trivial
lemma new_lemma_141616 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_141617 (h0 : group (ring (has_add (finset linarith.comp)))) : is_simple_group (ring (has_add (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_141618 (h0 : fin has_zero.zero) : @strong_rank_condition.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) h0) (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_141619 (h0 : ring (has_add (finset pos))) : rank_condition (has_add (finset pos)) := sorry --non-trivial
lemma new_lemma_141620 (h0 : complete_lattice (non_assoc_semiring empty)) : complete_lattice.is_Sup_finite_compact (non_assoc_semiring empty) := sorry --non-trivial
lemma new_lemma_141621 (h1 : topological_space (add_comm_semigroup std_gen)) : totally_disconnected_space (add_comm_semigroup std_gen) := sorry --non-trivial
lemma new_lemma_141622 (h0 : ring (id (semiring congr_arg_kind))) : strong_rank_condition (id (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_141623 (h0 : prod (has_inter empty) (has_inter empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_141624 (h0 : group (normed_comm_ring (has_add pos))) : normalizer_condition (normed_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_141625 (h0 : set (linarith.ineq -> nondiscrete_normed_field linarith.ineq)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_141626 (h0 : topological_space (with_one (random_gen fun_info))) : irreducible_space (with_one (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_141627 (h0 : functor.add_const (topological_space (has_neg_part Type)) pos) : @loc_path_connected_space.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg_part.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_141628 (h0 : topological_space (ordered_comm_group num)) : loc_path_connected_space (ordered_comm_group num) := sorry --non-trivial
lemma new_lemma_141629 (h0 : list (functor.add_const (topological_space (normed_comm_ring name)) Type)) : @locally_compact_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} name)) Type (@list.head.{0} (functor.add_const.{0 1} (topological_space.{0} (normed_comm_ring.{0} name)) Type) (@functor.add_const.inhabited.{0 1} (topological_space.{0} (normed_comm_ring.{0} name)) Type (@inhabited_topological_space.{0} (normed_comm_ring.{0} name))) h0))  := sorry --non-trivial
lemma new_lemma_141630 (h0 : topological_space (has_dist (option unsigned))) : locally_compact_space (has_dist (option unsigned)) := sorry --non-trivial
lemma new_lemma_141631 (h0 : topological_space (ordered_comm_monoid (has_bot (finset Type)))) : t0_space (ordered_comm_monoid (has_bot (finset Type))) := sorry --non-trivial
lemma new_lemma_141632 (h0 : not (uniform_space (with_bot num) -> false)) : @complete_space.{0} (with_bot.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (with_bot.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_141633 (h0 : not (ring (add_left_cancel_monoid char) -> false)) : @rank_condition.{0} (add_left_cancel_monoid.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (add_left_cancel_monoid.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_141634 (h0 : topological_space (left_cancel_semigroup (partial_order (mul_zero_class unsigned)))) : totally_disconnected_space (left_cancel_semigroup (partial_order (mul_zero_class unsigned))) := sorry --non-trivial
lemma new_lemma_141635 (h0 : functor.add_const (filter (add_cancel_monoid environment.implicit_infer_kind)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_141636 (h1 : not (filter (distrib to_additive.value_type) -> false)) : filter.ne_bot (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_141637 (h0 : functor.add_const (group (add_cancel_monoid linarith.comp)) pos) : @normalizer_condition.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_141638 (h0 : group (semigroup ennreal)) : group.fg (semigroup ennreal) := sorry --non-trivial
lemma new_lemma_141639 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_141640 (h0 : monoid (linear_order (option unsigned))) : monoid.fg (linear_order (option unsigned)) := sorry --non-trivial
lemma new_lemma_141641 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_141642 (h0 : ordered_comm_monoid (semigroup (ring (has_neg environment.implicit_infer_kind)))) : has_exists_mul_of_le (semigroup (ring (has_neg environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_141643 (h0 : complete_lattice (has_top (has_ssubset fun_info))) : complete_lattice.is_Sup_finite_compact (has_top (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_141644 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_141645 (h0 : filter (ordered_comm_group (option (option (option (option (option (option (option (option unsigned)))))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_141646 (h0 : functor.add_const (topological_space (simple_graph Type)) linarith.comp) : @topological_space.separable_space.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (simple_graph.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_141647 (h0 : function.extfun Type group) : @normalizer_condition.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_141648 (h0 : ring (has_emptyc (has_top to_additive.value_type))) : is_domain (has_emptyc (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_141649 (h0 : cancel_comm_monoid_with_zero (has_pos_part (has_pos_part linarith.comp))) : unique_factorization_monoid (has_pos_part (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_141650 (h0 : ring (linear_ordered_comm_monoid_with_zero empty)) : is_principal_ideal_ring (linear_ordered_comm_monoid_with_zero empty) := sorry --non-trivial
lemma new_lemma_141651 (h0 : not (uniform_space (random_gen (random_gen (mul_one_class linarith.comp_source))) -> false)) : @complete_space.{0} (random_gen.{0} (random_gen.{0} (mul_one_class.{0} linarith.comp_source))) (@classical.by_contradiction'.{1} (uniform_space.{0} (random_gen.{0} (random_gen.{0} (mul_one_class.{0} linarith.comp_source)))) h0)  := sorry --non-trivial
lemma new_lemma_141652 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (add_left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_141653 (h1 : complete_lattice (linear_ordered_add_comm_group (has_nnnorm (random_gen string_imp)))) : is_compactly_generated (linear_ordered_add_comm_group (has_nnnorm (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_141654 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_simple_group.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_141655 (h0 : topological_space (has_add (has_neg Type))) : irreducible_space (has_add (has_neg Type)) := sorry --non-trivial
lemma new_lemma_141656 (h0 : topological_space (generalized_boolean_algebra (has_neg name))) : loc_path_connected_space (generalized_boolean_algebra (has_neg name)) := sorry --non-trivial
lemma new_lemma_141657 (h0 : topological_space (has_zero (normed_comm_ring unsigned))) : discrete_topology (has_zero (normed_comm_ring unsigned)) := sorry --non-trivial
lemma new_lemma_141658 (h0 : functor.add_const (cancel_comm_monoid_with_zero (left_cancel_semigroup congr_arg_kind)) num) : @unique_factorization_monoid.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (left_cancel_semigroup.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_141659 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_141660 (h0 : topological_space (measurable_space.dynkin_system unsigned)) : t0_space (measurable_space.dynkin_system unsigned) := sorry --non-trivial
lemma new_lemma_141661 (h0 : ring (normed_field (mul_one_class (has_nnnorm (has_nnnorm reducibility_hints))))) : rank_condition (normed_field (mul_one_class (has_nnnorm (has_nnnorm reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_141662 (h0 : functor.add_const (add_monoid (has_neg_part name)) (semigroup environment.implicit_infer_kind)) : @add_monoid.fg.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_neg_part.{0} name)) (semigroup.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_141663 (h0 : ring (ordered_comm_ring (has_Inf Type))) : strong_rank_condition (ordered_comm_ring (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_141664 (h0 : functor.add_const (topological_space (has_add pos)) environment.implicit_infer_kind) : @topological_space.separable_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_141665 (h0 : topological_space (has_nndist (has_add linarith.comp))) : sequential_space (has_nndist (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_141666 (h0 : functor.add_const (cancel_comm_monoid_with_zero (mul_zero_class unsigned)) num) : @unique_factorization_monoid.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (mul_zero_class.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_141667 (h0 : topological_space (linear_ordered_field (option (option unsigned)))) : irreducible_space (linear_ordered_field (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_141668 (h0 : topological_space (distrib (random_gen (has_nnnorm fun_info)))) : totally_disconnected_space (distrib (random_gen (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_141669 (h0 : function.extfun Type (functor.add_const (list (normed_linear_ordered_group unsigned)))) : palindrome (functor.add_const.run (function.extfun_app h0 unsigned)) := sorry --non-trivial
lemma new_lemma_141670 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} string_imp (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) string_imp)  := sorry --non-trivial
lemma new_lemma_141671 (h0 : topological_space (has_Inf (has_pos_part pos))) : discrete_topology (has_Inf (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_141672 (h0 : functor.add_const (add_group (simple_graph name)) Type) : @is_add_cyclic.{0} (simple_graph.{0} name) (@functor.add_const.run.{0 1} (add_group.{0} (simple_graph.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_141673 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_141674 (h0 : function.extfun (finset Type) (has_mem.mem (with_one fun_info))) : @normal_space.{0} (with_one.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_141675 (h0 : topological_space (finset (sub_neg_monoid Type))) : totally_separated_space (finset (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_141676 (h0 : functor.add_const (function.extfun Type ring) (has_neg linarith.comp)) : @rank_condition.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (has_neg.{0} linarith.comp) h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_141677 (h0 : finset (add_comm_monoid (option pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_141678 (h0 : group (has_inv (has_top to_additive.value_type))) : is_cyclic (has_inv (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_141679 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) linarith.comp) : @regular_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_141680 (h1 : topological_space (semi_normed_comm_ring string_imp)) : t0_space (semi_normed_comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_141681 (h1 : complete_lattice (has_add char)) : complete_lattice.is_Sup_finite_compact (has_add char) := sorry --non-trivial
lemma new_lemma_141682 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_141683 (h0 : ring (measurable_space.dynkin_system (semiring unsigned))) : strong_rank_condition (measurable_space.dynkin_system (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_141684 (h0 : function.extfun Type group) : @is_cyclic.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_141685 (h0 : fin has_zero.zero) : @separated_space.{0} (comm_semigroup.{0} linarith.comp) (@matrix.vec_empty.{0} (uniform_space.{0} (comm_semigroup.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_141686 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (canonically_ordered_comm_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (canonically_ordered_comm_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_141687 (h0 : topological_space (random_gen linarith.ineq)) (h1 : preorder (random_gen linarith.ineq)) : order_closed_topology (random_gen linarith.ineq) := sorry --non-trivial
lemma new_lemma_141688 (h0 : topological_space (distrib (has_ssubset (has_ssubset (has_inv linarith.ineq))))) : path_connected_space (distrib (has_ssubset (has_ssubset (has_inv linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_141689 (h0 : uniform_space (has_add (option ennreal))) : separated_space (has_add (option ennreal)) := sorry --non-trivial
lemma new_lemma_141690 (h0 : topological_space (complete_distrib_lattice (has_add linarith.comp))) : discrete_topology (complete_distrib_lattice (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_141691 (h0 : functor.add_const (function.extfun (Type 1) monoid) name) : @monoid.fg.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) monoid.{1}) name h0) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_141692 (h0 : complete_lattice (complete_linear_order empty)) : complete_lattice.is_Sup_finite_compact (complete_linear_order empty) := sorry --non-trivial
lemma new_lemma_141693 (h0 : ring (add_cancel_monoid (comm_group name))) : is_principal_ideal_ring (add_cancel_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_141694 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_141695 (h0 : topological_space (normed_group (has_top linarith.ineq))) : totally_disconnected_space (normed_group (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_141696 (h0 : group (boolean_algebra (ring pos))) : is_simple_group (boolean_algebra (ring pos)) := sorry --non-trivial
lemma new_lemma_141697 (h0 : topological_space (comm_group pos)) : t1_space (comm_group pos) := sorry --non-trivial
lemma new_lemma_141698 (h0 : add_monoid (linear_ordered_field empty)) : add_monoid.fg (linear_ordered_field empty) := sorry --non-trivial
lemma new_lemma_141699 (h0 : uniform_space (free_add_monoid (semiring empty))) : complete_space (free_add_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_141700 (h0 : topological_space (comm_ring (has_inv to_additive.value_type))) : t0_space (comm_ring (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_141701 (h0 : monoid (measurable_space (has_one linarith.comp))) : monoid.fg (measurable_space (has_one linarith.comp)) := sorry --non-trivial
lemma new_lemma_141702 (h0 : group (has_zero (finset (finset Type)))) : is_cyclic (has_zero (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_141703 (h1 : not (complete_lattice (non_unital_non_assoc_semiring linarith.ineq) -> false)) : @is_compactly_generated.{0} (non_unital_non_assoc_semiring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (non_unital_non_assoc_semiring.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_141704 (h0 : function.extfun Type topological_space) : @t1_space.{0} (semigroup.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_141705 (h0 : topological_space (preorder num)) : t0_space (preorder num) := sorry --non-trivial
lemma new_lemma_141706 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} h0 (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_141707 (h0 : functor.add_const (semiring (partial_order num)) empty) : @is_noetherian_ring.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (semiring.{0} (partial_order.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_141708 (h0 : not (complete_lattice (with_one to_additive.value_type) -> false)) : @is_atomistic.{0} (with_one.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_one.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_141709 (h0 : group (boolean_algebra (has_add unsigned))) : is_cyclic (boolean_algebra (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_141710 (h0 : ring (finset ennreal)) : is_principal_ideal_ring (finset ennreal) := sorry --non-trivial
lemma new_lemma_141711 (h0 : monoid (cancel_monoid (add_cancel_monoid ennreal))) : monoid.fg (cancel_monoid (add_cancel_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_141712 (h0 : functor.add_const (topological_space (has_star num)) empty) : @normal_space.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_141713 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) linarith.comp) : @sequential_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_141714 (h0 : ring (normed_comm_ring (has_add (has_add linarith.comp)))) : strong_rank_condition (normed_comm_ring (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_141715 (h0 : topological_space (has_neg_part (comm_group (has_add name)))) : topological_space.separable_space (has_neg_part (comm_group (has_add name))) := sorry --non-trivial
lemma new_lemma_141716 (h0 : add_group (generalized_boolean_algebra (has_neg (has_neg name)))) : is_add_cyclic (generalized_boolean_algebra (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_141717 (h0 : functor.add_const (function.extfun Type uniform_space) name) : @separated_space.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) name h0) (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_141718 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_141719 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_141720 (h0 : functor.add_const (ring (has_nndist environment.implicit_infer_kind)) name) : @is_domain.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_141721 (h0 : ring (has_ssubset (has_ssubset (has_ssubset linarith.comp_source)))) : strong_rank_condition (has_ssubset (has_ssubset (has_ssubset linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_141722 (h0 : functor.add_const (ring (has_to_string environment.implicit_infer_kind)) Type) : @strong_rank_condition.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ring.{0} (has_to_string.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_141723 (h0 : ordered_add_comm_monoid (pseudo_metric_space Type)) : archimedean (pseudo_metric_space Type) := sorry --non-trivial
lemma new_lemma_141724 (h0 : topological_space (finset (has_zero linarith.comp))) : t0_space (finset (has_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_141725 (h0 : Prop) (h1 : ulower (ulower (list (list Prop)))) : list.ilast' h0 (list.head (ulower.up (ulower.up h1))) := sorry --non-trivial
lemma new_lemma_141726 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_141727 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_141728 (h1 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_141729 (h0 : not (complete_lattice (has_top fun_info) -> false)) : @is_compactly_generated.{0} (has_top.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_top.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_141730 (h0 : add_group (has_compl environment.projection_info)) : is_add_cyclic (has_compl environment.projection_info) := sorry --non-trivial
lemma new_lemma_141731 (h0 : topological_space (mul_zero_class (option pos))) : regular_space (mul_zero_class (option pos)) := sorry --non-trivial
lemma new_lemma_141732 (h1 : ring (random_gen (fintype linarith.comp_source))) : is_domain (random_gen (fintype linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_141733 (h0 : not (add_group (non_assoc_semiring num) -> false)) : @is_add_cyclic.{0} (non_assoc_semiring.{0} num) (@classical.by_contradiction'.{1} (add_group.{0} (non_assoc_semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_141734 (h0 : functor.add_const (list (boolean_algebra.core unsigned)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_141735 (h0 : not (has_mem.mem topological_space has_emptyc.emptyc -> false)) : @t0_space.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0} (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type)))) h0)) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_141736 (h0 : filter (has_add (has_add (has_to_string pos)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_141737 (h0 : function.extfun Type ring) : @rank_condition.{0} (monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_141738 (h0 : not (topological_space (metric_space empty) -> false)) : @totally_disconnected_space.{0} (metric_space.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (metric_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_141739 (h0 : ring (mul_one_class (mul_one_class (mul_one_class ereal)))) : strong_rank_condition (mul_one_class (mul_one_class (mul_one_class ereal))) := sorry --non-trivial
lemma new_lemma_141740 (h0 : group (cancel_monoid (has_neg_part (add_comm_monoid environment.implicit_infer_kind)))) : is_simple_group (cancel_monoid (has_neg_part (add_comm_monoid environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_141741 (h0 : functor.add_const (topological_space (bin_tree num)) num) : @discrete_topology.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_141742 (h0 : functor.add_const (topological_space (semigroup (has_add linarith.comp))) Type) : @preconnected_space.{0} (semigroup.{0} (has_add.{0} linarith.comp)) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} (has_add.{0} linarith.comp))) Type h0)  := sorry --non-trivial
lemma new_lemma_141743 (h0 : cancel_comm_monoid_with_zero (complete_semilattice_Sup unsigned)) : unique_factorization_monoid (complete_semilattice_Sup unsigned) := sorry --non-trivial
lemma new_lemma_141744 (h0 : finset (has_nndist environment.implicit_infer_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_141745 (h0 : function.extfun (Type 1) filter) : countable_Inter_filter (function.extfun_app h0 Type) := sorry --non-trivial
lemma new_lemma_141746 (h0 : ring (add_cancel_monoid (has_neg Type))) : strong_rank_condition (add_cancel_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_141747 (h0 : list (normed_comm_ring (boolean_algebra unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_141748 (h0 : functor.add_const (topological_space (ring name)) linarith.comp) : @locally_compact_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_141749 (h0 : ordered_comm_monoid (has_neg (finset (finset pos)))) : has_exists_mul_of_le (has_neg (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_141750 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (canonically_ordered_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_141751 (h0 : functor.add_const (topological_space (pseudo_metric_space pos)) pos) : @totally_separated_space.{0} (pseudo_metric_space.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_141752 (h0 : functor.add_const (ring (normed_linear_ordered_group congr_arg_kind)) (option (option (option (option unsigned))))) : @rank_condition.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (normed_linear_ordered_group.{0} congr_arg_kind)) (option.{0} (option.{0} (option.{0} (option.{0} unsigned)))) h0)  := sorry --non-trivial
lemma new_lemma_141753 (h0 : add_group (distrib (has_nnnorm (comm_ring linarith.ineq)))) : is_add_cyclic (distrib (has_nnnorm (comm_ring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_141754 (h0 : topological_space (measurable_space num)) : normal_space (measurable_space num) := sorry --non-trivial
lemma new_lemma_141755 (h0 : ring (add_left_cancel_monoid (has_inv fun_info))) : is_domain (add_left_cancel_monoid (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_141756 (h0 : topological_space (linear_ordered_semiring (has_top fun_info))) : discrete_topology (linear_ordered_semiring (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_141757 (h0 : functor.add_const (topological_space (has_add Type)) Type) : @sequential_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_add.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_141758 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_141759 (h0 : topological_space (canonically_ordered_monoid (has_Inf pos))) : regular_space (canonically_ordered_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_141760 (h0 : fin has_zero.zero) : @irreducible_space.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_141761 (h0 : ring (uniform_space (has_nnnorm reducibility_hints))) : strong_rank_condition (uniform_space (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_141762 (h0 : topological_space (finset (has_Inf linarith.comp))) : sequential_space (finset (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_141763 (h0 : complete_lattice (semiring (has_top congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (semiring (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_141764 (h2 : set fun_info) : set.finite h2 := sorry --non-trivial
lemma new_lemma_141765 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_141766 (h0 : group (cancel_monoid congr_arg_kind)) : is_cyclic (cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_141767 (h0 : cancel_comm_monoid_with_zero (complete_distrib_lattice (option unsigned))) : unique_factorization_monoid (complete_distrib_lattice (option unsigned)) := sorry --non-trivial
lemma new_lemma_141768 (h0 : functor.add_const (topological_space (has_to_string Type)) linarith.comp) : @discrete_topology.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_to_string.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_141769 (h0 : topological_space (has_one (has_top congr_arg_kind))) : normal_space (has_one (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_141770 (h0 : functor.add_const (topological_space Type) (ordered_ring (has_Inf linarith.comp))) : @preirreducible_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) (ordered_ring.{0} (has_Inf.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_141771 (h0 : topological_space (has_pos_part pos)) : locally_compact_space (has_pos_part pos) := sorry --non-trivial
lemma new_lemma_141772 (h0 : topological_space (ring (boolean_algebra pos))) : topological_space.separable_space (ring (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_141773 (h0 : group (dlist (random_gen linarith.ineq))) : group.fg (dlist (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_141774 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (comm_monoid.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (comm_monoid.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_141775 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_141776 (h0 : function.extfun Type ring) : @is_domain.{0} (has_sub.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_sub.{0} num))  := sorry --non-trivial
lemma new_lemma_141777 (h0 : topological_space (add_cancel_monoid (has_to_string (has_neg_part name)))) : totally_disconnected_space (add_cancel_monoid (has_to_string (has_neg_part name))) := sorry --non-trivial
lemma new_lemma_141778 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @t1_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_141779 (h0 : complete_lattice (linear_ordered_cancel_comm_monoid unsigned)) : is_compactly_generated (linear_ordered_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_141780 (h0 : topological_space (canonically_ordered_monoid unsigned)) : discrete_topology (canonically_ordered_monoid unsigned) := sorry --non-trivial
lemma new_lemma_141781 (h0 : topological_space (has_lt (mul_one_class enat))) : path_connected_space (has_lt (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_141782 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_141783 (h0 : ordered_comm_monoid (generalized_boolean_algebra (ordered_ring (has_Inf linarith.comp)))) : has_exists_mul_of_le (generalized_boolean_algebra (ordered_ring (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_141784 (h0 : functor.add_const (uniform_space (mul_zero_class unsigned)) (finset name)) : @complete_space.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (mul_zero_class.{0} unsigned)) (finset.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_141785 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) environment.implicit_infer_kind) : @preirreducible_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_141786 (h0 : functor.add_const Prop (complete_distrib_lattice linarith.comp)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_141787 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (mul_zero_class.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (mul_zero_class.{0} empty))  := sorry --non-trivial
lemma new_lemma_141788 (h0 : functor.add_const (function.extfun Type semiring) Type) : @is_noetherian_ring.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type semiring.{0}) Type h0) (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_141789 (h0 : group (nondiscrete_normed_field environment.projection_info) -> Prop) (h1 : Exists (fun (x : group (nondiscrete_normed_field environment.projection_info)), h0 x)) : @group.fg.{0} (nondiscrete_normed_field.{0} environment.projection_info) (@classical.some.{1} (group.{0} (nondiscrete_normed_field.{0} environment.projection_info)) h0 h1)  := sorry --non-trivial
lemma new_lemma_141790 (h0 : list (has_to_string (ring (has_add pos)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_141791 (h0 : not (ring (with_zero to_additive.value_type) -> false)) : @strong_rank_condition.{0} (with_zero.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (with_zero.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_141792 (h0 : cancel_comm_monoid_with_zero (has_to_string unsigned)) : unique_factorization_monoid (has_to_string unsigned) := sorry --non-trivial
lemma new_lemma_141793 (h0 : function.extfun Type group) : @normalizer_condition.{0} (non_assoc_semiring.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (non_assoc_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_141794 (h0 : functor.add_const (finset (measure_theory.measure_space num)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_141795 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) pos) : @totally_disconnected_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_141796 (h0 : topological_space (random_gen (semiring num))) : totally_separated_space (random_gen (semiring num)) := sorry --non-trivial
lemma new_lemma_141797 (h0 : topological_space (random_gen (mul_one_class reducibility_hints))) : path_connected_space (random_gen (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_141798 (h0 : topological_space (has_neg_part (add_comm_monoid pos))) : preirreducible_space (has_neg_part (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_141799 (h0 : functor.add_const (topological_space (normed_comm_ring name)) pos) : @totally_separated_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_141800 (h0 : functor.add_const (add_group (has_neg_part Type)) environment.implicit_infer_kind) : @is_add_cyclic.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (has_neg_part.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_141801 (h0 : pos -> pos -> Prop) : is_extensional pos h0 := sorry --non-trivial
lemma new_lemma_141802 (h0 : topological_space (normed_comm_ring (comm_group unsigned))) : preirreducible_space (normed_comm_ring (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_141803 (h0 : function.extfun (Type 1) topological_space) : @totally_separated_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_141804 (h0 : functor.add_const (topological_space (has_Inf pos)) linarith.comp) : @locally_compact_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_141805 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} to_additive.value_type (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_141806 (h0 : ring (topological_space (has_nnnorm (has_nnnorm linarith.ineq)))) : rank_condition (topological_space (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_141807 (h0 : semiring (semiring num) -> semiring (semiring num) -> Prop) : is_strict_order (semiring (semiring num)) h0 := sorry --non-trivial
lemma new_lemma_141808 (h0 : function.extfun Type group) : @normalizer_condition.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_141809 (h0 : functor.add_const (topological_space (has_star empty)) num) : @loc_path_connected_space.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_141810 (h0 : functor.add_const (topological_space (sub_neg_monoid Type)) name) : @regular_space.{1} (sub_neg_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (sub_neg_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_141811 (h0 : functor.add_const (uniform_space (has_to_string environment.implicit_infer_kind)) unsigned) : @separated_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_141812 (h0 : set (non_unital_non_assoc_semiring (mul_one_class string.iterator_imp))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_141813 (h0 : functor.add_const (topological_space (has_add linarith.comp)) (finset (ring (ordered_ring name)))) : @regular_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) (finset.{0} (ring.{0} (ordered_ring.{0} name))) h0)  := sorry --non-trivial
lemma new_lemma_141814 (h0 : functor.add_const (add_monoid (left_cancel_monoid num)) (semiring num)) : @add_monoid.fg.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (add_monoid.{0} (left_cancel_monoid.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_141815 (h0 : functor.add_const (group (add_cancel_monoid pos)) pos) : @group.fg.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_141816 (h0 : topological_space (has_add (has_pos_part (has_pos_part linarith.comp)))) : totally_separated_space (has_add (has_pos_part (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_141817 (h0 : uniform_space (has_zero (finset (ring Type)))) : complete_space (has_zero (finset (ring Type))) := sorry --non-trivial
lemma new_lemma_141818 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_141819 (h0 : group (generalized_boolean_algebra pos)) : normalizer_condition (generalized_boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_141820 (h0 : add_monoid (ordered_comm_ring (ring (has_pos_part linarith.comp)))) : add_monoid.fg (ordered_comm_ring (ring (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_141821 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (dlist.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (dlist.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_141822 (h0 : add_group (semigroup name)) : is_add_cyclic (semigroup name) := sorry --non-trivial
lemma new_lemma_141823 (h0 : fin has_zero.zero) : @group.fg.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (group.{0} (ordered_comm_ring.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_141824 (h0 : topological_space (option ennreal)) : path_connected_space (option ennreal) := sorry --non-trivial
lemma new_lemma_141825 (h0 : ring (boolean_algebra (ring environment.implicit_infer_kind))) : rank_condition (boolean_algebra (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_141826 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm empty))) : @irreducible_space.{0} (has_norm.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_141827 (h1 : semiring (add_comm_semigroup enat)) (h2 : ideal (add_comm_semigroup enat)) : ideal.is_prime h2 := sorry --non-trivial
lemma new_lemma_141828 (h0 : complete_lattice (comm_ring linarith.comp_source)) : complete_lattice.is_Sup_finite_compact (comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_141829 (h0 : monoid (has_neg_part ennreal)) : monoid.fg (has_neg_part ennreal) := sorry --non-trivial
lemma new_lemma_141830 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (measurable_space.{0} (has_norm.{0} (semiring.{0} (has_norm.{0} empty)))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} (has_norm.{0} (semiring.{0} (has_norm.{0} empty)))))  := sorry --non-trivial
lemma new_lemma_141831 (h0 : topological_space (has_Inf (ring (has_Inf (has_Inf (has_add name)))))) : totally_disconnected_space (has_Inf (ring (has_Inf (has_Inf (has_add name))))) := sorry --non-trivial
lemma new_lemma_141832 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (left_cancel_monoid.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} num))))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_monoid.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} num))))))  := sorry --non-trivial
lemma new_lemma_141833 (h0 : has_mem.mem (complete_semilattice_Sup linarith.comp_source) has_emptyc.emptyc) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type add_group.{0} (complete_semilattice_Sup.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_141834 (h1 : has_mem.mem linarith.comp_source has_emptyc.emptyc) : @strong_rank_condition.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type ring.{0} linarith.comp_source h1)  := sorry --non-trivial
lemma new_lemma_141835 (h0 : function.extfun Type (functor.add_const (prod (free_add_monoid empty) (free_add_monoid empty)))) : id_rel (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_141836 (h0 : ring (add_right_cancel_monoid num)) : rank_condition (add_right_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_141837 (h0 : list (add_cancel_monoid Type)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_141838 (h0 : topological_space (sub_neg_monoid (has_Inf Type))) : irreducible_space (sub_neg_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_141839 (h0 : topological_space (normed_comm_ring (finset linarith.comp))) : regular_space (normed_comm_ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_141840 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type monoid.{0} h0 (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_141841 (h0 : functor.add_const (topological_space (has_add linarith.comp)) pos) : @preirreducible_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_141842 (h0 : prod (has_zero name) (has_zero name)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_141843 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_141844 (h0 : add_group (add_group (has_norm linarith.comp))) : is_add_cyclic (add_group (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_141845 (h0 : functor.add_const (list (add_cancel_monoid name)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_141846 (h0 : group (has_inv (random_gen (random_gen (random_gen (random_gen to_additive.value_type)))))) : is_cyclic (has_inv (random_gen (random_gen (random_gen (random_gen to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_141847 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_141848 (h0 : not (has_mem.mem (random_gen linarith.comp_source) has_emptyc.emptyc -> false)) : @strong_rank_condition.{0} (random_gen.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (random_gen.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_141849 (h0 : not (has_mem.mem (random_gen linarith.comp_source) has_emptyc.emptyc -> false)) : @irreducible_space.{0} (random_gen.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_141850 (h0 : ring (comm_ring (has_compl char))) : strong_rank_condition (comm_ring (has_compl char)) := sorry --non-trivial
lemma new_lemma_141851 (h0 : ordered_add_comm_monoid (has_Sup unsigned)) : archimedean (has_Sup unsigned) := sorry --non-trivial
lemma new_lemma_141852 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_141853 (h1 : measurable_space (has_ssubset ereal)) (h2 : filter (has_ssubset ereal)) : filter.is_measurably_generated h2 := sorry --non-trivial
lemma new_lemma_141854 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_141855 (h0 : ring (has_star (semiring unsigned))) : is_principal_ideal_ring (has_star (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_141856 (h0 : not (add_group (with_bot unsigned) -> false)) : @is_add_cyclic.{0} (with_bot.{0} unsigned) (@classical.by_contradiction'.{1} (add_group.{0} (with_bot.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_141857 (h0 : function.extfun nat fin) : @complete_space.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (simple_graph.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_141858 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @discrete_topology.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_141859 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_neg.{0} (has_add.{0} pos)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} (has_add.{0} pos)))  := sorry --non-trivial
lemma new_lemma_141860 (h0 : ring (add_comm_semigroup (mul_one_class (mul_one_class ereal)))) : strong_rank_condition (add_comm_semigroup (mul_one_class (mul_one_class ereal))) := sorry --non-trivial
lemma new_lemma_141861 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 empty) := sorry --non-trivial
lemma new_lemma_141862 (h0 : group (measure_theory.measure_space (semiring unsigned))) : normalizer_condition (measure_theory.measure_space (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_141863 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) (finset Type)) : @totally_disconnected_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} pos)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_141864 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_141865 (h0 : monoid (has_norm linarith.comp)) : monoid.fg (has_norm linarith.comp) := sorry --non-trivial
lemma new_lemma_141866 (h0 : complete_lattice (option num)) : is_atomistic (option num) := sorry --non-trivial
lemma new_lemma_141867 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_141868 (h0 : not (topological_space (has_emptyc linarith.comp) -> false)) : @path_connected_space.{0} (has_emptyc.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_141869 (h1 : uniform_space (topological_space char)) : complete_space (topological_space char) := sorry --non-trivial
lemma new_lemma_141870 (h0 : add_monoid (ring (option (option unsigned)))) : add_monoid.fg (ring (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_141871 (h0 : topological_space (normed_lattice_add_comm_group (finset (has_add (has_add pos))))) : preconnected_space (normed_lattice_add_comm_group (finset (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_141872 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_141873 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} linarith.comp (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 linarith.comp)  := sorry --non-trivial
lemma new_lemma_141874 (h0 : group (has_top (random_gen (has_top (random_gen to_additive.value_type))))) : normalizer_condition (has_top (random_gen (has_top (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_141875 (h0 : ring (has_inter (option (option unsigned)))) : is_principal_ideal_ring (has_inter (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_141876 (h0 : complete_lattice (measurable_space linarith.ineq)) : complete_lattice.is_Sup_finite_compact (measurable_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_141877 (h0 : topological_space (random_gen congr_arg_kind)) : normal_space (random_gen congr_arg_kind) := sorry --non-trivial
lemma new_lemma_141878 (h0 : functor.add_const (list (finset name)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_141879 (h0 : topological_space (mul_zero_class (boolean_algebra.core (finset pos)))) : normal_space (mul_zero_class (boolean_algebra.core (finset pos))) := sorry --non-trivial
lemma new_lemma_141880 (h0 : string_imp -> encodable string_imp -> string_imp) : right_commutative h0 := sorry --non-trivial
lemma new_lemma_141881 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_141882 (h0 : functor.add_const (list (add_comm_monoid linarith.comp)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_141883 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) linarith.comp) : @path_connected_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_141884 (h0 : topological_space (complete_distrib_lattice ennreal)) : t1_space (complete_distrib_lattice ennreal) := sorry --non-trivial
lemma new_lemma_141885 (h1 : ring (has_top (has_nnnorm (has_nnnorm char)))) : is_domain (has_top (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_141886 (h0 : semiring (nondiscrete_normed_field linarith.ineq)) (h1 : ideal (nondiscrete_normed_field linarith.ineq)) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_141887 (h0 : topological_space (normed_linear_ordered_group num)) : loc_path_connected_space (normed_linear_ordered_group num) := sorry --non-trivial
lemma new_lemma_141888 (h0 : group (has_edist (option (semiring empty)))) : normalizer_condition (has_edist (option (semiring empty))) := sorry --non-trivial
lemma new_lemma_141889 (h0 : functor.add_const (list (ordered_comm_ring linarith.comp)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_141890 (h0 : functor.add_const (add_group (mul_zero_class name)) Type) : @is_add_cyclic.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 1} (add_group.{0} (mul_zero_class.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_141891 (h0 : cancel_comm_monoid_with_zero (has_to_string (finset (has_Inf Type)))) : unique_factorization_monoid (has_to_string (finset (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_141892 (h0 : ordered_add_comm_monoid (has_bot empty)) : archimedean (has_bot empty) := sorry --non-trivial
lemma new_lemma_141893 (h1 : complete_lattice (comm_ring string_imp)) : complete_lattice.is_Sup_finite_compact (comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_141894 (h0 : function.extfun Type (functor.add_const (uniform_space ennreal))) : @separated_space.{0} ennreal (@functor.add_const.run.{0 0} (uniform_space.{0} ennreal) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} ennreal)) h0 pos))  := sorry --non-trivial
lemma new_lemma_141895 (h0 : ordered_add_comm_monoid (has_inter (option (option (option ennreal))))) : archimedean (has_inter (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_141896 (h0 : functor.add_const (topological_space (has_dist empty)) unsigned) : @normal_space.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_141897 (h0 : finset (has_Inf (has_add (has_add (has_add name))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_141898 (h0 : ring (linear_ordered_add_comm_group_with_top std_gen)) : is_domain (linear_ordered_add_comm_group_with_top std_gen) := sorry --non-trivial
lemma new_lemma_141899 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_141900 (h0 : group (finset (comm_group (comm_group (semigroup name))))) : normalizer_condition (finset (comm_group (comm_group (semigroup name)))) := sorry --non-trivial
lemma new_lemma_141901 (h0 : complete_lattice (plift (semiring congr_arg_kind))) : is_compactly_generated (plift (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_141902 (h0 : functor.add_const (add_monoid (comm_group environment.implicit_infer_kind)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (comm_group.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_141903 (h0 : uniform_space (has_lt to_additive.value_type)) : complete_space (has_lt to_additive.value_type) := sorry --non-trivial
lemma new_lemma_141904 (h0 : topological_space (normed_lattice_add_comm_group Type)) : loc_path_connected_space (normed_lattice_add_comm_group Type) := sorry --non-trivial
lemma new_lemma_141905 (h0 : fin has_zero.zero) : @is_compactly_generated.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (generalized_boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_141906 (h0 : functor.add_const (ring znum) empty) : @strong_rank_condition.{0} znum (@functor.add_const.run.{0 0} (ring.{0} znum) empty h0)  := sorry --non-trivial
lemma new_lemma_141907 (h0 : set (add_comm_semigroup (add_comm_semigroup (mul_one_class environment.projection_info)) -> linarith.ineq)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_141908 (h0 : functor.add_const (topological_space pos) (finset pos)) : @irreducible_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_141909 (h0 : pnat) (h1 : ulower (ulower pnat)) : pnat.coprime h0 (ulower.up (ulower.up h1)) := sorry --non-trivial
lemma new_lemma_141910 (h0 : functor.add_const (group znum) empty) : @normalizer_condition.{0} znum (@functor.add_const.run.{0 0} (group.{0} znum) empty h0)  := sorry --non-trivial
lemma new_lemma_141911 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring empty))) : @is_add_cyclic.{0} (linear_ordered_semiring.{0} empty) (@finset.pi.empty.{1 0} Type add_group.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_141912 (h0 : finset (boolean_algebra (has_to_string unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_141913 (h0 : ring (simple_graph char)) : is_domain (simple_graph char) := sorry --non-trivial
lemma new_lemma_141914 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_141915 (h0 : pseudo_metric_space (mul_one_class linarith.ineq)) (h1 : set (mul_one_class linarith.ineq)) : metric.bounded h1 := sorry --non-trivial
lemma new_lemma_141916 (h0 : functor.add_const Prop (linear_ordered_comm_group ennreal)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_141917 (h0 : functor.add_const (uniform_space (linear_ordered_comm_ring empty)) (semiring (semiring num))) : @complete_space.{0} (linear_ordered_comm_ring.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (linear_ordered_comm_ring.{0} empty)) (semiring.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_141918 (h0 : has_neg string.iterator_imp) (h4 : measurable_space string.iterator_imp) : has_measurable_neg string.iterator_imp := sorry --non-trivial
lemma new_lemma_141919 (h0 : topological_space (distrib fun_info)) : t0_space (distrib fun_info) := sorry --non-trivial
lemma new_lemma_141920 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_141921 (h0 : complete_lattice (has_lt (distrib string.iterator_imp))) : is_compactly_generated (has_lt (distrib string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_141922 (h0 : topological_space (comm_semigroup Type)) : loc_path_connected_space (comm_semigroup Type) := sorry --non-trivial
lemma new_lemma_141923 (h0 : topological_space (dlist (distrib_lattice (dlist to_additive.value_type)))) : t0_space (dlist (distrib_lattice (dlist to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_141924 (h0 : monoid (boolean_algebra.core (semigroup Type))) : monoid.fg (boolean_algebra.core (semigroup Type)) := sorry --non-trivial
lemma new_lemma_141925 (h0 : topological_space (comm_group Type)) : loc_path_connected_space (comm_group Type) := sorry --non-trivial
lemma new_lemma_141926 (h0 : has_mem.mem (has_emptyc to_additive.value_type) has_emptyc.emptyc) : @totally_separated_space.{0} (has_emptyc.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_141927 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_141928 (h0 : topological_space (canonically_linear_ordered_monoid (finset (has_Inf Type)))) : topological_space.separable_space (canonically_linear_ordered_monoid (finset (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_141929 (h0 : topological_space (mul_zero_class (normed_comm_ring pos))) : path_connected_space (mul_zero_class (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_141930 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (group_with_zero congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_141931 (h0 : functor.add_const (group (boolean_algebra pos)) pos) : @group.fg.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_141932 (h0 : not (complete_lattice (measure_theory.measure_space num) -> false)) : @is_compactly_generated.{0} (measure_theory.measure_space.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (measure_theory.measure_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_141933 (h5 : topological_space (normed_field (has_nnnorm char))) : totally_disconnected_space (normed_field (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_141934 (h0 : functor.add_const (topological_space (has_add name)) (has_neg linarith.comp)) : @regular_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_141935 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_141936 (h0 : topological_space (with_bot (semiring (semiring (semiring unsigned))))) : totally_disconnected_space (with_bot (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_141937 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_add_comm_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_141938 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (complete_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (complete_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_141939 (h0 : functor.add_const (function.extfun Type group) Type) : @is_cyclic.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_141940 (h0 : group (linear_ordered_add_comm_group (has_top fun_info))) : is_cyclic (linear_ordered_add_comm_group (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_141941 (h0 : group (semiring (has_norm (has_norm empty)))) : group.fg (semiring (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_141942 (h0 : topological_space (filter congr_arg_kind)) : path_connected_space (filter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_141943 (h0 : topological_space (random_gen (has_nnnorm fun_info))) : totally_disconnected_space (random_gen (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_141944 (h0 : functor.add_const (topological_space (ring Type)) linarith.comp) : @regular_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_141945 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (comm_monoid.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (comm_monoid.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_141946 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_141947 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} unsigned (@function.extfun_app.{2 1} Type topological_space.{0} h0 unsigned)  := sorry --non-trivial
lemma new_lemma_141948 (h0 : topological_space (pseudo_metric_space (linear_ordered_field pos))) : t1_space (pseudo_metric_space (linear_ordered_field pos)) := sorry --non-trivial
lemma new_lemma_141949 (h0 : functor.add_const (topological_space (has_neg_part pos)) linarith.comp) : @path_connected_space.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_141950 (h0 : topological_space (comm_ring (random_gen (random_gen char)))) : path_connected_space (comm_ring (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_141951 (h0 : group (semi_normed_comm_ring (has_nnnorm (has_nnnorm linarith.comp_source)))) : is_cyclic (semi_normed_comm_ring (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_141952 (h0 : functor.add_const (semiring (add_group congr_arg_kind)) congr_arg_kind) : @is_noetherian_ring.{0} (add_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (semiring.{0} (add_group.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_141953 (h0 : function.extfun Type (functor.comp list finset)) : palindrome (functor.comp.run (function.extfun_app h0 pos)) := sorry --non-trivial
lemma new_lemma_141954 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (preorder congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_141955 (h0 : filter (has_top (random_gen linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_141956 (h0 : functor.add_const (finset (ring linarith.comp)) (has_add pos)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_141957 (h0 : group (semiring (has_top (has_top linarith.comp_source)))) : normalizer_condition (semiring (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_141958 (h0 : function.extfun Type ring) : @rank_condition.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_141959 (h0 : functor.add_const (group (has_Inf Type)) linarith.comp) : @normalizer_condition.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_Inf.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_141960 (h0 : complete_lattice (has_nnnorm (mul_one_class (mul_one_class string.iterator_imp)))) : is_compactly_generated (has_nnnorm (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_141961 (h0 : add_group (encodable (random_gen fun_info))) : is_add_cyclic (encodable (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_141962 (h0 : topological_space (has_bot pos)) : t1_space (has_bot pos) := sorry --non-trivial
lemma new_lemma_141963 (h2 : not (group (normed_field char) -> false)) : @is_cyclic.{0} (normed_field.{0} char) (@classical.by_contradiction'.{1} (group.{0} (normed_field.{0} char)) h2)  := sorry --non-trivial
lemma new_lemma_141964 (h0 : complete_lattice (semigroup (semiring empty))) : is_compactly_generated (semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_141965 (h0 : ring (add_left_cancel_semigroup empty)) : strong_rank_condition (add_left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_141966 (h0 : topological_space (mul_one_class fun_info)) (h1 : set (mul_one_class fun_info)) : is_closed h1 := sorry --non-trivial
lemma new_lemma_141967 (h1 : list (normed_group (random_gen to_additive.value_type))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_141968 (h1 : not (uniform_space (linear_ordered_comm_group_with_zero string_imp) -> false)) : @complete_space.{0} (linear_ordered_comm_group_with_zero.{0} string_imp) (@classical.by_contradiction'.{1} (uniform_space.{0} (linear_ordered_comm_group_with_zero.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_141969 (h0 : function.extfun Type (functor.add_const (semiring (semigroup congr_arg_kind)))) : @is_noetherian_ring.{0} (semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (semiring.{0} (semigroup.{0} congr_arg_kind)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (semiring.{0} (semigroup.{0} congr_arg_kind))) h0 num))  := sorry --non-trivial
lemma new_lemma_141970 (h0 : ring (semiring (semiring unsigned))) : strong_rank_condition (semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_141971 (h0 : group (add_cancel_monoid num)) : is_cyclic (add_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_141972 (h0 : list (has_to_string (has_add (has_add linarith.comp)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_141973 (h0 : function.extfun nat fin) : @is_compactly_generated.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@matrix.vec_empty.{0} (complete_lattice.{0} (normed_lattice_add_comm_group.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_141974 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} fun_info)))))) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} fun_info)))))))  := sorry --non-trivial
lemma new_lemma_141975 (h0 : functor.add_const (topological_space (has_nndist Type)) linarith.comp) : @discrete_topology.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_141976 (h0 : not (topological_space (has_emptyc empty) -> false)) : @totally_disconnected_space.{0} (has_emptyc.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_141977 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (encodable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (encodable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_141978 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space fun_info))) : @t0_space.{0} (measurable_space.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_141979 (h0 : complete_lattice (measurable_space.dynkin_system (semiring (semiring congr_arg_kind)))) : is_atomistic (measurable_space.dynkin_system (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_141980 (h0 : functor.add_const (filter (finset name)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_141981 (h0 : monoid (random_gen string_imp)) : monoid.fg (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_141982 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (canonically_linear_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (canonically_linear_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_141983 (h0 : group (boolean_algebra.core (add_cancel_monoid name))) : group.fg (boolean_algebra.core (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_141984 (h0 : topological_space (add_cancel_monoid (boolean_algebra.core linarith.comp))) : totally_separated_space (add_cancel_monoid (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_141985 (h0 : complete_lattice (finset (mul_zero_class pos))) : is_compactly_generated (finset (mul_zero_class pos)) := sorry --non-trivial
lemma new_lemma_141986 (h0 : topological_space (has_bot (has_pos_part (has_add real)))) : totally_separated_space (has_bot (has_pos_part (has_add real))) := sorry --non-trivial
lemma new_lemma_141987 (h0 : add_group (partial_order congr_arg_kind)) : is_add_cyclic (partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_141988 (h1 : topological_space (encodable string_imp)) : locally_compact_space (encodable string_imp) := sorry --non-trivial
lemma new_lemma_141989 (h0 : topological_space (has_zero (add_comm_monoid pos))) : irreducible_space (has_zero (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_141990 (h0 : group (random_gen empty)) : normalizer_condition (random_gen empty) := sorry --non-trivial
lemma new_lemma_141991 (h2 : topological_space (normed_field (random_gen char))) : path_connected_space (normed_field (random_gen char)) := sorry --non-trivial
lemma new_lemma_141992 (h0 : function.extfun (Type 1) ordered_add_comm_monoid) : @archimedean.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} h0 (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_141993 (h0 : functor.add_const (topological_space (add_group empty)) num) : @normal_space.{0} (add_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_141994 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} to_additive.value_type (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_141995 (h0 : group (has_neg_part (has_add name))) : group.fg (has_neg_part (has_add name)) := sorry --non-trivial
lemma new_lemma_141996 (h0 : functor.add_const (topological_space (finset Type)) pos) : @irreducible_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_141997 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc fun_info))) : @totally_separated_space.{0} (has_emptyc.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_141998 (h0 : not (ring (dlist to_additive.value_type) -> false)) : @rank_condition.{0} (dlist.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (dlist.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_141999 (h0 : topological_space (semiring (random_gen linarith.comp))) : irreducible_space (semiring (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_142000 (h0 : functor.add_const (topological_space (plift congr_arg_kind)) congr_arg_kind) : @t1_space.{1} (plift.{1} congr_arg_kind) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_142001 (h0 : group (has_zero (has_Inf (has_pos_part Type)))) : normalizer_condition (has_zero (has_Inf (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_142002 (h0 : topological_space (metric_space fun_info)) : path_connected_space (metric_space fun_info) := sorry --non-trivial
lemma new_lemma_142003 (h0 : ring (has_neg_part (add_comm_monoid Type))) : rank_condition (has_neg_part (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_142004 (h0 : boolean_algebra pos -> boolean_algebra pos -> boolean_algebra pos) : left_cancelative h0 := sorry --non-trivial
lemma new_lemma_142005 (h0 : topological_space (linear_ordered_semiring (has_norm (has_norm empty)))) : normal_space (linear_ordered_semiring (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_142006 (h0 : fin has_zero.zero) : @separated_space.{1} (add_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (add_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_142007 (h2 : add_monoid (add_comm_semigroup enat)) : add_monoid.fg (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_142008 (h0 : topological_space (with_bot (has_norm (has_norm empty)))) : irreducible_space (with_bot (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_142009 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_union.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_union.{0} empty))  := sorry --non-trivial
lemma new_lemma_142010 (h0 : topological_space empty) : t0_space empty := sorry --non-trivial
lemma new_lemma_142011 (h0 : ring (free_add_monoid (semiring (semiring (semiring (semiring unsigned)))))) : rank_condition (free_add_monoid (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_142012 (h0 : semiring (group_with_zero (option (option ennreal)))) : is_noetherian_ring (group_with_zero (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_142013 (h0 : functor.add_const (topological_space (has_zero pos)) linarith.comp) : @totally_disconnected_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_142014 (h0 : topological_space (complete_linear_order congr_arg_kind)) : t1_space (complete_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_142015 (h0 : ring (dlist (random_gen (random_gen (random_gen (random_gen (random_gen char))))))) : strong_rank_condition (dlist (random_gen (random_gen (random_gen (random_gen (random_gen char)))))) := sorry --non-trivial
lemma new_lemma_142016 (h0 : topological_space (add_comm_monoid (has_pos_part linarith.comp))) : t1_space (add_comm_monoid (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_142017 (h0 : add_group (cancel_monoid (option pos))) : is_add_cyclic (cancel_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_142018 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (ring Type)) : @path_connected_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) (ring.{1} Type) h0) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_142019 (h0 : ring (measurable_space unsigned)) : rank_condition (measurable_space unsigned) := sorry --non-trivial
lemma new_lemma_142020 (h0 : finset (has_nndist (metric_space (has_pos_part (has_pos_part Type))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_142021 (h0 : ring (has_Inf real)) : is_domain (has_Inf real) := sorry --non-trivial
lemma new_lemma_142022 (h0 : not (topological_space real.angle -> false)) : @totally_separated_space.{0} real.angle (@classical.by_contradiction'.{1} (topological_space.{0} real.angle) h0)  := sorry --non-trivial
lemma new_lemma_142023 (h0 : group (has_pos_part linarith.comp)) : normalizer_condition (has_pos_part linarith.comp) := sorry --non-trivial
lemma new_lemma_142024 (h0 : functor.add_const (function.extfun (Type 1) semiring) name) : @is_noetherian_ring.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) semiring.{1}) name h0) (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_142025 (h0 : finset (linear_ordered_comm_monoid_with_zero congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_142026 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (option.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_142027 (h0 : topological_space (add_group_with_zero_nhd num)) : totally_separated_space (add_group_with_zero_nhd num) := sorry --non-trivial
lemma new_lemma_142028 (h0 : functor.comp topological_space has_neg Type) : @irreducible_space.{1} (has_neg.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_neg.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_142029 (h0 : ordered_add_comm_monoid (has_neg (comm_group unsigned))) : archimedean (has_neg (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_142030 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_142031 (h0 : monoid (linear_ordered_semiring (has_norm (random_gen congr_arg_kind)))) : monoid.fg (linear_ordered_semiring (has_norm (random_gen congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_142032 (h0 : unit) (h1 : set (prod unit unit)) : @trace_call_stack.{0} Prop (@uniform_space.ball.{0} unit h0 h1)  := sorry --non-trivial
lemma new_lemma_142033 (h0 : topological_space (ring congr_arg_kind)) : t1_space (ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_142034 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_142035 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_142036 (h0 : group (has_top (has_norm fun_info))) : normalizer_condition (has_top (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_142037 (h0 : complete_lattice (is_R_or_C congr_arg_kind)) : is_atomistic (is_R_or_C congr_arg_kind) := sorry --non-trivial
lemma new_lemma_142038 (h0 : not (topological_space (has_compl char) -> false)) : @totally_disconnected_space.{0} (has_compl.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (has_compl.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_142039 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) Type) : @preconnected_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ordered_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_142040 (h0 : list (complete_distrib_lattice pos)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_142041 (h0 : functor.add_const (group (generalized_boolean_algebra pos)) linarith.comp) : @normalizer_condition.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (generalized_boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_142042 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_142043 (h0 : function.extfun Type group) : @is_cyclic.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_142044 (h0 : functor.add_const (topological_space (has_to_string name)) Type) : @irreducible_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_142045 (h0 : functor.add_const (ring (mul_zero_class empty)) empty) : @is_domain.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_142046 (h0 : finset (has_add (complete_distrib_lattice pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_142047 (h0 : mul_zero_class num -> mul_zero_class num -> Prop) : is_strict_order (mul_zero_class num) h0 := sorry --non-trivial
lemma new_lemma_142048 (h0 : functor.add_const (topological_space empty) empty) : t1_space empty := sorry --non-trivial
lemma new_lemma_142049 (h0 : semiring (has_pos_part real)) : is_noetherian_ring (has_pos_part real) := sorry --non-trivial
lemma new_lemma_142050 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_142051 (h0 : complete_lattice (has_star empty) -> Prop) (h1 : Exists (fun (x : complete_lattice (has_star empty)), h0 x)) : @is_atomistic.{0} (has_star.{0} empty) (@classical.some.{1} (complete_lattice.{0} (has_star.{0} empty)) h0 h1)  := sorry --non-trivial
lemma new_lemma_142052 (h0 : topological_space (dlist string_imp)) : locally_compact_space (dlist string_imp) := sorry --non-trivial
lemma new_lemma_142053 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_142054 (h0 : functor.add_const (function.extfun Type topological_space) (has_Inf Type)) : @path_connected_space.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (has_Inf.{1} Type) h0) (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_142055 (h0 : add_group (has_emptyc linarith.comp)) : is_add_cyclic (has_emptyc linarith.comp) := sorry --non-trivial
lemma new_lemma_142056 (h0 : topological_space (canonically_ordered_add_monoid (semiring empty))) : loc_path_connected_space (canonically_ordered_add_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_142057 (h0 : function.extfun (Type 1) add_group) : @is_add_cyclic.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} h0 (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_142058 (h0 : functor.add_const (topological_space (has_add pos)) (has_zero pos)) : @totally_disconnected_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) (has_zero.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_142059 (h1 : not (complete_lattice (measurable_space unsigned) -> false)) : is_compactly_generated (measurable_space unsigned) := sorry --non-trivial
lemma new_lemma_142060 (h0 : topological_space (comm_monoid congr_arg_kind)) : totally_disconnected_space (comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_142061 (h0 : function.extfun (Type 1) list) : palindrome (function.extfun_app h0 (canonically_ordered_comm_semiring Type)) := sorry --non-trivial
lemma new_lemma_142062 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} linarith.ineq (@function.extfun_app.{2 1} Type topological_space.{0} h0 linarith.ineq)  := sorry --non-trivial
lemma new_lemma_142063 (h0 : topological_space (boolean_algebra.core (has_neg_part Type))) : preirreducible_space (boolean_algebra.core (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_142064 (h0 : function.extfun Type (functor.add_const (filter environment.implicit_infer_kind))) : countable_Inter_filter (functor.add_const.run (function.extfun_app h0 name)) := sorry --non-trivial
lemma new_lemma_142065 (h0 : topological_space (has_norm (semiring congr_arg_kind))) : locally_compact_space (has_norm (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_142066 (h0 : semiring (add_group congr_arg_kind)) : is_noetherian_ring (add_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_142067 (h0 : topological_space (comm_group (comm_group (has_neg_part pos)))) : normal_space (comm_group (comm_group (has_neg_part pos))) := sorry --non-trivial
lemma new_lemma_142068 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_142069 (h0 : not (uniform_space (with_bot num) -> false)) : @separated_space.{0} (with_bot.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (with_bot.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_142070 (h0 : function.extfun nat fin) : @preirreducible_space.{0} (has_add.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} linarith.comp)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))))  := sorry --non-trivial
lemma new_lemma_142071 (h1 : set (mul_one_class (mul_one_class (add_comm_semigroup (add_comm_semigroup fun_info))) -> enat)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_142072 (h0 : complete_lattice (canonically_ordered_monoid (has_bot (has_add real)))) : is_compactly_generated (canonically_ordered_monoid (has_bot (has_add real))) := sorry --non-trivial
lemma new_lemma_142073 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space num))) : @totally_separated_space.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_142074 (h0 : topological_space (canonically_linear_ordered_monoid (option pos))) : topological_space.separable_space (canonically_linear_ordered_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_142075 (h0 : group (monoid_with_zero congr_arg_kind)) : is_simple_group (monoid_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_142076 (h0 : ring (has_pos_part Type)) : strong_rank_condition (has_pos_part Type) := sorry --non-trivial
lemma new_lemma_142077 (h0 : topological_space (boolean_algebra environment.implicit_infer_kind)) : normal_space (boolean_algebra environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_142078 (h0 : not (has_mem.mem (semiring num) has_emptyc.emptyc -> false)) : @strong_rank_condition.{0} (semiring.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_142079 (h0 : ring (has_neg (comm_group (comm_group pos)))) : is_domain (has_neg (comm_group (comm_group pos))) := sorry --non-trivial
lemma new_lemma_142080 (h0 : ring (normed_group (random_gen (dlist linarith.ineq)))) : is_domain (normed_group (random_gen (dlist linarith.ineq))) := sorry --non-trivial
lemma new_lemma_142081 (h0 : set (add_comm_semigroup string.iterator_imp -> ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_142082 (h0 : topological_space (has_compl to_additive.value_type)) : path_connected_space (has_compl to_additive.value_type) := sorry --non-trivial
lemma new_lemma_142083 (h0 : topological_space (semiring (random_gen linarith.ineq))) : locally_compact_space (semiring (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_142084 (h0 : not (add_group (semi_normed_comm_ring reducibility_hints) -> false)) : @is_add_cyclic.{0} (semi_normed_comm_ring.{0} reducibility_hints) (@classical.by_contradiction'.{1} (add_group.{0} (semi_normed_comm_ring.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_142085 (h0 : function.extfun Type ring) : @is_domain.{0} (has_edist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_edist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_142086 (h0 : ordered_add_comm_monoid (add_cancel_monoid (has_pos_part pos))) : archimedean (add_cancel_monoid (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_142087 (h0 : has_mem.mem (random_gen (has_top fun_info)) has_emptyc.emptyc) : @strong_rank_condition.{0} (random_gen.{0} (has_top.{0} fun_info)) (@finset.pi.empty.{1 0} Type ring.{0} (random_gen.{0} (has_top.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_142088 (h0 : functor.add_const (ring (has_add linarith.comp)) (has_Inf Type)) : @is_domain.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (has_add.{0} linarith.comp)) (has_Inf.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_142089 (h0 : add_monoid (cancel_monoid name)) : add_monoid.fg (cancel_monoid name) := sorry --non-trivial
lemma new_lemma_142090 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (linear_ordered_comm_ring.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_142091 (h0 : list (complete_distrib_lattice num)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_142092 (h0 : complete_lattice (normed_comm_ring (has_add (has_add (comm_group pos))))) : is_compactly_generated (normed_comm_ring (has_add (has_add (comm_group pos)))) := sorry --non-trivial
lemma new_lemma_142093 (h1 : has_lt (nondiscrete_normed_field environment.projection_info)) : no_max_order (nondiscrete_normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_142094 (h1 : uniform_space (encodable (has_ssubset (has_ssubset string_imp)))) : complete_space (encodable (has_ssubset (has_ssubset string_imp))) := sorry --non-trivial
lemma new_lemma_142095 (h0 : topological_space (monoid pos)) : locally_compact_space (monoid pos) := sorry --non-trivial
lemma new_lemma_142096 (h0 : topological_space (has_top (semiring (has_norm linarith.comp_source)))) : totally_disconnected_space (has_top (semiring (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_142097 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem monoid)) : @monoid.fg.{0} (has_emptyc.{0} (has_top.{0} fun_info)) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) monoid.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_emptyc.{0} (has_top.{0} fun_info)))  := sorry --non-trivial
lemma new_lemma_142098 (h0 : topological_space (has_nndist Type)) : locally_compact_space (has_nndist Type) := sorry --non-trivial
lemma new_lemma_142099 (h0 : ring (generalized_boolean_algebra (ring name))) : is_principal_ideal_ring (generalized_boolean_algebra (ring name)) := sorry --non-trivial
lemma new_lemma_142100 (h0 : function.extfun Type ring) : @is_domain.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_142101 (h0 : topological_space (finset unsigned)) : t1_space (finset unsigned) := sorry --non-trivial
lemma new_lemma_142102 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_142103 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup Type)) (has_neg linarith.comp)) : @archimedean.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (semigroup.{1} Type)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_142104 (h1 : uniform_space (has_nnnorm fun_info)) : complete_space (has_nnnorm fun_info) := sorry --non-trivial
lemma new_lemma_142105 (h1 : ring (has_append (metric_space (metric_space (denumerable to_additive.value_type))))) : is_domain (has_append (metric_space (metric_space (denumerable to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_142106 (h0 : topological_space (has_zero congr_arg_kind)) : preirreducible_space (has_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_142107 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (finset.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (finset.{0} num))  := sorry --non-trivial
lemma new_lemma_142108 (h0 : group (distrib_lattice char)) : is_cyclic (distrib_lattice char) := sorry --non-trivial
lemma new_lemma_142109 (h0 : topological_space (mul_zero_class (semiring unsigned))) : irreducible_space (mul_zero_class (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_142110 (h0 : complete_lattice (preorder (option (option empty)))) : is_compactly_generated (preorder (option (option empty))) := sorry --non-trivial
lemma new_lemma_142111 (h5 : add_group (nondiscrete_normed_field (normed_field ereal))) : is_add_cyclic (nondiscrete_normed_field (normed_field ereal)) := sorry --non-trivial
lemma new_lemma_142112 (h0 : ring (has_zero (finset name))) : strong_rank_condition (has_zero (finset name)) := sorry --non-trivial
lemma new_lemma_142113 (h0 : topological_space (bin_tree num)) : t0_space (bin_tree num) := sorry --non-trivial
lemma new_lemma_142114 (h0 : list (mul_zero_class (semiring (semiring congr_arg_kind)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_142115 (h1 : filter (dlist (linear_ordered_add_comm_group (fintype (fintype (fintype to_additive.value_type)))))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_142116 (h0 : functor.add_const (complete_lattice (has_nndist name)) Type) : @is_atomistic.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_nndist.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_142117 (h0 : function.extfun Type (functor.add_const (list (linear_order num)))) : palindrome (functor.add_const.run (function.extfun_app h0 empty)) := sorry --non-trivial
lemma new_lemma_142118 (h0 : comm_ring (has_nndist name)) : local_ring (has_nndist name) := sorry --non-trivial
lemma new_lemma_142119 (h0 : complete_lattice (add_group congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (add_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_142120 (h0 : ordered_comm_monoid (boolean_algebra.core (option ennreal))) : has_exists_mul_of_le (boolean_algebra.core (option ennreal)) := sorry --non-trivial
lemma new_lemma_142121 (h0 : topological_space (with_bot (random_gen (random_gen linarith.ineq)))) : t0_space (with_bot (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_142122 (h0 : topological_space (has_pos_part (sub_neg_monoid real))) : loc_path_connected_space (has_pos_part (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_142123 (h0 : topological_space (has_add linarith.ineq)) : locally_compact_space (has_add linarith.ineq) := sorry --non-trivial
lemma new_lemma_142124 (h0 : group (add_comm_monoid (comm_group (has_add environment.implicit_infer_kind)))) : is_simple_group (add_comm_monoid (comm_group (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_142125 (h0 : measurable_space (semi_normed_comm_ring linarith.ineq)) (h1 : filter (semi_normed_comm_ring linarith.ineq)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_142126 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_142127 (h0 : not (ring (uniform_space (mul_one_class (mul_one_class string_imp))) -> false)) : @strong_rank_condition.{0} (uniform_space.{0} (mul_one_class.{0} (mul_one_class.{0} string_imp))) (@classical.by_contradiction'.{1} (ring.{0} (uniform_space.{0} (mul_one_class.{0} (mul_one_class.{0} string_imp)))) h0)  := sorry --non-trivial
lemma new_lemma_142128 (h2 : complete_lattice (with_one (has_ssubset linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (with_one (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_142129 (h0 : topological_space (has_neg (option ennreal))) : irreducible_space (has_neg (option ennreal)) := sorry --non-trivial
lemma new_lemma_142130 (h0 : ring (has_top (with_bot to_additive.value_type))) : is_domain (has_top (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_142131 (h0 : topological_space (mul_zero_class environment.implicit_infer_kind)) : totally_separated_space (mul_zero_class environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_142132 (h0 : ring (has_emptyc (linear_ordered_semiring num))) : rank_condition (has_emptyc (linear_ordered_semiring num)) := sorry --non-trivial
lemma new_lemma_142133 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) Type) : @archimedean.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) Type h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_142134 (h0 : function.extfun (Type 1) monoid) : @monoid.fg.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} h0 (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_142135 (h1 : not (has_mem.mem empty has_emptyc.emptyc -> false)) : @is_compactly_generated.{0} empty (@finset.pi.empty.{1 0} Type complete_lattice.{0} empty (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) empty (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h1))  := sorry --non-trivial
lemma new_lemma_142136 (h0 : ring (ring (has_neg_part pos))) : is_domain (ring (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_142137 (h0 : function.extfun (Type 1) topological_space) : @irreducible_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_142138 (h0 : group (distrib_lattice fun_info)) : group.fg (distrib_lattice fun_info) := sorry --non-trivial
lemma new_lemma_142139 (h0 : ring (normed_comm_ring (comm_group name))) : is_domain (normed_comm_ring (comm_group name)) := sorry --non-trivial
lemma new_lemma_142140 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (measurable_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (measurable_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_142141 (h0 : functor.add_const (filter (cancel_monoid name)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_142142 (h0 : uniform_space (ordered_comm_ring (add_comm_monoid linarith.comp))) : complete_space (ordered_comm_ring (add_comm_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_142143 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) pos) : @preconnected_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_142144 (h0 : functor.add_const (add_group (has_neg_part unsigned)) pos) : @is_add_cyclic.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (has_neg_part.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_142145 (h0 : ring (distrib (has_nnnorm (has_ssubset (has_nnnorm reducibility_hints))))) : rank_condition (distrib (has_nnnorm (has_ssubset (has_nnnorm reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_142146 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) (ring (has_neg pos))) : @preconnected_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_ring.{1} Type)) (ring.{0} (has_neg.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_142147 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen empty))) : @totally_separated_space.{0} (random_gen.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_142148 (h0 : finset (has_nndist unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_142149 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (measure_theory.measure_space.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (measure_theory.measure_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_142150 (h0 : function.extfun Type ring) : @is_domain.{0} (left_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (left_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_142151 (h0 : topological_space (has_ssubset (random_gen (has_one reducibility_hints)))) : path_connected_space (has_ssubset (random_gen (has_one reducibility_hints))) := sorry --non-trivial
lemma new_lemma_142152 (h0 : filter (has_append (semi_normed_ring linarith.comp_source))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_142153 (h0 : has_inter (has_inter (option (option empty))) -> has_inter (has_inter (option (option empty))) -> Prop) : reflexive h0 := sorry --non-trivial
lemma new_lemma_142154 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_142155 (h0 : function.extfun Type (functor.add_const (topological_space (complete_distrib_lattice empty)))) : @totally_disconnected_space.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} empty)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} empty))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_142156 (h0 : uniform_space (add_comm_monoid num)) : separated_space (add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_142157 (h0 : add_group (linear_ordered_field Type)) : is_add_cyclic (linear_ordered_field Type) := sorry --non-trivial
lemma new_lemma_142158 (h0 : functor.add_const (add_group (has_star num)) unsigned) : @is_add_cyclic.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (add_group.{0} (has_star.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_142159 (h0 : uniform_space (normed_comm_ring (option num))) : separated_space (normed_comm_ring (option num)) := sorry --non-trivial
lemma new_lemma_142160 (h0 : ring (rel fun_info fun_info)) : strong_rank_condition (rel fun_info fun_info) := sorry --non-trivial
lemma new_lemma_142161 (h0 : functor.add_const (function.extfun Type topological_space) (finset name)) : @path_connected_space.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (finset.{0} name) h0) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_142162 (h0 : topological_space (ordered_comm_monoid Type)) : regular_space (ordered_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_142163 (h0 : ring (has_pos_part (has_add real))) : is_principal_ideal_ring (has_pos_part (has_add real)) := sorry --non-trivial
lemma new_lemma_142164 (h0 : functor.add_const (topological_space (comm_group unsigned)) environment.implicit_infer_kind) : @irreducible_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_142165 (h0 : uniform_space (canonically_ordered_monoid (has_Inf (has_add (has_add linarith.comp))))) : complete_space (canonically_ordered_monoid (has_Inf (has_add (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_142166 (h0 : topological_space (add_comm_monoid linarith.comp)) : sequential_space (add_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_142167 (h0 : ring (has_to_string (ring (has_pos_part Type)))) : rank_condition (has_to_string (ring (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_142168 (h0 : ring (non_unital_non_assoc_semiring (mul_zero_class string_imp))) : rank_condition (non_unital_non_assoc_semiring (mul_zero_class string_imp)) := sorry --non-trivial
lemma new_lemma_142169 (h1 : group (topological_space linarith.comp_source)) : group.fg (topological_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_142170 (h0 : topological_space (semigroup (semiring empty))) : locally_compact_space (semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_142171 (h0 : topological_space (boolean_algebra (has_add (comm_group unsigned)))) : normal_space (boolean_algebra (has_add (comm_group unsigned))) := sorry --non-trivial
lemma new_lemma_142172 (h0 : topological_space (dlist fun_info)) : path_connected_space (dlist fun_info) := sorry --non-trivial
lemma new_lemma_142173 (h0 : set (mul_zero_class char)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_142174 (h0 : functor.add_const (uniform_space (add_cancel_monoid Type)) name) : @separated_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (add_cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_142175 (h0 : topological_space (generalized_boolean_algebra (sub_neg_monoid real))) : normal_space (generalized_boolean_algebra (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_142176 (h0 : uniform_space (has_nnnorm linarith.comp_source)) : complete_space (has_nnnorm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_142177 (h0 : topological_space (has_Inf (ring (has_neg pos)))) : locally_compact_space (has_Inf (ring (has_neg pos))) := sorry --non-trivial
lemma new_lemma_142178 (h0 : topological_space (with_one congr_arg_kind)) : discrete_topology (with_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_142179 (h1 : list (topological_space (has_norm string_imp))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_142180 (h0 : not (group (dlist linarith.ineq) -> false)) : @is_cyclic.{0} (dlist.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (dlist.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_142181 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @topological_space.separable_space.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_142182 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_142183 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_142184 (h0 : functor.add_const (list (semigroup name)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_142185 (h0 : function.extfun Type group) : @normalizer_condition.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_142186 (h0 : topological_space (pseudo_metric_space (has_neg_part unsigned))) : totally_disconnected_space (pseudo_metric_space (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_142187 (h0 : functor.add_const (topological_space (has_dist empty)) congr_arg_kind) : @irreducible_space.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_142188 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_to_string.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_to_string.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_142189 (h0 : functor.add_const (list (has_neg name)) (boolean_algebra Type)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_142190 (h0 : uniform_space (has_bot (finset pos))) : complete_space (has_bot (finset pos)) := sorry --non-trivial
lemma new_lemma_142191 (h0 : filter (has_neg_part (option (option (option pos))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_142192 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (linear_order congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_142193 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_142194 (h0 : list (has_ssubset linarith.ineq)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_142195 (h0 : ring (has_add (ring (has_add (has_nndist linarith.comp))))) : strong_rank_condition (has_add (ring (has_add (has_nndist linarith.comp)))) := sorry --non-trivial
lemma new_lemma_142196 (h0 : topological_space (boolean_algebra (has_add (has_pos_part pos)))) : t1_space (boolean_algebra (has_add (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_142197 (h0 : functor.add_const (uniform_space (has_add linarith.comp)) (finset environment.implicit_infer_kind)) : @complete_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_add.{0} linarith.comp)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_142198 (h0 : semiring (canonically_linear_ordered_monoid (option pos))) : is_noetherian_ring (canonically_linear_ordered_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_142199 (h0 : function.extfun Type group) : @normalizer_condition.{0} (generalized_boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (generalized_boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_142200 (h0 : ring (ring (normed_comm_ring (ordered_ring (has_Inf (ordered_ring (has_neg linarith.comp))))))) : is_domain (ring (normed_comm_ring (ordered_ring (has_Inf (ordered_ring (has_neg linarith.comp)))))) := sorry --non-trivial
lemma new_lemma_142201 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_142202 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm empty))) : @is_add_cyclic.{0} (has_norm.{0} empty) (@finset.pi.empty.{1 0} Type add_group.{0} (has_norm.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_142203 (h0 : topological_space (boolean_algebra (has_pos_part (has_pos_part Type)))) : regular_space (boolean_algebra (has_pos_part (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_142204 (h0 : group (semigroup (ordered_ring Type))) : is_simple_group (semigroup (ordered_ring Type)) := sorry --non-trivial
lemma new_lemma_142205 (h0 : topological_space (has_norm (random_gen linarith.comp_source))) : irreducible_space (has_norm (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_142206 (h0 : group (monoid (option unsigned))) : normalizer_condition (monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_142207 (h0 : has_lt (normed_field (mul_one_class (mul_one_class string.iterator_imp)))) : no_max_order (normed_field (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_142208 (h0 : fin has_zero.zero) : @is_domain.{1} (canonically_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (canonically_ordered_monoid.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_142209 (h0 : set (nondiscrete_normed_field std_gen)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_142210 (h0 : list (has_neg pos)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_142211 (h0 : topological_space (complete_distrib_lattice (has_neg (has_add pos)))) : path_connected_space (complete_distrib_lattice (has_neg (has_add pos))) := sorry --non-trivial
lemma new_lemma_142212 (h0 : add_group (ring (has_neg (ring (has_neg (has_neg pos)))))) : is_add_cyclic (ring (has_neg (ring (has_neg (has_neg pos))))) := sorry --non-trivial
lemma new_lemma_142213 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_ssubset.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_ssubset.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_142214 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (group_with_zero ennreal)) := sorry --non-trivial
lemma new_lemma_142215 (h0 : monoid_with_zero (add_comm_monoid pos) -> monoid_with_zero (add_comm_monoid pos) -> Prop) : is_symm (monoid_with_zero (add_comm_monoid pos)) h0 := sorry --non-trivial
lemma new_lemma_142216 (h0 : topological_space (cancel_monoid (finset (boolean_algebra.core name)))) : path_connected_space (cancel_monoid (finset (boolean_algebra.core name))) := sorry --non-trivial
lemma new_lemma_142217 (h1 : topological_space (add_comm_semigroup enat)) (h2 : preorder (add_comm_semigroup enat)) : order_closed_topology (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_142218 (h0 : add_group (linear_ordered_semiring (random_gen fun_info))) : is_add_cyclic (linear_ordered_semiring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_142219 (h0 : topological_space (has_Inf (ring name))) : discrete_topology (has_Inf (ring name)) := sorry --non-trivial
lemma new_lemma_142220 (h0 : group (has_nnnorm (has_nnnorm linarith.ineq))) : is_cyclic (has_nnnorm (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_142221 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_142222 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (has_add name)) := sorry --non-trivial
lemma new_lemma_142223 (h0 : not (topological_space (add_group linarith.comp) -> false)) : @totally_disconnected_space.{0} (add_group.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_142224 (h0 : ring (has_dist (option (option empty)))) : rank_condition (has_dist (option (option empty))) := sorry --non-trivial
lemma new_lemma_142225 (h0 : topological_space (plift num)) : loc_path_connected_space (plift num) := sorry --non-trivial
lemma new_lemma_142226 (h0 : functor.add_const (ring (normed_comm_ring unsigned)) unsigned) : @is_domain.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_142227 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring pos)) Type) : @regular_space.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (canonically_ordered_comm_semiring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_142228 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_bot.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_142229 (h0 : finset (normed_lattice_add_comm_group (has_add (sub_neg_monoid real)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_142230 (h0 : ring (has_norm fun_info)) : strong_rank_condition (has_norm fun_info) := sorry --non-trivial
lemma new_lemma_142231 (h0 : topological_space (cancel_monoid empty)) : discrete_topology (cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_142232 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_142233 (h0 : not (topological_space (has_ssubset fun_info) -> false)) : @path_connected_space.{0} (has_ssubset.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_142234 (h0 : topological_space (id (comm_ring (random_gen to_additive.value_type)))) : totally_separated_space (id (comm_ring (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_142235 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} linarith.comp (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_142236 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (add_right_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_right_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_142237 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_142238 (h0 : functor.add_const (complete_lattice (plift empty)) num) : @complete_lattice.is_Sup_finite_compact.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (complete_lattice.{1} (plift.{1} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_142239 (h0 : functor.add_const (topological_space (has_nndist name)) environment.implicit_infer_kind) : @normal_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_142240 (h0 : monoid (linear_ordered_add_comm_group string_imp)) : monoid.fg (linear_ordered_add_comm_group string_imp) := sorry --non-trivial
lemma new_lemma_142241 (h0 : has_mem.mem (has_top fun_info) has_emptyc.emptyc) : @totally_disconnected_space.{0} (has_top.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_142242 (h0 : uniform_space (simple_graph (has_add (finset linarith.comp)))) : separated_space (simple_graph (has_add (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_142243 (h0 : functor.add_const (functor.add_const (group Type) linarith.comp) Type) : @is_simple_group.{1} Type (@functor.add_const.run.{1 0} (group.{1} Type) linarith.comp (@functor.add_const.run.{1 1} (functor.add_const.{1 0} (group.{1} Type) linarith.comp) Type h0))  := sorry --non-trivial
lemma new_lemma_142244 (h0 : topological_space (complete_semilattice_Sup unsigned)) : preirreducible_space (complete_semilattice_Sup unsigned) := sorry --non-trivial
lemma new_lemma_142245 (h0 : ring (boolean_algebra.core environment.implicit_infer_kind)) : rank_condition (boolean_algebra.core environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_142246 (h0 : topological_space (ordered_comm_ring (has_neg name))) : normal_space (ordered_comm_ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_142247 (h0 : function.extfun Type (functor.comp topological_space has_zero)) : @topological_space.separable_space.{0} (has_zero.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_zero.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_142248 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (finset.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (finset.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_142249 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_ssubset.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (has_ssubset.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_142250 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_142251 (h0 : topological_space (has_inv (random_gen (has_ssubset linarith.ineq)))) : irreducible_space (has_inv (random_gen (has_ssubset linarith.ineq))) := sorry --non-trivial
lemma new_lemma_142252 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) environment.implicit_infer_kind) : @regular_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_142253 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preirreducible_space.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_142254 (h0 : group (with_one (semiring unsigned))) : normalizer_condition (with_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_142255 (h0 : function.extfun Type ring) : @rank_condition.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_142256 (h1 : has_neg (normed_field linarith.ineq)) (h2 : measurable_space (normed_field linarith.ineq)) : has_measurable_neg (normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_142257 (h0 : topological_space (is_R_or_C (semiring empty))) : locally_compact_space (is_R_or_C (semiring empty)) := sorry --non-trivial
lemma new_lemma_142258 (h0 : functor.add_const (topological_space (linear_ordered_semiring empty)) empty) : @irreducible_space.{0} (linear_ordered_semiring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_semiring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_142259 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_142260 (h2 : topological_space (has_emptyc to_additive.value_type)) : irreducible_space (has_emptyc to_additive.value_type) := sorry --non-trivial
lemma new_lemma_142261 (h3 : ring (denumerable char)) : rank_condition (denumerable char) := sorry --non-trivial
lemma new_lemma_142262 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (semi_normed_comm_ring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (semi_normed_comm_ring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_142263 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @is_principal_ideal_ring.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_142264 (h1 : function.extfun Type monoid) : @monoid.fg.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} h1 (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_142265 (h1 : filter (complete_semilattice_Sup char)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_142266 (h1 h2 : multiset (add_comm_semigroup (add_comm_semigroup char))) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_142267 (h0 : topological_space (ordered_comm_monoid (has_add (has_Inf (has_Inf real))))) : t1_space (ordered_comm_monoid (has_add (has_Inf (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_142268 (h0 : ring (has_union (has_norm linarith.comp))) : rank_condition (has_union (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_142269 (h0 : ordered_add_comm_monoid (has_add (has_pos_part Type))) : archimedean (has_add (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_142270 (h0 : not (has_mem.mem (semiring linarith.comp_source) has_emptyc.emptyc -> false)) : @locally_compact_space.{0} (semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_142271 (h0 : add_group (ordered_comm_semiring fun_info)) : is_add_cyclic (ordered_comm_semiring fun_info) := sorry --non-trivial
lemma new_lemma_142272 (h0 : topological_space (ordered_comm_monoid (sub_neg_monoid linarith.comp))) : locally_compact_space (ordered_comm_monoid (sub_neg_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_142273 (h0 : not (uniform_space (distrib fun_info) -> false)) : @complete_space.{0} (distrib.{0} fun_info) (@classical.by_contradiction'.{1} (uniform_space.{0} (distrib.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_142274 (h0 : group (has_nnnorm (random_gen linarith.comp_source))) : is_cyclic (has_nnnorm (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_142275 (h0 : not (ring (mul_one_class reducibility_hints) -> false)) : @is_domain.{0} (mul_one_class.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (mul_one_class.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_142276 (h0 : topological_space (id unsigned)) : locally_compact_space (id unsigned) := sorry --non-trivial
lemma new_lemma_142277 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm num))) : @normalizer_condition.{0} (has_norm.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (has_norm.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_142278 (h0 : functor.add_const (topological_space (semigroup (ring (has_to_string Type)))) (ring pos)) : @topological_space.separable_space.{1} (semigroup.{1} (ring.{1} (has_to_string.{1} Type))) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} (ring.{1} (has_to_string.{1} Type)))) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_142279 (h0 : ring (has_lt fun_info)) : strong_rank_condition (has_lt fun_info) := sorry --non-trivial
lemma new_lemma_142280 (h0 : add_group (normed_group (has_inv linarith.ineq))) : is_add_cyclic (normed_group (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_142281 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_142282 (h2 : complete_lattice (complete_semilattice_Sup (random_gen (random_gen string_imp)))) : is_atomistic (complete_semilattice_Sup (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_142283 (h0 : complete_lattice unsigned) : complete_lattice.is_Sup_finite_compact unsigned := sorry --non-trivial
lemma new_lemma_142284 (h0 : functor.add_const (function.extfun (Type 1) monoid) Type) : @monoid.fg.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) monoid.{1}) Type h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_142285 (h0 : ring (semigroup (comm_group pos))) : is_domain (semigroup (comm_group pos)) := sorry --non-trivial
lemma new_lemma_142286 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (mul_zero_class.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (mul_zero_class.{0} empty))  := sorry --non-trivial
lemma new_lemma_142287 (h0 : prod (add_right_cancel_monoid (semiring unsigned)) (add_right_cancel_monoid (semiring unsigned))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_142288 (h0 : ring (sub_neg_monoid (canonically_ordered_monoid Type))) : is_domain (sub_neg_monoid (canonically_ordered_monoid Type)) := sorry --non-trivial
lemma new_lemma_142289 (h0 : group (semigroup unsigned)) : is_simple_group (semigroup unsigned) := sorry --non-trivial
lemma new_lemma_142290 (h0 : topological_space (canonically_linear_ordered_monoid (has_zero num))) : totally_disconnected_space (canonically_linear_ordered_monoid (has_zero num)) := sorry --non-trivial
lemma new_lemma_142291 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_142292 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_142293 (h0 : not (uniform_space nnreal -> false)) : separated_space nnreal := sorry --non-trivial
lemma new_lemma_142294 (h0 : topological_space (ordered_cancel_add_comm_monoid congr_arg_kind)) : path_connected_space (ordered_cancel_add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_142295 (h0 : function.extfun Type (functor.add_const (add_monoid auto.case_option))) : @add_monoid.fg.{0} auto.case_option (@functor.add_const.run.{0 0} (add_monoid.{0} auto.case_option) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_monoid.{0} auto.case_option)) h0 num))  := sorry --non-trivial
lemma new_lemma_142296 (h0 : complete_lattice (comm_semigroup (has_bot real))) : is_atomistic (comm_semigroup (has_bot real)) := sorry --non-trivial
lemma new_lemma_142297 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} h0 (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_142298 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_142299 (h0 : has_neg (add_comm_semigroup (mul_one_class (add_comm_semigroup std_gen)))) (h1 : measurable_space (add_comm_semigroup (mul_one_class (add_comm_semigroup std_gen)))) : has_measurable_neg (add_comm_semigroup (mul_one_class (add_comm_semigroup std_gen))) := sorry --non-trivial
lemma new_lemma_142300 (h0 : topological_space (canonically_ordered_comm_semiring (comm_group (comm_group name)))) : irreducible_space (canonically_ordered_comm_semiring (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_142301 (h0 : functor.add_const (topological_space (has_Inf name)) linarith.comp) : @regular_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_142302 (h0 : topological_space (ring (option (option (option num))))) : totally_disconnected_space (ring (option (option (option num)))) := sorry --non-trivial
lemma new_lemma_142303 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) name) : @locally_compact_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_142304 (h2 : topological_space (has_inv linarith.comp_source)) : t0_space (has_inv linarith.comp_source) := sorry --non-trivial
lemma new_lemma_142305 (h0 : filter (has_Inf (has_Inf (has_Inf pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_142306 (h0 : topological_space (has_compl (has_lt string_imp))) : path_connected_space (has_compl (has_lt string_imp)) := sorry --non-trivial
lemma new_lemma_142307 (h2 : topological_space (has_nnnorm fun_info)) : path_connected_space (has_nnnorm fun_info) := sorry --non-trivial
lemma new_lemma_142308 (h0 : add_monoid (complete_distrib_lattice (has_Inf linarith.comp))) : add_monoid.fg (complete_distrib_lattice (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_142309 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_inv.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_inv.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_142310 (h0 : topological_space (add_comm_monoid (normed_comm_ring Type))) : sequential_space (add_comm_monoid (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_142311 (h0 : functor.add_const (cancel_comm_monoid_with_zero Type) Type) : @unique_factorization_monoid.{1} Type (@functor.add_const.run.{1 1} (cancel_comm_monoid_with_zero.{1} Type) Type h0)  := sorry --non-trivial
lemma new_lemma_142312 (h0 : functor.add_const (uniform_space (sub_neg_monoid pos)) linarith.comp) : @separated_space.{0} (sub_neg_monoid.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (sub_neg_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_142313 (h0 : semiring (has_add (ring (boolean_algebra.core pos)))) : is_noetherian_ring (has_add (ring (boolean_algebra.core pos))) := sorry --non-trivial
lemma new_lemma_142314 (h0 : functor.add_const (add_monoid (canonically_ordered_add_monoid unsigned)) empty) : @add_monoid.fg.{0} (canonically_ordered_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (canonically_ordered_add_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_142315 (h0 : complete_lattice (distrib_lattice (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) : is_compactly_generated (distrib_lattice (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_142316 (h1 : ring (has_compl string_imp)) : is_domain (has_compl string_imp) := sorry --non-trivial
lemma new_lemma_142317 (h1 : add_group (non_unital_non_assoc_semiring (comm_ring to_additive.value_type))) : is_add_cyclic (non_unital_non_assoc_semiring (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_142318 (h0 : topological_space (with_zero Type)) : t0_space (with_zero Type) := sorry --non-trivial
lemma new_lemma_142319 (h0 : functor.add_const (uniform_space (complete_distrib_lattice environment.implicit_infer_kind)) (has_neg pos)) : @separated_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_142320 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_142321 (h0 : functor.add_const (group (has_nndist name)) name) : @group.fg.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_142322 (h0 : functor.add_const (complete_lattice (has_zero unsigned)) name) : @is_compactly_generated.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_142323 (h0 : not (topological_space (simple_graph string_imp) -> false)) : @path_connected_space.{0} (simple_graph.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (simple_graph.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_142324 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_142325 (h0 : topological_space (canonically_ordered_comm_semiring (ring linarith.comp))) : topological_space.separable_space (canonically_ordered_comm_semiring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_142326 (h0 : topological_space (add_cancel_monoid (has_Inf Type))) : t1_space (add_cancel_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_142327 (h0 : functor.add_const (monoid (uniform_space unsigned)) ennreal) : @monoid.fg.{0} (uniform_space.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (uniform_space.{0} unsigned)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_142328 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_142329 (h0 : complete_lattice (with_one (random_gen linarith.ineq))) : complete_lattice.is_Sup_finite_compact (with_one (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_142330 (h0 : topological_space (id unsigned)) : topological_space.separable_space (id unsigned) := sorry --non-trivial
lemma new_lemma_142331 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (with_one.{0} string_imp) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (with_one.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_142332 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : t0_space nnreal := sorry --non-trivial
lemma new_lemma_142333 (h0 : group (topological_space (denumerable (denumerable (denumerable char))))) : is_cyclic (topological_space (denumerable (denumerable (denumerable char)))) := sorry --non-trivial
lemma new_lemma_142334 (h0 : group (canonically_ordered_monoid (has_add linarith.comp))) : group.fg (canonically_ordered_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_142335 (h0 : filter (add_cancel_monoid (has_add ennreal))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_142336 (h0 : functor.add_const (function.extfun Type complete_lattice) name) : @is_compactly_generated.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) name h0) (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_142337 (h0 : uniform_space (uniform_space (mul_one_class (mul_one_class string.iterator_imp)))) : complete_space (uniform_space (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_142338 (h0 : function.extfun (set num) (fun (x : set num), Prop)) : is_countably_spanning (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_142339 (h0 : function.extfun (Type 1) ordered_comm_monoid) : @has_exists_mul_of_le.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} h0 (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_142340 (h0 : topological_space (ring (has_neg pos))) : locally_compact_space (ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_142341 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) Type) : @sequential_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_142342 (h2 : function.extfun Type group) : @normalizer_condition.{0} congr_arg_kind (@function.extfun_app.{2 1} Type group.{0} h2 congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_142343 (h0 : functor.add_const (group (has_bot linarith.comp)) linarith.comp) : @normalizer_condition.{0} (has_bot.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_bot.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_142344 (h0 : measurable_space (distrib linarith.ineq)) (h1 : filter (distrib linarith.ineq)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_142345 (h0 : function.extfun (finset Type) (has_mem.mem (semiring empty))) : @strong_rank_condition.{0} (semiring.{0} empty) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_142346 (h0 : functor.add_const (uniform_space (canonically_linear_ordered_monoid name)) linarith.comp) : @complete_space.{0} (canonically_linear_ordered_monoid.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (canonically_linear_ordered_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_142347 (h0 : complete_lattice (ordered_comm_monoid name)) : is_compactly_generated (ordered_comm_monoid name) := sorry --non-trivial
lemma new_lemma_142348 (h0 : ring (add_cancel_comm_monoid (has_compl (mul_one_class (add_cancel_comm_monoid ennreal))))) : is_domain (add_cancel_comm_monoid (has_compl (mul_one_class (add_cancel_comm_monoid ennreal)))) := sorry --non-trivial
lemma new_lemma_142349 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_bot.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_142350 (h0 : topological_space (has_union (semiring (semiring (semiring (semiring (semiring unsigned))))))) : path_connected_space (has_union (semiring (semiring (semiring (semiring (semiring unsigned)))))) := sorry --non-trivial
lemma new_lemma_142351 (h0 : ring (add_comm_monoid (semigroup linarith.comp))) : rank_condition (add_comm_monoid (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_142352 (h0 : add_group (has_ssubset (has_nnnorm (has_nnnorm linarith.comp_source)))) : is_add_cyclic (has_ssubset (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_142353 (h0 : topological_space (linear_ordered_comm_ring congr_arg_kind)) : locally_compact_space (linear_ordered_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_142354 (h0 : ordered_add_comm_monoid (simple_graph (has_Inf Type))) : archimedean (simple_graph (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_142355 (h0 : list (topological_space (has_nnnorm fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_142356 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_142357 (h0 : ring (add_semigroup congr_arg_kind)) : is_principal_ideal_ring (add_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_142358 (h0 : uniform_space (non_unital_non_assoc_semiring linarith.comp_source)) : complete_space (non_unital_non_assoc_semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_142359 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (mul_one_class.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (mul_one_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_142360 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_142361 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem group)) : @normalizer_condition.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_142362 (h1 : has_mem.mem group has_emptyc.emptyc) : @normalizer_condition.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h1) (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_142363 (h0 : topological_space (has_add (sub_neg_monoid (sub_neg_monoid (has_Inf real))))) : regular_space (has_add (sub_neg_monoid (sub_neg_monoid (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_142364 (h0 : cancel_comm_monoid_with_zero (comm_group (option (finset ennreal)))) : unique_factorization_monoid (comm_group (option (finset ennreal))) := sorry --non-trivial
lemma new_lemma_142365 (h0 : functor.add_const (topological_space Type) name) : @totally_separated_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) name h0)  := sorry --non-trivial
lemma new_lemma_142366 (h0 : topological_space (has_nndist (has_add (has_nndist (has_add name))))) : discrete_topology (has_nndist (has_add (has_nndist (has_add name)))) := sorry --non-trivial
lemma new_lemma_142367 (h0 : functor.add_const (ring (comm_group Type)) pos) : @is_principal_ideal_ring.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (comm_group.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_142368 (h1 : topological_space (normed_field (mul_one_class ereal))) (h2 : preorder (normed_field (mul_one_class ereal))) : order_closed_topology (normed_field (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_142369 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_142370 (h0 : functor.add_const (filter (mul_zero_class empty)) num) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_142371 (h0 : add_group (has_zero ennreal)) : is_add_cyclic (has_zero ennreal) := sorry --non-trivial
lemma new_lemma_142372 (h0 : fin has_zero.zero) : @add_monoid.fg.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (add_monoid.{1} (generalized_boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_142373 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (fintype.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (fintype.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_142374 (h0 : ordered_add_comm_monoid (has_pos_part (has_neg pos))) : archimedean (has_pos_part (has_neg pos)) := sorry --non-trivial
lemma new_lemma_142375 (h0 : group (has_union linarith.comp)) : normalizer_condition (has_union linarith.comp) := sorry --non-trivial
lemma new_lemma_142376 (h0 : topological_space (preorder congr_arg_kind)) : t1_space (preorder congr_arg_kind) := sorry --non-trivial
lemma new_lemma_142377 (h0 : topological_space (add_comm_monoid (finset linarith.comp))) : loc_path_connected_space (add_comm_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_142378 (h0 : topological_space (normed_comm_ring (finset Type))) : normal_space (normed_comm_ring (finset Type)) := sorry --non-trivial
lemma new_lemma_142379 (h0 h1 : multiset (has_nnnorm (distrib string_imp))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_142380 (h0 : uniform_space (has_nndist (has_Inf (finset pos)))) : separated_space (has_nndist (has_Inf (finset pos))) := sorry --non-trivial
lemma new_lemma_142381 (h0 : group (finset (has_add linarith.comp))) : is_cyclic (finset (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_142382 (h0 : topological_space (finset (boolean_algebra Type))) : normal_space (finset (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_142383 (h0 : add_group (normed_comm_ring unsigned)) : is_add_cyclic (normed_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_142384 (h0 : topological_space (sub_neg_monoid (has_add Type))) : preirreducible_space (sub_neg_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_142385 (h0 : topological_space (add_left_cancel_semigroup (has_edist (option unsigned)))) : topological_space.separable_space (add_left_cancel_semigroup (has_edist (option unsigned))) := sorry --non-trivial
lemma new_lemma_142386 (h0 : ring (linear_ordered_semiring (random_gen num))) : is_domain (linear_ordered_semiring (random_gen num)) := sorry --non-trivial
lemma new_lemma_142387 (h0 : ring (ring (comm_group (comm_group pos)))) : is_domain (ring (comm_group (comm_group pos))) := sorry --non-trivial
lemma new_lemma_142388 (h0 : functor.add_const (list (has_to_string name)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_142389 (h1 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (denumerable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (denumerable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_142390 (h0 : not (topological_space (comm_ring linarith.ineq) -> false)) : @totally_disconnected_space.{0} (comm_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (comm_ring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_142391 (h0 : topological_space (normed_field (random_gen (random_gen linarith.ineq)))) : t0_space (normed_field (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_142392 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (normed_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (normed_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_142393 (h0 : not (filter (has_top unsigned) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_142394 (h0 : functor.add_const (ordered_add_comm_monoid (has_to_string linarith.comp)) linarith.comp) : @archimedean.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_to_string.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_142395 (h0 : cancel_comm_monoid_with_zero (ordered_comm_monoid Type)) : unique_factorization_monoid (ordered_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_142396 (h0 : complete_lattice (add_cancel_monoid ennreal)) : is_compactly_generated (add_cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_142397 (h0 : ring (linear_ordered_comm_group congr_arg_kind)) : strong_rank_condition (linear_ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_142398 (h0 : topological_space (has_bot (has_Inf name))) : preconnected_space (has_bot (has_Inf name)) := sorry --non-trivial
lemma new_lemma_142399 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 congr_arg_kind) := sorry --non-trivial
lemma new_lemma_142400 (h0 : functor.add_const (topological_space (has_edist unsigned)) unsigned) : @t1_space.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_142401 (h0 : ring (boolean_algebra pos)) : is_principal_ideal_ring (boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_142402 (h0 : group (ring (has_Inf name))) : normalizer_condition (ring (has_Inf name)) := sorry --non-trivial
lemma new_lemma_142403 (h0 : function.extfun (((Type -> Type) -> Type 1) -> Type 1) (function.extfun ((Type -> Type) -> Type 1))) : @is_add_cyclic.{0} (has_inv.{0} linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (@function.extfun_app.{3 3} (((Type → Type) → Type 1) → Type 1) (function.extfun.{3 2} ((Type → Type) → Type 1)) h0 (function.extfun.{2 2} (Type → Type))) (function.extfun.{2 1} Type)) add_group.{0}) (has_inv.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_142404 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) pos) : @totally_separated_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_142405 (h0 : option (ordered_add_comm_monoid (has_nndist (has_neg (has_neg_part (boolean_algebra (has_neg pos))))))) (h1 : ordered_add_comm_monoid (has_nndist (has_neg (has_neg_part (boolean_algebra (has_neg pos)))))) : archimedean (has_nndist (has_neg (has_neg_part (boolean_algebra (has_neg pos))))) := sorry --non-trivial
lemma new_lemma_142406 (h0 : functor.add_const (add_group (boolean_algebra unsigned)) pos) : @is_add_cyclic.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (boolean_algebra.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_142407 (h0 : functor.add_const (finset (partial_order num)) num) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_142408 (h0 : lattice (has_emptyc (has_norm empty))) : is_modular_lattice (has_emptyc (has_norm empty)) := sorry --non-trivial
lemma new_lemma_142409 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_neg.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_142410 (h0 : functor.add_const (group (has_add Type)) pos) : @is_cyclic.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_add.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_142411 (h0 : list (finset (has_add pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_142412 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_142413 (h0 : function.extfun Type group) : @group.fg.{0} auto.case_option (@function.extfun_app.{2 1} Type group.{0} h0 auto.case_option)  := sorry --non-trivial
lemma new_lemma_142414 (h0 : ordered_comm_monoid (sub_neg_monoid (finset (finset (has_Inf (finset linarith.comp)))))) : has_exists_mul_of_le (sub_neg_monoid (finset (finset (has_Inf (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_142415 (h0 : not (cancel_comm_monoid_with_zero (partial_order empty) -> false)) : @unique_factorization_monoid.{0} (partial_order.{0} empty) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (partial_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_142416 (h0 : ring (ring empty)) : rank_condition (ring empty) := sorry --non-trivial
lemma new_lemma_142417 (h0 : topological_space (add_cancel_monoid (has_add Type))) : sequential_space (add_cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_142418 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @locally_compact_space.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_142419 (h0 : functor.comp topological_space ring environment.implicit_infer_kind) : @preirreducible_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_142420 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_142421 (h0 : functor.add_const (filter (cancel_monoid ennreal)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_142422 (h0 : list (left_cancel_monoid (semiring (semiring (semiring unsigned))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_142423 (h0 : topological_space (random_gen (has_norm fun_info))) : locally_compact_space (random_gen (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_142424 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @t1_space.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_142425 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (simple_graph.{0} (has_neg.{0} linarith.comp)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (simple_graph.{0} (has_neg.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_142426 (h0 : finset (generalized_boolean_algebra (finset linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_142427 (h0 : list (canonically_linear_ordered_monoid congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_142428 (h0 : semiring (has_to_string linarith.comp)) : is_noetherian_ring (has_to_string linarith.comp) := sorry --non-trivial
lemma new_lemma_142429 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @irreducible_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_142430 (h0 : complete_lattice (semiring (has_top to_additive.value_type))) : is_compactly_generated (semiring (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_142431 (h0 : add_group (has_bot (has_Inf (finset pos)))) : is_add_cyclic (has_bot (has_Inf (finset pos))) := sorry --non-trivial
lemma new_lemma_142432 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_142433 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) linarith.comp) : @topological_space.separable_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_142434 (h0 : topological_space (semigroup (has_add (finset environment.implicit_infer_kind)))) : t0_space (semigroup (has_add (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_142435 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @strong_rank_condition.{0} (has_emptyc.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_emptyc.{0} empty))  := sorry --non-trivial
lemma new_lemma_142436 (h0 : not (topological_space (denumerable (has_ssubset (has_ssubset to_additive.value_type))) -> false)) : @t0_space.{0} (denumerable.{0} (has_ssubset.{0} (has_ssubset.{0} to_additive.value_type))) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} (has_ssubset.{0} (has_ssubset.{0} to_additive.value_type)))) h0)  := sorry --non-trivial
lemma new_lemma_142437 (h0 : functor.add_const (ring (has_nndist Type)) (has_neg_part Type)) : @strong_rank_condition.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (has_nndist.{1} Type)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_142438 (h0 : topological_space (semi_normed_comm_ring reducibility_hints)) : totally_disconnected_space (semi_normed_comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_142439 (h1 : ring (has_ssubset (mul_one_class std_gen))) : is_domain (has_ssubset (mul_one_class std_gen)) := sorry --non-trivial
lemma new_lemma_142440 (h0 : complete_lattice (distrib (has_nnnorm (has_nnnorm reducibility_hints)))) : complete_lattice.is_Sup_finite_compact (distrib (has_nnnorm (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_142441 (h0 : functor.add_const (monoid (semigroup pos)) name) : @monoid.fg.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (semigroup.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_142442 (h0 : group (complete_linear_order empty)) : normalizer_condition (complete_linear_order empty) := sorry --non-trivial
lemma new_lemma_142443 (h0 : functor.add_const (topological_space (ring pos)) (has_neg pos)) : @totally_separated_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_142444 (h0 : ring (normed_lattice_add_comm_group name)) : rank_condition (normed_lattice_add_comm_group name) := sorry --non-trivial
lemma new_lemma_142445 (h0 : uniform_space (pseudo_metric_space (option (option pos)))) : complete_space (pseudo_metric_space (option (option pos))) := sorry --non-trivial
lemma new_lemma_142446 (h0 : functor.add_const (monoid (boolean_algebra environment.implicit_infer_kind)) (finset Type)) : @monoid.fg.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (monoid.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_142447 (h0 : functor.add_const (list (add_cancel_monoid pos)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_142448 (h0 : functor.add_const (topological_space (has_neg pos)) (semigroup linarith.comp)) : @path_connected_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) (semigroup.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_142449 (h0 : group (has_Inf (has_add (has_add pos)))) : normalizer_condition (has_Inf (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_142450 (h1 : not (filter (div_inv_monoid to_additive.value_type) -> false)) : filter.ne_bot (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_142451 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_142452 (h0 : left_cancel_semigroup (ordered_ring empty) -> left_cancel_semigroup (ordered_ring empty) -> bool) : is_dec_refl h0 := sorry --non-trivial
lemma new_lemma_142453 (h0 : add_monoid (has_dist (option (option empty)))) : add_monoid.fg (has_dist (option (option empty))) := sorry --non-trivial
lemma new_lemma_142454 (h0 : topological_space (add_cancel_monoid ennreal)) : preconnected_space (add_cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_142455 (h0 : topological_space (has_to_string (has_pos_part (has_pos_part (has_add linarith.comp))))) : preconnected_space (has_to_string (has_pos_part (has_pos_part (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_142456 (h0 : topological_space (with_bot (random_gen (denumerable string_imp)))) : path_connected_space (with_bot (random_gen (denumerable string_imp))) := sorry --non-trivial
lemma new_lemma_142457 (h0 : list (finset (option empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_142458 (h0 : topological_space (has_Inf (has_add pos))) : totally_disconnected_space (has_Inf (has_add pos)) := sorry --non-trivial
lemma new_lemma_142459 (h0 : group (complete_semilattice_Sup (has_top string_imp))) : normalizer_condition (complete_semilattice_Sup (has_top string_imp)) := sorry --non-trivial
lemma new_lemma_142460 (h0 : functor.comp topological_space finset Type) : @discrete_topology.{1} (finset.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} finset.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_142461 (h0 : topological_space (boolean_algebra Type)) : loc_path_connected_space (boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_142462 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_noetherian_ring.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 semiring.{1}) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_142463 (h0 : functor.add_const (add_monoid (cancel_monoid Type)) pos) : @add_monoid.fg.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_142464 (h0 : add_group (topological_space (has_ssubset char))) : is_add_cyclic (topological_space (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_142465 (h0 : add_group Type) : is_add_cyclic Type := sorry --non-trivial
lemma new_lemma_142466 (h0 : topological_space (canonically_linear_ordered_monoid (option (option congr_arg_kind)))) : totally_disconnected_space (canonically_linear_ordered_monoid (option (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_142467 (h0 : function.extfun Type ring) : @is_domain.{0} (has_top.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_top.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_142468 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (metric_space num)) := sorry --non-trivial
lemma new_lemma_142469 (h0 : ring (linear_ordered_field (option ennreal))) : rank_condition (linear_ordered_field (option ennreal)) := sorry --non-trivial
lemma new_lemma_142470 (h0 : finset (ordered_comm_ring (has_add pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_142471 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_142472 (h0 : not (ring (has_append fun_info) -> false)) : @rank_condition.{0} (has_append.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (has_append.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_142473 (h0 : cancel_comm_monoid_with_zero (semigroup (has_add Type))) : unique_factorization_monoid (semigroup (has_add Type)) := sorry --non-trivial
lemma new_lemma_142474 (h0 : prod (has_Sup empty) (has_Sup empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_142475 (h0 : functor.add_const (topological_space (comm_group ennreal)) unsigned) : @sequential_space.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_142476 (h0 : functor.add_const (topological_space (has_to_string pos)) linarith.comp) : @regular_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_142477 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space to_additive.value_type))) : is_compactly_generated (measurable_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_142478 (h0 : ring (has_nndist (finset (normed_comm_ring (finset Type))))) : is_principal_ideal_ring (has_nndist (finset (normed_comm_ring (finset Type)))) := sorry --non-trivial
lemma new_lemma_142479 (h0 : ring (ordered_cancel_add_comm_monoid (option pos))) : rank_condition (ordered_cancel_add_comm_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_142480 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_star.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_star.{0} num))  := sorry --non-trivial
lemma new_lemma_142481 (h0 : topological_space (topological_space (fintype linarith.comp_source))) : path_connected_space (topological_space (fintype linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_142482 (h2 : complete_lattice linarith.ineq) : complete_lattice.is_Sup_finite_compact linarith.ineq := sorry --non-trivial
lemma new_lemma_142483 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_142484 (h0 : has_mem.mem (random_gen linarith.comp) has_emptyc.emptyc) : @normal_space.{0} (random_gen.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_142485 (h0 : cancel_comm_monoid_with_zero (ordered_comm_monoid name)) : unique_factorization_monoid (ordered_comm_monoid name) := sorry --non-trivial
lemma new_lemma_142486 (h0 : functor.add_const (ring (complete_distrib_lattice pos)) pos) : @strong_rank_condition.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_142487 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) pos) : @preconnected_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_142488 (h0 : functor.add_const (topological_space (has_nndist pos)) (boolean_algebra (has_to_string name))) : @loc_path_connected_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) (boolean_algebra.{0} (has_to_string.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_142489 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (left_cancel_semigroup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (left_cancel_semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_142490 (h0 : list (add_cancel_monoid (finset (finset (finset name))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_142491 (h0 : list (normed_comm_ring (has_neg_part Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_142492 (h0 : not (topological_space (left_cancel_semigroup empty) -> false)) : @irreducible_space.{0} (left_cancel_semigroup.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (left_cancel_semigroup.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_142493 (h0 : ring (has_compl (random_gen (random_gen (has_nnnorm to_additive.value_type))))) : strong_rank_condition (has_compl (random_gen (random_gen (has_nnnorm to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_142494 (h0 : topological_space (has_neg (finset (finset (finset ennreal))))) : totally_separated_space (has_neg (finset (finset (finset ennreal)))) := sorry --non-trivial
lemma new_lemma_142495 (h0 : not (add_group (linear_ordered_comm_ring num) -> false)) : @is_add_cyclic.{0} (linear_ordered_comm_ring.{0} num) (@classical.by_contradiction'.{1} (add_group.{0} (linear_ordered_comm_ring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_142496 (h0 : functor.add_const (complete_lattice (complete_distrib_lattice Type)) name) : @is_compactly_generated.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (complete_distrib_lattice.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_142497 (h0 : has_mem.mem (with_one linarith.comp_source) has_emptyc.emptyc) : @totally_separated_space.{0} (with_one.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_142498 (h0 : functor.comp topological_space canonically_linear_ordered_monoid unsigned) : @regular_space.{0} (canonically_linear_ordered_monoid.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_linear_ordered_monoid.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_142499 (h0 : monoid (measurable_space (random_gen (random_gen fun_info)))) : monoid.fg (measurable_space (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_142500 (h0 : complete_lattice (has_neg (comm_group (has_neg_part Type)))) : is_compactly_generated (has_neg (comm_group (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_142501 (h0 : std_gen -> std_gen -> std_gen) (h1 : std_gen) : right_identity h0 h1 := sorry --non-trivial
lemma new_lemma_142502 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (dlist.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (dlist.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_142503 (h0 : function.extfun nat fin) : @is_cyclic.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (group.{1} (normed_lattice_add_comm_group.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_142504 (h0 : not (topological_space (has_emptyc linarith.ineq) -> false)) : @path_connected_space.{0} (has_emptyc.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_142505 (h0 : ring (add_right_cancel_monoid (semiring unsigned))) : rank_condition (add_right_cancel_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_142506 (h0 : topological_space (linear_ordered_add_comm_group (has_top linarith.comp_source))) : path_connected_space (linear_ordered_add_comm_group (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_142507 (h0 : ring (sub_neg_monoid (has_Inf real))) : rank_condition (sub_neg_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_142508 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (measurable_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_142509 (h0 : uniform_space (semi_normed_comm_ring std_gen)) : complete_space (semi_normed_comm_ring std_gen) := sorry --non-trivial
lemma new_lemma_142510 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (ordered_cancel_add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (ordered_cancel_add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_142511 (h0 : fin has_zero.zero) : @unique_factorization_monoid.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (cancel_comm_monoid_with_zero.{1} (ordered_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_142512 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system congr_arg_kind)) unsigned) : @totally_separated_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_142513 (h0 : function.extfun Type topological_space) : @t1_space.{0} (add_cancel_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_142514 (h0 : topological_space (add_cancel_monoid (option (option num)))) : preconnected_space (add_cancel_monoid (option (option num))) := sorry --non-trivial
lemma new_lemma_142515 (h0 : topological_space (has_neg (has_add (has_add (has_add unsigned))))) : irreducible_space (has_neg (has_add (has_add (has_add unsigned)))) := sorry --non-trivial
lemma new_lemma_142516 (h1 : topological_space ereal) : totally_disconnected_space ereal := sorry --non-trivial
lemma new_lemma_142517 (h0 : ring (pseudo_metric_space ennreal)) : strong_rank_condition (pseudo_metric_space ennreal) := sorry --non-trivial
lemma new_lemma_142518 (h0 : topological_space (has_add congr_arg_kind)) : totally_separated_space (has_add congr_arg_kind) := sorry --non-trivial
lemma new_lemma_142519 (h0 : topological_space (has_top (semiring (semiring (semiring congr_arg_kind))))) : path_connected_space (has_top (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_142520 (h0 : topological_space (has_nndist (add_comm_monoid environment.implicit_infer_kind))) : locally_compact_space (has_nndist (add_comm_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_142521 (h0 : not (topological_space (linear_ordered_comm_ring num) -> false)) : @topological_space.separable_space.{0} (linear_ordered_comm_ring.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_ring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_142522 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (add_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (add_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_142523 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_142524 (h0 : topological_space (has_pos_part (ring linarith.comp))) : regular_space (has_pos_part (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_142525 (h0 : uniform_space (canonically_ordered_monoid (canonically_ordered_monoid (has_Inf Type)))) : separated_space (canonically_ordered_monoid (canonically_ordered_monoid (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_142526 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 string_imp) := sorry --non-trivial
lemma new_lemma_142527 (h0 : functor.add_const Prop (has_nndist linarith.comp)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_142528 (h0 : uniform_space (has_Inf (has_add pos))) : separated_space (has_Inf (has_add pos)) := sorry --non-trivial
lemma new_lemma_142529 (h0 : group (boolean_algebra.core name)) : group.fg (boolean_algebra.core name) := sorry --non-trivial
lemma new_lemma_142530 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) (has_zero (has_zero (has_zero pos)))) : @regular_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) (has_zero.{0} (has_zero.{0} (has_zero.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_142531 (h0 : prod (has_dist empty) (has_dist empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_142532 (h0 : ring (has_star (semiring (semiring unsigned)))) : is_principal_ideal_ring (has_star (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_142533 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) pos) : @totally_disconnected_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_142534 (h0 : fin has_zero.zero) : @sequential_space.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_142535 (h0 : group (boolean_algebra.core (boolean_algebra.core pos))) : group.fg (boolean_algebra.core (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_142536 (h0 : functor.add_const (filter (finset name)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_142537 (h0 : functor.add_const (monoid (has_neg linarith.comp)) name) : @monoid.fg.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (has_neg.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_142538 (h0 : ring (has_neg (semigroup linarith.comp))) : is_principal_ideal_ring (has_neg (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_142539 (h0 : complete_lattice (ring (boolean_algebra linarith.comp))) : is_compactly_generated (ring (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_142540 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type semiring.{0} h0 (semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_142541 (h3 : topological_space linarith.ineq) : locally_compact_space linarith.ineq := sorry --non-trivial
lemma new_lemma_142542 (h0 : semiring (has_ssubset (mul_one_class (add_comm_semigroup linarith.ineq)))) (h1 : ideal (has_ssubset (mul_one_class (add_comm_semigroup linarith.ineq)))) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_142543 (h0 : uniform_space (has_bot (option empty))) : separated_space (has_bot (option empty)) := sorry --non-trivial
lemma new_lemma_142544 (h1 : non_assoc_semiring char -> linarith.ineq -> linarith.ineq) (h2 : linarith.ineq -> linarith.ineq -> Prop) : contravariant_class (non_assoc_semiring char) linarith.ineq h1 h2 := sorry --non-trivial
lemma new_lemma_142545 (h1 : complete_lattice (distrib string_imp)) : complete_lattice.is_Sup_finite_compact (distrib string_imp) := sorry --non-trivial
lemma new_lemma_142546 (h0 : complete_lattice (normed_group (random_gen (random_gen fun_info)))) : complete_lattice.is_Sup_finite_compact (normed_group (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_142547 (h0 : monoid (normed_lattice_add_comm_group (has_bot (has_bot (sub_neg_monoid real))))) : monoid.fg (normed_lattice_add_comm_group (has_bot (has_bot (sub_neg_monoid real)))) := sorry --non-trivial
lemma new_lemma_142548 (h0 : functor.add_const (add_group (semigroup pos)) (has_add (has_add (has_add pos)))) : @is_add_cyclic.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} pos)) (has_add.{0} (has_add.{0} (has_add.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_142549 (h0 : measurable_space char) (h1 : filter char) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_142550 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) linarith.comp) : @discrete_topology.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_142551 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_cyclic.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) group.{0}) (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_142552 (h0 : functor.add_const (monoid (semigroup name)) name) : @monoid.fg.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (semigroup.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_142553 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (@id.{2} Type linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (@id.{2} Type linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_142554 (h0 : functor.add_const (function.extfun (Type 1) finset) (ring pos)) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_142555 (h0 : group (add_comm_monoid (finset pos))) : group.fg (add_comm_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_142556 (h0 : function.extfun Type ring) : @is_domain.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type ring.{0} h0 environment.implicit_infer_kind)  := sorry --non-trivial
lemma new_lemma_142557 (h2 : ring (linear_ordered_comm_group_with_zero to_additive.value_type)) : rank_condition (linear_ordered_comm_group_with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_142558 (h1 : not (topological_space (simple_graph reducibility_hints) -> false)) : @t0_space.{0} (simple_graph.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (simple_graph.{0} reducibility_hints)) h1)  := sorry --non-trivial
lemma new_lemma_142559 (h0 : function.extfun Type ring) : @rank_condition.{0} (measurable_space.dynkin_system.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (measurable_space.dynkin_system.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_142560 (h0 : group (boolean_algebra (add_cancel_monoid Type))) : group.fg (boolean_algebra (add_cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_142561 (h0 : generalized_boolean_algebra real -> generalized_boolean_algebra real -> Prop) : total h0 := sorry --non-trivial
lemma new_lemma_142562 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_142563 (h0 : functor.add_const (add_group auto.case_option) (option num)) : @is_add_cyclic.{0} auto.case_option (@functor.add_const.run.{0 0} (add_group.{0} auto.case_option) (option.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_142564 (h0 : functor.add_const (list (add_comm_monoid pos)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_142565 (h0 : functor.add_const (monoid (add_left_cancel_semigroup empty)) (semiring unsigned)) : @monoid.fg.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (add_left_cancel_semigroup.{0} empty)) (semiring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_142566 (h0 : functor.add_const (uniform_space (add_comm_monoid pos)) environment.implicit_infer_kind) : @complete_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_comm_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_142567 (h0 : add_group (with_one (has_inv fun_info))) : is_add_cyclic (with_one (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_142568 (h0 : ring (canonically_ordered_add_monoid (option (option unsigned)))) : is_principal_ideal_ring (canonically_ordered_add_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_142569 (h0 : uniform_space (complete_distrib_lattice (option (option (option empty))))) : separated_space (complete_distrib_lattice (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_142570 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_142571 (h0 : set (has_lt (has_div enat))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_142572 (h0 : topological_space (has_nndist (comm_group name))) : loc_path_connected_space (has_nndist (comm_group name)) := sorry --non-trivial
lemma new_lemma_142573 (h0 : filter (metric_space (semiring (semiring (semiring (semiring (semiring (semiring (semiring unsigned))))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_142574 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} char) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_norm.{0} char))  := sorry --non-trivial
lemma new_lemma_142575 (h0 : functor.add_const (group (boolean_algebra linarith.comp)) pos) : @is_cyclic.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_142576 (h2 : topological_space string.iterator_imp) : t0_space string.iterator_imp := sorry --non-trivial
lemma new_lemma_142577 (h0 : functor.add_const (topological_space (has_dist unsigned)) unsigned) : @preirreducible_space.{0} (has_dist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_142578 (h1 : group (with_one (random_gen string_imp))) : group.fg (with_one (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_142579 (h0 : topological_space (has_neg name)) : locally_compact_space (has_neg name) := sorry --non-trivial
lemma new_lemma_142580 (h0 : topological_space (has_Inf (has_add pos))) : t1_space (has_Inf (has_add pos)) := sorry --non-trivial
lemma new_lemma_142581 (h0 : topological_space (measure_theory.measure_space (semiring (semiring empty)))) : discrete_topology (measure_theory.measure_space (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_142582 (h1 : uniform_space (measure_theory.measure_space linarith.ineq)) : complete_space (measure_theory.measure_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_142583 (h0 : set (has_div (mul_one_class linarith.ineq))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_142584 (h0 : finset (normed_comm_ring (add_comm_monoid environment.implicit_infer_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_142585 (h0 : monoid (has_to_string (finset Type))) : monoid.fg (has_to_string (finset Type)) := sorry --non-trivial
lemma new_lemma_142586 (h0 : filter (fintype (has_ssubset (has_ssubset linarith.comp_source)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_142587 (h1 : set (string -> std_gen)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_142588 (h0 : topological_space (has_ssubset (has_ssubset to_additive.value_type))) : totally_disconnected_space (has_ssubset (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_142589 (h0 : set (add_comm_semigroup (mul_one_class string.iterator_imp))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_142590 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (dlist.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (dlist.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_142591 (h1 : topological_space (semiring (semiring linarith.comp))) : irreducible_space (semiring (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_142592 (h0 : has_lt (has_compl string_imp)) : no_max_order (has_compl string_imp) := sorry --non-trivial
lemma new_lemma_142593 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (uniform_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (uniform_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_142594 (h0 : not (multiset stieltjes_function -> false)) (h1 : multiset stieltjes_function) : multiset.disjoint (classical.by_contradiction' h0) h1 := sorry --non-trivial
lemma new_lemma_142595 (h0 : uniform_space (left_cancel_semigroup (semiring (semiring num)))) : separated_space (left_cancel_semigroup (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_142596 (h1 : function.extfun Type topological_space) : @totally_separated_space.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_142597 (h1 : pfun (mul_one_class (mul_one_class ereal)) Prop) (h2 : coe_sort (pfun.dom h1)) : pfun.as_subtype h1 h2 := sorry --non-trivial
lemma new_lemma_142598 (h0 : functor.comp list has_neg linarith.comp) : list.nodup (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_142599 (h0 : group (complete_semilattice_Sup (random_gen linarith.ineq))) : group.fg (complete_semilattice_Sup (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_142600 (h0 : topological_space (boolean_algebra (boolean_algebra linarith.comp))) : path_connected_space (boolean_algebra (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_142601 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (pseudo_metric_space.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (pseudo_metric_space.{0} name))  := sorry --non-trivial
lemma new_lemma_142602 (h0 : topological_space (has_add (has_add linarith.comp))) : loc_path_connected_space (has_add (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_142603 (h0 : functor.add_const (filter pos) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_142604 (h0 : semiring (ring (option unsigned))) : is_noetherian_ring (ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_142605 (h0 : functor.add_const (monoid (has_nndist pos)) name) : @monoid.fg.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (has_nndist.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_142606 (h1 : function.extfun Type group) : @is_cyclic.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type group.{0} h1 (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_142607 (h0 : topological_space (has_inv (random_gen (random_gen linarith.ineq)))) : totally_disconnected_space (has_inv (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_142608 (h0 : complete_lattice (comm_ring (has_norm linarith.ineq))) : complete_lattice.is_Sup_finite_compact (comm_ring (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_142609 (h1 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_142610 (h0 : topological_space (measure_theory.measure_space congr_arg_kind)) : totally_separated_space (measure_theory.measure_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_142611 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_neg.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} ennreal))))))))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} ennreal))))))))))  := sorry --non-trivial
lemma new_lemma_142612 (h0 : group (has_neg (has_to_string (has_pos_part linarith.comp)))) : normalizer_condition (has_neg (has_to_string (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_142613 (h0 : functor.add_const (group (finset linarith.comp)) Type) : @is_cyclic.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (finset.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_142614 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) (ring (has_neg name))) : @totally_disconnected_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) (ring.{0} (has_neg.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_142615 (h0 : function.extfun Type group) : @group.fg.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} h0 (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_142616 (h0 : topological_space (has_bot (has_pos_part Type))) : discrete_topology (has_bot (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_142617 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (@id.{2} Type to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_142618 (h1 : ring (distrib (comm_ring (comm_ring char)))) : rank_condition (distrib (comm_ring (comm_ring char))) := sorry --non-trivial
lemma new_lemma_142619 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_142620 (h0 h1 : multiset (add_comm_semigroup reducibility_hints)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_142621 (h0 : functor.add_const (monoid (has_neg_part environment.implicit_infer_kind)) (boolean_algebra pos)) : @monoid.fg.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (has_neg_part.{0} environment.implicit_infer_kind)) (boolean_algebra.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_142622 (h0 : cancel_comm_monoid_with_zero (has_Inf (has_add linarith.comp))) : unique_factorization_monoid (has_Inf (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_142623 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_142624 (h0 : has_coe fun_info Prop) (h7 : fun_info) : @coe_b.{1 1} fun_info Prop h0 h7  := sorry --non-trivial
lemma new_lemma_142625 (h0 : group (measurable_space (random_gen (random_gen (random_gen num))))) : normalizer_condition (measurable_space (random_gen (random_gen (random_gen num)))) := sorry --non-trivial
lemma new_lemma_142626 (h0 : topological_space (has_bot (option (option (option empty))))) : locally_compact_space (has_bot (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_142627 (h0 : has_add (linear_ordered_comm_group_with_zero string_imp)) (h1 : complete_lattice (add_con (linear_ordered_comm_group_with_zero string_imp))) : complete_lattice.is_Sup_finite_compact (add_con (linear_ordered_comm_group_with_zero string_imp)) := sorry --non-trivial
lemma new_lemma_142628 (h0 : functor.add_const (ring (has_Inf linarith.comp)) name) : @is_principal_ideal_ring.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_Inf.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_142629 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @totally_separated_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_142630 (h0 : not (topological_space (has_Sup congr_arg_kind) -> false)) : @totally_separated_space.{0} (has_Sup.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_Sup.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_142631 (h0 : function.extfun num (fun (x : num), Prop)) : zzz_forall (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_142632 (h0 : complete_lattice (has_neg_part (semigroup Type))) : is_atomistic (has_neg_part (semigroup Type)) := sorry --non-trivial
lemma new_lemma_142633 (h0 : ordered_comm_monoid (canonically_linear_ordered_monoid (boolean_algebra real))) : has_exists_mul_of_le (canonically_linear_ordered_monoid (boolean_algebra real)) := sorry --non-trivial
lemma new_lemma_142634 (h0 : group (normed_group (semiring (semiring unsigned)))) : group.fg (normed_group (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_142635 (h0 : uniform_space (normed_group (has_inv linarith.comp_source))) : complete_space (normed_group (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_142636 (h1 : ring (comm_ring (random_gen char))) : strong_rank_condition (comm_ring (random_gen char)) := sorry --non-trivial
lemma new_lemma_142637 (h0 : complete_lattice (measure_theory.measure_space (semiring (semiring (semiring unsigned))))) : is_compactly_generated (measure_theory.measure_space (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_142638 (h0 : not (topological_space (semi_normed_comm_ring (has_ssubset string_imp)) -> false)) : @t0_space.{0} (semi_normed_comm_ring.{0} (has_ssubset.{0} string_imp)) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_comm_ring.{0} (has_ssubset.{0} string_imp))) h0)  := sorry --non-trivial
lemma new_lemma_142639 (h0 : ordered_comm_monoid (has_Inf (ordered_ring (has_Inf pos)))) : has_exists_mul_of_le (has_Inf (ordered_ring (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_142640 (h0 : ring (ring pos)) : strong_rank_condition (ring pos) := sorry --non-trivial
lemma new_lemma_142641 (h0 : ring (has_top (complete_semilattice_Sup num))) : strong_rank_condition (has_top (complete_semilattice_Sup num)) := sorry --non-trivial
lemma new_lemma_142642 (h0 : topological_space (has_neg_part (has_add name))) : sequential_space (has_neg_part (has_add name)) := sorry --non-trivial
lemma new_lemma_142643 (h0 : topological_space (boolean_algebra.core (has_neg_part pos))) : totally_disconnected_space (boolean_algebra.core (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_142644 (h1 : topological_space (add_comm_semigroup fun_info)) : topological_space.first_countable_topology (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_142645 (h0 : functor.add_const (list (left_cancel_semigroup empty)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_142646 (h0 : group (has_emptyc linarith.ineq)) : normalizer_condition (has_emptyc linarith.ineq) := sorry --non-trivial
lemma new_lemma_142647 (h0 : topological_space (add_right_cancel_monoid congr_arg_kind)) : totally_disconnected_space (add_right_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_142648 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (normed_comm_ring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_comm_ring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_142649 (h0 : topological_space (canonically_ordered_monoid Type)) : path_connected_space (canonically_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_142650 (h0 : group (with_one linarith.ineq)) : is_cyclic (with_one linarith.ineq) := sorry --non-trivial
lemma new_lemma_142651 (h0 : topological_space (canonically_linear_ordered_monoid linarith.comp)) : normal_space (canonically_linear_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_142652 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_142653 (h0 : topological_space (has_add ennreal)) : sequential_space (has_add ennreal) := sorry --non-trivial
lemma new_lemma_142654 (h0 : add_monoid (is_R_or_C empty)) : add_monoid.fg (is_R_or_C empty) := sorry --non-trivial
lemma new_lemma_142655 (h0 : complete_lattice (comm_ring (random_gen (random_gen (random_gen char))))) : complete_lattice.is_Sup_finite_compact (comm_ring (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_142656 (h0 : cancel_comm_monoid_with_zero (has_union num)) : unique_factorization_monoid (has_union num) := sorry --non-trivial
lemma new_lemma_142657 (h0 : complete_lattice (with_one (random_gen string_imp))) : is_compactly_generated (with_one (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_142658 (h1 : ring (has_append (random_gen (random_gen (random_gen char))))) : strong_rank_condition (has_append (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_142659 (h0 : ordered_add_comm_monoid (semigroup linarith.comp)) : archimedean (semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_142660 (h0 : functor.comp group has_neg name) : @normalizer_condition.{0} (has_neg.{0} name) (@functor.comp.run.{0 0 0} group.{0} has_neg.{0} name h0)  := sorry --non-trivial
lemma new_lemma_142661 (h0 : add_group (random_gen (has_ssubset char))) : is_add_cyclic (random_gen (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_142662 (h2 : topological_space string_imp) : totally_separated_space string_imp := sorry --non-trivial
lemma new_lemma_142663 (h0 : functor.add_const (topological_space (canonically_ordered_monoid pos)) name) : @normal_space.{0} (canonically_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_142664 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (add_cancel_monoid num)) := sorry --non-trivial
lemma new_lemma_142665 (h0 : topological_space (linear_ordered_comm_group congr_arg_kind)) : preconnected_space (linear_ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_142666 (h0 : measurable_space (nondiscrete_normed_field (mul_one_class linarith.ineq))) (h1 : filter (nondiscrete_normed_field (mul_one_class linarith.ineq))) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_142667 (h0 : not (group (with_one unsigned) -> false)) : @normalizer_condition.{0} (with_one.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (with_one.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_142668 (h0 : cancel_comm_monoid_with_zero (has_star (semiring unsigned))) : unique_factorization_monoid (has_star (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_142669 (h0 : topological_space (linear_ordered_semiring (has_top empty))) : path_connected_space (linear_ordered_semiring (has_top empty)) := sorry --non-trivial
lemma new_lemma_142670 (h0 : ordered_comm_monoid (complete_distrib_lattice (finset name))) : has_exists_mul_of_le (complete_distrib_lattice (finset name)) := sorry --non-trivial
lemma new_lemma_142671 (h0 : functor.add_const (functor.add_const (topological_space Type) name) linarith.comp) : @sequential_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) name (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (topological_space.{1} Type) name) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_142672 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_principal_ideal_ring.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_142673 (h0 : functor.add_const Prop (has_to_string linarith.comp)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_142674 (h0 : functor.add_const (complete_lattice (has_to_string linarith.comp)) linarith.comp) : @is_atomistic.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_142675 (h0 : topological_space (has_compl (normed_field std_gen))) : path_connected_space (has_compl (normed_field std_gen)) := sorry --non-trivial
lemma new_lemma_142676 (h0 : functor.add_const (add_monoid (comm_group unsigned)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (add_monoid.{0} (comm_group.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_142677 (h0 : topological_space (canonically_ordered_monoid (has_neg (has_neg Type)))) : t0_space (canonically_ordered_monoid (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_142678 (h0 : functor.add_const (complete_lattice (ring linarith.comp)) (has_neg name)) : @is_compactly_generated.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} linarith.comp)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_142679 (h0 : topological_space (canonically_ordered_monoid (ordered_comm_monoid (has_pos_part Type)))) : totally_disconnected_space (canonically_ordered_monoid (ordered_comm_monoid (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_142680 (h0 : topological_space (has_zero (option unsigned))) : preirreducible_space (has_zero (option unsigned)) := sorry --non-trivial
lemma new_lemma_142681 (h0 : function.extfun Type multiset) : multiset.nodup (function.extfun_app h0 auto.case_option) := sorry --non-trivial
lemma new_lemma_142682 (h0 : ring (pseudo_metric_space empty)) : is_principal_ideal_ring (pseudo_metric_space empty) := sorry --non-trivial
lemma new_lemma_142683 (h0 : not (function.extfun Type list -> false)) : list.nodup (function.extfun_app (classical.by_contradiction' h0) string_imp) := sorry --non-trivial
lemma new_lemma_142684 (h0 : function.extfun (Type 1) topological_space) : @preconnected_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_142685 (h0 : ordered_add_comm_monoid (add_cancel_monoid (has_nndist (finset environment.implicit_infer_kind)))) : archimedean (add_cancel_monoid (has_nndist (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_142686 (h4 : complete_lattice (has_compl (random_gen (random_gen (random_gen char))))) : complete_lattice.is_Sup_finite_compact (has_compl (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_142687 (h0 : topological_space (random_gen (comm_ring (comm_ring linarith.ineq)))) : t0_space (random_gen (comm_ring (comm_ring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_142688 (h0 : topological_space (group_with_zero (option (option (option ennreal))))) : normal_space (group_with_zero (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_142689 (h0 : uniform_space (with_one (comm_ring (random_gen to_additive.value_type)))) : complete_space (with_one (comm_ring (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_142690 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (normed_group.{0} string_imp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (normed_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_142691 (h0 : topological_space (semigroup (normed_comm_ring name))) : normal_space (semigroup (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_142692 (h0 : not (topological_space (has_top fun_info) -> false)) : @totally_separated_space.{0} (has_top.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_142693 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_domain.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_142694 (h0 : group (linear_ordered_semiring congr_arg_kind)) : normalizer_condition (linear_ordered_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_142695 (h0 : topological_space (boolean_algebra.core name)) : regular_space (boolean_algebra.core name) := sorry --non-trivial
lemma new_lemma_142696 (h0 : topological_space (has_top linarith.comp)) : preirreducible_space (has_top linarith.comp) := sorry --non-trivial
lemma new_lemma_142697 (h0 : topological_space (has_pos_part (ring (has_Inf pos)))) : sequential_space (has_pos_part (ring (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_142698 (h0 : functor.add_const (group (normed_comm_ring pos)) Type) : @normalizer_condition.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (normed_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_142699 (h0 : add_monoid (measure_theory.measure_space empty)) (h1 : has_one (measure_theory.measure_space empty)) : char_zero (measure_theory.measure_space empty) := sorry --non-trivial
lemma new_lemma_142700 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_star num)) unsigned) : @unique_factorization_monoid.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_star.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_142701 (h0 : ring (with_one (has_norm (has_norm (has_norm empty))))) : rank_condition (with_one (has_norm (has_norm (has_norm empty)))) := sorry --non-trivial
lemma new_lemma_142702 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_142703 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_142704 (h0 : functor.add_const (topological_space (comm_group pos)) linarith.comp) : @totally_separated_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_142705 (h0 : add_monoid (canonically_ordered_monoid (has_bot pos))) : add_monoid.fg (canonically_ordered_monoid (has_bot pos)) := sorry --non-trivial
lemma new_lemma_142706 (h0 : list (free_add_monoid num)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_142707 (h0 : topological_space (has_emptyc (has_top linarith.ineq))) : totally_separated_space (has_emptyc (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_142708 (h0 : topological_space (has_sub (semiring (semiring empty)))) : totally_separated_space (has_sub (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_142709 (h0 : topological_space (normed_group (semiring num))) : preirreducible_space (normed_group (semiring num)) := sorry --non-trivial
lemma new_lemma_142710 (h0 : topological_space (has_neg (has_Inf pos))) : preirreducible_space (has_neg (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_142711 (h0 : function.extfun Type topological_space) : @t0_space.{0} (mul_zero_class.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_142712 (h0 : not (group (measurable_space num) -> false)) : @normalizer_condition.{0} (measurable_space.{0} num) (@classical.by_contradiction'.{1} (group.{0} (measurable_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_142713 (h0 : function.extfun Type group) : @is_simple_group.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_142714 (h1 : has_mem.mem (with_one congr_arg_kind) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_one.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_142715 (h0 : topological_space (finset (ring Type))) : loc_path_connected_space (finset (ring Type)) := sorry --non-trivial
lemma new_lemma_142716 (h0 : topological_space (add_cancel_monoid (mul_one_class (mul_one_class linarith.comp)))) : irreducible_space (add_cancel_monoid (mul_one_class (mul_one_class linarith.comp))) := sorry --non-trivial
lemma new_lemma_142717 (h0 : functor.add_const (group (is_R_or_C empty)) unsigned) : @group.fg.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (is_R_or_C.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_142718 (h0 : function.extfun (Type 1) add_monoid) : @add_monoid.fg.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} h0 (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_142719 (h0 : uniform_space (generalized_boolean_algebra Type)) : complete_space (generalized_boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_142720 (h0 : list (dlist (random_gen (has_norm string_imp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_142721 (h0 : functor.comp topological_space cancel_monoid pos) : @regular_space.{0} (cancel_monoid.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_142722 (h0 : complete_lattice (with_bot congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (with_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_142723 (h1 : complete_lattice (random_gen (with_bot (with_bot string_imp)))) : is_compactly_generated (random_gen (with_bot (with_bot string_imp))) := sorry --non-trivial
lemma new_lemma_142724 (h0 : not (topological_space (measure_theory.measure_space empty) -> false)) : @irreducible_space.{0} (measure_theory.measure_space.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (measure_theory.measure_space.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_142725 (h0 : ordered_add_comm_monoid (has_Inf (ring (ring pos)))) : archimedean (has_Inf (ring (ring pos))) := sorry --non-trivial
lemma new_lemma_142726 (h0 : add_group (measurable_space.dynkin_system (semiring num))) : is_add_cyclic (measurable_space.dynkin_system (semiring num)) := sorry --non-trivial
lemma new_lemma_142727 (h0 : list (complete_semilattice_Sup (dlist (has_norm to_additive.value_type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_142728 (h0 : function.extfun Type (functor.add_const (topological_space (comm_monoid empty)))) : @totally_separated_space.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (comm_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_142729 (h0 : group (encodable (has_inv linarith.comp_source))) : group.fg (encodable (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_142730 (h0 : topological_space (comm_semigroup (ordered_comm_monoid pos))) : totally_disconnected_space (comm_semigroup (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_142731 (h0 : function.extfun (set linarith.comp_source) (fun (x : set linarith.comp_source), Prop)) : is_countably_spanning (function.extfun_app h0) := sorry --non-trivial
lemma new_lemma_142732 (h0 : function.extfun Type (functor.comp topological_space boolean_algebra.core)) : @irreducible_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} boolean_algebra.core.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_142733 (h0 : complete_lattice (div_inv_monoid string_imp)) : is_compactly_generated (div_inv_monoid string_imp) := sorry --non-trivial
lemma new_lemma_142734 (h0 : ring (add_group (has_to_string (boolean_algebra.core Type)))) : rank_condition (add_group (has_to_string (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_142735 (h1 : ring linarith.ineq) : strong_rank_condition linarith.ineq := sorry --non-trivial
lemma new_lemma_142736 (h0 : not (uniform_space (ordered_comm_group string_imp) -> false)) : @complete_space.{0} (ordered_comm_group.{0} string_imp) (@classical.by_contradiction'.{1} (uniform_space.{0} (ordered_comm_group.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_142737 (h0 : uniform_space (normed_lattice_add_comm_group (sub_neg_monoid linarith.comp))) : separated_space (normed_lattice_add_comm_group (sub_neg_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_142738 (h0 : std_gen -> std_gen -> std_gen) (h1 : std_gen) : left_identity h0 h1 := sorry --non-trivial
lemma new_lemma_142739 (h0 : topological_space (random_gen (random_gen num))) : locally_compact_space (random_gen (random_gen num)) := sorry --non-trivial
lemma new_lemma_142740 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_142741 (h0 : topological_space (semigroup (comm_group pos))) : totally_separated_space (semigroup (comm_group pos)) := sorry --non-trivial
lemma new_lemma_142742 (h0 : function.extfun (Type 1) ring) : @rank_condition.{1} (plift.{1} congr_arg_kind) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (plift.{1} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_142743 (h0 : not (cancel_comm_monoid_with_zero (has_star unsigned) -> false)) : @unique_factorization_monoid.{0} (has_star.{0} unsigned) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (has_star.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_142744 (h0 : functor.add_const (finset (left_cancel_semigroup unsigned)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_142745 (h0 : functor.add_const (ordered_comm_monoid (complete_distrib_lattice linarith.comp)) Type) : @has_exists_mul_of_le.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (complete_distrib_lattice.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_142746 (h0 : fin has_zero.zero) : @preirreducible_space.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_142747 (h0 : functor.add_const (complete_lattice (normed_linear_ordered_group unsigned)) empty) : @is_compactly_generated.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_linear_ordered_group.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_142748 (h0 : fin has_zero.zero) : @strong_rank_condition.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (ring.{0} (ordered_comm_ring.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_142749 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) name) : @has_exists_mul_of_le.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) name h0) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_142750 (h0 : function.extfun Type group) : @group.fg.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_142751 (h0 : complete_lattice (non_unital_non_assoc_semiring (mul_one_class (mul_one_class enat)))) : is_compactly_generated (non_unital_non_assoc_semiring (mul_one_class (mul_one_class enat))) := sorry --non-trivial
lemma new_lemma_142752 (h0 : topological_space (monoid_with_zero (option pos))) : locally_compact_space (monoid_with_zero (option pos)) := sorry --non-trivial
lemma new_lemma_142753 (h0 : ordered_add_comm_monoid (has_to_string (option ennreal))) : archimedean (has_to_string (option ennreal)) := sorry --non-trivial
lemma new_lemma_142754 (h0 : function.extfun (finset Type) (has_mem.mem (semiring linarith.comp))) : @rank_condition.{0} (semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_142755 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_142756 (h0 : functor.add_const (topological_space (boolean_algebra Type)) (finset (finset pos))) : @discrete_topology.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) (finset.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_142757 (h0 : functor.add_const (topological_space (comm_monoid empty)) empty) : @normal_space.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_142758 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_142759 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) name) : @totally_disconnected_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_142760 (h0 : function.extfun nat fin) : @normalizer_condition.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (group.{0} (complete_distrib_lattice.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_142761 (h0 : ring (comm_group (semiring empty))) : is_principal_ideal_ring (comm_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_142762 (h0 : set (linarith.comp_source -> to_additive.value_type)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_142763 (h0 : filter (measurable_space (random_gen linarith.comp_source))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_142764 (h0 : uniform_space (boolean_algebra Type)) : separated_space (boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_142765 (h0 : functor.add_const (function.extfun Type uniform_space) (has_neg (has_neg name))) : @separated_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) (has_neg.{0} (has_neg.{0} name)) h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_142766 (h0 : has_mem.mem monoid has_emptyc.emptyc) : @monoid.fg.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} h0) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_142767 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (distrib_lattice.{0} linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} h0 (distrib_lattice.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_142768 (h0 : prod (canonically_ordered_comm_semiring (option empty)) (canonically_ordered_comm_semiring (option empty))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_142769 (h0 : ring (has_compl enat)) : strong_rank_condition (has_compl enat) := sorry --non-trivial
lemma new_lemma_142770 (h1 : uniform_space (with_bot to_additive.value_type)) : complete_space (with_bot to_additive.value_type) := sorry --non-trivial
lemma new_lemma_142771 (h0 : topological_space (ordered_comm_monoid (has_Inf (has_add Type)))) : t0_space (ordered_comm_monoid (has_Inf (has_add Type))) := sorry --non-trivial
lemma new_lemma_142772 (h0 : group (normed_group (semiring empty))) : group.fg (normed_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_142773 (h0 : functor.add_const (list (has_nndist name)) pos) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_142774 (h0 : not (add_group (with_bot congr_arg_kind) -> false)) : @is_add_cyclic.{0} (with_bot.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_group.{0} (with_bot.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_142775 (h0 : has_mem.mem (with_bot empty) has_emptyc.emptyc) : @rank_condition.{0} (with_bot.{0} empty) (@finset.pi.empty.{1 0} Type ring.{0} (with_bot.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_142776 (h0 : not (cancel_comm_monoid_with_zero (complete_semilattice_Sup empty) -> false)) : @unique_factorization_monoid.{0} (complete_semilattice_Sup.{0} empty) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (complete_semilattice_Sup.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_142777 (h0 : group (has_neg_part (has_add Type))) : is_cyclic (has_neg_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_142778 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_142779 (h0 : pnat) (h1 : ulower pnat) : pnat.coprime h0 (id (ulower.up h1)) := sorry --non-trivial
lemma new_lemma_142780 (h0 : monoid (id (random_gen (has_norm (has_top linarith.ineq))))) : monoid.fg (id (random_gen (has_norm (has_top linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_142781 (h0 : topological_space (boolean_algebra (finset (ring Type)))) : t0_space (boolean_algebra (finset (ring Type))) := sorry --non-trivial
lemma new_lemma_142782 (h0 : functor.add_const (topological_space (semigroup Type)) linarith.comp) : @locally_compact_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_142783 (h0 : not (topological_space (semiring (random_gen linarith.ineq)) -> false)) : @totally_separated_space.{0} (semiring.{0} (random_gen.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} (random_gen.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_142784 (h0 : complete_lattice (has_one (semiring (semiring (semiring unsigned))))) : is_atomistic (has_one (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_142785 (h0 : topological_space (sub_neg_monoid (has_to_string linarith.comp))) : preconnected_space (sub_neg_monoid (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_142786 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} h0 (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_142787 (h0 : monoid (distrib_lattice (has_inv (has_top (comm_ring to_additive.value_type))))) : monoid.fg (distrib_lattice (has_inv (has_top (comm_ring to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_142788 (h0 : set (has_nnnorm (mul_one_class (mul_one_class (mul_one_class string.iterator_imp))))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_142789 (h0 : topological_space (has_add (option (linear_ordered_comm_monoid_with_zero (option pos))))) : preirreducible_space (has_add (option (linear_ordered_comm_monoid_with_zero (option pos)))) := sorry --non-trivial
lemma new_lemma_142790 (h1 : group (denumerable (random_gen string_imp))) : is_cyclic (denumerable (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_142791 (h0 : list ereal -> list ereal -> Prop) : is_total (list ereal) h0 := sorry --non-trivial
lemma new_lemma_142792 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_142793 (h0 : function.extfun Type group) : @normalizer_condition.{0} (@id.{2} Type (has_top.{0} fun_info)) (@function.extfun_app.{2 1} Type group.{0} h0 (@id.{2} Type (has_top.{0} fun_info)))  := sorry --non-trivial
lemma new_lemma_142794 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_142795 (h0 : add_group (ring (has_pos_part Type))) : is_add_cyclic (ring (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_142796 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_142797 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (comm_ring.{0} (random_gen.{0} to_additive.value_type)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_ring.{0} (random_gen.{0} to_additive.value_type)))  := sorry --non-trivial
lemma new_lemma_142798 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (ring ennreal)) := sorry --non-trivial
lemma new_lemma_142799 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_142800 (h0 : complete_lattice (has_neg (has_add (has_add pos)))) : is_atomistic (has_neg (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_142801 (h0 : complete_lattice (with_bot (random_gen (random_gen (random_gen linarith.comp_source))))) : is_atomistic (with_bot (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_142802 (h0 : functor.add_const (ring (plift empty)) empty) : @strong_rank_condition.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (ring.{1} (plift.{1} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_142803 (h0 : complete_lattice (has_Sup name)) : is_atomistic (has_Sup name) := sorry --non-trivial
lemma new_lemma_142804 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_142805 (h1 : topological_space (complete_semilattice_Sup congr_arg_kind)) : t0_space (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_142806 (h0 : topological_space (measurable_space.dynkin_system (option unsigned))) : preconnected_space (measurable_space.dynkin_system (option unsigned)) := sorry --non-trivial
lemma new_lemma_142807 (h0 : ring (metric_space congr_arg_kind)) : is_principal_ideal_ring (metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_142808 (h0 : function.extfun (Type 1) topological_space) : @preconnected_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_142809 (h0 : functor.add_const (add_group (normed_comm_ring pos)) linarith.comp) : @is_add_cyclic.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (normed_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_142810 (h1 : monoid (linear_ordered_add_comm_group linarith.comp_source)) : monoid.fg (linear_ordered_add_comm_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_142811 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @regular_space.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_142812 (h0 : has_le (add_comm_semigroup (mul_one_class (has_Sup reducibility_hints)))) (h1 : add_comm_semigroup (mul_one_class (has_Sup reducibility_hints))) : is_bot h1 := sorry --non-trivial
lemma new_lemma_142813 (h0 : topological_space (linear_ordered_field (option (has_to_string pos)))) : regular_space (linear_ordered_field (option (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_142814 (h0 : topological_space (boolean_algebra.core (has_add pos))) : normal_space (boolean_algebra.core (has_add pos)) := sorry --non-trivial
lemma new_lemma_142815 (h0 : topological_space (monoid (option congr_arg_kind))) : normal_space (monoid (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_142816 (h1 : topological_space (complete_semilattice_Sup congr_arg_kind)) : totally_separated_space (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_142817 (h0 : topological_space (ring (ring (ring name)))) : totally_separated_space (ring (ring (ring name))) := sorry --non-trivial
lemma new_lemma_142818 (h0 : functor.add_const (uniform_space (ordered_ring empty)) empty) : @separated_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_ring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_142819 (h0 : measurable_space (mul_one_class reducibility_hints)) (h1 : measure_theory.measure (mul_one_class reducibility_hints)) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_142820 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_neg_part.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg_part.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_142821 (h1 : ring (div_inv_monoid string_imp)) : is_domain (div_inv_monoid string_imp) := sorry --non-trivial
lemma new_lemma_142822 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_142823 (h0 : function.extfun nat fin) : @t1_space.{1} (has_nndist.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_nndist.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_142824 (h0 : not (topological_space (option empty) -> false)) : @totally_disconnected_space.{0} (option.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_142825 (h1 : ring (distrib (random_gen char))) : strong_rank_condition (distrib (random_gen char)) := sorry --non-trivial
lemma new_lemma_142826 (h0 : topological_space (ordered_comm_ring pos)) : path_connected_space (ordered_comm_ring pos) := sorry --non-trivial
lemma new_lemma_142827 (h0 : topological_space (add_cancel_monoid (finset linarith.comp))) : loc_path_connected_space (add_cancel_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_142828 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_nnnorm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_nnnorm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_142829 (h0 : functor.add_const (ring (ring environment.implicit_infer_kind)) Type) : @is_principal_ideal_ring.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ring.{0} (ring.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_142830 (h0 : topological_space (finset (finset (finset (finset (finset Type)))))) : totally_separated_space (finset (finset (finset (finset (finset Type))))) := sorry --non-trivial
lemma new_lemma_142831 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_142832 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_142833 (h0 : has_mem.mem (with_one congr_arg_kind) has_emptyc.emptyc) : @path_connected_space.{0} (with_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_142834 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (semigroup unsigned)) := sorry --non-trivial
lemma new_lemma_142835 (h0 : complete_lattice (has_neg_part (finset (finset ennreal)))) : complete_lattice.is_Sup_finite_compact (has_neg_part (finset (finset ennreal))) := sorry --non-trivial
lemma new_lemma_142836 (h0 : functor.add_const (function.extfun Type topological_space) name) : @normal_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_142837 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (partial_order.{0} (semiring.{0} (semiring.{0} empty))) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (partial_order.{0} (semiring.{0} (semiring.{0} empty))))  := sorry --non-trivial
lemma new_lemma_142838 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_142839 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (omega_complete_partial_order.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_142840 (h0 : function.extfun Type group) : @group.fg.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_142841 (h0 : topological_space (complete_distrib_lattice (finset (finset Type)))) : topological_space.separable_space (complete_distrib_lattice (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_142842 (h0 : functor.add_const (uniform_space (ordered_ring empty)) num) : @complete_space.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_ring.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_142843 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (ring num)) := sorry --non-trivial
lemma new_lemma_142844 (h0 : ordered_add_comm_monoid (option (option ennreal))) : archimedean (option (option ennreal)) := sorry --non-trivial
lemma new_lemma_142845 (h0 : topological_space (has_nndist (has_zero pos))) : totally_disconnected_space (has_nndist (has_zero pos)) := sorry --non-trivial
lemma new_lemma_142846 (h1 : topological_space (semi_normed_ring string_imp)) : totally_disconnected_space (semi_normed_ring string_imp) := sorry --non-trivial
lemma new_lemma_142847 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (comm_semigroup.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (comm_semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_142848 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) environment.implicit_infer_kind) : @topological_space.separable_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_142849 (h0 : empty -> congr_arg_kind -> Prop) : relator.right_total h0 := sorry --non-trivial
lemma new_lemma_142850 (h0 : functor.add_const (ring (has_nndist Type)) pos) : @rank_condition.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_nndist.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_142851 (h1 : ring (distrib char)) : rank_condition (distrib char) := sorry --non-trivial
lemma new_lemma_142852 (h0 : complete_lattice (has_norm (has_norm (has_inv string_imp)))) : is_compactly_generated (has_norm (has_norm (has_inv string_imp))) := sorry --non-trivial
lemma new_lemma_142853 (h0 : complete_lattice (ring (boolean_algebra linarith.comp))) : is_atomistic (ring (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_142854 (h1 : ring (has_compl linarith.comp_source)) : is_domain (has_compl linarith.comp_source) := sorry --non-trivial
lemma new_lemma_142855 (h0 : functor.add_const (topological_space (has_add pos)) pos) : @irreducible_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_142856 (h1 : ring (has_lt linarith.ineq)) : is_domain (has_lt linarith.ineq) := sorry --non-trivial
lemma new_lemma_142857 (h0 : topological_space (boolean_algebra (finset name))) : irreducible_space (boolean_algebra (finset name)) := sorry --non-trivial
lemma new_lemma_142858 (h1 : ring (add_left_cancel_monoid char)) : strong_rank_condition (add_left_cancel_monoid char) := sorry --non-trivial
lemma new_lemma_142859 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group to_additive.value_type))) : @is_cyclic.{0} (normed_group.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type group.{0} (normed_group.{0} to_additive.value_type) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} to_additive.value_type)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_142860 (h0 : functor.add_const (topological_space (has_neg_part environment.implicit_infer_kind)) name) : @path_connected_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_142861 (h0 : group (with_bot (has_inv (has_inv (has_inv to_additive.value_type))))) : group.fg (with_bot (has_inv (has_inv (has_inv to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_142862 (h0 : ring (pseudo_metric_space (option unsigned))) : strong_rank_condition (pseudo_metric_space (option unsigned)) := sorry --non-trivial
lemma new_lemma_142863 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_142864 (h1 : not (group (distrib linarith.comp_source) -> false)) : @is_cyclic.{0} (distrib.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (distrib.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_142865 (h0 : topological_space (semiring (semiring num))) : discrete_topology (semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_142866 (h0 : group (boolean_algebra (normed_comm_ring (ring linarith.comp)))) : is_cyclic (boolean_algebra (normed_comm_ring (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_142867 (h0 : topological_space bool) : path_connected_space bool := sorry --non-trivial
lemma new_lemma_142868 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_142869 (h0 : function.extfun Type topological_space) : @normal_space.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_142870 (h0 : function.extfun Type group) : @group.fg.{0} (measurable_space.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} linarith.ineq))))) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} linarith.ineq))))))  := sorry --non-trivial
lemma new_lemma_142871 (h0 : filter (finset (option (option empty)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_142872 (h0 : ring (has_zero (has_neg Type))) : strong_rank_condition (has_zero (has_neg Type)) := sorry --non-trivial
lemma new_lemma_142873 (h0 : group (comm_semigroup real)) : group.fg (comm_semigroup real) := sorry --non-trivial
lemma new_lemma_142874 (h0 : ring (add_right_cancel_monoid (semiring (semiring empty)))) : rank_condition (add_right_cancel_monoid (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_142875 (h1 : set (enat -> string.iterator_imp)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_142876 (h0 : complete_lattice (denumerable char)) : is_compactly_generated (denumerable char) := sorry --non-trivial
lemma new_lemma_142877 (h0 : functor.add_const (filter (has_add linarith.comp)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_142878 (h0 : semiring (add_cancel_monoid (has_to_string unsigned))) : is_noetherian_ring (add_cancel_monoid (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_142879 (h0 : functor.add_const (group (ordered_comm_ring linarith.comp)) linarith.comp) : @normalizer_condition.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (ordered_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_142880 (h0 : topological_space (canonically_ordered_comm_semiring linarith.comp)) : normal_space (canonically_ordered_comm_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_142881 (h0 : is_empty (has_nnnorm char)) (h1 : has_nnnorm char) : @is_domain.{0} (has_append.{0} (comm_ring.{0} (comm_ring.{0} (comm_ring.{0} (has_nnnorm.{0} char))))) (@is_empty.elim'.{1 1} (has_nnnorm.{0} char) (ring.{0} (has_append.{0} (comm_ring.{0} (comm_ring.{0} (comm_ring.{0} (has_nnnorm.{0} char)))))) h0 h1)  := sorry --non-trivial
lemma new_lemma_142882 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (mul_zero_class.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (mul_zero_class.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_142883 (h0 : functor.add_const (functor.add_const (list Prop) pos) linarith.comp) : list.head (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_142884 (h1 : topological_space (mul_one_class reducibility_hints)) : totally_disconnected_space (mul_one_class reducibility_hints) := sorry --non-trivial
lemma new_lemma_142885 (h0 : set (add_comm_semigroup linarith.ineq -> linarith.ineq)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_142886 (h0 : ring (pseudo_metric_space empty)) : rank_condition (pseudo_metric_space empty) := sorry --non-trivial
lemma new_lemma_142887 (h0 : topological_space (add_cancel_monoid (has_add unsigned))) : topological_space.separable_space (add_cancel_monoid (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_142888 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @preirreducible_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_142889 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (dlist.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (dlist.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_142890 (h0 : group (dlist linarith.ineq)) : is_cyclic (dlist linarith.ineq) := sorry --non-trivial
lemma new_lemma_142891 (h0 : function.extfun Type group) : @group.fg.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_142892 (h0 : function.extfun Type (functor.add_const (uniform_space Type))) : @separated_space.{1} Type (@functor.add_const.run.{1 0} (uniform_space.{1} Type) name (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (uniform_space.{1} Type)) h0 name))  := sorry --non-trivial
lemma new_lemma_142893 (h0 : functor.add_const (uniform_space (has_zero Type)) pos) : @separated_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_zero.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_142894 (h0 : has_lt (has_mod linarith.ineq)) : no_max_order (has_mod linarith.ineq) := sorry --non-trivial
lemma new_lemma_142895 (h0 : functor.add_const (group (boolean_algebra pos)) (has_zero Type)) : @group.fg.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (boolean_algebra.{0} pos)) (has_zero.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_142896 (h2 : filter (dlist (denumerable to_additive.value_type))) : filter.ne_bot h2 := sorry --non-trivial
lemma new_lemma_142897 (h0 : semiring (has_Inf (has_pos_part linarith.comp))) : is_noetherian_ring (has_Inf (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_142898 (h0 : not (group (linear_ordered_semiring congr_arg_kind) -> false)) : @normalizer_condition.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_142899 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_142900 (h0 : functor.add_const Prop (finset (finset pos))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_142901 (h0 : ring (add_comm_monoid (comm_group name))) : rank_condition (add_comm_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_142902 (h0 : topological_space (has_zero name)) : locally_compact_space (has_zero name) := sorry --non-trivial
lemma new_lemma_142903 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_142904 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_142905 (h0 : functor.add_const (uniform_space (add_comm_monoid name)) pos) : @separated_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_comm_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_142906 (h0 : filter (dlist (fintype linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_142907 (h0 : functor.add_const (complete_lattice (comm_group pos)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (comm_group.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_142908 (h0 : topological_space (boolean_algebra.core (option (option unsigned)))) : locally_compact_space (boolean_algebra.core (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_142909 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (ring pos)) := sorry --non-trivial
lemma new_lemma_142910 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (finset (has_to_string Type))) : @discrete_topology.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) (finset.{1} (has_to_string.{1} Type)) h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_142911 (h0 : topological_space (comm_monoid (option empty))) : normal_space (comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_142912 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) (has_neg (has_neg Type))) : @preconnected_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ordered_comm_ring.{1} Type)) (has_neg.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_142913 (h0 : functor.add_const (ring (comm_group pos)) (has_neg_part Type)) : @rank_condition.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (comm_group.{0} pos)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_142914 (h0 : complete_lattice (has_top (has_ssubset (has_inv (has_top linarith.ineq))))) : is_compactly_generated (has_top (has_ssubset (has_inv (has_top linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_142915 (h0 : topological_space (ordered_cancel_add_comm_monoid num)) : normal_space (ordered_cancel_add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_142916 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} pos (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) pos)  := sorry --non-trivial
lemma new_lemma_142917 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (add_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_142918 (h0 : complete_lattice (has_top (has_top linarith.ineq))) : is_compactly_generated (has_top (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_142919 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_neg.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_142920 (h1 : has_mem.mem num has_emptyc.emptyc) : @normalizer_condition.{0} num (@finset.pi.empty.{1 0} Type group.{0} num h1)  := sorry --non-trivial
lemma new_lemma_142921 (h0 : topological_space (semigroup (has_neg linarith.comp))) : topological_space.separable_space (semigroup (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_142922 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (add_comm_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_142923 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_star.{0} (left_cancel_monoid.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_star.{0} (left_cancel_monoid.{0} empty)))  := sorry --non-trivial
lemma new_lemma_142924 (h0 : topological_space (has_norm (has_top congr_arg_kind))) : discrete_topology (has_norm (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_142925 (h0 : complete_lattice (has_norm (has_top fun_info))) : complete_lattice.is_Sup_finite_compact (has_norm (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_142926 (h1 : group (with_one to_additive.value_type)) : normalizer_condition (with_one to_additive.value_type) := sorry --non-trivial
lemma new_lemma_142927 (h0 : functor.add_const (topological_space (semiring num)) congr_arg_kind) : @topological_space.separable_space.{0} (semiring.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_142928 (h0 : topological_space (boolean_algebra.core (option ennreal))) : locally_compact_space (boolean_algebra.core (option ennreal)) := sorry --non-trivial
lemma new_lemma_142929 (h1 : not (ring (div_inv_monoid to_additive.value_type) -> false)) : @is_domain.{0} (div_inv_monoid.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (div_inv_monoid.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_142930 (h0 : topological_space (preorder num)) : locally_compact_space (preorder num) := sorry --non-trivial
lemma new_lemma_142931 (h0 : functor.add_const (complete_lattice auto.case_option) (option empty)) : @is_atomistic.{0} auto.case_option (@functor.add_const.run.{0 0} (complete_lattice.{0} auto.case_option) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_142932 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_142933 (h0 : ring (id (has_norm (has_norm unsigned)))) : strong_rank_condition (id (has_norm (has_norm unsigned))) := sorry --non-trivial
lemma new_lemma_142934 (h0 : group (boolean_algebra (has_to_string environment.implicit_infer_kind))) : group.fg (boolean_algebra (has_to_string environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_142935 (h0 : enat -> enat -> Prop) (h1 h2 : enat) : eqv_gen h0 h1 h2 := sorry --non-trivial
lemma new_lemma_142936 (h0 : not (topological_space (complete_linear_order congr_arg_kind) -> false)) : @totally_disconnected_space.{0} (complete_linear_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_linear_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_142937 (h0 : functor.add_const (topological_space (add_semigroup unsigned)) empty) : @preirreducible_space.{0} (add_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_142938 (h0 : uniform_space (multiplicative char)) : complete_space (multiplicative char) := sorry --non-trivial
lemma new_lemma_142939 (h0 : group (ordered_comm_monoid (has_add pos))) : is_simple_group (ordered_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_142940 (h0 : add_group (ordered_comm_ring (ring (sub_neg_monoid (has_pos_part name))))) : is_add_cyclic (ordered_comm_ring (ring (sub_neg_monoid (has_pos_part name)))) := sorry --non-trivial
lemma new_lemma_142941 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preconnected_space.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_142942 (h0 : group (monoid empty)) : is_cyclic (monoid empty) := sorry --non-trivial
lemma new_lemma_142943 (h0 : function.extfun Type (prod (semigroup (mul_zero_class (option unsigned))))) : id_rel (function.extfun_app h0 (semigroup (mul_zero_class (option unsigned)))) := sorry --non-trivial
lemma new_lemma_142944 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (canonically_ordered_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_ordered_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_142945 (h0 : functor.add_const (ring ennreal) (option unsigned)) : @strong_rank_condition.{0} ennreal (@functor.add_const.run.{0 0} (ring.{0} ennreal) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_142946 (h0 : topological_space (mul_zero_class Type)) : locally_compact_space (mul_zero_class Type) := sorry --non-trivial
lemma new_lemma_142947 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @topological_space.separable_space.{0} (finset.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (finset.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_142948 (h0 : cancel_comm_monoid_with_zero (comm_group (comm_group name))) : unique_factorization_monoid (comm_group (comm_group name)) := sorry --non-trivial
lemma new_lemma_142949 (h1 : not (ring reducibility_hints -> false)) : @is_domain.{0} reducibility_hints (@classical.by_contradiction'.{1} (ring.{0} reducibility_hints) h1)  := sorry --non-trivial
lemma new_lemma_142950 (h0 : add_monoid (comm_semigroup (sub_neg_monoid (sub_neg_monoid real)))) : add_monoid.fg (comm_semigroup (sub_neg_monoid (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_142951 (h0 : ring (uniform_space num)) : strong_rank_condition (uniform_space num) := sorry --non-trivial
lemma new_lemma_142952 (h0 : linear_ordered_field (ring (option ennreal)) -> linear_ordered_field (ring (option ennreal)) -> Prop) : is_symm (linear_ordered_field (ring (option ennreal))) h0 := sorry --non-trivial
lemma new_lemma_142953 (h0 : ring (has_Sup empty)) : is_principal_ideal_ring (has_Sup empty) := sorry --non-trivial
lemma new_lemma_142954 (h0 : topological_space (cancel_monoid (comm_group name))) : t0_space (cancel_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_142955 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_142956 (h0 : prod (has_top (semiring empty)) (has_top (semiring empty))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_142957 (h0 : function.extfun Type uniform_space) : @separated_space.{0} to_additive.value_type (@function.extfun_app.{2 1} Type uniform_space.{0} h0 to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_142958 (h0 : list (has_nnnorm to_additive.value_type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_142959 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_142960 (h0 : topological_space (canonically_ordered_comm_semiring name)) : t0_space (canonically_ordered_comm_semiring name) := sorry --non-trivial
lemma new_lemma_142961 (h0 : not (topological_space (measure_theory.measure_space num) -> false)) : @preirreducible_space.{0} (measure_theory.measure_space.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (measure_theory.measure_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_142962 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group fun_info))) : @path_connected_space.{0} (normed_group.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_142963 (h0 : functor.comp topological_space normed_comm_ring name) : @topological_space.separable_space.{0} (normed_comm_ring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} normed_comm_ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_142964 (h0 : ring (random_gen string_imp)) : rank_condition (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_142965 (h1 : ring (denumerable (denumerable fun_info))) : is_domain (denumerable (denumerable fun_info)) := sorry --non-trivial
lemma new_lemma_142966 (h0 : semiring (add_cancel_monoid (finset (finset linarith.comp)))) : is_noetherian_ring (add_cancel_monoid (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_142967 (h0 : topological_space (normed_comm_ring linarith.comp)) : topological_space.separable_space (normed_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_142968 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_142969 (h0 : ordered_add_comm_monoid (finset (has_add (has_add (has_neg_part name))))) : archimedean (finset (has_add (has_add (has_neg_part name)))) := sorry --non-trivial
lemma new_lemma_142970 (h0 : add_group (add_cancel_monoid (has_add pos))) : is_add_cyclic (add_cancel_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_142971 (h0 : monoid (preorder (option unsigned))) : monoid.fg (preorder (option unsigned)) := sorry --non-trivial
lemma new_lemma_142972 (h0 : functor.add_const (function.extfun Type add_group) pos) : @is_add_cyclic.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) pos h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_142973 (h0 : functor.add_const (uniform_space (boolean_algebra.core linarith.comp)) environment.implicit_infer_kind) : @complete_space.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.core.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_142974 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_142975 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_142976 (h0 : functor.add_const (monoid (has_pos_part Type)) name) : @monoid.fg.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (has_pos_part.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_142977 (h0 : topological_space (normed_group (has_norm linarith.comp))) : preirreducible_space (normed_group (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_142978 (h0 : topological_space (complete_distrib_lattice (ring Type))) : regular_space (complete_distrib_lattice (ring Type)) := sorry --non-trivial
lemma new_lemma_142979 (h0 : complete_lattice (has_inter (option empty))) : complete_lattice.is_Sup_finite_compact (has_inter (option empty)) := sorry --non-trivial
lemma new_lemma_142980 (h0 : function.extfun (finset Type) (has_mem.mem (has_top empty))) : @t0_space.{0} (has_top.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_142981 (h0 : functor.add_const (function.extfun (Type 1) finset) (finset (finset linarith.comp))) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (semigroup Type)) := sorry --non-trivial
lemma new_lemma_142982 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) name) : @sequential_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_142983 (h0 : functor.add_const (topological_space (sub_neg_monoid linarith.comp)) pos) : @regular_space.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_142984 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_star.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_star.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_142985 (h0 : measurable_space (complete_distrib_lattice (measure_theory.measure_space linarith.comp))) (h1 : has_add (complete_distrib_lattice (measure_theory.measure_space linarith.comp))) : has_measurable_add (complete_distrib_lattice (measure_theory.measure_space linarith.comp)) := sorry --non-trivial
lemma new_lemma_142986 (h0 : topological_space (encodable (has_ssubset (has_nnnorm linarith.comp_source)))) : totally_disconnected_space (encodable (has_ssubset (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_142987 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (canonically_ordered_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_142988 (h0 : ordered_add_comm_monoid (ring (option unsigned))) : archimedean (ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_142989 (h0 : list (has_nndist name)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_142990 (h0 : complete_lattice (has_nnnorm (mul_one_class reducibility_hints))) : complete_lattice.is_Sup_finite_compact (has_nnnorm (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_142991 (h0 : topological_space (has_zero (has_add (finset linarith.comp)))) : totally_separated_space (has_zero (has_add (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_142992 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @irreducible_space.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_linear_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_142993 (h0 : uniform_space (semiring (has_norm to_additive.value_type))) : complete_space (semiring (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_142994 (h0 : topological_space (mul_zero_class (has_top unsigned))) : path_connected_space (mul_zero_class (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_142995 (h0 : not (complete_lattice (linear_ordered_comm_group_with_zero reducibility_hints) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_comm_group_with_zero.{0} reducibility_hints) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_comm_group_with_zero.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_142996 (h0 : functor.add_const (complete_lattice (has_add unsigned)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_add.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_142997 (h1 : not (add_group (semi_normed_ring char) -> false)) : @is_add_cyclic.{0} (semi_normed_ring.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (semi_normed_ring.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_142998 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : regular_space real := sorry --non-trivial
lemma new_lemma_142999 (h0 : has_mem.mem (with_one congr_arg_kind) has_emptyc.emptyc) : @strong_rank_condition.{0} (with_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type ring.{0} (with_one.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_143000 (h0 : filter (mul_zero_class (cancel_monoid (option (finset ennreal))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_143001 (h0 : functor.add_const (topological_space (plift unsigned)) empty) : @irreducible_space.{1} (plift.{1} unsigned) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_143002 (h0 : functor.comp group finset Type) : @is_simple_group.{1} (finset.{1} Type) (@functor.comp.run.{1 1 1} group.{1} finset.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_143003 (h0 : group (has_neg_part (has_add (has_add (has_add Type))))) : normalizer_condition (has_neg_part (has_add (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_143004 (h0 : complete_lattice (finset (has_pos_part linarith.comp))) : is_compactly_generated (finset (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_143005 (h0 : group (linear_ordered_field unsigned)) : is_cyclic (linear_ordered_field unsigned) := sorry --non-trivial
lemma new_lemma_143006 (h0 : functor.add_const (function.extfun (Type -> Type) (function.extfun Type)) empty) : @separated_space.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (semigroup.{0} empty))) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@functor.add_const.run.{1 0} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) empty h0) (functor.add_const.{0 0} (uniform_space.{0} (semigroup.{0} empty)))) empty))  := sorry --non-trivial
lemma new_lemma_143007 (h0 : functor.add_const (ordered_comm_monoid (cancel_monoid environment.implicit_infer_kind)) linarith.comp) : @has_exists_mul_of_le.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_143008 (h0 : fin has_zero.zero) : @is_simple_group.{0} (has_add.{0} pos) (@matrix.vec_empty.{0} (group.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_143009 (h0 : ring (cancel_monoid (option pos))) : is_principal_ideal_ring (cancel_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_143010 (h0 : function.extfun Type (functor.add_const (complete_lattice (normed_linear_ordered_group num)))) : @complete_lattice.is_Sup_finite_compact.{0} (normed_linear_ordered_group.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_linear_ordered_group.{0} num)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (normed_linear_ordered_group.{0} num))) h0 empty))  := sorry --non-trivial
lemma new_lemma_143011 (h0 : topological_space (comm_group (boolean_algebra name))) : preconnected_space (comm_group (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_143012 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_143013 (h0 : topological_space (has_zero (has_to_string (has_to_string pos)))) : t1_space (has_zero (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_143014 (h0 : uniform_space (option (semiring (semiring num)))) : separated_space (option (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_143015 (h0 : prod (finset (has_zero Type)) (finset (has_zero Type))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_143016 (h0 : functor.add_const (topological_space (preorder empty)) num) : @t1_space.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_143017 (h0 : ulower pnat) (h1 : pnat) : id (pnat.coprime (ulower.up h0) h1) := sorry --non-trivial
lemma new_lemma_143018 (h0 : complete_lattice (has_bot (has_Inf real))) : is_atomistic (has_bot (has_Inf real)) := sorry --non-trivial
lemma new_lemma_143019 (h0 : functor.add_const (ring (left_cancel_monoid empty)) (semiring (semiring (semiring empty)))) : @is_principal_ideal_ring.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} empty)) (semiring.{0} (semiring.{0} (semiring.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_143020 (h0 : function.extfun (Type 1) topological_space) : @sequential_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_143021 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_domain.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_143022 (h0 : group fun_info) : group.fg fun_info := sorry --non-trivial
lemma new_lemma_143023 (h0 : topological_space (with_one to_additive.value_type)) : t0_space (with_one to_additive.value_type) := sorry --non-trivial
lemma new_lemma_143024 (h0 : not (topological_space (semiring linarith.ineq) -> false)) : @totally_separated_space.{0} (semiring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_143025 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_star congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_143026 (h0 : cancel_comm_monoid_with_zero (has_add ennreal)) : unique_factorization_monoid (has_add ennreal) := sorry --non-trivial
lemma new_lemma_143027 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (add_comm_monoid.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (add_comm_monoid.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_143028 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) linarith.comp) : @irreducible_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_143029 (h0 : function.extfun nat fin) : @is_add_cyclic.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (add_group.{0} (comm_semigroup.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))))  := sorry --non-trivial
lemma new_lemma_143030 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @totally_separated_space.{0} (has_inv.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (has_inv.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_143031 (h0 : has_mem.mem (with_bot num) has_emptyc.emptyc) : @totally_separated_space.{0} (with_bot.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_143032 (h0 : topological_space (ordered_comm_ring Type)) : preirreducible_space (ordered_comm_ring Type) := sorry --non-trivial
lemma new_lemma_143033 (h0 : functor.add_const (ring (complete_distrib_lattice Type)) pos) : @is_domain.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (complete_distrib_lattice.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_143034 (h0 : ring (has_Inf (has_Inf (finset (has_pos_part pos))))) : rank_condition (has_Inf (has_Inf (finset (has_pos_part pos)))) := sorry --non-trivial
lemma new_lemma_143035 (h0 : uniform_space (has_add (has_Inf (has_Inf Type)))) : separated_space (has_add (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_143036 (h0 : functor.add_const (complete_lattice (option pos)) (option pos)) : @is_compactly_generated.{0} (option.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (option.{0} pos)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_143037 (h0 : ring (add_comm_monoid (option (option (option (option unsigned)))))) : is_domain (add_comm_monoid (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_143038 (h0 : add_group (with_one (random_gen linarith.comp_source))) : is_add_cyclic (with_one (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_143039 (h0 : set (linear_ordered_comm_group_with_zero (mul_one_class (mul_one_class (mul_one_class linarith.comp_source))))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_143040 (h0 : functor.comp topological_space add_comm_monoid (option unsigned)) : @t1_space.{0} (add_comm_monoid.{0} (option.{0} unsigned)) (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_143041 (h0 : fin has_zero.zero) : @rank_condition.{0} (has_add.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_143042 (h0 : topological_space (ordered_comm_monoid (has_add linarith.comp))) : topological_space.separable_space (ordered_comm_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_143043 (h0 : ennreal -> has_zero num -> Prop) : relator.bi_total h0 := sorry --non-trivial
lemma new_lemma_143044 (h0 : functor.add_const (list (has_neg_part environment.implicit_infer_kind)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_143045 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_add linarith.comp)) : @topological_space.separable_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_add.{0} linarith.comp) h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_143046 (h0 : functor.add_const (function.extfun Type add_monoid) name) : @add_monoid.fg.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) name h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_143047 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_143048 (h0 : add_group (has_to_string (boolean_algebra.core (boolean_algebra.core Type)))) : is_add_cyclic (has_to_string (boolean_algebra.core (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_143049 (h0 : group (normed_lattice_add_comm_group congr_arg_kind)) : group.fg (normed_lattice_add_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_143050 (h0 : functor.add_const (complete_lattice (add_cancel_monoid environment.implicit_infer_kind)) pos) : @is_atomistic.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_143051 (h0 : function.extfun Type ring -> Prop) (h1 : Exists (fun (x : function.extfun Type ring), h0 x)) : @rank_condition.{0} (bin_tree.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.some.{2} (function.extfun.{2 1} Type ring.{0}) h0 h1) (bin_tree.{0} num))  := sorry --non-trivial
lemma new_lemma_143052 (h0 : functor.add_const (topological_space (has_neg pos)) (has_neg (has_zero (ring (ring (ring pos)))))) : @locally_compact_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) (has_neg.{0} (has_zero.{0} (ring.{0} (ring.{0} (ring.{0} pos))))) h0)  := sorry --non-trivial
lemma new_lemma_143053 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (complete_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (complete_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_143054 (h0 : set (add_comm_semigroup linarith.comp_source)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_143055 (h0 : topological_space (normed_comm_ring (canonically_ordered_comm_semiring environment.implicit_infer_kind))) : t1_space (normed_comm_ring (canonically_ordered_comm_semiring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_143056 (h0 : functor.add_const (topological_space (has_to_string pos)) linarith.comp) : @normal_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_143057 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @rank_condition.{0} (has_union.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) ring.{0}) (has_union.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_143058 (h0 : ring (complete_semilattice_Sup (semiring num))) : is_domain (complete_semilattice_Sup (semiring num)) := sorry --non-trivial
lemma new_lemma_143059 (h1 h2 : multiset (mul_one_class reducibility_hints)) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_143060 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) environment.implicit_infer_kind) : @topological_space.separable_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_143061 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_inter.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_inter.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_143062 (h0 : topological_space (as_linear_order (comm_monoid (comm_monoid unsigned)))) : locally_compact_space (as_linear_order (comm_monoid (comm_monoid unsigned))) := sorry --non-trivial
lemma new_lemma_143063 (h0 : topological_space (topological_space (has_nnnorm reducibility_hints))) : path_connected_space (topological_space (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_143064 (h2 : topological_space linarith.ineq) (h3 : preorder linarith.ineq) : order_topology linarith.ineq := sorry --non-trivial
lemma new_lemma_143065 (h0 : has_mem.mem group has_emptyc.emptyc) : @is_cyclic.{0} unsigned (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) unsigned)  := sorry --non-trivial
lemma new_lemma_143066 (h0 : has_mem.mem ring has_emptyc.emptyc) : @is_domain.{0} (measurable_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (measurable_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_143067 (h0 : function.extfun Type group) : @group.fg.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_143068 (h0 : topological_space (canonically_ordered_comm_semiring (option empty))) : discrete_topology (canonically_ordered_comm_semiring (option empty)) := sorry --non-trivial
lemma new_lemma_143069 (h0 : ring (normed_group (has_norm (random_gen linarith.ineq)))) : rank_condition (normed_group (has_norm (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_143070 (h0 : function.extfun nat fin) : @is_domain.{0} (boolean_algebra.{0} real) (@matrix.vec_empty.{0} (ring.{0} (boolean_algebra.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_143071 (h0 : functor.add_const (topological_space (semiring congr_arg_kind)) congr_arg_kind) : @t0_space.{0} (semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_143072 (h0 : group (cancel_monoid (simple_graph unsigned))) : is_cyclic (cancel_monoid (simple_graph unsigned)) := sorry --non-trivial
lemma new_lemma_143073 (h0 : topological_space (has_bot pos)) : regular_space (has_bot pos) := sorry --non-trivial
lemma new_lemma_143074 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (ordered_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (ordered_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_143075 (h0 : uniform_space (complete_distrib_lattice (option (option empty)))) : complete_space (complete_distrib_lattice (option (option empty))) := sorry --non-trivial
lemma new_lemma_143076 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @totally_disconnected_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_143077 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_143078 (h0 : complete_lattice (has_div (mul_one_class linarith.ineq))) : is_compactly_generated (has_div (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_143079 (h0 : functor.add_const (list (has_zero linarith.comp)) (has_neg (has_neg (has_neg (has_neg (has_neg linarith.comp)))))) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_143080 (h0 : topological_space (has_inv (denumerable linarith.comp_source))) : t0_space (has_inv (denumerable linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_143081 (h0 : topological_space (normed_field (comm_ring (comm_ring linarith.ineq)))) : t0_space (normed_field (comm_ring (comm_ring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_143082 (h0 : cancel_comm_monoid_with_zero (add_right_cancel_monoid (semiring unsigned))) : unique_factorization_monoid (add_right_cancel_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_143083 (h0 : topological_space (has_to_string (finset pos))) : t0_space (has_to_string (finset pos)) := sorry --non-trivial
lemma new_lemma_143084 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_star.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_star.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_143085 (h0 : not (ring (has_append linarith.comp_source) -> false)) : @rank_condition.{0} (has_append.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (has_append.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_143086 (h0 : group (random_gen (denumerable (denumerable (has_inv linarith.ineq))))) : group.fg (random_gen (denumerable (denumerable (has_inv linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_143087 (h0 : function.extfun (finset Type) (has_mem.mem (has_top unsigned))) : @separated_space.{0} (has_top.{0} unsigned) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} unsigned)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_143088 (h0 : topological_space (semigroup (option (option (option ennreal))))) : totally_separated_space (semigroup (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_143089 (h1 : ring (nondiscrete_normed_field (add_comm_semigroup linarith.ineq))) : is_domain (nondiscrete_normed_field (add_comm_semigroup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_143090 (h0 : topological_space (has_Inf (has_Inf name))) : path_connected_space (has_Inf (has_Inf name)) := sorry --non-trivial
lemma new_lemma_143091 (h0 : topological_space (has_pos_part Type)) : t1_space (has_pos_part Type) := sorry --non-trivial
lemma new_lemma_143092 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_comm_ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_143093 (h0 : list (pseudo_metric_space (option unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_143094 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_neg ennreal)) unsigned) : @unique_factorization_monoid.{0} (has_neg.{0} ennreal) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_neg.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_143095 (h0 : topological_space (has_zero (finset (finset linarith.comp)))) : discrete_topology (has_zero (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_143096 (h0 : functor.add_const (add_monoid (has_nndist pos)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_nndist.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_143097 (h0 : group (random_gen (random_gen (random_gen linarith.ineq)))) : is_cyclic (random_gen (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_143098 (h0 : topological_space (complete_distrib_lattice (has_add real))) : normal_space (complete_distrib_lattice (has_add real)) := sorry --non-trivial
lemma new_lemma_143099 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (cancel_monoid.{0} (option.{0} name)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} (option.{0} name)))  := sorry --non-trivial
lemma new_lemma_143100 (h0 : topological_space (normed_comm_ring (has_to_string (finset environment.implicit_infer_kind)))) : t1_space (normed_comm_ring (has_to_string (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_143101 (h1 : cancel_comm_monoid_with_zero (has_div std_gen)) : unique_factorization_monoid (has_div std_gen) := sorry --non-trivial
lemma new_lemma_143102 (h0 : filter (has_compl (has_inv (has_inv linarith.ineq)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_143103 (h0 : functor.add_const (list (has_zero name)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_143104 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_principal_ideal_ring.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (comm_semigroup.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_143105 (h0 : topological_space (complete_distrib_lattice (has_Inf (has_Inf (has_add Type))))) : preconnected_space (complete_distrib_lattice (has_Inf (has_Inf (has_add Type)))) := sorry --non-trivial
lemma new_lemma_143106 (h0 : topological_space (has_dist (option ennreal))) : t0_space (has_dist (option ennreal)) := sorry --non-trivial
lemma new_lemma_143107 (h0 : topological_space (has_star (option empty))) : t0_space (has_star (option empty)) := sorry --non-trivial
lemma new_lemma_143108 (h0 : functor.add_const (functor.add_const (topological_space pos) name) (option name)) : @regular_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) name (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} pos) name) (option.{0} name) h0))  := sorry --non-trivial
lemma new_lemma_143109 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (uniform_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (uniform_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_143110 (h0 : complete_lattice (simple_graph (non_unital_non_assoc_semiring linarith.ineq))) : complete_lattice.is_Sup_finite_compact (simple_graph (non_unital_non_assoc_semiring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_143111 (h0 : topological_space (uniform_space enat)) : t0_space (uniform_space enat) := sorry --non-trivial
lemma new_lemma_143112 (h0 : function.extfun Type ring) : @is_domain.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_143113 (h0 : cancel_comm_monoid_with_zero (partial_order (has_norm empty))) : unique_factorization_monoid (partial_order (has_norm empty)) := sorry --non-trivial
lemma new_lemma_143114 (h0 : not (topological_space (has_top linarith.comp) -> false)) : @discrete_topology.{0} (has_top.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_143115 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_143116 (h1 : ring (has_append (has_append char))) : is_domain (has_append (has_append char)) := sorry --non-trivial
lemma new_lemma_143117 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_143118 (h0 : function.extfun Type topological_space) : @t0_space.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.dynkin_system.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_143119 (h0 : topological_space (has_pos_part pos)) : regular_space (has_pos_part pos) := sorry --non-trivial
lemma new_lemma_143120 (h0 : functor.add_const (ring (left_cancel_monoid empty)) num) : @is_domain.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_143121 (h0 : topological_space (random_gen linarith.ineq)) (h1 : preorder (random_gen linarith.ineq)) : order_topology (random_gen linarith.ineq) := sorry --non-trivial
lemma new_lemma_143122 (h0 : complete_lattice (has_emptyc (random_gen fun_info))) : is_atomistic (has_emptyc (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_143123 (h1 : set (normed_field to_additive.value_type)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_143124 (h0 : not (complete_lattice (id unsigned) -> false)) : @is_atomistic.{0} (@id.{2} Type unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (@id.{2} Type unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_143125 (h0 : complete_lattice (dlist (has_nnnorm (has_nnnorm (has_inv linarith.ineq))))) : is_compactly_generated (dlist (has_nnnorm (has_nnnorm (has_inv linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_143126 (h0 : topological_space (boolean_algebra.core (option (option ennreal)))) : discrete_topology (boolean_algebra.core (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_143127 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_zero unsigned)) := sorry --non-trivial
lemma new_lemma_143128 (h0 : functor.add_const (topological_space (boolean_algebra.core environment.implicit_infer_kind)) name) : @regular_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_143129 (h0 : functor.add_const (ordered_add_comm_monoid (finset pos)) (finset environment.implicit_infer_kind)) : @archimedean.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (finset.{0} pos)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_143130 (h0 : functor.add_const (function.extfun Type uniform_space) Type) : @separated_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) Type h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_143131 (h0 : topological_space (as_linear_order num)) : t0_space (as_linear_order num) := sorry --non-trivial
lemma new_lemma_143132 (h0 : topological_space (has_Inf (has_neg pos))) : discrete_topology (has_Inf (has_neg pos)) := sorry --non-trivial
lemma new_lemma_143133 (h0 : filter (normed_linear_ordered_group linarith.comp_source)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_143134 (h1 : set (fun_info -> mul_one_class enat)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_143135 (h0 : has_le (mul_one_class fun_info)) (h1 : bounded_order (mul_one_class fun_info)) : is_simple_order (mul_one_class fun_info) := sorry --non-trivial
lemma new_lemma_143136 (h0 : uniform_space (preorder (option (option empty)))) : complete_space (preorder (option (option empty))) := sorry --non-trivial
lemma new_lemma_143137 (h0 : add_group (simple_graph linarith.comp_source)) : is_add_cyclic (simple_graph linarith.comp_source) := sorry --non-trivial
lemma new_lemma_143138 (h0 : ring (ordered_comm_group num)) : is_domain (ordered_comm_group num) := sorry --non-trivial
lemma new_lemma_143139 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_143140 (h2 : topological_space (mul_one_class string.iterator_imp)) : totally_disconnected_space (mul_one_class string.iterator_imp) := sorry --non-trivial
lemma new_lemma_143141 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_143142 (h0 : not (group (normed_field char) -> false)) : @is_cyclic.{0} (normed_field.{0} char) (@classical.by_contradiction'.{1} (group.{0} (normed_field.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_143143 (h0 : not (group (has_norm unsigned) -> false)) : @group.fg.{0} (has_norm.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (has_norm.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_143144 (h0 : functor.add_const (filter (has_zero pos)) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_143145 (h0 : topological_space (add_cancel_monoid (option (option ennreal)))) : discrete_topology (add_cancel_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_143146 (h0 : functor.add_const (topological_space (has_nndist Type)) linarith.comp) : @t0_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_143147 (h0 : topological_space (complete_semilattice_Sup fun_info)) : totally_separated_space (complete_semilattice_Sup fun_info) := sorry --non-trivial
lemma new_lemma_143148 (h0 : functor.add_const (topological_space (left_cancel_monoid empty)) (semiring num)) : @totally_disconnected_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_143149 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_143150 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (random_gen.{0} char) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (random_gen.{0} char))  := sorry --non-trivial
lemma new_lemma_143151 (h0 : fun_info -> fun_info -> Prop) (h1 h2 : fun_info) : eqv_gen h0 h1 h2 := sorry --non-trivial
lemma new_lemma_143152 (h0 : topological_space (add_comm_monoid (has_to_string (has_to_string unsigned)))) : totally_disconnected_space (add_comm_monoid (has_to_string (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_143153 (h0 : uniform_space (has_add (ring pos))) : separated_space (has_add (ring pos)) := sorry --non-trivial
lemma new_lemma_143154 (h0 : topological_space (pseudo_metric_space (has_add (finset pos)))) : path_connected_space (pseudo_metric_space (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_143155 (h0 : topological_space (canonically_ordered_comm_semiring (has_to_string (cancel_monoid (cancel_monoid ennreal))))) : t0_space (canonically_ordered_comm_semiring (has_to_string (cancel_monoid (cancel_monoid ennreal)))) := sorry --non-trivial
lemma new_lemma_143156 (h0 : functor.add_const (topological_space nnreal) empty) : t0_space nnreal := sorry --non-trivial
lemma new_lemma_143157 (h0 : uniform_space (with_one congr_arg_kind)) : separated_space (with_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_143158 (h0 : ring (ring (has_add (ring (ring linarith.comp))))) : is_domain (ring (has_add (ring (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_143159 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @path_connected_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_143160 (h0 : functor.add_const (ordered_comm_monoid (comm_group Type)) (ring name)) : @has_exists_mul_of_le.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (comm_group.{1} Type)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_143161 (h0 : add_group (distrib (has_subset (has_nnnorm linarith.ineq)))) : is_add_cyclic (distrib (has_subset (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_143162 (h0 : topological_space (sub_neg_monoid (has_Inf (has_pos_part Type)))) : locally_compact_space (sub_neg_monoid (has_Inf (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_143163 (h0 : function.extfun (finset Type) (has_mem.mem (with_one congr_arg_kind))) : @separated_space.{0} (with_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type uniform_space.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_143164 (h0 : group (add_cancel_comm_monoid (random_gen reducibility_hints))) : is_cyclic (add_cancel_comm_monoid (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_143165 (h0 : topological_space (has_to_string (ring pos))) : t0_space (has_to_string (ring pos)) := sorry --non-trivial
lemma new_lemma_143166 (h0 : topological_space (add_cancel_monoid (has_add (has_add (has_add Type))))) : irreducible_space (add_cancel_monoid (has_add (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_143167 (h1 : group (normed_group (random_gen string_imp))) : is_cyclic (normed_group (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_143168 (h0 : semiring (normed_comm_ring (comm_group (has_add (has_to_string pos))))) : is_noetherian_ring (normed_comm_ring (comm_group (has_add (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_143169 (h0 : complete_lattice (has_compl (random_gen linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (has_compl (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_143170 (h0 : functor.add_const (functor.add_const (ring environment.implicit_infer_kind) linarith.comp) linarith.comp) : @strong_rank_condition.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (ring.{0} environment.implicit_infer_kind) linarith.comp (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (ring.{0} environment.implicit_infer_kind) linarith.comp) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_143171 (h0 : set (non_unital_non_assoc_semiring (mul_one_class to_additive.value_type))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_143172 (h0 : not (ring (semi_normed_ring reducibility_hints) -> false)) : @strong_rank_condition.{0} (semi_normed_ring.{0} reducibility_hints) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_ring.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_143173 (h0 : list (generalized_boolean_algebra (has_add (has_Inf Type)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_143174 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (ordered_comm_monoid.{1} (simple_graph.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_143175 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (add_comm_monoid num)) := sorry --non-trivial
lemma new_lemma_143176 (h0 : finset (finset pos) -> finset (finset pos) -> Prop) : is_symm (finset (finset pos)) h0 := sorry --non-trivial
lemma new_lemma_143177 (h0 : functor.add_const (complete_lattice (add_cancel_monoid empty)) unsigned) : @is_compactly_generated.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_143178 (h0 : ring (normed_comm_ring (option ennreal))) : is_principal_ideal_ring (normed_comm_ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_143179 (h0 : topological_space (complete_distrib_lattice (has_Inf pos))) : regular_space (complete_distrib_lattice (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_143180 (h0 : functor.add_const (group (has_to_string Type)) pos) : @is_cyclic.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_to_string.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_143181 (h1 : ring (non_unital_non_assoc_semiring linarith.comp_source)) : is_domain (non_unital_non_assoc_semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_143182 (h0 : topological_space (with_bot unsigned)) : topological_space.separable_space (with_bot unsigned) := sorry --non-trivial
lemma new_lemma_143183 (h0 : topological_space (simple_graph (boolean_algebra.core Type))) : preconnected_space (simple_graph (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_143184 (h0 : topological_space (mul_one_class (mul_one_class ereal))) : totally_disconnected_space (mul_one_class (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_143185 (h0 : functor.add_const (ordered_comm_monoid (cancel_monoid name)) (has_add (has_add environment.implicit_infer_kind))) : @has_exists_mul_of_le.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (cancel_monoid.{0} name)) (has_add.{0} (has_add.{0} environment.implicit_infer_kind)) h0)  := sorry --non-trivial
lemma new_lemma_143186 (h0 : functor.add_const (group (add_comm_monoid pos)) (has_neg linarith.comp)) : @is_simple_group.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} pos)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_143187 (h0 : functor.add_const (topological_space (left_cancel_semigroup congr_arg_kind)) empty) : @normal_space.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_143188 (h0 : functor.add_const (function.extfun Type list) (ring Type)) : palindrome (function.extfun_app (functor.add_const.run h0) (ordered_comm_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_143189 (h0 : cancel_comm_monoid_with_zero (normed_linear_ordered_group congr_arg_kind)) : unique_factorization_monoid (normed_linear_ordered_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_143190 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @irreducible_space.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (comm_semigroup.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_143191 (h0 : add_group (mul_zero_class (has_add ennreal))) (h1 : add_subgroup (mul_zero_class (has_add ennreal))) : add_subgroup.is_commutative h1 := sorry --non-trivial
lemma new_lemma_143192 (h0 : topological_space (mul_zero_class (semiring unsigned))) : topological_space.separable_space (mul_zero_class (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_143193 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @preirreducible_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_143194 (h0 : functor.add_const (filter (preorder unsigned)) congr_arg_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_143195 (h0 : add_monoid (canonically_ordered_comm_semiring (option (has_to_string pos)))) : add_monoid.fg (canonically_ordered_comm_semiring (option (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_143196 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_to_string Type)) Type) : @unique_factorization_monoid.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (cancel_comm_monoid_with_zero.{1} (has_to_string.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_143197 (h0 : ring (has_compl linarith.comp_source)) : rank_condition (has_compl linarith.comp_source) := sorry --non-trivial
lemma new_lemma_143198 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) pos) : @discrete_topology.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_143199 (h0 : topological_space (generalized_boolean_algebra pos)) : discrete_topology (generalized_boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_143200 (h1 : add_comm_group (distrib (fintype to_additive.value_type))) (h2 : topological_space (fintype (add_comm_group.positive_cone (distrib (fintype to_additive.value_type))))) : t0_space (fintype (add_comm_group.positive_cone (distrib (fintype to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_143201 (h0 : functor.add_const (functor.add_const (cancel_comm_monoid_with_zero pos) pos) unsigned) : @unique_factorization_monoid.{0} pos (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} pos) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} pos) pos) unsigned h0))  := sorry --non-trivial
lemma new_lemma_143202 (h0 : topological_space (has_one (semiring unsigned))) : t0_space (has_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_143203 (h0 : not (has_mem.mem (has_to_string congr_arg_kind) has_emptyc.emptyc -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_to_string.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_to_string.{0} congr_arg_kind) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_to_string.{0} congr_arg_kind) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_143204 (h0 : topological_space (boolean_algebra.core (has_add environment.implicit_infer_kind))) : path_connected_space (boolean_algebra.core (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_143205 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (add_group unsigned)) := sorry --non-trivial
lemma new_lemma_143206 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm linarith.comp_source))) : @is_domain.{0} (has_norm.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_143207 (h0 : not (uniform_space (mul_one_class to_additive.value_type) -> false)) : @complete_space.{0} (mul_one_class.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (uniform_space.{0} (mul_one_class.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_143208 (h0 : filter (with_bot (semiring num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_143209 (h0 : topological_space (has_emptyc linarith.comp_source)) : locally_compact_space (has_emptyc linarith.comp_source) := sorry --non-trivial
lemma new_lemma_143210 (h0 : complete_lattice (has_inv (random_gen linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (has_inv (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_143211 (h0 : filter (complete_linear_order num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_143212 (h0 : list (add_right_cancel_monoid empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_143213 (h0 : not (topological_space (with_zero to_additive.value_type) -> false)) : @totally_disconnected_space.{0} (with_zero.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (with_zero.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_143214 (h0 : topological_space (add_comm_monoid (mul_zero_class ennreal))) : loc_path_connected_space (add_comm_monoid (mul_zero_class ennreal)) := sorry --non-trivial
lemma new_lemma_143215 (h0 : monoid (has_top (has_union num))) : monoid.fg (has_top (has_union num)) := sorry --non-trivial
lemma new_lemma_143216 (h0 : group (add_cancel_monoid (option name))) : normalizer_condition (add_cancel_monoid (option name)) := sorry --non-trivial
lemma new_lemma_143217 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_inv.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} linarith.comp_source))))) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_inv.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} linarith.comp_source))))))  := sorry --non-trivial
lemma new_lemma_143218 (h0 : group (finset linarith.comp)) : is_cyclic (finset linarith.comp) := sorry --non-trivial
lemma new_lemma_143219 (h0 : ring (normed_lattice_add_comm_group (has_bot real))) : strong_rank_condition (normed_lattice_add_comm_group (has_bot real)) := sorry --non-trivial
lemma new_lemma_143220 (h0 : finset (canonically_ordered_comm_semiring (option pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_143221 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra.core Type)) (ordered_comm_monoid Type)) : @has_exists_mul_of_le.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 1} (ordered_comm_monoid.{1} (boolean_algebra.core.{1} Type)) (ordered_comm_monoid.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_143222 (h0 : group (measure_theory.measure_space unsigned)) : is_cyclic (measure_theory.measure_space unsigned) := sorry --non-trivial
lemma new_lemma_143223 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (linear_ordered_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_143224 (h0 : fin has_zero.zero) : @sequential_space.{0} (finset.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_143225 (h0 : has_le (uniform_space linarith.ineq)) (h1 : uniform_space linarith.ineq) : is_min h1 := sorry --non-trivial
lemma new_lemma_143226 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @is_simple_group.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_143227 (h0 : function.extfun Type ring) : @rank_condition.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_143228 (h0 : functor.add_const (add_group (has_neg linarith.comp)) linarith.comp) : @is_add_cyclic.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (has_neg.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_143229 (h4 : topological_space (add_comm_semigroup linarith.ineq)) (h5 : preorder (add_comm_semigroup linarith.ineq)) : order_closed_topology (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_143230 (h0 : group (complete_linear_order (semiring congr_arg_kind))) : group.fg (complete_linear_order (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_143231 (h0 : uniform_space (has_bot (has_add linarith.comp))) : complete_space (has_bot (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_143232 (h0 : topological_space (generalized_boolean_algebra Type)) : topological_space.separable_space (generalized_boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_143233 (h1 : not (topological_space (random_gen fun_info) -> false)) : @totally_disconnected_space.{0} (random_gen.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (random_gen.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_143234 (h0 : functor.add_const (complete_lattice (boolean_algebra.core ennreal)) ennreal) : @is_atomistic.{0} (boolean_algebra.core.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_143235 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (filter.{0} (semiring.{0} num)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (filter.{0} (semiring.{0} num)))  := sorry --non-trivial
lemma new_lemma_143236 (h0 : list (canonically_linear_ordered_monoid (has_add (finset pos)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_143237 (h0 : complete_lattice (distrib (semi_normed_ring (mul_one_class fun_info)))) : complete_lattice.is_Sup_finite_compact (distrib (semi_normed_ring (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_143238 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (pseudo_metric_space.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (pseudo_metric_space.{0} name))  := sorry --non-trivial
lemma new_lemma_143239 (h0 : complete_lattice (fintype (has_nnnorm (random_gen (random_gen char))))) : complete_lattice.is_Sup_finite_compact (fintype (has_nnnorm (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_143240 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_143241 (h0 : complete_lattice (linear_ordered_semiring (random_gen (has_norm num)))) : is_atomistic (linear_ordered_semiring (random_gen (has_norm num))) := sorry --non-trivial
lemma new_lemma_143242 (h0 : topological_space (has_Inf (has_add real))) : path_connected_space (has_Inf (has_add real)) := sorry --non-trivial
lemma new_lemma_143243 (h0 : uniform_space (add_comm_monoid (option unsigned))) : complete_space (add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_143244 (h0 : ring (boolean_algebra.core (add_comm_monoid (mul_zero_class name)))) : rank_condition (boolean_algebra.core (add_comm_monoid (mul_zero_class name))) := sorry --non-trivial
lemma new_lemma_143245 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @regular_space.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_143246 (h0 : uniform_space (ordered_ring Type)) : separated_space (ordered_ring Type) := sorry --non-trivial
lemma new_lemma_143247 (h0 : functor.add_const (list linarith.comp) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_143248 (h0 : functor.add_const (topological_space (normed_comm_ring name)) linarith.comp) : @preconnected_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_143249 (h0 : topological_space (comm_ring (has_inv (random_gen linarith.ineq)))) : path_connected_space (comm_ring (has_inv (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_143250 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_nndist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_143251 (h0 : not (uniform_space (has_nnnorm char) -> false)) : @complete_space.{0} (has_nnnorm.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_nnnorm.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_143252 (h0 : ring (ring (has_to_string (has_add pos)))) : rank_condition (ring (has_to_string (has_add pos))) := sorry --non-trivial
lemma new_lemma_143253 (h0 : function.extfun Type (functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)))) : @locally_compact_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) linarith.comp (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp))) h0 linarith.comp))  := sorry --non-trivial
lemma new_lemma_143254 (h0 : functor.add_const (uniform_space (semigroup Type)) pos) : @separated_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (semigroup.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_143255 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_pos_part linarith.comp)) pos) : @unique_factorization_monoid.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_pos_part.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_143256 (h0 : filter (has_nndist name)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_143257 (h0 : functor.add_const (group (cancel_monoid linarith.comp)) linarith.comp) : @group.fg.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_143258 (h0 : topological_space (ordered_ring (semiring (semiring congr_arg_kind)))) : path_connected_space (ordered_ring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_143259 (h0 : topological_space (has_add (has_add (finset ennreal)))) : locally_compact_space (has_add (has_add (finset ennreal))) := sorry --non-trivial
lemma new_lemma_143260 (h1 : topological_space (has_add (has_nnnorm (has_inv char)))) : t0_space (has_add (has_nnnorm (has_inv char))) := sorry --non-trivial
lemma new_lemma_143261 (h0 : topological_space (has_nndist (option environment.implicit_infer_kind))) : totally_separated_space (has_nndist (option environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_143262 (h0 : functor.add_const (topological_space (has_nndist pos)) environment.implicit_infer_kind) : @preconnected_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_143263 (h0 : group (has_nndist (option (option (option name))))) : is_simple_group (has_nndist (option (option (option name)))) := sorry --non-trivial
lemma new_lemma_143264 (h0 : function.extfun Type topological_space) : @normal_space.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_143265 (h0 : function.extfun Type group) : @group.fg.{0} (complete_distrib_lattice.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_distrib_lattice.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_143266 (h0 : topological_space (has_one (semiring (semiring empty)))) : totally_separated_space (has_one (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_143267 (h0 : group (normed_group (semiring unsigned))) : normalizer_condition (normed_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_143268 (h0 : topological_space (complete_distrib_lattice (sub_neg_monoid (sub_neg_monoid (has_Inf (has_Inf pos)))))) : t0_space (complete_distrib_lattice (sub_neg_monoid (sub_neg_monoid (has_Inf (has_Inf pos))))) := sorry --non-trivial
lemma new_lemma_143269 (h0 : complete_lattice (has_neg name)) : is_compactly_generated (has_neg name) := sorry --non-trivial
lemma new_lemma_143270 (h0 : topological_space (measurable_space.dynkin_system char)) : topological_space.first_countable_topology (measurable_space.dynkin_system char) := sorry --non-trivial
lemma new_lemma_143271 (h0 : not (topological_space (add_group linarith.comp) -> false)) : @t0_space.{0} (add_group.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (add_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_143272 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) linarith.comp) : @preirreducible_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_143273 (h0 : topological_space (boolean_algebra (has_Inf pos))) : loc_path_connected_space (boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_143274 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (canonically_ordered_comm_semiring.{0} (option.{0} name)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_ordered_comm_semiring.{0} (option.{0} name)))  := sorry --non-trivial
lemma new_lemma_143275 (h2 : topological_space (add_comm_semigroup string.iterator_imp)) (h3 : preorder (add_comm_semigroup string.iterator_imp)) : order_topology (add_comm_semigroup string.iterator_imp) := sorry --non-trivial
lemma new_lemma_143276 (h0 : topological_space (ring (has_nndist (has_neg linarith.comp)))) : locally_compact_space (ring (has_nndist (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_143277 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_143278 (h0 : topological_space (topological_space (random_gen (has_ssubset (has_ssubset string_imp))))) : path_connected_space (topological_space (random_gen (has_ssubset (has_ssubset string_imp)))) := sorry --non-trivial
lemma new_lemma_143279 (h0 : function.extfun (Type 1) (functor.comp topological_space comm_group)) : @irreducible_space.{1} (comm_group.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} comm_group.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} comm_group.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_143280 (h0 : topological_space (has_dist (option empty))) : irreducible_space (has_dist (option empty)) := sorry --non-trivial
lemma new_lemma_143281 (h0 : topological_space (group_with_zero (option (option pos)))) : preirreducible_space (group_with_zero (option (option pos))) := sorry --non-trivial
lemma new_lemma_143282 (h0 : functor.add_const (uniform_space (finset linarith.comp)) linarith.comp) : @separated_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (finset.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_143283 (h0 : functor.add_const (filter (comm_group name)) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_143284 (h0 : topological_space (add_cancel_monoid (has_Inf (has_neg linarith.comp)))) : locally_compact_space (add_cancel_monoid (has_Inf (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_143285 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_143286 (h0 : topological_space (has_norm empty)) : path_connected_space (has_norm empty) := sorry --non-trivial
lemma new_lemma_143287 (h0 : topological_space (fintype fun_info)) : t0_space (fintype fun_info) := sorry --non-trivial
lemma new_lemma_143288 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_143289 (h0 : cancel_comm_monoid_with_zero (has_to_string (comm_group unsigned))) : unique_factorization_monoid (has_to_string (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_143290 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @totally_separated_space.{0} fun_info (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) fun_info)  := sorry --non-trivial
lemma new_lemma_143291 (h0 : group (has_inv (random_gen (random_gen to_additive.value_type)))) : group.fg (has_inv (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_143292 (h0 : function.extfun (Type 1) topological_space) : @regular_space.{1} (comm_semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (comm_semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_143293 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) unsigned) : @discrete_topology.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_143294 (h0 : not (group (has_sdiff fun_info) -> false)) : @is_cyclic.{0} (has_sdiff.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (has_sdiff.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_143295 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_143296 (h0 : topological_space (has_add (option ennreal))) : discrete_topology (has_add (option ennreal)) := sorry --non-trivial
lemma new_lemma_143297 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_nndist unsigned)) unsigned) : @unique_factorization_monoid.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_nndist.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_143298 (h0 : functor.add_const (function.extfun Type list) linarith.comp) : palindrome (function.extfun_app (functor.add_const.run h0) (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_143299 (h0 : list (has_Inf (has_Inf (ring name)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_143300 (h0 : topological_space (semigroup (has_add (finset (ring pos))))) : path_connected_space (semigroup (has_add (finset (ring pos)))) := sorry --non-trivial
lemma new_lemma_143301 (h0 : list (add_cancel_monoid (finset (has_to_string (has_to_string (has_to_string name)))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_143302 (h0 : semiring (boolean_algebra linarith.comp)) : is_noetherian_ring (boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_143303 (h0 : group (finset (boolean_algebra.core Type))) : group.fg (finset (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_143304 (h0 : topological_space (normed_lattice_add_comm_group (sub_neg_monoid (sub_neg_monoid pos)))) : t0_space (normed_lattice_add_comm_group (sub_neg_monoid (sub_neg_monoid pos))) := sorry --non-trivial
lemma new_lemma_143305 (h0 : functor.comp topological_space semigroup Type) : @loc_path_connected_space.{1} (semigroup.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} semigroup.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_143306 (h0 : list (random_gen (has_inv to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_143307 (h0 : group (topological_space (has_nnnorm to_additive.value_type))) : is_cyclic (topological_space (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_143308 (h0 : topological_space (has_nndist (has_neg_part (has_add name)))) : locally_compact_space (has_nndist (has_neg_part (has_add name))) := sorry --non-trivial
lemma new_lemma_143309 (h0 : function.extfun Type (functor.comp topological_space pseudo_metric_space)) : @normal_space.{0} (pseudo_metric_space.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} pseudo_metric_space.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} pseudo_metric_space.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_143310 (h0 : ring (is_R_or_C (semiring num))) : is_principal_ideal_ring (is_R_or_C (semiring num)) := sorry --non-trivial
lemma new_lemma_143311 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_143312 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) Type) : @locally_compact_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_143313 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @normal_space.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_143314 (h2 : not (has_mem.mem fun_info has_emptyc.emptyc -> false)) : @is_domain.{0} fun_info (@finset.pi.empty.{1 0} Type ring.{0} fun_info (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) fun_info (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h2))  := sorry --non-trivial
lemma new_lemma_143315 (h0 : topological_space (random_gen (has_top (has_norm (has_norm linarith.comp))))) : path_connected_space (random_gen (has_top (has_norm (has_norm linarith.comp)))) := sorry --non-trivial
lemma new_lemma_143316 (h0 : uniform_space (finset name)) : complete_space (finset name) := sorry --non-trivial
lemma new_lemma_143317 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (measure_theory.measure_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measure_theory.measure_space.{0} num))  := sorry --non-trivial
lemma new_lemma_143318 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (measure_theory.measure_space.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (measure_theory.measure_space.{0} num))  := sorry --non-trivial
lemma new_lemma_143319 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_143320 (h0 : not (ring (random_gen unsigned) -> false)) : @is_domain.{0} (random_gen.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_143321 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_143322 (h0 : group (random_gen linarith.comp_source)) : normalizer_condition (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_143323 (h0 : functor.comp topological_space finset name) : @totally_disconnected_space.{0} (finset.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} name h0)  := sorry --non-trivial
lemma new_lemma_143324 (h0 : functor.comp add_group cancel_monoid environment.implicit_infer_kind) : @is_add_cyclic.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} add_group.{0} cancel_monoid.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_143325 (h1 : complete_lattice (measurable_space congr_arg_kind)) : is_atomistic (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_143326 (h0 : ring (has_nnnorm (random_gen (has_append char)))) : is_domain (has_nnnorm (random_gen (has_append char))) := sorry --non-trivial
lemma new_lemma_143327 (h0 : topological_space (finset empty)) : path_connected_space (finset empty) := sorry --non-trivial
lemma new_lemma_143328 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) environment.implicit_infer_kind) : @preirreducible_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_143329 (h0 : function.extfun ((finset Type -> Prop) -> Prop) (function.extfun (finset Type -> Prop))) : is_compactly_generated (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_143330 (h0 : topological_space (has_norm (has_inv (random_gen linarith.comp_source)))) : irreducible_space (has_norm (has_inv (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_143331 (h0 : topological_space (complete_semilattice_Sup linarith.comp)) : totally_separated_space (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_143332 (h0 : prod (has_zero pos) (has_zero pos)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_143333 (h0 : functor.add_const (semiring (boolean_algebra name)) name) : @is_noetherian_ring.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (boolean_algebra.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_143334 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @totally_disconnected_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_143335 (h0 : list (semigroup (has_pos_part linarith.comp))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_143336 (h0 : topological_space (linear_ordered_field (option (option unsigned)))) : totally_disconnected_space (linear_ordered_field (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_143337 (h0 : functor.add_const (list (add_cancel_monoid Type)) (ring (has_add pos))) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_143338 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (add_left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (add_left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_143339 (h1 : topological_space (topological_space (has_nnnorm (has_nnnorm reducibility_hints)))) : t0_space (topological_space (has_nnnorm (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_143340 (h0 : group (sub_neg_monoid (has_pos_part pos))) : group.fg (sub_neg_monoid (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_143341 (h0 : functor.add_const (group (semigroup environment.implicit_infer_kind)) linarith.comp) : @is_simple_group.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_143342 (h0 : uniform_space (mul_zero_class (has_nndist name))) : complete_space (mul_zero_class (has_nndist name)) := sorry --non-trivial
lemma new_lemma_143343 (h0 : functor.add_const (topological_space (boolean_algebra name)) Type) : @preirreducible_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_143344 (h0 : topological_space (has_bot (has_add real))) : t0_space (has_bot (has_add real)) := sorry --non-trivial
lemma new_lemma_143345 (h0 : topological_space (id num)) : locally_compact_space (id num) := sorry --non-trivial
lemma new_lemma_143346 (h0 : topological_space (has_nndist (add_cancel_monoid (ring (add_cancel_monoid pos))))) : totally_disconnected_space (has_nndist (add_cancel_monoid (ring (add_cancel_monoid pos)))) := sorry --non-trivial
lemma new_lemma_143347 (h0 : functor.add_const (complete_lattice (has_nndist name)) name) : @is_atomistic.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_143348 (h0 : topological_space (complete_semilattice_Sup (has_nnnorm (has_nnnorm fun_info)))) : locally_compact_space (complete_semilattice_Sup (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_143349 (h0 : ring (add_comm_semigroup enat)) : strong_rank_condition (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_143350 (h0 : function.extfun Type (functor.add_const (cancel_comm_monoid_with_zero linarith.comp))) : @unique_factorization_monoid.{0} linarith.comp (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} linarith.comp) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} linarith.comp)) h0 pos))  := sorry --non-trivial
lemma new_lemma_143351 (h0 : group (div_inv_monoid (has_nnnorm (has_nnnorm linarith.comp_source)))) : is_cyclic (div_inv_monoid (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_143352 (h0 : functor.add_const (add_monoid (boolean_algebra.core unsigned)) Type) : @add_monoid.fg.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 1} (add_monoid.{0} (boolean_algebra.core.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_143353 (h0 : has_mem.mem (has_union empty) has_emptyc.emptyc) : filter.ne_bot (finset.pi.empty filter (has_union empty) h0) := sorry --non-trivial
lemma new_lemma_143354 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_143355 (h0 : has_mem.mem (with_one fun_info) has_emptyc.emptyc) : @is_cyclic.{0} (with_one.{0} fun_info) (@finset.pi.empty.{1 0} Type group.{0} (with_one.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_143356 (h0 : monoid (add_cancel_comm_monoid Type)) : monoid.fg (add_cancel_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_143357 (h0 : functor.add_const (ordered_comm_monoid (has_neg unsigned)) (has_add unsigned)) : @has_exists_mul_of_le.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_neg.{0} unsigned)) (has_add.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_143358 (h0 : not (ring (semi_normed_ring linarith.ineq) -> false)) : @is_domain.{0} (semi_normed_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_ring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_143359 (h0 : topological_space (with_one (has_norm empty))) : totally_disconnected_space (with_one (has_norm empty)) := sorry --non-trivial
lemma new_lemma_143360 (h0 : uniform_space (semigroup (finset (mul_one_class Type)))) : separated_space (semigroup (finset (mul_one_class Type))) := sorry --non-trivial
lemma new_lemma_143361 (h0 : functor.add_const (topological_space (has_neg_part ennreal)) ennreal) : @normal_space.{0} (has_neg_part.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_143362 (h0 : complete_lattice (has_emptyc num)) : is_compactly_generated (has_emptyc num) := sorry --non-trivial
lemma new_lemma_143363 (h0 : topological_space (has_neg_part (has_nndist (has_add pos)))) : topological_space.separable_space (has_neg_part (has_nndist (has_add pos))) := sorry --non-trivial
lemma new_lemma_143364 (h0 : prod (non_assoc_semiring (semiring empty)) (non_assoc_semiring (semiring empty))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_143365 (h0 : group (finset (ring (has_pos_part (ring linarith.comp))))) : group.fg (finset (ring (has_pos_part (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_143366 (h0 : filter (has_add (has_to_string pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_143367 (h0 : functor.add_const (add_group (partial_order empty)) congr_arg_kind) : @is_add_cyclic.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (partial_order.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_143368 (h0 : topological_space (has_neg_part (option pos))) : regular_space (has_neg_part (option pos)) := sorry --non-trivial
lemma new_lemma_143369 (h0 : not (ring (has_nnnorm char) -> false)) : @rank_condition.{0} (has_nnnorm.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (has_nnnorm.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_143370 (h0 : complete_lattice (add_comm_monoid empty)) : is_compactly_generated (add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_143371 (h0 : group fun_info) (h1 : Prop) : or (group.fg fun_info) h1 := sorry --non-trivial
lemma new_lemma_143372 (h0 : functor.add_const (complete_lattice (semigroup linarith.comp)) name) : @is_compactly_generated.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_143373 (h0 : functor.add_const (topological_space (cancel_monoid environment.implicit_infer_kind)) Type) : @loc_path_connected_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_143374 (h0 : not (group (add_group num) -> false)) : @normalizer_condition.{0} (add_group.{0} num) (@classical.by_contradiction'.{1} (group.{0} (add_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_143375 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (dlist.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (dlist.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_143376 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (has_add.{0} pos) (@matrix.vec_empty.{0} (semiring.{0} (has_add.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_143377 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) linarith.comp) : @normal_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_143378 (h0 : add_group (with_one (with_bot to_additive.value_type))) : is_add_cyclic (with_one (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_143379 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_emptyc.{0} (random_gen.{0} (has_top.{0} (has_inv.{0} (random_gen.{0} linarith.ineq))))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} (random_gen.{0} (has_top.{0} (has_inv.{0} (random_gen.{0} linarith.ineq))))))  := sorry --non-trivial
lemma new_lemma_143380 (h0 : group (preorder (option unsigned))) : normalizer_condition (preorder (option unsigned)) := sorry --non-trivial
lemma new_lemma_143381 (h0 : functor.add_const (function.extfun Type ring) name) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_143382 (h0 : topological_space (plift num)) : path_connected_space (plift num) := sorry --non-trivial
lemma new_lemma_143383 (h0 h1 : multiset (nondiscrete_normed_field (add_comm_semigroup string.iterator_imp))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_143384 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : complete_lattice.is_Sup_finite_compact ennreal := sorry --non-trivial
lemma new_lemma_143385 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (with_bot.{0} (has_top.{0} to_additive.value_type)) (@matrix.vec_empty.{0} (topological_space.{0} (with_bot.{0} (has_top.{0} to_additive.value_type))) h0)  := sorry --non-trivial
lemma new_lemma_143386 (h0 : topological_space (comm_group (add_cancel_monoid name))) : t1_space (comm_group (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_143387 (h0 : topological_space (ordered_comm_monoid name)) : loc_path_connected_space (ordered_comm_monoid name) := sorry --non-trivial
lemma new_lemma_143388 (h0 : group (add_left_cancel_semigroup congr_arg_kind)) : group.fg (add_left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_143389 (h0 : topological_space (has_zero (finset name))) : t1_space (has_zero (finset name)) := sorry --non-trivial
lemma new_lemma_143390 (h0 : topological_space (has_union (metric_space congr_arg_kind))) : normal_space (has_union (metric_space congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_143391 (h0 : add_group (distrib (distrib enat))) : is_add_cyclic (distrib (distrib enat)) := sorry --non-trivial
lemma new_lemma_143392 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) Type) : @discrete_topology.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_143393 (h0 : monoid (has_bot (sub_neg_monoid real))) : monoid.fg (has_bot (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_143394 (h0 : function.extfun Type topological_space) : @t0_space.{0} (denumerable.{0} char) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (denumerable.{0} char))  := sorry --non-trivial
lemma new_lemma_143395 (h0 : functor.add_const (topological_space (has_Inf pos)) (has_neg name)) : @sequential_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_143396 (h0 : functor.add_const (ordered_add_comm_monoid (canonically_ordered_add_monoid empty)) (option empty)) : @archimedean.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (canonically_ordered_add_monoid.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_143397 (h0 : not (ring (has_union num) -> false)) : @is_domain.{0} (has_union.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (has_union.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_143398 (h0 : topological_space (finset (option (option unsigned)))) : normal_space (finset (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_143399 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_add_comm_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_143400 (h0 : mul_one_class (semi_normed_ring string.iterator_imp)) (h1 : complete_lattice (submonoid (semi_normed_ring string.iterator_imp))) : complete_lattice.is_Sup_finite_compact (submonoid (semi_normed_ring string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_143401 (h0 : functor.add_const (topological_space (boolean_algebra environment.implicit_infer_kind)) (ring linarith.comp)) : @discrete_topology.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_143402 (h0 : ring (has_star (semiring (semiring (semiring unsigned))))) : is_principal_ideal_ring (has_star (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_143403 (h0 : topological_space (non_assoc_semiring empty)) : preirreducible_space (non_assoc_semiring empty) := sorry --non-trivial
lemma new_lemma_143404 (h0 : functor.add_const (function.extfun Type list) pos) : palindrome (function.extfun_app (functor.add_const.run h0) (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_143405 (h0 : functor.add_const (function.extfun (Type 1) cancel_comm_monoid_with_zero) Type) : @unique_factorization_monoid.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1}) Type h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_143406 (h0 : not (filter environment.implicit_infer_kind -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_143407 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_143408 (h0 : functor.comp topological_space has_neg name) : @path_connected_space.{0} (has_neg.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} name h0)  := sorry --non-trivial
lemma new_lemma_143409 (h0 : topological_space (linear_ordered_field (cancel_monoid ennreal))) : loc_path_connected_space (linear_ordered_field (cancel_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_143410 (h0 : functor.comp uniform_space boolean_algebra name) : @complete_space.{0} (boolean_algebra.{0} name) (@functor.comp.run.{0 0 0} uniform_space.{0} boolean_algebra.{0} name h0)  := sorry --non-trivial
lemma new_lemma_143411 (h0 : topological_space (add_comm_monoid (has_to_string unsigned))) : t0_space (add_comm_monoid (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_143412 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_143413 (h0 : functor.add_const (ordered_comm_monoid (canonically_ordered_comm_semiring Type)) Type) : @has_exists_mul_of_le.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 1} (ordered_comm_monoid.{1} (canonically_ordered_comm_semiring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_143414 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_143415 (h0 : functor.add_const (add_group (complete_distrib_lattice Type)) (has_add pos)) : @is_add_cyclic.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (complete_distrib_lattice.{1} Type)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_143416 (h0 : functor.add_const (topological_space (has_neg_part name)) name) : @sequential_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_143417 (h0 : functor.add_const (topological_space (has_neg_part Type)) environment.implicit_infer_kind) : @preirreducible_space.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg_part.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_143418 (h0 : not (ring (random_gen (mul_one_class linarith.comp_source)) -> false)) : @strong_rank_condition.{0} (random_gen.{0} (mul_one_class.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} (mul_one_class.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_143419 (h0 : topological_space (with_bot (has_inv (has_inv linarith.comp_source)))) : t0_space (with_bot (has_inv (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_143420 (h0 : functor.add_const (group (has_neg_part environment.implicit_infer_kind)) name) : @is_simple_group.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_neg_part.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_143421 (h0 : functor.add_const (uniform_space (complete_distrib_lattice empty)) congr_arg_kind) : @complete_space.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (complete_distrib_lattice.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_143422 (h0 : topological_space (boolean_algebra (cancel_monoid environment.implicit_infer_kind))) : preirreducible_space (boolean_algebra (cancel_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_143423 (h0 : has_le (add_comm_semigroup linarith.ineq)) (h2 : add_comm_semigroup linarith.ineq) : is_bot h2 := sorry --non-trivial
lemma new_lemma_143424 (h0 : has_neg (has_neg Type) -> has_neg (has_neg Type) -> Prop) : is_symm (has_neg (has_neg Type)) h0 := sorry --non-trivial
lemma new_lemma_143425 (h0 : ring (has_norm (has_norm linarith.comp_source))) : strong_rank_condition (has_norm (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_143426 (h0 : topological_space (has_one (semiring unsigned))) : totally_disconnected_space (has_one (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_143427 (h0 : functor.add_const (add_monoid (canonically_ordered_add_monoid empty)) empty) : @add_monoid.fg.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (canonically_ordered_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_143428 (h0 : topological_space (has_nnnorm (random_gen (random_gen (random_gen string_imp))))) : t0_space (has_nnnorm (random_gen (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_143429 (h0 : topological_space (with_bot (has_norm linarith.comp))) : path_connected_space (with_bot (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_143430 (h0 : complete_lattice (bin_tree (semiring (semiring (complete_linear_order (option num)))))) : is_atomistic (bin_tree (semiring (semiring (complete_linear_order (option num))))) := sorry --non-trivial
lemma new_lemma_143431 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (semiring.{0} (has_bot.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_143432 (h1 : decidable_eq (nondiscrete_normed_field (mul_one_class (add_comm_semigroup linarith.ineq)))) (h2 : equiv.perm (nondiscrete_normed_field (mul_one_class (add_comm_semigroup linarith.ineq)))) : equiv.perm.is_swap h2 := sorry --non-trivial
lemma new_lemma_143433 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup Type)) pos) : @archimedean.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (semigroup.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_143434 (h0 : cancel_comm_monoid_with_zero (preorder empty)) : unique_factorization_monoid (preorder empty) := sorry --non-trivial
lemma new_lemma_143435 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_143436 (h1 : uniform_space (normed_group fun_info)) : complete_space (normed_group fun_info) := sorry --non-trivial
lemma new_lemma_143437 (h0 : functor.add_const (topological_space (ring Type)) Type) : @locally_compact_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_143438 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_143439 (h0 : uniform_space (measurable_space linarith.ineq)) : separated_space (measurable_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_143440 (h0 : functor.add_const (ring (complete_distrib_lattice empty)) (option empty)) : @is_domain.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_143441 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_dist unsigned)) := sorry --non-trivial
lemma new_lemma_143442 (h0 : ring (comm_ring (mul_one_class ennreal))) : is_domain (comm_ring (mul_one_class ennreal)) := sorry --non-trivial
lemma new_lemma_143443 (h0 : group (has_top string_imp)) : group.fg (has_top string_imp) := sorry --non-trivial
lemma new_lemma_143444 (h0 : semiring (has_Sup (option (semiring empty)))) : is_noetherian_ring (has_Sup (option (semiring empty))) := sorry --non-trivial
lemma new_lemma_143445 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (add_cancel_monoid.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (add_cancel_monoid.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_143446 (h1 : topological_space (id empty)) : t0_space (id empty) := sorry --non-trivial
lemma new_lemma_143447 (h0 : functor.add_const (topological_space (bin_tree congr_arg_kind)) unsigned) : @t1_space.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_143448 (h0 : list (topological_space (mul_one_class string.iterator_imp))) (h1 : ne h0 list.nil) : @path_connected_space.{0} (mul_one_class.{0} string.iterator_imp) (@list.last.{0} (topological_space.{0} (mul_one_class.{0} string.iterator_imp)) h0 h1)  := sorry --non-trivial
lemma new_lemma_143449 (h0 : topological_space unsigned) : totally_disconnected_space unsigned := sorry --non-trivial
lemma new_lemma_143450 (h0 : group (has_neg (has_to_string congr_arg_kind))) : normalizer_condition (has_neg (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_143451 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_143452 (h0 : monoid (has_Sup (option empty))) : monoid.fg (has_Sup (option empty)) := sorry --non-trivial
lemma new_lemma_143453 (h0 : cancel_comm_monoid_with_zero (complete_linear_order (semiring unsigned))) : unique_factorization_monoid (complete_linear_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_143454 (h0 : topological_space (canonically_ordered_monoid (has_Inf linarith.comp))) : normal_space (canonically_ordered_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_143455 (h0 : group (has_to_string ennreal)) : group.fg (has_to_string ennreal) := sorry --non-trivial
lemma new_lemma_143456 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_143457 (h0 : std_gen -> Prop) (h1 : filter std_gen) : filter.eventually h0 h1 := sorry --non-trivial
lemma new_lemma_143458 (h0 : filter (boolean_algebra (comm_group Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_143459 (h0 : functor.add_const (semiring (has_to_string Type)) environment.implicit_infer_kind) : @is_noetherian_ring.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (has_to_string.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_143460 (h0 : function.extfun Type group) : @group.fg.{0} (encodable.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (encodable.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_143461 (h0 : topological_space (has_add (mul_one_class environment.implicit_infer_kind))) : totally_separated_space (has_add (mul_one_class environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_143462 (h0 : list (add_right_cancel_monoid (semiring empty))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_143463 (h0 : functor.comp group distrib_lattice to_additive.value_type) : @group.fg.{0} (distrib_lattice.{0} to_additive.value_type) (@functor.comp.run.{0 0 0} group.{0} distrib_lattice.{0} to_additive.value_type h0)  := sorry --non-trivial
lemma new_lemma_143464 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) name) : @totally_disconnected_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_143465 (h1 : complete_lattice (has_one linarith.comp)) : complete_lattice.is_Sup_finite_compact (has_one linarith.comp) := sorry --non-trivial
lemma new_lemma_143466 (h2 : add_group (metric_space char)) : add_group.fg (metric_space char) := sorry --non-trivial
lemma new_lemma_143467 (h0 : functor.add_const (ring (comm_group environment.implicit_infer_kind)) pos) : @is_principal_ideal_ring.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_143468 (h1 : measurable_space (add_comm_semigroup fun_info)) (h2 : measure_theory.measure (add_comm_semigroup fun_info)) : measure_theory.is_finite_measure h2 := sorry --non-trivial
lemma new_lemma_143469 (h0 : complete_lattice (has_emptyc (has_top (has_norm linarith.comp_source)))) : is_compactly_generated (has_emptyc (has_top (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_143470 (h5 : ring (add_monoid char)) : rank_condition (add_monoid char) := sorry --non-trivial
lemma new_lemma_143471 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) (has_neg linarith.comp)) : @locally_compact_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_143472 (h0 : functor.add_const (complete_lattice nnreal) congr_arg_kind) : @complete_lattice.is_Sup_finite_compact.{0} nnreal (@functor.add_const.run.{0 0} (complete_lattice.{0} nnreal) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_143473 (h0 : topological_space (mul_zero_class ennreal)) : loc_path_connected_space (mul_zero_class ennreal) := sorry --non-trivial
lemma new_lemma_143474 (h0 : functor.add_const (ring unsigned) unsigned) : @strong_rank_condition.{0} unsigned (@functor.add_const.run.{0 0} (ring.{0} unsigned) unsigned h0)  := sorry --non-trivial
lemma new_lemma_143475 (h0 : list (with_bot empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_143476 (h0 : functor.add_const (group (ring linarith.comp)) (finset environment.implicit_infer_kind)) : @is_simple_group.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} linarith.comp)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_143477 (h0 : functor.add_const (complete_lattice (semigroup environment.implicit_infer_kind)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_143478 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_143479 (h0 : complete_lattice (boolean_algebra.core (has_neg_part name))) : is_atomistic (boolean_algebra.core (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_143480 (h0 : topological_space (add_comm_monoid (finset (ring linarith.comp)))) : discrete_topology (add_comm_monoid (finset (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_143481 (h0 : ring (add_cancel_monoid linarith.comp)) : rank_condition (add_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_143482 (h0 : functor.add_const (topological_space (has_zero linarith.comp)) pos) : @normal_space.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_143483 (h0 : functor.add_const (topological_space (mul_zero_class num)) num) : @discrete_topology.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_143484 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_143485 (h3 : topological_space (has_compl (random_gen char))) : t0_space (has_compl (random_gen char)) := sorry --non-trivial
lemma new_lemma_143486 (h0 : complete_lattice (finset (finset (finset name)))) : is_atomistic (finset (finset (finset name))) := sorry --non-trivial
lemma new_lemma_143487 (h0 : function.extfun Type group) : @normalizer_condition.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_143488 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_143489 (h0 : functor.add_const (complete_lattice (preorder empty)) unsigned) : @is_atomistic.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (preorder.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_143490 (h0 : filter (add_cancel_monoid (comm_group pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_143491 (h0 : topological_space (nondiscrete_normed_field (nondiscrete_normed_field environment.projection_info))) : t0_space (nondiscrete_normed_field (nondiscrete_normed_field environment.projection_info)) := sorry --non-trivial
lemma new_lemma_143492 (h0 : functor.add_const (topological_space (has_zero name)) Type) : @totally_separated_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_zero.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_143493 (h0 : functor.add_const (topological_space (has_pos_part pos)) Type) : @preconnected_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_pos_part.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_143494 (h2 : add_group linarith.comp_source) : is_add_cyclic linarith.comp_source := sorry --non-trivial
lemma new_lemma_143495 (h0 : list (has_to_string (option (option (option (option (option (option (option ennreal))))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_143496 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_ring.{0} unsigned)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (ordered_ring.{0} unsigned))) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.add_const.{0 0} (complete_lattice.{0} (ordered_ring.{0} unsigned)))) num))  := sorry --non-trivial
lemma new_lemma_143497 (h0 : group (ordered_comm_monoid pos)) : group.fg (ordered_comm_monoid pos) := sorry --non-trivial
lemma new_lemma_143498 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen congr_arg_kind))) : @complete_space.{0} (random_gen.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type uniform_space.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_143499 (h0 : topological_space environment.projection_info) (h1 : preorder environment.projection_info) : order_closed_topology environment.projection_info := sorry --non-trivial
lemma new_lemma_143500 (h0 : functor.comp topological_space has_neg name) : @regular_space.{0} (has_neg.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg.{0} name h0)  := sorry --non-trivial
lemma new_lemma_143501 (h0 : list (mul_zero_class (option name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_143502 (h0 : ring (has_add (cancel_monoid ennreal))) : strong_rank_condition (has_add (cancel_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_143503 (h0 : topological_space (uniform_space linarith.comp_source)) : t0_space (uniform_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_143504 (h0 : functor.add_const (finset (semigroup name)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_143505 (h0 : topological_space (has_neg_part environment.implicit_infer_kind)) : t0_space (has_neg_part environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_143506 (h0 : ordered_comm_monoid (semigroup (has_Inf (normed_comm_ring pos)))) : has_exists_mul_of_le (semigroup (has_Inf (normed_comm_ring pos))) := sorry --non-trivial
lemma new_lemma_143507 (h0 : functor.add_const (list (ring name)) (has_neg (has_neg linarith.comp))) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_143508 (h0 : not (simple_graph (encodable char) -> false)) (h1 : encodable char) : simple_graph.support (classical.by_contradiction' h0) h1 := sorry --non-trivial
lemma new_lemma_143509 (h0 : topological_space (comm_ring linarith.comp_source)) : t0_space (comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_143510 (h0 : complete_lattice (normed_group (with_bot (has_norm linarith.comp)))) : is_compactly_generated (normed_group (with_bot (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_143511 (h0 : filter (topological_space (boolean_algebra.core congr_arg_kind))) : @loc_path_connected_space.{0} (boolean_algebra.core.{0} congr_arg_kind) (@filter.Limsup.{0} (topological_space.{0} (boolean_algebra.core.{0} congr_arg_kind)) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (boolean_algebra.core.{0} congr_arg_kind)) (@topological_space.complete_lattice.{0} (boolean_algebra.core.{0} congr_arg_kind))) h0)  := sorry --non-trivial
lemma new_lemma_143512 (h0 : topological_space (group_with_zero (option empty))) : loc_path_connected_space (group_with_zero (option empty)) := sorry --non-trivial
lemma new_lemma_143513 (h0 : set (set Prop)) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@filter.generate.{0} Prop h0)  := sorry --non-trivial
lemma new_lemma_143514 (h0 : functor.add_const (function.extfun Type ring) pos) : @strong_rank_condition.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_143515 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @rank_condition.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_143516 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : palindrome (function.extfun_app (function.extfun_app h0 list) (comm_group Type)) := sorry --non-trivial
lemma new_lemma_143517 (h0 : functor.add_const (cancel_comm_monoid_with_zero (finset name)) name) : @unique_factorization_monoid.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (finset.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_143518 (h0 : topological_space (has_Inf (has_pos_part pos))) : t0_space (has_Inf (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_143519 (h0 : add_monoid (has_nndist (cancel_monoid (has_add pos)))) : add_monoid.fg (has_nndist (cancel_monoid (has_add pos))) := sorry --non-trivial
lemma new_lemma_143520 (h0 : fin has_zero.zero) : @complete_space.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (canonically_ordered_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_143521 (h0 : has_mem.mem (with_one empty) has_emptyc.emptyc) : @irreducible_space.{0} (with_one.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_143522 (h0 : functor.add_const (topological_space (comm_group pos)) unsigned) : @totally_separated_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_143523 (h0 : list (comm_group (has_add (canonically_ordered_comm_semiring (has_nndist (has_zero Type)))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_143524 (h0 : finset (has_to_string congr_arg_kind)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_143525 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (ordered_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (ordered_comm_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_143526 (h0 : functor.add_const (group (cancel_monoid empty)) num) : @is_cyclic.{0} (cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (cancel_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_143527 (h0 : functor.add_const (complete_lattice (comm_group pos)) (ring (finset (ring linarith.comp)))) : @complete_lattice.is_Sup_finite_compact.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} pos)) (ring.{0} (finset.{0} (ring.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_143528 (h0 : finset (normed_comm_ring (has_add (has_to_string Type)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_143529 (h0 : functor.add_const (ordered_comm_monoid (finset name)) pos) : @has_exists_mul_of_le.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (finset.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_143530 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) environment.implicit_infer_kind) : @loc_path_connected_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_143531 (h1 : topological_space (with_one (random_gen fun_info))) : totally_separated_space (with_one (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_143532 (h2 : topological_space (distrib char)) : totally_disconnected_space (distrib char) := sorry --non-trivial
lemma new_lemma_143533 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (denumerable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (denumerable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_143534 (h0 : functor.add_const (topological_space (normed_linear_ordered_group unsigned)) congr_arg_kind) : @topological_space.separable_space.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_143535 (h0 : functor.add_const (topological_space (has_add linarith.comp)) environment.implicit_infer_kind) : @discrete_topology.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_143536 (h0 : add_group (random_gen linarith.ineq)) : is_add_cyclic (random_gen linarith.ineq) := sorry --non-trivial
lemma new_lemma_143537 (h0 : ring (has_one (semiring (semiring congr_arg_kind)))) : is_domain (has_one (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_143538 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_143539 (h0 : complete_lattice (metric_space linarith.comp)) : complete_lattice.is_Sup_finite_compact (metric_space linarith.comp) := sorry --non-trivial
lemma new_lemma_143540 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_143541 (h0 : topological_space (ordered_comm_monoid (finset (finset (has_Inf pos))))) : irreducible_space (ordered_comm_monoid (finset (finset (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_143542 (h0 : functor.add_const (topological_space (has_neg_part name)) Type) : @totally_separated_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg_part.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_143543 (h0 : uniform_space (finset (has_nndist (has_add pos)))) : separated_space (finset (has_nndist (has_add pos))) := sorry --non-trivial
lemma new_lemma_143544 (h0 : list (ordered_comm_ring Type)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_143545 (h0 : ordered_add_comm_monoid (has_zero (has_nndist name))) : archimedean (has_zero (has_nndist name)) := sorry --non-trivial
lemma new_lemma_143546 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_143547 (h0 : list (has_nndist linarith.comp)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_143548 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (linear_ordered_comm_ring empty)) := sorry --non-trivial
lemma new_lemma_143549 (h0 : ordered_comm_monoid (ring Type)) : has_exists_mul_of_le (ring Type) := sorry --non-trivial
lemma new_lemma_143550 (h0 : ring (has_ssubset (has_norm (has_norm to_additive.value_type)))) : is_domain (has_ssubset (has_norm (has_norm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_143551 (h0 : ring (normed_group (semiring (has_norm empty)))) : rank_condition (normed_group (semiring (has_norm empty))) := sorry --non-trivial
lemma new_lemma_143552 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_143553 (h0 : topological_space (has_add (ordered_comm_monoid (has_add (has_Inf linarith.comp))))) : preconnected_space (has_add (ordered_comm_monoid (has_add (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_143554 (h0 : functor.comp list cancel_monoid name) : palindrome (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_143555 (h0 : functor.add_const (cancel_comm_monoid_with_zero (boolean_algebra linarith.comp)) (has_neg pos)) : @unique_factorization_monoid.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (boolean_algebra.{0} linarith.comp)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_143556 (h0 : ring (encodable (random_gen (random_gen to_additive.value_type)))) : is_domain (encodable (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_143557 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @archimedean.{1} (plift.{1} (semiring.{0} empty)) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ordered_add_comm_monoid.{1}) (plift.{1} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_143558 (h0 : function.extfun (Type 1) topological_space) : @normal_space.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_143559 (h0 : topological_space (comm_semigroup (has_Inf Type))) : sequential_space (comm_semigroup (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_143560 (h0 : function.extfun Type topological_space) : @t0_space.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_143561 (h0 : function.extfun (Type 1) finset) : finset.nonempty (function.extfun_app h0 (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_143562 (h0 : topological_space (ordered_comm_monoid (has_neg pos))) : loc_path_connected_space (ordered_comm_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_143563 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) pos) : @t0_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_143564 (h0 : topological_space (boolean_algebra (normed_comm_ring Type))) : locally_compact_space (boolean_algebra (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_143565 (h0 : fin has_zero.zero) : @group.fg.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (group.{0} (has_add.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_143566 (h0 : function.extfun nat fin) : @preirreducible_space.{0} (ordered_comm_monoid.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_143567 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) linarith.comp) : @has_exists_mul_of_le.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) linarith.comp h0) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_143568 (h0 : functor.add_const (complete_lattice (has_add linarith.comp)) linarith.comp) : @is_atomistic.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_add.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_143569 (h0 : topological_space (semi_normed_comm_ring (random_gen (random_gen (random_gen char))))) : path_connected_space (semi_normed_comm_ring (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_143570 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) Type) : @sequential_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_143571 (h0 : ring (nondiscrete_normed_field environment.projection_info)) : rank_condition (nondiscrete_normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_143572 (h0 : list (has_neg (boolean_algebra (has_Inf Type)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_143573 (h0 : topological_space (with_one (has_norm fun_info))) : locally_compact_space (with_one (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_143574 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (has_add pos)) := sorry --non-trivial
lemma new_lemma_143575 (h1 : complete_lattice (normed_field string.iterator_imp)) : complete_lattice.is_Sup_finite_compact (normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_143576 (h0 : topological_space (comm_ring (random_gen (has_nnnorm char)))) : path_connected_space (comm_ring (random_gen (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_143577 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (semiring.{0} (ordered_comm_ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_143578 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_143579 (h0 : topological_space (add_cancel_comm_monoid (option (option empty)))) : preirreducible_space (add_cancel_comm_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_143580 (h0 : ordered_comm_monoid (complete_distrib_lattice (has_pos_part pos))) : has_exists_mul_of_le (complete_distrib_lattice (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_143581 (h0 : ring (has_one (has_norm (uniform_space (has_one linarith.comp))))) : is_domain (has_one (has_norm (uniform_space (has_one linarith.comp)))) := sorry --non-trivial
lemma new_lemma_143582 (h0 : topological_space (has_pos_part (has_pos_part (has_nndist (ring (ring linarith.comp)))))) : preirreducible_space (has_pos_part (has_pos_part (has_nndist (ring (ring linarith.comp))))) := sorry --non-trivial
lemma new_lemma_143583 (h0 : monoid (complete_semilattice_Sup (has_norm fun_info))) : monoid.fg (complete_semilattice_Sup (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_143584 (h0 : functor.add_const (topological_space (canonically_ordered_add_monoid empty)) empty) : @t0_space.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_143585 (h0 : group (distrib_lattice (has_ssubset fun_info))) : group.fg (distrib_lattice (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_143586 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (measurable_space.dynkin_system.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.dynkin_system.{0} empty))  := sorry --non-trivial
lemma new_lemma_143587 (h0 : topological_space (option (has_to_string (has_to_string (has_to_string num))))) : totally_disconnected_space (option (has_to_string (has_to_string (has_to_string num)))) := sorry --non-trivial
lemma new_lemma_143588 (h0 : functor.add_const (function.extfun Type topological_space) name) : @totally_separated_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_143589 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @t1_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_143590 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (distrib_lattice.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (distrib_lattice.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_143591 (h0 : topological_space (boolean_algebra.core pos)) : sequential_space (boolean_algebra.core pos) := sorry --non-trivial
lemma new_lemma_143592 (h0 : add_monoid (add_cancel_monoid (boolean_algebra.core pos))) : add_monoid.fg (add_cancel_monoid (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_143593 (h0 : function.extfun Type (functor.add_const (cancel_comm_monoid_with_zero auto.case_option))) : @unique_factorization_monoid.{0} auto.case_option (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} auto.case_option) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (cancel_comm_monoid_with_zero.{0} auto.case_option)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_143594 (h0 : functor.add_const (topological_space (semigroup Type)) (has_neg pos)) : @preconnected_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_143595 (h0 : functor.add_const (topological_space (bin_tree congr_arg_kind)) (semiring unsigned)) : @discrete_topology.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} congr_arg_kind)) (semiring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_143596 (h0 : has_mem.mem (has_emptyc congr_arg_kind) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (has_emptyc.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_emptyc.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_143597 (h0 : topological_space (has_Inf (has_add (has_Inf (has_nndist linarith.comp))))) : discrete_topology (has_Inf (has_add (has_Inf (has_nndist linarith.comp)))) := sorry --non-trivial
lemma new_lemma_143598 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @path_connected_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_143599 (h0 : not (uniform_space (mul_zero_class unsigned) -> false)) : @complete_space.{0} (mul_zero_class.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (mul_zero_class.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_143600 (h0 : uniform_space (linear_ordered_comm_ring string_imp)) : complete_space (linear_ordered_comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_143601 (h0 : topological_space (add_comm_monoid (has_Inf (has_Inf Type)))) : totally_separated_space (add_comm_monoid (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_143602 (h0 : has_mem.mem (with_bot empty) has_emptyc.emptyc) : @strong_rank_condition.{0} (with_bot.{0} empty) (@finset.pi.empty.{1 0} Type ring.{0} (with_bot.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_143603 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_143604 (h0 : not (group name -> false)) : @normalizer_condition.{0} name (@classical.by_contradiction'.{1} (group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_143605 (h0 : functor.add_const (ring (free_add_monoid empty)) num) : @rank_condition.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (free_add_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_143606 (h0 : topological_space (ordered_cancel_comm_monoid empty)) : discrete_topology (ordered_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_143607 (h0 : not (uniform_space (measurable_space.dynkin_system unsigned) -> false)) : @separated_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (measurable_space.dynkin_system.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_143608 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_143609 (h0 : semiring (non_assoc_semiring (semiring (semiring (semiring (semiring num)))))) : is_noetherian_ring (non_assoc_semiring (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_143610 (h0 : group (has_Inf (has_add real))) : group.fg (has_Inf (has_add real)) := sorry --non-trivial
lemma new_lemma_143611 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_143612 (h0 : uniform_space (ordered_comm_monoid (has_add (finset linarith.comp)))) : complete_space (ordered_comm_monoid (has_add (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_143613 (h0 : topological_space (distrib_lattice (comm_ring (random_gen fun_info)))) : irreducible_space (distrib_lattice (comm_ring (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_143614 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_143615 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) Type) : @sequential_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_143616 (h0 : topological_space (sub_neg_monoid (has_Inf (has_add (has_add pos))))) : t1_space (sub_neg_monoid (has_Inf (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_143617 (h0 : uniform_space (finset (finset (finset pos)))) : complete_space (finset (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_143618 (h0 : has_mem.mem (has_emptyc linarith.comp_source) has_emptyc.emptyc) : @locally_compact_space.{0} (has_emptyc.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_143619 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_principal_ideal_ring.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_143620 (h0 : ordered_add_comm_monoid (linear_ordered_field pos)) : archimedean (linear_ordered_field pos) := sorry --non-trivial
lemma new_lemma_143621 (h0 : not (cancel_comm_monoid_with_zero (complete_semilattice_Sup unsigned) -> false)) : @unique_factorization_monoid.{0} (complete_semilattice_Sup.{0} unsigned) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (complete_semilattice_Sup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_143622 (h0 : (enat -> linarith.ineq) -> (enat -> linarith.ineq) -> enat -> linarith.ineq) : set.separates_points (left_identity h0) := sorry --non-trivial
lemma new_lemma_143623 (h0 : topological_space (ordered_comm_monoid (finset (finset (finset (finset linarith.comp)))))) : preconnected_space (ordered_comm_monoid (finset (finset (finset (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_143624 (h0 : not (ring (normed_group linarith.comp_source) -> false)) : @strong_rank_condition.{0} (normed_group.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (normed_group.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_143625 (h0 : topological_space (normed_linear_ordered_group unsigned)) : t1_space (normed_linear_ordered_group unsigned) := sorry --non-trivial
lemma new_lemma_143626 (h0 : semiring (finset (has_add (has_add (has_add Type))))) : is_noetherian_ring (finset (has_add (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_143627 (h0 : group (has_bot (has_neg name))) : is_simple_group (has_bot (has_neg name)) := sorry --non-trivial
lemma new_lemma_143628 (h1 : topological_space (comm_ring (has_norm (random_gen to_additive.value_type)))) : path_connected_space (comm_ring (has_norm (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_143629 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_143630 (h0 : functor.add_const (topological_space (ring linarith.comp)) Type) : @t1_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_143631 (h0 : ring (normed_field (random_gen (random_gen (random_gen char))))) : strong_rank_condition (normed_field (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_143632 (h0 : topological_space (boolean_algebra (finset linarith.comp))) : regular_space (boolean_algebra (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_143633 (h0 : not (complete_lattice (has_add linarith.comp_source) -> false)) : @is_compactly_generated.{0} (has_add.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_add.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_143634 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) (semigroup Type)) : @t0_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (add_cancel_monoid.{1} Type)) (semigroup.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_143635 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_143636 (h0 : ring (ordered_comm_ring (has_add pos))) : strong_rank_condition (ordered_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_143637 (h0 : pseudo_emetric_space nat) (h1 : pseudo_emetric_space bool) (h2 : nnreal) : lipschitz_with h2 nat.bodd := sorry --non-trivial
lemma new_lemma_143638 (h0 : topological_space (complete_linear_order (semiring unsigned))) : t0_space (complete_linear_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_143639 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (semigroup.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (semigroup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_143640 (h1 : ring (semiring linarith.ineq)) : is_domain (semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_143641 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_143642 (h0 : topological_space (has_zero (option ennreal))) : t0_space (has_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_143643 (h0 : functor.add_const (list (semigroup linarith.comp)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_143644 (h0 : functor.add_const (filter (has_add name)) environment.implicit_infer_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_143645 (h0 : functor.add_const (topological_space (has_neg name)) pos) : @topological_space.separable_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_143646 (h0 : order_hom nat (topological_space (random_gen (has_nnnorm fun_info)))) : @t0_space.{0} (random_gen.{0} (has_nnnorm.{0} fun_info)) (@monotonic_sequence_limit.{0} (topological_space.{0} (random_gen.{0} (has_nnnorm.{0} fun_info))) (@topological_space.partial_order.{0} (random_gen.{0} (has_nnnorm.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_143647 (h0 : functor.add_const (monoid (cancel_monoid name)) environment.implicit_infer_kind) : @monoid.fg.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (cancel_monoid.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_143648 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_143649 (h0 : uniform_space (has_emptyc (has_emptyc fun_info))) : complete_space (has_emptyc (has_emptyc fun_info)) := sorry --non-trivial
lemma new_lemma_143650 (h0 : functor.add_const (uniform_space (has_pos_part pos)) linarith.comp) : @separated_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_pos_part.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_143651 (h0 : topological_space (measurable_space (has_top num))) : totally_separated_space (measurable_space (has_top num)) := sorry --non-trivial
lemma new_lemma_143652 (h0 : complete_lattice (finset (add_cancel_monoid pos))) : is_compactly_generated (finset (add_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_143653 (h0 : ring (measurable_space (random_gen num))) : strong_rank_condition (measurable_space (random_gen num)) := sorry --non-trivial
lemma new_lemma_143654 (h0 : topological_space environment.implicit_infer_kind) : path_connected_space environment.implicit_infer_kind := sorry --non-trivial
lemma new_lemma_143655 (h0 : topological_space (group_with_zero ennreal)) : totally_disconnected_space (group_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_143656 (h0 : function.extfun (finset Type) (has_mem.mem (with_one num))) : @monoid.fg.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type monoid.{0} (with_one.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_143657 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_143658 (h0 : functor.add_const (list (simple_graph linarith.comp)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_143659 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_143660 (h1 : ring (normed_group (has_ssubset string_imp))) : strong_rank_condition (normed_group (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_143661 (h1 : set (simple_graph environment.projection_info)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_143662 (h0 : topological_space (finset (finset Type))) : preirreducible_space (finset (finset Type)) := sorry --non-trivial
lemma new_lemma_143663 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_inter.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_inter.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_143664 (h0 : fin has_zero.zero) : @irreducible_space.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (normed_lattice_add_comm_group.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_143665 (h0 : not (function.extfun Type ring -> false)) : @is_principal_ideal_ring.{0} (option.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (option.{0} num))  := sorry --non-trivial
lemma new_lemma_143666 (h0 : topological_space (has_top (comm_ring (random_gen fun_info)))) : irreducible_space (has_top (comm_ring (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_143667 (h0 : topological_space (boolean_algebra (has_pos_part pos))) : preirreducible_space (boolean_algebra (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_143668 (h0 : topological_space (normed_comm_ring (option (option (option empty))))) : preirreducible_space (normed_comm_ring (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_143669 (h0 : topological_space (normed_group string_imp)) : locally_compact_space (normed_group string_imp) := sorry --non-trivial
lemma new_lemma_143670 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_143671 (h0 : functor.comp cancel_comm_monoid_with_zero has_neg Type) : @unique_factorization_monoid.{1} (has_neg.{1} Type) (@functor.comp.run.{1 1 1} cancel_comm_monoid_with_zero.{1} has_neg.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_143672 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_143673 (h0 : filter (has_to_string (has_neg (has_add (mul_one_class (has_add pos)))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_143674 (h0 : functor.add_const (uniform_space (has_pos_part real)) real) : @separated_space.{0} (has_pos_part.{0} real) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_pos_part.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_143675 (h0 : group linarith.comp_source) : normalizer_condition linarith.comp_source := sorry --non-trivial
lemma new_lemma_143676 (h0 : functor.add_const (add_monoid (bin_tree congr_arg_kind)) unsigned) : @add_monoid.fg.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (bin_tree.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_143677 (h0 : functor.add_const (complete_lattice (comm_group ennreal)) name) : @is_atomistic.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_143678 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_143679 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (linear_ordered_field.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (linear_ordered_field.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_143680 (h0 : measurable_space (non_unital_non_assoc_semiring enat)) (h1 : filter (non_unital_non_assoc_semiring enat)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_143681 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_143682 (h0 : add_group (has_top (random_gen (random_gen (has_inv linarith.comp_source))))) : is_add_cyclic (has_top (random_gen (random_gen (has_inv linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_143683 (h0 : functor.comp ring boolean_algebra.core ennreal) : @rank_condition.{0} (boolean_algebra.core.{0} ennreal) (@functor.comp.run.{0 0 0} ring.{0} boolean_algebra.core.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_143684 (h0 : functor.add_const (finset (canonically_ordered_comm_semiring name)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_143685 (h0 : list (has_Inf real)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_143686 (h0 : functor.add_const (topological_space (complete_distrib_lattice empty)) unsigned) : @topological_space.separable_space.{0} (complete_distrib_lattice.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_143687 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_143688 (h0 : not (ring (ordered_comm_ring fun_info) -> false)) : @rank_condition.{0} (ordered_comm_ring.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (ordered_comm_ring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_143689 (h0 : functor.add_const (ordered_comm_monoid (finset Type)) (finset (finset (finset pos)))) : @has_exists_mul_of_le.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (finset.{1} Type)) (finset.{0} (finset.{0} (finset.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_143690 (h0 : functor.add_const (group (cancel_monoid linarith.comp)) name) : @group.fg.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (cancel_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_143691 (h0 : functor.add_const (topological_space (boolean_algebra Type)) (has_add name)) : @totally_disconnected_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_143692 (h0 : topological_space (has_edist (option empty))) : normal_space (has_edist (option empty)) := sorry --non-trivial
lemma new_lemma_143693 (h0 : ring (distrib_lattice (random_gen (random_gen (random_gen string_imp))))) : rank_condition (distrib_lattice (random_gen (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_143694 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_143695 (h0 : topological_space (has_add (has_Inf (mul_one_class Type)))) : topological_space.separable_space (has_add (has_Inf (mul_one_class Type))) := sorry --non-trivial
lemma new_lemma_143696 (h0 : fin has_zero.zero) : @group.fg.{0} (boolean_algebra.{0} real) (@matrix.vec_empty.{0} (group.{0} (boolean_algebra.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_143697 (h0 : complete_lattice (cancel_monoid num)) : is_compactly_generated (cancel_monoid num) := sorry --non-trivial
lemma new_lemma_143698 (h0 : topological_space (denumerable (has_nnnorm reducibility_hints))) : totally_disconnected_space (denumerable (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_143699 (h0 : complete_lattice (ordered_comm_monoid (has_neg (ordered_comm_ring (has_Inf name))))) : is_atomistic (ordered_comm_monoid (has_neg (ordered_comm_ring (has_Inf name)))) := sorry --non-trivial
lemma new_lemma_143700 (h0 : filter (generalized_boolean_algebra (has_pos_part (has_neg (ring (ring (has_pos_part linarith.comp))))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_143701 (h0 : topological_space (canonically_ordered_comm_semiring (has_neg_part (has_to_string pos)))) : locally_compact_space (canonically_ordered_comm_semiring (has_neg_part (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_143702 (h0 : topological_space (linear_ordered_comm_group (option empty))) : discrete_topology (linear_ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_143703 (h0 : not (prod (has_one empty) (has_one empty) -> false)) : id_rel (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_143704 (h0 : function.extfun Type ring) : @rank_condition.{0} linarith.comp_source (@function.extfun_app.{2 1} Type ring.{0} h0 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_143705 (h0 : topological_space (semiring (has_norm (has_norm linarith.comp)))) : totally_separated_space (semiring (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_143706 (h0 : functor.add_const (topological_space (ring name)) pos) : @locally_compact_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_143707 (h0 : functor.comp ring mul_zero_class Type) : @strong_rank_condition.{1} (mul_zero_class.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} mul_zero_class.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_143708 (h0 : not (ring (has_nnnorm to_additive.value_type) -> false)) : @is_domain.{0} (has_nnnorm.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (has_nnnorm.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_143709 (h0 : topological_space (has_nndist (finset unsigned))) : regular_space (has_nndist (finset unsigned)) := sorry --non-trivial
lemma new_lemma_143710 (h0 : function.extfun (Type 1) complete_lattice) : @is_atomistic.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_143711 (h0 : functor.add_const (ring (has_neg_part Type)) linarith.comp) : @rank_condition.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_neg_part.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_143712 (h0 : topological_space (linear_ordered_field (option (option empty)))) : topological_space.separable_space (linear_ordered_field (option (option empty))) := sorry --non-trivial
lemma new_lemma_143713 (h0 : functor.add_const (complete_lattice (ring linarith.comp)) (has_to_string (has_to_string pos))) : @complete_lattice.is_Sup_finite_compact.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} linarith.comp)) (has_to_string.{0} (has_to_string.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_143714 (h0 : list (has_neg_part (has_add (option ennreal)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_143715 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_143716 (h0 : topological_space (has_pos_part (complete_distrib_lattice (sub_neg_monoid real)))) : totally_disconnected_space (has_pos_part (complete_distrib_lattice (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_143717 (h0 : functor.add_const (filter (pseudo_metric_space ennreal)) (has_add name)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_143718 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_143719 (h0 : topological_space (random_gen congr_arg_kind)) : irreducible_space (random_gen congr_arg_kind) := sorry --non-trivial
lemma new_lemma_143720 (h0 : topological_space (has_add (has_neg linarith.comp))) : preirreducible_space (has_add (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_143721 (h0 : functor.add_const (semiring (is_R_or_C congr_arg_kind)) empty) : @is_noetherian_ring.{0} (is_R_or_C.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (semiring.{0} (is_R_or_C.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_143722 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) pos) : @sequential_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_143723 (h0 : group (has_inv (has_inv linarith.ineq))) : is_cyclic (has_inv (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_143724 (h0 : complete_lattice (random_gen (with_bot linarith.ineq))) : is_compactly_generated (random_gen (with_bot linarith.ineq)) := sorry --non-trivial
lemma new_lemma_143725 (h2 : measurable_space (nondiscrete_normed_field (nondiscrete_normed_field linarith.ineq))) (h3 : measure_theory.measure (nondiscrete_normed_field (nondiscrete_normed_field linarith.ineq))) : measure_theory.is_finite_measure h3 := sorry --non-trivial
lemma new_lemma_143726 (h0 : functor.add_const (function.extfun Type group) (ordered_ring Type)) : @normalizer_condition.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) (ordered_ring.{1} Type) h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_143727 (h0 : topological_space (add_semigroup (option unsigned))) : t1_space (add_semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_143728 (h1 : function.extfun Type topological_space) : @locally_compact_space.{0} (measurable_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (measurable_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_143729 (h0 : has_mul (has_append (has_nnnorm reducibility_hints))) (h1 : add_group (con (has_append (has_nnnorm reducibility_hints)))) : is_add_cyclic (con (has_append (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_143730 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @group.fg.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_143731 (h0 : uniform_space (add_comm_monoid (normed_comm_ring name))) : separated_space (add_comm_monoid (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_143732 (h0 : ring (has_norm string_imp)) : is_domain (has_norm string_imp) := sorry --non-trivial
lemma new_lemma_143733 (h0 : functor.add_const (ordered_comm_monoid (has_nndist linarith.comp)) linarith.comp) : @has_exists_mul_of_le.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_nndist.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_143734 (h0 : add_group (mul_one_class ennreal)) : is_add_cyclic (mul_one_class ennreal) := sorry --non-trivial
lemma new_lemma_143735 (h0 : functor.add_const (topological_space (has_Sup empty)) unsigned) : @discrete_topology.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_143736 (h0 : ordered_add_comm_monoid (has_add (has_Inf (has_bot (has_bot Type))))) : archimedean (has_add (has_Inf (has_bot (has_bot Type)))) := sorry --non-trivial
lemma new_lemma_143737 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @totally_disconnected_space.{0} (group_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (group_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_143738 (h0 : functor.add_const (ring (add_group unsigned)) congr_arg_kind) : @strong_rank_condition.{0} (add_group.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (add_group.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_143739 (h0 : complete_lattice (has_nnnorm (semi_normed_ring linarith.ineq))) : complete_lattice.is_Sup_finite_compact (has_nnnorm (semi_normed_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_143740 (h0 : group (ordered_comm_monoid linarith.comp)) : normalizer_condition (ordered_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_143741 (h0 : functor.add_const (topological_space (normed_linear_ordered_group num)) empty) : @totally_separated_space.{0} (normed_linear_ordered_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_143742 (h0 : not (list (denumerable linarith.ineq) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_143743 (h0 : function.extfun (Type 1) topological_space) : @totally_disconnected_space.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_143744 (h0 : nat) : nat.prime (id h0) := sorry --non-trivial
lemma new_lemma_143745 (h0 : functor.add_const (topological_space (has_zero Type)) linarith.comp) : @normal_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_143746 (h0 : group (canonically_ordered_monoid (has_add (has_add (sub_neg_monoid pos))))) : is_simple_group (canonically_ordered_monoid (has_add (has_add (sub_neg_monoid pos)))) := sorry --non-trivial
lemma new_lemma_143747 (h0 : uniform_space (add_comm_monoid linarith.comp_source)) : complete_space (add_comm_monoid linarith.comp_source) := sorry --non-trivial
lemma new_lemma_143748 (h0 : group (random_gen (has_top congr_arg_kind))) : normalizer_condition (random_gen (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_143749 (h0 : topological_space (left_cancel_semigroup (option (option unsigned)))) : locally_compact_space (left_cancel_semigroup (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_143750 (h0 : group (canonically_ordered_comm_semiring empty)) : is_cyclic (canonically_ordered_comm_semiring empty) := sorry --non-trivial
lemma new_lemma_143751 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (ordered_comm_ring.{0} real)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_143752 (h0 : ordered_comm_monoid (has_bot (has_neg name))) : has_exists_mul_of_le (has_bot (has_neg name)) := sorry --non-trivial
lemma new_lemma_143753 (h0 : ring environment.implicit_infer_kind) : rank_condition environment.implicit_infer_kind := sorry --non-trivial
lemma new_lemma_143754 (h0 : function.extfun (Type 1) topological_space) : @regular_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_143755 (h0 : filter (linear_ordered_add_comm_group linarith.ineq)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_143756 (h0 : topological_space (linear_ordered_semiring unsigned)) : locally_compact_space (linear_ordered_semiring unsigned) := sorry --non-trivial
lemma new_lemma_143757 (h0 : cancel_comm_monoid_with_zero (ring unsigned)) : unique_factorization_monoid (ring unsigned) := sorry --non-trivial
lemma new_lemma_143758 (h0 : filter (has_bot congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_143759 (h0 : ring (simple_graph (mul_one_class fun_info))) : is_domain (simple_graph (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_143760 (h0 : list (has_top (has_nnnorm (has_nnnorm (has_ssubset linarith.comp_source))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_143761 (h0 : functor.add_const (list (semigroup pos)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_143762 (h0 : ordered_comm_monoid (generalized_boolean_algebra (sub_neg_monoid pos))) : has_exists_mul_of_le (generalized_boolean_algebra (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_143763 (h0 : ring (comm_group pos)) : is_principal_ideal_ring (comm_group pos) := sorry --non-trivial
lemma new_lemma_143764 (h0 : fin has_zero.zero) : @path_connected_space.{0} (add_comm_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_143765 (h0 : functor.add_const (function.extfun (Type 1) cancel_comm_monoid_with_zero) pos) : @unique_factorization_monoid.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1}) pos h0) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_143766 (h0 : topological_space (has_sub num)) : path_connected_space (has_sub num) := sorry --non-trivial
lemma new_lemma_143767 (h0 : add_monoid (linear_ordered_field unsigned)) : add_monoid.fg (linear_ordered_field unsigned) := sorry --non-trivial
lemma new_lemma_143768 : infinite congr_arg_kind := sorry --non-trivial
lemma new_lemma_143769 (h0 : not (uniform_space (semi_normed_comm_ring linarith.comp_source) -> false)) : @complete_space.{0} (semi_normed_comm_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (uniform_space.{0} (semi_normed_comm_ring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_143770 (h0 : functor.add_const (ring (ordered_comm_monoid Type)) (has_add name)) : @is_domain.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (ordered_comm_monoid.{1} Type)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_143771 (h0 : not (complete_lattice (semiring empty) -> false)) : @is_compactly_generated.{0} (semiring.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_143772 (h0 : uniform_space (normed_group (has_norm (semiring congr_arg_kind)))) : separated_space (normed_group (has_norm (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_143773 (h2 : complete_lattice (mul_one_class (mul_one_class (mul_one_class enat)))) : complete_lattice.is_Sup_finite_compact (mul_one_class (mul_one_class (mul_one_class enat))) := sorry --non-trivial
lemma new_lemma_143774 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_dist.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_143775 (h0 : functor.add_const (monoid (id empty)) empty) : @monoid.fg.{0} (@id.{2} Type empty) (@functor.add_const.run.{0 0} (monoid.{0} (@id.{2} Type empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_143776 (h0 : filter (normed_group (has_top num))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_143777 (h0 : group (ordered_comm_monoid (ordered_comm_ring (boolean_algebra Type)))) : is_cyclic (ordered_comm_monoid (ordered_comm_ring (boolean_algebra Type))) := sorry --non-trivial
lemma new_lemma_143778 (h0 : topological_space (finset num)) : irreducible_space (finset num) := sorry --non-trivial
lemma new_lemma_143779 (h0 : complete_lattice (boolean_algebra (has_add (add_comm_monoid pos)))) : is_compactly_generated (boolean_algebra (has_add (add_comm_monoid pos))) := sorry --non-trivial
lemma new_lemma_143780 (h1 : add_group (has_nnnorm (has_nnnorm empty))) : is_add_cyclic (has_nnnorm (has_nnnorm empty)) := sorry --non-trivial
lemma new_lemma_143781 (h0 : ring (distrib_lattice (pseudo_emetric_space char))) : rank_condition (distrib_lattice (pseudo_emetric_space char)) := sorry --non-trivial
lemma new_lemma_143782 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @t1_space.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_143783 (h0 : ring (monoid_with_zero (option (option pos)))) : is_principal_ideal_ring (monoid_with_zero (option (option pos))) := sorry --non-trivial
lemma new_lemma_143784 (h0 : functor.add_const (function.extfun Type topological_space) name) : @topological_space.separable_space.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_143785 (h0 : topological_space (ordered_comm_monoid real)) : sequential_space (ordered_comm_monoid real) := sorry --non-trivial
lemma new_lemma_143786 (h0 : add_group (has_scalar unsigned unsigned)) : is_add_cyclic (has_scalar unsigned unsigned) := sorry --non-trivial
lemma new_lemma_143787 (h0 : topological_space (mul_zero_class (finset (finset ennreal)))) : locally_compact_space (mul_zero_class (finset (finset ennreal))) := sorry --non-trivial
lemma new_lemma_143788 (h0 : uniform_space (has_top (has_top fun_info))) : separated_space (has_top (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_143789 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_143790 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_143791 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_143792 (h1 : add_group (mul_one_class reducibility_hints)) : is_add_cyclic (mul_one_class reducibility_hints) := sorry --non-trivial
lemma new_lemma_143793 (h0 : functor.add_const (uniform_space (finset pos)) (finset pos)) : @complete_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (finset.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_143794 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @sequential_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_143795 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (ordered_comm_ring.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ordered_comm_ring.{0} real))  := sorry --non-trivial
lemma new_lemma_143796 (h0 : functor.add_const (finset (normed_comm_ring pos)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_143797 (h0 : semiring (partial_order unsigned) -> semiring (partial_order unsigned) -> Prop) : is_strict_order (semiring (partial_order unsigned)) h0 := sorry --non-trivial
lemma new_lemma_143798 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) name) : @discrete_topology.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_143799 (h0 : function.extfun Type (functor.comp ring finset)) : @strong_rank_condition.{0} (finset.{0} name) (@functor.comp.run.{0 0 0} ring.{0} finset.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} finset.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_143800 (h2 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h2 (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_143801 (h0 : ordered_comm_monoid (finset (finset (ring linarith.comp)))) : has_exists_mul_of_le (finset (finset (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_143802 (h0 : topological_space (mul_one_class (add_comm_semigroup string.iterator_imp))) : t0_space (mul_one_class (add_comm_semigroup string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_143803 (h0 : functor.comp group boolean_algebra environment.implicit_infer_kind) : @is_simple_group.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} group.{0} boolean_algebra.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_143804 (h0 : filter (canonically_linear_ordered_monoid Type)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_143805 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) Type) : @locally_compact_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (boolean_algebra.core.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_143806 (h0 : list (has_inner empty empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_143807 (h1 : function.extfun Type monoid) : @monoid.fg.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type monoid.{0} h1 (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_143808 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_143809 (h0 : list (comm_semigroup Type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_143810 (h0 : uniform_space (plift (partial_order num))) : complete_space (plift (partial_order num)) := sorry --non-trivial
lemma new_lemma_143811 (h0 : functor.add_const (complete_lattice (semigroup Type)) environment.implicit_infer_kind) : @complete_lattice.is_Sup_finite_compact.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (semigroup.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_143812 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_add_cyclic.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 add_group.{1}) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_143813 (h0 : topological_space (ordered_comm_ring real)) : t0_space (ordered_comm_ring real) := sorry --non-trivial
lemma new_lemma_143814 (h0 : function.extfun Type group) : @is_cyclic.{0} (with_one.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h0 (with_one.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_143815 (h0 : ordered_add_comm_monoid (add_cancel_comm_monoid unsigned)) : archimedean (add_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_143816 (h0 : functor.add_const (complete_lattice (ring linarith.comp)) linarith.comp) : @is_compactly_generated.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_143817 (h0 : functor.add_const (group pos) (option pos)) : @group.fg.{0} pos (@functor.add_const.run.{0 0} (group.{0} pos) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_143818 (h0 : finset (ring (normed_comm_ring (normed_comm_ring name)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_143819 (h0 : nat) (h1 h2 : fin h0) : fin.lt h1 h2 := sorry --non-trivial
lemma new_lemma_143820 (h0 : set (set (nondiscrete_normed_field std_gen))) (h1 : set (nondiscrete_normed_field std_gen)) : measurable_space.dynkin_system.generate_has h0 h1 := sorry --non-trivial
lemma new_lemma_143821 (h0 : topological_space (has_Inf (has_Inf (has_add (has_Inf name))))) : loc_path_connected_space (has_Inf (has_Inf (has_add (has_Inf name)))) := sorry --non-trivial
lemma new_lemma_143822 (h0 : not (group (encodable linarith.ineq) -> false)) : @group.fg.{0} (encodable.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (encodable.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_143823 (h0 : functor.add_const (topological_space (has_star empty)) empty) : @path_connected_space.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_143824 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (canonically_ordered_add_monoid.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_add_monoid.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_143825 (h0 : complete_lattice (has_neg (finset name))) : is_compactly_generated (has_neg (finset name)) := sorry --non-trivial
lemma new_lemma_143826 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_143827 (h0 : function.extfun (finset Type -> Prop) (function.extfun (finset Type))) : @totally_disconnected_space.{0} fun_info (@finset.pi.empty.{1 0} Type topological_space.{0} fun_info (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) fun_info) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) h0 (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) fun_info)) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_143828 (h0 : cancel_comm_monoid_with_zero (has_edist (semiring (semiring (option (semiring unsigned)))))) : unique_factorization_monoid (has_edist (semiring (semiring (option (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_143829 (h0 : topological_space (has_to_string (boolean_algebra (has_add Type)))) : totally_disconnected_space (has_to_string (boolean_algebra (has_add Type))) := sorry --non-trivial
lemma new_lemma_143830 (h0 : not (topological_space (mul_zero_class congr_arg_kind) -> false)) : @totally_separated_space.{0} (mul_zero_class.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (mul_zero_class.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_143831 (h0 : topological_space (random_gen string_imp)) (h1 : preorder (random_gen string_imp)) : order_topology (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_143832 (h0 : has_mul (linear_ordered_field ennreal)) (h1 : linear_ordered_field ennreal) : is_regular h1 := sorry --non-trivial
lemma new_lemma_143833 (h0 : functor.add_const (complete_lattice (complete_distrib_lattice ennreal)) ennreal) : @is_compactly_generated.{0} (complete_distrib_lattice.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (complete_distrib_lattice.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_143834 (h1 : ring (distrib_lattice to_additive.value_type)) : is_domain (distrib_lattice to_additive.value_type) := sorry --non-trivial
lemma new_lemma_143835 (h0 : function.extfun Type topological_space) : @normal_space.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_143836 (h0 : topological_space (generalized_boolean_algebra (has_neg (has_Inf (ring (has_Inf (has_neg Type))))))) : t1_space (generalized_boolean_algebra (has_neg (has_Inf (ring (has_Inf (has_neg Type)))))) := sorry --non-trivial
lemma new_lemma_143837 (h0 : topological_space (monoid (option (option (option unsigned))))) : discrete_topology (monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_143838 (h0 : functor.add_const (complete_lattice (add_cancel_monoid unsigned)) (normed_comm_ring name)) : @is_compactly_generated.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} unsigned)) (normed_comm_ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_143839 (h0 : complete_lattice (has_add (has_to_string Type))) : is_atomistic (has_add (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_143840 (h0 : monoid (ordered_comm_monoid (has_bot pos))) : monoid.fg (ordered_comm_monoid (has_bot pos)) := sorry --non-trivial
lemma new_lemma_143841 (h0 : ring (semigroup (option (option empty)))) : is_domain (semigroup (option (option empty))) := sorry --non-trivial
lemma new_lemma_143842 (h0 : topological_space (ring (has_add Type))) : topological_space.separable_space (ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_143843 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @regular_space.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_143844 (h0 : functor.add_const (ring (has_nndist linarith.comp)) linarith.comp) : @is_principal_ideal_ring.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_143845 (h0 : group (ring (has_neg (has_neg Type)))) : is_simple_group (ring (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_143846 (h0 : functor.add_const (cancel_comm_monoid_with_zero (preorder num)) empty) : @unique_factorization_monoid.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (preorder.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_143847 (h0 : functor.add_const (ring (boolean_algebra Type)) (mul_one_class linarith.comp)) : @strong_rank_condition.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.{1} Type)) (mul_one_class.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_143848 (h0 : topological_space (ordered_comm_ring (has_Inf Type))) : preirreducible_space (ordered_comm_ring (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_143849 (h0 : filter (has_star unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_143850 (h0 : group (boolean_algebra.core (has_add environment.implicit_infer_kind))) : is_cyclic (boolean_algebra.core (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_143851 (h0 : group (ordered_comm_ring (has_Inf (has_Inf (has_Inf (has_add (has_Inf pos))))))) : is_simple_group (ordered_comm_ring (has_Inf (has_Inf (has_Inf (has_add (has_Inf pos)))))) := sorry --non-trivial
lemma new_lemma_143852 (h0 : functor.add_const (function.extfun Type topological_space) (ring linarith.comp)) : @locally_compact_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (ring.{0} linarith.comp) h0) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_143853 (h0 : ring (has_union (semiring (semiring congr_arg_kind)))) : is_domain (has_union (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_143854 (h0 : add_group (topological_space char)) : is_add_cyclic (topological_space char) := sorry --non-trivial
lemma new_lemma_143855 (h0 : functor.add_const (topological_space (semigroup unsigned)) pos) : @preconnected_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_143856 (h0 : add_group (add_left_cancel_monoid (has_nnnorm linarith.ineq))) : is_add_cyclic (add_left_cancel_monoid (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_143857 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} char (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) char)  := sorry --non-trivial
lemma new_lemma_143858 (h0 : topological_space (pseudo_emetric_space congr_arg_kind)) : totally_disconnected_space (pseudo_emetric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_143859 (h0 : topological_space (add_cancel_monoid (has_to_string pos))) : topological_space.separable_space (add_cancel_monoid (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_143860 (h0 : topological_space (add_cancel_comm_monoid (metric_space char))) : t0_space (add_cancel_comm_monoid (metric_space char)) := sorry --non-trivial
lemma new_lemma_143861 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_143862 (h0 : topological_space (has_norm (plift linarith.comp_source))) : discrete_topology (has_norm (plift linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_143863 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_143864 (h0 : topological_space (has_add (option (option pos)))) : regular_space (has_add (option (option pos))) := sorry --non-trivial
lemma new_lemma_143865 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_143866 (h0 : complete_lattice (add_comm_monoid (semigroup (add_comm_monoid name)))) : is_compactly_generated (add_comm_monoid (semigroup (add_comm_monoid name))) := sorry --non-trivial
lemma new_lemma_143867 (h0 : uniform_space (linear_ordered_comm_group_with_zero std_gen)) : complete_space (linear_ordered_comm_group_with_zero std_gen) := sorry --non-trivial
lemma new_lemma_143868 (h0 : functor.add_const (ring (has_neg pos)) (finset linarith.comp)) : @is_principal_ideal_ring.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} pos)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_143869 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_cyclic.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_143870 (h0 : function.extfun Type group) : @group.fg.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type group.{0} h0 (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_143871 (h1 : functor.comp ring semi_normed_ring reducibility_hints) : @rank_condition.{0} (semi_normed_ring.{0} reducibility_hints) (@functor.comp.run.{0 0 0} ring.{0} semi_normed_ring.{0} reducibility_hints h1)  := sorry --non-trivial
lemma new_lemma_143872 (h0 : complete_lattice (has_top (random_gen unsigned))) : is_compactly_generated (has_top (random_gen unsigned)) := sorry --non-trivial
lemma new_lemma_143873 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) linarith.comp) : @sequential_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_143874 (h0 : group (has_zero (ring (ring Type)))) : group.fg (has_zero (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_143875 (h0 : complete_lattice (linear_ordered_field ennreal)) : is_atomistic (linear_ordered_field ennreal) := sorry --non-trivial
lemma new_lemma_143876 (h0 : functor.comp topological_space boolean_algebra environment.implicit_infer_kind) : @sequential_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_143877 (h0 : add_group (metric_space linarith.comp_source)) : is_add_cyclic (metric_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_143878 (h0 : topological_space (has_neg (option unsigned))) : totally_disconnected_space (has_neg (option unsigned)) := sorry --non-trivial
lemma new_lemma_143879 (h1 : add_group (nondiscrete_normed_field (normed_field reducibility_hints))) : is_add_cyclic (nondiscrete_normed_field (normed_field reducibility_hints)) := sorry --non-trivial
lemma new_lemma_143880 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_143881 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (linear_ordered_field.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} num))  := sorry --non-trivial
lemma new_lemma_143882 (h0 : has_ssubset (mul_one_class linarith.comp_source)) (h1 : list (has_ssubset (mul_one_class linarith.comp_source))) : list.duplicate h0 h1 := sorry --non-trivial
lemma new_lemma_143883 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_143884 (h0 : topological_space (metric_space to_additive.value_type)) : t0_space (metric_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_143885 (h0 : topological_space (boolean_algebra (comm_group (comm_group name)))) : preconnected_space (boolean_algebra (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_143886 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) linarith.comp) : @t1_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_143887 (h0 : topological_space (comm_group (has_neg Type))) : loc_path_connected_space (comm_group (has_neg Type)) := sorry --non-trivial
lemma new_lemma_143888 (h0 : functor.add_const (filter (ring linarith.comp)) (boolean_algebra pos)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_143889 (h0 : uniform_space (metric_space (metric_space num))) : separated_space (metric_space (metric_space num)) := sorry --non-trivial
lemma new_lemma_143890 (h0 : ring (topological_space (random_gen linarith.ineq))) : strong_rank_condition (topological_space (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_143891 (h0 : ring (topological_space (has_ssubset (has_ssubset (has_ssubset char))))) : rank_condition (topological_space (has_ssubset (has_ssubset (has_ssubset char)))) := sorry --non-trivial
lemma new_lemma_143892 (h0 : uniform_space (multiplicative reducibility_hints)) : complete_space (multiplicative reducibility_hints) := sorry --non-trivial
lemma new_lemma_143893 (h0 : topological_space (boolean_algebra (has_Inf linarith.comp))) : totally_disconnected_space (boolean_algebra (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_143894 (h0 : topological_space (finset (has_add name))) : regular_space (finset (has_add name)) := sorry --non-trivial
lemma new_lemma_143895 (h0 : functor.add_const (topological_space znum) num) : @normal_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) num h0)  := sorry --non-trivial
lemma new_lemma_143896 (h0 : complete_lattice (add_group unsigned)) : is_atomistic (add_group unsigned) := sorry --non-trivial
lemma new_lemma_143897 (h0 : topological_space (left_cancel_semigroup (option unsigned))) : t1_space (left_cancel_semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_143898 (h0 : topological_space (simple_graph pos)) : regular_space (simple_graph pos) := sorry --non-trivial
lemma new_lemma_143899 (h0 : filter (comm_ring linarith.ineq)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_143900 (h0 : functor.add_const (function.extfun Type complete_lattice) (has_neg pos)) : @is_compactly_generated.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) (has_neg.{0} pos) h0) (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_143901 (h0 : functor.add_const (topological_space (ring name)) name) : @topological_space.separable_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_143902 (h0 : topological_space (normed_group linarith.comp_source)) : irreducible_space (normed_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_143903 (h0 : uniform_space (semigroup (has_add Type))) : complete_space (semigroup (has_add Type)) := sorry --non-trivial
lemma new_lemma_143904 (h0 : functor.add_const (topological_space (omega_complete_partial_order empty)) num) : @discrete_topology.{0} (omega_complete_partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (omega_complete_partial_order.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_143905 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} name (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) name)  := sorry --non-trivial
lemma new_lemma_143906 (h0 : topological_space (boolean_algebra.core empty)) : irreducible_space (boolean_algebra.core empty) := sorry --non-trivial
lemma new_lemma_143907 (h0 : uniform_space (boolean_algebra unsigned)) : complete_space (boolean_algebra unsigned) := sorry --non-trivial
lemma new_lemma_143908 (h0 : topological_space (has_top (has_norm congr_arg_kind))) : path_connected_space (has_top (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_143909 (h0 : functor.add_const (topological_space (linear_ordered_field ennreal)) num) : @path_connected_space.{0} (linear_ordered_field.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_143910 (h0 : ordered_add_comm_monoid (ordered_comm_ring (ordered_ring (has_nndist linarith.comp)))) : archimedean (ordered_comm_ring (ordered_ring (has_nndist linarith.comp))) := sorry --non-trivial
lemma new_lemma_143911 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @t1_space.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_143912 (h0 : group (finset empty)) : normalizer_condition (finset empty) := sorry --non-trivial
lemma new_lemma_143913 (h0 : not (functor.add_const Prop (linear_ordered_semiring unsigned) -> false)) : functor.add_const.run (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_143914 (h0 : monoid (cancel_monoid (has_add Type))) : monoid.fg (cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_143915 (h0 : filter (has_sub empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_143916 (h4 : uniform_space char) : separated_space char := sorry --non-trivial
lemma new_lemma_143917 (h0 : complete_lattice (fintype reducibility_hints)) : complete_lattice.is_Sup_finite_compact (fintype reducibility_hints) := sorry --non-trivial
lemma new_lemma_143918 (h0 : not (add_monoid (complete_linear_order empty) -> false)) : @add_monoid.fg.{0} (complete_linear_order.{0} empty) (@classical.by_contradiction'.{1} (add_monoid.{0} (complete_linear_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_143919 (h0 : topological_space (has_emptyc (has_inv (random_gen linarith.ineq)))) : locally_compact_space (has_emptyc (has_inv (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_143920 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_edist unsigned)) := sorry --non-trivial
lemma new_lemma_143921 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (cancel_monoid num)) := sorry --non-trivial
lemma new_lemma_143922 (h0 : functor.add_const (topological_space (has_to_string environment.implicit_infer_kind)) name) : @irreducible_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_143923 (h0 : ring (simple_graph (option (option empty)))) : is_principal_ideal_ring (simple_graph (option (option empty))) := sorry --non-trivial
lemma new_lemma_143924 (h0 : functor.add_const (semiring (canonically_linear_ordered_monoid pos)) (has_to_string ennreal)) : @is_noetherian_ring.{0} (canonically_linear_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (canonically_linear_ordered_monoid.{0} pos)) (has_to_string.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_143925 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (boolean_algebra.core.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_143926 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) linarith.comp) := sorry --non-trivial
lemma new_lemma_143927 (h0 : topological_space (comm_monoid (option (option empty)))) : totally_disconnected_space (comm_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_143928 (h0 : complete_lattice (semiring (has_norm to_additive.value_type))) : complete_lattice.is_Sup_finite_compact (semiring (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_143929 (h0 : functor.add_const (ordered_add_comm_monoid ennreal) unsigned) : archimedean ennreal := sorry --non-trivial
lemma new_lemma_143930 (h0 : not (list (has_inv (has_ssubset fun_info)) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_143931 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : list.nodup (function.extfun_app (function.extfun_app h0 list) (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_143932 (h1 : ring (mul_one_class std_gen)) : strong_rank_condition (mul_one_class std_gen) := sorry --non-trivial
lemma new_lemma_143933 (h0 : topological_space (measurable_space.dynkin_system (semiring (semiring (semiring congr_arg_kind))))) : discrete_topology (measurable_space.dynkin_system (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_143934 (h0 : group (has_append (mul_one_class linarith.ineq))) : is_cyclic (has_append (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_143935 (h0 : functor.comp topological_space boolean_algebra.core Type) : @preconnected_space.{1} (boolean_algebra.core.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} boolean_algebra.core.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_143936 (h0 : topological_space (pseudo_metric_space (option empty))) : irreducible_space (pseudo_metric_space (option empty)) := sorry --non-trivial
lemma new_lemma_143937 (h0 : topological_space (semiring (has_norm (has_norm linarith.comp)))) : normal_space (semiring (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_143938 (h0 : filter (semigroup (option name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_143939 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_143940 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_inv.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_inv.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_143941 (h2 : complete_lattice (normed_field to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_143942 (h0 : topological_space (finset (has_neg real))) : preirreducible_space (finset (has_neg real)) := sorry --non-trivial
lemma new_lemma_143943 (h0 : function.extfun (Type 1) topological_space) : @t1_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_143944 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (dlist.{0} to_additive.value_type) (@id.{1} (ring.{0} (dlist.{0} to_additive.value_type)) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (dlist.{0} to_additive.value_type)))  := sorry --non-trivial
lemma new_lemma_143945 (h0 : ring (finset (finset linarith.comp))) : rank_condition (finset (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_143946 (h0 : topological_space (has_one (semiring empty))) : normal_space (has_one (semiring empty)) := sorry --non-trivial
lemma new_lemma_143947 (h0 : list (random_gen (has_nnnorm (has_ssubset fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_143948 (h1 : not (topological_space (complete_semilattice_Sup linarith.comp) -> false)) : @locally_compact_space.{0} (complete_semilattice_Sup.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} linarith.comp)) h1)  := sorry --non-trivial
lemma new_lemma_143949 (h0 : topological_space (normed_group (has_top (has_norm to_additive.value_type)))) : totally_separated_space (normed_group (has_top (has_norm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_143950 (h0 : topological_space (has_bot linarith.comp)) : t1_space (has_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_143951 (h0 : functor.add_const (topological_space (plift empty)) (semiring (semiring (semiring (option unsigned))))) : @totally_separated_space.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} empty)) (semiring.{0} (semiring.{0} (semiring.{0} (option.{0} unsigned)))) h0)  := sorry --non-trivial
lemma new_lemma_143952 (h0 : ring (has_emptyc empty)) : rank_condition (has_emptyc empty) := sorry --non-trivial
lemma new_lemma_143953 (h3 : topological_space (normed_field to_additive.value_type)) : t0_space (normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_143954 (h0 : ring (monoid congr_arg_kind)) : is_domain (monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_143955 (h2 : ring (denumerable to_additive.value_type)) : rank_condition (denumerable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_143956 (h0 : ordered_comm_monoid (has_neg_part (has_add environment.implicit_infer_kind))) : has_exists_mul_of_le (has_neg_part (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_143957 (h0 : uniform_space (has_emptyc (semiring (has_norm linarith.comp)))) : complete_space (has_emptyc (semiring (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_143958 (h0 : functor.add_const (topological_space (measure_theory.measure_space num)) empty) : @loc_path_connected_space.{0} (measure_theory.measure_space.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (measure_theory.measure_space.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_143959 (h0 : group (add_cancel_monoid (finset linarith.comp))) : is_simple_group (add_cancel_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_143960 (h0 : list (ordered_cancel_add_comm_monoid (option (option ennreal)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_143961 (h0 : uniform_space (boolean_algebra (mul_one_class pos))) : complete_space (boolean_algebra (mul_one_class pos)) := sorry --non-trivial
lemma new_lemma_143962 (h4 : ring (mul_one_class reducibility_hints)) : strong_rank_condition (mul_one_class reducibility_hints) := sorry --non-trivial
lemma new_lemma_143963 (h1 : complete_lattice (add_monoid (has_nnnorm (random_gen to_additive.value_type)))) : complete_lattice.is_Sup_finite_compact (add_monoid (has_nnnorm (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_143964 (h0 : not (ring (partial_order num) -> false)) : @is_principal_ideal_ring.{0} (partial_order.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (partial_order.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_143965 (h0 : topological_space (boolean_algebra (has_add pos))) : locally_compact_space (boolean_algebra (has_add pos)) := sorry --non-trivial
lemma new_lemma_143966 (h1 : function.extfun Type topological_space) : @totally_disconnected_space.{0} string_imp (@function.extfun_app.{2 1} Type topological_space.{0} h1 string_imp)  := sorry --non-trivial
lemma new_lemma_143967 (h0 : function.extfun (Type 1) topological_space) : @normal_space.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_143968 (h1 : uniform_space (has_ssubset std_gen)) : complete_space (has_ssubset std_gen) := sorry --non-trivial
lemma new_lemma_143969 (h0 : functor.add_const (topological_space (has_add pos)) (measurable_space.dynkin_system name)) : @loc_path_connected_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) (measurable_space.dynkin_system.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_143970 (h0 : functor.add_const (ring (has_edist num)) empty) : @is_domain.{0} (has_edist.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (has_edist.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_143971 (h0 : ring (ordered_comm_monoid (sub_neg_monoid real))) : strong_rank_condition (ordered_comm_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_143972 (h0 : topological_space (has_emptyc (random_gen fun_info))) : locally_compact_space (has_emptyc (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_143973 (h0 : functor.add_const (ordered_add_comm_monoid (ordered_comm_ring linarith.comp)) linarith.comp) : @archimedean.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (ordered_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_143974 (h0 : functor.add_const (finset name) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_143975 (h0 : finset (add_cancel_monoid (semigroup Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_143976 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_143977 (h0 : topological_space (comm_ring linarith.ineq)) : irreducible_space (comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_143978 (h0 : topological_space (boolean_algebra environment.implicit_infer_kind)) : preirreducible_space (boolean_algebra environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_143979 (h0 : functor.add_const (ordered_comm_monoid (has_to_string pos)) Type) : @has_exists_mul_of_le.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (has_to_string.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_143980 (h0 : group (is_R_or_C unsigned)) : group.fg (is_R_or_C unsigned) := sorry --non-trivial
lemma new_lemma_143981 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_143982 (h0 : add_group (rel string_imp char)) : is_add_cyclic (rel string_imp char) := sorry --non-trivial
lemma new_lemma_143983 (h0 : ring (with_one (div_inv_monoid fun_info))) : strong_rank_condition (with_one (div_inv_monoid fun_info)) := sorry --non-trivial
lemma new_lemma_143984 (h0 : functor.add_const (topological_space (ring name)) (ring Type)) : @sequential_space.{0} (ring.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} name)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_143985 (h0 : topological_space (has_union unsigned)) : totally_disconnected_space (has_union unsigned) := sorry --non-trivial
lemma new_lemma_143986 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (normed_comm_ring.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_143987 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : list.nodup (function.extfun_app (function.extfun_app h0 list) Type) := sorry --non-trivial
lemma new_lemma_143988 (h0 : functor.add_const (list (free_add_monoid num)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_143989 (h0 : topological_space (has_Inf (has_add pos))) : locally_compact_space (has_Inf (has_add pos)) := sorry --non-trivial
lemma new_lemma_143990 : infinite ereal := sorry --non-trivial
lemma new_lemma_143991 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_143992 (h0 : group (has_zero (has_add Type))) : is_simple_group (has_zero (has_add Type)) := sorry --non-trivial
lemma new_lemma_143993 (h0 : functor.add_const (group (semigroup linarith.comp)) (has_neg (has_nndist linarith.comp))) : @is_simple_group.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} linarith.comp)) (has_neg.{0} (has_nndist.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_143994 (h0 : add_group (add_group congr_arg_kind)) : is_add_cyclic (add_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_143995 (h0 : add_group (boolean_algebra.core ennreal)) : is_add_cyclic (boolean_algebra.core ennreal) := sorry --non-trivial
lemma new_lemma_143996 (h0 : complete_lattice (with_zero linarith.comp_source)) : is_compactly_generated (with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_143997 (h0 : topological_space (has_to_string (has_add (has_add linarith.comp)))) : totally_disconnected_space (has_to_string (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_143998 (h0 : function.extfun Type (functor.comp topological_space normed_comm_ring)) : @preirreducible_space.{0} (normed_comm_ring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} normed_comm_ring.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} normed_comm_ring.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_143999 (h0 : function.extfun (finset Type) (has_mem.mem (has_union empty))) : @t0_space.{0} (has_union.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_union.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_union.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
