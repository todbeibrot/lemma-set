import imports
lemma new_lemma_56000 (h0 : ring (has_inv (has_nnnorm (random_gen linarith.comp_source)))) : rank_condition (has_inv (has_nnnorm (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_56001 (h0 : semiring (has_to_string pos)) : is_noetherian_ring (has_to_string pos) := sorry --non-trivial
lemma new_lemma_56002 (h0 : ring (random_gen (random_gen (random_gen char)))) : rank_condition (random_gen (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_56003 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_56004 (h0 : ring (generalized_boolean_algebra (has_neg pos))) : rank_condition (generalized_boolean_algebra (has_neg pos)) := sorry --non-trivial
lemma new_lemma_56005 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (with_one.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (with_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_56006 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_56007 (h1 : group (semiring linarith.comp_source)) : is_cyclic (semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_56008 (h0 : monoid (normed_group (has_top (has_top linarith.ineq)))) : monoid.fg (normed_group (has_top (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_56009 (h0 : functor.add_const (topological_space (has_neg_part environment.implicit_infer_kind)) linarith.comp) : @preirreducible_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_56010 (h0 : functor.add_const (add_monoid (add_comm_monoid name)) linarith.comp) : @add_monoid.fg.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (add_comm_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_56011 (h0 : topological_space (has_zero (add_cancel_monoid environment.implicit_infer_kind))) : t1_space (has_zero (add_cancel_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_56012 (h0 : filter (has_neg_part (has_add (finset name)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_56013 (h0 : topological_space (pseudo_metric_space (option ennreal))) : loc_path_connected_space (pseudo_metric_space (option ennreal)) := sorry --non-trivial
lemma new_lemma_56014 (h0 : not (uniform_space (has_add fun_info) -> false)) : @complete_space.{0} (has_add.{0} fun_info) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_add.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_56015 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_inter.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_inter.{0} num))  := sorry --non-trivial
lemma new_lemma_56016 (h0 : ordered_comm_monoid (complete_distrib_lattice (finset (has_Inf Type)))) : has_exists_mul_of_le (complete_distrib_lattice (finset (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_56017 (h0 : not (group (uniform_space char) -> false)) : @is_cyclic.{0} (uniform_space.{0} char) (@classical.by_contradiction'.{1} (group.{0} (uniform_space.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_56018 (h0 : functor.add_const (list (finset environment.implicit_infer_kind)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_56019 (h0 : group (normed_comm_ring (boolean_algebra Type))) : normalizer_condition (normed_comm_ring (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_56020 (h0 : group (sub_neg_monoid pos)) : normalizer_condition (sub_neg_monoid pos) := sorry --non-trivial
lemma new_lemma_56021 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) pos) : @preconnected_space.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_56022 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_56023 (h0 : functor.add_const (topological_space (ordered_comm_ring real)) (has_Inf (has_Inf (ordered_comm_monoid real)))) : @locally_compact_space.{0} (ordered_comm_ring.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} real)) (has_Inf.{0} (has_Inf.{0} (ordered_comm_monoid.{0} real))) h0)  := sorry --non-trivial
lemma new_lemma_56024 (h0 : topological_space (boolean_algebra (finset real))) : locally_compact_space (boolean_algebra (finset real)) := sorry --non-trivial
lemma new_lemma_56025 (h0 : topological_space (ring (option name))) : t1_space (ring (option name)) := sorry --non-trivial
lemma new_lemma_56026 (h0 : functor.comp cancel_comm_monoid_with_zero boolean_algebra.core unsigned) : @unique_factorization_monoid.{0} (boolean_algebra.core.{0} unsigned) (@functor.comp.run.{0 0 0} cancel_comm_monoid_with_zero.{0} boolean_algebra.core.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_56027 (h0 : ring (semi_normed_ring (random_gen (random_gen (random_gen char))))) : strong_rank_condition (semi_normed_ring (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_56028 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) ennreal) : @irreducible_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_56029 (h0 : topological_space (with_one char)) : locally_compact_space (with_one char) := sorry --non-trivial
lemma new_lemma_56030 (h0 : function.extfun nat fin) : @is_domain.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (has_add.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_56031 (h0 : ring (has_le enat)) : strong_rank_condition (has_le enat) := sorry --non-trivial
lemma new_lemma_56032 (h0 : group (comm_group (has_add ennreal))) : group.fg (comm_group (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_56033 (h0 : functor.add_const (add_monoid (finset ennreal)) name) : @add_monoid.fg.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 0} (add_monoid.{0} (finset.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_56034 (h0 : list (ordered_comm_monoid (has_add pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_56035 (h0 : set (monoid_with_zero char)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_56036 (h0 : nat) (h1 : vector pnat (nat.succ h0)) (h2 : pnat) : pnat.coprime (vector.head h1) h2 := sorry --non-trivial
lemma new_lemma_56037 (h0 : functor.add_const (ring (finset Type)) ennreal) : @strong_rank_condition.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (finset.{1} Type)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_56038 (h0 : not (uniform_space (mul_one_class string_imp) -> false)) : @complete_space.{0} (mul_one_class.{0} string_imp) (@classical.by_contradiction'.{1} (uniform_space.{0} (mul_one_class.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_56039 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_union.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_union.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_56040 (h0 : list (uniform_space (canonically_ordered_monoid char))) : @complete_space.{0} (canonically_ordered_monoid.{0} char) (@list.ilast.{0} (uniform_space.{0} (canonically_ordered_monoid.{0} char)) (@inhabited_uniform_space.{0} (canonically_ordered_monoid.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_56041 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (has_add.{0} name) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (has_add.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_56042 (h0 : uniform_space (add_group linarith.comp)) : complete_space (add_group linarith.comp) := sorry --non-trivial
lemma new_lemma_56043 (h0 : has_mem.mem (has_emptyc (has_norm num)) has_emptyc.emptyc) : @is_compactly_generated.{0} (has_emptyc.{0} (has_norm.{0} num)) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_emptyc.{0} (has_norm.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_56044 (h0 : topological_space (as_linear_order (comm_monoid unsigned))) : normal_space (as_linear_order (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_56045 (h0 : functor.add_const (complete_lattice (cancel_monoid empty)) unsigned) : @is_atomistic.{0} (cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_56046 (h0 : topological_space (partial_order empty)) : irreducible_space (partial_order empty) := sorry --non-trivial
lemma new_lemma_56047 (h0 : functor.add_const (ring (left_cancel_semigroup empty)) empty) : @is_principal_ideal_ring.{0} (left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_56048 (h0 : functor.add_const (functor.add_const (add_group pos) pos) Type) : @is_add_cyclic.{0} pos (@functor.add_const.run.{0 0} (add_group.{0} pos) pos (@functor.add_const.run.{0 1} (functor.add_const.{0 0} (add_group.{0} pos) pos) Type h0))  := sorry --non-trivial
lemma new_lemma_56049 (h0 : topological_space (generalized_boolean_algebra (has_bot (has_bot (has_bot real))))) : path_connected_space (generalized_boolean_algebra (has_bot (has_bot (has_bot real)))) := sorry --non-trivial
lemma new_lemma_56050 (h0 : ordered_comm_monoid (simple_graph (ring (has_add (ring (boolean_algebra.core (ring Type))))))) : has_exists_mul_of_le (simple_graph (ring (has_add (ring (boolean_algebra.core (ring Type)))))) := sorry --non-trivial
lemma new_lemma_56051 (h0 : topological_space (add_cancel_monoid (has_add (has_Inf linarith.comp)))) : locally_compact_space (add_cancel_monoid (has_add (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_56052 (h0 : ring (boolean_algebra.core (has_add (add_comm_monoid name)))) : rank_condition (boolean_algebra.core (has_add (add_comm_monoid name))) := sorry --non-trivial
lemma new_lemma_56053 (h0 : group (canonically_linear_ordered_monoid (option unsigned))) : is_simple_group (canonically_linear_ordered_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_56054 (h0 : uniform_space (sub_neg_monoid (has_Inf Type))) : separated_space (sub_neg_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_56055 (h0 : functor.add_const (uniform_space (has_to_string pos)) (has_pos_part pos)) : @separated_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_to_string.{0} pos)) (has_pos_part.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_56056 (h1 : function.extfun (has_top linarith.comp_source) (fun (x : has_top linarith.comp_source), Prop)) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) (has_top.{0} linarith.comp_source) (@function.extfun_app.{1 1} (has_top.{0} linarith.comp_source) (λ (x : has_top.{0} linarith.comp_source), Prop) h1)  := sorry --non-trivial
lemma new_lemma_56057 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_56058 (h0 : set (nondiscrete_normed_field (add_comm_semigroup (add_comm_semigroup linarith.ineq)))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_56059 (h0 : ring (has_ssubset (mul_one_class std_gen))) : is_domain (has_ssubset (mul_one_class std_gen)) := sorry --non-trivial
lemma new_lemma_56060 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_56061 (h0 : not (prod (measurable_space.dynkin_system unsigned) (measurable_space.dynkin_system unsigned) -> false)) : id_rel (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_56062 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @loc_path_connected_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_56063 (h0 : function.extfun Type (functor.add_const (topological_space (ordered_comm_group empty)))) : @loc_path_connected_space.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_group.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (ordered_comm_group.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_56064 (h0 : std_gen -> Prop) : Exists h0 := sorry --non-trivial
lemma new_lemma_56065 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_neg_part.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_56066 (h0 : topological_space (simple_graph (boolean_algebra.core (boolean_algebra.core Type)))) : topological_space.separable_space (simple_graph (boolean_algebra.core (boolean_algebra.core Type))) := sorry --non-trivial
lemma new_lemma_56067 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) linarith.comp) : @discrete_topology.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_56068 (h0 : not (topological_space (encodable linarith.comp_source) -> false)) : @locally_compact_space.{0} (encodable.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (encodable.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_56069 (h0 : not (topological_space (measurable_space.dynkin_system unsigned) -> false)) : @discrete_topology.{0} (measurable_space.dynkin_system.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.dynkin_system.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_56070 (h0 : topological_space (denumerable (has_top linarith.ineq))) : t0_space (denumerable (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_56071 (h0 : ring (encodable (has_nnnorm (has_nnnorm linarith.ineq)))) : is_domain (encodable (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_56072 (h0 : ring (add_cancel_monoid empty)) : rank_condition (add_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_56073 (h0 : topological_space (semi_normed_ring (mul_one_class (mul_one_class reducibility_hints)))) : totally_disconnected_space (semi_normed_ring (mul_one_class (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_56074 (h0 : functor.add_const (topological_space (pseudo_metric_space ennreal)) name) : @preirreducible_space.{0} (pseudo_metric_space.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_56075 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_56076 (h0 : topological_space (has_bot Type)) : preirreducible_space (has_bot Type) := sorry --non-trivial
lemma new_lemma_56077 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_comm_semiring (has_to_string (has_to_string name)))) : unique_factorization_monoid (canonically_ordered_comm_semiring (has_to_string (has_to_string name))) := sorry --non-trivial
lemma new_lemma_56078 (h0 : topological_space (finset (generalized_boolean_algebra Type))) : totally_disconnected_space (finset (generalized_boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_56079 (h0 : topological_space (ring (finset Type))) : totally_disconnected_space (ring (finset Type)) := sorry --non-trivial
lemma new_lemma_56080 (h0 : topological_space (has_norm (random_gen linarith.comp_source))) : totally_disconnected_space (has_norm (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_56081 (h0 : uniform_space (with_bot linarith.comp_source)) : separated_space (with_bot linarith.comp_source) := sorry --non-trivial
lemma new_lemma_56082 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_56083 (h0 : function.extfun Type topological_space) : @t0_space.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_56084 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (boolean_algebra.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (boolean_algebra.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_56085 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_56086 (h0 : functor.comp ordered_comm_monoid has_add ennreal) : @has_exists_mul_of_le.{0} (has_add.{0} ennreal) (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} has_add.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_56087 (h0 : ring (canonically_linear_ordered_add_monoid char)) : strong_rank_condition (canonically_linear_ordered_add_monoid char) := sorry --non-trivial
lemma new_lemma_56088 (h0 : topological_space (generalized_boolean_algebra (has_bot pos))) : path_connected_space (generalized_boolean_algebra (has_bot pos)) := sorry --non-trivial
lemma new_lemma_56089 (h0 : ring (semi_normed_ring (mul_one_class char))) : strong_rank_condition (semi_normed_ring (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_56090 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_cancel_monoid empty)) unsigned) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_cancel_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_56091 (h0 : functor.add_const (ring nnreal) num) : @is_principal_ideal_ring.{0} nnreal (@functor.add_const.run.{0 0} (ring.{0} nnreal) num h0)  := sorry --non-trivial
lemma new_lemma_56092 (h0 : group (add_comm_monoid (option unsigned))) : is_cyclic (add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_56093 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group fun_info))) : @irreducible_space.{0} (normed_group.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_56094 (h0 : functor.add_const (uniform_space (boolean_algebra.core name)) linarith.comp) : @separated_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.core.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_56095 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_56096 (h0 : not (add_monoid (partial_order empty) -> false)) : @add_monoid.fg.{0} (partial_order.{0} empty) (@classical.by_contradiction'.{1} (add_monoid.{0} (partial_order.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_56097 (h0 : function.extfun Type (functor.comp ring ring)) : @is_principal_ideal_ring.{0} (ring.{0} (normed_comm_ring.{0} name)) (@functor.comp.run.{0 0 0} ring.{0} ring.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} ring.{0}) h0 (normed_comm_ring.{0} name)))  := sorry --non-trivial
lemma new_lemma_56098 (h0 : not (topological_space (with_zero linarith.ineq) -> false)) : @path_connected_space.{0} (with_zero.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (with_zero.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_56099 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) name) : @has_exists_mul_of_le.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) name h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_56100 (h0 : prod (finset (option pos)) (finset (option pos))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_56101 (h0 : functor.add_const (group (normed_comm_ring environment.implicit_infer_kind)) Type) : @is_simple_group.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (group.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_56102 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_56103 (h0 : complete_lattice (complete_semilattice_Sup (has_inv (random_gen string_imp)))) : complete_lattice.is_Sup_finite_compact (complete_semilattice_Sup (has_inv (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_56104 (h0 : function.extfun Type group) : @normalizer_condition.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_56105 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) Type) : @is_compactly_generated.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) Type h0) (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_56106 (h0 : complete_lattice (plift (semiring (semiring (semiring (semiring num)))))) : is_compactly_generated (plift (semiring (semiring (semiring (semiring num))))) := sorry --non-trivial
lemma new_lemma_56107 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_56108 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_56109 (h0 : filter (comm_ring to_additive.value_type)) (h1 : comm_ring to_additive.value_type -> Prop) : @filter.limsup.{0 0} Prop (comm_ring.{0} to_additive.value_type) (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice) h0 h1  := sorry --non-trivial
lemma new_lemma_56110 (h0 : not (topological_space (has_norm linarith.ineq) -> false)) : @discrete_topology.{0} (has_norm.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_56111 (h0 : topological_space (mul_zero_class (finset Type))) : irreducible_space (mul_zero_class (finset Type)) := sorry --non-trivial
lemma new_lemma_56112 (h0 : uniform_space (linear_order (option (option (option (option (option unsigned))))))) : separated_space (linear_order (option (option (option (option (option unsigned)))))) := sorry --non-trivial
lemma new_lemma_56113 (h0 : fin has_zero.zero) : matrix.vec_empty (matrix.vec_empty (matrix.vec_empty (id (id (id (matrix.vec_empty h0)))))) := sorry --non-trivial
lemma new_lemma_56114 (h0 : not (has_mem.mem (with_one linarith.comp) has_emptyc.emptyc -> false)) : @is_add_cyclic.{0} (with_one.{0} linarith.comp) (@finset.pi.empty.{1 0} Type add_group.{0} (with_one.{0} linarith.comp) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} linarith.comp) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_56115 (h0 : functor.add_const (topological_space (comm_semigroup real)) linarith.comp) : @preconnected_space.{0} (comm_semigroup.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_semigroup.{0} real)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_56116 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) (has_Inf pos)) : @preirreducible_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_56117 (h0 : function.extfun Type ring) : @rank_condition.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_56118 (h0 : not (topological_space (has_sub unsigned) -> false)) : @preirreducible_space.{0} (has_sub.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_56119 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} fun_info (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) fun_info)  := sorry --non-trivial
lemma new_lemma_56120 (h0 : group (denumerable (random_gen (has_inv string_imp)))) : group.fg (denumerable (random_gen (has_inv string_imp))) := sorry --non-trivial
lemma new_lemma_56121 (h0 : cancel_comm_monoid_with_zero (has_add (ring (option (has_zero ennreal))))) : unique_factorization_monoid (has_add (ring (option (has_zero ennreal)))) := sorry --non-trivial
lemma new_lemma_56122 (h0 : group (linear_ordered_add_comm_group (random_gen (random_gen (random_gen linarith.ineq))))) : group.fg (linear_ordered_add_comm_group (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_56123 (h0 : functor.add_const (function.extfun (Type 1) ring) linarith.comp) : @is_principal_ideal_ring.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) linarith.comp h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_56124 (h0 : set (linear_ordered_comm_group_with_zero environment.projection_info)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_56125 (h0 : not (filter (linear_ordered_add_comm_group to_additive.value_type) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_56126 (h0 : group (measurable_space (with_bot string_imp))) : normalizer_condition (measurable_space (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_56127 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (simple_graph.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (simple_graph.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_56128 (h0 : filter (left_cancel_monoid num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_56129 (h0 : add_group (semigroup (mul_zero_class pos))) : is_add_cyclic (semigroup (mul_zero_class pos)) := sorry --non-trivial
lemma new_lemma_56130 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_56131 (h2 : ring (comm_ring to_additive.value_type)) : strong_rank_condition (comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_56132 (h0 : not (group (comm_ring to_additive.value_type) -> false)) : @is_cyclic.{0} (comm_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (comm_ring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_56133 (h0 : add_monoid (group_with_zero num)) : add_monoid.fg (group_with_zero num) := sorry --non-trivial
lemma new_lemma_56134 (h0 : topological_space (comm_ring (comm_ring (has_nnnorm reducibility_hints)))) : totally_disconnected_space (comm_ring (comm_ring (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_56135 (h0 : group (as_linear_order unsigned)) : normalizer_condition (as_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_56136 (h0 : topological_space (sub_neg_monoid (has_nndist (has_Inf linarith.comp)))) : preirreducible_space (sub_neg_monoid (has_nndist (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_56137 (h0 : not (ring (non_assoc_semiring empty) -> false)) : @strong_rank_condition.{0} (non_assoc_semiring.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (non_assoc_semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_56138 (h0 : cancel_comm_monoid_with_zero (has_add (has_zero (linear_ordered_comm_group ennreal)))) : unique_factorization_monoid (has_add (has_zero (linear_ordered_comm_group ennreal))) := sorry --non-trivial
lemma new_lemma_56139 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_56140 (h0 : function.extfun Type group) : @is_simple_group.{0} (complete_distrib_lattice.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_distrib_lattice.{0} real))  := sorry --non-trivial
lemma new_lemma_56141 (h0 : topological_space (id (semiring empty))) : path_connected_space (id (semiring empty)) := sorry --non-trivial
lemma new_lemma_56142 (h0 : set (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup linarith.ineq))) -> char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_56143 (h0 : has_lt (has_compl string.iterator_imp)) : no_max_order (has_compl string.iterator_imp) := sorry --non-trivial
lemma new_lemma_56144 (h0 : topological_space (has_nndist (has_to_string Type))) : irreducible_space (has_nndist (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_56145 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (comm_semigroup.{0} linarith.comp) (@matrix.vec_empty.{0} (add_group.{0} (comm_semigroup.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_56146 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @monoid.fg.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) monoid.{0}) (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_56147 (h0 : group (canonically_ordered_comm_semiring name)) : group.fg (canonically_ordered_comm_semiring name) := sorry --non-trivial
lemma new_lemma_56148 (h0 : functor.add_const (add_monoid (has_pos_part linarith.comp)) pos) : @add_monoid.fg.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_pos_part.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_56149 (h1 : topological_space (has_compl (has_nnnorm string_imp))) : totally_disconnected_space (has_compl (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_56150 (h0 : functor.add_const (add_monoid (has_neg pos)) (option (mul_zero_class pos))) : @add_monoid.fg.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_neg.{0} pos)) (option.{0} (mul_zero_class.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_56151 (h0 : function.extfun (Type 1) (functor.comp ring has_add)) : @is_principal_ideal_ring.{1} (has_add.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} has_add.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} ring.{1} has_add.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_56152 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_56153 (h0 : not (complete_lattice (has_one linarith.comp) -> false)) : @is_atomistic.{0} (has_one.{0} linarith.comp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_one.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_56154 (h0 : functor.add_const (complete_lattice (has_to_string ennreal)) unsigned) : @is_atomistic.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_56155 (h0 : topological_space (semigroup (finset (finset (finset environment.implicit_infer_kind))))) : locally_compact_space (semigroup (finset (finset (finset environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_56156 (h0 : group (add_cancel_monoid (has_neg pos))) : normalizer_condition (add_cancel_monoid (has_neg pos)) := sorry --non-trivial
lemma new_lemma_56157 (h0 : monoid (id (random_gen linarith.comp_source))) : monoid.fg (id (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_56158 (h0 : measurable_space (simple_graph string.iterator_imp)) (h1 : filter (simple_graph string.iterator_imp)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_56159 (h0 : group (semigroup (semigroup environment.implicit_infer_kind))) : is_simple_group (semigroup (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_56160 (h0 : function.extfun nat fin) : @t0_space.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (boolean_algebra.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_56161 (h0 : add_group (random_gen (random_gen (has_inv (has_inv linarith.comp_source))))) : is_add_cyclic (random_gen (random_gen (has_inv (has_inv linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_56162 (h0 : uniform_space (has_neg_part (option unsigned))) : complete_space (has_neg_part (option unsigned)) := sorry --non-trivial
lemma new_lemma_56163 (h0 : group (has_pos_part (has_pos_part Type))) : normalizer_condition (has_pos_part (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_56164 (h0 : not (complete_lattice (distrib linarith.comp_source) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (distrib.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (distrib.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_56165 (h0 : topological_space (ordered_comm_group (option empty))) : locally_compact_space (ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_56166 (h0 : functor.add_const (list (has_add name)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_56167 (h1 : complete_lattice (comm_ring linarith.comp_source)) : is_compactly_generated (comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_56168 (h0 : topological_space (complete_distrib_lattice (semiring (semiring empty)))) : totally_separated_space (complete_distrib_lattice (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_56169 (h0 : add_monoid (canonically_ordered_comm_semiring (ring Type))) : add_monoid.fg (canonically_ordered_comm_semiring (ring Type)) := sorry --non-trivial
lemma new_lemma_56170 (h0 : function.extfun Type group) : @group.fg.{0} (has_sub.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (has_sub.{0} empty))  := sorry --non-trivial
lemma new_lemma_56171 (h0 : function.extfun (multiset (Type -> Type)) (has_mem.mem topological_space)) : @preconnected_space.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@multiset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (multiset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (multiset.{1} (Type → Type)) (@multiset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_zero.zero.{1} (multiset.{1} (Type → Type)) (@multiset.has_zero.{1} (Type → Type))))) (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_56172 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_56173 (h0 : has_zero (has_zero pos) -> has_zero (has_zero pos) -> Prop) : total h0 := sorry --non-trivial
lemma new_lemma_56174 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_56175 (h0 : topological_space (monoid num)) : discrete_topology (monoid num) := sorry --non-trivial
lemma new_lemma_56176 (h0 : ordered_add_comm_monoid (comm_semigroup (has_neg real))) : archimedean (comm_semigroup (has_neg real)) := sorry --non-trivial
lemma new_lemma_56177 (h0 : not (list (bin_tree unsigned) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_56178 (h0 : functor.add_const (filter (add_comm_monoid linarith.comp)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_56179 (h0 : topological_space (has_to_string (has_neg (has_Inf (has_Inf Type))))) : t0_space (has_to_string (has_neg (has_Inf (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_56180 (h0 : group (add_cancel_monoid (has_neg (finset (has_neg linarith.comp))))) : group.fg (add_cancel_monoid (has_neg (finset (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_56181 (h0 : functor.add_const (ordered_add_comm_monoid (comm_group Type)) (ring pos)) : @archimedean.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (comm_group.{1} Type)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_56182 (h0 : complete_lattice (measure_theory.measure_space (semiring (semiring empty)))) : is_atomistic (measure_theory.measure_space (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_56183 (h0 : topological_space (has_add unsigned)) : locally_compact_space (has_add unsigned) := sorry --non-trivial
lemma new_lemma_56184 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_ordered_comm_semiring.{0} (option.{0} pos)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_ordered_comm_semiring.{0} (option.{0} pos)))  := sorry --non-trivial
lemma new_lemma_56185 (h0 : functor.add_const (ordered_comm_monoid environment.implicit_infer_kind) (ring environment.implicit_infer_kind)) : @has_exists_mul_of_le.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} environment.implicit_infer_kind) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_56186 (h1 : list (topological_space (has_emptyc (random_gen to_additive.value_type)))) : @locally_compact_space.{0} (has_emptyc.{0} (random_gen.{0} to_additive.value_type)) (@list.head.{0} (topological_space.{0} (has_emptyc.{0} (random_gen.{0} to_additive.value_type))) (@inhabited_topological_space.{0} (has_emptyc.{0} (random_gen.{0} to_additive.value_type))) h1)  := sorry --non-trivial
lemma new_lemma_56187 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_inter.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_inter.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_56188 (h0 : ring (has_nndist (has_neg (finset Type)))) : is_principal_ideal_ring (has_nndist (has_neg (finset Type))) := sorry --non-trivial
lemma new_lemma_56189 (h1 : ring (has_le environment.projection_info)) : strong_rank_condition (has_le environment.projection_info) := sorry --non-trivial
lemma new_lemma_56190 (h0 : ring (complete_distrib_lattice real)) : rank_condition (complete_distrib_lattice real) := sorry --non-trivial
lemma new_lemma_56191 (h0 : function.extfun Type (functor.comp topological_space has_to_string)) : @t0_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_to_string.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_56192 (h0 : functor.add_const (function.extfun Type finset) (has_to_string linarith.comp)) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_56193 (h0 : functor.add_const (ring (has_pos_part pos)) (finset pos)) : @strong_rank_condition.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_pos_part.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_56194 (h0 : topological_space (finset pos)) : id (sequential_space (finset pos)) := sorry --non-trivial
lemma new_lemma_56195 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) Type) : @topological_space.separable_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (normed_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_56196 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_56197 (h0 : functor.add_const Prop (normed_comm_ring unsigned)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_56198 (h0 : ordered_add_comm_monoid (normed_comm_ring (ring linarith.comp))) : archimedean (normed_comm_ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_56199 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (left_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (left_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_56200 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_56201 (h0 : finset (add_right_cancel_monoid (semiring congr_arg_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_56202 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen congr_arg_kind))) : @normalizer_condition.{0} (random_gen.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type group.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_56203 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_56204 (h0 : topological_space (ordered_comm_ring (has_bot real))) : loc_path_connected_space (ordered_comm_ring (has_bot real)) := sorry --non-trivial
lemma new_lemma_56205 (h0 : group (simple_graph (has_neg pos))) : is_simple_group (simple_graph (has_neg pos)) := sorry --non-trivial
lemma new_lemma_56206 (h0 : not (semiring (linear_ordered_semiring linarith.comp) -> false)) : @is_noetherian_ring.{0} (linear_ordered_semiring.{0} linarith.comp) (@classical.by_contradiction'.{1} (semiring.{0} (linear_ordered_semiring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_56207 (h0 : functor.add_const (topological_space (ring name)) (has_add Type)) : @topological_space.separable_space.{0} (ring.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} name)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_56208 (h0 : group (has_one (semiring (semiring (semiring (semiring unsigned)))))) : normalizer_condition (has_one (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_56209 (h0 : complete_lattice (ring (finset linarith.comp))) : is_compactly_generated (ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_56210 (h0 : functor.add_const (ring (comm_group environment.implicit_infer_kind)) pos) : @is_domain.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_56211 (h0 : function.extfun Type topological_space) : @t1_space.{0} (cancel_monoid.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_56212 (h0 : topological_space (cancel_monoid ennreal)) : normal_space (cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_56213 (h0 : functor.add_const (monoid (semigroup environment.implicit_infer_kind)) pos) : @monoid.fg.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (monoid.{0} (semigroup.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_56214 (h0 : uniform_space (id congr_arg_kind)) : separated_space (id congr_arg_kind) := sorry --non-trivial
lemma new_lemma_56215 (h0 : semiring (has_pos_part (has_neg (has_neg name)))) : is_noetherian_ring (has_pos_part (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_56216 (h0 : topological_space (has_top (has_norm congr_arg_kind))) : discrete_topology (has_top (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_56217 (h0 : function.extfun Type complete_lattice) : is_atomistic (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_56218 (h0 : functor.add_const (monoid (is_R_or_C empty)) (semiring unsigned)) : @monoid.fg.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (is_R_or_C.{0} empty)) (semiring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_56219 (h0 : topological_space (has_neg (semigroup linarith.comp))) : totally_disconnected_space (has_neg (semigroup linarith.comp)) := sorry --non-trivial
lemma new_lemma_56220 (h1 : topological_space (random_gen fun_info)) : discrete_topology (random_gen fun_info) := sorry --non-trivial
lemma new_lemma_56221 (h0 : ring (monoid_with_zero (option ennreal))) : is_principal_ideal_ring (monoid_with_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_56222 (h4 : not (group (has_ssubset reducibility_hints) -> false)) : @is_cyclic.{0} (has_ssubset.{0} reducibility_hints) (@classical.by_contradiction'.{1} (group.{0} (has_ssubset.{0} reducibility_hints)) h4)  := sorry --non-trivial
lemma new_lemma_56223 (h0 : monoid (add_group num)) : monoid.fg (add_group num) := sorry --non-trivial
lemma new_lemma_56224 (h0 : not (topological_space (has_union num) -> false)) : @totally_separated_space.{0} (has_union.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_union.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_56225 (h1 : topological_space (dlist (has_nnnorm fun_info))) : totally_disconnected_space (dlist (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_56226 (h0 : function.extfun Type group) : @is_cyclic.{0} auto.case_option (@function.extfun_app.{2 1} Type group.{0} h0 auto.case_option)  := sorry --non-trivial
lemma new_lemma_56227 (h0 : topological_space (add_comm_semigroup (mul_one_class char))) (h2 : Prop) : is_path_connected (id (fun (h1 : add_comm_semigroup (mul_one_class char)), h2)) := sorry --non-trivial
lemma new_lemma_56228 (h2 : group (with_one (with_bot (with_bot string_imp)))) : normalizer_condition (with_one (with_bot (with_bot string_imp))) := sorry --non-trivial
lemma new_lemma_56229 (h0 : cancel_comm_monoid_with_zero (linear_ordered_comm_group (option ennreal))) : unique_factorization_monoid (linear_ordered_comm_group (option ennreal)) := sorry --non-trivial
lemma new_lemma_56230 (h0 : group (semigroup (finset (has_nndist pos)))) : normalizer_condition (semigroup (finset (has_nndist pos))) := sorry --non-trivial
lemma new_lemma_56231 (h0 : topological_space (semiring (has_norm unsigned))) : discrete_topology (semiring (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_56232 (h0 : has_mem.mem (with_bot num) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_bot.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_56233 (h0 : topological_space (monoid congr_arg_kind)) : topological_space.separable_space (monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_56234 (h0 : topological_space (has_bot pos)) : normal_space (has_bot pos) := sorry --non-trivial
lemma new_lemma_56235 (h3 : topological_space (semi_normed_ring linarith.ineq)) : t0_space (semi_normed_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_56236 (h0 : functor.add_const (topological_space (has_nndist name)) pos) : @discrete_topology.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_56237 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_56238 (h0 : add_group (ordered_ring (semiring congr_arg_kind))) : is_add_cyclic (ordered_ring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_56239 (h0 : cancel_comm_monoid_with_zero (has_nndist (has_Inf Type))) : unique_factorization_monoid (has_nndist (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_56240 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (sub_neg_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_56241 (h0 : topological_space (boolean_algebra.core (has_neg_part Type))) : loc_path_connected_space (boolean_algebra.core (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_56242 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_nndist (option ennreal))) := sorry --non-trivial
lemma new_lemma_56243 (h0 : ring (option congr_arg_kind)) : rank_condition (option congr_arg_kind) := sorry --non-trivial
lemma new_lemma_56244 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (normed_group.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_56245 (h0 : ordered_comm_monoid (cancel_monoid Type)) : has_exists_mul_of_le (cancel_monoid Type) := sorry --non-trivial
lemma new_lemma_56246 (h0 : uniform_space (denumerable (random_gen fun_info))) : complete_space (denumerable (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_56247 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_56248 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_56249 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @group.fg.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_56250 (h0 : function.extfun (Type 1) ring) : @strong_rank_condition.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_56251 (h1 : topological_space (has_ssubset (random_gen (random_gen char)))) : t0_space (has_ssubset (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_56252 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra.core (has_to_string environment.implicit_infer_kind))) pos) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} (has_to_string.{0} environment.implicit_infer_kind)) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.core.{0} (has_to_string.{0} environment.implicit_infer_kind))) pos h0)  := sorry --non-trivial
lemma new_lemma_56253 (h0 : add_group (comm_group (has_add name))) : is_add_cyclic (comm_group (has_add name)) := sorry --non-trivial
lemma new_lemma_56254 (h0 : topological_space (has_nndist (finset pos))) : preirreducible_space (has_nndist (finset pos)) := sorry --non-trivial
lemma new_lemma_56255 (h0 : not (complete_lattice (semiring fun_info) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semiring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_56256 (h0 : topological_space (uniform_space pos)) : irreducible_space (uniform_space pos) := sorry --non-trivial
lemma new_lemma_56257 (h0 : functor.add_const (topological_space (bin_tree empty)) unsigned) : @normal_space.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_56258 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_star unsigned)) := sorry --non-trivial
lemma new_lemma_56259 (h0 : function.extfun Type ring) : @rank_condition.{0} (dlist.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (dlist.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_56260 (h0 : monoid (linear_ordered_semiring (with_bot congr_arg_kind))) : monoid.fg (linear_ordered_semiring (with_bot congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_56261 (h0 : add_monoid pos) : add_monoid.fg pos := sorry --non-trivial
lemma new_lemma_56262 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_56263 (h0 : function.extfun Type (functor.add_const (topological_space znum))) : @loc_path_connected_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} znum)) h0 num))  := sorry --non-trivial
lemma new_lemma_56264 (h0 : functor.add_const (topological_space (generalized_boolean_algebra Type)) pos) : @locally_compact_space.{1} (generalized_boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_56265 (h0 : uniform_space (with_bot (random_gen (semiring to_additive.value_type)))) : complete_space (with_bot (random_gen (semiring to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_56266 (h0 : topological_space (add_comm_monoid (has_Inf Type))) : sequential_space (add_comm_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_56267 (h0 : group (comm_group name)) : group.fg (comm_group name) := sorry --non-trivial
lemma new_lemma_56268 (h0 : complete_lattice (generalized_boolean_algebra (ordered_ring (ring Type)))) : complete_lattice.is_Sup_finite_compact (generalized_boolean_algebra (ordered_ring (ring Type))) := sorry --non-trivial
lemma new_lemma_56269 (h1 : topological_space (mul_one_class linarith.comp_source)) : path_connected_space (mul_one_class linarith.comp_source) := sorry --non-trivial
lemma new_lemma_56270 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (mul_zero_class.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (mul_zero_class.{0} num))  := sorry --non-trivial
lemma new_lemma_56271 (h0 : ring (complete_distrib_lattice num)) : is_domain (complete_distrib_lattice num) := sorry --non-trivial
lemma new_lemma_56272 (h0 : topological_space (omega_complete_partial_order (has_add (ring pos)))) : t0_space (omega_complete_partial_order (has_add (ring pos))) := sorry --non-trivial
lemma new_lemma_56273 (h2 : set (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup ereal)) -> std_gen)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_56274 (h0 : functor.add_const (topological_space (linear_ordered_field ennreal)) unsigned) : @loc_path_connected_space.{0} (linear_ordered_field.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_56275 (h2 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} fun_info (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h2) fun_info)  := sorry --non-trivial
lemma new_lemma_56276 (h0 : topological_space (comm_semigroup (has_add real))) : normal_space (comm_semigroup (has_add real)) := sorry --non-trivial
lemma new_lemma_56277 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (ordered_comm_group.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ordered_comm_group.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_56278 (h0 : topological_space (normed_comm_ring (option (ring unsigned)))) : t0_space (normed_comm_ring (option (ring unsigned))) := sorry --non-trivial
lemma new_lemma_56279 (h0 : function.extfun (Type 1) topological_space) : @irreducible_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_56280 (h0 : functor.add_const (group (bin_tree num)) congr_arg_kind) : @is_cyclic.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (group.{0} (bin_tree.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_56281 (h0 : functor.add_const (group (has_bot empty)) empty) : @group.fg.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (has_bot.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_56282 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_56283 (h0 : topological_space (pseudo_metric_space (option unsigned))) : t0_space (pseudo_metric_space (option unsigned)) := sorry --non-trivial
lemma new_lemma_56284 (h0 : functor.add_const (topological_space (simple_graph Type)) Type) : @totally_disconnected_space.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (simple_graph.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_56285 (h0 : topological_space (has_pos_part (has_pos_part real))) : preconnected_space (has_pos_part (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_56286 (h0 : function.extfun Type (functor.add_const (topological_space (free_add_monoid unsigned)))) : @t0_space.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} unsigned)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (free_add_monoid.{0} unsigned))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_56287 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_56288 (h0 : functor.add_const Prop (mul_zero_class ennreal)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_56289 (h0 : function.extfun Type (functor.comp add_monoid has_neg)) : @add_monoid.fg.{0} (has_neg.{0} pos) (@functor.comp.run.{0 0 0} add_monoid.{0} has_neg.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} add_monoid.{0} has_neg.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_56290 (h0 : complete_lattice (pseudo_metric_space name)) : complete_lattice.is_Sup_finite_compact (pseudo_metric_space name) := sorry --non-trivial
lemma new_lemma_56291 (h1 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h1 (has_emptyc congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_56292 (h0 : ring (has_nnnorm environment.projection_info)) : rank_condition (has_nnnorm environment.projection_info) := sorry --non-trivial
lemma new_lemma_56293 (h0 : ring (with_bot (semiring (semiring (semiring (semiring unsigned)))))) : is_principal_ideal_ring (with_bot (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_56294 (h0 : complete_lattice (topological_space reducibility_hints)) : is_compactly_generated (topological_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_56295 (h0 : set to_additive.value_type) : set.finite h0 := sorry --non-trivial
lemma new_lemma_56296 (h0 : set (linear_ordered_comm_group_with_zero environment.projection_info)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_56297 (h0 : function.extfun Type (functor.add_const (group pos))) : @normalizer_condition.{0} pos (@functor.add_const.run.{0 0} (group.{0} pos) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (group.{0} pos)) h0 pos))  := sorry --non-trivial
lemma new_lemma_56298 (h0 : group (has_top (dlist (has_top linarith.ineq)))) : is_cyclic (has_top (dlist (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_56299 (h0 : functor.add_const (topological_space (non_assoc_semiring unsigned)) unsigned) : @irreducible_space.{0} (non_assoc_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_56300 (h0 : group (measurable_space (has_inv (random_gen to_additive.value_type)))) : is_cyclic (measurable_space (has_inv (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_56301 (h0 : ordered_add_comm_monoid (has_Inf (ring linarith.comp))) : archimedean (has_Inf (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_56302 (h0 : group (has_zero (finset (has_neg (finset environment.implicit_infer_kind))))) : is_simple_group (has_zero (finset (has_neg (finset environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_56303 (h0 : functor.add_const (uniform_space (add_cancel_monoid Type)) environment.implicit_infer_kind) : @separated_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (add_cancel_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_56304 (h0 : not (uniform_space (metric_space linarith.comp) -> false)) : @separated_space.{0} (metric_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (uniform_space.{0} (metric_space.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_56305 (h0 : functor.add_const (topological_space (has_nndist pos)) (has_Inf (has_Inf pos))) : @totally_disconnected_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) (has_Inf.{0} (has_Inf.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_56306 (h1 : not (topological_space (non_unital_non_assoc_semiring string_imp) -> false)) : @t0_space.{0} (non_unital_non_assoc_semiring.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (non_unital_non_assoc_semiring.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_56307 (h0 : list (semigroup (option (option (option (option unsigned)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_56308 (h0 : functor.add_const (add_group (canonically_ordered_comm_semiring unsigned)) unsigned) : @is_add_cyclic.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (canonically_ordered_comm_semiring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_56309 (h0 : topological_space (canonically_ordered_monoid (has_add (has_Inf linarith.comp)))) : normal_space (canonically_ordered_monoid (has_add (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_56310 (h1 : topological_space (non_unital_non_assoc_semiring (mul_one_class string.iterator_imp))) : t0_space (non_unital_non_assoc_semiring (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_56311 (h0 : functor.add_const (function.extfun Type group) Type) : @normalizer_condition.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_56312 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @rank_condition.{0} ennreal (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) ring.{0}) ennreal)  := sorry --non-trivial
lemma new_lemma_56313 (h0 : add_monoid (has_nndist num)) : add_monoid.fg (has_nndist num) := sorry --non-trivial
lemma new_lemma_56314 (h0 : function.extfun Type (functor.add_const (filter (has_nndist num)))) : filter.ne_bot (functor.add_const.run (function.extfun_app h0 ennreal)) := sorry --non-trivial
lemma new_lemma_56315 (h1 : function.extfun Type topological_space) : @t0_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_56316 (h1 : topological_space (add_cancel_comm_monoid char)) : totally_disconnected_space (add_cancel_comm_monoid char) := sorry --non-trivial
lemma new_lemma_56317 (h0 : complete_lattice (distrib fun_info)) : is_compactly_generated (distrib fun_info) := sorry --non-trivial
lemma new_lemma_56318 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_56319 (h0 : not (add_group (has_emptyc num) -> false)) : @is_add_cyclic.{0} (has_emptyc.{0} num) (@classical.by_contradiction'.{1} (add_group.{0} (has_emptyc.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_56320 (h0 : group (denumerable (has_inv linarith.ineq))) : is_cyclic (denumerable (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_56321 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_56322 (h0 : function.extfun Type group) : @is_cyclic.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_56323 (h0 : functor.add_const (topological_space (boolean_algebra Type)) name) : @t1_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_56324 (h0 : function.extfun Type group) : @normalizer_condition.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} h0 (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_56325 (h0 : has_mem.mem (has_norm fun_info) has_emptyc.emptyc) (h1 : set (has_norm fun_info)) : @set.ord_connected.{0} (has_norm.{0} fun_info) (@finset.pi.empty.{1 0} Type preorder.{0} (has_norm.{0} fun_info) h0) h1  := sorry --non-trivial
lemma new_lemma_56326 (h0 : topological_space (linear_ordered_semiring (random_gen linarith.comp_source))) : locally_compact_space (linear_ordered_semiring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_56327 (h0 : ring (comm_group pos)) : rank_condition (comm_group pos) := sorry --non-trivial
lemma new_lemma_56328 (h0 : functor.add_const (topological_space (semigroup pos)) name) : @locally_compact_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_56329 (h0 : topological_space (normed_field fun_info)) : totally_disconnected_space (normed_field fun_info) := sorry --non-trivial
lemma new_lemma_56330 (h0 : fin has_zero.zero) : @complete_space.{0} (ordered_comm_monoid.{0} name) (@matrix.vec_empty.{0} (uniform_space.{0} (ordered_comm_monoid.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_56331 (h0 : list (simple_graph pos)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_56332 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_56333 (h0 : functor.add_const (topological_space (boolean_algebra pos)) (boolean_algebra Type)) : @t0_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} pos)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_56334 (h0 : functor.add_const (group (has_inter empty)) empty) : @normalizer_condition.{0} (has_inter.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (has_inter.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_56335 (h0 : pseudo_metric_space (has_append (random_gen (random_gen to_additive.value_type)))) (h1 : set (has_append (random_gen (random_gen to_additive.value_type)))) : metric.bounded h1 := sorry --non-trivial
lemma new_lemma_56336 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_56337 (h0 : ring (cancel_monoid (normed_comm_ring Type))) : is_principal_ideal_ring (cancel_monoid (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_56338 (h0 : complete_lattice (simple_graph (mul_one_class enat))) : is_compactly_generated (simple_graph (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_56339 (h1 : group (has_inv linarith.ineq)) : is_cyclic (has_inv linarith.ineq) := sorry --non-trivial
lemma new_lemma_56340 (h3 : group (normed_field char)) : is_cyclic (normed_field char) := sorry --non-trivial
lemma new_lemma_56341 (h0 : functor.add_const (ordered_add_comm_monoid (linear_ordered_field ennreal)) unsigned) : @archimedean.{0} (linear_ordered_field.{0} ennreal) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (linear_ordered_field.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_56342 (h0 : group (with_one num)) : normalizer_condition (with_one num) := sorry --non-trivial
lemma new_lemma_56343 (h0 : fin has_zero.zero) : @path_connected_space.{0} (ordered_comm_monoid.{0} name) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_56344 (h0 : ring environment.projection_info) : rank_condition environment.projection_info := sorry --non-trivial
lemma new_lemma_56345 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (bin_tree.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} empty))  := sorry --non-trivial
lemma new_lemma_56346 (h1 : group (encodable (random_gen (random_gen string_imp)))) : is_cyclic (encodable (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_56347 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) linarith.comp) : @unique_factorization_monoid.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) linarith.comp h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_56348 (h0 : topological_space (add_group (semiring unsigned))) : locally_compact_space (add_group (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_56349 (h0 : ring (has_append (has_nnnorm char))) : is_domain (has_append (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_56350 (h0 : functor.add_const (cancel_comm_monoid_with_zero (semigroup name)) environment.implicit_infer_kind) : @unique_factorization_monoid.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (semigroup.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_56351 (h0 : cancel_comm_monoid_with_zero (simple_graph (option empty))) : unique_factorization_monoid (simple_graph (option empty)) := sorry --non-trivial
lemma new_lemma_56352 (h1 : has_le (add_comm_semigroup fun_info)) : no_top_order (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_56353 (h0 : functor.add_const (complete_lattice (boolean_algebra pos)) Type) : @is_atomistic.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_56354 (h0 h1 : nat) (h2 : unit) : id (scope_trace (connected_component (id h2))) := sorry --non-trivial
lemma new_lemma_56355 (h1 : ring (random_gen (comm_ring (comm_ring reducibility_hints)))) : rank_condition (random_gen (comm_ring (comm_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_56356 (h0 : complete_lattice (distrib char)) : is_compactly_generated (distrib char) := sorry --non-trivial
lemma new_lemma_56357 (h0 : not (topological_space (dlist fun_info) -> false)) : @totally_disconnected_space.{0} (dlist.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (dlist.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_56358 (h0 : ring (normed_group (random_gen (random_gen string_imp)))) : strong_rank_condition (normed_group (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_56359 (h0 : add_group (cancel_monoid (option ennreal))) : is_add_cyclic (cancel_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_56360 (h0 : functor.add_const (ordered_add_comm_monoid (is_R_or_C unsigned)) (option unsigned)) : @archimedean.{0} (is_R_or_C.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (is_R_or_C.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_56361 (h0 : functor.add_const (complete_lattice (add_comm_monoid name)) Type) : @is_compactly_generated.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (add_comm_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_56362 (h2 : topological_space linarith.ineq) : path_connected_space linarith.ineq := sorry --non-trivial
lemma new_lemma_56363 (h0 : has_mem.mem Type has_emptyc.emptyc) : @add_monoid.fg.{1} Type (@finset.pi.empty.{2 1} (Type 1) add_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_56364 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (non_assoc_semiring.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} h0 (non_assoc_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_56365 (h0 : topological_space (has_neg (has_neg (has_neg pos)))) : totally_disconnected_space (has_neg (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_56366 (h0 : topological_space (has_neg (has_neg name))) : locally_compact_space (has_neg (has_neg name)) := sorry --non-trivial
lemma new_lemma_56367 (h0 : cancel_comm_monoid_with_zero (normed_comm_ring (boolean_algebra.core name))) : unique_factorization_monoid (normed_comm_ring (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_56368 (h0 : add_monoid (has_union (semiring (semiring (has_norm linarith.comp))))) : add_monoid.fg (has_union (semiring (semiring (has_norm linarith.comp)))) := sorry --non-trivial
lemma new_lemma_56369 (h0 : function.extfun Type ring) : @is_domain.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_56370 (h0 : not (topological_space (with_one unsigned) -> false)) : @path_connected_space.{0} (with_one.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_56371 (h0 : functor.comp uniform_space ring pos) : @separated_space.{0} (ring.{0} pos) (@functor.comp.run.{0 0 0} uniform_space.{0} ring.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_56372 (h0 : not (ring (has_emptyc num) -> false)) : @strong_rank_condition.{0} (has_emptyc.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (has_emptyc.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_56373 (h0 : topological_space (plift (semiring (semiring num)))) : preirreducible_space (plift (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_56374 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (linear_ordered_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_56375 (h0 : has_coe linarith.comp_source Prop) (h1 : linarith.comp_source) : @coe_b.{1 1} linarith.comp_source Prop h0 h1  := sorry --non-trivial
lemma new_lemma_56376 (h0 : uniform_space (has_add unsigned)) : complete_space (has_add unsigned) := sorry --non-trivial
lemma new_lemma_56377 (h1 : topological_space (normed_field (metric_space to_additive.value_type))) : t0_space (normed_field (metric_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_56378 (h0 : not (function.extfun Type list -> false)) : list.nodup (function.extfun_app (classical.by_contradiction' h0) (with_bot linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_56379 (h0 : not (group (has_emptyc empty) -> false)) : @group.fg.{0} (has_emptyc.{0} empty) (@classical.by_contradiction'.{1} (group.{0} (has_emptyc.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_56380 (h0 : complete_lattice (has_add (option name))) : complete_lattice.is_Sup_finite_compact (has_add (option name)) := sorry --non-trivial
lemma new_lemma_56381 (h0 : ring (boolean_algebra (has_neg (has_neg pos)))) : rank_condition (boolean_algebra (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_56382 (h0 : topological_space (has_dist (option empty))) : t0_space (has_dist (option empty)) := sorry --non-trivial
lemma new_lemma_56383 (h0 : topological_space (has_inf (semiring (semiring congr_arg_kind)))) : irreducible_space (has_inf (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_56384 (h0 : complete_lattice (normed_comm_ring (has_add (finset name)))) : is_atomistic (normed_comm_ring (has_add (finset name))) := sorry --non-trivial
lemma new_lemma_56385 (h0 : list (ring pos)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_56386 (h0 : topological_space (has_neg (has_neg linarith.comp))) : topological_space.separable_space (has_neg (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_56387 (h0 : function.extfun Type group) : @normalizer_condition.{0} (add_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (add_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_56388 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_disconnected_space.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_56389 (h0 : functor.add_const (filter (add_cancel_monoid environment.implicit_infer_kind)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_56390 (h0 : complete_lattice (has_star (semiring num))) : complete_lattice.is_Sup_finite_compact (has_star (semiring num)) := sorry --non-trivial
lemma new_lemma_56391 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (normed_linear_ordered_group.{0} (semiring.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_linear_ordered_group.{0} (semiring.{0} empty)))  := sorry --non-trivial
lemma new_lemma_56392 (h0 : group (linear_ordered_semiring (has_norm (has_norm empty)))) : is_cyclic (linear_ordered_semiring (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_56393 (h2 : not (ring (topological_space char) -> false)) : @is_domain.{0} (topological_space.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (topological_space.{0} char)) h2)  := sorry --non-trivial
lemma new_lemma_56394 (h0 : functor.add_const (function.extfun Type add_group) Type) : @is_add_cyclic.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_group.{0}) Type h0) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_56395 (h1 : function.extfun Type topological_space) : @t0_space.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_56396 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_56397 (h0 h1 : multiset (has_div (mul_one_class (mul_one_class char)))) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_56398 (h0 : uniform_space (add_comm_monoid (has_neg_part (has_neg_part linarith.comp)))) : separated_space (add_comm_monoid (has_neg_part (has_neg_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_56399 (h0 : ring (normed_lattice_add_comm_group (has_neg (has_Inf (has_Inf (has_neg (has_Inf real))))))) : is_domain (normed_lattice_add_comm_group (has_neg (has_Inf (has_Inf (has_neg (has_Inf real)))))) := sorry --non-trivial
lemma new_lemma_56400 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @discrete_topology.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_56401 (h0 : not (complete_lattice (mul_zero_class empty) -> false)) : @is_atomistic.{0} (mul_zero_class.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (mul_zero_class.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_56402 (h0 : ordered_add_comm_monoid (has_pos_part (sub_neg_monoid Type))) : archimedean (has_pos_part (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_56403 (h1 : list (measurable_space string_imp)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_56404 (h0 : group (linear_ordered_comm_group congr_arg_kind)) : normalizer_condition (linear_ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_56405 (h0 : ring (add_comm_semigroup (mul_one_class linarith.ineq))) : is_domain (add_comm_semigroup (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_56406 (h0 : function.extfun Type topological_space) : @t0_space.{0} fun_info (@function.extfun_app.{2 1} Type topological_space.{0} h0 fun_info)  := sorry --non-trivial
lemma new_lemma_56407 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (add_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_56408 (h0 : topological_space (normed_comm_ring (option num))) : totally_disconnected_space (normed_comm_ring (option num)) := sorry --non-trivial
lemma new_lemma_56409 (h0 : functor.add_const (topological_space (free_add_monoid empty)) empty) : @loc_path_connected_space.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_56410 (h0 : functor.add_const (function.extfun Type uniform_space) pos) : @separated_space.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) pos h0) (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_56411 (h0 : fin has_zero.zero) : @t1_space.{0} (add_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_56412 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_neg_part.{0} (add_comm_monoid.{0} unsigned)) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_neg_part.{0} (add_comm_monoid.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_56413 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (simple_graph.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_56414 (h0 : ring (has_zero (has_neg environment.implicit_infer_kind))) : is_principal_ideal_ring (has_zero (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_56415 (h0 : semiring (normed_comm_ring (has_neg linarith.comp))) : is_noetherian_ring (normed_comm_ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_56416 (h0 : group (has_zero (normed_comm_ring Type))) : normalizer_condition (has_zero (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_56417 (h0 : topological_space (random_gen (semiring (semiring congr_arg_kind)))) : locally_compact_space (random_gen (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_56418 (h0 : functor.add_const (complete_lattice (semiring unsigned)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semiring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_56419 (h0 : cancel_comm_monoid_with_zero (canonically_linear_ordered_monoid (option ennreal))) : unique_factorization_monoid (canonically_linear_ordered_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_56420 (h0 : functor.add_const (uniform_space (boolean_algebra.core Type)) Type) : @separated_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (boolean_algebra.core.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_56421 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_56422 (h0 : complete_lattice (has_bot (has_Inf Type))) : is_compactly_generated (has_bot (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_56423 (h0 : group (sub_neg_monoid linarith.comp)) : is_cyclic (sub_neg_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_56424 (h1 : complete_lattice (non_unital_non_assoc_semiring (mul_one_class enat))) : is_compactly_generated (non_unital_non_assoc_semiring (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_56425 (h0 : denumerable to_additive.value_type -> denumerable to_additive.value_type -> denumerable to_additive.value_type) : is_right_cancel (denumerable to_additive.value_type) h0 := sorry --non-trivial
lemma new_lemma_56426 (h0 : topological_space (measurable_space linarith.comp)) : preirreducible_space (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_56427 (h0 : functor.add_const (ring (semigroup pos)) name) : @is_domain.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_56428 (h0 : functor.add_const (ordered_add_comm_monoid (semigroup pos)) (option pos)) : @archimedean.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (semigroup.{0} pos)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_56429 (h0 : uniform_space (linear_order (option (option (option (option unsigned)))))) : separated_space (linear_order (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_56430 (h0 : uniform_space (monoid (option (option (option ennreal))))) : separated_space (monoid (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_56431 (h0 : group (has_one (semiring (semiring (semiring num))))) : is_cyclic (has_one (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_56432 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preconnected_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_56433 (h0 : ring (semi_normed_ring (mul_one_class linarith.ineq))) : strong_rank_condition (semi_normed_ring (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_56434 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_56435 (h0 : ordered_comm_monoid (ring (has_neg name))) : has_exists_mul_of_le (ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_56436 (h0 : group (linear_ordered_add_comm_group linarith.ineq)) : normalizer_condition (linear_ordered_add_comm_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_56437 (h1 : Prop) : set.separates_points (id (fun (h0 : enat -> std_gen), h1)) := sorry --non-trivial
lemma new_lemma_56438 (h0 : complete_lattice (finset (has_neg Type))) : complete_lattice.is_Sup_finite_compact (finset (has_neg Type)) := sorry --non-trivial
lemma new_lemma_56439 (h0 : topological_space (has_inv (random_gen (random_gen (random_gen (has_top linarith.ineq)))))) : irreducible_space (has_inv (random_gen (random_gen (random_gen (has_top linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_56440 (h1 : function.extfun Type add_group) : @is_add_cyclic.{0} (measurable_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type add_group.{0} h1 (measurable_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_56441 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_to_string num)) := sorry --non-trivial
lemma new_lemma_56442 (h0 : has_mem.mem (with_one empty) has_emptyc.emptyc) : @normal_space.{0} (with_one.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_56443 (h0 : functor.add_const (topological_space (has_to_string unsigned)) linarith.comp) : @discrete_topology.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_56444 (h0 : group (group_with_zero (option (option ennreal)))) : is_cyclic (group_with_zero (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_56445 (h0 : function.extfun Type group) : @is_cyclic.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_56446 (h0 : function.extfun Type ring) : @rank_condition.{0} (ordered_ring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_56447 (h0 : topological_space (linear_ordered_cancel_comm_monoid num)) : loc_path_connected_space (linear_ordered_cancel_comm_monoid num) := sorry --non-trivial
lemma new_lemma_56448 (h0 : group (sub_neg_monoid (has_nndist pos))) : normalizer_condition (sub_neg_monoid (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_56449 (h0 : filter (distrib_lattice (random_gen fun_info))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_56450 (h0 : topological_space (has_nnnorm (mul_one_class linarith.ineq))) : totally_disconnected_space (has_nnnorm (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_56451 (h0 : cancel_comm_monoid_with_zero (finset (ordered_comm_monoid (ordered_comm_monoid linarith.comp)))) : unique_factorization_monoid (finset (ordered_comm_monoid (ordered_comm_monoid linarith.comp))) := sorry --non-trivial
lemma new_lemma_56452 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_56453 (h0 : monoid (semigroup (has_neg (has_zero (has_neg (ring pos)))))) : monoid.fg (semigroup (has_neg (has_zero (has_neg (ring pos))))) := sorry --non-trivial
lemma new_lemma_56454 (h0 : filter (monoid (option (option empty)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_56455 (h0 : ring (has_Sup (option empty))) : is_principal_ideal_ring (has_Sup (option empty)) := sorry --non-trivial
lemma new_lemma_56456 (h0 : functor.add_const (uniform_space (has_neg Type)) unsigned) : @separated_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_neg.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_56457 (h0 : add_group (has_neg_part reducibility_hints)) : is_add_cyclic (has_neg_part reducibility_hints) := sorry --non-trivial
lemma new_lemma_56458 (h0 : functor.add_const (topological_space (has_to_string unsigned)) num) : @preconnected_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_56459 (h0 : add_group (ordered_comm_ring (has_bot (has_bot real)))) : is_add_cyclic (ordered_comm_ring (has_bot (has_bot real))) := sorry --non-trivial
lemma new_lemma_56460 (h0 : group (has_append (random_gen (has_nnnorm reducibility_hints)))) : is_cyclic (has_append (random_gen (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_56461 (h0 : set (add_comm_semigroup enat -> linear_ordered_cancel_add_comm_monoid fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_56462 (h0 : filter (add_cancel_monoid empty)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_56463 (h1 : topological_space (has_one empty)) : normal_space (has_one empty) := sorry --non-trivial
lemma new_lemma_56464 (h0 : functor.add_const (topological_space (mul_zero_class unsigned)) unsigned) : @t1_space.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_56465 (h0 : functor.add_const (filter (ring name)) environment.implicit_infer_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_56466 (h0 : function.extfun Type (functor.add_const (ring (partial_order empty)))) : @is_principal_ideal_ring.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (partial_order.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (partial_order.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_56467 (h0 : not (function.extfun Type topological_space -> false)) : @topological_space.separable_space.{0} (bin_tree.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (bin_tree.{0} empty))  := sorry --non-trivial
lemma new_lemma_56468 (h0 : topological_space (has_norm (has_top (has_top linarith.comp_source)))) : path_connected_space (has_norm (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_56469 (h0 : not (complete_lattice (has_well_founded congr_arg_kind) -> false)) : @is_compactly_generated.{1} (has_well_founded.{1} congr_arg_kind) (@classical.by_contradiction'.{2} (complete_lattice.{1} (has_well_founded.{1} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_56470 (h0 : semiring (add_comm_monoid (has_to_string Type))) : is_noetherian_ring (add_comm_monoid (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_56471 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (random_gen.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_56472 (h0 : ring (semiring unsigned)) : strong_rank_condition (semiring unsigned) := sorry --non-trivial
lemma new_lemma_56473 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_56474 (h0 : topological_space (add_cancel_monoid (has_add linarith.comp))) : preconnected_space (add_cancel_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_56475 (h0 : function.extfun (finset Type) (has_mem.mem linarith.comp_source)) : @is_cyclic.{0} linarith.comp_source (@finset.pi.empty.{1 0} Type group.{0} linarith.comp_source (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp_source) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_56476 (h0 : group (has_edist congr_arg_kind)) : group.fg (has_edist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_56477 (h0 : group (non_assoc_semiring (option unsigned))) : normalizer_condition (non_assoc_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_56478 (h0 : ring (nondiscrete_normed_field (mul_one_class reducibility_hints))) : is_domain (nondiscrete_normed_field (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_56479 (h0 : group (has_nndist num)) : is_cyclic (has_nndist num) := sorry --non-trivial
lemma new_lemma_56480 (h0 : filter (boolean_algebra (has_Inf pos))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_56481 (h0 : not (complete_lattice (normed_group unsigned) -> false)) : @is_compactly_generated.{0} (normed_group.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_56482 (h0 : topological_space (simple_graph (generalized_boolean_algebra (has_Inf (has_nndist (has_add Type)))))) : irreducible_space (simple_graph (generalized_boolean_algebra (has_Inf (has_nndist (has_add Type))))) := sorry --non-trivial
lemma new_lemma_56483 (h0 : uniform_space (complete_semilattice_Sup (semiring (semiring (semiring unsigned))))) : complete_space (complete_semilattice_Sup (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_56484 (h1 : not (complete_lattice num -> false)) : @is_atomistic.{0} num (@classical.by_contradiction'.{1} (complete_lattice.{0} num) h1)  := sorry --non-trivial
lemma new_lemma_56485 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_56486 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @separated_space.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (normed_lattice_add_comm_group.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_56487 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) pos) : @topological_space.separable_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_56488 (h0 : group (ordered_comm_monoid (ordered_comm_monoid (has_Inf (has_add real))))) : normalizer_condition (ordered_comm_monoid (ordered_comm_monoid (has_Inf (has_add real)))) := sorry --non-trivial
lemma new_lemma_56489 (h0 : list (has_nndist (has_add name))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_56490 (h0 : uniform_space (add_cancel_monoid (metric_space Type))) : complete_space (add_cancel_monoid (metric_space Type)) := sorry --non-trivial
lemma new_lemma_56491 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (complete_linear_order.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (complete_linear_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_56492 (h0 : not (topological_space (distrib_lattice linarith.comp_source) -> false)) : @t0_space.{0} (distrib_lattice.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib_lattice.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_56493 (h0 : topological_space (random_gen (has_top (comm_ring (comm_ring to_additive.value_type))))) : t0_space (random_gen (has_top (comm_ring (comm_ring to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_56494 (h0 : add_group (has_to_string (option (option (option (option num)))))) : is_add_cyclic (has_to_string (option (option (option (option num))))) := sorry --non-trivial
lemma new_lemma_56495 (h0 : functor.add_const (function.extfun Type ring) pos) : @strong_rank_condition.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_56496 (h0 : topological_space (simple_graph linarith.comp_source)) : totally_disconnected_space (simple_graph linarith.comp_source) := sorry --non-trivial
lemma new_lemma_56497 (h0 : functor.add_const (semiring (semigroup pos)) unsigned) : @is_noetherian_ring.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (semigroup.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_56498 (h0 : topological_space (has_ssubset (has_inv (random_gen (random_gen to_additive.value_type))))) : path_connected_space (has_ssubset (has_inv (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_56499 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) linarith.comp) : @locally_compact_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_56500 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_56501 (h0 : add_monoid (has_top empty)) : add_monoid.fg (has_top empty) := sorry --non-trivial
lemma new_lemma_56502 (h0 : linear_ordered_cancel_comm_monoid (option empty) -> linear_ordered_cancel_comm_monoid (option empty) -> bool) : is_dec_refl h0 := sorry --non-trivial
lemma new_lemma_56503 (h0 : cancel_comm_monoid_with_zero (ring num)) : unique_factorization_monoid (ring num) := sorry --non-trivial
lemma new_lemma_56504 (h0 : ring (boolean_algebra.core ennreal)) : rank_condition (boolean_algebra.core ennreal) := sorry --non-trivial
lemma new_lemma_56505 (h0 : complete_lattice (uniform_space (distrib (mul_one_class fun_info)))) : complete_lattice.is_Sup_finite_compact (uniform_space (distrib (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_56506 (h0 : topological_space (has_one (semiring (semiring (semiring empty))))) : irreducible_space (has_one (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_56507 (h0 : uniform_space (canonically_linear_ordered_monoid (has_neg name))) : separated_space (canonically_linear_ordered_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_56508 (h0 h1 : multiset (add_comm_semigroup (mul_one_class enat))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_56509 (h0 : ring (mul_zero_class name)) : rank_condition (mul_zero_class name) := sorry --non-trivial
lemma new_lemma_56510 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @irreducible_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_56511 (h0 : topological_space (has_neg_part (has_add (add_comm_monoid environment.implicit_infer_kind)))) : preconnected_space (has_neg_part (has_add (add_comm_monoid environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_56512 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (filter.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (filter.{0} empty))  := sorry --non-trivial
lemma new_lemma_56513 (h0 : ring (add_semigroup (finset (finset (has_add Type))))) : is_domain (add_semigroup (finset (finset (has_add Type)))) := sorry --non-trivial
lemma new_lemma_56514 (h0 : random_gen string_imp -> random_gen string_imp -> Prop) : anti_symmetric h0 := sorry --non-trivial
lemma new_lemma_56515 (h0 : has_mem.mem (measurable_space empty) has_emptyc.emptyc) : @t0_space.{0} (measurable_space.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_56516 (h0 : semiring (has_bot (option (option (option (option (option empty))))))) : is_noetherian_ring (has_bot (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_56517 (h0 : functor.add_const (topological_space (mul_zero_class num)) (semiring num)) : @t1_space.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_56518 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_56519 (h0 : functor.add_const (group (has_neg unsigned)) environment.implicit_infer_kind) : @group.fg.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_56520 (h0 : ordered_add_comm_monoid (has_to_string (ring environment.implicit_infer_kind))) : archimedean (has_to_string (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_56521 (h0 : topological_space (has_div linarith.ineq)) (h1 : add_group (has_div linarith.ineq)) : topological_add_group (has_div linarith.ineq) := sorry --non-trivial
lemma new_lemma_56522 (h0 : has_neg linarith.comp_source) (h1 : measurable_space linarith.comp_source) : has_measurable_neg linarith.comp_source := sorry --non-trivial
lemma new_lemma_56523 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (finset.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_56524 (h0 : functor.add_const (complete_lattice (add_cancel_monoid pos)) pos) : @is_compactly_generated.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_56525 (h0 : topological_space (has_norm (has_top linarith.ineq))) : t0_space (has_norm (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_56526 (h0 : topological_space (canonically_ordered_comm_semiring ennreal)) : t1_space (canonically_ordered_comm_semiring ennreal) := sorry --non-trivial
lemma new_lemma_56527 (h0 : ring (div_inv_monoid (comm_ring fun_info))) : is_domain (div_inv_monoid (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_56528 (h0 : functor.add_const (uniform_space (simple_graph Type)) pos) : @complete_space.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (simple_graph.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_56529 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_56530 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_neg.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_56531 (h0 : ring (finset (has_add (has_to_string (has_add pos))))) : rank_condition (finset (has_add (has_to_string (has_add pos)))) := sorry --non-trivial
lemma new_lemma_56532 (h0 : has_mem.mem ring has_emptyc.emptyc) : @is_domain.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_56533 (h0 : list (comm_group (has_neg (has_add pos)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_56534 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_56535 (h0 : filter (add_cancel_monoid (add_comm_monoid unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_56536 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (group_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (group_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_56537 (h1 : not (topological_space (denumerable linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (denumerable.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_56538 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_56539 (h0 : semiring (ring ennreal)) : is_noetherian_ring (ring ennreal) := sorry --non-trivial
lemma new_lemma_56540 (h0 : semiring (add_cancel_monoid linarith.comp)) : is_noetherian_ring (add_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_56541 (h0 : filter (has_add (finset pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_56542 (h0 : not (ring (has_append (has_nnnorm (has_nnnorm linarith.ineq))) -> false)) : @strong_rank_condition.{0} (has_append.{0} (has_nnnorm.{0} (has_nnnorm.{0} linarith.ineq))) (@classical.by_contradiction'.{1} (ring.{0} (has_append.{0} (has_nnnorm.{0} (has_nnnorm.{0} linarith.ineq)))) h0)  := sorry --non-trivial
lemma new_lemma_56543 (h0 : functor.add_const (complete_lattice (right_cancel_semigroup Type)) Type) : @is_compactly_generated.{1} (right_cancel_semigroup.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (right_cancel_semigroup.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_56544 (h0 : complete_lattice (non_unital_non_assoc_semiring (mul_one_class char))) : is_compactly_generated (non_unital_non_assoc_semiring (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_56545 (h0 : group (comm_group (option (cancel_monoid pos)))) : group.fg (comm_group (option (cancel_monoid pos))) := sorry --non-trivial
lemma new_lemma_56546 (h0 : functor.add_const (semiring (add_cancel_monoid name)) pos) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (add_cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_56547 (h0 : ring (comm_monoid unsigned)) : is_domain (comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_56548 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_inter.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} empty))  := sorry --non-trivial
lemma new_lemma_56549 (h0 : ring (has_neg (normed_comm_ring Type))) : rank_condition (has_neg (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_56550 (h0 : functor.add_const (function.extfun Type ring) pos) : @rank_condition.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_56551 (h0 : functor.add_const (topological_space (semilattice_inf Type)) Type) : @loc_path_connected_space.{1} (semilattice_inf.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (semilattice_inf.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_56552 (h0 : functor.add_const (topological_space (has_nndist ennreal)) Type) : @preirreducible_space.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_56553 (h0 : finset (canonically_ordered_monoid (semiring empty))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_56554 (h0 : complete_lattice (add_comm_semigroup (mul_one_class (mul_one_class string.iterator_imp)))) : is_compactly_generated (add_comm_semigroup (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_56555 (h0 : topological_space (has_bot (has_neg pos))) : preirreducible_space (has_bot (has_neg pos)) := sorry --non-trivial
lemma new_lemma_56556 (h0 : fin has_zero.zero) : @t0_space.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_56557 (h0 : complete_lattice (has_inv (has_inv (has_inv fun_info)))) : is_atomistic (has_inv (has_inv (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_56558 (h0 : group (ordered_comm_ring (finset (finset (has_neg (finset Type)))))) : group.fg (ordered_comm_ring (finset (finset (has_neg (finset Type))))) := sorry --non-trivial
lemma new_lemma_56559 (h1 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h1 (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_56560 (h0 : add_group (has_union (semiring (semiring congr_arg_kind)))) : is_add_cyclic (has_union (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_56561 (h0 : group (with_one (semiring (semiring empty)))) : group.fg (with_one (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_56562 (h0 : not (filter (linear_ordered_semiring unsigned) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_56563 (h5 : ring (has_div enat)) : rank_condition (has_div enat) := sorry --non-trivial
lemma new_lemma_56564 (h0 : function.extfun Type (functor.add_const (functor.add_const (complete_lattice znum) empty))) : @is_compactly_generated.{0} znum (@functor.add_const.run.{0 0} (complete_lattice.{0} znum) empty (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (complete_lattice.{0} znum) empty) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (functor.add_const.{0 0} (complete_lattice.{0} znum) empty)) h0 empty)))  := sorry --non-trivial
lemma new_lemma_56565 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_56566 (h0 : functor.add_const (topological_space (left_cancel_monoid congr_arg_kind)) unsigned) : @totally_disconnected_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_56567 (h0 : function.extfun (Type 1) ring) : @is_principal_ideal_ring.{1} (cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_56568 (h0 : functor.add_const (fin has_zero.zero) linarith.comp) : @rank_condition.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (boolean_algebra.{1} Type)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_56569 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_56570 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_56571 (h0 : function.extfun (((Type -> Type) -> Type 1) -> Type 1) (function.extfun ((Type -> Type) -> Type 1))) : @is_compactly_generated.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (@function.extfun_app.{3 3} (((Type → Type) → Type 1) → Type 1) (function.extfun.{3 2} ((Type → Type) → Type 1)) h0 (function.extfun.{2 2} (Type → Type))) (function.extfun.{2 1} Type)) complete_lattice.{0}) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_56572 (h0 : not (topological_space (has_sub unsigned) -> false)) : @irreducible_space.{0} (has_sub.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_56573 (h0 : function.extfun nat fin) : @rank_condition.{0} (complete_distrib_lattice.{0} real) (@matrix.vec_empty.{0} (ring.{0} (complete_distrib_lattice.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_56574 (h0 : uniform_space (dlist linarith.comp_source)) : complete_space (dlist linarith.comp_source) := sorry --non-trivial
lemma new_lemma_56575 (h0 : topological_space (add_cancel_comm_monoid (comm_ring (comm_ring reducibility_hints)))) : totally_disconnected_space (add_cancel_comm_monoid (comm_ring (comm_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_56576 (h0 : topological_space (comm_ring (has_ssubset (comm_ring (random_gen string_imp))))) : totally_disconnected_space (comm_ring (has_ssubset (comm_ring (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_56577 (h0 : ring (has_Sup (semiring (semiring (semiring empty))))) : is_domain (has_Sup (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_56578 (h0 : functor.add_const (topological_space (ring pos)) name) : @t0_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_56579 (h0 : add_group (has_top (semiring congr_arg_kind))) : is_add_cyclic (has_top (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_56580 (h0 : functor.add_const (finset (semigroup Type)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_56581 (h3 : topological_space (linear_ordered_comm_ring linarith.ineq)) : t0_space (linear_ordered_comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_56582 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_ordered_add_monoid.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_ordered_add_monoid.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_56583 (h0 : functor.add_const (group (finset pos)) pos) : @is_simple_group.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_56584 (h0 : functor.add_const (topological_space (boolean_algebra.core ennreal)) Type) : @preconnected_space.{0} (boolean_algebra.core.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_56585 (h0 : functor.add_const (group (has_add linarith.comp)) name) : @is_simple_group.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_56586 (h0 : group (semiring linarith.comp_source)) : is_cyclic (semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_56587 (h0 : topological_space (add_semigroup empty)) : topological_space.separable_space (add_semigroup empty) := sorry --non-trivial
lemma new_lemma_56588 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_56589 (h0 : prod (has_bot empty) (has_bot empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_56590 (h0 : filter (has_zero pos)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_56591 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_56592 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_inter.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_inter.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_56593 (h0 : topological_space (add_cancel_monoid (has_add linarith.comp))) : regular_space (add_cancel_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_56594 (h1 : group (fintype linarith.ineq)) : group.fg (fintype linarith.ineq) := sorry --non-trivial
lemma new_lemma_56595 (h0 : topological_space (add_right_cancel_monoid (semiring congr_arg_kind))) : totally_disconnected_space (add_right_cancel_monoid (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_56596 (h0 : list (list Prop)) : list.tfae (list.head (id h0)) := sorry --non-trivial
lemma new_lemma_56597 (h0 : function.extfun (Type 1) topological_space) : @sequential_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_56598 (h0 : ring (non_assoc_semiring (semiring num))) : is_domain (non_assoc_semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_56599 (h0 : topological_space (comm_group (option (comm_group pos)))) : t0_space (comm_group (option (comm_group pos))) := sorry --non-trivial
lemma new_lemma_56600 (h0 : topological_space (finset (has_add Type))) : sequential_space (finset (has_add Type)) := sorry --non-trivial
lemma new_lemma_56601 (h0 : functor.add_const (list (normed_comm_ring unsigned)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_56602 (h0 : not (add_group (fintype string_imp) -> false)) : @is_add_cyclic.{0} (fintype.{0} string_imp) (@classical.by_contradiction'.{1} (add_group.{0} (fintype.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_56603 (h0 : group (has_zero (has_to_string name))) : is_simple_group (has_zero (has_to_string name)) := sorry --non-trivial
lemma new_lemma_56604 (h0 : not (finset Type -> false)) : finset.nonempty (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_56605 (h0 : topological_space (canonically_ordered_comm_semiring (has_to_string pos))) : loc_path_connected_space (canonically_ordered_comm_semiring (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_56606 (h0 : topological_space (random_gen char)) : t0_space (random_gen char) := sorry --non-trivial
lemma new_lemma_56607 (h0 : set (has_le linarith.comp_source)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_56608 (h0 : complete_lattice (has_one (semiring (semiring (has_top (semiring empty)))))) : is_atomistic (has_one (semiring (semiring (has_top (semiring empty))))) := sorry --non-trivial
lemma new_lemma_56609 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (linear_ordered_comm_ring.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (linear_ordered_comm_ring.{0} num))  := sorry --non-trivial
lemma new_lemma_56610 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_56611 (h0 : topological_space (has_compl string.iterator_imp)) : t0_space (has_compl string.iterator_imp) := sorry --non-trivial
lemma new_lemma_56612 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_disconnected_space.{0} fun_info (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) fun_info)  := sorry --non-trivial
lemma new_lemma_56613 (h0 : add_group (canonically_linear_ordered_monoid pos)) : is_add_cyclic (canonically_linear_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_56614 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_56615 (h0 : add_monoid (comm_group (has_nndist environment.implicit_infer_kind))) : add_monoid.fg (comm_group (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_56616 (h0 : monoid (with_one (random_gen (random_gen (random_gen linarith.ineq))))) : monoid.fg (with_one (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_56617 (h0 : functor.add_const (function.extfun Type ring) Type) : @is_domain.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_56618 (h0 : functor.add_const (function.extfun Type uniform_space) Type) : @complete_space.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) Type h0) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_56619 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @totally_separated_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_56620 (h0 : function.extfun (Type 1) topological_space) : @discrete_topology.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_56621 (h0 : functor.add_const (complete_lattice (comm_group pos)) Type) : @is_atomistic.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (comm_group.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_56622 (h0 : ring (ring empty)) : strong_rank_condition (ring empty) := sorry --non-trivial
lemma new_lemma_56623 (h0 : group (complete_semilattice_Sup (semiring (semiring (semiring unsigned))))) : normalizer_condition (complete_semilattice_Sup (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_56624 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) (boolean_algebra Type)) : @discrete_topology.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_56625 (h0 : function.extfun Type ring) : @rank_condition.{0} (mul_zero_class.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (mul_zero_class.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_56626 (h0 : functor.add_const (topological_space (has_to_string name)) environment.implicit_infer_kind) : @t0_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_56627 (h0 : function.extfun Type topological_space) : path_connected_space ennreal := sorry --non-trivial
lemma new_lemma_56628 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_bot.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_56629 (h0 : topological_space (semiring (has_top fun_info))) : totally_disconnected_space (semiring (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_56630 (h0 : topological_space (canonically_ordered_monoid (has_add linarith.comp))) : totally_disconnected_space (canonically_ordered_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_56631 (h0 : functor.add_const (topological_space (cancel_monoid name)) name) : @path_connected_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_56632 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_56633 (h0 : topological_space (semi_normed_comm_ring (has_nnnorm (random_gen linarith.comp_source)))) : totally_disconnected_space (semi_normed_comm_ring (has_nnnorm (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_56634 (h0 : ring (has_edist (option (option empty)))) : rank_condition (has_edist (option (option empty))) := sorry --non-trivial
lemma new_lemma_56635 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_56636 (h0 : ring (simple_graph (has_nnnorm char))) : rank_condition (simple_graph (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_56637 (h0 : topological_space (canonically_linear_ordered_monoid (has_add Type))) : preirreducible_space (canonically_linear_ordered_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_56638 (h0 : topological_space (with_bot (has_union (has_union (has_union (has_union unsigned)))))) : locally_compact_space (with_bot (has_union (has_union (has_union (has_union unsigned))))) := sorry --non-trivial
lemma new_lemma_56639 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (mul_zero_class.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (mul_zero_class.{0} empty))  := sorry --non-trivial
lemma new_lemma_56640 (h0 : topological_space (generalized_boolean_algebra (has_neg (has_neg (has_Inf (has_neg Type)))))) : irreducible_space (generalized_boolean_algebra (has_neg (has_neg (has_Inf (has_neg Type))))) := sorry --non-trivial
lemma new_lemma_56641 (h1 : not (uniform_space (normed_field linarith.comp_source) -> false)) : @complete_space.{0} (normed_field.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (uniform_space.{0} (normed_field.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_56642 (h0 : functor.add_const (topological_space (ring linarith.comp)) linarith.comp) : @totally_disconnected_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_56643 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_56644 (h0 : add_group (has_union empty)) : is_add_cyclic (has_union empty) := sorry --non-trivial
lemma new_lemma_56645 (h2 : semiring (mul_one_class fun_info)) (h3 : ideal (mul_one_class fun_info)) : ideal.is_prime h3 := sorry --non-trivial
lemma new_lemma_56646 (h0 : uniform_space (normed_lattice_add_comm_group name)) : separated_space (normed_lattice_add_comm_group name) := sorry --non-trivial
lemma new_lemma_56647 (h0 : add_group (normed_comm_ring (has_add Type))) : is_add_cyclic (normed_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_56648 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_56649 (h0 : function.extfun Type (functor.add_const (ordered_add_comm_monoid nnreal))) : archimedean nnreal := sorry --non-trivial
lemma new_lemma_56650 (h0 : functor.add_const Prop (has_zero num)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_56651 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_56652 (h0 : set (std_gen -> string.iterator_imp)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_56653 (h0 : uniform_space (canonically_linear_ordered_monoid num)) : separated_space (canonically_linear_ordered_monoid num) := sorry --non-trivial
lemma new_lemma_56654 (h0 : not (uniform_space num -> false)) : @separated_space.{0} num (@classical.by_contradiction'.{1} (uniform_space.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_56655 (h0 : topological_space (ordered_comm_monoid (has_Inf (has_Inf (has_add name))))) : preirreducible_space (ordered_comm_monoid (has_Inf (has_Inf (has_add name)))) := sorry --non-trivial
lemma new_lemma_56656 (h0 : functor.add_const (function.extfun (Type 1) filter) Type) : countable_Inter_filter (function.extfun_app (functor.add_const.run h0) (ordered_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_56657 (h0 : functor.comp topological_space complete_distrib_lattice name) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} name h0)  := sorry --non-trivial
lemma new_lemma_56658 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) name) : @t0_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_56659 (h0 : ring (add_group (has_norm num))) : is_domain (add_group (has_norm num)) := sorry --non-trivial
lemma new_lemma_56660 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_56661 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_56662 (h0 : add_group (has_star num)) : is_add_cyclic (has_star num) := sorry --non-trivial
lemma new_lemma_56663 (h0 : topological_space (ordered_comm_monoid linarith.comp)) : locally_compact_space (ordered_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_56664 (h0 : measurable_space (add_comm_semigroup std_gen)) (h1 : filter (add_comm_semigroup std_gen)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_56665 (h0 : add_group (comm_group (add_comm_monoid (normed_comm_ring Type)))) : is_add_cyclic (comm_group (add_comm_monoid (normed_comm_ring Type))) := sorry --non-trivial
lemma new_lemma_56666 (h0 : functor.add_const (add_group (semigroup linarith.comp)) name) : @is_add_cyclic.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_56667 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_56668 (h0 : has_neg (add_comm_semigroup linarith.ineq)) (h1 : measurable_space (add_comm_semigroup linarith.ineq)) : has_measurable_neg (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_56669 (h0 : ring (with_bot (comm_ring (random_gen (random_gen (random_gen to_additive.value_type)))))) : is_domain (with_bot (comm_ring (random_gen (random_gen (random_gen to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_56670 (h1 : topological_space (has_append reducibility_hints)) : t0_space (has_append reducibility_hints) := sorry --non-trivial
lemma new_lemma_56671 (h0 : topological_space (generalized_boolean_algebra (ring (linear_ordered_add_comm_group_with_top Type)))) : normal_space (generalized_boolean_algebra (ring (linear_ordered_add_comm_group_with_top Type))) := sorry --non-trivial
lemma new_lemma_56672 (h0 : ordered_comm_monoid (cancel_monoid (ring pos))) : has_exists_mul_of_le (cancel_monoid (ring pos)) := sorry --non-trivial
lemma new_lemma_56673 (h0 : set (has_nnnorm (mul_one_class linarith.comp_source))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_56674 (h0 : topological_space (as_linear_order (option (option (comm_monoid (option num)))))) : totally_disconnected_space (as_linear_order (option (option (comm_monoid (option num))))) := sorry --non-trivial
lemma new_lemma_56675 (h0 : functor.add_const (topological_space (boolean_algebra name)) name) : @totally_disconnected_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_56676 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_56677 (h0 : ring (non_unital_non_assoc_semiring (has_ssubset (has_ssubset linarith.ineq)))) : is_domain (non_unital_non_assoc_semiring (has_ssubset (has_ssubset linarith.ineq))) := sorry --non-trivial
lemma new_lemma_56678 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @topological_space.separable_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero))) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_56679 (h0 : uniform_space (complete_semilattice_Sup (has_top unsigned))) : separated_space (complete_semilattice_Sup (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_56680 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_56681 (h0 : monoid (add_right_cancel_monoid (semiring (has_top unsigned)))) : monoid.fg (add_right_cancel_monoid (semiring (has_top unsigned))) := sorry --non-trivial
lemma new_lemma_56682 (h0 : functor.add_const (topological_space (has_to_string name)) name) : @t0_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_56683 (h0 : ring (fintype znum)) : is_domain (fintype znum) := sorry --non-trivial
lemma new_lemma_56684 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_emptyc linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_56685 (h0 : functor.add_const (group (add_semigroup unsigned)) num) : @group.fg.{0} (add_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (add_semigroup.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_56686 (h0 : monoid (has_inter (option (option (option (option (option empty))))))) : monoid.fg (has_inter (option (option (option (option (option empty)))))) := sorry --non-trivial
lemma new_lemma_56687 (h0 : group (encodable (comm_ring linarith.ineq))) : group.fg (encodable (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_56688 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (linear_ordered_comm_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} num))  := sorry --non-trivial
lemma new_lemma_56689 (h0 : group (has_star (semiring congr_arg_kind))) : is_cyclic (has_star (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_56690 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_56691 (h1 : filter (dlist (random_gen (has_nnnorm (has_nnnorm char))))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_56692 (h0 : list (canonically_ordered_add_monoid unsigned)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_56693 (h0 : topological_space (with_one (has_norm (semiring linarith.comp)))) : irreducible_space (with_one (has_norm (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_56694 (h0 : functor.add_const (complete_lattice (finset environment.implicit_infer_kind)) pos) : @is_compactly_generated.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_56695 (h0 : topological_space (normed_group (has_top to_additive.value_type))) : discrete_topology (normed_group (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_56696 (h0 : ring (normed_field enat)) : strong_rank_condition (normed_field enat) := sorry --non-trivial
lemma new_lemma_56697 (h0 : functor.add_const (ring (generalized_boolean_algebra linarith.comp)) name) : @rank_condition.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (generalized_boolean_algebra.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_56698 (h0 : group (has_bot pos)) : is_simple_group (has_bot pos) := sorry --non-trivial
lemma new_lemma_56699 (h0 : semiring string.iterator) (h1 : ideal string.iterator) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_56700 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_to_string.{0} (has_to_string.{0} pos)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_to_string.{0} (has_to_string.{0} pos)))  := sorry --non-trivial
lemma new_lemma_56701 (h0 : topological_space (has_edist congr_arg_kind)) : t0_space (has_edist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_56702 (h0 : functor.add_const (topological_space (left_cancel_monoid num)) empty) : @loc_path_connected_space.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_56703 (h0 : function.extfun Type ring) : @is_domain.{0} (measurable_space.dynkin_system.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (measurable_space.dynkin_system.{0} empty))  := sorry --non-trivial
lemma new_lemma_56704 (h0 : topological_space (semi_normed_comm_ring (mul_one_class string.iterator_imp))) : totally_disconnected_space (semi_normed_comm_ring (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_56705 (h0 : topological_space (pseudo_metric_space (has_nndist ennreal))) : t0_space (pseudo_metric_space (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_56706 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_56707 (h0 : uniform_space (metric_space empty)) : separated_space (metric_space empty) := sorry --non-trivial
lemma new_lemma_56708 (h0 : group (generalized_boolean_algebra linarith.comp)) : is_simple_group (generalized_boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_56709 (h0 : filter (normed_group (comm_ring (comm_ring (comm_ring fun_info))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_56710 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_56711 (h0 : functor.add_const (topological_space (preorder empty)) (semiring empty)) : @t1_space.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_56712 (h0 : ring (has_ssubset (mul_one_class ereal))) : is_domain (has_ssubset (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_56713 (h0 : add_monoid (has_sub linarith.comp)) : add_monoid.fg (has_sub linarith.comp) := sorry --non-trivial
lemma new_lemma_56714 (h0 : functor.add_const (group (boolean_algebra Type)) (finset linarith.comp)) : @is_cyclic.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (boolean_algebra.{1} Type)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_56715 (h0 : topological_space (denumerable linarith.ineq)) : totally_disconnected_space (denumerable linarith.ineq) := sorry --non-trivial
lemma new_lemma_56716 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_56717 (h0 : topological_space (filter congr_arg_kind)) : t1_space (filter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_56718 (h3 : topological_space ereal) : totally_disconnected_space ereal := sorry --non-trivial
lemma new_lemma_56719 (h0 : topological_space (add_comm_monoid (finset (finset (has_to_string name))))) : t0_space (add_comm_monoid (finset (finset (has_to_string name)))) := sorry --non-trivial
lemma new_lemma_56720 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_56721 (h0 : functor.add_const (list (semigroup unsigned)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_56722 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (linear_ordered_comm_monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_56723 (h1 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_56724 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (partial_order.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (partial_order.{0} num))  := sorry --non-trivial
lemma new_lemma_56725 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group unsigned))) : @add_monoid.fg.{0} (normed_group.{0} unsigned) (@finset.pi.empty.{1 0} Type add_monoid.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} unsigned)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_56726 (h0 : list (simple_graph pos)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_56727 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_56728 (h0 : functor.comp topological_space has_nndist unsigned) : @totally_separated_space.{0} (has_nndist.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} has_nndist.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_56729 (h0 : not (group (with_zero linarith.ineq) -> false)) : @group.fg.{0} (with_zero.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (with_zero.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_56730 (h1 : function.extfun Type add_group) : @is_add_cyclic.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} h1 (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_56731 (h0 : has_mem.mem (linear_ordered_semiring fun_info) has_emptyc.emptyc) : @monoid.fg.{0} (linear_ordered_semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type monoid.{0} (linear_ordered_semiring.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_56732 (h0 : ring (has_top (has_norm (has_norm empty)))) : is_domain (has_top (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_56733 (h0 : topological_space (canonically_ordered_comm_semiring (has_add (has_add name)))) : preirreducible_space (canonically_ordered_comm_semiring (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_56734 (h0 : functor.add_const (topological_space (comm_group ennreal)) name) : @discrete_topology.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_56735 (h3 : set (char -> fun_info)) : set.separates_points h3 := sorry --non-trivial
lemma new_lemma_56736 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_56737 (h0 : topological_space (has_neg congr_arg_kind)) : totally_separated_space (has_neg congr_arg_kind) := sorry --non-trivial
lemma new_lemma_56738 (h0 : ring (boolean_algebra (has_Inf (has_Inf Type)))) : strong_rank_condition (boolean_algebra (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_56739 (h0 : topological_space (cancel_monoid ennreal)) (h1 : set (cancel_monoid ennreal)) : is_seq_compact h1 := sorry --non-trivial
lemma new_lemma_56740 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_inv.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_inv.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_56741 (h0 : uniform_space (random_gen linarith.comp_source)) : complete_space (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_56742 (h1 : complete_lattice (id (random_gen linarith.ineq))) : complete_lattice.is_Sup_finite_compact (id (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_56743 (h0 : function.extfun Type (functor.add_const (topological_space znum))) : @topological_space.separable_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} znum)) h0 num))  := sorry --non-trivial
lemma new_lemma_56744 (h0 : functor.add_const (group (add_comm_monoid congr_arg_kind)) num) : @is_cyclic.{0} (add_comm_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_56745 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 add_group.{0}) (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_56746 (h0 : group (has_inv (has_inv to_additive.value_type))) : is_cyclic (has_inv (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_56747 (h0 : functor.add_const (add_group (boolean_algebra environment.implicit_infer_kind)) (has_add name)) : @is_add_cyclic.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_group.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_56748 (h0 : semiring (id (semiring (semiring empty)))) : is_noetherian_ring (id (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_56749 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_union.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_56750 (h0 : functor.add_const (monoid (boolean_algebra.core name)) (has_add (boolean_algebra.core pos))) : @monoid.fg.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (boolean_algebra.core.{0} name)) (has_add.{0} (boolean_algebra.core.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_56751 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_cyclic.{0} (canonically_linear_ordered_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (canonically_linear_ordered_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_56752 (h0 : functor.add_const (topological_space (omega_complete_partial_order empty)) congr_arg_kind) : @irreducible_space.{0} (omega_complete_partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (omega_complete_partial_order.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_56753 (h0 : topological_space (complete_distrib_lattice Type)) : totally_disconnected_space (complete_distrib_lattice Type) := sorry --non-trivial
lemma new_lemma_56754 (h0 : topological_space (has_lt linarith.ineq)) (h1 : preorder (has_lt linarith.ineq)) : order_closed_topology (has_lt linarith.ineq) := sorry --non-trivial
lemma new_lemma_56755 (h0 : topological_space (option (semiring (semiring congr_arg_kind)))) : normal_space (option (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_56756 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_neg pos)) : @sequential_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_neg.{0} pos) h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_56757 (h0 : functor.add_const (add_group (boolean_algebra pos)) (boolean_algebra.core (has_add name))) : @is_add_cyclic.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (boolean_algebra.{0} pos)) (boolean_algebra.core.{0} (has_add.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_56758 (h0 : topological_space (has_union (has_top num))) : normal_space (has_union (has_top num)) := sorry --non-trivial
lemma new_lemma_56759 (h0 : complete_lattice (has_nndist (option pos))) : is_compactly_generated (has_nndist (option pos)) := sorry --non-trivial
lemma new_lemma_56760 (h0 : topological_space (dlist (random_gen to_additive.value_type))) : locally_compact_space (dlist (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_56761 (h0 : topological_space (comm_group (has_zero unsigned))) : regular_space (comm_group (has_zero unsigned)) := sorry --non-trivial
lemma new_lemma_56762 (h0 : complete_lattice (has_zero (finset (has_neg (finset linarith.comp))))) : is_compactly_generated (has_zero (finset (has_neg (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_56763 (h1 : ring (random_gen (linear_ordered_add_comm_group linarith.comp_source))) : strong_rank_condition (random_gen (linear_ordered_add_comm_group linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_56764 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type add_group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type add_group.{0}) h0) (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_56765 (h0 : complete_lattice (has_union (semiring congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (has_union (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_56766 (h0 : monoid (comm_group (has_neg (has_neg (has_neg (has_neg (has_neg (has_neg linarith.comp)))))))) : monoid.fg (comm_group (has_neg (has_neg (has_neg (has_neg (has_neg (has_neg linarith.comp))))))) := sorry --non-trivial
lemma new_lemma_56767 (h0 : uniform_space (has_nnnorm string.iterator_imp)) : complete_space (has_nnnorm string.iterator_imp) := sorry --non-trivial
lemma new_lemma_56768 (h0 : functor.comp complete_lattice cancel_monoid Type) : @is_compactly_generated.{1} (cancel_monoid.{1} Type) (@functor.comp.run.{1 1 1} complete_lattice.{1} cancel_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_56769 (h0 : filter (plift (semiring (semiring empty)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_56770 (h0 : topological_space (semigroup (cancel_monoid (has_add pos)))) : t0_space (semigroup (cancel_monoid (has_add pos))) := sorry --non-trivial
lemma new_lemma_56771 (h0 : filter (with_one unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_56772 (h0 : functor.add_const (function.extfun Type topological_space) name) : @topological_space.separable_space.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_56773 (h0 : functor.add_const (semiring (left_cancel_monoid num)) empty) : @is_noetherian_ring.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (semiring.{0} (left_cancel_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_56774 (h0 : add_group (uniform_space (mul_one_class (mul_one_class linarith.ineq)))) : is_add_cyclic (uniform_space (mul_one_class (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_56775 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (option.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (option.{0} num))  := sorry --non-trivial
lemma new_lemma_56776 (h0 : filter (has_to_string (has_add name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_56777 (h0 : functor.add_const (ordered_add_comm_monoid (cancel_monoid Type)) pos) : @archimedean.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_56778 (h0 : uniform_space (comm_group (comm_group name))) : complete_space (comm_group (comm_group name)) := sorry --non-trivial
lemma new_lemma_56779 (h0 : functor.add_const (uniform_space (ordered_comm_ring Type)) linarith.comp) : @separated_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (ordered_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_56780 (h0 : monoid (add_cancel_monoid (finset (has_pos_part (finset pos))))) : monoid.fg (add_cancel_monoid (finset (has_pos_part (finset pos)))) := sorry --non-trivial
lemma new_lemma_56781 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (finset.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (finset.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_56782 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) Type) : @preirreducible_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_56783 (h0 : group (has_nnnorm fun_info)) : group.fg (has_nnnorm fun_info) := sorry --non-trivial
lemma new_lemma_56784 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_56785 (h0 : group (has_add (has_add name))) : is_cyclic (has_add (has_add name)) := sorry --non-trivial
lemma new_lemma_56786 (h0 : topological_space (measurable_space (has_inv linarith.ineq))) : totally_separated_space (measurable_space (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_56787 (h0 : ring (distrib (random_gen (random_gen string_imp)))) : strong_rank_condition (distrib (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_56788 (h0 : ring (mv_power_series empty empty)) : rank_condition (mv_power_series empty empty) := sorry --non-trivial
lemma new_lemma_56789 (h0 : topological_space (complete_distrib_lattice ennreal)) : totally_disconnected_space (complete_distrib_lattice ennreal) := sorry --non-trivial
lemma new_lemma_56790 (h0 : ring (measurable_space (has_norm num))) : rank_condition (measurable_space (has_norm num)) := sorry --non-trivial
lemma new_lemma_56791 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @t0_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_56792 (h0 : semiring (linear_ordered_comm_group ennreal)) : is_noetherian_ring (linear_ordered_comm_group ennreal) := sorry --non-trivial
lemma new_lemma_56793 (h0 : functor.add_const (topological_space (has_zero name)) name) : @locally_compact_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_56794 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (ring (ring pos))) : @normal_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (ring.{0} (ring.{0} pos)) h0) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_56795 (h0 : functor.add_const (add_group (has_nndist name)) pos) : @is_add_cyclic.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (has_nndist.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_56796 (h0 : has_mem.mem (with_one (random_gen (semiring num))) has_emptyc.emptyc) : @is_compactly_generated.{0} (with_one.{0} (random_gen.{0} (semiring.{0} num))) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_one.{0} (random_gen.{0} (semiring.{0} num))) h0)  := sorry --non-trivial
lemma new_lemma_56797 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (measurable_space congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_56798 (h0 : topological_space (has_to_string name)) : regular_space (has_to_string name) := sorry --non-trivial
lemma new_lemma_56799 (h0 : topological_space (boolean_algebra (has_Inf (has_Inf (has_Inf linarith.comp))))) : normal_space (boolean_algebra (has_Inf (has_Inf (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_56800 (h0 : group (comm_semigroup (has_Inf (has_Inf real)))) : group.fg (comm_semigroup (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_56801 (h0 : functor.comp topological_space boolean_algebra name) : @path_connected_space.{0} (boolean_algebra.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.{0} name h0)  := sorry --non-trivial
lemma new_lemma_56802 (h0 : semiring enat) (h2 : enat) : even h2 := sorry --non-trivial
lemma new_lemma_56803 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (complete_distrib_lattice.{0} (option.{0} (option.{0} (option.{0} empty)))) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_distrib_lattice.{0} (option.{0} (option.{0} (option.{0} empty)))))  := sorry --non-trivial
lemma new_lemma_56804 (h0 : ring (monoid pos)) : rank_condition (monoid pos) := sorry --non-trivial
lemma new_lemma_56805 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (add_left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_56806 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_56807 (h0 : function.extfun Type group) : @is_cyclic.{0} (comm_semigroup.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (comm_semigroup.{0} real))  := sorry --non-trivial
lemma new_lemma_56808 (h0 : topological_space (has_neg (boolean_algebra linarith.comp))) : irreducible_space (has_neg (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_56809 (h0 : ring (canonically_ordered_add_monoid unsigned)) : rank_condition (canonically_ordered_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_56810 (h0 : functor.add_const (topological_space (left_cancel_monoid empty)) unsigned) : @totally_disconnected_space.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_56811 (h0 : topological_space (partial_order unsigned)) : path_connected_space (partial_order unsigned) := sorry --non-trivial
lemma new_lemma_56812 (h0 : group (add_monoid char)) : is_cyclic (add_monoid char) := sorry --non-trivial
lemma new_lemma_56813 (h0 : add_comm_semigroup fun_info -> add_comm_semigroup fun_info -> add_comm_semigroup fun_info) (h2 : add_comm_semigroup fun_info) : right_identity h0 h2 := sorry --non-trivial
lemma new_lemma_56814 (h0 : cancel_comm_monoid_with_zero (has_nndist (finset (finset (finset pos))))) : unique_factorization_monoid (has_nndist (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_56815 (h0 : option pos -> option pos -> Prop) : is_symm (option pos) h0 := sorry --non-trivial
lemma new_lemma_56816 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_56817 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) pos) : @t1_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_56818 (h1 : uniform_space (random_gen (has_ssubset fun_info))) : complete_space (random_gen (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_56819 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_56820 (h0 : topological_space (has_to_string (option (cancel_monoid pos)))) : t0_space (has_to_string (option (cancel_monoid pos))) := sorry --non-trivial
lemma new_lemma_56821 (h1 : topological_space (has_ssubset fun_info)) : path_connected_space (has_ssubset fun_info) := sorry --non-trivial
lemma new_lemma_56822 (h0 : topological_space (has_Inf (has_neg pos))) : t1_space (has_Inf (has_neg pos)) := sorry --non-trivial
lemma new_lemma_56823 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_56824 (h0 : has_mem.mem fin has_emptyc.emptyc) : matrix.vec_empty (function.extfun_app (finset.pi.empty (function.extfun nat) fin h0) has_zero.zero) := sorry --non-trivial
lemma new_lemma_56825 (h0 : topological_space (has_nnnorm (has_ssubset to_additive.value_type))) : locally_compact_space (has_nnnorm (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_56826 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (as_linear_order.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (as_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_56827 (h0 : semiring (with_bot (with_bot empty))) : is_noetherian_ring (with_bot (with_bot empty)) := sorry --non-trivial
lemma new_lemma_56828 (h0 : functor.add_const (fin has_zero.zero) Type) : @add_monoid.fg.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (add_monoid.{1} (canonically_linear_ordered_monoid.{1} Type)) (@functor.add_const.run.{0 1} (fin (@has_zero.zero.{0} nat nat.has_zero)) Type h0))  := sorry --non-trivial
lemma new_lemma_56829 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @irreducible_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_56830 (h0 : ring (metric_space reducibility_hints)) : rank_condition (metric_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_56831 (h0 : ordered_add_comm_monoid (has_neg (finset pos))) : archimedean (has_neg (finset pos)) := sorry --non-trivial
lemma new_lemma_56832 (h0 : cancel_comm_monoid_with_zero (has_add (has_nndist (has_Inf linarith.comp)))) : unique_factorization_monoid (has_add (has_nndist (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_56833 (h1 : complete_lattice (distrib string_imp)) : is_compactly_generated (distrib string_imp) := sorry --non-trivial
lemma new_lemma_56834 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (has_sub.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_sub.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_56835 (h0 : list (dlist (random_gen (random_gen (has_nnnorm string_imp))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_56836 (h0 : topological_space (boolean_algebra pos)) : totally_separated_space (boolean_algebra pos) := sorry --non-trivial
lemma new_lemma_56837 (h0 : function.extfun nat fin) : @sequential_space.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_linear_ordered_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_56838 (h0 : functor.add_const (function.extfun Type ring) Type) : @rank_condition.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_56839 (h0 : ring (add_cancel_monoid (option (option ennreal)))) : rank_condition (add_cancel_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_56840 (h0 : topological_space (comm_group (finset (finset environment.implicit_infer_kind)))) : t1_space (comm_group (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_56841 (h0 : semiring (has_to_string name)) : is_noetherian_ring (has_to_string name) := sorry --non-trivial
lemma new_lemma_56842 (h0 : set (set (has_top linarith.ineq))) : is_countably_spanning h0 := sorry --non-trivial
lemma new_lemma_56843 (h0 : not (topological_space (has_star num) -> false)) : @t0_space.{0} (has_star.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_star.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_56844 (h0 : ring (has_add (has_ssubset linarith.comp_source))) : rank_condition (has_add (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_56845 (h0 : complete_lattice (has_star (semiring (semiring (semiring congr_arg_kind))))) : is_compactly_generated (has_star (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_56846 (h0 : functor.add_const (topological_space (ordered_comm_monoid pos)) Type) : @locally_compact_space.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_56847 (h0 : group (normed_linear_ordered_group (semiring empty))) : group.fg (normed_linear_ordered_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_56848 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @totally_disconnected_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_56849 (h0 : uniform_space (has_le char)) : complete_space (has_le char) := sorry --non-trivial
lemma new_lemma_56850 (h0 : functor.add_const (semiring (left_cancel_monoid unsigned)) num) : @is_noetherian_ring.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (left_cancel_monoid.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_56851 (h0 : ring (ordered_comm_monoid (has_add (has_add (has_add (has_add linarith.comp)))))) : rank_condition (ordered_comm_monoid (has_add (has_add (has_add (has_add linarith.comp))))) := sorry --non-trivial
lemma new_lemma_56852 (h0 : topological_space (boolean_algebra (has_neg pos))) : t0_space (boolean_algebra (has_neg pos)) := sorry --non-trivial
lemma new_lemma_56853 (h0 : group (has_top (with_bot (has_norm empty)))) : is_cyclic (has_top (with_bot (has_norm empty))) := sorry --non-trivial
lemma new_lemma_56854 (h0 : not (topological_space (normed_group fun_info) -> false)) : @discrete_topology.{0} (normed_group.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_56855 (h0 : topological_space (finset pos)) : totally_disconnected_space (finset pos) := sorry --non-trivial
lemma new_lemma_56856 (h0 : function.extfun (Type 1) ring) : @strong_rank_condition.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_56857 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (comm_group name)) := sorry --non-trivial
lemma new_lemma_56858 (h0 : not (group (non_assoc_semiring congr_arg_kind) -> false)) : @is_cyclic.{0} (non_assoc_semiring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (non_assoc_semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_56859 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_56860 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_group.{0} h0 (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_56861 (h0 : nat) (h1 : fin h0) (h2 : fin has_zero.zero) : fin.lt h1 (matrix.vec_empty h2) := sorry --non-trivial
lemma new_lemma_56862 (h0 : add_group (has_pos_part (sub_neg_monoid Type))) : is_add_cyclic (has_pos_part (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_56863 (h0 : ring (encodable char)) : is_domain (encodable char) := sorry --non-trivial
lemma new_lemma_56864 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_bot.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_56865 (h0 : ring (uniform_space (semi_normed_ring linarith.comp_source))) : rank_condition (uniform_space (semi_normed_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_56866 (h0 : functor.add_const (complete_lattice (normed_linear_ordered_group num)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (normed_linear_ordered_group.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_linear_ordered_group.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_56867 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) (ring linarith.comp)) : @totally_disconnected_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_56868 (h1 : complete_lattice (has_lt linarith.comp_source)) : is_compactly_generated (has_lt linarith.comp_source) := sorry --non-trivial
lemma new_lemma_56869 (h0 : fin has_zero.zero) : @irreducible_space.{0} (has_pos_part.{0} (has_add.{0} linarith.comp)) (@matrix.vec_empty.{0} (topological_space.{0} (has_pos_part.{0} (has_add.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_56870 (h0 : uniform_space (comm_group (has_neg (has_neg (add_cancel_monoid name))))) : complete_space (comm_group (has_neg (has_neg (add_cancel_monoid name)))) := sorry --non-trivial
lemma new_lemma_56871 (h0 : functor.add_const (uniform_space (finset pos)) linarith.comp) : @complete_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (finset.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_56872 (h0 : functor.add_const (ring (ring linarith.comp)) name) : @is_domain.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_56873 (h0 : functor.add_const (group (boolean_algebra.core name)) name) : @group.fg.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.core.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_56874 (h1 : topological_space (random_gen string_imp)) : t0_space (random_gen string_imp) := sorry --non-trivial
lemma new_lemma_56875 (h0 : topological_space (normed_linear_ordered_group char)) : totally_disconnected_space (normed_linear_ordered_group char) := sorry --non-trivial
lemma new_lemma_56876 (h0 : monoid (normed_comm_ring (has_add (finset environment.implicit_infer_kind)))) : monoid.fg (normed_comm_ring (has_add (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_56877 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @complete_space.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (has_bot.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_56878 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_56879 (h0 : functor.add_const (topological_space (ring unsigned)) pos) : @t0_space.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_56880 (h3 : complete_lattice reducibility_hints) : complete_lattice.is_Sup_finite_compact reducibility_hints := sorry --non-trivial
lemma new_lemma_56881 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_56882 (h0 : add_monoid (finset pos)) : add_monoid.fg (finset pos) := sorry --non-trivial
lemma new_lemma_56883 (h0 : monoid (has_to_string (has_add (semigroup (has_add Type))))) : monoid.fg (has_to_string (has_add (semigroup (has_add Type)))) := sorry --non-trivial
lemma new_lemma_56884 (h0 : unsigned -> nat) (h1 : functor.add_const nat unsigned) (h2 : topological_space (derive_fintype.finset_above unsigned h0 (functor.add_const.run h1))) : t0_space (derive_fintype.finset_above unsigned h0 (functor.add_const.run h1)) := sorry --non-trivial
lemma new_lemma_56885 (h0 : functor.add_const (ring (ordered_comm_ring pos)) pos) : @is_principal_ideal_ring.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_56886 (h0 : topological_space (has_div linarith.comp_source)) : t0_space (has_div linarith.comp_source) := sorry --non-trivial
lemma new_lemma_56887 (h0 : ring (normed_comm_ring (has_add (finset linarith.comp)))) : is_principal_ideal_ring (normed_comm_ring (has_add (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_56888 (h1 : topological_space (semi_normed_comm_ring (random_gen (add_left_cancel_monoid (random_gen string_imp))))) : t0_space (semi_normed_comm_ring (random_gen (add_left_cancel_monoid (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_56889 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_56890 (h0 : set (has_compl (mul_one_class (mul_one_class enat)))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_56891 (h0 : topological_space (ordered_comm_ring (has_add pos))) : totally_separated_space (ordered_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_56892 (h0 : topological_space (group_with_zero num)) : path_connected_space (group_with_zero num) := sorry --non-trivial
lemma new_lemma_56893 (h0 : filter (semigroup unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_56894 (h0 : ring (add_right_cancel_monoid (semiring (semiring num)))) : is_domain (add_right_cancel_monoid (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_56895 (h0 : functor.add_const (topological_space (simple_graph pos)) name) : @loc_path_connected_space.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_56896 (h1 : ring (distrib std_gen)) : rank_condition (distrib std_gen) := sorry --non-trivial
lemma new_lemma_56897 (h0 : has_mem.mem group has_emptyc.emptyc) : @is_cyclic.{0} (has_inter.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (has_inter.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_56898 (h0 : function.extfun Type group) : @normalizer_condition.{0} string_imp (@function.extfun_app.{2 1} Type group.{0} h0 string_imp)  := sorry --non-trivial
lemma new_lemma_56899 (h0 : filter (has_neg_part (has_add pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_56900 (h0 : topological_space (has_nndist (has_neg_part pos))) : preirreducible_space (has_nndist (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_56901 (h0 : topological_space (normed_comm_ring (has_add environment.implicit_infer_kind))) : totally_disconnected_space (normed_comm_ring (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_56902 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @t0_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) Type)  := sorry --non-trivial
lemma new_lemma_56903 (h0 : topological_space (group_with_zero unsigned)) : totally_disconnected_space (group_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_56904 (h0 : function.extfun Type (functor.comp semiring mul_zero_class)) : @is_noetherian_ring.{0} (mul_zero_class.{0} name) (@functor.comp.run.{0 0 0} semiring.{0} mul_zero_class.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} semiring.{0} mul_zero_class.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_56905 (h1 : add_group (has_emptyc linarith.comp)) : is_add_cyclic (has_emptyc linarith.comp) := sorry --non-trivial
lemma new_lemma_56906 (h0 : functor.add_const (monoid (has_to_string Type)) (ring pos)) : @monoid.fg.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (has_to_string.{1} Type)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_56907 (h0 : not (topological_space (mul_zero_class unsigned) -> false)) : @topological_space.separable_space.{0} (mul_zero_class.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (mul_zero_class.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_56908 (h2 : topological_space (has_emptyc (random_gen (random_gen (random_gen string_imp))))) : path_connected_space (has_emptyc (random_gen (random_gen (random_gen string_imp)))) := sorry --non-trivial
lemma new_lemma_56909 (h0 : functor.add_const (topological_space (ring name)) (has_nndist name)) : @irreducible_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) (has_nndist.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_56910 (h1 : ring (topological_space (has_nnnorm (has_nnnorm linarith.comp_source)))) : is_domain (topological_space (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_56911 (h0 : functor.add_const (semiring (has_pos_part linarith.comp)) (has_Inf (has_Inf (finset (finset Type))))) : @is_noetherian_ring.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 1} (semiring.{0} (has_pos_part.{0} linarith.comp)) (has_Inf.{1} (has_Inf.{1} (finset.{1} (finset.{1} Type)))) h0)  := sorry --non-trivial
lemma new_lemma_56912 (h0 : function.extfun Type (functor.comp ring cancel_monoid)) : @rank_condition.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} ring.{0} cancel_monoid.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} cancel_monoid.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_56913 (h0 : filter (add_cancel_monoid unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_56914 (h0 : functor.add_const (add_group (has_nndist pos)) (has_add (has_pos_part linarith.comp))) : @is_add_cyclic.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (has_nndist.{0} pos)) (has_add.{0} (has_pos_part.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_56915 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_56916 (h1 : topological_space (is_R_or_C string.iterator_imp)) : t0_space (is_R_or_C string.iterator_imp) := sorry --non-trivial
lemma new_lemma_56917 (h0 : ring (random_gen (random_gen (conditionally_complete_lattice char)))) : rank_condition (random_gen (random_gen (conditionally_complete_lattice char))) := sorry --non-trivial
lemma new_lemma_56918 (h0 : complete_lattice (with_one (comm_ring to_additive.value_type))) : is_compactly_generated (with_one (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_56919 (h0 : group (has_bot (has_neg Type))) : normalizer_condition (has_bot (has_neg Type)) := sorry --non-trivial
lemma new_lemma_56920 (h0 : add_group (cancel_monoid (ring (boolean_algebra name)))) : is_add_cyclic (cancel_monoid (ring (boolean_algebra name))) := sorry --non-trivial
lemma new_lemma_56921 (h0 : topological_space (semigroup (has_add pos))) : t0_space (semigroup (has_add pos)) := sorry --non-trivial
lemma new_lemma_56922 (h0 : group (has_neg_part (option unsigned))) : is_cyclic (has_neg_part (option unsigned)) := sorry --non-trivial
lemma new_lemma_56923 (h0 : has_mem.mem (normed_group fun_info) has_emptyc.emptyc) : @locally_compact_space.{0} (normed_group.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_56924 (h0 : functor.add_const (group (has_zero name)) linarith.comp) : @group.fg.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_56925 (h0 : functor.add_const (topological_space (canonically_ordered_add_monoid empty)) (option empty)) : @locally_compact_space.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_add_monoid.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_56926 (h0 : with_bot (topological_space (has_add (has_to_string (has_to_string pos))))) (h1 : function.extfun (eq h0 has_bot.bot) (fun (x : eq h0 has_bot.bot), false)) : @totally_disconnected_space.{0} (has_add.{0} (has_to_string.{0} (has_to_string.{0} pos))) (@with_bot.unbot.{0} (topological_space.{0} (has_add.{0} (has_to_string.{0} (has_to_string.{0} pos)))) h0 (@function.extfun_app.{0 0} (@eq.{1} (with_bot.{0} (topological_space.{0} (has_add.{0} (has_to_string.{0} (has_to_string.{0} pos))))) h0 (@has_bot.bot.{0} (with_bot.{0} (topological_space.{0} (has_add.{0} (has_to_string.{0} (has_to_string.{0} pos))))) (@with_bot.has_bot.{0} (topological_space.{0} (has_add.{0} (has_to_string.{0} (has_to_string.{0} pos))))))) (λ (x : @eq.{1} (with_bot.{0} (topological_space.{0} (has_add.{0} (has_to_string.{0} (has_to_string.{0} pos))))) h0 (@has_bot.bot.{0} (with_bot.{0} (topological_space.{0} (has_add.{0} (has_to_string.{0} (has_to_string.{0} pos))))) (@with_bot.has_bot.{0} (topological_space.{0} (has_add.{0} (has_to_string.{0} (has_to_string.{0} pos))))))), false) h1))  := sorry --non-trivial
lemma new_lemma_56927 (h0 : filter (plift (semiring congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_56928 (h0 : functor.add_const (ring (semigroup Type)) ennreal) : @rank_condition.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (semigroup.{1} Type)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_56929 (h0 : ring (ordered_comm_ring (has_add Type))) : rank_condition (ordered_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_56930 (h2 : filter (add_left_cancel_monoid to_additive.value_type)) : filter.ne_bot h2 := sorry --non-trivial
lemma new_lemma_56931 (h0 : topological_space (ordered_comm_ring (sub_neg_monoid real))) : t1_space (ordered_comm_ring (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_56932 (h0 : not (group (has_top unsigned) -> false)) : @group.fg.{0} (has_top.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (has_top.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_56933 (h0 : fin has_zero.zero) : @path_connected_space.{0} (has_pos_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_pos_part.{0} name))  := sorry --non-trivial
lemma new_lemma_56934 (h1 h2 : multiset enat) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_56935 (h0 : functor.add_const (topological_space (option empty)) unsigned) : @t0_space.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_56936 (h0 : ordered_comm_monoid (ordered_comm_monoid (ring pos))) : has_exists_mul_of_le (ordered_comm_monoid (ring pos)) := sorry --non-trivial
lemma new_lemma_56937 (h1 : not (add_group (with_one linarith.ineq) -> false)) : @is_add_cyclic.{0} (with_one.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (with_one.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_56938 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_56939 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @unique_factorization_monoid.{1} (canonically_ordered_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 cancel_comm_monoid_with_zero.{1}) (canonically_ordered_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_56940 (h0 : functor.add_const (function.extfun Type add_monoid) linarith.comp) : @add_monoid.fg.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) linarith.comp h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_56941 (h0 : functor.add_const (topological_space (has_zero pos)) pos) : @t0_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_56942 (h1 : ring (add_comm_semigroup ereal)) : is_domain (add_comm_semigroup ereal) := sorry --non-trivial
lemma new_lemma_56943 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_add.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_56944 (h0 : functor.add_const (group pos) (normed_comm_ring environment.implicit_infer_kind)) : @is_cyclic.{0} pos (@functor.add_const.run.{0 0} (group.{0} pos) (normed_comm_ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_56945 (h0 : function.extfun Type ring) : @rank_condition.{0} (free_add_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (free_add_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_56946 (h0 : topological_space (is_R_or_C unsigned)) : discrete_topology (is_R_or_C unsigned) := sorry --non-trivial
lemma new_lemma_56947 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (normed_linear_ordered_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_linear_ordered_group.{0} num))  := sorry --non-trivial
lemma new_lemma_56948 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} string_imp (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) string_imp)  := sorry --non-trivial
lemma new_lemma_56949 (h0 : topological_space (mul_one_class (add_comm_semigroup (add_comm_semigroup enat)))) : t0_space (mul_one_class (add_comm_semigroup (add_comm_semigroup enat))) := sorry --non-trivial
lemma new_lemma_56950 (h0 : functor.add_const (uniform_space (preorder empty)) empty) : @complete_space.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (preorder.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_56951 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (add_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_56952 (h0 : filter (has_zero (option pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_56953 (h0 : topological_space (has_one congr_arg_kind)) : topological_space.separable_space (has_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_56954 (h0 : ring (has_neg (option (canonically_ordered_comm_semiring unsigned)))) : rank_condition (has_neg (option (canonically_ordered_comm_semiring unsigned))) := sorry --non-trivial
lemma new_lemma_56955 (h0 : not (group (semi_normed_comm_ring string_imp) -> false)) : @is_cyclic.{0} (semi_normed_comm_ring.{0} string_imp) (@classical.by_contradiction'.{1} (group.{0} (semi_normed_comm_ring.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_56956 (h0 : group (linear_order unsigned)) : is_cyclic (linear_order unsigned) := sorry --non-trivial
lemma new_lemma_56957 (h0 : ring (cancel_monoid empty)) : is_domain (cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_56958 (h0 : topological_space (free_add_monoid num)) : path_connected_space (free_add_monoid num) := sorry --non-trivial
lemma new_lemma_56959 (h0 : functor.add_const (ordered_add_comm_monoid (add_comm_monoid pos)) (has_neg linarith.comp)) : @archimedean.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_comm_monoid.{0} pos)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_56960 (h0 : functor.add_const (topological_space (ordered_ring congr_arg_kind)) num) : @totally_separated_space.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_56961 (h0 : functor.add_const (uniform_space (option num)) empty) : @complete_space.{0} (option.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (option.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_56962 (h0 : functor.add_const (function.extfun Type topological_space) (finset environment.implicit_infer_kind)) : @locally_compact_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (finset.{0} environment.implicit_infer_kind) h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_56963 (h0 : functor.add_const (topological_space (finset Type)) linarith.comp) : @topological_space.separable_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_56964 (h0 : has_mem.mem (random_gen linarith.comp) has_emptyc.emptyc) : @discrete_topology.{0} (random_gen.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_56965 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} subsingleton_info (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 subsingleton_info)  := sorry --non-trivial
lemma new_lemma_56966 (h0 : with_bot (ulower Prop)) (h1 : ne h0 has_bot.bot) : @id.{1} Prop (@ulower.up.{0} Prop encodable.Prop (@with_bot.unbot.{0} (@ulower.{0} Prop encodable.Prop) h0 h1))  := sorry --non-trivial
lemma new_lemma_56967 (h0 : cancel_comm_monoid_with_zero (has_neg (finset linarith.comp))) : unique_factorization_monoid (has_neg (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_56968 (h0 : functor.add_const (topological_space (has_Inf name)) Type) : @topological_space.separable_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_56969 (h0 : topological_space (has_neg_part (mul_zero_class pos))) : totally_disconnected_space (has_neg_part (mul_zero_class pos)) := sorry --non-trivial
lemma new_lemma_56970 (h0 : uniform_space (ordered_comm_monoid (comm_semigroup real))) : separated_space (ordered_comm_monoid (comm_semigroup real)) := sorry --non-trivial
lemma new_lemma_56971 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_56972 (h0 : topological_space (has_neg_part (cancel_monoid name))) : sequential_space (has_neg_part (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_56973 (h0 : functor.add_const (uniform_space (partial_order congr_arg_kind)) unsigned) : @complete_space.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (partial_order.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_56974 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} real.angle (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) real.angle)  := sorry --non-trivial
lemma new_lemma_56975 (h0 : not (group (denumerable (random_gen fun_info)) -> false)) : @group.fg.{0} (denumerable.{0} (random_gen.{0} fun_info)) (@classical.by_contradiction'.{1} (group.{0} (denumerable.{0} (random_gen.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_56976 (h0 : function.extfun Type (functor.add_const (complete_lattice (mul_zero_class empty)))) : @is_compactly_generated.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (mul_zero_class.{0} empty)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (mul_zero_class.{0} empty))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_56977 (h0 : uniform_space (comm_ring (normed_field string_imp))) : complete_space (comm_ring (normed_field string_imp)) := sorry --non-trivial
lemma new_lemma_56978 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} pos (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) pos)  := sorry --non-trivial
lemma new_lemma_56979 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (has_norm.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_norm.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_56980 (h0 : add_monoid (has_neg (finset pos))) : add_monoid.fg (has_neg (finset pos)) := sorry --non-trivial
lemma new_lemma_56981 (h0 : fin has_zero.zero) : matrix.vec_empty (id (id (id (id (id (id h0)))))) := sorry --non-trivial
lemma new_lemma_56982 (h0 : topological_space (non_assoc_semiring num)) : normal_space (non_assoc_semiring num) := sorry --non-trivial
lemma new_lemma_56983 (h0 : monoid (semigroup (has_neg Type))) : monoid.fg (semigroup (has_neg Type)) := sorry --non-trivial
lemma new_lemma_56984 (h0 : group (ring (finset (has_add linarith.comp)))) : is_simple_group (ring (finset (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_56985 (h0 : topological_space (linear_ordered_add_comm_group (has_top (has_top num)))) : totally_separated_space (linear_ordered_add_comm_group (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_56986 (h0 : functor.add_const (ring (has_add Type)) linarith.comp) : @rank_condition.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_add.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_56987 (h0 : group (ordered_comm_monoid (has_to_string pos))) : is_simple_group (ordered_comm_monoid (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_56988 (h0 : not (ring (plift empty) -> false)) : @is_principal_ideal_ring.{1} (plift.{1} empty) (@classical.by_contradiction'.{2} (ring.{1} (plift.{1} empty)) h0)  := sorry --non-trivial
lemma new_lemma_56989 (h0 : functor.add_const (topological_space (has_neg_part name)) pos) : @regular_space.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_56990 (h0 : not (ring (measure_theory.measure_space num) -> false)) : @strong_rank_condition.{0} (measure_theory.measure_space.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (measure_theory.measure_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_56991 (h0 : functor.add_const (filter (has_pos_part Type)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_56992 (h0 : functor.add_const (semiring (with_bot congr_arg_kind)) congr_arg_kind) : @is_noetherian_ring.{0} (with_bot.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (semiring.{0} (with_bot.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_56993 (h0 : topological_space (add_cancel_monoid (has_zero Type))) : normal_space (add_cancel_monoid (has_zero Type)) := sorry --non-trivial
lemma new_lemma_56994 (h0 : filter (ordered_comm_monoid (has_add (has_add (ring pos))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_56995 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @t1_space.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_56996 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_56997 (h1 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_56998 (h1 : topological_space (denumerable string_imp)) : t0_space (denumerable string_imp) := sorry --non-trivial
lemma new_lemma_56999 (h0 : ordered_comm_monoid (option unsigned)) : has_exists_mul_of_le (option unsigned) := sorry --non-trivial
lemma new_lemma_57000 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @totally_disconnected_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_57001 (h0 : ordered_add_comm_monoid (boolean_algebra.core pos)) : archimedean (boolean_algebra.core pos) := sorry --non-trivial
lemma new_lemma_57002 (h0 : not (complete_lattice (measurable_space linarith.ineq) -> false)) : is_compactly_generated (measurable_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_57003 (h0 : topological_space (has_inv (random_gen (has_ssubset to_additive.value_type)))) : t0_space (has_inv (random_gen (has_ssubset to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_57004 (h0 : topological_space (add_right_cancel_monoid (semiring empty))) : normal_space (add_right_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_57005 (h0 : functor.add_const (functor.comp ordered_add_comm_monoid has_to_string pos) Type) : @archimedean.{0} (has_to_string.{0} pos) (@functor.comp.run.{0 0 0} ordered_add_comm_monoid.{0} has_to_string.{0} pos (@functor.add_const.run.{0 1} (functor.comp.{0 0 0} ordered_add_comm_monoid.{0} has_to_string.{0} pos) Type h0))  := sorry --non-trivial
lemma new_lemma_57006 (h0 : list (comm_group (comm_group (mul_zero_class ennreal)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_57007 (h0 : topological_space (has_one (semiring (semiring (semiring (random_gen fun_info)))))) : totally_separated_space (has_one (semiring (semiring (semiring (random_gen fun_info))))) := sorry --non-trivial
lemma new_lemma_57008 (h0 : fin has_zero.zero) : @add_monoid.fg.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (add_monoid.{1} (canonically_linear_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_57009 (h0 : group (comm_group (has_add ennreal))) : normalizer_condition (comm_group (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_57010 (h0 : topological_space (normed_field char) -> random_gen char) (h1 : coe_sort (set.range h0)) : @totally_disconnected_space.{0} (normed_field.{0} char) (@set.range_splitting.{0 0} (topological_space.{0} (normed_field.{0} char)) (random_gen.{0} char) h0 h1)  := sorry --non-trivial
lemma new_lemma_57011 (h0 : functor.add_const Prop (normed_comm_ring (has_to_string name))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_57012 (h0 : topological_space (has_Inf (has_Inf (sub_neg_monoid pos)))) : topological_space.separable_space (has_Inf (has_Inf (sub_neg_monoid pos))) := sorry --non-trivial
lemma new_lemma_57013 (h0 : topological_space (comm_semigroup (has_Inf Type))) : path_connected_space (comm_semigroup (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_57014 (h0 : topological_space (semigroup (add_comm_monoid Type))) : discrete_topology (semigroup (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_57015 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (group_with_zero unsigned)) := sorry --non-trivial
lemma new_lemma_57016 (h0 : functor.comp group has_neg_part Type) : @group.fg.{1} (has_neg_part.{1} Type) (@functor.comp.run.{1 1 1} group.{1} has_neg_part.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_57017 (h0 : functor.add_const (topological_space (ring unsigned)) Type) : @regular_space.{0} (ring.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_57018 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (ordered_comm_group.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (ordered_comm_group.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_57019 (h0 : ring (topological_space (with_one fun_info))) : is_domain (topological_space (with_one fun_info)) := sorry --non-trivial
lemma new_lemma_57020 (h0 : add_group (normed_comm_ring name)) : is_add_cyclic (normed_comm_ring name) := sorry --non-trivial
lemma new_lemma_57021 (h0 : uniform_space (finset linarith.comp)) : separated_space (finset linarith.comp) := sorry --non-trivial
lemma new_lemma_57022 (h0 : add_group (semigroup (boolean_algebra.core (add_cancel_monoid Type)))) : is_add_cyclic (semigroup (boolean_algebra.core (add_cancel_monoid Type))) := sorry --non-trivial
lemma new_lemma_57023 (h0 : not (ring (ordered_comm_monoid to_additive.value_type) -> false)) : @rank_condition.{0} (ordered_comm_monoid.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (ordered_comm_monoid.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_57024 (h0 : functor.add_const (finset (finset unsigned)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_57025 (h0 : functor.add_const (filter (normed_comm_ring pos)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_57026 (h1 : function.extfun Type uniform_space) : @complete_space.{0} string_imp (@function.extfun_app.{2 1} Type uniform_space.{0} h1 string_imp)  := sorry --non-trivial
lemma new_lemma_57027 (h0 : group (with_bot (id (has_top (random_gen (random_gen linarith.ineq)))))) : normalizer_condition (with_bot (id (has_top (random_gen (random_gen linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_57028 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_57029 (h0 : add_group (plift (semiring empty))) : is_add_cyclic (plift (semiring empty)) := sorry --non-trivial
lemma new_lemma_57030 (h0 : functor.add_const (uniform_space (ordered_comm_ring name)) pos) : @separated_space.{0} (ordered_comm_ring.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (ordered_comm_ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_57031 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_57032 (h0 : not (complete_lattice (option congr_arg_kind) -> false)) : @is_atomistic.{0} (option.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (option.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_57033 (h0 : group (bin_tree (semiring unsigned))) : is_cyclic (bin_tree (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_57034 (h0 : complete_lattice (ring (has_neg_part pos))) : is_compactly_generated (ring (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_57035 (h0 : functor.add_const (ring (has_nndist pos)) name) : @is_principal_ideal_ring.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_nndist.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_57036 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_57037 (h0 : ring (has_lt (mul_one_class linarith.comp_source))) : rank_condition (has_lt (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_57038 (h0 : group (complete_distrib_lattice linarith.comp)) : normalizer_condition (complete_distrib_lattice linarith.comp) := sorry --non-trivial
lemma new_lemma_57039 (h0 : topological_space (complete_distrib_lattice (has_add Type))) : regular_space (complete_distrib_lattice (has_add Type)) := sorry --non-trivial
lemma new_lemma_57040 (h0 : topological_space (boolean_algebra.core unsigned)) : irreducible_space (boolean_algebra.core unsigned) := sorry --non-trivial
lemma new_lemma_57041 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring name)) Type) : @rank_condition.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (canonically_ordered_comm_semiring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_57042 (h0 : semiring (ordered_cancel_add_comm_monoid (option empty))) : is_noetherian_ring (ordered_cancel_add_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_57043 (h0 : ring (ring (normed_comm_ring pos))) : is_principal_ideal_ring (ring (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_57044 (h0 : topological_space (comm_group (has_add environment.implicit_infer_kind))) : irreducible_space (comm_group (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_57045 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_inter.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_inter.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_57046 (h0 : add_group (ordered_comm_ring real)) : is_add_cyclic (ordered_comm_ring real) := sorry --non-trivial
lemma new_lemma_57047 (h0 : function.extfun nat fin) : @archimedean.{0} (ordered_comm_monoid.{0} real) (@matrix.vec_empty.{0} (ordered_add_comm_monoid.{0} (ordered_comm_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_57048 (h0 : topological_space (uniform_space string_imp)) : t0_space (uniform_space string_imp) := sorry --non-trivial
lemma new_lemma_57049 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @loc_path_connected_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_57050 (h0 : not (ring (semi_normed_ring string_imp) -> false)) : @strong_rank_condition.{0} (semi_normed_ring.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_ring.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_57051 (h0 : topological_space (has_add (has_nndist ennreal))) : preconnected_space (has_add (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_57052 (h0 : multiset (uniform_space linarith.comp_source)) (h1 : not (multiset (uniform_space linarith.comp_source) -> false)) : multiset.disjoint h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_57053 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_57054 (h0 h1 : multiset (semi_normed_comm_ring enat)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_57055 (h0 : add_group (canonically_ordered_add_monoid unsigned) -> Prop) (h1 : Exists (fun (x : add_group (canonically_ordered_add_monoid unsigned)), h0 x)) : @is_add_cyclic.{0} (canonically_ordered_add_monoid.{0} unsigned) (@classical.some.{1} (add_group.{0} (canonically_ordered_add_monoid.{0} unsigned)) h0 h1)  := sorry --non-trivial
lemma new_lemma_57056 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_57057 (h0 : filter (boolean_algebra (has_add unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_57058 (h1 h2 : multiset (mul_one_class (mul_one_class (mul_one_class (add_comm_semigroup ereal))))) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_57059 (h0 : functor.add_const (list (add_comm_monoid environment.implicit_infer_kind)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_57060 (h0 : topological_space (boolean_algebra.core (has_add (has_add (has_add (has_add linarith.comp)))))) : preirreducible_space (boolean_algebra.core (has_add (has_add (has_add (has_add linarith.comp))))) := sorry --non-trivial
lemma new_lemma_57061 (h0 : topological_space (random_gen reducibility_hints)) : t0_space (random_gen reducibility_hints) := sorry --non-trivial
lemma new_lemma_57062 (h0 : functor.add_const (complete_lattice (has_to_string Type)) (finset linarith.comp)) : @is_compactly_generated.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_to_string.{1} Type)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_57063 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_57064 (h1 : set (set to_additive.value_type)) : is_countably_spanning h1 := sorry --non-trivial
lemma new_lemma_57065 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) linarith.comp) : @path_connected_space.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_57066 (h0 : topological_space pos) : regular_space pos := sorry --non-trivial
lemma new_lemma_57067 (h0 : monoid (has_pos_part (boolean_algebra.core Type))) : monoid.fg (has_pos_part (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_57068 (h0 : topological_space (semi_normed_comm_ring (mul_one_class to_additive.value_type))) : t0_space (semi_normed_comm_ring (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_57069 (h0 : set (has_le reducibility_hints)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_57070 (h0 : topological_space (has_pos_part (finset Type))) : irreducible_space (has_pos_part (finset Type)) := sorry --non-trivial
lemma new_lemma_57071 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (as_linear_order.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (as_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_57072 (h0 : has_mem.mem (with_one linarith.comp) has_emptyc.emptyc) : @add_monoid.fg.{0} (with_one.{0} linarith.comp) (@finset.pi.empty.{1 0} Type add_monoid.{0} (with_one.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_57073 (h0 : finset (complete_distrib_lattice (comm_group Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_57074 (h0 : functor.add_const (group (semiring num)) num) : @group.fg.{0} (semiring.{0} num) (@functor.add_const.run.{0 0} (group.{0} (semiring.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_57075 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_Sup.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_Sup.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_57076 (h0 : topological_space (boolean_algebra (boolean_algebra pos))) : irreducible_space (boolean_algebra (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_57077 (h0 : ring (metric_space (has_top num))) : is_domain (metric_space (has_top num)) := sorry --non-trivial
lemma new_lemma_57078 (h0 : ordered_add_comm_monoid (add_comm_monoid congr_arg_kind)) : archimedean (add_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_57079 (h0 : complete_lattice (boolean_algebra (finset (has_Inf linarith.comp)))) : complete_lattice.is_Sup_finite_compact (boolean_algebra (finset (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_57080 (h0 : functor.add_const (function.extfun Type complete_lattice) (has_Inf Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type complete_lattice.{0}) (has_Inf.{1} Type) h0) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_57081 (h0 : topological_space (boolean_algebra (is_R_or_C (has_pos_part (finset linarith.comp))))) : preconnected_space (boolean_algebra (is_R_or_C (has_pos_part (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_57082 (h0 : list (has_top (has_ssubset (random_gen string_imp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_57083 (h0 : functor.add_const (topological_space (boolean_algebra.core environment.implicit_infer_kind)) Type) : @topological_space.separable_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_57084 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_57085 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_57086 (h0 : ring (encodable (has_top fun_info))) : strong_rank_condition (encodable (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_57087 (h0 : topological_space (ring (has_Inf linarith.comp))) : t0_space (ring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_57088 (h0 : not (uniform_space (with_zero fun_info) -> false)) : @complete_space.{0} (with_zero.{0} fun_info) (@classical.by_contradiction'.{1} (uniform_space.{0} (with_zero.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_57089 (h0 : group (finset (has_add (ring pos)))) : is_simple_group (finset (has_add (ring pos))) := sorry --non-trivial
lemma new_lemma_57090 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_57091 (h0 : topological_space (comm_group (has_neg (has_add ennreal)))) : totally_separated_space (comm_group (has_neg (has_add ennreal))) := sorry --non-trivial
lemma new_lemma_57092 (h0 : group (generalized_boolean_algebra (has_pos_part (has_add linarith.comp)))) : group.fg (generalized_boolean_algebra (has_pos_part (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_57093 (h0 : functor.add_const (ordered_comm_monoid (ring Type)) (finset (finset Type))) : @has_exists_mul_of_le.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (ordered_comm_monoid.{1} (ring.{1} Type)) (finset.{1} (finset.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_57094 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (has_pos_part.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_57095 (h0 : complete_lattice (has_norm (has_top empty))) : is_atomistic (has_norm (has_top empty)) := sorry --non-trivial
lemma new_lemma_57096 (h0 : functor.add_const (ring (has_neg_part Type)) environment.implicit_infer_kind) : @rank_condition.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_neg_part.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_57097 (h0 : has_mem.mem (complete_lattice (random_gen num)) has_emptyc.emptyc) : @rank_condition.{0} (complete_lattice.{0} (random_gen.{0} num)) (@finset.pi.empty.{1 0} Type ring.{0} (complete_lattice.{0} (random_gen.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_57098 (h0 : list (linear_ordered_field (option (option empty)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_57099 (h0 : functor.add_const (topological_space (has_Inf pos)) (has_neg name)) : @preconnected_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_57100 (h0 : add_group (has_inv (random_gen linarith.ineq))) : is_add_cyclic (has_inv (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_57101 (h0 : not (add_monoid (has_sub empty) -> false)) : @add_monoid.fg.{0} (has_sub.{0} empty) (@classical.by_contradiction'.{1} (add_monoid.{0} (has_sub.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_57102 (h0 : filter (measurable_space (semiring (semiring empty)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_57103 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) pos) : @topological_space.separable_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_57104 (h2 : ring (normed_field linarith.comp_source)) : rank_condition (normed_field linarith.comp_source) := sorry --non-trivial
lemma new_lemma_57105 (h0 : uniform_space (add_right_cancel_monoid (semiring (semiring unsigned)))) : separated_space (add_right_cancel_monoid (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_57106 (h0 : group (boolean_algebra unsigned)) : is_cyclic (boolean_algebra unsigned) := sorry --non-trivial
lemma new_lemma_57107 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) (mul_one_class (mul_one_class pos))) : @sequential_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) (mul_one_class.{0} (mul_one_class.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_57108 (h0 : complete_lattice (comm_group name)) : is_atomistic (comm_group name) := sorry --non-trivial
lemma new_lemma_57109 (h2 : group (has_norm (random_gen linarith.comp_source))) : is_cyclic (has_norm (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_57110 (h0 : multiset (simple_graph char)) (h1 : not (multiset (simple_graph char) -> false)) : multiset.disjoint h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_57111 (h0 : has_mem.mem ring has_emptyc.emptyc) : @strong_rank_condition.{0} num (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) num)  := sorry --non-trivial
lemma new_lemma_57112 (h0 : ring (ring (boolean_algebra linarith.comp))) : is_domain (ring (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_57113 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @discrete_topology.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_57114 (h0 : group (encodable (has_nnnorm linarith.comp_source))) : is_cyclic (encodable (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_57115 (h2 : topological_space (normed_field to_additive.value_type)) : path_connected_space (normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_57116 (h0 : functor.add_const (topological_space (complete_distrib_lattice name)) environment.implicit_infer_kind) : @locally_compact_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_57117 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (canonically_linear_ordered_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_57118 (h0 : topological_space (normed_lattice_add_comm_group (has_bot (has_neg Type)))) : discrete_topology (normed_lattice_add_comm_group (has_bot (has_neg Type))) := sorry --non-trivial
lemma new_lemma_57119 (h0 : functor.add_const (semiring (linear_ordered_cancel_comm_monoid empty)) (semiring unsigned)) : @is_noetherian_ring.{0} (linear_ordered_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (linear_ordered_cancel_comm_monoid.{0} empty)) (semiring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_57120 (h0 : ring (has_ssubset (uniform_space (comm_ring (comm_ring linarith.comp_source))))) : strong_rank_condition (has_ssubset (uniform_space (comm_ring (comm_ring linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_57121 (h0 : filter (boolean_algebra (has_to_string unsigned))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_57122 (h0 : functor.add_const (function.extfun nat fin) linarith.comp) : @discrete_topology.{0} (ordered_comm_ring.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin (@functor.add_const.run.{0 0} (function.extfun.{1 1} nat fin) linarith.comp h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_57123 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (preorder.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (preorder.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_57124 (h0 : functor.add_const (list (has_pos_part pos)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_57125 (h0 : topological_space (boolean_algebra (cancel_monoid (has_add Type)))) : totally_disconnected_space (boolean_algebra (cancel_monoid (has_add Type))) := sorry --non-trivial
lemma new_lemma_57126 (h0 : pfun (mul_one_class std_gen) (topological_space (has_nnnorm ereal))) (h1 : coe_sort (pfun.dom h0)) : @path_connected_space.{0} (has_nnnorm.{0} ereal) (@pfun.as_subtype.{0 0} (mul_one_class.{0} std_gen) (topological_space.{0} (has_nnnorm.{0} ereal)) h0 h1)  := sorry --non-trivial
lemma new_lemma_57127 (h0 : functor.add_const (monoid (has_edist unsigned)) num) : @monoid.fg.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (has_edist.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_57128 (h0 : functor.comp topological_space finset Type) : @preconnected_space.{1} (finset.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} finset.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_57129 (h0 : finset (canonically_linear_ordered_monoid (has_add name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_57130 (h0 : uniform_space (has_append (comm_ring linarith.ineq))) : complete_space (has_append (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_57131 (h0 : function.extfun Type (functor.add_const (topological_space (add_cancel_monoid empty)))) : @normal_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty)) (option.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty))) h0 (option.{0} (option.{0} empty))))  := sorry --non-trivial
lemma new_lemma_57132 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @group.fg.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_57133 (h0 : has_le (has_nnnorm fun_info)) (h1 : bounded_order (has_nnnorm fun_info)) : is_simple_order (has_nnnorm fun_info) := sorry --non-trivial
lemma new_lemma_57134 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_57135 (h0 : functor.add_const (list (add_left_cancel_semigroup empty)) (option unsigned)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_57136 (h0 : function.extfun (Type 1) ring) : @is_principal_ideal_ring.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_57137 (h0 : function.extfun (finset Type) (has_mem.mem fun_info)) : @monoid.fg.{0} fun_info (@finset.pi.empty.{1 0} Type monoid.{0} fun_info (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) fun_info) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_57138 (h0 : ordered_comm_monoid (linear_ordered_field unsigned)) : has_exists_mul_of_le (linear_ordered_field unsigned) := sorry --non-trivial
lemma new_lemma_57139 (h0 : topological_space (comm_group (has_add (has_neg environment.implicit_infer_kind)))) : preirreducible_space (comm_group (has_add (has_neg environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_57140 (h0 : group (simple_graph linarith.comp)) : is_cyclic (simple_graph linarith.comp) := sorry --non-trivial
lemma new_lemma_57141 (h0 : function.extfun Type topological_space) : @t0_space.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_57142 (h0 : complete_lattice (ordered_comm_semiring char)) : is_compactly_generated (ordered_comm_semiring char) := sorry --non-trivial
lemma new_lemma_57143 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @t1_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_57144 (h0 : topological_space (topological_space (has_nnnorm (has_nnnorm fun_info)))) : path_connected_space (topological_space (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_57145 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_57146 (h0 : topological_space (add_comm_semigroup (add_comm_semigroup string.iterator_imp))) (h1 : set (add_comm_semigroup (add_comm_semigroup string.iterator_imp))) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_57147 (h0 : list (has_top (random_gen char))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_57148 (h0 : topological_space (has_bot pos)) : irreducible_space (has_bot pos) := sorry --non-trivial
lemma new_lemma_57149 (h0 : functor.add_const Prop (option num)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_57150 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_57151 (h0 : ulower empty) : empty.elim (ulower.up h0) := sorry --non-trivial
lemma new_lemma_57152 (h0 : functor.add_const (topological_space (has_to_string pos)) name) : @t0_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_57153 (h0 : ring (has_ssubset linarith.ineq)) : rank_condition (has_ssubset linarith.ineq) := sorry --non-trivial
lemma new_lemma_57154 (h0 : functor.add_const (filter (semigroup linarith.comp)) environment.implicit_infer_kind) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_57155 (h0 : has_mem.mem (has_norm fun_info) has_emptyc.emptyc) : @is_atomistic.{0} (has_norm.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_norm.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_57156 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_57157 (h0 : functor.add_const (topological_space (has_add name)) name) : @discrete_topology.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_57158 (h0 : cancel_comm_monoid_with_zero (has_to_string Type)) : unique_factorization_monoid (has_to_string Type) := sorry --non-trivial
lemma new_lemma_57159 (h2 : ring (semi_normed_ring linarith.ineq)) : strong_rank_condition (semi_normed_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_57160 (h0 : cancel_comm_monoid_with_zero (left_cancel_semigroup empty)) : unique_factorization_monoid (left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_57161 (h0 : function.extfun (finset ((Type -> Type) -> Type 1)) (has_mem.mem (function.extfun Type))) : @rank_condition.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@function.extfun_app.{3 0} (finset.{2} ((Type → Type) → Type 1)) (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (finset.{2} ((Type → Type) → Type 1)) (@finset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type)) h0 (@has_emptyc.emptyc.{2} (finset.{2} ((Type → Type) → Type 1)) (@finset.has_emptyc.{2} ((Type → Type) → Type 1))))) ring.{0}) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_57162 (h0 : list (has_neg linarith.comp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_57163 (h0 : ring (denumerable (group char))) : strong_rank_condition (denumerable (group char)) := sorry --non-trivial
lemma new_lemma_57164 (h0 : function.extfun Type (functor.add_const (uniform_space znum))) : @separated_space.{0} znum (@functor.add_const.run.{0 0} (uniform_space.{0} znum) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} znum)) h0 num))  := sorry --non-trivial
lemma new_lemma_57165 (h1 : group (has_top (random_gen string_imp))) : is_cyclic (has_top (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_57166 (h0 : complete_lattice (with_bot (random_gen linarith.ineq))) : complete_lattice.is_Sup_finite_compact (with_bot (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_57167 (h0 : topological_space (ordered_comm_monoid (has_neg name))) : discrete_topology (ordered_comm_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_57168 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_57169 (h0 : functor.add_const (topological_space (semigroup Type)) pos) : @irreducible_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_57170 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) pos) : @preirreducible_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_57171 (h0 : group (has_add (ring linarith.comp))) : is_simple_group (has_add (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_57172 (h0 : add_monoid (has_Inf (has_neg pos))) : add_monoid.fg (has_Inf (has_neg pos)) := sorry --non-trivial
lemma new_lemma_57173 (h0 h1 : multiset (nondiscrete_normed_field char)) (h2 : punit) : multiset.le h0 (category_theory.hom_of_element h1 h2) := sorry --non-trivial
lemma new_lemma_57174 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @has_exists_mul_of_le.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ordered_comm_monoid.{1}) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_57175 (h0 : complete_lattice (has_Inf Type)) : is_compactly_generated (has_Inf Type) := sorry --non-trivial
lemma new_lemma_57176 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_dist.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (has_dist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_57177 (h0 : topological_space (non_unital_non_assoc_semiring enat)) (h1 : add_group (non_unital_non_assoc_semiring enat)) : topological_add_group (non_unital_non_assoc_semiring enat) := sorry --non-trivial
lemma new_lemma_57178 (h0 : group (topological_space (semi_normed_comm_ring reducibility_hints))) : is_cyclic (topological_space (semi_normed_comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_57179 (h0 : fin has_zero.zero) : @t1_space.{0} (add_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_57180 (h0 : functor.add_const (semiring Type) linarith.comp) : @is_noetherian_ring.{1} Type (@functor.add_const.run.{1 0} (semiring.{1} Type) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_57181 (h0 : not (ring (option unsigned) -> false)) : @strong_rank_condition.{0} (option.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_57182 (h0 : boolean_algebra.core (option ennreal) -> boolean_algebra.core (option ennreal) -> Prop) : is_symm (boolean_algebra.core (option ennreal)) h0 := sorry --non-trivial
lemma new_lemma_57183 (h0 : set (has_compl (mul_one_class (mul_one_class (mul_one_class linarith.ineq))))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_57184 (h0 : function.extfun (Type 1) (functor.add_const (topological_space (has_Inf pos)))) : @locally_compact_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} pos)) Type (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (topological_space.{0} (has_Inf.{0} pos))) h0 Type))  := sorry --non-trivial
lemma new_lemma_57185 (h0 : topological_space (normed_lattice_add_comm_group (canonically_linear_ordered_monoid (has_neg pos)))) : t0_space (normed_lattice_add_comm_group (canonically_linear_ordered_monoid (has_neg pos))) := sorry --non-trivial
lemma new_lemma_57186 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (add_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_57187 (h0 : has_mem.mem (linear_ordered_add_comm_group linarith.comp_source) has_emptyc.emptyc) : @is_atomistic.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_57188 (h0 : topological_space (mul_zero_class (semiring empty))) : irreducible_space (mul_zero_class (semiring empty)) := sorry --non-trivial
lemma new_lemma_57189 (h0 : topological_space (encodable fun_info)) : t0_space (encodable fun_info) := sorry --non-trivial
lemma new_lemma_57190 (h0 : semiring (group_with_zero congr_arg_kind)) : is_noetherian_ring (group_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_57191 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} auto.case_option (@function.extfun_app.{2 1} Type ring.{0} h0 auto.case_option)  := sorry --non-trivial
lemma new_lemma_57192 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 pos) := sorry --non-trivial
lemma new_lemma_57193 (h0 : functor.add_const (complete_lattice (ring name)) Type) : @is_atomistic.{0} (ring.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_57194 (h0 : add_group (div_inv_monoid char)) : is_add_cyclic (div_inv_monoid char) := sorry --non-trivial
lemma new_lemma_57195 (h0 : ring (sub_neg_monoid (finset (has_add (finset (finset linarith.comp)))))) : strong_rank_condition (sub_neg_monoid (finset (has_add (finset (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_57196 (h0 : functor.add_const (topological_space (has_neg unsigned)) environment.implicit_infer_kind) : @topological_space.separable_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_57197 (h0 : fin has_zero.zero) : @is_cyclic.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (normed_lattice_add_comm_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_57198 (h1 : topological_space (distrib_lattice linarith.ineq)) : totally_separated_space (distrib_lattice linarith.ineq) := sorry --non-trivial
lemma new_lemma_57199 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (simple_graph pos)) := sorry --non-trivial
lemma new_lemma_57200 (h0 : topological_space (random_gen (semiring (semiring empty)))) : totally_separated_space (random_gen (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_57201 (h0 : monoid (measurable_space (semiring num))) : monoid.fg (measurable_space (semiring num)) := sorry --non-trivial
lemma new_lemma_57202 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_57203 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (linear_ordered_comm_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} num))  := sorry --non-trivial
lemma new_lemma_57204 (h0 : group (normed_group (semiring (semiring congr_arg_kind)))) : is_cyclic (normed_group (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_57205 (h0 : topological_space (add_cancel_comm_monoid (metric_space string_imp))) : path_connected_space (add_cancel_comm_monoid (metric_space string_imp)) := sorry --non-trivial
lemma new_lemma_57206 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group num))) : @totally_separated_space.{0} (normed_group.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_57207 (h0 : functor.comp topological_space comm_group (option (option unsigned))) : @topological_space.separable_space.{0} (comm_group.{0} (option.{0} (option.{0} unsigned))) (@functor.comp.run.{0 0 0} topological_space.{0} comm_group.{0} (option.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_57208 (h0 : topological_space (canonically_ordered_monoid linarith.comp)) : sequential_space (canonically_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_57209 (h0 : functor.add_const (fin has_zero.zero) real) : @add_monoid.fg.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (add_monoid.{1} (has_bot.{1} Type)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) real h0))  := sorry --non-trivial
lemma new_lemma_57210 (h0 : topological_space (left_cancel_monoid unsigned)) : irreducible_space (left_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_57211 (h0 : complete_lattice (sub_neg_monoid (has_Inf (has_add (has_add Type))))) : is_compactly_generated (sub_neg_monoid (has_Inf (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_57212 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_57213 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_57214 (h0 : set (distrib (mul_one_class fun_info))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_57215 (h0 : list (complete_distrib_lattice Type)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_57216 (h0 : topological_space (complete_linear_order empty)) : locally_compact_space (complete_linear_order empty) := sorry --non-trivial
lemma new_lemma_57217 (h0 : functor.add_const (topological_space znum) (option (option (option empty)))) : @locally_compact_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) (option.{0} (option.{0} (option.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_57218 (h0 : ring (ordered_comm_monoid (sub_neg_monoid real))) : rank_condition (ordered_comm_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_57219 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_57220 (h0 : functor.comp add_group has_neg linarith.comp) : @is_add_cyclic.{0} (has_neg.{0} linarith.comp) (@functor.comp.run.{0 0 0} add_group.{0} has_neg.{0} linarith.comp (@functor.comp.run.{0 0 0} add_group.{0} has_neg.{0} linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_57221 (h0 : functor.add_const (finset (has_zero linarith.comp)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_57222 (h1 : group (complete_semilattice_Sup to_additive.value_type)) : is_cyclic (complete_semilattice_Sup to_additive.value_type) := sorry --non-trivial
lemma new_lemma_57223 (h0 : group (ring (option num))) : group.fg (ring (option num)) := sorry --non-trivial
lemma new_lemma_57224 (h0 : group (has_emptyc empty)) : normalizer_condition (has_emptyc empty) := sorry --non-trivial
lemma new_lemma_57225 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (monoid ennreal)) := sorry --non-trivial
lemma new_lemma_57226 (h0 : topological_space (has_top (has_nnnorm to_additive.value_type))) : locally_compact_space (has_top (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_57227 (h0 : topological_space (has_zero (option pos))) : preconnected_space (has_zero (option pos)) := sorry --non-trivial
lemma new_lemma_57228 (h0 : function.extfun Type ring) : @rank_condition.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_57229 (h0 : functor.add_const (functor.add_const (filter Type) linarith.comp) Type) : countable_Inter_filter (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_57230 (h0 : function.extfun Type (functor.add_const (topological_space pos))) : @loc_path_connected_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} pos)) h0 pos))  := sorry --non-trivial
lemma new_lemma_57231 (h0 : functor.add_const (complete_lattice (left_cancel_monoid unsigned)) unsigned) : @is_compactly_generated.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_57232 (h0 : topological_space (cancel_monoid (complete_distrib_lattice (has_nndist ennreal)))) : preconnected_space (cancel_monoid (complete_distrib_lattice (has_nndist ennreal))) := sorry --non-trivial
lemma new_lemma_57233 (h0 : topological_space (has_union (has_union (has_union (metric_space empty))))) : t0_space (has_union (has_union (has_union (metric_space empty)))) := sorry --non-trivial
lemma new_lemma_57234 (h0 : topological_space (comm_group (has_to_string name))) : sequential_space (comm_group (has_to_string name)) := sorry --non-trivial
lemma new_lemma_57235 (h0 : group (random_gen (random_gen string_imp))) : is_cyclic (random_gen (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_57236 (h0 : topological_space (has_add (ring (has_pos_part (has_Inf (has_Inf (has_pos_part Type))))))) : locally_compact_space (has_add (ring (has_pos_part (has_Inf (has_Inf (has_pos_part Type)))))) := sorry --non-trivial
lemma new_lemma_57237 (h0 : functor.add_const (function.extfun Type group) Type) : @group.fg.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_57238 (h0 : functor.comp topological_space has_neg Type) : @topological_space.separable_space.{1} (has_neg.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_neg.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_57239 (h0 : topological_space (semigroup name)) : irreducible_space (semigroup name) := sorry --non-trivial
lemma new_lemma_57240 (h0 : complete_lattice (linear_ordered_add_comm_group fun_info)) : is_atomistic (linear_ordered_add_comm_group fun_info) := sorry --non-trivial
lemma new_lemma_57241 (h0 : group (measurable_space (semiring linarith.comp))) : group.fg (measurable_space (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_57242 (h0 : ring (bin_tree num)) : strong_rank_condition (bin_tree num) := sorry --non-trivial
lemma new_lemma_57243 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_57244 (h0 : ring (complete_distrib_lattice (ring (has_add unsigned)))) : rank_condition (complete_distrib_lattice (ring (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_57245 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_57246 (h0 : group (add_group (semiring num))) : normalizer_condition (add_group (semiring num)) := sorry --non-trivial
lemma new_lemma_57247 (h0 : functor.add_const (topological_space (boolean_algebra Type)) name) : @locally_compact_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_57248 (h0 : group (has_zero (option pos))) : normalizer_condition (has_zero (option pos)) := sorry --non-trivial
lemma new_lemma_57249 (h0 : functor.add_const (topological_space (finset unsigned)) unsigned) : @t1_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_57250 (h1 : add_group (ordered_comm_monoid char)) : is_add_cyclic (ordered_comm_monoid char) := sorry --non-trivial
lemma new_lemma_57251 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_57252 (h0 : topological_space (has_ssubset (has_top fun_info))) : irreducible_space (has_ssubset (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_57253 (h0 : functor.add_const (ring (semigroup linarith.comp)) environment.implicit_infer_kind) : @strong_rank_condition.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_57254 (h0 : list (comm_ring (has_ssubset to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_57255 (h0 : topological_space (has_top (has_norm linarith.comp))) : irreducible_space (has_top (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_57256 (h0 : not (semiring (non_assoc_semiring unsigned) -> false)) : @is_noetherian_ring.{0} (non_assoc_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (semiring.{0} (non_assoc_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_57257 (h0 : function.extfun Type topological_space) : @normal_space.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_57258 (h0 : functor.add_const (group (finset Type)) (add_comm_monoid Type)) : @is_simple_group.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (finset.{1} Type)) (add_comm_monoid.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_57259 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_union.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_union.{0} num))  := sorry --non-trivial
lemma new_lemma_57260 (h0 : function.extfun Type topological_space) : @normal_space.{0} (group_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_57261 (h1 : topological_space (add_monoid (has_nnnorm fun_info))) : t0_space (add_monoid (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_57262 (h0 : topological_space (linear_ordered_semiring congr_arg_kind)) : locally_compact_space (linear_ordered_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_57263 (h0 : topological_space (complete_distrib_lattice (cancel_monoid ennreal))) : t1_space (complete_distrib_lattice (cancel_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_57264 (h0 : ring (semiring (has_norm (semiring linarith.comp)))) : is_domain (semiring (has_norm (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_57265 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_57266 (h0 : add_monoid (add_cancel_monoid (ring (finset environment.implicit_infer_kind)))) : add_monoid.fg (add_cancel_monoid (ring (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_57267 (h0 : finset (canonically_ordered_comm_semiring (has_add pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_57268 (h0 : ring (has_zero unsigned)) : is_principal_ideal_ring (has_zero unsigned) := sorry --non-trivial
lemma new_lemma_57269 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (ring name)) : @topological_space.separable_space.{1} (ordered_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (ring.{0} name) h0) (ordered_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_57270 (h0 : topological_space (linear_ordered_field (option pos))) : locally_compact_space (linear_ordered_field (option pos)) := sorry --non-trivial
lemma new_lemma_57271 (h0 : filter (has_nndist (comm_group (comm_group pos)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_57272 (h0 : functor.add_const (topological_space (has_zero name)) name) : @preconnected_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_57273 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_57274 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} h0 (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_57275 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (denumerable.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (denumerable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_57276 (h0 : ring (add_cancel_comm_monoid string.iterator_imp)) : strong_rank_condition (add_cancel_comm_monoid string.iterator_imp) := sorry --non-trivial
lemma new_lemma_57277 (h0 : functor.add_const (complete_lattice (boolean_algebra.core unsigned)) unsigned) : @is_compactly_generated.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_57278 (h0 : function.extfun Type (functor.comp topological_space cancel_monoid)) : @totally_disconnected_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} environment.implicit_infer_kind (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} cancel_monoid.{0}) h0 environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_57279 (h0 : topological_space (dlist (has_nnnorm (has_inv (has_ssubset fun_info))))) : totally_disconnected_space (dlist (has_nnnorm (has_inv (has_ssubset fun_info)))) := sorry --non-trivial
lemma new_lemma_57280 (h0 : functor.add_const (group (add_cancel_monoid Type)) pos) : @normalizer_condition.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (add_cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_57281 (h0 : not (topological_space (with_bot unsigned) -> false)) : @preirreducible_space.{0} (with_bot.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_57282 (h0 : functor.add_const (monoid (has_neg_part pos)) unsigned) : @monoid.fg.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (has_neg_part.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_57283 (h0 : ring (linear_ordered_semiring empty)) : rank_condition (linear_ordered_semiring empty) := sorry --non-trivial
lemma new_lemma_57284 (h0 : topological_space (generalized_boolean_algebra (ring (has_add Type)))) : totally_disconnected_space (generalized_boolean_algebra (ring (has_add Type))) := sorry --non-trivial
lemma new_lemma_57285 (h0 : has_to_string (normed_comm_ring (option ennreal)) -> has_to_string (normed_comm_ring (option ennreal)) -> Prop) : is_symm (has_to_string (normed_comm_ring (option ennreal))) h0 := sorry --non-trivial
lemma new_lemma_57286 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) pos) : @sequential_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_57287 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (generalized_boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_57288 (h0 : uniform_space (complete_distrib_lattice congr_arg_kind)) : separated_space (complete_distrib_lattice congr_arg_kind) := sorry --non-trivial
lemma new_lemma_57289 (h0 : functor.add_const (add_monoid (add_comm_monoid environment.implicit_infer_kind)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_57290 (h0 : topological_space (boolean_algebra.core (cancel_monoid environment.implicit_infer_kind))) : loc_path_connected_space (boolean_algebra.core (cancel_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_57291 (h0 : topological_space (boolean_algebra.core (comm_group name))) : discrete_topology (boolean_algebra.core (comm_group name)) := sorry --non-trivial
lemma new_lemma_57292 (h0 : functor.add_const (topological_space (complete_distrib_lattice unsigned)) Type) : @locally_compact_space.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (complete_distrib_lattice.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_57293 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (preorder num)) := sorry --non-trivial
lemma new_lemma_57294 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @path_connected_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_57295 (h1 : ring (normed_field reducibility_hints)) : rank_condition (normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_57296 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) (boolean_algebra name)) : @totally_disconnected_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) (boolean_algebra.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_57297 (h0 : group (add_cancel_monoid congr_arg_kind)) : is_cyclic (add_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_57298 (h0 : finset (linear_ordered_field (option unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_57299 (h0 : ring (non_unital_non_assoc_semiring linarith.ineq)) : rank_condition (non_unital_non_assoc_semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_57300 (h0 : topological_space (linear_ordered_comm_ring num)) : t1_space (linear_ordered_comm_ring num) := sorry --non-trivial
lemma new_lemma_57301 (h0 : list (omega_complete_partial_order (option (option empty)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_57302 (h0 : group (normed_group (has_inv linarith.comp_source))) : is_cyclic (normed_group (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_57303 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_bot.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_57304 (h0 : functor.add_const (topological_space (semigroup unsigned)) linarith.comp) : @locally_compact_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_57305 (h0 : functor.add_const (functor.add_const (function.extfun Type ordered_comm_monoid) Type) (has_pos_part pos)) : @has_exists_mul_of_le.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) Type (@functor.add_const.run.{1 0} (functor.add_const.{1 1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) Type) (has_pos_part.{0} pos) h0)) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_57306 (h0 : semiring (id unsigned)) : is_noetherian_ring (id unsigned) := sorry --non-trivial
lemma new_lemma_57307 (h0 : complete_lattice (has_nnnorm (mul_one_class environment.projection_info))) : complete_lattice.is_Sup_finite_compact (has_nnnorm (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_57308 (h0 : topological_space (add_comm_monoid (has_add pos))) : normal_space (add_comm_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_57309 (h0 : functor.add_const (ring (has_neg_part Type)) (boolean_algebra environment.implicit_infer_kind)) : @strong_rank_condition.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_neg_part.{1} Type)) (boolean_algebra.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_57310 (h0 : uniform_space (add_group num)) : complete_space (add_group num) := sorry --non-trivial
lemma new_lemma_57311 (h0 : ring (has_nndist (boolean_algebra (has_add (comm_group name))))) : is_domain (has_nndist (boolean_algebra (has_add (comm_group name)))) := sorry --non-trivial
lemma new_lemma_57312 (h0 : topological_space (sub_neg_monoid (has_neg (has_Inf name)))) : loc_path_connected_space (sub_neg_monoid (has_neg (has_Inf name))) := sorry --non-trivial
lemma new_lemma_57313 (h1 : topological_space (random_gen linarith.comp)) : locally_compact_space (random_gen linarith.comp) := sorry --non-trivial
lemma new_lemma_57314 (h0 : topological_space (has_add (option name))) : normal_space (has_add (option name)) := sorry --non-trivial
lemma new_lemma_57315 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) name) : @topological_space.separable_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_57316 (h0 : functor.add_const (function.extfun Type topological_space) real) : @path_connected_space.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) real h0) (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_57317 (h0 : has_lt (distrib (mul_one_class linarith.ineq))) : no_max_order (distrib (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_57318 (h0 : topological_space (pseudo_metric_space (option (option unsigned)))) : normal_space (pseudo_metric_space (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_57319 (h0 : semigroup (comm_group (has_add (comm_group (comm_group unsigned))))) (h1 : function.extfun Type filter) : @t1_space.{0} (semigroup.{0} (comm_group.{0} (has_add.{0} (comm_group.{0} (comm_group.{0} unsigned))))) (@nhds_adjoint.{0} (semigroup.{0} (comm_group.{0} (has_add.{0} (comm_group.{0} (comm_group.{0} unsigned))))) h0 (@function.extfun_app.{2 1} Type filter.{0} h1 (semigroup.{0} (comm_group.{0} (has_add.{0} (comm_group.{0} (comm_group.{0} unsigned)))))))  := sorry --non-trivial
lemma new_lemma_57320 (h0 : functor.add_const (list (normed_comm_ring Type)) (has_neg pos)) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_57321 (h0 : topological_space (complete_distrib_lattice num)) : irreducible_space (complete_distrib_lattice num) := sorry --non-trivial
lemma new_lemma_57322 (h0 : group (has_emptyc (with_bot congr_arg_kind))) : is_cyclic (has_emptyc (with_bot congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_57323 (h0 : ordered_comm_monoid (generalized_boolean_algebra Type)) : has_exists_mul_of_le (generalized_boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_57324 (h0 : function.extfun Type topological_space) : @normal_space.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_57325 (h2 : set (nondiscrete_normed_field (mul_one_class environment.projection_info))) : set.finite h2 := sorry --non-trivial
lemma new_lemma_57326 (h0 : functor.add_const (finset (add_comm_monoid environment.implicit_infer_kind)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_57327 (h0 : ring (complete_linear_order (semiring (semiring (semiring unsigned))))) : is_principal_ideal_ring (complete_linear_order (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_57328 (h0 : topological_space (topological_space (random_gen linarith.ineq))) : totally_disconnected_space (topological_space (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_57329 (h0 : functor.add_const (topological_space (ring Type)) (boolean_algebra Type)) : @totally_disconnected_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ring.{1} Type)) (boolean_algebra.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_57330 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_Inf.{0} real) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_Inf.{0} real))  := sorry --non-trivial
lemma new_lemma_57331 (h1 : group (metric_space string_imp)) : is_cyclic (metric_space string_imp) := sorry --non-trivial
lemma new_lemma_57332 (h0 : plift (non_assoc_semiring empty) -> plift (non_assoc_semiring empty) -> Prop) : is_strict_order (plift (non_assoc_semiring empty)) h0 := sorry --non-trivial
lemma new_lemma_57333 (h1 : set (add_cancel_comm_monoid char)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_57334 (h0 : monoid ennreal) : monoid.fg ennreal := sorry --non-trivial
lemma new_lemma_57335 (h0 : semiring (has_add (has_to_string name))) : is_noetherian_ring (has_add (has_to_string name)) := sorry --non-trivial
lemma new_lemma_57336 (h1 : ring (mul_one_class (mul_one_class std_gen))) : strong_rank_condition (mul_one_class (mul_one_class std_gen)) := sorry --non-trivial
lemma new_lemma_57337 (h0 : monoid (add_cancel_monoid (has_neg (has_neg (has_add linarith.comp))))) : monoid.fg (add_cancel_monoid (has_neg (has_neg (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_57338 (h0 : group (with_one (has_ssubset to_additive.value_type))) : group.fg (with_one (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_57339 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_57340 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_57341 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (cancel_monoid environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_57342 (h0 : topological_space (bin_tree (semiring (semiring empty)))) : normal_space (bin_tree (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_57343 (h0 : fin has_zero.zero) : @is_atomistic.{0} (has_pos_part.{0} name) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_pos_part.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_57344 (h0 : functor.add_const (topological_space (has_neg_part ennreal)) pos) : @totally_disconnected_space.{0} (has_neg_part.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_57345 (h0 : ring (normed_comm_ring (has_Inf linarith.comp))) : rank_condition (normed_comm_ring (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_57346 (h0 : uniform_space (non_unital_non_assoc_semiring (mul_one_class (mul_one_class reducibility_hints)))) : complete_space (non_unital_non_assoc_semiring (mul_one_class (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_57347 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring environment.implicit_infer_kind)) name) : @sequential_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_57348 (h0 : functor.add_const (function.extfun (Type 1) group) linarith.comp) : @group.fg.{1} Type (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) linarith.comp h0) Type)  := sorry --non-trivial
lemma new_lemma_57349 (h0 : topological_space (normed_comm_ring pos)) : preconnected_space (normed_comm_ring pos) := sorry --non-trivial
lemma new_lemma_57350 (h0 : add_group (canonically_ordered_monoid (has_Inf real))) : is_add_cyclic (canonically_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_57351 (h0 : complete_lattice (has_compl (random_gen string_imp))) : is_compactly_generated (has_compl (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_57352 (h0 : topological_space (has_nndist (has_to_string (has_to_string pos)))) : path_connected_space (has_nndist (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_57353 (h0 : function.extfun Type topological_space) : @t1_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_57354 (h0 : functor.add_const (add_group (add_cancel_monoid unsigned)) Type) : @is_add_cyclic.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 1} (add_group.{0} (add_cancel_monoid.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_57355 (h0 : fin has_zero.zero) : @totally_disconnected_space.{0} (simple_graph.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (simple_graph.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_57356 (h0 : functor.add_const (ordered_comm_monoid (normed_comm_ring name)) pos) : @has_exists_mul_of_le.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (normed_comm_ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_57357 (h0 : topological_space (group_with_zero num)) : totally_disconnected_space (group_with_zero num) := sorry --non-trivial
lemma new_lemma_57358 (h0 : ring (has_append (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq))))) : rank_condition (has_append (has_nnnorm (has_nnnorm (has_nnnorm linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_57359 (h0 : topological_space (id (linear_ordered_semiring num))) : totally_disconnected_space (id (linear_ordered_semiring num)) := sorry --non-trivial
lemma new_lemma_57360 (h0 : topological_space (pseudo_metric_space unsigned)) : regular_space (pseudo_metric_space unsigned) := sorry --non-trivial
lemma new_lemma_57361 (h0 : group (simple_graph (has_to_string (ring Type)))) : group.fg (simple_graph (has_to_string (ring Type))) := sorry --non-trivial
lemma new_lemma_57362 (h0 : functor.add_const (add_group pos) (option unsigned)) : @is_add_cyclic.{0} pos (@functor.add_const.run.{0 0} (add_group.{0} pos) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_57363 (h0 : function.extfun (Type 1) ordered_comm_monoid) : @has_exists_mul_of_le.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} h0 (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_57364 (h0 : functor.add_const (list (ordered_ring empty)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_57365 (h0 : topological_space (finset (has_Inf linarith.comp))) : irreducible_space (finset (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_57366 (h0 : not (ring (partial_order num) -> false)) : @strong_rank_condition.{0} (partial_order.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (partial_order.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_57367 (h3 : ring (has_div linarith.comp_source)) : is_domain (has_div linarith.comp_source) := sorry --non-trivial
lemma new_lemma_57368 (h0 : topological_space (finset (finset (has_add pos)))) : totally_disconnected_space (finset (finset (has_add pos))) := sorry --non-trivial
lemma new_lemma_57369 (h0 : list (has_edist (semiring unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_57370 (h0 : functor.add_const (group (cancel_monoid name)) linarith.comp) : @normalizer_condition.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_57371 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_principal_ideal_ring.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_57372 (h0 : filter (cancel_monoid (add_comm_monoid (comm_group (add_comm_monoid unsigned))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_57373 (h1 : ring (has_emptyc num)) : is_domain (has_emptyc num) := sorry --non-trivial
lemma new_lemma_57374 (h0 : topological_space (ring (has_pos_part (has_Inf real)))) : totally_disconnected_space (ring (has_pos_part (has_Inf real))) := sorry --non-trivial
lemma new_lemma_57375 (h0 : list (distrib_lattice string_imp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_57376 (h0 : add_monoid (comm_group (has_neg name))) : add_monoid.fg (comm_group (has_neg name)) := sorry --non-trivial
lemma new_lemma_57377 (h0 : complete_lattice (add_cancel_comm_monoid congr_arg_kind)) : is_atomistic (add_cancel_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_57378 (h0 : topological_space (distrib_lattice (random_gen (has_top linarith.comp_source)))) : t0_space (distrib_lattice (random_gen (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_57379 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_57380 (h0 : topological_space (has_star congr_arg_kind)) : loc_path_connected_space (has_star congr_arg_kind) := sorry --non-trivial
lemma new_lemma_57381 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_star.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_star.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_57382 (h0 : complete_lattice (random_gen (has_top (has_top num)))) : complete_lattice.is_Sup_finite_compact (random_gen (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_57383 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_57384 (h0 : topological_space (simple_graph (has_add linarith.comp))) : locally_compact_space (simple_graph (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_57385 (h0 : filter (add_cancel_monoid (ring Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_57386 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) linarith.comp) : @t0_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_57387 (h0 : monoid (linear_order empty)) : monoid.fg (linear_order empty) := sorry --non-trivial
lemma new_lemma_57388 (h0 : list (left_cancel_monoid (semiring empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_57389 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (@id.{2} Type (with_bot.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type (with_bot.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_57390 (h0 : function.extfun Type topological_space) : @normal_space.{0} (normed_linear_ordered_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_linear_ordered_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_57391 (h0 : add_group (boolean_algebra (semigroup environment.implicit_infer_kind))) : is_add_cyclic (boolean_algebra (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_57392 (h0 : function.extfun (normed_group (denumerable string_imp)) (fun (x : normed_group (denumerable string_imp)), Prop)) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) (normed_group.{0} (denumerable.{0} string_imp)) (@function.extfun_app.{1 1} (normed_group.{0} (denumerable.{0} string_imp)) (λ (x : normed_group.{0} (denumerable.{0} string_imp)), Prop) h0)  := sorry --non-trivial
lemma new_lemma_57393 (h0 : list (left_cancel_monoid empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_57394 (h0 : not (monoid (normed_group linarith.comp_source) -> false)) : @monoid.fg.{0} (normed_group.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (monoid.{0} (normed_group.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_57395 (h0 : set (lattice enat)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_57396 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg pos)) : @preconnected_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{0} pos) h0) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_57397 (h0 : group (has_emptyc (has_norm (has_top linarith.ineq)))) : normalizer_condition (has_emptyc (has_norm (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_57398 (h0 : ring (has_norm (random_gen (has_inv linarith.ineq)))) : rank_condition (has_norm (random_gen (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_57399 (h0 : uniform_space (semiring (has_norm (has_norm linarith.comp_source)))) : complete_space (semiring (has_norm (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_57400 (h0 : topological_space real.angle) : locally_compact_space real.angle := sorry --non-trivial
lemma new_lemma_57401 (h0 : not (add_group (complete_semilattice_Sup unsigned) -> false)) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} unsigned) (@classical.by_contradiction'.{1} (add_group.{0} (complete_semilattice_Sup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_57402 (h0 : functor.add_const (list (ring unsigned)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_57403 (h0 : topological_space (denumerable (has_nnnorm (has_nnnorm (random_gen linarith.ineq))))) : t0_space (denumerable (has_nnnorm (has_nnnorm (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_57404 (h0 : topological_space (linear_ordered_comm_ring (semiring empty))) : totally_separated_space (linear_ordered_comm_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_57405 (h0 : functor.add_const (complete_lattice (ordered_cancel_add_comm_monoid empty)) congr_arg_kind) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_cancel_add_comm_monoid.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_57406 (h0 : set (mul_one_class (add_comm_semigroup (mul_one_class (mul_one_class ereal))))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_57407 (h0 : functor.add_const (list (boolean_algebra linarith.comp)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_57408 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (with_one.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (with_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_57409 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (distrib_lattice.{0} linarith.ineq) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (distrib_lattice.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_57410 (h0 : functor.add_const (topological_space (normed_comm_ring empty)) unsigned) : @loc_path_connected_space.{0} (normed_comm_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_57411 (h0 : ring (has_ssubset (mul_one_class (mul_one_class environment.projection_info)))) : rank_condition (has_ssubset (mul_one_class (mul_one_class environment.projection_info))) := sorry --non-trivial
lemma new_lemma_57412 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_57413 (h0 : functor.add_const (topological_space (ordered_cancel_add_comm_monoid empty)) unsigned) : @locally_compact_space.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_cancel_add_comm_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_57414 (h0 : function.extfun Type group) : @group.fg.{0} (encodable.{0} char) (@function.extfun_app.{2 1} Type group.{0} h0 (encodable.{0} char))  := sorry --non-trivial
lemma new_lemma_57415 (h0 : topological_space string.iterator_imp) (h1 : add_group string.iterator_imp) : topological_add_group string.iterator_imp := sorry --non-trivial
lemma new_lemma_57416 (h0 : group (distrib_lattice (has_nnnorm (has_nnnorm fun_info)))) : group.fg (distrib_lattice (has_nnnorm (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_57417 (h0 : functor.add_const (ring (has_add linarith.comp)) (has_Inf (has_Inf linarith.comp))) : @strong_rank_condition.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} linarith.comp)) (has_Inf.{0} (has_Inf.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_57418 (h0 : functor.add_const (topological_space (semiring congr_arg_kind)) (semiring num)) : @locally_compact_space.{0} (semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} congr_arg_kind)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_57419 (h1 : function.extfun Type ring) : @strong_rank_condition.{0} (linear_ordered_add_comm_group.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} h1 (linear_ordered_add_comm_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_57420 (h1 : topological_space (linear_ordered_comm_group_with_zero std_gen)) : totally_disconnected_space (linear_ordered_comm_group_with_zero std_gen) := sorry --non-trivial
lemma new_lemma_57421 (h0 : functor.comp group canonically_ordered_comm_semiring Type) : @normalizer_condition.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.comp.run.{1 1 1} group.{1} canonically_ordered_comm_semiring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_57422 (h1 : complete_lattice (fintype char)) : is_compactly_generated (fintype char) := sorry --non-trivial
lemma new_lemma_57423 (h0 : topological_space (finset (has_to_string (has_add (finset name))))) : totally_disconnected_space (finset (has_to_string (has_add (finset name)))) := sorry --non-trivial
lemma new_lemma_57424 (h2 : topological_space (add_group_with_zero_nhd (denumerable char))) : totally_disconnected_space (add_group_with_zero_nhd (denumerable char)) := sorry --non-trivial
lemma new_lemma_57425 (h0 : functor.add_const (ring (bin_tree empty)) unsigned) : @rank_condition.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (bin_tree.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_57426 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_57427 (h0 : functor.add_const (topological_space (has_nndist empty)) num) : @topological_space.separable_space.{0} (has_nndist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_57428 (h0 : uniform_space (normed_field reducibility_hints)) : complete_space (normed_field reducibility_hints) := sorry --non-trivial
lemma new_lemma_57429 (h1 : filter (has_ssubset (random_gen char))) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_57430 (h0 : topological_space (canonically_ordered_comm_semiring (has_add (has_add (ring (finset Type)))))) : sequential_space (canonically_ordered_comm_semiring (has_add (has_add (ring (finset Type))))) := sorry --non-trivial
lemma new_lemma_57431 (h0 : topological_space (canonically_ordered_comm_semiring (finset name))) : preirreducible_space (canonically_ordered_comm_semiring (finset name)) := sorry --non-trivial
lemma new_lemma_57432 (h0 : topological_space (has_neg_part Type)) : locally_compact_space (has_neg_part Type) := sorry --non-trivial
lemma new_lemma_57433 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_57434 (h0 : function.extfun (Type 1) group) : @is_simple_group.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_57435 (h0 : not (topological_space (id linarith.comp) -> false)) : @t0_space.{0} (@id.{2} Type linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_57436 (h0 : not (topological_space (complete_linear_order congr_arg_kind) -> false)) : @discrete_topology.{0} (complete_linear_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_linear_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_57437 (h0 : functor.add_const (complete_lattice (comm_group Type)) Type) : @complete_lattice.is_Sup_finite_compact.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (comm_group.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_57438 (h0 : topological_space (distrib_lattice (comm_ring char))) : path_connected_space (distrib_lattice (comm_ring char)) := sorry --non-trivial
lemma new_lemma_57439 (h0 : add_monoid (has_neg_part name)) : add_monoid.fg (has_neg_part name) := sorry --non-trivial
lemma new_lemma_57440 (h0 : functor.add_const (semiring (left_cancel_semigroup unsigned)) unsigned) : @is_noetherian_ring.{0} (left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (left_cancel_semigroup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_57441 (h0 : fin has_zero.zero) : @monoid.fg.{0} (boolean_algebra.core.{0} name) (@matrix.vec_empty.{0} (monoid.{0} (boolean_algebra.core.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_57442 (h0 : functor.add_const (function.extfun Type ring) Type) : @rank_condition.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_57443 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_57444 (h0 : ordered_comm_monoid (sub_neg_monoid (has_Inf pos))) : has_exists_mul_of_le (sub_neg_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_57445 (h0 : not (function.extfun Type uniform_space -> false)) : @separated_space.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_57446 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @preconnected_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_57447 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_zero (ring pos))) := sorry --non-trivial
lemma new_lemma_57448 (h0 : topological_space (has_nndist (option name))) : discrete_topology (has_nndist (option name)) := sorry --non-trivial
lemma new_lemma_57449 (h0 : ring (denumerable (random_gen char))) : is_domain (denumerable (random_gen char)) := sorry --non-trivial
lemma new_lemma_57450 (h0 : ring (has_neg Type)) : strong_rank_condition (has_neg Type) := sorry --non-trivial
lemma new_lemma_57451 (h0 : ring (has_emptyc (has_norm num))) : is_domain (has_emptyc (has_norm num)) := sorry --non-trivial
lemma new_lemma_57452 (h0 : functor.add_const (filter (generalized_boolean_algebra (boolean_algebra.core linarith.comp))) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_57453 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_57454 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_57455 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_dist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_57456 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (random_gen.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} empty))  := sorry --non-trivial
lemma new_lemma_57457 (h0 : functor.add_const (group (ordered_ring empty)) (semiring (semiring num))) : @normalizer_condition.{0} (ordered_ring.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (ordered_ring.{0} empty)) (semiring.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_57458 (h0 : group (complete_semilattice_Sup (set.set_semiring linarith.ineq))) : is_cyclic (complete_semilattice_Sup (set.set_semiring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_57459 (h0 : topological_space (ordered_comm_ring (ring (has_nndist Type)))) : preirreducible_space (ordered_comm_ring (ring (has_nndist Type))) := sorry --non-trivial
lemma new_lemma_57460 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_57461 (h0 : function.extfun (finset Type) (has_mem.mem (with_one linarith.comp_source))) : @path_connected_space.{0} (with_one.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_57462 (h0 : complete_lattice (random_gen (comm_ring reducibility_hints))) : is_compactly_generated (random_gen (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_57463 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_57464 (h0 : uniform_space (normed_lattice_add_comm_group (has_Inf (has_add (has_add real))))) : separated_space (normed_lattice_add_comm_group (has_Inf (has_add (has_add real)))) := sorry --non-trivial
lemma new_lemma_57465 (h0 : functor.add_const (group (ring environment.implicit_infer_kind)) environment.implicit_infer_kind) : @is_cyclic.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_57466 (h0 : cancel_comm_monoid_with_zero (finset empty)) : unique_factorization_monoid (finset empty) := sorry --non-trivial
lemma new_lemma_57467 (h0 : not (complete_lattice (normed_group to_additive.value_type) -> false)) : @is_compactly_generated.{0} (normed_group.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (normed_group.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_57468 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_57469 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_57470 (h0 : ereal) : set.sInter is_open h0 := sorry --non-trivial
lemma new_lemma_57471 (h0 : list (has_add (normed_comm_ring name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_57472 (h0 : add_monoid (with_bot fun_info)) : add_monoid.fg (with_bot fun_info) := sorry --non-trivial
lemma new_lemma_57473 (h0 : group (cancel_monoid (finset Type))) : group.fg (cancel_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_57474 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_57475 (h1 : not (uniform_space (has_emptyc congr_arg_kind) -> false)) : @complete_space.{0} (has_emptyc.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_emptyc.{0} congr_arg_kind)) h1)  := sorry --non-trivial
lemma new_lemma_57476 (h0 : uniform_space (mul_zero_class (finset (finset environment.implicit_infer_kind)))) : complete_space (mul_zero_class (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_57477 (h0 : functor.add_const (semiring (sub_neg_monoid real)) real) : @is_noetherian_ring.{0} (sub_neg_monoid.{0} real) (@functor.add_const.run.{0 0} (semiring.{0} (sub_neg_monoid.{0} real)) real h0)  := sorry --non-trivial
lemma new_lemma_57478 (h0 : functor.add_const (group (has_to_string unsigned)) environment.implicit_infer_kind) : @group.fg.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_57479 (h0 : monoid (mul_zero_class (finset name))) : monoid.fg (mul_zero_class (finset name)) := sorry --non-trivial
lemma new_lemma_57480 (h0 : function.extfun nat fin) : @is_principal_ideal_ring.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ring.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_57481 (h0 : functor.add_const (finset (left_cancel_monoid empty)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_57482 (h0 : functor.add_const (filter (has_add Type)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_57483 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (normed_group.{0} char) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_group.{0} char))  := sorry --non-trivial
lemma new_lemma_57484 (h0 : complete_lattice (as_linear_order (option (option (option (option unsigned)))))) : is_atomistic (as_linear_order (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_57485 (h1 : group (normed_field linarith.comp_source)) : is_cyclic (normed_field linarith.comp_source) := sorry --non-trivial
lemma new_lemma_57486 (h0 : ring (non_unital_non_assoc_semiring linarith.comp_source)) : rank_condition (non_unital_non_assoc_semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_57487 (h0 : cancel_comm_monoid_with_zero (add_comm_monoid ennreal)) : unique_factorization_monoid (add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_57488 (h0 : has_emptyc (has_inv linarith.comp_source) -> Prop) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) (has_emptyc.{0} (has_inv.{0} linarith.comp_source)) h0  := sorry --non-trivial
lemma new_lemma_57489 (h0 : function.extfun (Type 1) topological_space) : @normal_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_57490 (h0 : group (has_norm congr_arg_kind)) : group.fg (has_norm congr_arg_kind) := sorry --non-trivial
lemma new_lemma_57491 (h0 : group (has_dist (option unsigned))) : is_cyclic (has_dist (option unsigned)) := sorry --non-trivial
lemma new_lemma_57492 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_57493 (h0 : uniform_space (simple_graph (has_ssubset string.iterator_imp))) : complete_space (simple_graph (has_ssubset string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_57494 (h0 : filter (finset (has_add ennreal))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_57495 (h0 : not (group (has_union num) -> false)) : @is_cyclic.{0} (has_union.{0} num) (@classical.by_contradiction'.{1} (group.{0} (has_union.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_57496 (h0 : function.extfun Type group) : @is_simple_group.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_57497 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (has_inner.{0 0} empty empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (has_inner.{0 0} empty empty))  := sorry --non-trivial
lemma new_lemma_57498 (h0 : function.extfun (Type 1) filter) : countable_Inter_filter (function.extfun_app h0 (ring Type)) := sorry --non-trivial
lemma new_lemma_57499 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_57500 (h4 : filter (div_inv_monoid (random_gen (random_gen to_additive.value_type)))) : filter.ne_bot h4 := sorry --non-trivial
lemma new_lemma_57501 (h0 : function.extfun Type (functor.add_const (filter auto.case_option))) : filter.ne_bot (functor.add_const.run (function.extfun_app h0 unsigned)) := sorry --non-trivial
lemma new_lemma_57502 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_57503 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (omega_complete_partial_order congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_57504 (h0 : functor.add_const (topological_space (boolean_algebra (ring (add_comm_monoid pos)))) name) : @t1_space.{0} (boolean_algebra.{0} (ring.{0} (add_comm_monoid.{0} pos))) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} (ring.{0} (add_comm_monoid.{0} pos)))) name h0)  := sorry --non-trivial
lemma new_lemma_57505 (h1 : topological_space (semiring num)) : totally_disconnected_space (semiring num) := sorry --non-trivial
lemma new_lemma_57506 (h0 : topological_space (has_to_string (finset name))) : locally_compact_space (has_to_string (finset name)) := sorry --non-trivial
lemma new_lemma_57507 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (canonically_ordered_comm_semiring empty)) := sorry --non-trivial
lemma new_lemma_57508 (h2 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h2) (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_57509 (h0 : group (linear_order (semiring empty))) : is_cyclic (linear_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_57510 (h0 : topological_space (linear_ordered_cancel_comm_monoid unsigned)) : loc_path_connected_space (linear_ordered_cancel_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_57511 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (add_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_57512 (h0 : topological_space (with_bot (semiring empty))) : totally_disconnected_space (with_bot (semiring empty)) := sorry --non-trivial
lemma new_lemma_57513 (h0 : complete_lattice (has_pos_part (has_Inf real))) : complete_lattice.is_Sup_finite_compact (has_pos_part (has_Inf real)) := sorry --non-trivial
lemma new_lemma_57514 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_57515 (h0 : topological_space (semigroup (semigroup ennreal))) : path_connected_space (semigroup (semigroup ennreal)) := sorry --non-trivial
lemma new_lemma_57516 (h0 : topological_space (has_nndist (comm_group pos))) : path_connected_space (has_nndist (comm_group pos)) := sorry --non-trivial
lemma new_lemma_57517 (h0 : ring (with_zero (random_gen linarith.comp_source))) : strong_rank_condition (with_zero (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_57518 (h0 : monoid (with_one (random_gen (random_gen linarith.comp_source)))) : monoid.fg (with_one (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_57519 (h0 : uniform_space (boolean_algebra.core (add_comm_monoid linarith.comp))) : separated_space (boolean_algebra.core (add_comm_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_57520 (h0 : functor.add_const (monoid (finset pos)) linarith.comp) : @monoid.fg.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (finset.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_57521 (h0 : topological_space (normed_comm_ring pos)) : totally_separated_space (normed_comm_ring pos) := sorry --non-trivial
lemma new_lemma_57522 (h0 : topological_space (has_to_string (has_add linarith.comp))) : locally_compact_space (has_to_string (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_57523 (h0 : function.extfun Type (functor.add_const (uniform_space (has_Sup congr_arg_kind)))) : @complete_space.{0} (has_Sup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_Sup.{0} congr_arg_kind)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (has_Sup.{0} congr_arg_kind))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_57524 (h0 : topological_space (has_one unsigned)) : discrete_topology (has_one unsigned) := sorry --non-trivial
lemma new_lemma_57525 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (ordered_cancel_add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_57526 (h0 : ordered_add_comm_monoid (boolean_algebra unsigned)) : archimedean (boolean_algebra unsigned) := sorry --non-trivial
lemma new_lemma_57527 (h0 : monoid (finset (has_neg linarith.comp))) : monoid.fg (finset (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_57528 (h0 : functor.add_const (topological_space znum) unsigned) : @normal_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) unsigned h0)  := sorry --non-trivial
lemma new_lemma_57529 (h1 : ring (non_unital_non_assoc_semiring linarith.ineq)) : is_domain (non_unital_non_assoc_semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_57530 (h0 : topological_space (normed_comm_ring (option congr_arg_kind))) : path_connected_space (normed_comm_ring (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_57531 (h0 : topological_space (comm_group (has_nndist environment.implicit_infer_kind))) : t1_space (comm_group (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_57532 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (topological_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (topological_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_57533 (h0 : ring (boolean_algebra.core (finset (has_Inf linarith.comp)))) : is_domain (boolean_algebra.core (finset (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_57534 (h0 : functor.add_const (list (ordered_comm_ring pos)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_57535 (h1 : topological_space (has_nnnorm (random_gen (has_nnnorm linarith.ineq)))) : totally_disconnected_space (has_nnnorm (random_gen (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_57536 (h0 : ordered_comm_monoid enat) : has_exists_mul_of_le enat := sorry --non-trivial
lemma new_lemma_57537 (h0 : topological_space (canonically_ordered_comm_semiring (ring environment.implicit_infer_kind))) : discrete_topology (canonically_ordered_comm_semiring (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_57538 (h0 : filter (has_Inf Type)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_57539 (h0 : functor.add_const (uniform_space (omega_complete_partial_order empty)) empty) : @complete_space.{0} (omega_complete_partial_order.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (omega_complete_partial_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_57540 (h0 : not (has_mem.mem (normed_group congr_arg_kind) has_emptyc.emptyc -> false)) : @is_atomistic.{0} (normed_group.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (normed_group.{0} congr_arg_kind) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} congr_arg_kind) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_57541 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (comm_semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_57542 (h0 : topological_space (has_Inf pos)) : normal_space (has_Inf pos) := sorry --non-trivial
lemma new_lemma_57543 (h0 : add_monoid (has_pos_part linarith.comp)) : add_monoid.fg (has_pos_part linarith.comp) := sorry --non-trivial
lemma new_lemma_57544 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (comm_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_57545 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (canonically_linear_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_57546 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (normed_comm_ring ennreal)) := sorry --non-trivial
lemma new_lemma_57547 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_57548 (h0 : functor.add_const (filter (has_to_string name)) (ring environment.implicit_infer_kind)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_57549 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) pos) : @t1_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_57550 (h0 : add_group (add_comm_monoid name)) : is_add_cyclic (add_comm_monoid name) := sorry --non-trivial
lemma new_lemma_57551 (h0 : group (normed_group (random_gen congr_arg_kind))) : normalizer_condition (normed_group (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_57552 (h0 : functor.add_const (finset (plift empty)) (semiring empty)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_57553 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_57554 (h0 : add_monoid (canonically_linear_ordered_monoid (mul_zero_class (mul_zero_class name)))) : add_monoid.fg (canonically_linear_ordered_monoid (mul_zero_class (mul_zero_class name))) := sorry --non-trivial
lemma new_lemma_57555 (h0 : functor.add_const (ordered_add_comm_monoid (has_nndist environment.implicit_infer_kind)) Type) : @archimedean.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (has_nndist.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_57556 (h0 : complete_lattice (complete_linear_order congr_arg_kind)) : is_atomistic (complete_linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_57557 (h0 : topological_space (complete_semilattice_Sup (has_norm linarith.comp))) : preirreducible_space (complete_semilattice_Sup (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_57558 (h0 : ring (ordered_cancel_add_comm_monoid (option ennreal))) : rank_condition (ordered_cancel_add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_57559 (h0 : monoid (has_union (semiring congr_arg_kind))) : monoid.fg (has_union (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_57560 (h0 : ring (dlist (has_nnnorm linarith.comp_source))) : rank_condition (dlist (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_57561 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (encodable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (encodable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_57562 (h0 : ring (add_cancel_monoid (finset Type))) : is_principal_ideal_ring (add_cancel_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_57563 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) environment.implicit_infer_kind) : @t0_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_57564 (h0 : add_group (has_one (has_norm (has_top (has_top linarith.comp))))) : is_add_cyclic (has_one (has_norm (has_top (has_top linarith.comp)))) := sorry --non-trivial
lemma new_lemma_57565 (h0 : function.extfun Type topological_space) : @t0_space.{0} (linear_ordered_semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_57566 (h0 : topological_space (mul_zero_class (has_to_string name))) : normal_space (mul_zero_class (has_to_string name)) := sorry --non-trivial
lemma new_lemma_57567 (h0 : functor.add_const (topological_space (has_neg Type)) Type) : @path_connected_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_neg.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_57568 (h0 : function.extfun nat fin) : @normalizer_condition.{0} (simple_graph.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (simple_graph.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_57569 (h1 : ring (denumerable to_additive.value_type)) : strong_rank_condition (denumerable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_57570 (h0 : complete_lattice (is_R_or_C num)) : is_atomistic (is_R_or_C num) := sorry --non-trivial
lemma new_lemma_57571 (h0 : has_lift_t ereal Prop) (h1 : ereal) : @lift_t.{1 1} ereal Prop h0 h1  := sorry --non-trivial
lemma new_lemma_57572 (h0 : monoid (linear_ordered_semiring (semiring (semiring unsigned)))) : monoid.fg (linear_ordered_semiring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_57573 (h0 : group (has_neg (finset pos))) : is_simple_group (has_neg (finset pos)) := sorry --non-trivial
lemma new_lemma_57574 (h0 : topological_space (comm_monoid empty)) : irreducible_space (comm_monoid empty) := sorry --non-trivial
lemma new_lemma_57575 (h0 : functor.add_const (finset (has_nndist unsigned)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_57576 (h0 : not (uniform_space (simple_graph string.iterator_imp) -> false)) : @complete_space.{0} (simple_graph.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (uniform_space.{0} (simple_graph.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_57577 (h0 : topological_space (has_Inf (has_Inf real))) : sequential_space (has_Inf (has_Inf real)) := sorry --non-trivial
lemma new_lemma_57578 (h0 : functor.add_const (uniform_space (has_add linarith.comp)) Type) : @separated_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_add.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_57579 (h0 : topological_space (id ennreal)) : discrete_topology (id ennreal) := sorry --non-trivial
lemma new_lemma_57580 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @path_connected_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) Type)  := sorry --non-trivial
lemma new_lemma_57581 (h0 : functor.add_const (list (semigroup Type)) (normed_comm_ring (add_comm_monoid Type))) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_57582 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_57583 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (measurable_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_57584 (h0 : uniform_space (id empty)) : separated_space (id empty) := sorry --non-trivial
lemma new_lemma_57585 (h0 : topological_space (has_pos_part real)) : regular_space (has_pos_part real) := sorry --non-trivial
lemma new_lemma_57586 (h0 : topological_space (has_add (has_add (has_add (has_Inf linarith.comp))))) : preconnected_space (has_add (has_add (has_add (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_57587 (h0 : uniform_space (has_nndist (has_to_string (has_neg_part Type)))) : separated_space (has_nndist (has_to_string (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_57588 (h0 : functor.add_const (topological_space (has_Inf name)) Type) : @preirreducible_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_57589 (h0 : functor.add_const (topological_space (simple_graph pos)) (ring (ring Type))) : @preconnected_space.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (simple_graph.{0} pos)) (ring.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_57590 (h0 : complete_lattice (encodable (random_gen linarith.ineq))) : complete_lattice.is_Sup_finite_compact (encodable (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_57591 (h0 : ordered_comm_monoid (has_to_string (ring name))) : has_exists_mul_of_le (has_to_string (ring name)) := sorry --non-trivial
lemma new_lemma_57592 (h0 : topological_space (comm_semigroup (has_neg real))) : preirreducible_space (comm_semigroup (has_neg real)) := sorry --non-trivial
lemma new_lemma_57593 (h0 : uniform_space (with_one (has_norm (semiring linarith.comp)))) : separated_space (with_one (has_norm (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_57594 (h0 : functor.add_const (topological_space (finset ennreal)) num) : @preconnected_space.{0} (finset.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_57595 (h1 : add_group (add_monoid string_imp)) : is_add_cyclic (add_monoid string_imp) := sorry --non-trivial
lemma new_lemma_57596 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) environment.implicit_infer_kind) : @normal_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_57597 (h0 : functor.add_const (topological_space (ring Type)) (has_neg Type)) : @loc_path_connected_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ring.{1} Type)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_57598 (h0 : uniform_space (ring (option ennreal))) : separated_space (ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_57599 (h0 : functor.add_const (topological_space (has_zero pos)) unsigned) : @sequential_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_57600 (h0 : group (has_norm num)) (h1 : group (group_topology (has_norm num))) : normalizer_condition (group_topology (has_norm num)) := sorry --non-trivial
lemma new_lemma_57601 (h5 : ring (non_unital_non_assoc_semiring string_imp)) : rank_condition (non_unital_non_assoc_semiring string_imp) := sorry --non-trivial
lemma new_lemma_57602 (h0 : topological_space (linear_ordered_add_comm_group (has_inv linarith.ineq))) : path_connected_space (linear_ordered_add_comm_group (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_57603 (h0 : functor.add_const (topological_space (has_star empty)) num) : @t0_space.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_57604 (h0 : add_monoid (has_to_string (finset Type))) : add_monoid.fg (has_to_string (finset Type)) := sorry --non-trivial
lemma new_lemma_57605 (h0 : function.extfun nat fin) : @unique_factorization_monoid.{0} (complete_distrib_lattice.{0} pos) (@matrix.vec_empty.{0} (cancel_comm_monoid_with_zero.{0} (complete_distrib_lattice.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))))  := sorry --non-trivial
lemma new_lemma_57606 (h0 : fin has_zero.zero) : @is_cyclic.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (group.{0} (has_add.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_57607 (h0 : functor.add_const (topological_space (has_neg pos)) linarith.comp) : @locally_compact_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_57608 (h0 : topological_space (random_gen (has_top to_additive.value_type))) : locally_compact_space (random_gen (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_57609 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_57610 (h0 : functor.comp ordered_comm_monoid has_to_string unsigned) : @has_exists_mul_of_le.{0} (has_to_string.{0} unsigned) (@functor.comp.run.{0 0 0} ordered_comm_monoid.{0} has_to_string.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_57611 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_57612 (h0 : not (add_group (has_top string_imp) -> false)) : @is_add_cyclic.{0} (has_top.{0} string_imp) (@classical.by_contradiction'.{1} (add_group.{0} (has_top.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_57613 (h0 : functor.add_const (topological_space (finset linarith.comp)) (has_add pos)) : @totally_disconnected_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_57614 (h0 : uniform_space (random_gen (random_gen (random_gen (random_gen linarith.ineq))))) : complete_space (random_gen (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_57615 (h0 : topological_space (metric_space char)) : t0_space (metric_space char) := sorry --non-trivial
lemma new_lemma_57616 (h0 : group (boolean_algebra.core (option pos))) : normalizer_condition (boolean_algebra.core (option pos)) := sorry --non-trivial
lemma new_lemma_57617 (h0 : functor.comp topological_space canonically_linear_ordered_monoid pos) : @sequential_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_linear_ordered_monoid.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_57618 (h0 : functor.add_const (group (add_comm_monoid linarith.comp)) name) : @normalizer_condition.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_57619 (h0 : not (add_group (simple_graph linarith.ineq) -> false)) : @is_add_cyclic.{0} (simple_graph.{0} linarith.ineq) (@classical.by_contradiction'.{1} (add_group.{0} (simple_graph.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_57620 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_57621 (h0 : functor.add_const (complete_lattice (left_cancel_monoid unsigned)) congr_arg_kind) : @complete_lattice.is_Sup_finite_compact.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_57622 (h0 : functor.add_const (complete_lattice (boolean_algebra Type)) name) : @complete_lattice.is_Sup_finite_compact.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (boolean_algebra.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_57623 (h0 : uniform_space (measurable_space (has_norm empty))) : separated_space (measurable_space (has_norm empty)) := sorry --non-trivial
lemma new_lemma_57624 (h0 : filter (boolean_algebra (has_add name))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_57625 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_57626 (h0 : functor.add_const (ring (normed_comm_ring Type)) name) : @is_principal_ideal_ring.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (normed_comm_ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_57627 (h0 : functor.add_const (functor.add_const (topological_space Type) pos) pos) : @regular_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) pos (@functor.add_const.run.{1 0} (functor.add_const.{1 0} (topological_space.{1} Type) pos) pos h0))  := sorry --non-trivial
lemma new_lemma_57628 (h0 : group (add_cancel_comm_monoid (has_nnnorm (has_append (comm_ring reducibility_hints))))) : is_cyclic (add_cancel_comm_monoid (has_nnnorm (has_append (comm_ring reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_57629 (h0 : functor.add_const (topological_space (semiring unsigned)) unsigned) : @path_connected_space.{0} (semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_57630 (h0 : function.extfun Type uniform_space) : @separated_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type uniform_space.{0} h0 congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_57631 (h0 : functor.add_const (group (canonically_linear_ordered_monoid pos)) name) : @group.fg.{0} (canonically_linear_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (canonically_linear_ordered_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_57632 (h0 : functor.add_const (topological_space (boolean_algebra Type)) (finset (finset pos))) : @t0_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) (finset.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_57633 (h0 : fin has_zero.zero) : @path_connected_space.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (comm_semigroup.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_57634 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_57635 (h2 : ring (distrib (has_nnnorm char))) : is_domain (distrib (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_57636 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) (has_neg Type)) : @t0_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_57637 (h0 : ring (has_add (has_neg name))) : is_principal_ideal_ring (has_add (has_neg name)) := sorry --non-trivial
lemma new_lemma_57638 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) Type) : @totally_separated_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_57639 (h0 : preorder (measurable_space.dynkin_system char)) (h1 : set (measurable_space.dynkin_system char)) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_57640 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (ordered_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_57641 (h0 : complete_lattice (has_zero (comm_group unsigned))) : is_atomistic (has_zero (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_57642 (h0 : topological_space auto.case_option) : normal_space auto.case_option := sorry --non-trivial
lemma new_lemma_57643 (h0 : functor.comp uniform_space finset ennreal) : @complete_space.{0} (finset.{0} ennreal) (@functor.comp.run.{0 0 0} uniform_space.{0} finset.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_57644 (h0 : add_group (metric_space empty)) : is_add_cyclic (metric_space empty) := sorry --non-trivial
lemma new_lemma_57645 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_57646 (h0 : functor.add_const (add_group (canonically_ordered_comm_semiring linarith.comp)) linarith.comp) : @is_add_cyclic.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (canonically_ordered_comm_semiring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_57647 (h0 : topological_space (add_cancel_monoid (has_to_string name))) : normal_space (add_cancel_monoid (has_to_string name)) := sorry --non-trivial
lemma new_lemma_57648 (h0 : topological_space (has_dist (comm_monoid unsigned))) : t0_space (has_dist (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_57649 (h0 : topological_space (has_nnnorm (comm_ring char)) -> linarith.ineq -> Prop) : relator.right_unique h0 := sorry --non-trivial
lemma new_lemma_57650 (h0 : not (ring (add_group num) -> false)) : @is_domain.{0} (add_group.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (add_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_57651 (h0 : topological_space (has_add (semiring (semiring (semiring (semiring (semiring unsigned))))))) : totally_disconnected_space (has_add (semiring (semiring (semiring (semiring (semiring unsigned)))))) := sorry --non-trivial
lemma new_lemma_57652 (h0 : functor.add_const (topological_space (preorder num)) congr_arg_kind) : @normal_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_57653 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_57654 (h0 : topological_space (cancel_monoid (add_comm_semigroup fun_info))) : t0_space (cancel_monoid (add_comm_semigroup fun_info)) := sorry --non-trivial
lemma new_lemma_57655 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_57656 (h0 : add_group (dlist (has_nnnorm (has_nnnorm linarith.ineq)))) : is_add_cyclic (dlist (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_57657 (h0 : finset (monoid (option num))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_57658 (h1 : filter (add_monoid char)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_57659 (h0 : topological_space (ordered_comm_ring (ring (ring name)))) : t0_space (ordered_comm_ring (ring (ring name))) := sorry --non-trivial
lemma new_lemma_57660 (h0 : filter (finset (finset name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_57661 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_57662 (h0 : functor.add_const (functor.add_const Prop (has_nndist Type)) (comm_group name)) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_57663 (h0 : set (uniform_space (mul_one_class char))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_57664 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) pos) : @is_atomistic.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) pos h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_57665 (h0 : not (ring (uniform_space enat) -> false)) : @rank_condition.{0} (uniform_space.{0} enat) (@classical.by_contradiction'.{1} (ring.{0} (uniform_space.{0} enat)) h0)  := sorry --non-trivial
lemma new_lemma_57666 (h1 : add_group (random_gen linarith.comp_source)) : is_add_cyclic (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_57667 (h0 : topological_space (mul_zero_class (finset pos))) : discrete_topology (mul_zero_class (finset pos)) := sorry --non-trivial
lemma new_lemma_57668 (h0 : functor.add_const (topological_space (group_with_zero empty)) ennreal) : @normal_space.{0} (group_with_zero.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (group_with_zero.{0} empty)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_57669 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} linarith.comp (@function.extfun_app.{2 1} Type ring.{0} h0 linarith.comp)  := sorry --non-trivial
lemma new_lemma_57670 (h0 : function.extfun Type ring) : @rank_condition.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} h0 (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_57671 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (linear_ordered_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (linear_ordered_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_57672 (h1 : topological_space (id (with_bot string_imp))) : locally_compact_space (id (with_bot string_imp)) := sorry --non-trivial
lemma new_lemma_57673 (h0 : has_le (add_comm_semigroup ereal)) (h1 : add_comm_semigroup ereal) : is_max h1 := sorry --non-trivial
lemma new_lemma_57674 (h0 : topological_space (sub_neg_monoid (has_add real))) : discrete_topology (sub_neg_monoid (has_add real)) := sorry --non-trivial
lemma new_lemma_57675 (h0 : functor.add_const (ring (boolean_algebra Type)) pos) : @is_principal_ideal_ring.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_57676 (h0 : not (complete_lattice (semi_normed_ring linarith.comp_source) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (semi_normed_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (semi_normed_ring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_57677 (h0 : add_group (add_left_cancel_semigroup (semiring empty))) : is_add_cyclic (add_left_cancel_semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_57678 (h1 : ring (has_div linarith.comp_source)) : strong_rank_condition (has_div linarith.comp_source) := sorry --non-trivial
lemma new_lemma_57679 (h0 : functor.add_const (ring (has_nndist pos)) (finset Type)) : @rank_condition.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_nndist.{0} pos)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_57680 (h0 : functor.add_const (complete_lattice (finset Type)) linarith.comp) : @is_compactly_generated.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (finset.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_57681 (h0 : filter (mul_zero_class pos)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_57682 (h0 : functor.comp uniform_space finset unsigned) : @separated_space.{0} (finset.{0} unsigned) (@functor.comp.run.{0 0 0} uniform_space.{0} finset.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_57683 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_57684 (h0 : filter nnreal) : not (countable_Inter_filter h0) := sorry --non-trivial
lemma new_lemma_57685 (h0 : group (dlist (has_nnnorm linarith.comp_source))) : group.fg (dlist (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_57686 (h0 : functor.add_const (ring (mul_zero_class name)) pos) : @strong_rank_condition.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_57687 (h0 : function.extfun Type (prod (complete_distrib_lattice num))) : id_rel (function.extfun_app h0 (complete_distrib_lattice num)) := sorry --non-trivial
lemma new_lemma_57688 (h0 : functor.add_const (ring (semigroup Type)) pos) : @rank_condition.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (semigroup.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_57689 (h0 : function.extfun Type (functor.add_const (uniform_space znum))) : @complete_space.{0} znum (@functor.add_const.run.{0 0} (uniform_space.{0} znum) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} znum)) h0 empty))  := sorry --non-trivial
lemma new_lemma_57690 (h0 : filter nat) : nat.perfect (Lim h0) := sorry --non-trivial
lemma new_lemma_57691 (h0 : topological_space (simple_graph string.iterator_imp)) (h2 : preorder (simple_graph string.iterator_imp)) : order_closed_topology (simple_graph string.iterator_imp) := sorry --non-trivial
lemma new_lemma_57692 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (mul_zero_class.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_57693 (h0 : topological_space (nondiscrete_normed_field (add_comm_semigroup ereal))) : t0_space (nondiscrete_normed_field (add_comm_semigroup ereal)) := sorry --non-trivial
lemma new_lemma_57694 (h0 : fin has_zero.zero) : @is_cyclic.{0} (has_add.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (has_add.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_57695 (h0 : topological_space (has_zero (finset Type))) : path_connected_space (has_zero (finset Type)) := sorry --non-trivial
lemma new_lemma_57696 (h0 : filter pos) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_57697 (h0 : functor.add_const (topological_space (comm_group pos)) Type) : @regular_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_57698 (h0 h1 : multiset (has_nnnorm string.iterator_imp)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_57699 (h0 : functor.add_const (complete_lattice (has_nndist environment.implicit_infer_kind)) (has_neg linarith.comp)) : @is_compactly_generated.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} environment.implicit_infer_kind)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_57700 (h0 : cancel_comm_monoid_with_zero (has_bot (option (add_cancel_monoid empty)))) : unique_factorization_monoid (has_bot (option (add_cancel_monoid empty))) := sorry --non-trivial
lemma new_lemma_57701 (h0 : complete_lattice (has_union (semiring linarith.comp))) : complete_lattice.is_Sup_finite_compact (has_union (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_57702 (h0 : topological_space (complete_distrib_lattice (ordered_semiring (cancel_monoid Type)))) : sequential_space (complete_distrib_lattice (ordered_semiring (cancel_monoid Type))) := sorry --non-trivial
lemma new_lemma_57703 (h0 : topological_space (has_sub linarith.comp)) : path_connected_space (has_sub linarith.comp) := sorry --non-trivial
lemma new_lemma_57704 (h0 : function.extfun Type group) : @normalizer_condition.{0} (ring.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_57705 (h0 : ring (measurable_space.dynkin_system (semiring (semiring empty)))) : is_domain (measurable_space.dynkin_system (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_57706 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) pos) : @t1_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_57707 (h0 : topological_space (boolean_algebra.core (option (option (option ennreal))))) : discrete_topology (boolean_algebra.core (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_57708 (h0 : list (has_neg environment.implicit_infer_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_57709 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} name (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) name)  := sorry --non-trivial
lemma new_lemma_57710 (h0 : set (add_comm_semigroup ereal -> std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_57711 (h0 : add_group (simple_graph (simple_graph (has_ssubset string.iterator_imp)))) : is_add_cyclic (simple_graph (simple_graph (has_ssubset string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_57712 (h0 : not (add_group (random_gen (has_compl string_imp)) -> false)) : @is_add_cyclic.{0} (random_gen.{0} (has_compl.{0} string_imp)) (@classical.by_contradiction'.{1} (add_group.{0} (random_gen.{0} (has_compl.{0} string_imp))) h0)  := sorry --non-trivial
lemma new_lemma_57713 (h0 : ring (mul_one_class (option (option empty)))) : is_principal_ideal_ring (mul_one_class (option (option empty))) := sorry --non-trivial
lemma new_lemma_57714 (h0 : group (canonically_linear_ordered_monoid (cancel_monoid pos))) : normalizer_condition (canonically_linear_ordered_monoid (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_57715 (h0 : functor.add_const (ring (semigroup pos)) Type) : @rank_condition.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (semigroup.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_57716 (h0 : uniform_space (simple_graph (metric_space (mul_one_class to_additive.value_type)))) : complete_space (simple_graph (metric_space (mul_one_class to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_57717 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_57718 (h0 : function.extfun (finset Type) (has_mem.mem (has_top linarith.comp))) : @normal_space.{0} (has_top.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_57719 (h0 : list stieltjes_function) : palindrome h0 := sorry --non-trivial
lemma new_lemma_57720 (h0 : function.extfun Type (functor.comp topological_space cancel_monoid)) : @irreducible_space.{0} (cancel_monoid.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} cancel_monoid.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_57721 (h0 : uniform_space (measure_theory.measure_space empty)) : separated_space (measure_theory.measure_space empty) := sorry --non-trivial
lemma new_lemma_57722 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (has_neg.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_neg.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_57723 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (ordered_cancel_add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (ordered_cancel_add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_57724 (h0 : functor.add_const (topological_space (has_add name)) unsigned) : @regular_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_57725 (h0 : functor.add_const (monoid (has_add linarith.comp)) pos) : @monoid.fg.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (has_add.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_57726 (h0 : functor.add_const (complete_lattice (comm_group name)) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_group.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_57727 (h0 : uniform_space (has_Inf (has_add (has_pos_part (has_Inf pos))))) : complete_space (has_Inf (has_add (has_pos_part (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_57728 (h0 : functor.add_const (ordered_add_comm_monoid (linear_order unsigned)) empty) : @archimedean.{0} (linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (linear_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_57729 (h0 : ring (comm_ring (random_gen (random_gen (distrib_lattice to_additive.value_type))))) : is_domain (comm_ring (random_gen (random_gen (distrib_lattice to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_57730 (h0 : function.extfun Type (functor.comp ring comm_group)) : @is_domain.{0} (comm_group.{0} name) (@functor.comp.run.{0 0 0} ring.{0} comm_group.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} comm_group.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_57731 (h0 : list (ring (has_to_string (option pos)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_57732 (h0 : topological_space (has_compl linarith.ineq)) : path_connected_space (has_compl linarith.ineq) := sorry --non-trivial
lemma new_lemma_57733 (h0 : topological_space (normed_comm_ring (ring linarith.comp))) : regular_space (normed_comm_ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_57734 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_emptyc.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_emptyc.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_57735 (h0 : topological_space (has_neg_part (has_add ennreal))) : path_connected_space (has_neg_part (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_57736 (h0 : has_mem.mem (with_one (random_gen num)) has_emptyc.emptyc) : @strong_rank_condition.{0} (with_one.{0} (random_gen.{0} num)) (@finset.pi.empty.{1 0} Type ring.{0} (with_one.{0} (random_gen.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_57737 (h0 : add_group (has_nnnorm enat)) : is_add_cyclic (has_nnnorm enat) := sorry --non-trivial
lemma new_lemma_57738 (h0 : topological_space (normed_field linarith.ineq)) : path_connected_space (normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_57739 (h0 : topological_space (has_add (has_add pos))) : preconnected_space (has_add (has_add pos)) := sorry --non-trivial
lemma new_lemma_57740 (h0 : ring (has_add string_imp)) : strong_rank_condition (has_add string_imp) := sorry --non-trivial
lemma new_lemma_57741 (h0 : ring (cancel_monoid (comm_group (semigroup name)))) : is_domain (cancel_monoid (comm_group (semigroup name))) := sorry --non-trivial
lemma new_lemma_57742 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring ennreal)) Type) : @preirreducible_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (canonically_ordered_comm_semiring.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_57743 (h0 : cancel_comm_monoid_with_zero (has_bot (has_Inf pos))) : unique_factorization_monoid (has_bot (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_57744 (h0 : ring (add_comm_semigroup reducibility_hints)) : rank_condition (add_comm_semigroup reducibility_hints) := sorry --non-trivial
lemma new_lemma_57745 (h0 : functor.add_const (filter (has_to_string name)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_57746 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_57747 (h0 : topological_space (add_comm_semigroup (normed_field (mul_one_class std_gen)))) (h1 : preorder (add_comm_semigroup (normed_field (mul_one_class std_gen)))) : order_closed_topology (add_comm_semigroup (normed_field (mul_one_class std_gen))) := sorry --non-trivial
lemma new_lemma_57748 (h0 : ring (boolean_algebra (finset (ring Type)))) : is_domain (boolean_algebra (finset (ring Type))) := sorry --non-trivial
lemma new_lemma_57749 (h0 : complete_lattice (has_to_string (comm_group (comm_group (comm_group unsigned))))) : is_atomistic (has_to_string (comm_group (comm_group (comm_group unsigned)))) := sorry --non-trivial
lemma new_lemma_57750 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (dlist.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (dlist.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_57751 (h0 : topological_space (mul_zero_class (semiring empty))) : locally_compact_space (mul_zero_class (semiring empty)) := sorry --non-trivial
lemma new_lemma_57752 (h0 : add_monoid (bin_tree (semiring (semiring unsigned)))) : add_monoid.fg (bin_tree (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_57753 (h0 : not (add_group (has_inv linarith.comp_source) -> false)) : @is_add_cyclic.{0} (has_inv.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (add_group.{0} (has_inv.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_57754 (h0 : functor.add_const (ring (has_neg ennreal)) (option ennreal)) : @rank_condition.{0} (has_neg.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} ennreal)) (option.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_57755 (h0 : topological_space (has_neg num)) : normal_space (has_neg num) := sorry --non-trivial
lemma new_lemma_57756 (h0 : uniform_space (add_cancel_monoid (has_neg_part Type))) : complete_space (add_cancel_monoid (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_57757 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_57758 (h0 : complete_lattice real.angle) : is_compactly_generated real.angle := sorry --non-trivial
lemma new_lemma_57759 (h0 : functor.add_const (filter (boolean_algebra pos)) environment.implicit_infer_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_57760 (h0 : ring (has_norm to_additive.value_type)) : is_domain (has_norm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_57761 (h0 : topological_space (has_add (has_nndist (has_neg environment.implicit_infer_kind)))) : preconnected_space (has_add (has_nndist (has_neg environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_57762 (h0 : fin has_zero.zero) : @regular_space.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (comm_semigroup.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_57763 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_57764 (h0 : functor.add_const (topological_space (semigroup pos)) unsigned) : @normal_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_57765 (h0 : list (monoid_with_zero (option (option ennreal)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_57766 (h0 : topological_space (semigroup (finset (finset (finset pos))))) : t0_space (semigroup (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_57767 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_57768 (h0 : not (complete_lattice (comm_ring linarith.comp_source) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (comm_ring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (comm_ring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_57769 (h0 : functor.add_const (add_group (has_add linarith.comp)) name) : @is_add_cyclic.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (has_add.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_57770 (h0 : topological_space (add_comm_monoid ennreal)) : t1_space (add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_57771 (h2 : function.extfun Type list) : list.nodup (list.tail (function.extfun_app h2 (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_57772 (h0 : monoid (has_one unsigned)) : monoid.fg (has_one unsigned) := sorry --non-trivial
lemma new_lemma_57773 (h0 : has_mem.mem (semiring congr_arg_kind) has_emptyc.emptyc) : @path_connected_space.{0} (semiring.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_57774 (h0 : ordered_comm_monoid (semigroup ennreal)) : has_exists_mul_of_le (semigroup ennreal) := sorry --non-trivial
lemma new_lemma_57775 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_57776 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_57777 (h1 : set (std_gen -> fun_info)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_57778 (h0 : ring (has_div (mul_one_class (uniform_space string.iterator_imp)))) : rank_condition (has_div (mul_one_class (uniform_space string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_57779 (h0 : not (add_group (dlist char) -> false)) : @is_add_cyclic.{0} (dlist.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (dlist.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_57780 (h0 : add_group (finset linarith.comp)) : is_add_cyclic (finset linarith.comp) := sorry --non-trivial
lemma new_lemma_57781 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @discrete_topology.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_57782 (h0 : functor.add_const (functor.add_const (complete_lattice (ring name)) Type) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (ring.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (ring.{0} name)) Type (@functor.add_const.run.{0 0} (functor.add_const.{0 1} (complete_lattice.{0} (ring.{0} name)) Type) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_57783 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @totally_disconnected_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_57784 (h0 : topological_space (canonically_ordered_comm_semiring environment.implicit_infer_kind)) : totally_disconnected_space (canonically_ordered_comm_semiring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_57785 (h0 : ordered_add_comm_monoid (comm_semigroup (sub_neg_monoid (has_bot (comm_semigroup (comm_semigroup real)))))) : archimedean (comm_semigroup (sub_neg_monoid (has_bot (comm_semigroup (comm_semigroup real))))) := sorry --non-trivial
lemma new_lemma_57786 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_principal_ideal_ring.{0} (canonically_linear_ordered_monoid.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ring.{0}) (canonically_linear_ordered_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_57787 (h0 : topological_space (random_gen (random_gen (random_gen char)))) : t0_space (random_gen (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_57788 (h1 : topological_space (div_inv_monoid char)) : totally_disconnected_space (div_inv_monoid char) := sorry --non-trivial
lemma new_lemma_57789 (h0 : functor.add_const (ring (mul_zero_class congr_arg_kind)) (semiring unsigned)) : @is_domain.{0} (mul_zero_class.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} congr_arg_kind)) (semiring.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_57790 (h0 : topological_space (boolean_algebra.core (has_neg pos))) : loc_path_connected_space (boolean_algebra.core (has_neg pos)) := sorry --non-trivial
lemma new_lemma_57791 (h0 : topological_space (ring (cancel_monoid (has_neg (boolean_algebra environment.implicit_infer_kind))))) : irreducible_space (ring (cancel_monoid (has_neg (boolean_algebra environment.implicit_infer_kind)))) := sorry --non-trivial
lemma new_lemma_57792 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (with_bot.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_57793 (h0 : complete_lattice (add_comm_monoid (sub_neg_monoid real))) : is_atomistic (add_comm_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_57794 (h0 : not (topological_space (uniform_space reducibility_hints) -> false)) : @totally_disconnected_space.{0} (uniform_space.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_57795 (h0 : topological_space (normed_comm_ring environment.implicit_infer_kind)) : topological_space.separable_space (normed_comm_ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_57796 (h0 : ring (has_nndist (option (option (option empty))))) : is_domain (has_nndist (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_57797 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) linarith.comp) : @has_exists_mul_of_le.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) linarith.comp h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_57798 (h0 : enat -> Prop) (h1 : heq (has_compl linarith.comp_source) enat) (h2 : filter (has_compl linarith.comp_source)) : filter.frequently h0 (heq.elim h1 h2) := sorry --non-trivial
lemma new_lemma_57799 (h0 : functor.add_const (uniform_space (add_cancel_monoid pos)) linarith.comp) : @complete_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_57800 (h0 : topological_space (has_bot (has_pos_part Type))) : totally_disconnected_space (has_bot (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_57801 (h0 : topological_space (add_comm_monoid (option (option (option num))))) : discrete_topology (add_comm_monoid (option (option (option num)))) := sorry --non-trivial
lemma new_lemma_57802 (h0 : functor.add_const (topological_space (mul_zero_class num)) congr_arg_kind) : @totally_separated_space.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_57803 (h0 : filter (canonically_ordered_add_monoid congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_57804 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) (has_add (has_add Type))) : @complete_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) uniform_space.{1}) (has_add.{1} (has_add.{1} Type)) h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_57805 (h0 : uniform_space char) (h1 : topological_space (uniform_space.separation_quotient char)) : t0_space (uniform_space.separation_quotient char) := sorry --non-trivial
lemma new_lemma_57806 (h0 : has_mem.mem (random_gen (has_norm linarith.comp_source)) has_emptyc.emptyc) : @is_compactly_generated.{0} (random_gen.{0} (has_norm.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (random_gen.{0} (has_norm.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_57807 (h0 : uniform_space (has_Sup empty)) : complete_space (has_Sup empty) := sorry --non-trivial
lemma new_lemma_57808 (h0 : finset (linear_order unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_57809 (h0 : ring (add_cancel_monoid (has_add environment.implicit_infer_kind))) : is_principal_ideal_ring (add_cancel_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_57810 (h0 : topological_space (generalized_boolean_algebra name)) : preirreducible_space (generalized_boolean_algebra name) := sorry --non-trivial
lemma new_lemma_57811 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (normed_linear_ordered_group.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (normed_linear_ordered_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_57812 (h0 : group (semiring congr_arg_kind)) : normalizer_condition (semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_57813 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra.core pos)) linarith.comp) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (boolean_algebra.core.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_57814 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_57815 (h1 : has_lt (normed_field (add_comm_semigroup linarith.ineq))) : no_max_order (normed_field (add_comm_semigroup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_57816 (h0 : complete_lattice (has_Inf (has_Inf (has_neg name)))) : complete_lattice.is_Sup_finite_compact (has_Inf (has_Inf (has_neg name))) := sorry --non-trivial
lemma new_lemma_57817 (h0 : has_lt (has_Sup to_additive.value_type)) : no_max_order (has_Sup to_additive.value_type) := sorry --non-trivial
lemma new_lemma_57818 (h0 : group (with_bot to_additive.value_type)) : is_cyclic (with_bot to_additive.value_type) := sorry --non-trivial
lemma new_lemma_57819 (h2 : add_group (distrib to_additive.value_type)) : is_add_cyclic (distrib to_additive.value_type) := sorry --non-trivial
lemma new_lemma_57820 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) name) : @irreducible_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_57821 (h0 : ring (has_to_string (has_to_string name))) : is_domain (has_to_string (has_to_string name)) := sorry --non-trivial
lemma new_lemma_57822 (h0 : functor.add_const (ring (add_comm_monoid name)) Type) : @is_principal_ideal_ring.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (add_comm_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_57823 (h0 : function.extfun Type ring) : @is_domain.{0} (has_sub.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_sub.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_57824 (h0 : group (ordered_comm_ring (has_add pos))) : is_simple_group (ordered_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_57825 (h0 : topological_space (canonically_ordered_comm_semiring name)) : t1_space (canonically_ordered_comm_semiring name) := sorry --non-trivial
lemma new_lemma_57826 (h0 : functor.add_const (group (finset name)) environment.implicit_infer_kind) : @group.fg.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_57827 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_57828 (h0 : add_monoid (pseudo_metric_space (option pos))) : add_monoid.fg (pseudo_metric_space (option pos)) := sorry --non-trivial
lemma new_lemma_57829 (h0 : topological_space (has_nnnorm char)) (h1 : set (has_nnnorm char)) : is_preconnected h1 := sorry --non-trivial
lemma new_lemma_57830 (h0 : not (topological_space (has_top num) -> false)) : @discrete_topology.{0} (has_top.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_57831 (h0 : ring (has_add (has_add (has_add (has_add (finset (finset pos))))))) : strong_rank_condition (has_add (has_add (has_add (has_add (finset (finset pos)))))) := sorry --non-trivial
lemma new_lemma_57832 (h0 : topological_space (ordered_comm_ring (ring Type))) : preirreducible_space (ordered_comm_ring (ring Type)) := sorry --non-trivial
lemma new_lemma_57833 (h0 : add_monoid (mul_zero_class (has_add ennreal))) : add_monoid.fg (mul_zero_class (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_57834 (h0 : topological_space (has_bot Type)) : loc_path_connected_space (has_bot Type) := sorry --non-trivial
lemma new_lemma_57835 (h0 : group (comm_ring (comm_ring reducibility_hints))) : is_cyclic (comm_ring (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_57836 (h0 : ordered_comm_monoid (canonically_ordered_comm_semiring (has_neg_part unsigned))) : has_exists_mul_of_le (canonically_ordered_comm_semiring (has_neg_part unsigned)) := sorry --non-trivial
lemma new_lemma_57837 (h1 : complete_lattice unsigned) : is_atomistic unsigned := sorry --non-trivial
lemma new_lemma_57838 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_57839 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_57840 (h0 : topological_space (random_gen (random_gen (random_gen fun_info)))) : irreducible_space (random_gen (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_57841 (h0 : list (has_zero name)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_57842 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_57843 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_57844 (h0 : monoid (add_comm_monoid num)) : monoid.fg (add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_57845 (h0 : std_gen -> std_gen -> std_gen) : is_associative std_gen h0 := sorry --non-trivial
lemma new_lemma_57846 (h1 : topological_space (normed_field string.iterator_imp)) (h2 : not (preorder (normed_field string.iterator_imp) -> false)) : @order_topology.{0} (normed_field.{0} string.iterator_imp) h1 (@classical.by_contradiction'.{1} (preorder.{0} (normed_field.{0} string.iterator_imp)) h2)  := sorry --non-trivial
lemma new_lemma_57847 (h0 : monoid (complete_semilattice_Sup (random_gen (random_gen fun_info)))) : monoid.fg (complete_semilattice_Sup (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_57848 (h0 : ordered_comm_monoid (cancel_monoid (has_add name))) : has_exists_mul_of_le (cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_57849 (h0 : not (ring (uniform_space linarith.ineq) -> false)) : @is_domain.{0} (uniform_space.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (uniform_space.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_57850 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space num))) : @discrete_topology.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_57851 (h0 : topological_space (measurable_space (random_gen (random_gen to_additive.value_type)))) : totally_separated_space (measurable_space (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_57852 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (partial_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_57853 (h0 : function.extfun Type topological_space) : @t0_space.{0} (filter.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (filter.{0} num))  := sorry --non-trivial
lemma new_lemma_57854 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_Sup unsigned)) := sorry --non-trivial
lemma new_lemma_57855 (h1 : complete_lattice (distrib_lattice string_imp)) : complete_lattice.is_Sup_finite_compact (distrib_lattice string_imp) := sorry --non-trivial
lemma new_lemma_57856 (h0 : topological_space (finset (has_pos_part Type))) : t0_space (finset (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_57857 (h0 : uniform_space (semigroup (mul_zero_class (mul_zero_class name)))) : separated_space (semigroup (mul_zero_class (mul_zero_class name))) := sorry --non-trivial
lemma new_lemma_57858 (h0 : functor.add_const (filter (boolean_algebra pos)) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_57859 (h0 : fin has_zero.zero) : @preconnected_space.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_57860 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_57861 (h0 : uniform_space (has_star (option unsigned))) : separated_space (has_star (option unsigned)) := sorry --non-trivial
lemma new_lemma_57862 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) name) : @irreducible_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_57863 (h0 : topological_space (ring (ring Type))) : locally_compact_space (ring (ring Type)) := sorry --non-trivial
lemma new_lemma_57864 (h0 : cancel_comm_monoid_with_zero (linear_ordered_cancel_comm_monoid empty)) : unique_factorization_monoid (linear_ordered_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_57865 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_57866 (h0 : functor.add_const (ordered_comm_monoid (complete_distrib_lattice linarith.comp)) (has_neg pos)) : @has_exists_mul_of_le.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (complete_distrib_lattice.{0} linarith.comp)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_57867 (h0 : functor.add_const (complete_lattice (has_dist num)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (has_dist.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_dist.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_57868 (h2 h3 : multiset (has_nnnorm linarith.ineq)) : multiset.disjoint h2 h3 := sorry --non-trivial
lemma new_lemma_57869 (h0 : list (ring (option pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_57870 (h1 : not (topological_space (topological_space to_additive.value_type) -> false)) : @t0_space.{0} (topological_space.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (topological_space.{0} to_additive.value_type)) h1)  := sorry --non-trivial
lemma new_lemma_57871 (h0 : has_mem.mem (has_emptyc num) has_emptyc.emptyc) : @normalizer_condition.{0} (has_emptyc.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (has_emptyc.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_57872 (h0 : functor.add_const (topological_space (with_bot name)) name) : @loc_path_connected_space.{0} (with_bot.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (with_bot.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_57873 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_neg_part.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_57874 (h0 : functor.add_const (topological_space (finset unsigned)) (ring (ring Type))) : @t0_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (finset.{0} unsigned)) (ring.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_57875 (h0 : uniform_space (non_assoc_semiring (semiring congr_arg_kind))) : separated_space (non_assoc_semiring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_57876 (h0 : ordered_add_comm_monoid (preorder (option unsigned))) : archimedean (preorder (option unsigned)) := sorry --non-trivial
lemma new_lemma_57877 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_57878 (h0 : topological_space (semigroup unsigned)) : preirreducible_space (semigroup unsigned) := sorry --non-trivial
lemma new_lemma_57879 (h0 : topological_space (measure_theory.measure_space congr_arg_kind)) : t0_space (measure_theory.measure_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_57880 (h0 : has_mem.mem (with_one to_additive.value_type) has_emptyc.emptyc) : @separated_space.{0} (with_one.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type uniform_space.{0} (with_one.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_57881 (h0 : functor.add_const (topological_space (semigroup name)) name) : @discrete_topology.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_57882 (h0 : functor.add_const (topological_space (cancel_monoid unsigned)) Type) : @normal_space.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_57883 (h0 : has_mem.mem (metric_space linarith.comp) has_emptyc.emptyc) : @group.fg.{0} (metric_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type group.{0} (metric_space.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_57884 (h0 : topological_space (complete_distrib_lattice (option ennreal))) : t1_space (complete_distrib_lattice (option ennreal)) := sorry --non-trivial
lemma new_lemma_57885 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_dist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_dist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_57886 (h0 : topological_space (has_bot congr_arg_kind)) : totally_disconnected_space (has_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_57887 (h0 : complete_lattice (has_top (has_inv to_additive.value_type))) : is_atomistic (has_top (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_57888 (h1 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h1) (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_57889 (h0 : topological_space (mul_zero_class ennreal)) : sequential_space (mul_zero_class ennreal) := sorry --non-trivial
lemma new_lemma_57890 (h0 : topological_space (add_comm_monoid (has_Inf pos))) : t0_space (add_comm_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_57891 (h0 : topological_space (pseudo_metric_space ennreal)) : normal_space (pseudo_metric_space ennreal) := sorry --non-trivial
lemma new_lemma_57892 (h0 : functor.add_const (topological_space (sub_neg_monoid name)) name) : @totally_disconnected_space.{0} (sub_neg_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (sub_neg_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_57893 (h0 : topological_space (has_one (has_top unsigned))) : locally_compact_space (has_one (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_57894 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (has_sub.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_sub.{0} num))  := sorry --non-trivial
lemma new_lemma_57895 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @strong_rank_condition.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_57896 (h0 : monoid (id (has_inv linarith.ineq))) : monoid.fg (id (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_57897 (h0 : functor.add_const (group (has_zero environment.implicit_infer_kind)) (has_nndist (has_to_string (has_neg Type)))) : @is_simple_group.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (group.{0} (has_zero.{0} environment.implicit_infer_kind)) (has_nndist.{1} (has_to_string.{1} (has_neg.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_57898 (h0 : function.extfun Type ring) : @is_domain.{0} nnreal (@function.extfun_app.{2 1} Type ring.{0} h0 nnreal)  := sorry --non-trivial
lemma new_lemma_57899 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @irreducible_space.{1} (simple_graph.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (simple_graph.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_57900 (h0 : topological_space (boolean_algebra name)) : irreducible_space (boolean_algebra name) := sorry --non-trivial
lemma new_lemma_57901 (h0 : topological_space (has_neg congr_arg_kind)) : totally_disconnected_space (has_neg congr_arg_kind) := sorry --non-trivial
lemma new_lemma_57902 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (boolean_algebra.core.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (boolean_algebra.core.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_57903 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_57904 (h0 : ring congr_arg_kind) (h1 : topological_space (ring.positive_cone congr_arg_kind)) : irreducible_space (ring.positive_cone congr_arg_kind) := sorry --non-trivial
lemma new_lemma_57905 (h0 : filter (linear_ordered_cancel_comm_monoid congr_arg_kind)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_57906 (h0 : ring (measurable_space.dynkin_system (semiring (has_top (semiring linarith.comp))))) : is_domain (measurable_space.dynkin_system (semiring (has_top (semiring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_57907 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) (has_neg name)) : @locally_compact_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_57908 (h0 : has_mem.mem fun_info has_emptyc.emptyc) : @complete_space.{0} fun_info (@finset.pi.empty.{1 0} Type uniform_space.{0} fun_info h0)  := sorry --non-trivial
lemma new_lemma_57909 (h3 : ring (add_monoid (has_nnnorm linarith.ineq))) : strong_rank_condition (add_monoid (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_57910 (h0 : topological_space (ordered_comm_monoid (has_add (finset (has_neg (has_Inf pos)))))) : loc_path_connected_space (ordered_comm_monoid (has_add (finset (has_neg (has_Inf pos))))) := sorry --non-trivial
lemma new_lemma_57911 (h0 : filter (has_dist congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_57912 (h0 : list (add_cancel_monoid (ring (add_comm_monoid Type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_57913 (h0 : functor.add_const (topological_space (finset environment.implicit_infer_kind)) name) : @path_connected_space.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_57914 (h0 : topological_space (canonically_linear_ordered_monoid ennreal)) : loc_path_connected_space (canonically_linear_ordered_monoid ennreal) := sorry --non-trivial
lemma new_lemma_57915 (h0 : group (add_comm_monoid (has_add (has_add (has_add Type))))) : group.fg (add_comm_monoid (has_add (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_57916 (h0 : complete_lattice (add_group empty)) : is_atomistic (add_group empty) := sorry --non-trivial
lemma new_lemma_57917 (h0 : topological_space (finset (has_neg (ring environment.implicit_infer_kind)))) : t1_space (finset (has_neg (ring environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_57918 (h0 : topological_space (canonically_ordered_comm_semiring (finset (has_nndist name)))) : totally_separated_space (canonically_ordered_comm_semiring (finset (has_nndist name))) := sorry --non-trivial
lemma new_lemma_57919 (h0 : topological_space (has_union (id congr_arg_kind))) : preirreducible_space (has_union (id congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_57920 (h0 : topological_space (has_nndist (finset name))) : normal_space (has_nndist (finset name)) := sorry --non-trivial
lemma new_lemma_57921 (h0 : group (simple_graph (option unsigned))) : normalizer_condition (simple_graph (option unsigned)) := sorry --non-trivial
lemma new_lemma_57922 (h0 : functor.add_const (function.extfun Type group) name) : @group.fg.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) name h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_57923 (h0 : topological_space (has_star (semiring congr_arg_kind))) : totally_separated_space (has_star (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_57924 (h0 : topological_space (measurable_space (has_top unsigned))) : t0_space (measurable_space (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_57925 (h0 : uniform_space (add_comm_monoid (normed_comm_ring environment.implicit_infer_kind))) : complete_space (add_comm_monoid (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_57926 (h0 : functor.add_const (topological_space (preorder empty)) (semiring (semiring empty))) : @totally_separated_space.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} empty)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_57927 (h0 : uniform_space (has_zero (finset pos))) : complete_space (has_zero (finset pos)) := sorry --non-trivial
lemma new_lemma_57928 (h0 : functor.add_const (ring (complete_distrib_lattice Type)) Type) : @is_domain.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (complete_distrib_lattice.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_57929 (h1 : function.extfun Type topological_space) : @locally_compact_space.{0} to_additive.value_type (@function.extfun_app.{2 1} Type topological_space.{0} h1 to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_57930 (h0 : group (distrib_lattice (has_nnnorm (random_gen linarith.ineq)))) : is_cyclic (distrib_lattice (has_nnnorm (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_57931 (h0 : not (group (normed_group unsigned) -> false)) : @is_cyclic.{0} (normed_group.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (normed_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_57932 (h0 : filter (linear_ordered_add_comm_group (random_gen to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_57933 (h0 : functor.add_const (cancel_comm_monoid_with_zero (cancel_monoid name)) unsigned) : @unique_factorization_monoid.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (cancel_monoid.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_57934 (h0 : pnat) (h1 : fin has_zero.zero) : pnat.coprime h0 (id (id (matrix.vec_empty h1))) := sorry --non-trivial
lemma new_lemma_57935 (h0 : functor.add_const (topological_space auto.case_option) (has_zero num)) : @discrete_topology.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) (has_zero.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_57936 (h0 : topological_space (has_to_string (comm_group Type))) : preconnected_space (has_to_string (comm_group Type)) := sorry --non-trivial
lemma new_lemma_57937 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_57938 (h0 : functor.add_const (function.extfun Type ring) (semigroup Type)) : @is_principal_ideal_ring.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) (semigroup.{1} Type) h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_57939 (h0 : topological_space (with_one (semiring (semiring empty)))) : t0_space (with_one (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_57940 (h0 : functor.add_const (group (add_group congr_arg_kind)) unsigned) : @is_cyclic.{0} (add_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (add_group.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_57941 (h0 : add_monoid (has_emptyc num)) : add_monoid.fg (has_emptyc num) := sorry --non-trivial
lemma new_lemma_57942 (h0 : functor.add_const (topological_space (simple_graph pos)) pos) : @path_connected_space.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_57943 (h0 : functor.add_const (complete_lattice (has_nndist unsigned)) linarith.comp) : @is_atomistic.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_57944 (h0 : complete_lattice (distrib_lattice (random_gen (random_gen (random_gen linarith.ineq))))) : is_compactly_generated (distrib_lattice (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_57945 (h0 : functor.add_const (ring (bin_tree num)) empty) : @is_domain.{0} (bin_tree.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (bin_tree.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_57946 (h0 : topological_space (partial_order congr_arg_kind)) : t1_space (partial_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_57947 (h0 : functor.add_const (fin has_zero.zero) linarith.comp) : @complete_space.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (complete_distrib_lattice.{1} Type)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_57948 (h0 : group (has_bot (finset linarith.comp))) : normalizer_condition (has_bot (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_57949 (h0 : topological_space (has_pos_part (has_neg (has_neg real)))) : preconnected_space (has_pos_part (has_neg (has_neg real))) := sorry --non-trivial
lemma new_lemma_57950 (h0 : fin has_zero.zero) : @normalizer_condition.{1} (sub_neg_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) group.{1}) h0) (sub_neg_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_57951 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_57952 (h0 : topological_space (cancel_monoid (cancel_monoid unsigned))) : locally_compact_space (cancel_monoid (cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_57953 (h0 : topological_space (has_pos_part (has_pos_part Type))) : discrete_topology (has_pos_part (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_57954 (h0 : topological_space (canonically_linear_ordered_monoid (has_Inf real))) : t0_space (canonically_linear_ordered_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_57955 (h0 : fin has_zero.zero) : @is_simple_group.{0} (canonically_linear_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (group.{0} (canonically_linear_ordered_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_57956 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_nndist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_nndist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_57957 (h0 : complete_lattice (has_le linarith.ineq)) : complete_lattice.is_Sup_finite_compact (has_le linarith.ineq) := sorry --non-trivial
lemma new_lemma_57958 (h0 : functor.add_const (topological_space (ring name)) (ring environment.implicit_infer_kind)) : @t1_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} name)) (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_57959 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) pos) : @t0_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_57960 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_57961 (h0 : topological_space (normed_lattice_add_comm_group (sub_neg_monoid (has_Inf pos)))) : loc_path_connected_space (normed_lattice_add_comm_group (sub_neg_monoid (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_57962 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (measurable_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (measurable_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_57963 (h0 : functor.add_const (uniform_space (comm_group pos)) environment.implicit_infer_kind) : @complete_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (comm_group.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_57964 (h0 : complete_lattice (semi_normed_comm_ring enat)) : is_compactly_generated (semi_normed_comm_ring enat) := sorry --non-trivial
lemma new_lemma_57965 (h0 : preorder unsigned) (h1 : preorder nat) (h2 : unsigned -> nat) (h3 : complete_lattice (galois_insertion h2 unsigned.of_nat')) : complete_lattice.is_Sup_finite_compact (galois_insertion h2 unsigned.of_nat') := sorry --non-trivial
lemma new_lemma_57966 (h0 : not (topological_space (with_one num) -> false)) : @discrete_topology.{0} (with_one.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_57967 (h0 : functor.comp (functor.comp topological_space has_zero) with_top nnreal) : @t0_space.{0} (has_zero.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} ennreal (@functor.comp.run.{0 0 0} (functor.comp.{0 0 0} topological_space.{0} has_zero.{0}) with_top.{0} nnreal h0))  := sorry --non-trivial
lemma new_lemma_57968 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_57969 (h0 : functor.comp list has_neg_part Type) : list.nodup (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_57970 (h0 : complete_lattice (metric_space to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (metric_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_57971 (h0 : ring (linear_ordered_comm_ring unsigned)) : is_principal_ideal_ring (linear_ordered_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_57972 (h0 : add_group (add_comm_semigroup (add_comm_semigroup string.iterator_imp))) : is_add_cyclic (add_comm_semigroup (add_comm_semigroup string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_57973 (h0 : functor.comp ring has_zero name) : @is_domain.{0} (has_zero.{0} name) (@functor.comp.run.{0 0 0} ring.{0} has_zero.{0} name h0)  := sorry --non-trivial
lemma new_lemma_57974 (h0 : topological_space (has_Inf (has_neg linarith.comp))) : preirreducible_space (has_Inf (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_57975 (h2 : filter (fintype fun_info)) : filter.ne_bot h2 := sorry --non-trivial
lemma new_lemma_57976 (h1 : with_bot (ring (has_append string_imp))) (h2 : ne h1 has_bot.bot) : @is_domain.{0} (has_append.{0} string_imp) (@with_bot.unbot.{0} (ring.{0} (has_append.{0} string_imp)) h1 h2)  := sorry --non-trivial
lemma new_lemma_57977 (h0 : functor.add_const (add_group (has_neg_part linarith.comp)) (has_neg_part (has_neg Type))) : @is_add_cyclic.{0} (has_neg_part.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_group.{0} (has_neg_part.{0} linarith.comp)) (has_neg_part.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_57978 (h0 : function.extfun Type complete_lattice) : is_atomistic (measurable_space (has_norm (has_norm (has_norm (has_norm linarith.comp))))) := sorry --non-trivial
lemma new_lemma_57979 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_57980 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @strong_rank_condition.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_57981 (h0 : functor.add_const (ring (normed_linear_ordered_group congr_arg_kind)) empty) : @strong_rank_condition.{0} (normed_linear_ordered_group.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (normed_linear_ordered_group.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_57982 (h0 : topological_space (canonically_linear_ordered_monoid (has_add linarith.comp))) : normal_space (canonically_linear_ordered_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_57983 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) (has_neg_part Type)) : @t0_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} name)) (has_neg_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_57984 (h0 : functor.add_const (uniform_space (ring Type)) linarith.comp) : @separated_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_57985 (h0 : not (group (denumerable char) -> false)) : @is_cyclic.{0} (denumerable.{0} char) (@classical.by_contradiction'.{1} (group.{0} (denumerable.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_57986 (h0 : ring (id (has_norm linarith.comp))) : strong_rank_condition (id (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_57987 (h0 : add_group (topological_space (comm_ring linarith.ineq))) (h1 : add_subgroup (topological_space (comm_ring linarith.ineq))) : add_subgroup.is_commutative h1 := sorry --non-trivial
lemma new_lemma_57988 (h0 : ring (semigroup (add_comm_monoid pos))) : rank_condition (semigroup (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_57989 (h0 : topological_space (cancel_monoid (monoid_with_zero pos))) : loc_path_connected_space (cancel_monoid (monoid_with_zero pos)) := sorry --non-trivial
lemma new_lemma_57990 (h0 : topological_space (distrib_lattice (has_inv fun_info))) : locally_compact_space (distrib_lattice (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_57991 (h0 : topological_space (preorder (option (option empty)))) : totally_separated_space (preorder (option (option empty))) := sorry --non-trivial
lemma new_lemma_57992 (h0 : function.extfun nat fin) : @complete_space.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (uniform_space.{1} (boolean_algebra.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_57993 (h0 : topological_space (random_gen (has_nnnorm (has_nnnorm linarith.ineq)))) : path_connected_space (random_gen (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_57994 (h0 : ordered_add_comm_monoid (as_linear_order (option (option (option empty))))) : archimedean (as_linear_order (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_57995 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (measurable_space.dynkin_system.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (measurable_space.dynkin_system.{0} empty))  := sorry --non-trivial
lemma new_lemma_57996 (h0 : topological_space (has_to_string (finset Type))) : loc_path_connected_space (has_to_string (finset Type)) := sorry --non-trivial
lemma new_lemma_57997 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) pos) : @path_connected_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (complete_distrib_lattice.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_57998 (h0 : group (ordered_comm_monoid real)) : group.fg (ordered_comm_monoid real) := sorry --non-trivial
lemma new_lemma_57999 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_58000 (h0 : list (canonically_ordered_comm_semiring (semigroup Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_58001 (h0 : functor.add_const (add_monoid (linear_ordered_comm_monoid_with_zero empty)) (option empty)) : @add_monoid.fg.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_58002 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_dist.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_dist.{0} num))  := sorry --non-trivial
lemma new_lemma_58003 (h0 : group (has_star (semiring (semiring congr_arg_kind)))) : is_cyclic (has_star (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_58004 (h1 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} linarith.comp_source (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_58005 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) Type) : @t1_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_58006 (h0 : topological_space (normed_group (semiring congr_arg_kind))) : discrete_topology (normed_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_58007 (h0 : set (non_unital_non_assoc_semiring linarith.ineq)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_58008 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @path_connected_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_58009 (h0 : filter (has_neg (has_neg pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_58010 (h0 : functor.add_const (topological_space name) empty) : @discrete_topology.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) empty h0)  := sorry --non-trivial
lemma new_lemma_58011 (h0 : has_mem.mem (normed_group linarith.comp) has_emptyc.emptyc) : @is_compactly_generated.{0} (normed_group.{0} linarith.comp) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (normed_group.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_58012 (h0 : list (has_ssubset (random_gen fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_58013 (h0 : topological_space (add_cancel_monoid (option empty))) : preirreducible_space (add_cancel_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_58014 (h0 : functor.add_const (ring (has_edist unsigned)) unsigned) : @is_domain.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_edist.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_58015 (h0 : topological_space (linear_order (option empty))) : loc_path_connected_space (linear_order (option empty)) := sorry --non-trivial
lemma new_lemma_58016 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_neg_part.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (has_neg_part.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_58017 (h0 : ring (id to_additive.value_type)) : is_domain (id to_additive.value_type) := sorry --non-trivial
lemma new_lemma_58018 (h0 : functor.add_const (complete_lattice (add_semigroup num)) empty) : @is_compactly_generated.{0} (add_semigroup.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_semigroup.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_58019 (h0 : cancel_comm_monoid_with_zero (ring (has_add unsigned))) : unique_factorization_monoid (ring (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_58020 (h0 : measurable_space (normed_field std_gen)) (h1 : filter (normed_field std_gen)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_58021 (h0 : functor.add_const (topological_space (has_zero environment.implicit_infer_kind)) (has_neg linarith.comp)) : @discrete_topology.{0} (has_zero.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} environment.implicit_infer_kind)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_58022 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (finset empty)) := sorry --non-trivial
lemma new_lemma_58023 (h0 : add_comm_semigroup (add_comm_semigroup std_gen) -> add_comm_semigroup (add_comm_semigroup std_gen) -> Prop) : is_total (add_comm_semigroup (add_comm_semigroup std_gen)) h0 := sorry --non-trivial
lemma new_lemma_58024 (h0 : functor.add_const (functor.add_const (topological_space auto.case_option) unsigned) empty) : @topological_space.separable_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) unsigned (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} auto.case_option) unsigned) empty h0))  := sorry --non-trivial
lemma new_lemma_58025 (h0 : uniform_space (semigroup (ring (ring Type)))) : separated_space (semigroup (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_58026 (h0 : ordered_comm_monoid (has_add (ring pos))) : has_exists_mul_of_le (has_add (ring pos)) := sorry --non-trivial
lemma new_lemma_58027 (h0 : functor.add_const (ordered_add_comm_monoid (has_add pos)) pos) : @archimedean.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_add.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_58028 (h3 : ring environment.projection_info) : is_domain environment.projection_info := sorry --non-trivial
lemma new_lemma_58029 (h0 : list (random_gen linarith.comp_source)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_58030 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_58031 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_to_string.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} empty))  := sorry --non-trivial
lemma new_lemma_58032 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (monoid empty)) := sorry --non-trivial
lemma new_lemma_58033 (h0 : not (uniform_space (id fun_info) -> false)) : @separated_space.{0} (@id.{2} Type fun_info) (@classical.by_contradiction'.{1} (uniform_space.{0} (@id.{2} Type fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_58034 (h0 : ring (has_dist ennreal)) : strong_rank_condition (has_dist ennreal) := sorry --non-trivial
lemma new_lemma_58035 (h0 : group (add_cancel_monoid (has_add (add_comm_monoid name)))) : is_simple_group (add_cancel_monoid (has_add (add_comm_monoid name))) := sorry --non-trivial
lemma new_lemma_58036 (h0 : uniform_space (has_add (option unsigned))) : complete_space (has_add (option unsigned)) := sorry --non-trivial
lemma new_lemma_58037 (h0 : functor.comp ring mul_zero_class pos) : @strong_rank_condition.{0} (mul_zero_class.{0} pos) (@functor.comp.run.{0 0 0} ring.{0} mul_zero_class.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_58038 (h0 : group (has_add num)) : group.fg (has_add num) := sorry --non-trivial
lemma new_lemma_58039 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_ordered_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_58040 (h0 : functor.add_const (functor.add_const (monoid Type) Type) (has_add environment.implicit_infer_kind)) : @monoid.fg.{1} Type (@functor.add_const.run.{1 1} (monoid.{1} Type) Type (@functor.add_const.run.{1 0} (functor.add_const.{1 1} (monoid.{1} Type) Type) (has_add.{0} environment.implicit_infer_kind) h0))  := sorry --non-trivial
lemma new_lemma_58041 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) (has_add (finset pos))) : @locally_compact_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) (has_add.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_58042 (h0 : functor.add_const (topological_space (has_bot name)) linarith.comp) : @totally_separated_space.{0} (has_bot.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_58043 (h0 : add_monoid (complete_distrib_lattice (option (option pos)))) : add_monoid.fg (complete_distrib_lattice (option (option pos))) := sorry --non-trivial
lemma new_lemma_58044 (h0 : function.extfun Type (prod (semigroup (mul_zero_class (mul_zero_class pos))))) : id_rel (function.extfun_app h0 (semigroup (mul_zero_class (mul_zero_class pos)))) := sorry --non-trivial
lemma new_lemma_58045 (h0 : not (has_lt (has_ssubset char) -> false)) : @densely_ordered.{0} (has_ssubset.{0} char) (@classical.by_contradiction'.{1} (has_lt.{0} (has_ssubset.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_58046 (h0 : add_monoid (cancel_monoid empty)) : add_monoid.fg (cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_58047 (h0 : functor.add_const (list (left_cancel_monoid empty)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_58048 (h0 : functor.add_const (group (ordered_semiring congr_arg_kind)) unsigned) : @normalizer_condition.{0} (ordered_semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (ordered_semiring.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_58049 (h0 : complete_lattice (encodable fun_info)) : complete_lattice.is_Sup_finite_compact (encodable fun_info) := sorry --non-trivial
lemma new_lemma_58050 (h0 : complete_lattice (has_Inf (finset pos))) : complete_lattice.is_Sup_finite_compact (has_Inf (finset pos)) := sorry --non-trivial
lemma new_lemma_58051 (h0 : topological_space (sub_neg_monoid (has_bot real))) : preirreducible_space (sub_neg_monoid (has_bot real)) := sorry --non-trivial
lemma new_lemma_58052 (h0 : monoid (add_cancel_monoid (boolean_algebra Type))) : monoid.fg (add_cancel_monoid (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_58053 (h0 : functor.add_const (add_group (cancel_monoid empty)) (option num)) : @is_add_cyclic.{0} (cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (cancel_monoid.{0} empty)) (option.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_58054 (h0 : functor.add_const (group (simple_graph Type)) linarith.comp) : @group.fg.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (simple_graph.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_58055 (h0 : functor.comp ring comm_group Type) : @rank_condition.{1} (comm_group.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} comm_group.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_58056 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_58057 (h0 : complete_lattice (has_to_string (option num))) : is_compactly_generated (has_to_string (option num)) := sorry --non-trivial
lemma new_lemma_58058 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (complete_distrib_lattice unsigned)) := sorry --non-trivial
lemma new_lemma_58059 (h0 : ring (with_zero (has_nnnorm linarith.comp_source))) : is_domain (with_zero (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_58060 (h0 : complete_lattice (has_div (mul_one_class linarith.comp_source))) : is_compactly_generated (has_div (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_58061 (h0 : semiring (has_bot linarith.comp)) : is_noetherian_ring (has_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_58062 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @discrete_topology.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_58063 (h0 : topological_space (measurable_space (has_top (has_norm linarith.comp_source)))) : sequential_space (measurable_space (has_top (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_58064 (h0 : topological_space (has_to_string (finset pos))) : topological_space.separable_space (has_to_string (finset pos)) := sorry --non-trivial
lemma new_lemma_58065 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_domain.{0} (normed_comm_ring.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (normed_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_58066 (h0 : complete_lattice (plift num)) : is_compactly_generated (plift num) := sorry --non-trivial
lemma new_lemma_58067 (h0 : complete_lattice (metric_space num)) : complete_lattice.is_Sup_finite_compact (metric_space num) := sorry --non-trivial
lemma new_lemma_58068 (h0 : has_mem.mem congr_arg_kind has_emptyc.emptyc) : @path_connected_space.{0} congr_arg_kind (@finset.pi.empty.{1 0} Type topological_space.{0} congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_58069 (h0 : functor.add_const (topological_space (cancel_monoid name)) name) : @t0_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_58070 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (generalized_boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_58071 (h0 : function.extfun Type group) : @group.fg.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_58072 (h0 : ring (has_nndist unsigned)) : rank_condition (has_nndist unsigned) := sorry --non-trivial
lemma new_lemma_58073 (h0 : functor.add_const (cancel_comm_monoid_with_zero (boolean_algebra name)) environment.implicit_infer_kind) : @unique_factorization_monoid.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (boolean_algebra.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_58074 (h0 : cancel_comm_monoid_with_zero (complete_semilattice_Sup (semiring (semiring unsigned)))) : unique_factorization_monoid (complete_semilattice_Sup (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_58075 (h0 : functor.add_const (complete_lattice (normed_comm_ring environment.implicit_infer_kind)) Type) : @is_atomistic.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (complete_lattice.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_58076 (h4 : not (uniform_space (semi_normed_ring string_imp) -> false)) : @complete_space.{0} (semi_normed_ring.{0} string_imp) (@classical.by_contradiction'.{1} (uniform_space.{0} (semi_normed_ring.{0} string_imp)) h4)  := sorry --non-trivial
lemma new_lemma_58077 (h0 : uniform_space (has_norm (semiring (has_norm (semiring congr_arg_kind))))) : complete_space (has_norm (semiring (has_norm (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_58078 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (ring (option pos))) := sorry --non-trivial
lemma new_lemma_58079 (h0 : monoid (has_emptyc (has_inv (has_norm linarith.comp_source)))) : monoid.fg (has_emptyc (has_inv (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_58080 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) name) : @loc_path_connected_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_58081 (h0 : function.extfun Type (functor.comp group cancel_monoid)) : @group.fg.{0} (cancel_monoid.{0} (has_add.{0} environment.implicit_infer_kind)) (@functor.comp.run.{0 0 0} group.{0} cancel_monoid.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} cancel_monoid.{0}) h0 (has_add.{0} environment.implicit_infer_kind)))  := sorry --non-trivial
lemma new_lemma_58082 (h0 : complete_lattice (random_gen (random_gen char))) : is_compactly_generated (random_gen (random_gen char)) := sorry --non-trivial
lemma new_lemma_58083 (h0 : functor.add_const (topological_space (has_add real)) (has_Inf (has_Inf pos))) : @preconnected_space.{0} (has_add.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} real)) (has_Inf.{0} (has_Inf.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_58084 (h0 : list (complete_linear_order (option (option unsigned)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_58085 (h0 : topological_space (has_dist empty)) : t1_space (has_dist empty) := sorry --non-trivial
lemma new_lemma_58086 (h0 : ring (comm_monoid num)) : is_domain (comm_monoid num) := sorry --non-trivial
lemma new_lemma_58087 (h0 : functor.add_const (list (emetric_space unsigned)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_58088 (h0 : functor.add_const (topological_space (has_edist empty)) empty) : @t0_space.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_58089 (h0 : group (as_linear_order (option empty))) : normalizer_condition (as_linear_order (option empty)) := sorry --non-trivial
lemma new_lemma_58090 (h0 : add_monoid (generalized_boolean_algebra (has_neg (has_Inf (has_neg (has_neg (has_neg real))))))) : add_monoid.fg (generalized_boolean_algebra (has_neg (has_Inf (has_neg (has_neg (has_neg real)))))) := sorry --non-trivial
lemma new_lemma_58091 (h2 : semiring (add_comm_semigroup char)) (h3 : ideal (add_comm_semigroup char)) : ideal.is_prime h3 := sorry --non-trivial
lemma new_lemma_58092 (h0 : not (topological_space (preorder empty) -> false)) : @irreducible_space.{0} (preorder.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (preorder.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_58093 (h1 : add_group (has_append char)) : is_add_cyclic (has_append char) := sorry --non-trivial
lemma new_lemma_58094 (h1 : ring (comm_ring linarith.comp_source)) : is_domain (comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_58095 (h0 : uniform_space (boolean_algebra (semigroup (has_add (has_add (has_pos_part Type)))))) : complete_space (boolean_algebra (semigroup (has_add (has_add (has_pos_part Type))))) := sorry --non-trivial
lemma new_lemma_58096 (h0 : functor.add_const (uniform_space (finset pos)) Type) : @complete_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (finset.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_58097 (h0 : functor.add_const (list (ring pos)) (ring (has_add pos))) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_58098 (h0 : functor.add_const (ring (measurable_space.dynkin_system empty)) unsigned) : @is_domain.{0} (measurable_space.dynkin_system.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (measurable_space.dynkin_system.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_58099 (h0 : complete_lattice (has_neg_part (has_add (cancel_monoid (has_add (has_add name)))))) : is_compactly_generated (has_neg_part (has_add (cancel_monoid (has_add (has_add name))))) := sorry --non-trivial
lemma new_lemma_58100 (h0 h1 : multiset (simple_graph linarith.comp_source)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_58101 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @topological_space.separable_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_58102 (h0 : has_bot (has_bot (sub_neg_monoid real)) -> name -> name) : left_commutative h0 := sorry --non-trivial
lemma new_lemma_58103 (h1 : group (normed_field (normed_field linarith.comp_source))) : is_cyclic (normed_field (normed_field linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_58104 (h0 : ring (has_top (has_norm fun_info))) : is_domain (has_top (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_58105 (h0 : complete_lattice (boolean_algebra.core (add_cancel_monoid name))) : is_atomistic (boolean_algebra.core (add_cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_58106 (h0 : topological_space (has_emptyc (has_top (has_top fun_info)))) : totally_disconnected_space (has_emptyc (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_58107 (h0 : topological_space (boolean_algebra (has_add (has_pos_part pos)))) : preirreducible_space (boolean_algebra (has_add (has_pos_part pos))) := sorry --non-trivial
lemma new_lemma_58108 (h0 : pnat) (h1 : with_bot (ulower pnat)) (h2 : ne h1 has_bot.bot) : pnat.coprime h0 (ulower.up (with_bot.unbot h1 h2)) := sorry --non-trivial
lemma new_lemma_58109 (h0 : ring (has_neg (finset (finset ennreal)))) : rank_condition (has_neg (finset (finset ennreal))) := sorry --non-trivial
lemma new_lemma_58110 (h0 : ring (semiring (has_norm (has_norm congr_arg_kind)))) : is_domain (semiring (has_norm (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_58111 (h0 : topological_space (add_comm_monoid Type)) : topological_space.separable_space (add_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_58112 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_58113 (h0 : not (semiring (has_one empty) -> false)) : @is_noetherian_ring.{0} (has_one.{0} empty) (@classical.by_contradiction'.{1} (semiring.{0} (has_one.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_58114 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_58115 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @path_connected_space.{0} (normed_group.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (normed_group.{0} name))  := sorry --non-trivial
lemma new_lemma_58116 (h0 : prod (add_cancel_monoid (has_add name)) (add_cancel_monoid (has_add name))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_58117 (h0 : functor.add_const (topological_space (has_dist empty)) unsigned) : @preconnected_space.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_58118 (h0 : topological_space (has_neg_part (has_add Type))) : topological_space.separable_space (has_neg_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_58119 (h0 : group (has_compl (has_nnnorm (random_gen string_imp)))) : is_cyclic (has_compl (has_nnnorm (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_58120 (h0 : functor.add_const (ring (cancel_monoid name)) linarith.comp) : @is_principal_ideal_ring.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (cancel_monoid.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_58121 (h2 : topological_space (with_zero to_additive.value_type)) : path_connected_space (with_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_58122 (h0 : ring (comm_ring (random_gen (has_ssubset linarith.ineq)))) : strong_rank_condition (comm_ring (random_gen (has_ssubset linarith.ineq))) := sorry --non-trivial
lemma new_lemma_58123 (h0 : topological_space (normed_comm_ring (has_add environment.implicit_infer_kind))) : regular_space (normed_comm_ring (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_58124 (h0 : semiring (ordered_comm_ring (ordered_comm_monoid Type))) : is_noetherian_ring (ordered_comm_ring (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_58125 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (div_inv_monoid.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (div_inv_monoid.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_58126 (h0 : topological_space (has_norm (semiring unsigned))) : normal_space (has_norm (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_58127 (h0 : topological_space (group_with_zero (option (option ennreal)))) : locally_compact_space (group_with_zero (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_58128 (h0 : complete_lattice (canonically_ordered_comm_semiring (option name))) : is_compactly_generated (canonically_ordered_comm_semiring (option name)) := sorry --non-trivial
lemma new_lemma_58129 (h1 : finset (distrib (random_gen reducibility_hints))) : finset.nonempty h1 := sorry --non-trivial
lemma new_lemma_58130 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_58131 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_58132 (h0 : topological_space (ordered_comm_group (option empty))) : irreducible_space (ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_58133 (h0 : ring (ordered_comm_ring (finset Type))) : rank_condition (ordered_comm_ring (finset Type)) := sorry --non-trivial
lemma new_lemma_58134 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) linarith.comp) : @loc_path_connected_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_58135 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) name) : @discrete_topology.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_58136 (h0 : Prop) (h1 : decidable h0) : as_false h0 := sorry --non-trivial
lemma new_lemma_58137 (h0 : topological_space (nondiscrete_normed_field (pseudo_metric_space fun_info))) : totally_disconnected_space (nondiscrete_normed_field (pseudo_metric_space fun_info)) := sorry --non-trivial
lemma new_lemma_58138 (h0 : topological_space (comm_group environment.implicit_infer_kind)) : irreducible_space (comm_group environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_58139 (h0 : list (dlist (random_gen (has_top (random_gen (random_gen linarith.ineq)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_58140 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (fintype.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (fintype.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_58141 (h0 : functor.comp list comm_group name) : palindrome (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_58142 (h0 : uniform_space (generalized_boolean_algebra (has_add (has_add (has_add pos))))) : separated_space (generalized_boolean_algebra (has_add (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_58143 (h0 : list (has_neg (option (option (option empty))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_58144 (h0 : ordered_add_comm_monoid (group_with_zero congr_arg_kind)) : archimedean (group_with_zero congr_arg_kind) := sorry --non-trivial
lemma new_lemma_58145 (h0 : fin has_zero.zero) : @loc_path_connected_space.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_58146 (h0 : not (topological_space (distrib linarith.ineq) -> false)) : @t0_space.{0} (distrib.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_58147 (h0 : add_monoid (with_bot (has_norm linarith.comp))) : add_monoid.fg (with_bot (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_58148 (h0 : topological_space (partial_order (semiring (semiring (semiring (semiring unsigned)))))) : t0_space (partial_order (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_58149 (h0 : functor.add_const (list (add_right_cancel_monoid num)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_58150 (h0 : has_mem.mem (has_top empty) has_emptyc.emptyc) : @locally_compact_space.{0} (has_top.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_58151 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (ordered_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_58152 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (boolean_algebra.core.{0} (finset.{0} pos)) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} (finset.{0} pos)))  := sorry --non-trivial
lemma new_lemma_58153 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_58154 (h0 : function.extfun (Type 1) topological_space) : @irreducible_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_58155 (h0 : ring (denumerable (has_nnnorm fun_info))) : rank_condition (denumerable (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_58156 (h0 : topological_space (has_ssubset (has_ssubset (has_ssubset (has_ssubset char))))) : totally_disconnected_space (has_ssubset (has_ssubset (has_ssubset (has_ssubset char)))) := sorry --non-trivial
lemma new_lemma_58157 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (linear_ordered_add_comm_group to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_58158 (h0 : add_group (add_comm_semigroup fun_info)) : is_add_cyclic (add_comm_semigroup fun_info) := sorry --non-trivial
lemma new_lemma_58159 (h0 : not (has_mem.mem (with_bot empty) has_emptyc.emptyc -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} empty) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_bot.{0} empty) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} empty) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_58160 (h0 : topological_space (add_cancel_monoid linarith.comp)) : t0_space (add_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_58161 (h0 : topological_space (nondiscrete_normed_field string.iterator_imp)) : totally_disconnected_space (nondiscrete_normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_58162 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} h0 (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_58163 (h0 : uniform_space (has_pos_part (finset (boolean_algebra.core pos)))) : separated_space (has_pos_part (finset (boolean_algebra.core pos))) := sorry --non-trivial
lemma new_lemma_58164 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_add linarith.comp)) linarith.comp) : @unique_factorization_monoid.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_add.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_58165 (h0 : topological_space (ring linarith.comp)) : sequential_space (ring linarith.comp) := sorry --non-trivial
lemma new_lemma_58166 (h0 : functor.add_const (add_monoid (plift num)) (semiring (semiring num))) : @add_monoid.fg.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (add_monoid.{1} (plift.{1} num)) (semiring.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_58167 (h1 : function.extfun (finset Type) (has_mem.mem (has_norm num))) : @rank_condition.{0} (has_norm.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (has_norm.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} num)) h1 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_58168 (h0 : topological_space (has_to_string (option ennreal))) : normal_space (has_to_string (option ennreal)) := sorry --non-trivial
lemma new_lemma_58169 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_inter unsigned)) := sorry --non-trivial
lemma new_lemma_58170 (h0 : has_mul (has_to_string empty)) (h1 : topological_space (con (has_to_string empty))) : locally_compact_space (con (has_to_string empty)) := sorry --non-trivial
lemma new_lemma_58171 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_58172 (h0 : functor.add_const (complete_lattice (boolean_algebra.core name)) pos) : @is_atomistic.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_58173 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) name) : @archimedean.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) name h0) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_58174 (h0 : functor.add_const (topological_space (option unsigned)) congr_arg_kind) : @topological_space.separable_space.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_58175 (h0 : complete_lattice (encodable char)) : complete_lattice.is_Sup_finite_compact (encodable char) := sorry --non-trivial
lemma new_lemma_58176 (h0 : functor.add_const (functor.add_const (uniform_space linarith.comp) pos) pos) : @separated_space.{0} linarith.comp (@functor.add_const.run.{0 0} (uniform_space.{0} linarith.comp) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (uniform_space.{0} linarith.comp) pos) pos h0))  := sorry --non-trivial
lemma new_lemma_58177 (h0 : not (topological_space (fintype to_additive.value_type) -> false)) : @locally_compact_space.{0} (fintype.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (fintype.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_58178 (h0 : topological_space (comm_group (semigroup (boolean_algebra environment.implicit_infer_kind)))) : t0_space (comm_group (semigroup (boolean_algebra environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_58179 (h0 : group (cancel_monoid linarith.comp)) : normalizer_condition (cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_58180 (h0 : complete_lattice (with_bot (random_gen (random_gen (has_norm (random_gen to_additive.value_type)))))) : is_atomistic (with_bot (random_gen (random_gen (has_norm (random_gen to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_58181 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} empty (@function.extfun_app.{2 1} Type ring.{0} h0 empty)  := sorry --non-trivial
lemma new_lemma_58182 (h0 : function.extfun nat fin) : @t1_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_58183 (h0 : functor.add_const (topological_space (has_add Type)) pos) : @totally_disconnected_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_add.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_58184 (h0 : fin has_zero.zero) : @monoid.fg.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (monoid.{1} (complete_distrib_lattice.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_58185 (h0 : not (complete_lattice (linear_ordered_comm_ring unsigned) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_comm_ring.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_comm_ring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_58186 (h0 : topological_space (finset (has_Inf Type))) : preconnected_space (finset (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_58187 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_58188 (h0 : topological_space (has_Inf (has_add real))) : discrete_topology (has_Inf (has_add real)) := sorry --non-trivial
lemma new_lemma_58189 (h0 : ring (complete_distrib_lattice (option (option (option empty))))) : strong_rank_condition (complete_distrib_lattice (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_58190 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_58191 (h0 : functor.add_const (topological_space (has_to_string pos)) (finset Type)) : @irreducible_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} pos)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_58192 (h0 : function.extfun Type topological_space) : @t1_space.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_58193 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_add.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} num))  := sorry --non-trivial
lemma new_lemma_58194 (h0 : topological_space (ring name)) : locally_compact_space (ring name) := sorry --non-trivial
lemma new_lemma_58195 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (has_to_string.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_to_string.{0}) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 (functor.comp.{0 0 0} topological_space.{0} has_to_string.{0})) pos))  := sorry --non-trivial
lemma new_lemma_58196 (h1 : has_coe (add_comm_semigroup (mul_one_class char)) Prop) (h2 : add_comm_semigroup (mul_one_class char)) : @coe_b.{1 1} (add_comm_semigroup.{0} (mul_one_class.{0} char)) Prop h1 h2  := sorry --non-trivial
lemma new_lemma_58197 (h0 : ring (normed_comm_ring (comm_group pos))) : is_principal_ideal_ring (normed_comm_ring (comm_group pos)) := sorry --non-trivial
lemma new_lemma_58198 (h0 : functor.add_const (filter (has_neg Type)) Type) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_58199 (h0 : topological_space (add_comm_monoid (has_add (normed_comm_ring (has_add (has_add (has_add name))))))) : normal_space (add_comm_monoid (has_add (normed_comm_ring (has_add (has_add (has_add name)))))) := sorry --non-trivial
lemma new_lemma_58200 (h0 : functor.add_const (finset (has_zero name)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_58201 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_58202 (h0 : has_mem.mem ring has_emptyc.emptyc) : @strong_rank_condition.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_58203 (h0 : topological_space std_gen) (h1 : set std_gen) : is_seq_compact h1 := sorry --non-trivial
lemma new_lemma_58204 (h0 : functor.add_const (topological_space (add_comm_monoid name)) (normed_comm_ring Type)) : @topological_space.separable_space.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} name)) (normed_comm_ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_58205 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_58206 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_58207 (h0 : functor.add_const (topological_space (has_to_string pos)) (has_neg Type)) : @loc_path_connected_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_58208 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_principal_ideal_ring.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_58209 (h0 : group (semigroup (has_to_string (has_to_string pos)))) : is_simple_group (semigroup (has_to_string (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_58210 (h0 : fin has_zero.zero) : @is_atomistic.{0} (add_comm_monoid.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (add_comm_monoid.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_58211 (h0 : topological_space (complete_distrib_lattice (option name))) : sequential_space (complete_distrib_lattice (option name)) := sorry --non-trivial
lemma new_lemma_58212 (h0 : functor.add_const (function.extfun Type list) (ring linarith.comp)) : palindrome (function.extfun_app (functor.add_const.run h0) (has_Inf name)) := sorry --non-trivial
lemma new_lemma_58213 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (linear_ordered_add_comm_group.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_add_comm_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_58214 (h0 : group (dlist (random_gen (has_inv linarith.comp_source)))) : normalizer_condition (dlist (random_gen (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_58215 (h0 : topological_space (has_compl std_gen)) (h1 : add_group (has_compl std_gen)) : topological_add_group (has_compl std_gen) := sorry --non-trivial
lemma new_lemma_58216 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (normed_linear_ordered_group.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_linear_ordered_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_58217 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_principal_ideal_ring.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) ring.{0}) (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_58218 (h0 : group (comm_ring (random_gen linarith.comp_source))) (h1 : subgroup (comm_ring (random_gen linarith.comp_source))) : subgroup.is_commutative h1 := sorry --non-trivial
lemma new_lemma_58219 (h0 : topological_space (has_Inf (has_pos_part linarith.comp))) : discrete_topology (has_Inf (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_58220 (h1 : list (complete_semilattice_Sup congr_arg_kind)) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_58221 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_58222 (h0 : functor.comp topological_space normed_comm_ring ennreal) : @irreducible_space.{0} (normed_comm_ring.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} normed_comm_ring.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_58223 (h0 : ring (complete_semilattice_Sup unsigned)) : is_principal_ideal_ring (complete_semilattice_Sup unsigned) := sorry --non-trivial
lemma new_lemma_58224 (h0 : ring (uniform_space (metric_space reducibility_hints))) : rank_condition (uniform_space (metric_space reducibility_hints)) := sorry --non-trivial
lemma new_lemma_58225 : infinite (uniform_space (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_58226 (h0 : topological_space (with_one num)) : discrete_topology (with_one num) := sorry --non-trivial
lemma new_lemma_58227 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} h0 (comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_58228 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : palindrome (function.extfun_app (function.extfun_app h0 list) (ordered_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_58229 (h0 : topological_space (has_Inf linarith.comp)) : irreducible_space (has_Inf linarith.comp) := sorry --non-trivial
lemma new_lemma_58230 (h0 : functor.add_const (ring (boolean_algebra pos)) Type) : @rank_condition.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_58231 (h0 : ring (complete_distrib_lattice num)) : rank_condition (complete_distrib_lattice num) := sorry --non-trivial
lemma new_lemma_58232 (h0 : prod fun_info fun_info) : set.diagonal fun_info h0 := sorry --non-trivial
lemma new_lemma_58233 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) (boolean_algebra (boolean_algebra pos))) : @preconnected_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned)) (boolean_algebra.{0} (boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_58234 (h1 : has_mem.mem (has_emptyc linarith.comp) has_emptyc.emptyc) : @strong_rank_condition.{0} (has_emptyc.{0} linarith.comp) (@finset.pi.empty.{1 0} Type ring.{0} (has_emptyc.{0} linarith.comp) h1)  := sorry --non-trivial
lemma new_lemma_58235 (h0 : topological_space (linear_ordered_comm_ring (semiring (has_norm unsigned)))) : preirreducible_space (linear_ordered_comm_ring (semiring (has_norm unsigned))) := sorry --non-trivial
lemma new_lemma_58236 (h0 : group (canonically_linear_ordered_monoid pos)) : is_simple_group (canonically_linear_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_58237 (h0 : function.extfun (Type 1) list) : list.nodup (function.extfun_app h0 (generalized_boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_58238 (h0 : ring (complete_distrib_lattice (comm_group name))) : is_principal_ideal_ring (complete_distrib_lattice (comm_group name)) := sorry --non-trivial
lemma new_lemma_58239 (h0 : function.extfun Type (functor.add_const (add_group (semigroup congr_arg_kind)))) : @is_add_cyclic.{0} (semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (add_group.{0} (semigroup.{0} congr_arg_kind)) (option.{0} (option.{0} (option.{0} unsigned))) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (add_group.{0} (semigroup.{0} congr_arg_kind))) h0 (option.{0} (option.{0} (option.{0} unsigned)))))  := sorry --non-trivial
lemma new_lemma_58240 (h0 : functor.add_const (filter (has_Inf Type)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_58241 (h0 : topological_space (has_lt (mul_one_class fun_info))) (h1 : preorder (has_lt (mul_one_class fun_info))) : order_topology (has_lt (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_58242 (h0 : functor.add_const (topological_space (mul_zero_class ennreal)) Type) : @path_connected_space.{0} (mul_zero_class.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (mul_zero_class.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_58243 (h0 : function.extfun Type ring) : @is_domain.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_58244 (h0 : functor.add_const (ring (partial_order unsigned)) unsigned) : @is_domain.{0} (partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (partial_order.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_58245 (h0 : finset (has_Sup empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_58246 (h0 : fin has_zero.zero) : @irreducible_space.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_58247 (h0 : functor.add_const (group (has_to_string environment.implicit_infer_kind)) Type) : @group.fg.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (group.{0} (has_to_string.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_58248 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_58249 (h0 : list Prop) (h1 : nat) : list.inth h0 h1 := sorry --non-trivial
lemma new_lemma_58250 (h0 : topological_space (has_zero (option pos))) : loc_path_connected_space (has_zero (option pos)) := sorry --non-trivial
lemma new_lemma_58251 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_58252 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (normed_linear_ordered_group.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (normed_linear_ordered_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_58253 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @complete_space.{1} (has_bot.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 uniform_space.{1}) (has_bot.{1} Type))  := sorry --non-trivial
lemma new_lemma_58254 (h0 : topological_space (canonically_ordered_monoid (sub_neg_monoid real))) : preconnected_space (canonically_ordered_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_58255 (h0 : complete_lattice (with_bot (has_norm num))) : is_atomistic (with_bot (has_norm num)) := sorry --non-trivial
lemma new_lemma_58256 (h0 : complete_lattice (cancel_monoid (finset ennreal))) : complete_lattice.is_Sup_finite_compact (cancel_monoid (finset ennreal)) := sorry --non-trivial
lemma new_lemma_58257 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (canonically_linear_ordered_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_58258 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @discrete_topology.{1} (boolean_algebra.core.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (boolean_algebra.core.{1} Type))  := sorry --non-trivial
lemma new_lemma_58259 (h0 : functor.comp group ring name) : @is_simple_group.{0} (ring.{0} name) (@functor.comp.run.{0 0 0} group.{0} ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_58260 (h0 : group (finset (comm_group (has_add (add_cancel_monoid (has_to_string name)))))) : is_simple_group (finset (comm_group (has_add (add_cancel_monoid (has_to_string name))))) := sorry --non-trivial
lemma new_lemma_58261 (h0 : filter (dlist (random_gen linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_58262 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_58263 (h0 : functor.add_const (group (complete_distrib_lattice unsigned)) unsigned) : @group.fg.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_58264 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} h0 (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_58265 (h0 : group (semigroup (has_add name))) : group.fg (semigroup (has_add name)) := sorry --non-trivial
lemma new_lemma_58266 (h0 : ring (has_lt (has_compl to_additive.value_type))) : is_domain (has_lt (has_compl to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_58267 (h0 : topological_space (preorder unsigned)) : loc_path_connected_space (preorder unsigned) := sorry --non-trivial
lemma new_lemma_58268 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_58269 (h0 : function.extfun (Type 1) list) : list.nodup (function.extfun_app h0 (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_58270 (h1 : ring (has_inf congr_arg_kind)) : strong_rank_condition (has_inf congr_arg_kind) := sorry --non-trivial
lemma new_lemma_58271 (h0 : topological_space (boolean_algebra (has_zero Type))) : topological_space.separable_space (boolean_algebra (has_zero Type)) := sorry --non-trivial
lemma new_lemma_58272 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @discrete_topology.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) num)  := sorry --non-trivial
lemma new_lemma_58273 (h0 : group (with_bot (random_gen (random_gen (has_inv linarith.comp_source))))) : is_cyclic (with_bot (random_gen (random_gen (has_inv linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_58274 (h0 : monoid (ordered_comm_ring (has_Inf pos))) : monoid.fg (ordered_comm_ring (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_58275 (h0 : group (has_one (semiring (has_top unsigned)))) : normalizer_condition (has_one (semiring (has_top unsigned))) := sorry --non-trivial
lemma new_lemma_58276 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_58277 (h0 : functor.add_const (uniform_space (semigroup pos)) (has_add linarith.comp)) : @complete_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} pos)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_58278 (h0 : complete_lattice (random_gen (random_gen linarith.comp))) : is_compactly_generated (random_gen (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_58279 (h0 : topological_space (cancel_monoid ennreal)) : path_connected_space (cancel_monoid ennreal) := sorry --non-trivial
lemma new_lemma_58280 (h0 : fin has_zero.zero) : @is_compactly_generated.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (ordered_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_58281 (h0 : complete_lattice (ordered_comm_monoid (finset Type))) : complete_lattice.is_Sup_finite_compact (ordered_comm_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_58282 (h1 : topological_space (measurable_space linarith.ineq)) : totally_disconnected_space (measurable_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_58283 (h0 : not (topological_space (semiring num) -> false)) : @topological_space.separable_space.{0} (semiring.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_58284 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_58285 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_58286 (h0 : topological_space (has_neg (option (option (option ennreal))))) : t0_space (has_neg (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_58287 (h0 : functor.add_const (topological_space (partial_order empty)) empty) : @discrete_topology.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_58288 (h0 : topological_space (has_nndist (option unsigned))) : preirreducible_space (has_nndist (option unsigned)) := sorry --non-trivial
lemma new_lemma_58289 (h0 : topological_space (complete_distrib_lattice (finset environment.implicit_infer_kind))) : discrete_topology (complete_distrib_lattice (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_58290 (h0 : group (linear_ordered_semiring (has_norm (has_norm to_additive.value_type)))) : normalizer_condition (linear_ordered_semiring (has_norm (has_norm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_58291 (h0 : functor.add_const (topological_space (has_to_string ennreal)) num) : @locally_compact_space.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_58292 (h0 : functor.add_const (ring (has_neg Type)) name) : @is_principal_ideal_ring.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_neg.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_58293 (h0 : topological_space (finset unsigned)) : irreducible_space (finset unsigned) := sorry --non-trivial
lemma new_lemma_58294 (h0 : group (has_zero (comm_group name))) : is_simple_group (has_zero (comm_group name)) := sorry --non-trivial
lemma new_lemma_58295 (h0 : ring (has_compl (has_ssubset linarith.ineq))) : is_domain (has_compl (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_58296 (h0 : group (add_cancel_monoid (has_neg (has_neg (finset Type))))) : is_simple_group (add_cancel_monoid (has_neg (has_neg (finset Type)))) := sorry --non-trivial
lemma new_lemma_58297 (h0 : topological_space (has_ssubset (has_ssubset linarith.ineq))) : locally_compact_space (has_ssubset (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_58298 (h0 : ordered_add_comm_monoid (comm_semigroup (has_bot (comm_semigroup (comm_semigroup real))))) : archimedean (comm_semigroup (has_bot (comm_semigroup (comm_semigroup real)))) := sorry --non-trivial
lemma new_lemma_58299 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (linear_ordered_semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_58300 (h0 : function.extfun Type topological_space) : @normal_space.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_58301 (h0 : topological_space (boolean_algebra.core (has_to_string Type))) : preirreducible_space (boolean_algebra.core (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_58302 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @t0_space.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_58303 (h0 : group (complete_distrib_lattice pos)) : is_simple_group (complete_distrib_lattice pos) := sorry --non-trivial
lemma new_lemma_58304 (h0 : functor.add_const (group (has_nndist empty)) empty) : @group.fg.{0} (has_nndist.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_58305 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (has_one.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_58306 (h0 : list (ring (finset (has_add (has_add linarith.comp))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_58307 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) environment.implicit_infer_kind) : @preconnected_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_58308 (h0 : group (has_union (add_group (has_union (has_union (has_union (semiring num))))))) : group.fg (has_union (add_group (has_union (has_union (has_union (semiring num)))))) := sorry --non-trivial
lemma new_lemma_58309 (h0 : topological_space (left_cancel_monoid unsigned)) : path_connected_space (left_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_58310 (h0 : function.extfun Type group) : @group.fg.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_58311 (h0 : functor.add_const (topological_space (has_neg ennreal)) ennreal) : @preconnected_space.{0} (has_neg.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_58312 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} num (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) num)  := sorry --non-trivial
lemma new_lemma_58313 (h0 : functor.add_const (topological_space (simple_graph Type)) linarith.comp) : @loc_path_connected_space.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (simple_graph.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_58314 (h0 : functor.add_const (topological_space (has_Sup unsigned)) empty) : @path_connected_space.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_58315 (h0 : not (ring (distrib linarith.comp_source) -> false)) : @is_principal_ideal_ring.{0} (distrib.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_58316 (h0 : topological_space (random_gen (has_append (comm_ring reducibility_hints)))) : t0_space (random_gen (has_append (comm_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_58317 (h0 : topological_space (canonically_ordered_monoid (has_neg (has_Inf name)))) : t0_space (canonically_ordered_monoid (has_neg (has_Inf name))) := sorry --non-trivial
lemma new_lemma_58318 (h0 : add_monoid (boolean_algebra.core congr_arg_kind)) : add_monoid.fg (boolean_algebra.core congr_arg_kind) := sorry --non-trivial
lemma new_lemma_58319 (h0 : functor.add_const (function.extfun Type topological_space) (has_nndist name)) : @locally_compact_space.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_nndist.{0} name) h0) (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_58320 (h0 : functor.add_const (group (has_to_string environment.implicit_infer_kind)) (boolean_algebra (boolean_algebra pos))) : @is_simple_group.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} environment.implicit_infer_kind)) (boolean_algebra.{0} (boolean_algebra.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_58321 (h0 : topological_space (linear_ordered_semiring (has_norm (semiring empty)))) : discrete_topology (linear_ordered_semiring (has_norm (semiring empty))) := sorry --non-trivial
lemma new_lemma_58322 (h0 : add_monoid (boolean_algebra name)) : add_monoid.fg (boolean_algebra name) := sorry --non-trivial
lemma new_lemma_58323 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} linarith.comp_source (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_58324 (h0 : functor.add_const (uniform_space (finset Type)) Type) : @complete_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (finset.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_58325 (h0 : has_neg ordering) (h1 : measurable_space ordering) : has_measurable_neg ordering := sorry --non-trivial
lemma new_lemma_58326 (h0 : ring (has_top (has_top num))) : strong_rank_condition (has_top (has_top num)) := sorry --non-trivial
lemma new_lemma_58327 (h0 : topological_space (semigroup (has_to_string (ring Type)))) : regular_space (semigroup (has_to_string (ring Type))) := sorry --non-trivial
lemma new_lemma_58328 (h1 : add_group (encodable (has_norm char))) : is_add_cyclic (encodable (has_norm char)) := sorry --non-trivial
lemma new_lemma_58329 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (monoid_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (monoid_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_58330 (h0 : add_monoid (boolean_algebra (ring linarith.comp))) : add_monoid.fg (boolean_algebra (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_58331 (h1 : has_le (normed_field (normed_field (has_ssubset linarith.ineq)))) (h2 : normed_field (normed_field (has_ssubset linarith.ineq))) : is_max h2 := sorry --non-trivial
lemma new_lemma_58332 (h0 : topological_space (uniform_space (mul_one_class string.iterator_imp))) : totally_disconnected_space (uniform_space (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_58333 (h0 : functor.comp cancel_comm_monoid_with_zero boolean_algebra Type) : @unique_factorization_monoid.{1} (boolean_algebra.{1} Type) (@functor.comp.run.{1 1 1} cancel_comm_monoid_with_zero.{1} boolean_algebra.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_58334 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_58335 (h0 : functor.add_const (filter (has_nndist Type)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_58336 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_58337 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_58338 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_58339 (h0 : topological_space (boolean_algebra (comm_group (comm_group Type)))) : irreducible_space (boolean_algebra (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_58340 (h0 : topological_space (linear_ordered_add_comm_group (has_ssubset fun_info))) : t0_space (linear_ordered_add_comm_group (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_58341 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) name) : @totally_separated_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_58342 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (finset.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (finset.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_58343 (h0 : has_mem.mem (has_top fun_info) has_emptyc.emptyc) : @discrete_topology.{0} (has_top.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_58344 (h0 : functor.add_const (group (canonically_ordered_add_monoid empty)) empty) : @is_cyclic.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_58345 (h0 : group (free_add_monoid empty)) : group.fg (free_add_monoid empty) := sorry --non-trivial
lemma new_lemma_58346 (h0 : functor.add_const (ordered_add_comm_monoid (cancel_monoid environment.implicit_infer_kind)) name) : @archimedean.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_58347 (h0 : ring (normed_field (comm_ring (has_nnnorm (comm_ring char))))) : strong_rank_condition (normed_field (comm_ring (has_nnnorm (comm_ring char)))) := sorry --non-trivial
lemma new_lemma_58348 (h0 : group (has_pos_part (has_pos_part linarith.comp))) : group.fg (has_pos_part (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_58349 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (add_right_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_right_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_58350 (h0 : functor.add_const (ring (has_add pos)) (has_neg linarith.comp)) : @rank_condition.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} pos)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_58351 (h0 : list (has_star congr_arg_kind)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_58352 (h0 : preorder ereal) (h1 : set ereal) : set.is_pwo h1 := sorry --non-trivial
lemma new_lemma_58353 (h0 : fin has_zero.zero) : @is_simple_group.{0} (ordered_comm_monoid.{0} real) (@matrix.vec_empty.{0} (group.{0} (ordered_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_58354 (h1 : group (complete_semilattice_Sup linarith.comp_source)) : normalizer_condition (complete_semilattice_Sup linarith.comp_source) := sorry --non-trivial
lemma new_lemma_58355 (h0 : not (uniform_space (add_right_cancel_monoid num) -> false)) : @complete_space.{0} (add_right_cancel_monoid.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (add_right_cancel_monoid.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_58356 (h0 : ring (has_bot empty)) : is_domain (has_bot empty) := sorry --non-trivial
lemma new_lemma_58357 (h0 : prod (add_group (semiring congr_arg_kind)) (add_group (semiring congr_arg_kind))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_58358 (h0 : topological_space (ordered_comm_monoid (has_nndist Type))) : preirreducible_space (ordered_comm_monoid (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_58359 (h0 : functor.add_const (cancel_comm_monoid_with_zero (canonically_ordered_monoid pos)) linarith.comp) : @unique_factorization_monoid.{0} (canonically_ordered_monoid.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (canonically_ordered_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_58360 (h0 : ring (generalized_boolean_algebra (ring (has_pos_part linarith.comp)))) : strong_rank_condition (generalized_boolean_algebra (ring (has_pos_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_58361 (h0 : functor.add_const (topological_space (ring Type)) (has_add name)) : @irreducible_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_58362 (h0 : group (ring (canonically_ordered_comm_semiring Type))) : normalizer_condition (ring (canonically_ordered_comm_semiring Type)) := sorry --non-trivial
lemma new_lemma_58363 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_disconnected_space.{0} (linear_ordered_add_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (linear_ordered_add_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_58364 (h0 : complete_lattice (has_lt enat)) : is_compactly_generated (has_lt enat) := sorry --non-trivial
lemma new_lemma_58365 (h2 : ring (complete_semilattice_Sup congr_arg_kind)) : strong_rank_condition (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_58366 (h0 : topological_space (has_ssubset (uniform_space to_additive.value_type))) : totally_disconnected_space (has_ssubset (uniform_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_58367 (h0 : add_group (uniform_space (has_lt (normed_field linarith.comp_source)))) : is_add_cyclic (uniform_space (has_lt (normed_field linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_58368 (h0 : topological_space (finset (ring pos))) : regular_space (finset (ring pos)) := sorry --non-trivial
lemma new_lemma_58369 (h0 : topological_space (generalized_boolean_algebra name)) : t0_space (generalized_boolean_algebra name) := sorry --non-trivial
lemma new_lemma_58370 (h0 : topological_space (boolean_algebra (has_to_string (has_add unsigned)))) : preconnected_space (boolean_algebra (has_to_string (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_58371 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_58372 (h0 : not (topological_space (distrib_lattice linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (distrib_lattice.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib_lattice.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_58373 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_58374 (h0 : topological_space (generalized_boolean_algebra (canonically_ordered_monoid real))) : discrete_topology (generalized_boolean_algebra (canonically_ordered_monoid real)) := sorry --non-trivial
lemma new_lemma_58375 (h0 : add_monoid (has_norm (semiring empty))) : add_monoid.fg (has_norm (semiring empty)) := sorry --non-trivial
lemma new_lemma_58376 (h0 : functor.add_const (prod (ordered_ring num) (ordered_ring num)) (semiring empty)) : id_rel (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_58377 (h0 : functor.add_const (complete_lattice (ordered_ring congr_arg_kind)) (semiring num)) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_ring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_ring.{0} congr_arg_kind)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_58378 (h0 : not (ring (has_append fun_info) -> false)) : @is_domain.{0} (has_append.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (has_append.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_58379 (h0 : functor.add_const (uniform_space (group_with_zero unsigned)) congr_arg_kind) : @complete_space.{0} (group_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (group_with_zero.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_58380 (h0 : functor.add_const (monoid (has_add name)) linarith.comp) : @monoid.fg.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (has_add.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_58381 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_right_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_58382 (h0 : functor.add_const (uniform_space (boolean_algebra.core Type)) linarith.comp) : @complete_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (boolean_algebra.core.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_58383 (h0 : ring (normed_comm_ring (has_add (has_add name)))) : rank_condition (normed_comm_ring (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_58384 (h0 : ring (ordered_comm_monoid (ring Type))) : is_domain (ordered_comm_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_58385 (h0 : topological_space (has_emptyc (has_top linarith.comp_source))) : irreducible_space (has_emptyc (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_58386 (h0 : not (add_monoid (has_top congr_arg_kind) -> false)) : @add_monoid.fg.{0} (has_top.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_monoid.{0} (has_top.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_58387 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_58388 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_58389 (h0 : ring (has_norm (has_top linarith.comp_source))) : rank_condition (has_norm (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_58390 (h0 : list (has_pos_part Type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_58391 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} h0 (linear_ordered_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_58392 (h0 : has_mem.mem (has_norm congr_arg_kind) has_emptyc.emptyc) : @is_cyclic.{0} (has_norm.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type group.{0} (has_norm.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_58393 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) (finset pos)) : @totally_separated_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_ring.{1} Type)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_58394 (h0 : uniform_space (distrib fun_info)) : complete_space (distrib fun_info) := sorry --non-trivial
lemma new_lemma_58395 (h0 : not (has_mem.mem (has_top num) has_emptyc.emptyc -> false)) : @is_compactly_generated.{0} (has_top.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_top.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_58396 (h0 : complete_lattice (canonically_ordered_add_monoid unsigned)) : is_atomistic (canonically_ordered_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_58397 (h0 : functor.add_const (topological_space (comm_group environment.implicit_infer_kind)) Type) : @locally_compact_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_58398 (h0 : topological_space (linear_ordered_comm_group (option (option (option ennreal))))) : topological_space.separable_space (linear_ordered_comm_group (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_58399 (h0 : add_group (add_left_cancel_monoid (has_nnnorm linarith.comp_source))) : is_add_cyclic (add_left_cancel_monoid (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_58400 (h0 : not (complete_lattice (metric_space to_additive.value_type) -> false)) : @is_compactly_generated.{0} (metric_space.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (metric_space.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_58401 (h0 : functor.add_const (topological_space (cancel_monoid unsigned)) (normed_comm_ring pos)) : @irreducible_space.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} unsigned)) (normed_comm_ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_58402 (h0 : list (measurable_space (has_inv (has_inv to_additive.value_type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_58403 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_58404 (h0 : topological_space (finset (has_to_string Type))) : totally_disconnected_space (finset (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_58405 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_58406 (h0 : function.extfun Type topological_space) : @t0_space.{0} (complete_semilattice_Sup.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_58407 (h0 : function.extfun Type ring) : @is_domain.{0} (has_emptyc.{0} (random_gen.{0} linarith.ineq)) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_emptyc.{0} (random_gen.{0} linarith.ineq)))  := sorry --non-trivial
lemma new_lemma_58408 (h0 : functor.add_const (complete_lattice (boolean_algebra Type)) environment.implicit_infer_kind) : @complete_lattice.is_Sup_finite_compact.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (boolean_algebra.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_58409 (h0 : topological_space (simple_graph environment.projection_info)) : t0_space (simple_graph environment.projection_info) := sorry --non-trivial
lemma new_lemma_58410 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (boolean_algebra.core.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_58411 (h0 : has_lt (mul_one_class (nondiscrete_normed_field std_gen))) : no_max_order (mul_one_class (nondiscrete_normed_field std_gen)) := sorry --non-trivial
lemma new_lemma_58412 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (has_pos_part.{0} pos) (@matrix.vec_empty.{0} (add_group.{0} (has_pos_part.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_58413 (h0 : ordered_add_comm_monoid (has_Inf (finset (has_add name)))) : archimedean (has_Inf (finset (has_add name))) := sorry --non-trivial
lemma new_lemma_58414 (h0 : not (filter (metric_space linarith.comp) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_58415 (h0 : add_group (has_compl string_imp)) : is_add_cyclic (has_compl string_imp) := sorry --non-trivial
lemma new_lemma_58416 (h0 : topological_space (semi_normed_ring (random_gen (random_gen char)))) : t0_space (semi_normed_ring (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_58417 (h0 : function.extfun Type group) : @normalizer_condition.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_58418 (h0 : topological_space (has_to_string pos)) : preconnected_space (has_to_string pos) := sorry --non-trivial
lemma new_lemma_58419 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (comm_semigroup.{0} linarith.comp) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (comm_semigroup.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_58420 (h0 : thunk (fin has_zero.zero)) : @id.{1} Prop (@matrix.vec_empty.{0} Prop (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@trace_call_stack.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_58421 (h0 : topological_space (bin_tree (semiring (semiring unsigned)))) : irreducible_space (bin_tree (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_58422 (h0 : topological_space (add_cancel_monoid (comm_group (has_neg_part pos)))) : discrete_topology (add_cancel_monoid (comm_group (has_neg_part pos))) := sorry --non-trivial
lemma new_lemma_58423 (h0 : complete_lattice (linear_ordered_semiring (has_top empty))) : is_atomistic (linear_ordered_semiring (has_top empty)) := sorry --non-trivial
lemma new_lemma_58424 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_58425 (h0 : topological_space (has_one (has_top congr_arg_kind))) : irreducible_space (has_one (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_58426 (h0 : function.extfun Type (functor.comp topological_space add_cancel_monoid)) : @preconnected_space.{0} (add_cancel_monoid.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} add_cancel_monoid.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_58427 (h0 : group (random_gen (has_nnnorm (has_nnnorm to_additive.value_type)))) : is_cyclic (random_gen (has_nnnorm (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_58428 (h0 : function.extfun (Type 1) ring) : @rank_condition.{1} (comm_group.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (comm_group.{1} Type))  := sorry --non-trivial
lemma new_lemma_58429 (h0 : functor.add_const (topological_space (ordered_ring unsigned)) num) : @irreducible_space.{0} (ordered_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_ring.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_58430 (h0 : list (group_with_zero congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_58431 (h0 : function.extfun nat fin) : @normalizer_condition.{0} (normed_lattice_add_comm_group.{0} real) (@matrix.vec_empty.{0} (group.{0} (normed_lattice_add_comm_group.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_58432 (h0 : not (filter (semiring num) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_58433 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_58434 (h0 : topological_space (boolean_algebra (comm_semigroup pos))) : t1_space (boolean_algebra (comm_semigroup pos)) := sorry --non-trivial
lemma new_lemma_58435 (h0 : filter (normed_group (semiring (semiring empty)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_58436 (h0 : functor.add_const (ring (has_to_string pos)) environment.implicit_infer_kind) : @is_domain.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_58437 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) pos) : @archimedean.{0} (has_neg.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) pos h0) (has_neg.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_58438 (h0 : monoid (complete_distrib_lattice name)) : monoid.fg (complete_distrib_lattice name) := sorry --non-trivial
lemma new_lemma_58439 (h0 : finset (boolean_algebra.core (boolean_algebra.core pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_58440 (h0 : functor.add_const (list (add_left_cancel_semigroup num)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_58441 (h0 : ring (has_compl string.iterator_imp)) : strong_rank_condition (has_compl string.iterator_imp) := sorry --non-trivial
lemma new_lemma_58442 (h0 : group (has_neg (has_add (finset (finset (has_add (finset name))))))) : is_cyclic (has_neg (has_add (finset (finset (has_add (finset name)))))) := sorry --non-trivial
lemma new_lemma_58443 (h0 : has_neg (has_ssubset fun_info)) (h1 : measurable_space (has_ssubset fun_info)) : has_measurable_neg (has_ssubset fun_info) := sorry --non-trivial
lemma new_lemma_58444 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_58445 (h0 : topological_space (has_to_string (add_cancel_monoid Type))) : normal_space (has_to_string (add_cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_58446 (h0 : topological_space (measurable_space fun_info)) : path_connected_space (measurable_space fun_info) := sorry --non-trivial
lemma new_lemma_58447 (h0 : group (cancel_monoid (has_nndist (finset name)))) : group.fg (cancel_monoid (has_nndist (finset name))) := sorry --non-trivial
lemma new_lemma_58448 (h0 : functor.comp add_group normed_comm_ring name) : @is_add_cyclic.{0} (normed_comm_ring.{0} name) (@functor.comp.run.{0 0 0} add_group.{0} normed_comm_ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_58449 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_58450 (h0 : topological_space (cancel_monoid (has_nndist ennreal))) : locally_compact_space (cancel_monoid (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_58451 (h0 : function.extfun Type group) : @is_cyclic.{0} (add_left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (add_left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_58452 (h0 : ring (ordered_comm_monoid (canonically_linear_ordered_monoid Type))) : is_principal_ideal_ring (ordered_comm_monoid (canonically_linear_ordered_monoid Type)) := sorry --non-trivial
lemma new_lemma_58453 (h0 : not (topological_space (with_one linarith.comp_source) -> false)) : @t0_space.{0} (with_one.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_58454 (h0 : functor.add_const (ordered_add_comm_monoid (finset unsigned)) name) : @archimedean.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (finset.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_58455 (h0 : ring (has_Inf (has_Inf (finset Type)))) : is_principal_ideal_ring (has_Inf (has_Inf (finset Type))) := sorry --non-trivial
lemma new_lemma_58456 (h0 : filter (has_inter (option empty))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_58457 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (left_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (left_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_58458 (h1 : topological_space (measurable_space linarith.comp_source)) : totally_separated_space (measurable_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_58459 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_58460 (h0 : filter (non_assoc_semiring (semiring (semiring (semiring (semiring (semiring empty))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_58461 (h0 : has_lt (has_nnnorm reducibility_hints)) : no_max_order (has_nnnorm reducibility_hints) := sorry --non-trivial
lemma new_lemma_58462 (h0 : functor.add_const (complete_lattice (semigroup Type)) name) : @is_compactly_generated.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (semigroup.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_58463 (h0 : ordered_add_comm_monoid (linear_ordered_field (option (option (option ennreal))))) : archimedean (linear_ordered_field (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_58464 (h0 : add_group (has_add char)) : is_add_cyclic (has_add char) := sorry --non-trivial
lemma new_lemma_58465 (h0 : topological_space (id to_additive.value_type)) : path_connected_space (id to_additive.value_type) := sorry --non-trivial
lemma new_lemma_58466 (h0 : list (add_comm_monoid (boolean_algebra (has_Inf name)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_58467 (h0 : functor.add_const (ring (finset name)) (option (option (option (option (option pos)))))) : @is_principal_ideal_ring.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} name)) (option.{0} (option.{0} (option.{0} (option.{0} (option.{0} pos))))) h0)  := sorry --non-trivial
lemma new_lemma_58468 (h0 : add_monoid (omega_complete_partial_order (option empty))) : add_monoid.fg (omega_complete_partial_order (option empty)) := sorry --non-trivial
lemma new_lemma_58469 (h1 : ring (dlist (random_gen to_additive.value_type))) : is_domain (dlist (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_58470 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_compactly_generated.{0} (with_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (with_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_58471 (h0 : functor.add_const (ring (add_cancel_monoid environment.implicit_infer_kind)) name) : @strong_rank_condition.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_58472 (h0 : uniform_space (has_nndist (has_add pos))) : complete_space (has_nndist (has_add pos)) := sorry --non-trivial
lemma new_lemma_58473 (h0 : measurable_space linarith.comp -> measurable_space linarith.comp -> measurable_space linarith.comp) : is_right_cancel (measurable_space linarith.comp) h0 := sorry --non-trivial
lemma new_lemma_58474 (h0 : not (topological_space (has_norm congr_arg_kind) -> false)) (h1 : option (topological_space (has_norm congr_arg_kind))) : @totally_separated_space.{0} (has_norm.{0} congr_arg_kind) (@option.lhoare.{0} (topological_space.{0} (has_norm.{0} congr_arg_kind)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} congr_arg_kind)) h0) h1)  := sorry --non-trivial
lemma new_lemma_58475 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @separated_space.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (has_bot.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_58476 (h0 : topological_space (monoid (option unsigned))) : totally_disconnected_space (monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_58477 (h0 : group (normed_comm_ring (option (option pos)))) : normalizer_condition (normed_comm_ring (option (option pos))) := sorry --non-trivial
lemma new_lemma_58478 (h0 : functor.add_const (function.extfun Type complete_lattice) pos) : @complete_lattice.is_Sup_finite_compact.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) pos h0) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_58479 (h0 : add_monoid (ordered_comm_monoid (finset (has_neg (has_neg name))))) : add_monoid.fg (ordered_comm_monoid (finset (has_neg (has_neg name)))) := sorry --non-trivial
lemma new_lemma_58480 (h0 : cancel_comm_monoid_with_zero (has_pos_part name)) : unique_factorization_monoid (has_pos_part name) := sorry --non-trivial
lemma new_lemma_58481 (h1 : group (has_emptyc num)) : normalizer_condition (has_emptyc num) := sorry --non-trivial
lemma new_lemma_58482 (h0 : finset (canonically_ordered_comm_semiring Type)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_58483 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_58484 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_Inf.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_Inf.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_58485 (h0 : monoid (denumerable linarith.comp_source)) : monoid.fg (denumerable linarith.comp_source) := sorry --non-trivial
lemma new_lemma_58486 (h2 : group (has_add (has_nnnorm linarith.comp_source))) : is_cyclic (has_add (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_58487 (h0 : functor.add_const (semiring (has_zero unsigned)) (has_sdiff (normed_comm_ring (has_neg linarith.comp)))) : @is_noetherian_ring.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (has_zero.{0} unsigned)) (has_sdiff.{0} (normed_comm_ring.{0} (has_neg.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_58488 (h1 : uniform_space (random_gen (metric_space (metric_space (metric_space to_additive.value_type))))) : complete_space (random_gen (metric_space (metric_space (metric_space to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_58489 (h0 : ordered_add_comm_monoid (as_linear_order empty)) : archimedean (as_linear_order empty) := sorry --non-trivial
lemma new_lemma_58490 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (dlist.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (dlist.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_58491 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (has_star.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (has_star.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_58492 (h0 : ring (has_pos_part pos)) : strong_rank_condition (has_pos_part pos) := sorry --non-trivial
lemma new_lemma_58493 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_58494 (h0 : list (linear_ordered_add_comm_group (with_zero to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_58495 (h0 : uniform_space (linear_ordered_cancel_comm_monoid (option empty))) : separated_space (linear_ordered_cancel_comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_58496 (h0 : add_monoid (random_gen (has_norm unsigned))) : add_monoid.fg (random_gen (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_58497 (h0 : functor.add_const (group (semigroup ennreal)) pos) : @normalizer_condition.{0} (semigroup.{0} ennreal) (@functor.add_const.run.{0 0} (group.{0} (semigroup.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_58498 (h0 : ring (option (option (option ennreal)))) : strong_rank_condition (option (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_58499 (h0 : not (complete_lattice to_additive.value_type -> false)) : @complete_lattice.is_Sup_finite_compact.{0} to_additive.value_type (@classical.by_contradiction'.{1} (complete_lattice.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_58500 (h0 : topological_space (has_compl (mul_one_class linarith.ineq))) : t0_space (has_compl (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_58501 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_58502 (h0 : add_group (ring (boolean_algebra Type))) : is_add_cyclic (ring (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_58503 (h0 : ring (has_nnnorm environment.projection_info)) : is_domain (has_nnnorm environment.projection_info) := sorry --non-trivial
lemma new_lemma_58504 (h0 : add_group (canonically_ordered_monoid (has_neg (generalized_boolean_algebra (has_Inf real))))) : is_add_cyclic (canonically_ordered_monoid (has_neg (generalized_boolean_algebra (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_58505 (h0 : group (has_neg (has_add (add_comm_monoid (has_neg_part Type))))) : is_simple_group (has_neg (has_add (add_comm_monoid (has_neg_part Type)))) := sorry --non-trivial
lemma new_lemma_58506 (h0 : function.extfun Type topological_space) : @t0_space.{0} (semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_58507 (h0 : finset (normed_comm_ring (comm_monoid unsigned))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_58508 (h0 : topological_space (has_Inf (has_pos_part (has_pos_part name)))) : topological_space.separable_space (has_Inf (has_pos_part (has_pos_part name))) := sorry --non-trivial
lemma new_lemma_58509 (h0 : list (ring Type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_58510 (h0 : functor.add_const (finset (has_zero Type)) name) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_58511 (h0 : functor.add_const (topological_space (linear_ordered_field empty)) (option (option num))) : @normal_space.{0} (linear_ordered_field.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} empty)) (option.{0} (option.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_58512 (h0 : topological_space (normed_linear_ordered_group (semiring num))) : t1_space (normed_linear_ordered_group (semiring num)) := sorry --non-trivial
lemma new_lemma_58513 (h0 : ring (id linarith.ineq)) : strong_rank_condition (id linarith.ineq) := sorry --non-trivial
lemma new_lemma_58514 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (encodable.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (encodable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_58515 (h0 : functor.add_const (ring (has_pos_part linarith.comp)) Type) : @is_domain.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (has_pos_part.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_58516 (h1 : uniform_space (measurable_space num)) : separated_space (measurable_space num) := sorry --non-trivial
lemma new_lemma_58517 (h0 : functor.add_const (complete_lattice (boolean_algebra name)) name) : @is_compactly_generated.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_58518 (h0 : normed_group (semi_normed_comm_ring string_imp)) : set.univ h0 := sorry --trivial
lemma new_lemma_58519 (h0 : topological_space (add_group (semiring (semiring empty)))) : locally_compact_space (add_group (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_58520 (h0 : ring (has_one empty)) : is_principal_ideal_ring (has_one empty) := sorry --non-trivial
lemma new_lemma_58521 (h0 : complete_lattice (with_bot (has_norm (semiring empty)))) : is_atomistic (with_bot (has_norm (semiring empty))) := sorry --non-trivial
lemma new_lemma_58522 (h0 : finset (complete_distrib_lattice (has_pos_part Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_58523 (h0 : complete_lattice (metric_space (has_top (semiring linarith.comp)))) : complete_lattice.is_Sup_finite_compact (metric_space (has_top (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_58524 (h0 : topological_space (semiring (semiring fun_info))) : totally_separated_space (semiring (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_58525 (h0 : functor.add_const (filter (pseudo_metric_space pos)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_58526 (h0 : filter (ordered_comm_ring (has_to_string linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_58527 (h0 : prod (mul_zero_class name) (mul_zero_class name)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_58528 (h0 : function.extfun Type (functor.comp complete_lattice finset)) : @complete_lattice.is_Sup_finite_compact.{0} (finset.{0} unsigned) (@functor.comp.run.{0 0 0} complete_lattice.{0} finset.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} complete_lattice.{0} finset.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_58529 (h0 : functor.add_const (function.extfun (Type 1) group) linarith.comp) : @is_cyclic.{1} Type (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) linarith.comp h0) Type)  := sorry --non-trivial
lemma new_lemma_58530 (h0 : topological_space (add_comm_monoid num)) : preconnected_space (add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_58531 (h0 : functor.add_const (topological_space (plift num)) congr_arg_kind) : @irreducible_space.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_58532 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} fun_info (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) fun_info)  := sorry --non-trivial
lemma new_lemma_58533 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (dlist.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (dlist.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_58534 (h0 : complete_lattice (has_bot congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (has_bot congr_arg_kind) := sorry --non-trivial
lemma new_lemma_58535 (h0 : uniform_space (has_inv (has_top (has_top (measurable_space fun_info))))) : complete_space (has_inv (has_top (has_top (measurable_space fun_info)))) := sorry --non-trivial
lemma new_lemma_58536 (h0 : function.extfun Type (functor.add_const (ring (is_R_or_C empty)))) : @rank_condition.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (is_R_or_C.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} (is_R_or_C.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_58537 (h0 : functor.add_const (finset (finset linarith.comp)) environment.implicit_infer_kind) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_58538 (h2 : set (nondiscrete_normed_field string.iterator_imp)) : set.finite h2 := sorry --non-trivial
lemma new_lemma_58539 (h0 : functor.add_const (group (add_cancel_monoid linarith.comp)) linarith.comp) : @is_simple_group.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_58540 (h0 : functor.add_const (topological_space (group_with_zero ennreal)) num) : @totally_separated_space.{0} (group_with_zero.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (group_with_zero.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_58541 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_58542 (h0 : functor.add_const (complete_lattice (ring (boolean_algebra (has_add linarith.comp)))) name) : @complete_lattice.is_Sup_finite_compact.{0} (ring.{0} (boolean_algebra.{0} (has_add.{0} linarith.comp))) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ring.{0} (boolean_algebra.{0} (has_add.{0} linarith.comp)))) name h0)  := sorry --non-trivial
lemma new_lemma_58543 (h0 : ring (semi_normed_comm_ring (has_nnnorm char))) : is_domain (semi_normed_comm_ring (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_58544 (h0 : topological_space (has_neg (has_pos_part linarith.comp))) : discrete_topology (has_neg (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_58545 (h0 : ring (denumerable (has_inv to_additive.value_type))) : strong_rank_condition (denumerable (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_58546 (h0 : functor.add_const (group (ordered_comm_ring pos)) pos) : @group.fg.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (ordered_comm_ring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_58547 (h0 : function.extfun Type ring) : @rank_condition.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_58548 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) (has_to_string pos)) : @preirreducible_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) (has_to_string.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_58549 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_58550 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : list.nodup (function.extfun_app (function.extfun_app h0 list) (comm_group Type)) := sorry --non-trivial
lemma new_lemma_58551 (h0 : topological_space (finset (has_pos_part pos))) : totally_disconnected_space (finset (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_58552 (h0 : topological_space (uniform_space (has_nnnorm linarith.ineq))) : totally_disconnected_space (uniform_space (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_58553 (h0 : functor.add_const (topological_space (right_cancel_semigroup Type)) pos) : @totally_disconnected_space.{1} (right_cancel_semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (right_cancel_semigroup.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_58554 (h0 : boolean_algebra (has_pos_part (has_neg name)) -> boolean_algebra (has_pos_part (has_neg name)) -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_58555 (h1 : group (has_emptyc (has_norm (has_norm fun_info)))) : normalizer_condition (has_emptyc (has_norm (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_58556 (h0 : ring (has_add (has_add pos))) : rank_condition (has_add (has_add pos)) := sorry --non-trivial
lemma new_lemma_58557 (h1 : topological_space (add_cancel_comm_monoid char)) : path_connected_space (add_cancel_comm_monoid char) := sorry --non-trivial
lemma new_lemma_58558 (h0 : linear_ordered_semiring empty -> linear_ordered_semiring empty -> Prop) : is_strict_order (linear_ordered_semiring empty) h0 := sorry --non-trivial
lemma new_lemma_58559 (h0 : function.extfun Type (functor.add_const (complete_lattice (left_cancel_monoid empty)))) : @complete_lattice.is_Sup_finite_compact.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} empty)) (option.{0} empty) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} empty))) h0 (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_58560 (h0 : functor.add_const (ordered_comm_monoid (add_cancel_monoid name)) Type) : @has_exists_mul_of_le.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (add_cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_58561 (h0 : ring (normed_comm_ring (ring linarith.comp))) : strong_rank_condition (normed_comm_ring (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_58562 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_58563 (h0 : functor.add_const (topological_space (normed_lattice_add_comm_group linarith.comp)) (has_add pos)) : @t1_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_58564 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (canonically_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (canonically_ordered_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_58565 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) name) : @archimedean.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) name h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_58566 (h0 : functor.add_const (group (has_Inf pos)) (has_neg (has_neg Type))) : @is_simple_group.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (has_Inf.{0} pos)) (has_neg.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_58567 (h0 : topological_space (add_comm_monoid (boolean_algebra (boolean_algebra (boolean_algebra name))))) : irreducible_space (add_comm_monoid (boolean_algebra (boolean_algebra (boolean_algebra name)))) := sorry --non-trivial
lemma new_lemma_58568 (h0 : complete_lattice (add_comm_monoid (has_add name))) : is_atomistic (add_comm_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_58569 (h0 : has_mem.mem (has_norm unsigned) has_emptyc.emptyc) : @is_domain.{0} (has_norm.{0} unsigned) (@finset.pi.empty.{1 0} Type ring.{0} (has_norm.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_58570 (h0 : ring (has_zero (has_Inf (has_neg environment.implicit_infer_kind)))) : strong_rank_condition (has_zero (has_Inf (has_neg environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_58571 (h0 : topological_space (finset (finset (has_nndist Type)))) : normal_space (finset (finset (has_nndist Type))) := sorry --non-trivial
lemma new_lemma_58572 (h1 : topological_space (has_norm to_additive.value_type)) : irreducible_space (has_norm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_58573 (h0 : topological_space (has_top (semiring (has_emptyc linarith.comp_source)))) : totally_separated_space (has_top (semiring (has_emptyc linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_58574 (h0 : functor.add_const (list (boolean_algebra Type)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_58575 (h0 : filter (dlist (has_inv (has_inv fun_info)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_58576 (h0 : not (has_mem.mem (has_top fun_info) has_emptyc.emptyc -> false)) : @discrete_topology.{0} (has_top.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} fun_info) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} fun_info) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_58577 (h0 : ordered_add_comm_monoid (sub_neg_monoid (has_Inf name))) : archimedean (sub_neg_monoid (has_Inf name)) := sorry --non-trivial
lemma new_lemma_58578 (h0 : complete_lattice (has_nnnorm enat)) : complete_lattice.is_Sup_finite_compact (has_nnnorm enat) := sorry --non-trivial
lemma new_lemma_58579 (h0 : add_group (comm_monoid num)) : is_add_cyclic (comm_monoid num) := sorry --non-trivial
lemma new_lemma_58580 (h0 : uniform_space (add_cancel_monoid (boolean_algebra pos))) : separated_space (add_cancel_monoid (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_58581 (h0 : complete_lattice (distrib_lattice (random_gen string_imp))) : complete_lattice.is_Sup_finite_compact (distrib_lattice (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_58582 (h0 : topological_space (has_neg (has_add (has_add (comm_group Type))))) : t0_space (has_neg (has_add (has_add (comm_group Type)))) := sorry --non-trivial
lemma new_lemma_58583 (h0 : functor.add_const (finset (ring Type)) (ring name)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_58584 (h4 : uniform_space char) : complete_space char := sorry --non-trivial
lemma new_lemma_58585 (h0 : functor.add_const (ring (semigroup Type)) pos) : @is_domain.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (semigroup.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_58586 (h0 : functor.add_const (complete_lattice (has_edist unsigned)) empty) : @is_compactly_generated.{0} (has_edist.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_edist.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_58587 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_58588 (h0 : not (function.extfun Type preorder -> false)) (h1 : not (function.extfun (has_neg num) (fun (x : has_neg num), Prop) -> false)) : @set.ord_connected.{0} (has_neg.{0} num) (@function.extfun_app.{2 1} Type preorder.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type preorder.{0}) h0) (has_neg.{0} num)) (@function.extfun_app.{1 1} (has_neg.{0} num) (λ (x : has_neg.{0} num), Prop) (@classical.by_contradiction'.{1} (function.extfun.{1 1} (has_neg.{0} num) (λ (x : has_neg.{0} num), Prop)) h1))  := sorry --non-trivial
lemma new_lemma_58589 (h0 : filter (pseudo_metric_space (option ennreal))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_58590 (h0 : group (has_union (has_norm (has_norm linarith.comp)))) : normalizer_condition (has_union (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_58591 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @t0_space.{0} fun_info (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) fun_info)  := sorry --non-trivial
lemma new_lemma_58592 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) linarith.comp) : @path_connected_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_58593 (h0 : ring (fintype (has_nnnorm char))) : is_domain (fintype (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_58594 (h0 : group (id congr_arg_kind)) : group.fg (id congr_arg_kind) := sorry --non-trivial
lemma new_lemma_58595 (h0 : set (has_nnnorm (semi_normed_comm_ring (semi_normed_comm_ring linarith.comp_source)))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_58596 (h0 : has_lt (normed_field (add_comm_semigroup linarith.ineq))) : no_max_order (normed_field (add_comm_semigroup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_58597 (h0 : monoid (linear_ordered_semiring linarith.comp)) (h1 : submonoid (linear_ordered_semiring linarith.comp)) : submonoid.fg h1 := sorry --non-trivial
lemma new_lemma_58598 (h0 : topological_space (ordered_comm_ring (ordered_comm_monoid linarith.comp))) : totally_separated_space (ordered_comm_ring (ordered_comm_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_58599 (h0 : topological_space (canonically_ordered_monoid (has_add (ordered_comm_monoid Type)))) : regular_space (canonically_ordered_monoid (has_add (ordered_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_58600 (h1 : topological_space (id congr_arg_kind)) : totally_disconnected_space (id congr_arg_kind) := sorry --non-trivial
lemma new_lemma_58601 (h0 : functor.add_const (ordered_comm_monoid (finset Type)) (has_nndist environment.implicit_infer_kind)) : @has_exists_mul_of_le.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (finset.{1} Type)) (has_nndist.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_58602 (h0 : topological_space (boolean_algebra (has_neg (finset linarith.comp)))) : totally_disconnected_space (boolean_algebra (has_neg (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_58603 (h0 : topological_space (has_union num)) : t0_space (has_union num) := sorry --non-trivial
lemma new_lemma_58604 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_58605 (h0 : semiring (has_add (has_nndist (semigroup linarith.comp)))) : is_noetherian_ring (has_add (has_nndist (semigroup linarith.comp))) := sorry --non-trivial
lemma new_lemma_58606 (h0 : cancel_comm_monoid_with_zero (comm_semigroup real)) : unique_factorization_monoid (comm_semigroup real) := sorry --non-trivial
lemma new_lemma_58607 (h0 : topological_space (ordered_comm_monoid (boolean_algebra pos))) : locally_compact_space (ordered_comm_monoid (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_58608 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_58609 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_58610 (h0 : topological_space (has_div (mul_one_class enat))) : t0_space (has_div (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_58611 (h2 : ring (distrib linarith.comp_source)) : is_domain (distrib linarith.comp_source) := sorry --non-trivial
lemma new_lemma_58612 (h0 : has_mem.mem (has_append (has_nnnorm linarith.ineq)) has_emptyc.emptyc) : @path_connected_space.{0} (has_append.{0} (has_nnnorm.{0} linarith.ineq)) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_append.{0} (has_nnnorm.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_58613 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (measurable_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measurable_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_58614 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_58615 (h0 : functor.add_const (filter (ring Type)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_58616 (h0 : add_group (add_left_cancel_monoid (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm char)))))) : is_add_cyclic (add_left_cancel_monoid (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm char))))) := sorry --non-trivial
lemma new_lemma_58617 (h0 : list (has_neg_part environment.implicit_infer_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_58618 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_zero unsigned)) := sorry --non-trivial
lemma new_lemma_58619 (h0 : functor.add_const (topological_space (has_star congr_arg_kind)) (semiring (semiring (semiring congr_arg_kind)))) : @totally_disconnected_space.{0} (has_star.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} congr_arg_kind)) (semiring.{0} (semiring.{0} (semiring.{0} congr_arg_kind))) h0)  := sorry --non-trivial
lemma new_lemma_58620 (h0 : functor.add_const (topological_space (preorder unsigned)) (semiring (semiring empty))) : @totally_separated_space.{0} (preorder.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} unsigned)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_58621 (h0 : functor.add_const (topological_space (add_comm_monoid environment.implicit_infer_kind)) Type) : @locally_compact_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (topological_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_58622 (h0 : topological_space (ring (has_add linarith.comp))) : t0_space (ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_58623 (h0 : topological_space (monoid ennreal)) : path_connected_space (monoid ennreal) := sorry --non-trivial
lemma new_lemma_58624 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_58625 (h0 : topological_space (has_to_string ennreal)) : topological_space.separable_space (has_to_string ennreal) := sorry --non-trivial
lemma new_lemma_58626 (h0 : semiring (add_comm_semigroup (omega_complete_partial_order fun_info))) (h1 : add_comm_semigroup (omega_complete_partial_order fun_info)) : even h1 := sorry --non-trivial
lemma new_lemma_58627 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (linear_ordered_comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_58628 (h0 : topological_space (boolean_algebra (has_nndist pos))) : irreducible_space (boolean_algebra (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_58629 (h0 : topological_space (has_to_string unsigned)) : path_connected_space (has_to_string unsigned) := sorry --non-trivial
lemma new_lemma_58630 (h0 : ring (has_norm (has_top (has_norm num)))) : strong_rank_condition (has_norm (has_top (has_norm num))) := sorry --non-trivial
lemma new_lemma_58631 (h0 : topological_space (simple_graph (mul_one_class to_additive.value_type))) (h1 : preorder (simple_graph (mul_one_class to_additive.value_type))) : order_topology (simple_graph (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_58632 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_neg.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_neg.{0} name))  := sorry --non-trivial
lemma new_lemma_58633 (h0 : function.extfun (Type 1) topological_space) : @totally_separated_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_58634 (h0 : functor.add_const (function.extfun Type group) name) : @group.fg.{0} pos (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) name h0) pos)  := sorry --non-trivial
lemma new_lemma_58635 (h0 : topological_space (ordered_comm_ring (has_neg linarith.comp))) : topological_space.separable_space (ordered_comm_ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_58636 (h0 : list (semigroup Type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_58637 (h0 : functor.add_const (topological_space (normed_comm_ring unsigned)) environment.implicit_infer_kind) : @normal_space.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_58638 (h0 : functor.add_const (topological_space (has_nndist empty)) empty) : @locally_compact_space.{0} (has_nndist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_58639 (h0 : functor.add_const (ordered_add_comm_monoid (canonically_ordered_comm_semiring pos)) Type) : @archimedean.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (canonically_ordered_comm_semiring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_58640 (h0 : complete_lattice (has_zero unsigned)) : is_compactly_generated (has_zero unsigned) := sorry --non-trivial
lemma new_lemma_58641 (h0 : add_group (normed_comm_ring (comm_group (comm_group Type)))) : is_add_cyclic (normed_comm_ring (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_58642 (h0 : has_mem.mem to_additive.value_type has_emptyc.emptyc) : @rank_condition.{0} to_additive.value_type (@finset.pi.empty.{1 0} Type ring.{0} to_additive.value_type h0)  := sorry --non-trivial
lemma new_lemma_58643 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) h0) (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_58644 (h0 : group (add_cancel_monoid (option (option (option ennreal))))) : is_simple_group (add_cancel_monoid (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_58645 (h1 : ring (uniform_space (has_nnnorm char))) : is_domain (uniform_space (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_58646 (h0 : not (topological_space (normed_group fun_info) -> false)) : @path_connected_space.{0} (normed_group.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_58647 (h0 : topological_space (ring (normed_comm_ring name))) : preirreducible_space (ring (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_58648 (h2 : ring (semi_normed_comm_ring (comm_ring to_additive.value_type))) : is_domain (semi_normed_comm_ring (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_58649 (h0 : topological_space (with_bot (has_emptyc (has_emptyc congr_arg_kind)))) : path_connected_space (with_bot (has_emptyc (has_emptyc congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_58650 (h0 : list (dlist (random_gen string_imp))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_58651 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_58652 (h0 : functor.add_const (topological_space (has_zero name)) (comm_group name)) : @t1_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_58653 (h0 : topological_space (has_neg (has_Inf name))) : normal_space (has_neg (has_Inf name)) := sorry --non-trivial
lemma new_lemma_58654 (h0 : add_group (ring (has_neg_part Type))) : is_add_cyclic (ring (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_58655 (h3 : has_nnnorm (random_gen char) -> has_nnnorm (random_gen char) -> Prop) : is_total_preorder (has_nnnorm (random_gen char)) h3 := sorry --non-trivial
lemma new_lemma_58656 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_58657 (h0 : topological_space (has_norm (random_gen (has_nnnorm (random_gen linarith.ineq))))) : t0_space (has_norm (random_gen (has_nnnorm (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_58658 (h0 : uniform_space (ordered_comm_monoid (has_neg (has_neg Type)))) : separated_space (ordered_comm_monoid (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_58659 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (preorder.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (preorder.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_58660 (h1 : not (ring (distrib_lattice fun_info) -> false)) : @is_domain.{0} (distrib_lattice.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (distrib_lattice.{0} fun_info)) h1)  := sorry --non-trivial
lemma new_lemma_58661 (h0 : topological_space (has_Sup (option unsigned))) : locally_compact_space (has_Sup (option unsigned)) := sorry --non-trivial
lemma new_lemma_58662 (h0 : monoid (ordered_cancel_add_comm_monoid (option (option ennreal)))) : monoid.fg (ordered_cancel_add_comm_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_58663 (h0 : topological_space (preorder congr_arg_kind)) : preirreducible_space (preorder congr_arg_kind) := sorry --non-trivial
lemma new_lemma_58664 (h0 : add_group string) : is_add_cyclic string := sorry --non-trivial
lemma new_lemma_58665 (h0 : topological_space (has_nndist (group_with_zero name))) : discrete_topology (has_nndist (group_with_zero name)) := sorry --non-trivial
lemma new_lemma_58666 (h0 : functor.add_const (complete_lattice (has_Sup empty)) (semiring (semiring congr_arg_kind))) : @complete_lattice.is_Sup_finite_compact.{0} (has_Sup.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_Sup.{0} empty)) (semiring.{0} (semiring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_58667 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_58668 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_58669 (h0 : ring (normed_comm_ring (has_add Type))) : rank_condition (normed_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_58670 (h0 : semiring (with_one fun_info)) (h1 : uniform_space (polynomial (with_one fun_info))) : complete_space (polynomial (with_one fun_info)) := sorry --non-trivial
lemma new_lemma_58671 (h0 : functor.add_const (ring (has_pos_part pos)) Type) : @rank_condition.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_pos_part.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_58672 (h0 : topological_space (measurable_space linarith.comp)) : irreducible_space (measurable_space linarith.comp) := sorry --non-trivial
lemma new_lemma_58673 (h0 : monoid (canonically_linear_ordered_monoid (has_pos_part (has_pos_part (has_add name))))) : monoid.fg (canonically_linear_ordered_monoid (has_pos_part (has_pos_part (has_add name)))) := sorry --non-trivial
lemma new_lemma_58674 (h1 : (linarith.ineq -> char) -> char) (h2 : char -> char -> Prop) (h3 : linarith.ineq -> char) : set.separates_points (order.preimage h1 h2 h3) := sorry --non-trivial
lemma new_lemma_58675 (h1 : topological_space (random_gen linarith.comp_source)) : path_connected_space (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_58676 (h0 : topological_space (add_comm_semigroup (mul_one_class (mul_one_class fun_info)))) : t0_space (add_comm_semigroup (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_58677 (h0 : uniform_space (ring (option unsigned))) : complete_space (ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_58678 (h0 : complete_lattice (normed_group (has_inv linarith.ineq))) : is_atomistic (normed_group (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_58679 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @unique_factorization_monoid.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 cancel_comm_monoid_with_zero.{1}) (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_58680 (h0 : semiring (has_union (has_top (semiring unsigned)))) : is_noetherian_ring (has_union (has_top (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_58681 (h0 : function.extfun (Type 1) topological_space) : @path_connected_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_58682 (h0 : semiring (ordered_cancel_add_comm_monoid ennreal)) : is_noetherian_ring (ordered_cancel_add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_58683 (h0 : ring (simple_graph (mul_one_class (mul_one_class (mul_one_class (mul_one_class fun_info)))))) : is_domain (simple_graph (mul_one_class (mul_one_class (mul_one_class (mul_one_class fun_info))))) := sorry --non-trivial
lemma new_lemma_58684 (h0 : functor.add_const (complete_lattice (boolean_algebra.core unsigned)) pos) : @is_compactly_generated.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_58685 (h0 : set (has_ssubset environment.projection_info)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_58686 (h0 : functor.add_const (function.extfun Type topological_space) (finset (ring pos))) : @normal_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (finset.{0} (ring.{0} pos)) h0) (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_58687 (h0 : topological_space (uniform_space (denumerable reducibility_hints))) : t0_space (uniform_space (denumerable reducibility_hints)) := sorry --non-trivial
lemma new_lemma_58688 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @topological_space.separable_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) Type)  := sorry --non-trivial
lemma new_lemma_58689 (h0 : functor.add_const (ring (has_to_string unsigned)) name) : @is_domain.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (has_to_string.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_58690 (h0 : not (ring (has_norm fun_info) -> false)) : @rank_condition.{0} (has_norm.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (has_norm.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_58691 (h0 : fin has_zero.zero) : @preconnected_space.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_58692 (h0 : ring (random_gen empty)) : rank_condition (random_gen empty) := sorry --non-trivial
lemma new_lemma_58693 (h0 : monoid (normed_group (comm_ring fun_info))) : monoid.fg (normed_group (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_58694 (h0 : list Prop) : list.ilast h0 := sorry --non-trivial
lemma new_lemma_58695 (h0 : ring (cancel_monoid (boolean_algebra (boolean_algebra.core (has_add unsigned))))) : rank_condition (cancel_monoid (boolean_algebra (boolean_algebra.core (has_add unsigned)))) := sorry --non-trivial
lemma new_lemma_58696 (h0 : functor.add_const (fin has_zero.zero) real) : @locally_compact_space.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (comm_semigroup.{1} Type)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) real h0))  := sorry --non-trivial
lemma new_lemma_58697 (h0 : complete_lattice (finset congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (finset congr_arg_kind) := sorry --non-trivial
lemma new_lemma_58698 (h0 : group (has_to_string (ring (has_neg (has_add Type))))) : is_simple_group (has_to_string (ring (has_neg (has_add Type)))) := sorry --non-trivial
lemma new_lemma_58699 (h0 : complete_lattice (has_to_string Type)) : is_atomistic (has_to_string Type) := sorry --non-trivial
lemma new_lemma_58700 (h0 : functor.add_const (topological_space (complete_distrib_lattice pos)) (has_Inf pos)) : @preirreducible_space.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_58701 (h0 : topological_space (ordered_comm_monoid (finset pos))) : path_connected_space (ordered_comm_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_58702 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_58703 (h0 : functor.add_const (ring (linear_ordered_field ennreal)) ennreal) : @strong_rank_condition.{0} (linear_ordered_field.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (linear_ordered_field.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_58704 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_58705 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_58706 (h0 : functor.add_const (topological_space (has_add Type)) Type) : @totally_separated_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_add.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_58707 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_58708 (h0 : topological_space (finset (boolean_algebra pos))) : sequential_space (finset (boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_58709 (h0 : ring (finset (finset (has_add Type)))) : is_domain (finset (finset (has_add Type))) := sorry --non-trivial
lemma new_lemma_58710 (h0 : ring (distrib (has_nnnorm (has_nnnorm (comm_ring (comm_ring fun_info)))))) : is_domain (distrib (has_nnnorm (has_nnnorm (comm_ring (comm_ring fun_info))))) := sorry --non-trivial
lemma new_lemma_58711 (h0 : complete_lattice (linear_ordered_add_comm_group reducibility_hints)) : is_compactly_generated (linear_ordered_add_comm_group reducibility_hints) := sorry --non-trivial
lemma new_lemma_58712 (h0 : functor.add_const (function.extfun Type topological_space) (has_to_string (mul_one_class Type))) : @regular_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) (has_to_string.{1} (mul_one_class.{1} Type)) h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_58713 (h0 : cancel_comm_monoid_with_zero (normed_lattice_add_comm_group pos)) : unique_factorization_monoid (normed_lattice_add_comm_group pos) := sorry --non-trivial
lemma new_lemma_58714 (h0 : complete_lattice (random_gen (has_top linarith.ineq))) : is_compactly_generated (random_gen (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_58715 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_sub.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_sub.{0} num))  := sorry --non-trivial
lemma new_lemma_58716 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_58717 (h0 : prod (has_dist (option (option congr_arg_kind))) (has_dist (option (option congr_arg_kind)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_58718 (h0 : semiring (monoid pos)) : is_noetherian_ring (monoid pos) := sorry --non-trivial
lemma new_lemma_58719 (h0 : group (has_emptyc (semiring empty))) : is_cyclic (has_emptyc (semiring empty)) := sorry --non-trivial
lemma new_lemma_58720 (h0 : fin has_zero.zero) : @add_monoid.fg.{0} (has_pos_part.{0} real) (@matrix.vec_empty.{0} (add_monoid.{0} (has_pos_part.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_58721 (h1 : topological_space to_additive.value_type) (h2 : preorder to_additive.value_type) : order_closed_topology to_additive.value_type := sorry --non-trivial
lemma new_lemma_58722 (h1 : complete_lattice (dlist linarith.ineq)) : is_compactly_generated (dlist linarith.ineq) := sorry --non-trivial
lemma new_lemma_58723 (h0 : not (has_mem.mem fun_info has_emptyc.emptyc -> false)) : @is_domain.{0} fun_info (@finset.pi.empty.{1 0} Type ring.{0} fun_info (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) fun_info (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_58724 (h0 : functor.add_const (ring (has_zero linarith.comp)) (has_neg Type)) : @strong_rank_condition.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (has_zero.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_58725 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) (option unsigned)) : @t0_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_58726 (h0 : topological_space (has_bot (has_neg (has_Inf pos)))) : topological_space.separable_space (has_bot (has_neg (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_58727 (h0 : group (with_one num)) : is_cyclic (with_one num) := sorry --non-trivial
lemma new_lemma_58728 (h0 : uniform_space (normed_field linarith.ineq)) : complete_space (normed_field linarith.ineq) := sorry --non-trivial
lemma new_lemma_58729 (h0 : topological_space (pseudo_metric_space (option empty))) : discrete_topology (pseudo_metric_space (option empty)) := sorry --non-trivial
lemma new_lemma_58730 (h0 : functor.add_const (topological_space (has_to_string unsigned)) pos) : @totally_separated_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_58731 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} real.angle (@function.extfun_app.{2 1} Type ring.{0} h0 real.angle)  := sorry --non-trivial
lemma new_lemma_58732 (h0 : uniform_space (has_ssubset (mul_one_class reducibility_hints))) : complete_space (has_ssubset (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_58733 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot congr_arg_kind))) : @is_compactly_generated.{0} (with_bot.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_bot.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_58734 (h0 : set (char -> std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_58735 (h0 : not (topological_space (id unsigned) -> false)) : @preirreducible_space.{0} (@id.{2} Type unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (@id.{2} Type unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_58736 (h0 : functor.comp semiring add_comm_monoid name) : @is_noetherian_ring.{0} (add_comm_monoid.{0} name) (@functor.comp.run.{0 0 0} semiring.{0} add_comm_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_58737 (h0 : function.extfun nat fin) : @regular_space.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (complete_distrib_lattice.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_58738 (h0 : topological_space (has_bot (sub_neg_monoid Type))) : preconnected_space (has_bot (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_58739 (h0 : group (has_Sup unsigned)) : group.fg (has_Sup unsigned) := sorry --non-trivial
lemma new_lemma_58740 (h0 : fin has_zero.zero) : @is_simple_group.{0} (sub_neg_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (sub_neg_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_58741 (h0 : functor.add_const (topological_space (has_nndist Type)) environment.implicit_infer_kind) : @regular_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_58742 (h0 : topological_space (has_zero (has_zero (has_pos_part (finset (finset (ring (has_Inf pos)))))))) : t0_space (has_zero (has_zero (has_pos_part (finset (finset (ring (has_Inf pos))))))) := sorry --non-trivial
lemma new_lemma_58743 (h0 : uniform_space (ring (has_pos_part (has_add Type)))) : separated_space (ring (has_pos_part (has_add Type))) := sorry --non-trivial
lemma new_lemma_58744 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) Type) : @totally_separated_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_58745 (h0 : function.extfun (Type 1) filter) : countable_Inter_filter (function.extfun_app h0 (ordered_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_58746 (h0 : functor.add_const (group (generalized_boolean_algebra name)) linarith.comp) : @group.fg.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (group.{0} (generalized_boolean_algebra.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_58747 (h0 : add_group (cancel_monoid (option (option (option (option (option (option (option ennreal))))))))) : is_add_cyclic (cancel_monoid (option (option (option (option (option (option (option ennreal)))))))) := sorry --non-trivial
lemma new_lemma_58748 (h0 : uniform_space (add_comm_semigroup environment.implicit_infer_kind)) : complete_space (add_comm_semigroup environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_58749 (h0 : add_monoid (has_neg_part (has_neg_part name))) : add_monoid.fg (has_neg_part (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_58750 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_58751 (h0 : function.extfun Type (functor.add_const (topological_space znum))) : @normal_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} znum)) h0 empty))  := sorry --non-trivial
lemma new_lemma_58752 (h0 : group (has_pos_part (sub_neg_monoid (has_Inf Type)))) : is_cyclic (has_pos_part (sub_neg_monoid (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_58753 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_58754 (h0 : group (add_left_cancel_semigroup congr_arg_kind)) : is_cyclic (add_left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_58755 (h0 : ring (is_R_or_C (has_edist unsigned))) : strong_rank_condition (is_R_or_C (has_edist unsigned)) := sorry --non-trivial
lemma new_lemma_58756 (h0 : function.extfun Type ring) : @is_domain.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_58757 (h0 : monoid (has_norm unsigned)) : monoid.fg (has_norm unsigned) := sorry --non-trivial
lemma new_lemma_58758 (h0 : functor.add_const (ring (linear_ordered_comm_monoid_with_zero unsigned)) (option (option unsigned))) : @is_principal_ideal_ring.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned)) (option.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_58759 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_58760 (h0 : functor.add_const (topological_space (ring linarith.comp)) linarith.comp) : @loc_path_connected_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_58761 (h0 : not (topological_space (add_right_cancel_monoid num) -> false)) : @t0_space.{0} (add_right_cancel_monoid.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (add_right_cancel_monoid.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_58762 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (boolean_algebra.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (boolean_algebra.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_58763 (h0 : functor.add_const (function.extfun Type semiring) Type) : @is_noetherian_ring.{0} (complete_lattice.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type semiring.{0}) Type h0) (complete_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_58764 (h0 : uniform_space (complete_distrib_lattice (has_add pos))) : complete_space (complete_distrib_lattice (has_add pos)) := sorry --non-trivial
lemma new_lemma_58765 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (left_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_58766 (h0 : has_mem.mem (normed_group fun_info) has_emptyc.emptyc) : @discrete_topology.{0} (normed_group.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_58767 (h0 : group (mul_zero_class (semiring num))) : group.fg (mul_zero_class (semiring num)) := sorry --non-trivial
lemma new_lemma_58768 (h0 : topological_space (sub_neg_monoid (has_Inf real))) : preconnected_space (sub_neg_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_58769 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (canonically_ordered_add_monoid empty)) := sorry --non-trivial
lemma new_lemma_58770 (h0 : monoid (normed_comm_ring (finset environment.implicit_infer_kind))) : monoid.fg (normed_comm_ring (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_58771 (h0 : functor.add_const (topological_space (has_nndist unsigned)) Type) : @irreducible_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_58772 (h0 : group (preorder congr_arg_kind)) : group.fg (preorder congr_arg_kind) := sorry --non-trivial
lemma new_lemma_58773 (h0 : functor.add_const (list (normed_comm_ring pos)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_58774 (h0 : ring (has_one (semiring num))) : rank_condition (has_one (semiring num)) := sorry --non-trivial
lemma new_lemma_58775 (h1 : has_le string.iterator_imp) (h2 : string.iterator_imp) : is_bot h2 := sorry --non-trivial
lemma new_lemma_58776 (h0 : topological_space (ordered_comm_ring (has_bot Type))) : t1_space (ordered_comm_ring (has_bot Type)) := sorry --non-trivial
lemma new_lemma_58777 (h0 : functor.add_const (function.extfun Type group) Type) : @is_cyclic.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_58778 (h0 : topological_space (denumerable (comm_ring linarith.comp_source))) : t0_space (denumerable (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_58779 (h0 : topological_space (complete_distrib_lattice num)) : t1_space (complete_distrib_lattice num) := sorry --non-trivial
lemma new_lemma_58780 (h0 : monoid (has_emptyc (has_top num))) : monoid.fg (has_emptyc (has_top num)) := sorry --non-trivial
lemma new_lemma_58781 (h0 : functor.comp topological_space cancel_monoid name) : @locally_compact_space.{0} (cancel_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_58782 (h1 : add_group (simple_graph string_imp)) : is_add_cyclic (simple_graph string_imp) := sorry --non-trivial
lemma new_lemma_58783 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (has_star.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_star.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_58784 (h0 : set (linear_ordered_comm_group_with_zero (mul_one_class char))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_58785 (h0 : cancel_comm_monoid_with_zero (has_neg (finset name))) : unique_factorization_monoid (has_neg (finset name)) := sorry --non-trivial
lemma new_lemma_58786 (h0 : topological_space (uniform_space string_imp)) : path_connected_space (uniform_space string_imp) := sorry --non-trivial
lemma new_lemma_58787 (h0 : group (has_norm fun_info)) : is_cyclic (has_norm fun_info) := sorry --non-trivial
lemma new_lemma_58788 (h0 : ordered_add_comm_monoid (sub_neg_monoid (has_bot real))) : archimedean (sub_neg_monoid (has_bot real)) := sorry --non-trivial
lemma new_lemma_58789 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (has_union.{0} (has_norm.{0} congr_arg_kind)) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_union.{0} (has_norm.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_58790 (h0 : ring (simple_graph (option (option empty)))) : strong_rank_condition (simple_graph (option (option empty))) := sorry --non-trivial
lemma new_lemma_58791 (h0 : ring (uniform_space (has_nnnorm string.iterator_imp))) : rank_condition (uniform_space (has_nnnorm string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_58792 (h0 : functor.add_const (add_group (cancel_monoid Type)) environment.implicit_infer_kind) : @is_add_cyclic.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (cancel_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_58793 (h0 : complete_lattice (random_gen (has_inv fun_info))) : is_atomistic (random_gen (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_58794 (h0 h1 : multiset (normed_field (comm_ring char))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_58795 (h0 : topological_space (random_gen (has_norm num))) : irreducible_space (random_gen (has_norm num)) := sorry --non-trivial
lemma new_lemma_58796 (h0 : topological_space (complete_distrib_lattice (has_Inf (comm_semigroup (comm_semigroup pos))))) : locally_compact_space (complete_distrib_lattice (has_Inf (comm_semigroup (comm_semigroup pos)))) := sorry --non-trivial
lemma new_lemma_58797 (h0 : ring (add_cancel_monoid (has_add (has_add (has_add (has_add (has_to_string name))))))) : rank_condition (add_cancel_monoid (has_add (has_add (has_add (has_add (has_to_string name)))))) := sorry --non-trivial
lemma new_lemma_58798 (h0 : topological_space (has_nndist (has_add name))) : preirreducible_space (has_nndist (has_add name)) := sorry --non-trivial
lemma new_lemma_58799 (h0 : ring (encodable (has_nnnorm linarith.comp_source))) : is_domain (encodable (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_58800 (h0 : functor.add_const (topological_space (semiring congr_arg_kind)) num) : @locally_compact_space.{0} (semiring.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_58801 (h0 : add_group (uniform_space string.iterator_imp)) : is_add_cyclic (uniform_space string.iterator_imp) := sorry --non-trivial
lemma new_lemma_58802 (h0 : group (with_one (semiring (semiring (has_top empty))))) : group.fg (with_one (semiring (semiring (has_top empty)))) := sorry --non-trivial
lemma new_lemma_58803 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_58804 (h0 : fin has_zero.zero) : @topological_space.separable_space.{0} (has_pos_part.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_58805 (h0 : complete_lattice (non_assoc_semiring (semiring empty))) : is_compactly_generated (non_assoc_semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_58806 (h0 : functor.add_const (uniform_space (comm_group Type)) environment.implicit_infer_kind) : @separated_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (comm_group.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_58807 (h0 : topological_space (with_one (random_gen linarith.comp_source))) : totally_separated_space (with_one (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_58808 (h0 : complete_lattice (semigroup (comm_group name))) : is_compactly_generated (semigroup (comm_group name)) := sorry --non-trivial
lemma new_lemma_58809 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : list.nodup (function.extfun_app (function.extfun_app h0 list) (simple_graph Type)) := sorry --non-trivial
lemma new_lemma_58810 (h0 : set (mul_one_class (mul_one_class enat))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_58811 (h0 : functor.add_const (ring nnreal) empty) : @is_domain.{0} nnreal (@functor.add_const.run.{0 0} (ring.{0} nnreal) empty h0)  := sorry --non-trivial
lemma new_lemma_58812 (h0 : functor.add_const (topological_space (measure_theory.measure_space empty)) empty) : @t1_space.{0} (measure_theory.measure_space.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (measure_theory.measure_space.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_58813 (h0 : topological_space (linear_ordered_add_comm_group_with_top (option unsigned))) : path_connected_space (linear_ordered_add_comm_group_with_top (option unsigned)) := sorry --non-trivial
lemma new_lemma_58814 (h1 : topological_space (add_comm_semigroup linarith.ineq)) (h2 : preorder (add_comm_semigroup linarith.ineq)) : order_closed_topology (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_58815 (h1 : topological_space (has_div linarith.comp_source)) : t0_space (has_div linarith.comp_source) := sorry --non-trivial
lemma new_lemma_58816 (h0 : topological_space (add_cancel_monoid num)) : totally_separated_space (add_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_58817 (h0 h1 : multiset (has_ssubset string.iterator_imp)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_58818 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_58819 (h0 : functor.add_const (ring (has_add pos)) linarith.comp) : @rank_condition.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_58820 (h0 : has_le (has_norm linarith.comp_source)) (h1 : has_norm linarith.comp_source) : is_min h1 := sorry --non-trivial
lemma new_lemma_58821 (h0 : topological_space subsingleton_info) : totally_separated_space subsingleton_info := sorry --non-trivial
lemma new_lemma_58822 (h0 : topological_space (option (option (semiring (ordered_cancel_comm_monoid empty))))) : t0_space (option (option (semiring (ordered_cancel_comm_monoid empty)))) := sorry --non-trivial
lemma new_lemma_58823 (h0 : topological_space (pseudo_metric_space ennreal)) : locally_compact_space (pseudo_metric_space ennreal) := sorry --non-trivial
lemma new_lemma_58824 (h0 : add_group (ring (option (option (option (option (option (option (option (option ennreal)))))))))) : is_add_cyclic (ring (option (option (option (option (option (option (option (option ennreal))))))))) := sorry --non-trivial
lemma new_lemma_58825 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) name) : @loc_path_connected_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (normed_comm_ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_58826 (h0 : not (ring (option num) -> false)) : @rank_condition.{0} (option.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (option.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_58827 (h0 : functor.add_const (topological_space (preorder num)) congr_arg_kind) : @topological_space.separable_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_58828 (h1 : has_mem.mem (has_norm congr_arg_kind) has_emptyc.emptyc) : @group.fg.{0} (has_norm.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type group.{0} (has_norm.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_58829 (h0 : topological_space (has_pos_part (has_add (has_add linarith.comp)))) : irreducible_space (has_pos_part (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_58830 (h0 : functor.add_const (semiring (normed_comm_ring environment.implicit_infer_kind)) name) : @is_noetherian_ring.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (semiring.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_58831 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (normed_group.{0} string_imp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (normed_group.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_58832 (h0 : has_scalar (option unsigned) unsigned) (h1 : has_faithful_scalar (option unsigned) unsigned -> has_faithful_scalar (option unsigned) unsigned -> Prop) : irreflexive h1 := sorry --non-trivial
lemma new_lemma_58833 (h0 : topological_space (boolean_algebra.core (has_to_string pos))) : sequential_space (boolean_algebra.core (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_58834 (h0 : function.extfun (Type 1) topological_space) : @irreducible_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_58835 (h0 : add_group (has_pos_part (ordered_comm_monoid Type))) : is_add_cyclic (has_pos_part (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_58836 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_58837 (h0 : ordered_comm_monoid (semigroup pos)) : has_exists_mul_of_le (semigroup pos) := sorry --non-trivial
lemma new_lemma_58838 (h0 : functor.add_const (complete_lattice (free_add_monoid empty)) unsigned) : @is_compactly_generated.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (free_add_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_58839 (h0 : topological_space (plift empty)) : normal_space (plift empty) := sorry --non-trivial
lemma new_lemma_58840 (h0 : group (has_union (semiring (has_norm (has_norm (semiring num)))))) : normalizer_condition (has_union (semiring (has_norm (has_norm (semiring num))))) := sorry --non-trivial
lemma new_lemma_58841 (h0 : not (filter (distrib fun_info) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_58842 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_58843 (h0 : topological_space (normed_group (has_norm num))) : preirreducible_space (normed_group (has_norm num)) := sorry --non-trivial
lemma new_lemma_58844 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_58845 (h0 : group (has_Sup congr_arg_kind)) : is_simple_group (has_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_58846 (h0 : function.extfun (Type 1) uniform_space) : @complete_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_58847 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_58848 (h0 : functor.add_const (ordered_add_comm_monoid (add_comm_monoid unsigned)) unsigned) : @archimedean.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_comm_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_58849 (h0 : function.extfun Type group) : @is_cyclic.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_add_comm_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_58850 (h0 : group (has_nndist (finset name))) : is_simple_group (has_nndist (finset name)) := sorry --non-trivial
lemma new_lemma_58851 (h0 : functor.add_const (ordered_add_comm_monoid (has_to_string pos)) name) : @archimedean.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_to_string.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_58852 (h0 : functor.add_const (topological_space (semigroup name)) linarith.comp) : @preconnected_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_58853 (h0 : function.extfun Type (functor.add_const (filter real.angle))) : countable_Inter_filter (functor.add_const.run (function.extfun_app h0 name)) := sorry --non-trivial
lemma new_lemma_58854 (h0 : ring (has_append (has_nnnorm (has_nnnorm (has_nnnorm char))))) : is_domain (has_append (has_nnnorm (has_nnnorm (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_58855 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_58856 (h0 : functor.comp filter mul_zero_class pos) : @filter.ne_bot.{0} (mul_zero_class.{0} pos) (@functor.comp.run.{0 0 0} filter.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} filter.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} filter.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} filter.{0} mul_zero_class.{0} pos h0))))  := sorry --non-trivial
lemma new_lemma_58857 (h0 : group (complete_distrib_lattice (has_Inf Type))) : group.fg (complete_distrib_lattice (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_58858 (h0 : complete_lattice (has_top num)) : complete_lattice.is_Sup_finite_compact (has_top num) := sorry --non-trivial
lemma new_lemma_58859 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} pos (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 pos)  := sorry --non-trivial
lemma new_lemma_58860 (h0 : topological_space (canonically_linear_ordered_monoid real)) : loc_path_connected_space (canonically_linear_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_58861 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @t0_space.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_58862 (h0 : topological_space (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source))))) : totally_disconnected_space (has_nnnorm (has_nnnorm (has_nnnorm (has_nnnorm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_58863 (h0 : functor.add_const (uniform_space (has_to_string linarith.comp)) linarith.comp) : @separated_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_to_string.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_58864 (h0 : monoid (mul_zero_class (ordered_cancel_comm_monoid num))) : monoid.fg (mul_zero_class (ordered_cancel_comm_monoid num)) := sorry --non-trivial
lemma new_lemma_58865 (h0 : complete_lattice (add_cancel_comm_monoid to_additive.value_type)) : is_compactly_generated (add_cancel_comm_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_58866 (h0 : finset (ordered_comm_monoid (ring (has_pos_part (has_add linarith.comp))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_58867 (h0 : functor.add_const (finset (has_neg_part ennreal)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_58868 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_nnnorm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_nnnorm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_58869 (h0 : topological_space (canonically_linear_ordered_monoid (has_neg name))) : preconnected_space (canonically_linear_ordered_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_58870 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type monoid.{0} h0 (ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_58871 (h0 : ring (nondiscrete_normed_field (mul_one_class char))) : is_domain (nondiscrete_normed_field (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_58872 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @locally_compact_space.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_58873 (h0 : complete_lattice (canonically_ordered_comm_semiring empty)) : is_compactly_generated (canonically_ordered_comm_semiring empty) := sorry --non-trivial
lemma new_lemma_58874 (h2 : ring (uniform_space linarith.comp_source)) : is_domain (uniform_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_58875 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @complete_lattice.is_Sup_finite_compact.{1} (has_bot.{1} Type) (@matrix.vec_empty.{1} (complete_lattice.{1} (has_bot.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_58876 (h0 : group (normed_field char)) : is_cyclic (normed_field char) := sorry --non-trivial
lemma new_lemma_58877 (h0 : group (with_bot (has_norm (has_norm (has_norm linarith.comp_source))))) : is_cyclic (with_bot (has_norm (has_norm (has_norm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_58878 (h0 : list (canonically_ordered_comm_semiring (finset (finset (finset (finset pos)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_58879 (h0 : ordered_add_comm_monoid (add_comm_monoid (normed_comm_ring Type))) : archimedean (add_comm_monoid (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_58880 (h0 : list (has_nndist (has_add environment.implicit_infer_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_58881 (h0 : cancel_comm_monoid_with_zero (has_add (has_add name))) : unique_factorization_monoid (has_add (has_add name)) := sorry --non-trivial
lemma new_lemma_58882 (h0 : group (encodable (has_nnnorm (has_top (has_nnnorm (has_nnnorm to_additive.value_type)))))) : group.fg (encodable (has_nnnorm (has_top (has_nnnorm (has_nnnorm to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_58883 (h0 : topological_space (cancel_monoid (has_add (boolean_algebra.core (has_Sup znum))))) : t1_space (cancel_monoid (has_add (boolean_algebra.core (has_Sup znum)))) := sorry --non-trivial
lemma new_lemma_58884 (h0 : topological_space (semigroup (finset (ring linarith.comp)))) : regular_space (semigroup (finset (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_58885 (h0 : functor.add_const (group (has_inter congr_arg_kind)) unsigned) : @is_cyclic.{0} (has_inter.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (has_inter.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_58886 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @topological_space.separable_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_58887 (h0 : topological_space (ordered_cancel_add_comm_monoid empty)) : topological_space.separable_space (ordered_cancel_add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_58888 (h0 : topological_space (non_unital_non_assoc_semiring linarith.ineq)) : path_connected_space (non_unital_non_assoc_semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_58889 (h0 : list (simple_graph (has_neg (has_add (semigroup (ring linarith.comp)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_58890 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type ring.{0} h0 (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_58891 (h0 : ordered_add_comm_monoid (add_left_cancel_semigroup (semiring empty))) : archimedean (add_left_cancel_semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_58892 (h0 : functor.add_const (group (mul_zero_class name)) name) : @normalizer_condition.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (group.{0} (mul_zero_class.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_58893 (h0 : ordered_comm_monoid (comm_group (has_to_string pos))) : has_exists_mul_of_le (comm_group (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_58894 (h0 : functor.add_const (topological_space (semigroup pos)) unsigned) : @irreducible_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_58895 (h0 : topological_space (add_comm_semigroup enat)) : topological_space.separable_space (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_58896 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (linear_ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_58897 (h0 : prod (has_dist (option unsigned)) (has_dist (option unsigned))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_58898 (h0 : functor.add_const (ring (is_R_or_C num)) empty) : @rank_condition.{0} (is_R_or_C.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (is_R_or_C.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_58899 (h0 : group (canonically_ordered_monoid pos)) : group.fg (canonically_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_58900 (h0 : topological_space (linear_ordered_semiring (semiring num))) : t0_space (linear_ordered_semiring (semiring num)) := sorry --non-trivial
lemma new_lemma_58901 (h0 : complete_lattice (add_group (plift unsigned))) : is_compactly_generated (add_group (plift unsigned)) := sorry --non-trivial
lemma new_lemma_58902 (h0 : functor.add_const (topological_space (has_add name)) pos) : @loc_path_connected_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_58903 (h0 : add_group (has_emptyc (has_top (has_top (has_norm (has_norm fun_info)))))) : is_add_cyclic (has_emptyc (has_top (has_top (has_norm (has_norm fun_info))))) := sorry --non-trivial
lemma new_lemma_58904 (h0 : functor.add_const (complete_lattice (normed_comm_ring linarith.comp)) (ring Type)) : @is_compactly_generated.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (normed_comm_ring.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_58905 (h0 : not (ring (metric_space fun_info) -> false)) : @strong_rank_condition.{0} (metric_space.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (metric_space.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_58906 (h0 : ring (dlist reducibility_hints)) : rank_condition (dlist reducibility_hints) := sorry --non-trivial
lemma new_lemma_58907 (h0 : functor.add_const (function.extfun Type list) Type) : palindrome (function.extfun_app (functor.add_const.run h0) (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_58908 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (has_to_string.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} empty))  := sorry --non-trivial
lemma new_lemma_58909 (h0 : function.extfun Type (functor.comp topological_space linear_ordered_field)) : @t0_space.{0} (linear_ordered_field.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} linear_ordered_field.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} linear_ordered_field.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_58910 (h0 : functor.add_const (list (has_to_string unsigned)) name) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_58911 (h0 : list (has_add pos)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_58912 (h0 : ring (normed_comm_ring (has_add (normed_comm_ring name)))) : is_principal_ideal_ring (normed_comm_ring (has_add (normed_comm_ring name))) := sorry --non-trivial
lemma new_lemma_58913 (h0 : functor.add_const (topological_space (boolean_algebra pos)) linarith.comp) : @locally_compact_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_58914 (h0 : group (dlist (comm_ring to_additive.value_type))) : is_cyclic (dlist (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_58915 (h0 : topological_space (add_comm_monoid (has_add environment.implicit_infer_kind))) : irreducible_space (add_comm_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_58916 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_58917 (h0 : functor.add_const (function.extfun (Type 1) group) pos) : @is_cyclic.{1} Type (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) pos h0) Type)  := sorry --non-trivial
lemma new_lemma_58918 (h0 : ordered_add_comm_monoid (add_cancel_monoid (has_nndist Type))) : archimedean (add_cancel_monoid (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_58919 (h0 : topological_space (generalized_boolean_algebra (has_add (ring pos)))) : sequential_space (generalized_boolean_algebra (has_add (ring pos))) := sorry --non-trivial
lemma new_lemma_58920 (h0 : functor.add_const (filter (has_zero environment.implicit_infer_kind)) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_58921 (h0 : topological_space (add_cancel_monoid (finset linarith.comp))) : preconnected_space (add_cancel_monoid (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_58922 (h0 : list (measure_theory.measure_space (semiring empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_58923 (h0 : complete_lattice (canonically_ordered_monoid (has_add (has_add real)))) : is_atomistic (canonically_ordered_monoid (has_add (has_add real))) := sorry --non-trivial
lemma new_lemma_58924 (h0 : topological_space (linear_ordered_semiring empty)) : t0_space (linear_ordered_semiring empty) := sorry --non-trivial
lemma new_lemma_58925 (h0 : functor.add_const (complete_lattice (semigroup unsigned)) pos) : @is_atomistic.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_58926 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) name) : @preconnected_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_58927 (h0 : topological_space (boolean_algebra.core (boolean_algebra.core unsigned))) : preirreducible_space (boolean_algebra.core (boolean_algebra.core unsigned)) := sorry --non-trivial
lemma new_lemma_58928 (h0 : topological_space (has_pos_part (has_bot real))) : preirreducible_space (has_pos_part (has_bot real)) := sorry --non-trivial
lemma new_lemma_58929 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_58930 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_58931 (h0 : function.extfun Type topological_space) : @normal_space.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_58932 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_58933 (h0 : complete_lattice (linear_ordered_comm_group unsigned)) : is_compactly_generated (linear_ordered_comm_group unsigned) := sorry --non-trivial
lemma new_lemma_58934 (h1 : complete_lattice (normed_group to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (normed_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_58935 (h0 : functor.add_const (topological_space (has_star num)) unsigned) : @t1_space.{0} (has_star.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_58936 (h0 : ordered_add_comm_monoid (finset (finset Type))) : archimedean (finset (finset Type)) := sorry --non-trivial
lemma new_lemma_58937 (h0 : functor.add_const (monoid (boolean_algebra pos)) (has_pos_part Type)) : @monoid.fg.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (monoid.{0} (boolean_algebra.{0} pos)) (has_pos_part.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_58938 (h0 : add_group (has_add (has_pos_part pos))) : is_add_cyclic (has_add (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_58939 (h0 : list (cancel_monoid (has_add (has_add name)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_58940 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring Type)) Type) : @preirreducible_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (canonically_ordered_comm_semiring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_58941 (h0 : measurable_space ereal) (h1 : has_inf ereal) : has_measurable_inf ereal := sorry --non-trivial
lemma new_lemma_58942 (h1 : complete_lattice (has_nnnorm to_additive.value_type)) : is_compactly_generated (has_nnnorm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_58943 (h0 : topological_space (has_union (semiring num))) : locally_compact_space (has_union (semiring num)) := sorry --non-trivial
lemma new_lemma_58944 (h0 : functor.add_const (complete_lattice (has_nndist (has_to_string unsigned))) name) : @complete_lattice.is_Sup_finite_compact.{0} (has_nndist.{0} (has_to_string.{0} unsigned)) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_nndist.{0} (has_to_string.{0} unsigned))) name h0)  := sorry --non-trivial
lemma new_lemma_58945 (h0 : topological_space (comm_group (has_add (option pos)))) : t1_space (comm_group (has_add (option pos))) := sorry --non-trivial
lemma new_lemma_58946 (h1 : complete_lattice (uniform_space to_additive.value_type)) : is_compactly_generated (uniform_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_58947 (h0 : topological_space (complete_distrib_lattice (has_Inf pos))) : t0_space (complete_distrib_lattice (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_58948 (h0 : add_group (normed_comm_ring (add_cancel_monoid (comm_group pos)))) : is_add_cyclic (normed_comm_ring (add_cancel_monoid (comm_group pos))) := sorry --non-trivial
lemma new_lemma_58949 (h0 : topological_space (canonically_ordered_monoid (has_Inf linarith.comp))) : preirreducible_space (canonically_ordered_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_58950 (h0 : not (topological_space (has_lt linarith.ineq) -> false)) : @path_connected_space.{0} (has_lt.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_lt.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_58951 (h0 : monoid (linear_ordered_add_comm_group (has_top fun_info))) : monoid.fg (linear_ordered_add_comm_group (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_58952 (h0 : topological_space (boolean_algebra (has_nndist pos))) : t1_space (boolean_algebra (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_58953 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (linear_ordered_semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_58954 (h0 : topological_space (semi_normed_ring string_imp)) : totally_disconnected_space (semi_normed_ring string_imp) := sorry --non-trivial
lemma new_lemma_58955 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) (finset (finset pos))) : @t0_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) (finset.{0} (finset.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_58956 (h0 : filter (with_bot (random_gen linarith.ineq))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_58957 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_58958 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_58959 (h0 : topological_space (ordered_comm_monoid (ring name))) : t0_space (ordered_comm_monoid (ring name)) := sorry --non-trivial
lemma new_lemma_58960 (h0 : fin has_zero.zero) : @discrete_topology.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_58961 (h0 : add_group (linear_ordered_semiring (has_norm congr_arg_kind))) : is_add_cyclic (linear_ordered_semiring (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_58962 (h0 : not (uniform_space (random_gen linarith.ineq) -> false)) : @separated_space.{0} (random_gen.{0} linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (random_gen.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_58963 (h0 : uniform_space (ordered_comm_ring (has_add Type))) : separated_space (ordered_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_58964 (h0 : ordered_comm_monoid (complete_distrib_lattice (ordered_comm_monoid real))) : has_exists_mul_of_le (complete_distrib_lattice (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_58965 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_disconnected_space.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_norm.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_58966 (h0 : complete_lattice (has_le to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (has_le to_additive.value_type) := sorry --non-trivial
lemma new_lemma_58967 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (bin_tree empty)) := sorry --non-trivial
lemma new_lemma_58968 (h0 : topological_space (complete_linear_order (has_sub congr_arg_kind))) : totally_disconnected_space (complete_linear_order (has_sub congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_58969 (h0 : filter (finset empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_58970 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_58971 (h0 : topological_space (sub_neg_monoid (has_neg real))) : discrete_topology (sub_neg_monoid (has_neg real)) := sorry --non-trivial
lemma new_lemma_58972 (h0 : topological_space (random_gen linarith.ineq)) : totally_disconnected_space (random_gen linarith.ineq) := sorry --non-trivial
lemma new_lemma_58973 (h0 : topological_space (measurable_space (has_norm (has_norm (has_top linarith.comp_source))))) : irreducible_space (measurable_space (has_norm (has_norm (has_top linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_58974 (h0 : topological_space (has_dist congr_arg_kind)) : topological_space.separable_space (has_dist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_58975 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_ordered_add_comm_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_58976 (h1 : complete_lattice (mul_one_class enat)) : complete_lattice.is_Sup_finite_compact (mul_one_class enat) := sorry --non-trivial
lemma new_lemma_58977 (h0 : functor.add_const (cancel_comm_monoid_with_zero (free_add_monoid unsigned)) unsigned) : @unique_factorization_monoid.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (free_add_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_58978 (h0 : has_mul std_gen) (h1 : std_gen) : is_regular h1 := sorry --non-trivial
lemma new_lemma_58979 (h0 : ring (pseudo_emetric_space pos)) : rank_condition (pseudo_emetric_space pos) := sorry --non-trivial
lemma new_lemma_58980 (h0 : add_group (ring (has_neg (has_nndist Type)))) : is_add_cyclic (ring (has_neg (has_nndist Type))) := sorry --non-trivial
lemma new_lemma_58981 (h0 : functor.comp topological_space ring pos) : @t1_space.{0} (ring.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} ring.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_58982 (h0 : ordered_comm_monoid (add_cancel_monoid (ring (has_add pos)))) : has_exists_mul_of_le (add_cancel_monoid (ring (has_add pos))) := sorry --non-trivial
lemma new_lemma_58983 (h0 : complete_lattice (distrib reducibility_hints)) : complete_lattice.is_Sup_finite_compact (distrib reducibility_hints) := sorry --non-trivial
lemma new_lemma_58984 (h0 : topological_space (add_comm_monoid (has_neg (has_neg Type)))) : totally_separated_space (add_comm_monoid (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_58985 (h0 : functor.add_const (ordered_add_comm_monoid (normed_comm_ring Type)) (ring (ring pos))) : @archimedean.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (normed_comm_ring.{1} Type)) (ring.{0} (ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_58986 (h0 : topological_space (mul_one_class (right_cancel_semigroup fun_info))) (h1 : set (mul_one_class (right_cancel_semigroup fun_info))) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_58987 (h0 : topological_space (generalized_boolean_algebra (finset Type))) : totally_disconnected_space (generalized_boolean_algebra (finset Type)) := sorry --non-trivial
lemma new_lemma_58988 (h0 : complete_lattice (comm_group (option pos))) : complete_lattice.is_Sup_finite_compact (comm_group (option pos)) := sorry --non-trivial
lemma new_lemma_58989 (h0 : functor.add_const (topological_space (add_cancel_monoid empty)) unsigned) : @locally_compact_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_58990 (h0 : ring (distrib_lattice (has_norm (has_norm (has_norm to_additive.value_type))))) : rank_condition (distrib_lattice (has_norm (has_norm (has_norm to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_58991 (h0 : group (add_right_cancel_monoid unsigned)) : is_cyclic (add_right_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_58992 (h0 : topological_space (complete_distrib_lattice (has_neg environment.implicit_infer_kind))) : t1_space (complete_distrib_lattice (has_neg environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_58993 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (random_gen.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.ineq)))))) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (random_gen.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.ineq)))))))  := sorry --non-trivial
lemma new_lemma_58994 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_58995 (h0 : complete_lattice (linear_order congr_arg_kind)) : is_compactly_generated (linear_order congr_arg_kind) := sorry --non-trivial
lemma new_lemma_58996 (h0 : ring (with_bot (has_top unsigned))) : rank_condition (with_bot (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_58997 (h0 : functor.add_const (semiring (normed_linear_ordered_group unsigned)) congr_arg_kind) : @is_noetherian_ring.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (semiring.{0} (normed_linear_ordered_group.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_58998 (h0 : functor.add_const (add_group (normed_lattice_add_comm_group linarith.comp)) (has_add (has_Inf pos))) : @is_add_cyclic.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (normed_lattice_add_comm_group.{0} linarith.comp)) (has_add.{0} (has_Inf.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_58999 (h0 : topological_space (dlist linarith.comp_source)) : totally_disconnected_space (dlist linarith.comp_source) := sorry --non-trivial
lemma new_lemma_59000 (h1 : complete_lattice (has_add string_imp)) : complete_lattice.is_Sup_finite_compact (has_add string_imp) := sorry --non-trivial
lemma new_lemma_59001 (h0 : functor.add_const (function.extfun Type topological_space) name) : @loc_path_connected_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_59002 (h0 : functor.add_const (topological_space (ring linarith.comp)) (has_to_string (boolean_algebra (has_to_string pos)))) : @t0_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) (has_to_string.{0} (boolean_algebra.{0} (has_to_string.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_59003 (h0 : ennreal -> ennreal -> Prop) : is_total ennreal h0 := sorry --non-trivial
lemma new_lemma_59004 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_59005 (h0 : group (add_comm_monoid (has_Inf (sub_neg_monoid (has_Inf Type))))) : is_cyclic (add_comm_monoid (has_Inf (sub_neg_monoid (has_Inf Type)))) := sorry --non-trivial
lemma new_lemma_59006 (h1 : monoid (has_union (semiring empty))) : monoid.fg (has_union (semiring empty)) := sorry --non-trivial
lemma new_lemma_59007 (h0 : complete_lattice (non_unital_non_assoc_semiring string.iterator_imp)) : complete_lattice.is_Sup_finite_compact (non_unital_non_assoc_semiring string.iterator_imp) := sorry --non-trivial
lemma new_lemma_59008 (h3 : topological_space (comm_ring to_additive.value_type)) : totally_disconnected_space (comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_59009 (h0 : functor.add_const (complete_lattice (normed_comm_ring Type)) linarith.comp) : @is_compactly_generated.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (normed_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_59010 (h0 : filter (has_neg_part (has_add environment.implicit_infer_kind))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_59011 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) Type) : @regular_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_59012 (h0 : ring (boolean_algebra.core ennreal)) : is_domain (boolean_algebra.core ennreal) := sorry --non-trivial
lemma new_lemma_59013 (h0 : ring (semi_normed_comm_ring (random_gen (random_gen char)))) : rank_condition (semi_normed_comm_ring (random_gen (random_gen char))) := sorry --non-trivial
lemma new_lemma_59014 (h0 : topological_space (boolean_algebra.core (finset Type))) : regular_space (boolean_algebra.core (finset Type)) := sorry --non-trivial
lemma new_lemma_59015 (h0 : functor.add_const (add_group (canonically_ordered_comm_semiring pos)) Type) : @is_add_cyclic.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 1} (add_group.{0} (canonically_ordered_comm_semiring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_59016 (h0 : complete_lattice (has_norm (random_gen (random_gen (random_gen num))))) : is_atomistic (has_norm (random_gen (random_gen (random_gen num)))) := sorry --non-trivial
lemma new_lemma_59017 (h0 : functor.add_const (filter (has_add nnreal)) environment.implicit_infer_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_59018 (h0 : functor.add_const (topological_space (semigroup Type)) pos) : @totally_separated_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_59019 (h0 : topological_space (semigroup (ring Type))) : irreducible_space (semigroup (ring Type)) := sorry --non-trivial
lemma new_lemma_59020 (h0 : not (topological_space (complete_semilattice_Sup char) -> false)) : @locally_compact_space.{0} (complete_semilattice_Sup.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_59021 (h0 : topological_space (dlist (has_ssubset linarith.comp_source))) : locally_compact_space (dlist (has_ssubset linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_59022 (h0 : semiring (has_neg_part (option name))) : is_noetherian_ring (has_neg_part (option name)) := sorry --non-trivial
lemma new_lemma_59023 (h0 : topological_space (has_zero (has_add name))) : t1_space (has_zero (has_add name)) := sorry --non-trivial
lemma new_lemma_59024 (h0 : function.extfun Type ring) : @rank_condition.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_59025 (h0 : has_mem.mem (with_one num) has_emptyc.emptyc) : @separated_space.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type uniform_space.{0} (with_one.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_59026 (h0 : complete_lattice (canonically_ordered_monoid (has_neg Type))) : is_compactly_generated (canonically_ordered_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_59027 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (linear_ordered_cancel_comm_monoid.{0} (ordered_comm_group.{0} empty)) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} (ordered_comm_group.{0} empty)))  := sorry --non-trivial
lemma new_lemma_59028 (h1 : set (add_comm_semigroup ereal -> char)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_59029 (h0 : uniform_space (with_bot (semiring congr_arg_kind))) : complete_space (with_bot (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_59030 (h0 : functor.add_const (function.extfun (Type 1) ring) name) : @is_principal_ideal_ring.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) name h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_59031 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_59032 (h0 : add_group (has_emptyc (has_top num))) : is_add_cyclic (has_emptyc (has_top num)) := sorry --non-trivial
lemma new_lemma_59033 (h0 : topological_space (add_right_cancel_monoid (semiring (semiring empty)))) : discrete_topology (add_right_cancel_monoid (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_59034 (h0 : topological_space (has_Inf (has_neg (has_neg (has_neg pos))))) : totally_separated_space (has_Inf (has_neg (has_neg (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_59035 (h0 : group (comm_ring (topological_space (comm_ring reducibility_hints)))) : is_cyclic (comm_ring (topological_space (comm_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_59036 (h0 : function.extfun (Type 1) topological_space) : @sequential_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_59037 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_59038 (h0 : ordered_add_comm_monoid (has_zero environment.implicit_infer_kind)) : archimedean (has_zero environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_59039 (h0 : functor.add_const (function.extfun (Type 1) ring) (has_pos_part (ring linarith.comp))) : @is_principal_ideal_ring.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) (has_pos_part.{0} (ring.{0} linarith.comp)) h0) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_59040 (h0 : topological_space (complete_distrib_lattice (finset pos))) : totally_disconnected_space (complete_distrib_lattice (finset pos)) := sorry --non-trivial
lemma new_lemma_59041 (h0 : functor.add_const (topological_space (finset linarith.comp)) linarith.comp) : @loc_path_connected_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_59042 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (normed_lattice_add_comm_group.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (normed_lattice_add_comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_59043 (h0 : function.extfun Type topological_space) : @t0_space.{0} (distrib_lattice.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (distrib_lattice.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_59044 (h0 : ring (has_union congr_arg_kind)) : is_domain (has_union congr_arg_kind) := sorry --non-trivial
lemma new_lemma_59045 (h0 : filter (has_to_string (has_to_string (has_to_string name)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_59046 (h0 : functor.add_const (ring (add_comm_monoid pos)) (has_neg environment.implicit_infer_kind)) : @rank_condition.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} pos)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_59047 (h0 : group (has_bot (sub_neg_monoid real))) : group.fg (has_bot (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_59048 (h0 : functor.add_const (functor.add_const (topological_space pos) (has_Inf pos)) (ring pos)) : @topological_space.separable_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} pos) (has_Inf.{0} pos)) (ring.{0} pos) h0))  := sorry --non-trivial
lemma new_lemma_59049 (h0 : topological_space (finset (has_to_string (has_to_string linarith.comp)))) : loc_path_connected_space (finset (has_to_string (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_59050 (h0 : uniform_space (normed_group (has_norm to_additive.value_type))) : complete_space (normed_group (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_59051 (h0 : function.extfun Type ring) : @is_domain.{0} empty (@function.extfun_app.{2 1} Type ring.{0} h0 empty)  := sorry --non-trivial
lemma new_lemma_59052 (h0 : semiring (has_neg_part (finset ennreal))) : is_noetherian_ring (has_neg_part (finset ennreal)) := sorry --non-trivial
lemma new_lemma_59053 (h0 : add_group (random_gen (semiring (semiring empty)))) : is_add_cyclic (random_gen (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_59054 (h0 : complete_lattice (mul_one_class (add_comm_semigroup enat))) : complete_lattice.is_Sup_finite_compact (mul_one_class (add_comm_semigroup enat)) := sorry --non-trivial
lemma new_lemma_59055 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} linarith.ineq (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) linarith.ineq)  := sorry --non-trivial
lemma new_lemma_59056 (h0 : topological_space (partial_order (semiring (semiring (semiring congr_arg_kind))))) : t1_space (partial_order (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_59057 (h0 : functor.add_const (complete_lattice (left_cancel_monoid num)) empty) : @is_atomistic.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (left_cancel_monoid.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_59058 (h0 : semiring (has_zero Type)) : is_noetherian_ring (has_zero Type) := sorry --non-trivial
lemma new_lemma_59059 (h0 : uniform_space (has_append (comm_ring (has_nnnorm char)))) : complete_space (has_append (comm_ring (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_59060 (h0 : not (add_group (option congr_arg_kind) -> false)) : @is_add_cyclic.{0} (option.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_group.{0} (option.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_59061 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_59062 (h0 : ring (monoid_with_zero (option (option pos)))) : rank_condition (monoid_with_zero (option (option pos))) := sorry --non-trivial
lemma new_lemma_59063 (h0 : functor.add_const (uniform_space (complete_distrib_lattice name)) linarith.comp) : @separated_space.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (complete_distrib_lattice.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_59064 (h0 : topological_space (sub_neg_monoid linarith.comp)) : topological_space.separable_space (sub_neg_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_59065 (h0 : not (has_mem.mem unsigned has_emptyc.emptyc -> false)) : @strong_rank_condition.{0} unsigned (@finset.pi.empty.{1 0} Type ring.{0} unsigned (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) unsigned (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_59066 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @group.fg.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_59067 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm linarith.ineq))) : @is_domain.{0} (has_norm.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type ring.{0} (has_norm.{0} linarith.ineq) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} linarith.ineq)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_59068 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring Type)) linarith.comp) : @strong_rank_condition.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (canonically_ordered_comm_semiring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_59069 (h0 : filter (semigroup name)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_59070 (h0 : fin has_zero.zero) : @preirreducible_space.{1} (has_nndist.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_nndist.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_59071 (h0 : finset (canonically_linear_ordered_monoid (has_add real))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_59072 (h0 : not (ring (with_bot unsigned) -> false)) : @strong_rank_condition.{0} (with_bot.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (with_bot.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_59073 (h0 : uniform_space (has_nndist (option ennreal))) : separated_space (has_nndist (option ennreal)) := sorry --non-trivial
lemma new_lemma_59074 (h0 : add_group (has_neg_part (option pos))) : is_add_cyclic (has_neg_part (option pos)) := sorry --non-trivial
lemma new_lemma_59075 (h0 : not (add_group (add_monoid char) -> false)) : @is_add_cyclic.{0} (add_monoid.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (add_monoid.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_59076 (h0 : functor.add_const (finset (has_dist empty)) (option empty)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_59077 (h1 : topological_space (has_nnnorm environment.projection_info)) (h2 : add_group (has_nnnorm environment.projection_info)) : topological_add_group (has_nnnorm environment.projection_info) := sorry --non-trivial
lemma new_lemma_59078 (h0 : add_monoid (simple_graph (finset name))) : add_monoid.fg (simple_graph (finset name)) := sorry --non-trivial
lemma new_lemma_59079 (h0 : ring (has_ssubset linarith.comp_source)) : is_domain (has_ssubset linarith.comp_source) := sorry --non-trivial
lemma new_lemma_59080 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_59081 (h0 : topological_space (random_gen (measurable_space to_additive.value_type))) : locally_compact_space (random_gen (measurable_space to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_59082 (h0 : complete_lattice (bin_tree congr_arg_kind)) : is_compactly_generated (bin_tree congr_arg_kind) := sorry --non-trivial
lemma new_lemma_59083 (h1 : topological_space (with_one (has_ssubset char))) : totally_disconnected_space (with_one (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_59084 (h0 : prod (linear_ordered_comm_monoid_with_zero empty) (linear_ordered_comm_monoid_with_zero empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_59085 (h1 : ring (normed_field environment.projection_info)) : strong_rank_condition (normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_59086 (h0 : auto.case_option -> auto.case_option -> Prop) : total h0 := sorry --non-trivial
lemma new_lemma_59087 (h0 : uniform_space (has_add (has_nnnorm fun_info))) : complete_space (has_add (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_59088 (h0 : topological_space (has_nnnorm to_additive.value_type)) (h1 : preorder (has_nnnorm to_additive.value_type)) : order_topology (has_nnnorm to_additive.value_type) := sorry --non-trivial
lemma new_lemma_59089 (h0 : topological_space (finset (add_comm_monoid name))) : loc_path_connected_space (finset (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_59090 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_59091 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (normed_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_59092 (h0 : uniform_space (mul_zero_class (semiring (semiring empty)))) : separated_space (mul_zero_class (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_59093 (h0 : topological_space (linear_ordered_comm_monoid_with_zero empty)) : t1_space (linear_ordered_comm_monoid_with_zero empty) := sorry --non-trivial
lemma new_lemma_59094 (h1 : topological_space (complete_semilattice_Sup linarith.comp)) : totally_disconnected_space (complete_semilattice_Sup linarith.comp) := sorry --non-trivial
lemma new_lemma_59095 (h0 : ordered_add_comm_monoid (canonically_ordered_comm_semiring (normed_comm_ring name))) : archimedean (canonically_ordered_comm_semiring (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_59096 (h0 : functor.add_const (function.extfun Type ring) unsigned) : @strong_rank_condition.{0} (comm_group.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) unsigned h0) (comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_59097 (h0 : add_group (mul_one_class (mul_one_class (mul_one_class fun_info)))) : is_add_cyclic (mul_one_class (mul_one_class (mul_one_class fun_info))) := sorry --non-trivial
lemma new_lemma_59098 (h1 : not (group (with_one num) -> false)) : @normalizer_condition.{0} (with_one.{0} num) (@classical.by_contradiction'.{1} (group.{0} (with_one.{0} num)) h1)  := sorry --non-trivial
lemma new_lemma_59099 (h0 : functor.add_const (topological_space (has_zero unsigned)) environment.implicit_infer_kind) : @loc_path_connected_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_59100 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_zero.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_59101 (h1 : not (complete_lattice (distrib (has_ssubset reducibility_hints)) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (distrib.{0} (has_ssubset.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (complete_lattice.{0} (distrib.{0} (has_ssubset.{0} reducibility_hints))) h1)  := sorry --non-trivial
lemma new_lemma_59102 (h0 : ring (finset (has_Inf pos))) : is_domain (finset (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_59103 (h0 : group (topological_space (mul_one_class linarith.ineq))) : is_cyclic (topological_space (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_59104 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_59105 (h0 : topological_space (ring (option (option pos)))) : topological_space.separable_space (ring (option (option pos))) := sorry --non-trivial
lemma new_lemma_59106 (h0 : group (fintype (has_nnnorm (has_nnnorm to_additive.value_type)))) : is_cyclic (fintype (has_nnnorm (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_59107 (h0 : functor.add_const (uniform_space (has_neg pos)) (ring (has_neg Type))) : @separated_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_neg.{0} pos)) (ring.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_59108 (h0 : topological_space (with_bot to_additive.value_type)) : normal_space (with_bot to_additive.value_type) := sorry --non-trivial
lemma new_lemma_59109 (h1 : add_group (fintype (has_nnnorm (has_nnnorm linarith.ineq)))) : is_add_cyclic (fintype (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_59110 (h0 : semigroup (ring pos) -> semigroup (ring pos) -> Prop) : is_symm (semigroup (ring pos)) h0 := sorry --non-trivial
lemma new_lemma_59111 (h0 : not (monoid (normed_group unsigned) -> false)) : @monoid.fg.{0} (normed_group.{0} unsigned) (@classical.by_contradiction'.{1} (monoid.{0} (normed_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_59112 (h0 : ordered_add_comm_monoid (cancel_monoid congr_arg_kind)) : archimedean (cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_59113 (h0 : complete_lattice (normed_field (comm_ring (has_compl reducibility_hints)))) : complete_lattice.is_Sup_finite_compact (normed_field (comm_ring (has_compl reducibility_hints))) := sorry --non-trivial
lemma new_lemma_59114 (h0 : functor.add_const (ring (has_neg num)) num) : @strong_rank_condition.{0} (has_neg.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (has_neg.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_59115 (h0 : topological_space (canonically_ordered_comm_semiring (option (option ennreal)))) : t0_space (canonically_ordered_comm_semiring (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_59116 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_domain.{0} (has_top.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ring.{0}) (has_top.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_59117 (h0 : topological_space (has_to_string (has_add (ring linarith.comp)))) : t1_space (has_to_string (has_add (ring linarith.comp))) := sorry --non-trivial
lemma new_lemma_59118 (h0 : not (complete_lattice (add_group unsigned) -> false)) : @is_atomistic.{0} (add_group.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (add_group.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_59119 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_59120 (h0 : function.extfun Type ring) : @rank_condition.{0} (normed_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_59121 (h0 : topological_space (has_to_string (ring name))) : t0_space (has_to_string (ring name)) := sorry --non-trivial
lemma new_lemma_59122 (h0 : function.extfun (Type 1) (functor.add_const (topological_space (simple_graph name)))) : @t1_space.{0} (simple_graph.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (simple_graph.{0} name)) Type (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (topological_space.{0} (simple_graph.{0} name))) h0 Type))  := sorry --non-trivial
lemma new_lemma_59123 (h0 : functor.add_const (group (normed_linear_ordered_group unsigned)) congr_arg_kind) : @normalizer_condition.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (normed_linear_ordered_group.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_59124 (h0 : topological_space (with_bot (random_gen fun_info))) : locally_compact_space (with_bot (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_59125 (h0 : group (cancel_monoid (boolean_algebra.core name))) : group.fg (cancel_monoid (boolean_algebra.core name)) := sorry --non-trivial
lemma new_lemma_59126 (h0 : topological_space (has_neg (finset linarith.comp))) : path_connected_space (has_neg (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_59127 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_59128 (h0 : complete_lattice (measurable_space (has_norm linarith.comp_source))) : is_atomistic (measurable_space (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_59129 (h0 : functor.add_const (group (linear_ordered_comm_ring empty)) unsigned) : @group.fg.{0} (linear_ordered_comm_ring.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (linear_ordered_comm_ring.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_59130 (h0 : ordered_comm_monoid (has_Inf (has_add linarith.comp))) : has_exists_mul_of_le (has_Inf (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_59131 (h0 : topological_space (has_append num)) : irreducible_space (has_append num) := sorry --non-trivial
lemma new_lemma_59132 (h0 : fin has_zero.zero) : @normal_space.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_pos_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_59133 (h0 : topological_space (has_norm (has_norm (has_norm (has_norm (has_norm linarith.ineq)))))) : irreducible_space (has_norm (has_norm (has_norm (has_norm (has_norm linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_59134 (h0 : complete_lattice (complete_semilattice_Sup string_imp)) : is_atomistic (complete_semilattice_Sup string_imp) := sorry --non-trivial
lemma new_lemma_59135 (h0 : fin has_zero.zero) : @is_atomistic.{0} (add_comm_monoid.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (add_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_59136 (h0 : complete_linear_order (has_star num) -> complete_linear_order (has_star num) -> Prop) : is_strict_order (complete_linear_order (has_star num)) h0 := sorry --non-trivial
lemma new_lemma_59137 (h0 : finset (boolean_algebra (ring pos))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_59138 (h0 : functor.add_const (add_group (as_linear_order unsigned)) unsigned) : @is_add_cyclic.{0} (as_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (as_linear_order.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_59139 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_59140 (h0 : functor.add_const (ordered_comm_monoid (has_to_string name)) (finset pos)) : @has_exists_mul_of_le.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_to_string.{0} name)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_59141 (h0 : group (has_nndist (has_to_string (finset environment.implicit_infer_kind)))) : normalizer_condition (has_nndist (has_to_string (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_59142 (h0 : complete_lattice (has_bot (option (option empty)))) : is_atomistic (has_bot (option (option empty))) := sorry --non-trivial
lemma new_lemma_59143 (h0 : functor.add_const (ring (semigroup pos)) (has_add linarith.comp)) : @strong_rank_condition.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} pos)) (has_add.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_59144 (h0 : functor.add_const (uniform_space (option empty)) (semiring empty)) : @complete_space.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (option.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_59145 (h0 : topological_space (has_to_string (has_to_string (has_to_string (has_to_string name))))) : normal_space (has_to_string (has_to_string (has_to_string (has_to_string name)))) := sorry --non-trivial
lemma new_lemma_59146 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @path_connected_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_59147 (h2 : monoid (random_gen (has_inv string_imp))) : monoid.fg (random_gen (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_59148 (h0 : filter (boolean_algebra.core (has_add (comm_group pos)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_59149 (h0 : complete_lattice (measurable_space string_imp)) : is_atomistic (measurable_space string_imp) := sorry --non-trivial
lemma new_lemma_59150 (h0 : functor.add_const (topological_space (semigroup ennreal)) num) : @t0_space.{0} (semigroup.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_59151 (h0 : function.extfun Type group) : @normalizer_condition.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_59152 (h0 : topological_space (has_to_string (add_comm_monoid (add_comm_monoid Type)))) : regular_space (has_to_string (add_comm_monoid (add_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_59153 (h0 : set (nondiscrete_normed_field char)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_59154 (h0 : complete_lattice (semiring (has_norm (has_top (has_norm fun_info))))) : complete_lattice.is_Sup_finite_compact (semiring (has_norm (has_top (has_norm fun_info)))) := sorry --non-trivial
lemma new_lemma_59155 (h0 : topological_space (comm_group (pseudo_metric_space (option (option ennreal))))) : sequential_space (comm_group (pseudo_metric_space (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_59156 (h0 : functor.add_const (function.extfun Type uniform_space) unsigned) : @complete_space.{0} (cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) unsigned h0) (cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_59157 (h0 : ring (has_star num)) : is_principal_ideal_ring (has_star num) := sorry --non-trivial
lemma new_lemma_59158 (h0 : group (has_nndist (has_neg linarith.comp))) : is_simple_group (has_nndist (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_59159 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @group.fg.{0} (dlist.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (dlist.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_59160 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_59161 (h0 : add_monoid (ordered_comm_group (has_dist unsigned))) : add_monoid.fg (ordered_comm_group (has_dist unsigned)) := sorry --non-trivial
lemma new_lemma_59162 (h0 : has_lt (mul_one_class (mul_one_class ereal))) : no_max_order (mul_one_class (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_59163 (h1 : topological_space (has_sub congr_arg_kind)) : locally_compact_space (has_sub congr_arg_kind) := sorry --non-trivial
lemma new_lemma_59164 (h0 : add_group (metric_space string_imp)) : is_add_cyclic (metric_space string_imp) := sorry --non-trivial
lemma new_lemma_59165 (h0 : topological_space (normed_comm_ring (has_add linarith.comp))) : locally_compact_space (normed_comm_ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_59166 (h0 : topological_space (comm_group (has_add (normed_comm_ring name)))) : preconnected_space (comm_group (has_add (normed_comm_ring name))) := sorry --non-trivial
lemma new_lemma_59167 (h0 : cancel_comm_monoid_with_zero (has_neg (has_to_string pos))) : unique_factorization_monoid (has_neg (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_59168 (h3 : ring (div_inv_monoid (random_gen to_additive.value_type))) : rank_condition (div_inv_monoid (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_59169 (h0 : functor.add_const (topological_space (normed_linear_ordered_group empty)) num) : @preirreducible_space.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_59170 (h0 : functor.add_const (ring (add_left_cancel_semigroup empty)) empty) : @is_principal_ideal_ring.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (add_left_cancel_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_59171 (h0 : function.extfun (finset Type) (has_mem.mem (complete_semilattice_Sup linarith.comp))) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_59172 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_59173 (h0 : functor.add_const (topological_space (has_pos_part pos)) Type) : @irreducible_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_pos_part.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_59174 (h0 : topological_space (has_add (has_Inf real))) : preconnected_space (has_add (has_Inf real)) := sorry --non-trivial
lemma new_lemma_59175 (h0 : function.extfun Type (functor.comp ring add_comm_monoid)) : @rank_condition.{0} (add_comm_monoid.{0} name) (@functor.comp.run.{0 0 0} ring.{0} add_comm_monoid.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} ring.{0} add_comm_monoid.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_59176 (h0 : ring (canonically_ordered_monoid (has_add linarith.comp))) : rank_condition (canonically_ordered_monoid (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_59177 (h0 : function.extfun Type ring) : @is_domain.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} h0 (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_59178 (h0 : filter (canonically_ordered_comm_semiring (cancel_monoid pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_59179 (h0 : add_group (has_dist (option unsigned))) : is_add_cyclic (has_dist (option unsigned)) := sorry --non-trivial
lemma new_lemma_59180 (h0 : topological_space (comm_group (add_comm_monoid Type))) : totally_disconnected_space (comm_group (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_59181 (h0 : topological_space (non_unital_non_assoc_semiring (has_lt string.iterator_imp))) : path_connected_space (non_unital_non_assoc_semiring (has_lt string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_59182 (h0 : uniform_space (has_pos_part (has_neg Type))) : separated_space (has_pos_part (has_neg Type)) := sorry --non-trivial
lemma new_lemma_59183 (h0 : topological_space ennreal) : loc_path_connected_space ennreal := sorry --non-trivial
lemma new_lemma_59184 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_59185 (h0 : functor.add_const (complete_lattice (boolean_algebra Type)) (has_add Type)) : @is_compactly_generated.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (boolean_algebra.{1} Type)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_59186 (h0 : monoid (has_dist unsigned)) : monoid.fg (has_dist unsigned) := sorry --non-trivial
lemma new_lemma_59187 (h0 : not (complete_lattice (add_right_cancel_monoid unsigned) -> false)) : @is_compactly_generated.{0} (add_right_cancel_monoid.{0} unsigned) (@classical.by_contradiction'.{1} (complete_lattice.{0} (add_right_cancel_monoid.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_59188 (h0 : topological_space (has_append (comm_ring (comm_ring (comm_ring (comm_ring char)))))) : t0_space (has_append (comm_ring (comm_ring (comm_ring (comm_ring char))))) := sorry --non-trivial
lemma new_lemma_59189 (h0 : topological_space (has_add (ring Type))) : irreducible_space (has_add (ring Type)) := sorry --non-trivial
lemma new_lemma_59190 (h0 : set (simple_graph string.iterator_imp)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_59191 (h0 : list (measurable_space string_imp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_59192 (h0 : topological_space (semigroup (has_add Type))) : path_connected_space (semigroup (has_add Type)) := sorry --non-trivial
lemma new_lemma_59193 (h0 : topological_space char) : preirreducible_space char := sorry --non-trivial
lemma new_lemma_59194 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (option.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (option.{0} num))  := sorry --non-trivial
lemma new_lemma_59195 (h0 : functor.add_const (finset (has_Inf Type)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_59196 (h0 : ring (linear_ordered_semiring linarith.ineq)) : is_domain (linear_ordered_semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_59197 (h0 : functor.add_const Prop (boolean_algebra.core (has_nndist pos))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_59198 (h0 : add_monoid (has_top (semiring (with_bot num)))) : add_monoid.fg (has_top (semiring (with_bot num))) := sorry --non-trivial
lemma new_lemma_59199 (h0 : filter (random_gen (random_gen (random_gen (random_gen (random_gen linarith.ineq)))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_59200 (h0 : not (ring (has_compl string.iterator_imp) -> false)) : @strong_rank_condition.{0} (has_compl.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_59201 (h0 : functor.add_const (uniform_space (boolean_algebra linarith.comp)) (finset pos)) : @complete_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.{0} linarith.comp)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_59202 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (pseudo_metric_space name)) := sorry --non-trivial
lemma new_lemma_59203 (h0 : has_ssubset fun_info -> has_ssubset fun_info -> Prop) (h1 : set (has_ssubset fun_info)) : set.bounded h0 h1 := sorry --non-trivial
lemma new_lemma_59204 (h0 : fin has_zero.zero) : @rank_condition.{1} (has_Inf.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (has_Inf.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_59205 (h1 : topological_space (distrib (has_compl (has_lt (mul_one_class char))))) : path_connected_space (distrib (has_compl (has_lt (mul_one_class char)))) := sorry --non-trivial
lemma new_lemma_59206 (h1 : ring (distrib (topological_space (comm_ring char)))) : rank_condition (distrib (topological_space (comm_ring char))) := sorry --non-trivial
lemma new_lemma_59207 (h0 : ring (denumerable (has_nnnorm reducibility_hints))) : rank_condition (denumerable (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_59208 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_Sup.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (has_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_59209 (h0 : topological_space (complete_semilattice_Sup num)) : locally_compact_space (complete_semilattice_Sup num) := sorry --non-trivial
lemma new_lemma_59210 (h0 : group (normed_group string_imp)) : normalizer_condition (normed_group string_imp) := sorry --non-trivial
lemma new_lemma_59211 (h0 : functor.add_const (topological_space (mul_zero_class name)) pos) : @preconnected_space.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_59212 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (right_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (right_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_59213 (h0 : functor.add_const (uniform_space (has_nndist name)) name) : @separated_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_nndist.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_59214 (h0 : not (topological_space (pseudo_emetric_space num) -> false)) : @path_connected_space.{0} (pseudo_emetric_space.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (pseudo_emetric_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_59215 (h0 : generalized_boolean_algebra real -> generalized_boolean_algebra real -> Prop) : is_per (generalized_boolean_algebra real) h0 := sorry --non-trivial
lemma new_lemma_59216 (h0 : topological_space (has_add (has_to_string (has_to_string (has_to_string congr_arg_kind))))) : locally_compact_space (has_add (has_to_string (has_to_string (has_to_string congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_59217 (h0 : ring (ordered_ring (option (option (option (option pos)))))) : strong_rank_condition (ordered_ring (option (option (option (option pos))))) := sorry --non-trivial
lemma new_lemma_59218 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) (add_cancel_monoid Type)) : @loc_path_connected_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (add_cancel_monoid.{1} Type)) (add_cancel_monoid.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_59219 (h0 : ring (comm_group (has_add (has_add (comm_group name))))) : is_principal_ideal_ring (comm_group (has_add (has_add (comm_group name)))) := sorry --non-trivial
lemma new_lemma_59220 (h0 : topological_space (ordered_cancel_add_comm_monoid (option (option num)))) : totally_disconnected_space (ordered_cancel_add_comm_monoid (option (option num))) := sorry --non-trivial
lemma new_lemma_59221 (h0 : function.extfun (Type 1) group) : @is_cyclic.{1} (simple_graph.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (simple_graph.{1} Type))  := sorry --non-trivial
lemma new_lemma_59222 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_59223 (h0 : function.extfun Type (functor.add_const (topological_space (has_Sup unsigned)))) : @discrete_topology.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} unsigned)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_Sup.{0} unsigned))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_59224 (h0 : functor.add_const (ring (comm_monoid unsigned)) empty) : @is_domain.{0} (comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (comm_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_59225 (h0 : functor.comp topological_space add_comm_monoid unsigned) : @loc_path_connected_space.{0} (add_comm_monoid.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_59226 (h0 : functor.add_const (monoid (add_cancel_monoid name)) name) : @monoid.fg.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (add_cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_59227 (h0 : ring (id (has_norm linarith.comp))) : is_domain (id (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_59228 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) environment.implicit_infer_kind) : @irreducible_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_59229 (h0 : add_monoid (comm_ring reducibility_hints)) (h1 : topological_space (uniform_space (add_units (comm_ring reducibility_hints)))) : t0_space (uniform_space (add_units (comm_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_59230 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_inv.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (has_inv.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_59231 (h0 : topological_space (pseudo_metric_space (option (option empty)))) : t0_space (pseudo_metric_space (option (option empty))) := sorry --non-trivial
lemma new_lemma_59232 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_59233 (h0 : add_group (preorder (option (option (option unsigned))))) : is_add_cyclic (preorder (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_59234 (h0 : topological_space (ring (add_cancel_monoid (ring (has_neg (add_cancel_monoid name)))))) : discrete_topology (ring (add_cancel_monoid (ring (has_neg (add_cancel_monoid name))))) := sorry --non-trivial
lemma new_lemma_59235 (h0 : pfun fun_info Prop) (h1 : coe_sort (pfun.dom h0)) : pfun.as_subtype h0 h1 := sorry --non-trivial
lemma new_lemma_59236 (h0 : group (generalized_boolean_algebra (has_nndist linarith.comp))) : group.fg (generalized_boolean_algebra (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_59237 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_59238 (h0 : ring (non_assoc_semiring unsigned)) : strong_rank_condition (non_assoc_semiring unsigned) := sorry --non-trivial
lemma new_lemma_59239 (h0 : topological_space (semigroup (has_to_string linarith.comp))) : t0_space (semigroup (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_59240 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_59241 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (boolean_algebra.core.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} pos))  := sorry --non-trivial
lemma new_lemma_59242 (h2 : function.extfun Type group) : @group.fg.{0} (complete_semilattice_Sup.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h2 (complete_semilattice_Sup.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_59243 (h0 : functor.add_const (complete_lattice (has_zero Type)) (ring pos)) : @is_compactly_generated.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_zero.{1} Type)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_59244 (h2 : ring empty) : strong_rank_condition empty := sorry --non-trivial
lemma new_lemma_59245 (h0 : complete_lattice (complete_distrib_lattice fun_info)) : is_compactly_generated (complete_distrib_lattice fun_info) := sorry --non-trivial
lemma new_lemma_59246 (h0 : function.extfun Type group) : @is_cyclic.{0} (non_assoc_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (non_assoc_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_59247 (h0 : complete_lattice (add_comm_monoid (semigroup pos))) : complete_lattice.is_Sup_finite_compact (add_comm_monoid (semigroup pos)) := sorry --non-trivial
lemma new_lemma_59248 (h0 : has_mem.mem (measurable_space empty) has_emptyc.emptyc) : @rank_condition.{0} (measurable_space.{0} empty) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_59249 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (measurable_space.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (measurable_space.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_59250 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @preconnected_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_59251 (h0 : topological_space (comm_group environment.implicit_infer_kind)) : sequential_space (comm_group environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_59252 (h0 : monoid (semiring (random_gen (random_gen linarith.ineq)))) : monoid.fg (semiring (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_59253 (h0 : add_group (random_gen (semiring num))) : is_add_cyclic (random_gen (semiring num)) := sorry --non-trivial
lemma new_lemma_59254 (h0 : topological_space (canonically_ordered_monoid name)) : preirreducible_space (canonically_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_59255 (h0 : topological_space (boolean_algebra.core Type)) : locally_compact_space (boolean_algebra.core Type) := sorry --non-trivial
lemma new_lemma_59256 (h0 : not (topological_space (with_one congr_arg_kind) -> false)) : @topological_space.separable_space.{0} (with_one.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_59257 (h0 : add_group (linear_ordered_add_comm_group (has_nnnorm linarith.ineq))) : is_add_cyclic (linear_ordered_add_comm_group (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_59258 (h0 : ring (plift (option unsigned))) : is_principal_ideal_ring (plift (option unsigned)) := sorry --non-trivial
lemma new_lemma_59259 (h1 : set (has_div reducibility_hints)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_59260 (h0 : functor.add_const (topological_space (cancel_monoid unsigned)) pos) : @preconnected_space.{0} (cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_59261 (h5 : linarith.comp_source -> std_gen) (h6 : linarith.comp_source) : set.finite (function.graph h5 h6) := sorry --non-trivial
lemma new_lemma_59262 (h0 : topological_space (semiring linarith.ineq)) : irreducible_space (semiring linarith.ineq) := sorry --non-trivial
lemma new_lemma_59263 (h0 : ring (normed_field (has_nnnorm char))) : strong_rank_condition (normed_field (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_59264 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @normal_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_59265 (h0 : topological_space (simple_graph (finset (has_Inf name)))) : path_connected_space (simple_graph (finset (has_Inf name))) := sorry --non-trivial
lemma new_lemma_59266 (h0 : function.extfun (finset Type) (has_mem.mem string_imp)) : @totally_separated_space.{0} string_imp (@finset.pi.empty.{1 0} Type topological_space.{0} string_imp (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) string_imp) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_59267 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} fun_info (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) fun_info)  := sorry --non-trivial
lemma new_lemma_59268 (h0 : group (id (semiring congr_arg_kind))) : group.fg (id (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_59269 (h0 : group (metric_space char)) : is_cyclic (metric_space char) := sorry --non-trivial
lemma new_lemma_59270 (h0 : topological_space (complete_semilattice_Sup num)) : t1_space (complete_semilattice_Sup num) := sorry --non-trivial
lemma new_lemma_59271 (h0 : plift (metric_space unsigned) -> plift (metric_space unsigned) -> Prop) : is_equiv (plift (metric_space unsigned)) h0 := sorry --non-trivial
lemma new_lemma_59272 (h0 : list (measurable_space (has_inv linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_59273 (h0 : not (list (distrib_lattice fun_info) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_59274 (h0 : uniform_space (canonically_ordered_monoid (has_bot (has_add real)))) : separated_space (canonically_ordered_monoid (has_bot (has_add real))) := sorry --non-trivial
lemma new_lemma_59275 (h0 : ring (ordered_comm_ring (has_neg pos))) : is_domain (ordered_comm_ring (has_neg pos)) := sorry --non-trivial
lemma new_lemma_59276 (h0 : topological_space (simple_graph (has_neg (has_neg name)))) : regular_space (simple_graph (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_59277 (h0 : topological_space (add_cancel_monoid (has_to_string (has_to_string linarith.comp)))) : loc_path_connected_space (add_cancel_monoid (has_to_string (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_59278 (h0 : topological_space (has_one (has_norm congr_arg_kind))) : discrete_topology (has_one (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_59279 (h0 : topological_space (bin_tree (semiring unsigned))) : t1_space (bin_tree (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_59280 (h0 : topological_space (as_linear_order (option (option (option num))))) : preirreducible_space (as_linear_order (option (option (option num)))) := sorry --non-trivial
lemma new_lemma_59281 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) (has_Inf name)) : @totally_disconnected_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} linarith.comp)) (has_Inf.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_59282 (h0 : complete_lattice (comm_monoid empty)) : is_atomistic (comm_monoid empty) := sorry --non-trivial
lemma new_lemma_59283 (h0 : functor.comp topological_space has_to_string unsigned) : @totally_disconnected_space.{0} (has_to_string.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_59284 (h0 : topological_space (ring (cancel_monoid pos))) : topological_space.separable_space (ring (cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_59285 (h0 : functor.comp topological_space has_zero Type) : @totally_disconnected_space.{1} (has_zero.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} has_zero.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_59286 (h0 : topological_space (left_cancel_monoid (semiring (semiring empty)))) : t1_space (left_cancel_monoid (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_59287 (h0 : ordered_comm_monoid (has_add (has_neg_part pos))) : has_exists_mul_of_le (has_add (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_59288 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (group_with_zero.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (group_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_59289 (h0 : monoid (has_top (semiring empty))) : monoid.fg (has_top (semiring empty)) := sorry --non-trivial
lemma new_lemma_59290 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @is_principal_ideal_ring.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_59291 (h0 : not (uniform_space (has_lt linarith.ineq) -> false)) : @complete_space.{0} (has_lt.{0} linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_lt.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_59292 (h0 : functor.add_const (add_group (ordered_comm_ring Type)) pos) : @is_add_cyclic.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (ordered_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_59293 (h0 : has_mem.mem group has_emptyc.emptyc) : @is_cyclic.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) group.{0} h0) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_59294 (h0 : functor.add_const (ring (ring Type)) Type) : @is_domain.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_59295 (h1 : has_lt (has_ssubset linarith.comp_source)) : no_max_order (has_ssubset linarith.comp_source) := sorry --non-trivial
lemma new_lemma_59296 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) (has_to_string environment.implicit_infer_kind)) : @regular_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) (has_to_string.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_59297 (h0 : ring (has_dist (option ennreal))) : is_principal_ideal_ring (has_dist (option ennreal)) := sorry --non-trivial
lemma new_lemma_59298 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (random_gen.{0} (has_top.{0} (has_norm.{0} (measurable_space.{0} unsigned)))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} (has_top.{0} (has_norm.{0} (measurable_space.{0} unsigned)))))  := sorry --non-trivial
lemma new_lemma_59299 (h0 : finset (ordered_comm_ring (boolean_algebra.core (ring (has_add Type))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_59300 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc num))) : @t0_space.{0} (has_emptyc.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_59301 (h0 : group (add_cancel_monoid (finset (has_to_string linarith.comp)))) : normalizer_condition (add_cancel_monoid (finset (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_59302 (h0 : ring (normed_group (has_top (has_top empty)))) : is_principal_ideal_ring (normed_group (has_top (has_top empty))) := sorry --non-trivial
lemma new_lemma_59303 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) Type) : @locally_compact_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_59304 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_59305 (h0 : function.extfun (Type 1) topological_space) : @totally_disconnected_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_59306 (h0 : set reducibility_hints) : set.finite h0 := sorry --non-trivial
lemma new_lemma_59307 (h0 : group (fintype (random_gen char))) : is_cyclic (fintype (random_gen char)) := sorry --non-trivial
lemma new_lemma_59308 (h0 : add_monoid (normed_group (has_top (has_top linarith.comp)))) : add_monoid.fg (normed_group (has_top (has_top linarith.comp))) := sorry --non-trivial
lemma new_lemma_59309 (h0 : ring (has_nndist linarith.comp)) : strong_rank_condition (has_nndist linarith.comp) := sorry --non-trivial
lemma new_lemma_59310 (h0 : has_mem.mem (normed_group linarith.comp_source) has_emptyc.emptyc) : @is_atomistic.{0} (normed_group.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (normed_group.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_59311 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) environment.implicit_infer_kind) : @totally_separated_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_59312 (h0 : topological_space (add_cancel_monoid (add_comm_monoid name))) : regular_space (add_cancel_monoid (add_comm_monoid name)) := sorry --non-trivial
lemma new_lemma_59313 (h0 : functor.add_const (add_group (add_comm_monoid environment.implicit_infer_kind)) Type) : @is_add_cyclic.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (add_group.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_59314 (h0 : topological_space (ordered_comm_monoid (has_add Type))) : preconnected_space (ordered_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_59315 (h0 : complete_lattice (add_monoid fun_info)) : is_compactly_generated (add_monoid fun_info) := sorry --non-trivial
lemma new_lemma_59316 (h1 : ring (has_top (add_left_cancel_monoid string_imp))) : rank_condition (has_top (add_left_cancel_monoid string_imp)) := sorry --non-trivial
lemma new_lemma_59317 (h0 : functor.add_const (filter (normed_linear_ordered_group unsigned)) empty) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_59318 (h0 : complete_lattice (denumerable (random_gen string_imp))) : is_compactly_generated (denumerable (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_59319 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (with_one.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (with_one.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_59320 (h0 : not (topological_space empty -> false)) : normal_space empty := sorry --non-trivial
lemma new_lemma_59321 (h0 : function.extfun nat fin) : @regular_space.{0} (has_bot.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_59322 (h0 : uniform_space (add_comm_monoid real)) : complete_space (add_comm_monoid real) := sorry --non-trivial
lemma new_lemma_59323 (h0 : group (has_inv char)) : group.fg (has_inv char) := sorry --non-trivial
lemma new_lemma_59324 (h0 : topological_space (has_zero (has_add Type))) : path_connected_space (has_zero (has_add Type)) := sorry --non-trivial
lemma new_lemma_59325 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (add_cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_59326 (h0 : functor.add_const (cancel_comm_monoid_with_zero (partial_order empty)) num) : @unique_factorization_monoid.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (partial_order.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_59327 (h0 : topological_space (linear_ordered_field congr_arg_kind)) : totally_disconnected_space (linear_ordered_field congr_arg_kind) := sorry --non-trivial
lemma new_lemma_59328 (h0 : not (add_group (has_top fun_info) -> false)) : @is_add_cyclic.{0} (has_top.{0} fun_info) (@classical.by_contradiction'.{1} (add_group.{0} (has_top.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_59329 (h0 : function.extfun (Type 1) (functor.comp topological_space finset)) : @locally_compact_space.{1} (finset.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} finset.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} finset.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_59330 (h0 : ring (linear_ordered_field (option pos))) : is_domain (linear_ordered_field (option pos)) := sorry --non-trivial
lemma new_lemma_59331 (h0 : functor.add_const (topological_space (complete_linear_order num)) num) : @preirreducible_space.{0} (complete_linear_order.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_linear_order.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_59332 (h0 : ring (finset ennreal) -> ring (finset ennreal) -> Prop) : is_symm (ring (finset ennreal)) h0 := sorry --non-trivial
lemma new_lemma_59333 (h0 : functor.add_const (cancel_comm_monoid_with_zero znum) (option (option (option empty)))) : @unique_factorization_monoid.{0} znum (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} znum) (option.{0} (option.{0} (option.{0} empty))) h0)  := sorry --non-trivial
lemma new_lemma_59334 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (has_nndist.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_nndist.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_59335 (h0 : has_mem.mem (id num) has_emptyc.emptyc) : @is_add_cyclic.{0} (@id.{2} Type num) (@finset.pi.empty.{1 0} Type add_group.{0} (@id.{2} Type num) h0)  := sorry --non-trivial
lemma new_lemma_59336 (h0 : normed_comm_ring num -> normed_comm_ring num -> Prop) : is_symm (normed_comm_ring num) h0 := sorry --non-trivial
lemma new_lemma_59337 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_59338 (h0 : functor.add_const (ring (ordered_comm_group empty)) empty) : @is_domain.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_59339 (h0 : not (ring environment.implicit_infer_kind -> false)) : @strong_rank_condition.{0} environment.implicit_infer_kind (@classical.by_contradiction'.{1} (ring.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_59340 (h0 : functor.add_const (topological_space (semigroup pos)) environment.implicit_infer_kind) : @totally_separated_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_59341 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) empty) : @irreducible_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_59342 (h0 : functor.comp topological_space finset pos) : @preirreducible_space.{0} (finset.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_59343 (h0 : topological_space (has_inner (linear_ordered_add_comm_group_with_top string_imp) linarith.ineq)) (h1 : preorder (has_inner (linear_ordered_add_comm_group_with_top string_imp) linarith.ineq)) : order_topology (has_inner (linear_ordered_add_comm_group_with_top string_imp) linarith.ineq) := sorry --non-trivial
lemma new_lemma_59344 (h0 : functor.add_const (topological_space (normed_group num)) empty) : @totally_separated_space.{0} (normed_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_group.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_59345 (h0 : topological_space (has_add (has_nndist linarith.comp))) : t0_space (has_add (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_59346 (h0 : ring (linear_ordered_comm_monoid_with_zero unsigned)) : rank_condition (linear_ordered_comm_monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_59347 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem monoid)) : @monoid.fg.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type monoid.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) monoid.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) monoid.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_59348 (h2 : not (topological_space (has_append linarith.ineq) -> false)) : @t0_space.{0} (has_append.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_append.{0} linarith.ineq)) h2)  := sorry --non-trivial
lemma new_lemma_59349 (h0 : monoid (has_nndist num)) : monoid.fg (has_nndist num) := sorry --non-trivial
lemma new_lemma_59350 (h0 : ring (ordered_comm_ring pos)) : rank_condition (ordered_comm_ring pos) := sorry --non-trivial
lemma new_lemma_59351 (h0 : functor.add_const (topological_space (has_neg Type)) ennreal) : @normal_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_neg.{1} Type)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_59352 (h0 : functor.add_const (topological_space (mul_zero_class Type)) name) : @regular_space.{1} (mul_zero_class.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (mul_zero_class.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_59353 (h0 : functor.add_const (function.extfun Type list) linarith.comp) : palindrome (function.extfun_app (functor.add_const.run h0) (has_add pos)) := sorry --non-trivial
lemma new_lemma_59354 (h0 : topological_space (sub_neg_monoid name)) : totally_separated_space (sub_neg_monoid name) := sorry --non-trivial
lemma new_lemma_59355 (h0 : functor.add_const (ring (finset unsigned)) name) : @strong_rank_condition.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_59356 (h1 : uniform_space (distrib_lattice linarith.comp_source)) : complete_space (distrib_lattice linarith.comp_source) := sorry --non-trivial
lemma new_lemma_59357 (h0 : topological_space (has_one (semiring linarith.comp))) : path_connected_space (has_one (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_59358 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @is_simple_group.{1} Type (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) Type)  := sorry --non-trivial
lemma new_lemma_59359 (h0 : topological_space (normed_lattice_add_comm_group (has_neg (has_neg name)))) : totally_separated_space (normed_lattice_add_comm_group (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_59360 (h0 : monoid (finset empty)) : monoid.fg (finset empty) := sorry --non-trivial
lemma new_lemma_59361 (h0 : functor.add_const (function.extfun Type finset) pos) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (finset name)) := sorry --non-trivial
lemma new_lemma_59362 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_union.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_union.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_59363 (h0 : nat) (h1 h2 : fin h0) : fin.lt (id (id (id h1))) h2 := sorry --non-trivial
lemma new_lemma_59364 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_59365 (h0 : complete_lattice (measure_theory.measure_space unsigned)) : is_compactly_generated (measure_theory.measure_space unsigned) := sorry --non-trivial
lemma new_lemma_59366 (h0 : complete_lattice (filter empty)) : is_compactly_generated (filter empty) := sorry --non-trivial
lemma new_lemma_59367 (h0 : functor.add_const (list (finset name)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_59368 (h0 : set (mul_one_class linarith.ineq -> enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_59369 (h0 : topological_space (canonically_ordered_monoid (finset name))) : sequential_space (canonically_ordered_monoid (finset name)) := sorry --non-trivial
lemma new_lemma_59370 (h0 : topological_space (comm_group (option (has_to_string (comm_group pos))))) : totally_disconnected_space (comm_group (option (has_to_string (comm_group pos)))) := sorry --non-trivial
lemma new_lemma_59371 (h1 : function.extfun Type ring) : @is_domain.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h1 (semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_59372 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_add_comm_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_59373 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) pos) : @discrete_topology.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_59374 (h0 : not (group (with_bot linarith.ineq) -> false)) : @normalizer_condition.{0} (with_bot.{0} linarith.ineq) (@classical.by_contradiction'.{1} (group.{0} (with_bot.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_59375 (h0 : ring (random_gen (random_gen to_additive.value_type))) : rank_condition (random_gen (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_59376 (h0 : group (has_Inf (ring (ring Type)))) : group.fg (has_Inf (ring (ring Type))) := sorry --non-trivial
lemma new_lemma_59377 (h0 : function.extfun Type ring) : @is_domain.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_lattice_add_comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_59378 (h0 : measurable_space (has_le (mul_one_class (mul_one_class reducibility_hints)))) (h1 : filter (has_le (mul_one_class (mul_one_class reducibility_hints)))) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_59379 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_59380 (h0 : topological_space znum) : preirreducible_space znum := sorry --non-trivial
lemma new_lemma_59381 (h0 : complete_lattice (measurable_space (semiring num))) : complete_lattice.is_Sup_finite_compact (measurable_space (semiring num)) := sorry --non-trivial
lemma new_lemma_59382 (h0 : semiring (has_zero (has_add name))) : is_noetherian_ring (has_zero (has_add name)) := sorry --non-trivial
lemma new_lemma_59383 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_59384 (h0 : functor.add_const Prop (option name)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_59385 (h0 : function.extfun (Type 1) filter) : countable_Inter_filter (function.extfun_app h0 (has_neg Type)) := sorry --non-trivial
lemma new_lemma_59386 (h0 : topological_space (linear_ordered_comm_group_with_zero (mul_one_class environment.projection_info))) : t0_space (linear_ordered_comm_group_with_zero (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_59387 (h0 : functor.add_const (filter (semigroup pos)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_59388 (h0 : topological_space (linear_ordered_field (option (option name)))) : topological_space.separable_space (linear_ordered_field (option (option name))) := sorry --non-trivial
lemma new_lemma_59389 (h0 : group (generalized_boolean_algebra (has_Inf pos))) : is_cyclic (generalized_boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_59390 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) Type) : @totally_separated_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_59391 (h0 : functor.add_const (topological_space (has_nndist unsigned)) Type) : @totally_separated_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_59392 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_59393 (h0 : topological_space (has_Inf (has_add name))) : totally_separated_space (has_Inf (has_add name)) := sorry --non-trivial
lemma new_lemma_59394 (h0 : functor.add_const (function.extfun (Type 1) topological_space) name) : @t0_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) name h0) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_59395 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_59396 (h1 : list (has_norm (with_one (random_gen (random_gen (has_inv linarith.ineq)))))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_59397 (h0 : filter (has_nndist (option (option (option (option (option (option unsigned)))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_59398 (h0 : topological_space (add_comm_semigroup (mul_one_class (mul_one_class enat)))) : path_connected_space (add_comm_semigroup (mul_one_class (mul_one_class enat))) := sorry --non-trivial
lemma new_lemma_59399 (h0 : functor.add_const (topological_space (has_neg pos)) (has_neg Type)) : @t1_space.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_neg.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_59400 (h0 : ordered_add_comm_monoid (has_pos_part (finset (has_pos_part (has_pos_part (has_add Type)))))) : archimedean (has_pos_part (finset (has_pos_part (has_pos_part (has_add Type))))) := sorry --non-trivial
lemma new_lemma_59401 (h0 : finset (has_zero (ring environment.implicit_infer_kind))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_59402 (h0 : topological_space (comm_group (ring (ring environment.implicit_infer_kind)))) : locally_compact_space (comm_group (ring (ring environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_59403 (h0 : topological_space (simple_graph (mul_one_class to_additive.value_type))) : t0_space (simple_graph (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_59404 (h0 : topological_space (finset (mul_one_class (has_to_string Type)))) : discrete_topology (finset (mul_one_class (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_59405 (h0 : topological_space (simple_graph (boolean_algebra.core pos))) : loc_path_connected_space (simple_graph (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_59406 (h0 : set (has_lt environment.projection_info)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_59407 (h0 : complete_lattice (has_nndist (comm_group Type))) : is_compactly_generated (has_nndist (comm_group Type)) := sorry --non-trivial
lemma new_lemma_59408 (h0 : set (distrib string.iterator_imp)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_59409 (h0 : monoid (has_emptyc (has_norm (has_norm congr_arg_kind)))) : monoid.fg (has_emptyc (has_norm (has_norm congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_59410 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} string_imp (@function.extfun_app.{2 1} Type topological_space.{0} h0 string_imp)  := sorry --non-trivial
lemma new_lemma_59411 (h0 : group (encodable (has_nnnorm (random_gen char)))) : group.fg (encodable (has_nnnorm (random_gen char))) := sorry --non-trivial
lemma new_lemma_59412 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (has_ssubset.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_ssubset.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_59413 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_59414 (h0 : functor.add_const (topological_space (has_pos_part pos)) linarith.comp) : @loc_path_connected_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_59415 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) linarith.comp) : @locally_compact_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_59416 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_59417 (h0 : function.extfun Type topological_space) : @t1_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_59418 (h0 : group (measurable_space (has_norm unsigned))) : normalizer_condition (measurable_space (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_59419 (h1 : uniform_space (linear_ordered_comm_group_with_zero linarith.comp_source)) : complete_space (linear_ordered_comm_group_with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_59420 (h0 : topological_space (semigroup (has_add (has_add name)))) : totally_disconnected_space (semigroup (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_59421 (h0 : functor.add_const (topological_space (has_zero Type)) Type) : @t1_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_zero.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_59422 (h0 : group (boolean_algebra.core (normed_comm_ring unsigned))) : is_cyclic (boolean_algebra.core (normed_comm_ring unsigned)) := sorry --non-trivial
lemma new_lemma_59423 (h0 : uniform_space (normed_comm_ring (comm_group Type))) : complete_space (normed_comm_ring (comm_group Type)) := sorry --non-trivial
lemma new_lemma_59424 (h0 : has_mem.mem (has_emptyc linarith.comp) has_emptyc.emptyc) : filter.ne_bot (finset.pi.empty filter (has_emptyc linarith.comp) h0) := sorry --non-trivial
lemma new_lemma_59425 (h0 : cancel_comm_monoid_with_zero (measure_theory.measure_space (has_top unsigned))) : unique_factorization_monoid (measure_theory.measure_space (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_59426 (h0 : group (topological_space string.iterator_imp)) : is_cyclic (topological_space string.iterator_imp) := sorry --non-trivial
lemma new_lemma_59427 (h0 : functor.add_const (topological_space (linear_ordered_comm_ring empty)) empty) : @preirreducible_space.{0} (linear_ordered_comm_ring.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_ring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_59428 (h0 : add_group (has_nnnorm (has_nnnorm (distrib linarith.ineq)))) : is_add_cyclic (has_nnnorm (has_nnnorm (distrib linarith.ineq))) := sorry --non-trivial
lemma new_lemma_59429 (h0 : list (canonically_ordered_comm_semiring (finset (has_nndist (finset ennreal))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_59430 (h0 : cancel_comm_monoid_with_zero (has_to_string (has_add (has_add Type)))) : unique_factorization_monoid (has_to_string (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_59431 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (complete_distrib_lattice.{0} real) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (complete_distrib_lattice.{0} real))  := sorry --non-trivial
lemma new_lemma_59432 (h0 : fin has_zero.zero) : @is_domain.{0} (ordered_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (ordered_comm_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_59433 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @is_simple_group.{0} pos (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) pos)  := sorry --non-trivial
lemma new_lemma_59434 (h0 : functor.add_const (function.extfun (Type 1) topological_space) environment.implicit_infer_kind) : @discrete_topology.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) environment.implicit_infer_kind h0) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_59435 (h0 : topological_space (has_to_string (comm_group (has_neg_part name)))) : loc_path_connected_space (has_to_string (comm_group (has_neg_part name))) := sorry --non-trivial
lemma new_lemma_59436 (h0 : has_neg (semi_normed_comm_ring linarith.comp_source)) (h1 : measurable_space (semi_normed_comm_ring linarith.comp_source)) : has_measurable_neg (semi_normed_comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_59437 (h0 : functor.add_const (topological_space (finset linarith.comp)) (semigroup (has_Inf (normed_comm_ring pos)))) : @preirreducible_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) (semigroup.{0} (has_Inf.{0} (normed_comm_ring.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_59438 (h0 : topological_space (semigroup (has_neg linarith.comp))) : path_connected_space (semigroup (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_59439 (h0 : add_group (has_add (finset linarith.comp))) : is_add_cyclic (has_add (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_59440 (h1 : topological_space (with_one string_imp)) : path_connected_space (with_one string_imp) := sorry --non-trivial
lemma new_lemma_59441 (h0 : complete_lattice (id (random_gen (measurable_space congr_arg_kind)))) : is_atomistic (id (random_gen (measurable_space congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_59442 (h0 : ring (cancel_monoid (mul_zero_class (add_comm_monoid (normed_comm_ring name))))) : strong_rank_condition (cancel_monoid (mul_zero_class (add_comm_monoid (normed_comm_ring name)))) := sorry --non-trivial
lemma new_lemma_59443 (h0 : functor.add_const (monoid linarith.comp) Type) : @monoid.fg.{0} linarith.comp (@functor.add_const.run.{0 1} (monoid.{0} linarith.comp) Type h0)  := sorry --non-trivial
lemma new_lemma_59444 (h0 : add_group (ordered_comm_monoid (finset pos))) : is_add_cyclic (ordered_comm_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_59445 (h0 : function.extfun Type (functor.comp topological_space add_cancel_monoid)) : @sequential_space.{0} (add_cancel_monoid.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} add_cancel_monoid.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_59446 (h0 : function.extfun (Type 1) uniform_space) : @complete_space.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_59447 (h1 : has_mem.mem linarith.comp has_emptyc.emptyc) : @normalizer_condition.{0} linarith.comp (@finset.pi.empty.{1 0} Type group.{0} linarith.comp h1)  := sorry --non-trivial
lemma new_lemma_59448 (h1 : add_monoid (mul_one_class linarith.ineq)) : add_monoid.fg (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_59449 (h0 : functor.add_const (ordered_add_comm_monoid (finset linarith.comp)) name) : @archimedean.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (finset.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_59450 (h0 : functor.add_const (group (boolean_algebra linarith.comp)) Type) : @group.fg.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_59451 (h0 : functor.add_const (topological_space (semigroup name)) ennreal) : @normal_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} name)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_59452 (h0 : monoid (add_cancel_monoid (cancel_monoid (cancel_monoid pos)))) : monoid.fg (add_cancel_monoid (cancel_monoid (cancel_monoid pos))) := sorry --non-trivial
lemma new_lemma_59453 (h0 : uniform_space (comm_semigroup Type)) : complete_space (comm_semigroup Type) := sorry --non-trivial
lemma new_lemma_59454 (h0 : group (boolean_algebra.core (semigroup Type))) : is_simple_group (boolean_algebra.core (semigroup Type)) := sorry --non-trivial
lemma new_lemma_59455 (h0 : functor.add_const (ordered_add_comm_monoid (has_inner empty unsigned)) empty) : @archimedean.{0} (has_inner.{0 0} empty unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_inner.{0 0} empty unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_59456 (h0 : monoid (plift (semiring unsigned))) : monoid.fg (plift (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_59457 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @sequential_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_59458 (h0 : topological_space (with_one (has_union (has_union linarith.comp)))) : discrete_topology (with_one (has_union (has_union linarith.comp))) := sorry --non-trivial
lemma new_lemma_59459 (h0 : environment.projection_info -> environment.projection_info) (h1 : nat) (h2 : environment.projection_info) : function.pts_of_period h0 h1 h2 := sorry --non-trivial
lemma new_lemma_59460 (h2 : function.extfun Type topological_space) : @path_connected_space.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h2 (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_59461 (h0 : function.extfun Type (functor.comp topological_space boolean_algebra.core)) : @discrete_topology.{0} (boolean_algebra.core.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} ennreal (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} boolean_algebra.core.{0}) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_59462 (h0 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_atomistic.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h0) (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_59463 (h0 : functor.add_const (uniform_space (has_bot pos)) name) : @separated_space.{0} (has_bot.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_bot.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_59464 (h0 : ring (has_top (random_gen congr_arg_kind))) : rank_condition (has_top (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_59465 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_59466 (h1 : not (filter (linear_ordered_add_comm_group char) -> false)) : filter.ne_bot (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_59467 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @totally_disconnected_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_59468 (h0 : uniform_space (has_add name)) : separated_space (has_add name) := sorry --non-trivial
lemma new_lemma_59469 (h0 : complete_lattice (has_top (has_top (has_top fun_info)))) : is_compactly_generated (has_top (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_59470 (h0 : function.extfun (set num -> Type) (function.extfun (set num))) : is_countably_spanning (function.extfun_app (function.extfun_app h0 (fun (x : set num), Prop))) := sorry --non-trivial
lemma new_lemma_59471 (h0 : functor.add_const (topological_space (monoid ennreal)) unsigned) : @t1_space.{0} (monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (monoid.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_59472 (h0 : uniform_space (linear_ordered_semiring (semiring (has_top (has_top (semiring unsigned)))))) : separated_space (linear_ordered_semiring (semiring (has_top (has_top (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_59473 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_59474 (h2 h3 : multiset linarith.ineq) : multiset.disjoint h2 h3 := sorry --non-trivial
lemma new_lemma_59475 (h0 : functor.add_const (topological_space (has_nndist unsigned)) (ring name)) : @loc_path_connected_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} unsigned)) (ring.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_59476 (h0 : topological_space (distrib_lattice (comm_ring char))) : locally_compact_space (distrib_lattice (comm_ring char)) := sorry --non-trivial
lemma new_lemma_59477 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_59478 (h0 : topological_space (has_dist (comm_monoid unsigned))) : locally_compact_space (has_dist (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_59479 (h0 : function.extfun Type (functor.add_const (topological_space (free_add_monoid unsigned)))) : @totally_separated_space.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} unsigned)) congr_arg_kind (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (free_add_monoid.{0} unsigned))) h0 congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_59480 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_59481 (h0 : functor.add_const (topological_space (has_neg linarith.comp)) (has_zero (finset (finset pos)))) : @regular_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} linarith.comp)) (has_zero.{0} (finset.{0} (finset.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_59482 (h0 : ordered_add_comm_monoid (has_bot unsigned)) : archimedean (has_bot unsigned) := sorry --non-trivial
lemma new_lemma_59483 (h1 : filter (add_monoid string_imp)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_59484 (h0 : filter (has_neg_part (boolean_algebra.core name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_59485 (h0 : functor.add_const Prop (metric_space (has_norm (has_norm unsigned)))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_59486 (h0 : ordered_comm_monoid (normed_lattice_add_comm_group (has_add linarith.comp))) : has_exists_mul_of_le (normed_lattice_add_comm_group (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_59487 (h0 : topological_space (has_emptyc (complete_semilattice_Sup (complete_semilattice_Sup linarith.comp)))) : irreducible_space (has_emptyc (complete_semilattice_Sup (complete_semilattice_Sup linarith.comp))) := sorry --non-trivial
lemma new_lemma_59488 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_59489 (h0 : uniform_space (has_norm (semiring (semiring unsigned)))) : complete_space (has_norm (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_59490 (h0 : fin has_zero.zero) : @has_exists_mul_of_le.{0} (simple_graph.{0} name) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (simple_graph.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_59491 (h0 : functor.add_const (function.extfun Type topological_space) (finset pos)) : @discrete_topology.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (finset.{0} pos) h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_59492 (h0 : functor.add_const (ring nnreal) empty) : @strong_rank_condition.{0} nnreal (@functor.add_const.run.{0 0} (ring.{0} nnreal) empty h0)  := sorry --non-trivial
lemma new_lemma_59493 (h0 : uniform_space (has_Inf (ring (finset linarith.comp)))) : separated_space (has_Inf (ring (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_59494 (h0 : topological_space (semi_normed_comm_ring linarith.ineq)) (h1 : preorder (semi_normed_comm_ring linarith.ineq)) : order_closed_topology (semi_normed_comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_59495 (h0 : functor.add_const (function.extfun (Type 1) group) linarith.comp) : @is_simple_group.{1} (has_nndist.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) linarith.comp h0) (has_nndist.{1} Type))  := sorry --non-trivial
lemma new_lemma_59496 (h0 : not (topological_space (has_star unsigned) -> false)) : @t0_space.{0} (has_star.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_star.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_59497 (h0 : fin has_zero.zero) : @is_add_cyclic.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type add_group.{0}) h0) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_59498 (h0 : ring (fintype (ordered_ring linarith.comp_source))) : strong_rank_condition (fintype (ordered_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_59499 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (semi_normed_comm_ring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (semi_normed_comm_ring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_59500 (h0 : topological_space (ordered_comm_ring (has_add (has_pos_part (has_add (has_Inf pos)))))) : irreducible_space (ordered_comm_ring (has_add (has_pos_part (has_add (has_Inf pos))))) := sorry --non-trivial
lemma new_lemma_59501 (h0 : ordered_comm_monoid (add_comm_monoid linarith.comp)) : has_exists_mul_of_le (add_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_59502 (h0 : has_mem.mem (has_emptyc linarith.comp_source) has_emptyc.emptyc) : @complete_space.{0} (has_emptyc.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type uniform_space.{0} (has_emptyc.{0} linarith.comp_source) h0)  := sorry --non-trivial
lemma new_lemma_59503 (h0 : not (list (dlist linarith.comp_source) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_59504 (h0 : functor.add_const (group (ring environment.implicit_infer_kind)) environment.implicit_infer_kind) : @normalizer_condition.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_59505 (h0 : not (semiring (with_bot linarith.comp) -> false)) : @is_noetherian_ring.{0} (with_bot.{0} linarith.comp) (@classical.by_contradiction'.{1} (semiring.{0} (with_bot.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_59506 (h0 : functor.add_const (topological_space (has_nndist pos)) name) : @totally_separated_space.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_59507 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) name) : @preconnected_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_59508 (h0 : simple_graph char) (h2 : char) (h3 : sym2 char) : simple_graph.incidence_set h0 h2 h3 := sorry --non-trivial
lemma new_lemma_59509 (h0 : measurable_space (has_le (distrib string.iterator_imp))) (h1 : filter (has_le (distrib string.iterator_imp))) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_59510 (h0 : group (has_nndist (option empty))) : is_cyclic (has_nndist (option empty)) := sorry --non-trivial
lemma new_lemma_59511 (h0 : group (random_gen (has_nnnorm linarith.comp_source))) : is_cyclic (random_gen (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_59512 (h0 : functor.add_const (group (boolean_algebra pos)) (has_neg Type)) : @is_simple_group.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (boolean_algebra.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_59513 (h1 : topological_space num) : irreducible_space num := sorry --non-trivial
lemma new_lemma_59514 (h0 : uniform_space (has_nndist (option Type))) : complete_space (has_nndist (option Type)) := sorry --non-trivial
lemma new_lemma_59515 (h0 : add_monoid (plift (semiring unsigned))) : add_monoid.fg (plift (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_59516 (h0 : ring (complete_distrib_lattice (ring Type))) : rank_condition (complete_distrib_lattice (ring Type)) := sorry --non-trivial
lemma new_lemma_59517 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (comm_monoid (semiring empty))) := sorry --non-trivial
lemma new_lemma_59518 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) (has_Inf (has_Inf name))) : @preconnected_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) (has_Inf.{0} (has_Inf.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_59519 (h0 : not (filter (has_one congr_arg_kind) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_59520 (h0 : topological_space (with_bot (semiring (semiring unsigned)))) : t1_space (with_bot (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_59521 (h0 : complete_lattice (linear_ordered_add_comm_group (random_gen (random_gen fun_info)))) : is_atomistic (linear_ordered_add_comm_group (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_59522 (h0 : functor.add_const (function.extfun (Type 1) group) Type) : @normalizer_condition.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) group.{1}) Type h0) (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_59523 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} real.angle (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 real.angle)  := sorry --non-trivial
lemma new_lemma_59524 (h0 : group (measurable_space (has_norm (has_norm num)))) : is_cyclic (measurable_space (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_59525 (h0 : has_mem.mem ring has_emptyc.emptyc) : @strong_rank_condition.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} h0) (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_59526 (h0 : complete_lattice (option (semiring congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (option (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_59527 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @regular_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_59528 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_linear_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (canonically_linear_ordered_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_59529 (h0 : functor.add_const (group (boolean_algebra.core name)) pos) : @normalizer_condition.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.core.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_59530 (h0 : functor.add_const (finset (ordered_comm_ring pos)) (has_Inf name)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_59531 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} (complete_semilattice_Sup.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (complete_semilattice_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_59532 (h0 : not (uniform_space (comm_ring linarith.ineq) -> false)) : @complete_space.{0} (comm_ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (comm_ring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_59533 (h0 : topological_space (pseudo_metric_space num)) : t0_space (pseudo_metric_space num) := sorry --non-trivial
lemma new_lemma_59534 (h0 : functor.add_const (finset (ring pos)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_59535 (h0 : ring (cancel_monoid (has_add Type))) : is_principal_ideal_ring (cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_59536 (h0 : functor.add_const (topological_space (boolean_algebra name)) name) : @normal_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_59537 (h0 : uniform_space (pseudo_emetric_space (option empty))) : separated_space (pseudo_emetric_space (option empty)) := sorry --non-trivial
lemma new_lemma_59538 (h0 : functor.add_const (function.extfun Type ring) name) : @rank_condition.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) name h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_59539 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_bot.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_59540 (h0 : topological_space (denumerable (has_inv (random_gen string_imp)))) : totally_disconnected_space (denumerable (has_inv (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_59541 (h0 : ring (comm_ring (has_nnnorm (has_nnnorm (encodable char))))) : is_domain (comm_ring (has_nnnorm (has_nnnorm (encodable char)))) := sorry --non-trivial
lemma new_lemma_59542 (h0 : topological_space (non_assoc_semiring (semiring unsigned))) : preirreducible_space (non_assoc_semiring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_59543 (h0 h1 : multiset enat) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_59544 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_59545 (h0 : group (has_neg_part (has_neg_part Type))) : normalizer_condition (has_neg_part (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_59546 (h0 : monoid (add_comm_monoid unsigned)) : monoid.fg (add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_59547 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (linear_ordered_field.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} num))  := sorry --non-trivial
lemma new_lemma_59548 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_59549 (h0 : functor.add_const (group (canonically_ordered_comm_semiring pos)) pos) : @normalizer_condition.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (canonically_ordered_comm_semiring.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_59550 (h0 : topological_space (linear_ordered_comm_group congr_arg_kind)) : path_connected_space (linear_ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_59551 (h0 : ordered_comm_monoid (comm_group (option name))) : has_exists_mul_of_le (comm_group (option name)) := sorry --non-trivial
lemma new_lemma_59552 (h0 : set (add_comm_semigroup fun_info -> string.iterator_imp)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_59553 (h0 : topological_space (monoid (option ennreal))) : discrete_topology (monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_59554 (h0 : filter (distrib_lattice (distrib_lattice to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_59555 (h0 : topological_space (canonically_ordered_comm_semiring num)) : path_connected_space (canonically_ordered_comm_semiring num) := sorry --non-trivial
lemma new_lemma_59556 (h0 : finset (add_cancel_monoid (option (option ennreal)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_59557 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (measurable_space.dynkin_system.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_59558 (h0 : functor.add_const (group (has_Inf environment.implicit_infer_kind)) pos) : @is_cyclic.{0} (has_Inf.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (has_Inf.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_59559 (h0 : topological_space (ordered_comm_ring (sub_neg_monoid (has_bot (has_Inf pos))))) : path_connected_space (ordered_comm_ring (sub_neg_monoid (has_bot (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_59560 (h0 : topological_space (normed_comm_ring (has_add pos))) : topological_space.separable_space (normed_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_59561 (h0 : group (with_one (linear_ordered_semiring (has_norm empty)))) : group.fg (with_one (linear_ordered_semiring (has_norm empty))) := sorry --non-trivial
lemma new_lemma_59562 (h1 : function.extfun Type list) : list.nodup (function.extfun_app h1 (id string_imp)) := sorry --non-trivial
lemma new_lemma_59563 (h0 : topological_space (boolean_algebra.core environment.implicit_infer_kind)) : normal_space (boolean_algebra.core environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_59564 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_59565 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (has_sdiff empty)) := sorry --non-trivial
lemma new_lemma_59566 (h0 : add_group (complete_semilattice_Sup (semiring (semiring congr_arg_kind)))) : is_add_cyclic (complete_semilattice_Sup (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_59567 (h0 : functor.comp finset semigroup name) : finset.nonempty (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_59568 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (distrib_lattice.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (distrib_lattice.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_59569 (h0 : filter (has_top (has_norm (comm_ring fun_info)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_59570 (h1 : function.extfun Type topological_space) : @path_connected_space.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} h1 num)  := sorry --non-trivial
lemma new_lemma_59571 (h0 : ring (comm_ring to_additive.value_type)) : rank_condition (comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_59572 (h0 : group (boolean_algebra.core num)) : normalizer_condition (boolean_algebra.core num) := sorry --non-trivial
lemma new_lemma_59573 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (complete_distrib_lattice.{0} real) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (complete_distrib_lattice.{0} real))  := sorry --non-trivial
lemma new_lemma_59574 (h0 : ring (has_to_string congr_arg_kind)) : is_domain (has_to_string congr_arg_kind) := sorry --non-trivial
lemma new_lemma_59575 (h1 : function.extfun Type topological_space) : @irreducible_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_59576 (h0 : uniform_space (comm_ring linarith.comp_source)) : complete_space (comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_59577 (h0 : functor.add_const (function.extfun Type ring) pos) : @is_domain.{0} (ordered_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) pos h0) (ordered_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_59578 (h2 h3 : multiset (nondiscrete_normed_field linarith.ineq)) : multiset.subset h2 h3 := sorry --non-trivial
lemma new_lemma_59579 (h0 : fin has_zero.zero) : @group.fg.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (group.{0} (canonically_ordered_monoid.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_59580 (h0 : topological_space (add_cancel_monoid empty)) : irreducible_space (add_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_59581 (h0 : has_mem.mem (semiring (with_one linarith.comp_source)) has_emptyc.emptyc) : @is_atomistic.{0} (semiring.{0} (with_one.{0} linarith.comp_source)) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (semiring.{0} (with_one.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_59582 (h0 : not (topological_space (has_compl enat) -> false)) : @path_connected_space.{0} (has_compl.{0} enat) (@classical.by_contradiction'.{1} (topological_space.{0} (has_compl.{0} enat)) h0)  := sorry --non-trivial
lemma new_lemma_59583 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (option.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (option.{0} empty))  := sorry --non-trivial
lemma new_lemma_59584 (h0 : topological_space (semigroup (has_pos_part (has_to_string Type)))) : t0_space (semigroup (has_pos_part (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_59585 (h0 : monoid (has_Inf (has_Inf (has_add real)))) : monoid.fg (has_Inf (has_Inf (has_add real))) := sorry --non-trivial
lemma new_lemma_59586 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @monoid.fg.{0} name (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) monoid.{0}) name)  := sorry --non-trivial
lemma new_lemma_59587 (h0 : functor.add_const (group (comm_group Type)) (has_add Type)) : @normalizer_condition.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (comm_group.{1} Type)) (has_add.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_59588 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_59589 (h0 : not (topological_space (has_append linarith.ineq) -> false)) : @totally_disconnected_space.{0} (has_append.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (has_append.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_59590 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_59591 (h0 : ring (sub_neg_monoid real)) : is_domain (sub_neg_monoid real) := sorry --non-trivial
lemma new_lemma_59592 (h1 : not (ring rat -> false)) : is_domain rat := sorry --non-trivial
lemma new_lemma_59593 (h0 : topological_space (add_cancel_monoid (option (option (option unsigned))))) : loc_path_connected_space (add_cancel_monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_59594 (h0 : complete_lattice (semiring (has_norm linarith.comp))) : complete_lattice.is_Sup_finite_compact (semiring (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_59595 (h0 : add_group (as_linear_order unsigned)) : is_add_cyclic (as_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_59596 (h0 : function.extfun Type group) : @group.fg.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_59597 (h0 : add_group (non_unital_non_assoc_semiring ereal)) : is_add_cyclic (non_unital_non_assoc_semiring ereal) := sorry --non-trivial
lemma new_lemma_59598 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_59599 (h1 : ring real.angle) : strong_rank_condition real.angle := sorry --non-trivial
lemma new_lemma_59600 (h1 : function.extfun Type topological_space) : @totally_separated_space.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_59601 (h1 : complete_lattice (has_div enat)) : is_compactly_generated (has_div enat) := sorry --non-trivial
lemma new_lemma_59602 (h0 : function.extfun Type topological_space) : @t0_space.{0} (ordered_cancel_add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_59603 (h0 : topological_space (normed_group (has_top string_imp))) : t0_space (normed_group (has_top string_imp)) := sorry --non-trivial
lemma new_lemma_59604 (h0 : ring (linear_ordered_add_comm_group (random_gen linarith.comp_source))) : rank_condition (linear_ordered_add_comm_group (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_59605 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (omega_complete_partial_order.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (omega_complete_partial_order.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_59606 (h0 : topological_space (has_Inf (finset (has_add (has_add pos))))) : t0_space (has_Inf (finset (has_add (has_add pos)))) := sorry --non-trivial
lemma new_lemma_59607 (h1 : list (has_inv (distrib_lattice to_additive.value_type))) : list.nodup h1 := sorry --non-trivial
lemma new_lemma_59608 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_add_cyclic.{0} congr_arg_kind (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) add_group.{0}) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_59609 (h0 : filter (pseudo_metric_space (option unsigned))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_59610 (h0 : complete_lattice (complete_distrib_lattice (finset pos))) : is_atomistic (complete_distrib_lattice (finset pos)) := sorry --non-trivial
lemma new_lemma_59611 (h0 : set (set (mul_one_class linarith.ineq))) (h1 : set (mul_one_class linarith.ineq)) : measurable_space.dynkin_system.generate_has h0 h1 := sorry --non-trivial
lemma new_lemma_59612 (h0 : topological_space ereal) (h2 : has_sub ereal) : has_continuous_sub ereal := sorry --non-trivial
lemma new_lemma_59613 (h0 : group (add_comm_monoid (option pos))) : group.fg (add_comm_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_59614 (h0 : ring (metric_space empty)) : is_domain (metric_space empty) := sorry --non-trivial
lemma new_lemma_59615 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_59616 (h0 : ring (cancel_monoid (semiring congr_arg_kind))) : strong_rank_condition (cancel_monoid (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_59617 (h0 : function.extfun (Type 1) topological_space) : @locally_compact_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 Type)  := sorry --non-trivial
lemma new_lemma_59618 (h0 : topological_space (has_zero (has_nndist (option num)))) : irreducible_space (has_zero (has_nndist (option num))) := sorry --non-trivial
lemma new_lemma_59619 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (canonically_linear_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (ring.{0} (canonically_linear_ordered_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_59620 (h0 : add_group (has_nnnorm (semi_normed_ring reducibility_hints))) : is_add_cyclic (has_nnnorm (semi_normed_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_59621 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_atomistic.{0} (boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type complete_lattice.{0}) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero))) (boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_59622 (h0 : add_group (normed_field to_additive.value_type)) : is_add_cyclic (normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_59623 (h0 : functor.add_const (ring (has_neg_part name)) name) : @strong_rank_condition.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_neg_part.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_59624 (h0 : functor.add_const (ring (normed_comm_ring real)) linarith.comp) : @strong_rank_condition.{0} (normed_comm_ring.{0} real) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} real)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_59625 (h0 : function.extfun nat fin) : @is_add_cyclic.{0} (sub_neg_monoid.{0} name) (@matrix.vec_empty.{0} (add_group.{0} (sub_neg_monoid.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_59626 (h0 : group (complete_distrib_lattice (generalized_boolean_algebra pos))) : group.fg (complete_distrib_lattice (generalized_boolean_algebra pos)) := sorry --non-trivial
lemma new_lemma_59627 (h0 : has_mem.mem to_additive.value_type has_emptyc.emptyc) : @path_connected_space.{0} to_additive.value_type (@finset.pi.empty.{1 0} Type topological_space.{0} to_additive.value_type h0)  := sorry --non-trivial
lemma new_lemma_59628 (h0 : bin_tree num -> bin_tree num -> Prop) : is_strict_order (bin_tree num) h0 := sorry --non-trivial
lemma new_lemma_59629 (h0 : functor.add_const (topological_space (comm_group Type)) linarith.comp) : @totally_separated_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_59630 (h0 h1 : multiset (mul_one_class fun_info)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_59631 (h0 : false) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@id.{1} (filter.{0} Prop) (@false.elim.{1} (filter.{0} Prop) h0))  := sorry --trivial
lemma new_lemma_59632 (h0 : functor.add_const (group (measurable_space.dynkin_system congr_arg_kind)) unsigned) : @is_cyclic.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (measurable_space.dynkin_system.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_59633 (h0 : topological_space (measurable_space (random_gen to_additive.value_type))) : locally_compact_space (measurable_space (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_59634 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (normed_lattice_add_comm_group.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (normed_lattice_add_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_59635 (h0 : uniform_space (normed_group linarith.comp)) : separated_space (normed_group linarith.comp) := sorry --non-trivial
lemma new_lemma_59636 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_59637 (h0 : ordered_add_comm_monoid (has_Inf (has_Inf real))) : archimedean (has_Inf (has_Inf real)) := sorry --non-trivial
lemma new_lemma_59638 (h0 : cancel_comm_monoid_with_zero (simple_graph (has_to_string pos))) : unique_factorization_monoid (simple_graph (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_59639 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_59640 (h0 : complete_lattice (simple_graph (has_Inf linarith.comp))) : is_compactly_generated (simple_graph (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_59641 (h0 : functor.add_const (cancel_comm_monoid_with_zero (comm_group Type)) unsigned) : @unique_factorization_monoid.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (comm_group.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_59642 (h0 : uniform_space (add_monoid (has_nnnorm (has_nnnorm linarith.comp_source)))) : complete_space (add_monoid (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_59643 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @locally_compact_space.{0} (has_union.{0} (has_norm.{0} congr_arg_kind)) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_union.{0} (has_norm.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_59644 (h0 : functor.add_const (ring (boolean_algebra.core linarith.comp)) pos) : @is_domain.{0} (boolean_algebra.core.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_59645 (h0 : ring (has_bot (option (option empty)))) : rank_condition (has_bot (option (option empty))) := sorry --non-trivial
lemma new_lemma_59646 (h0 : function.extfun (Type 1) topological_space) : @preirreducible_space.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_59647 (h0 : topological_space (complete_linear_order (semiring (semiring (semiring empty))))) : topological_space.separable_space (complete_linear_order (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_59648 (h0 : semiring (has_union (semiring (semiring empty)))) : is_noetherian_ring (has_union (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_59649 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (simple_graph.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (simple_graph.{0} empty))  := sorry --non-trivial
lemma new_lemma_59650 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_emptyc.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_59651 (h0 : topological_space (canonically_ordered_comm_semiring ennreal)) : irreducible_space (canonically_ordered_comm_semiring ennreal) := sorry --non-trivial
lemma new_lemma_59652 (h0 : group (plift (add_right_cancel_monoid num))) : normalizer_condition (plift (add_right_cancel_monoid num)) := sorry --non-trivial
lemma new_lemma_59653 (h0 : monoid (has_neg_part (has_add (mul_zero_class name)))) : monoid.fg (has_neg_part (has_add (mul_zero_class name))) := sorry --non-trivial
lemma new_lemma_59654 (h0 : function.extfun Type (functor.add_const (functor.add_const (topological_space (linear_order empty)) num))) : @topological_space.separable_space.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_order.{0} empty)) num (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (topological_space.{0} (linear_order.{0} empty)) num) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (functor.add_const.{0 0} (topological_space.{0} (linear_order.{0} empty)) num)) h0 num)))  := sorry --non-trivial
lemma new_lemma_59655 (h0 : topological_space (random_gen (semiring (semiring linarith.comp)))) : irreducible_space (random_gen (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_59656 (h0 : topological_space (normed_group (has_norm to_additive.value_type))) : t0_space (normed_group (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_59657 (h0 : measurable_space (is_R_or_C std_gen)) (h1 : filter (is_R_or_C std_gen)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_59658 (h0 : finset (linear_ordered_field (option ennreal))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_59659 (h0 : semiring (complete_semilattice_Sup (has_norm empty))) : is_noetherian_ring (complete_semilattice_Sup (has_norm empty)) := sorry --non-trivial
lemma new_lemma_59660 (h0 : functor.add_const (ring (normed_comm_ring name)) pos) : @strong_rank_condition.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_59661 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (has_nndist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} empty))  := sorry --non-trivial
lemma new_lemma_59662 (h0 : not (topological_space (has_ssubset enat) -> false)) : @totally_disconnected_space.{0} (has_ssubset.{0} enat) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} enat)) h0)  := sorry --non-trivial
lemma new_lemma_59663 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_59664 (h0 : functor.add_const (function.extfun Type topological_space) real) : @path_connected_space.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) real h0) (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_59665 (h0 : group (has_to_string (option (option ennreal)))) : is_cyclic (has_to_string (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_59666 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (option.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (option.{0} pos))  := sorry --non-trivial
lemma new_lemma_59667 (h0 : topological_space (left_cancel_semigroup (semiring (semiring (semiring (semiring (semiring num))))))) : t1_space (left_cancel_semigroup (semiring (semiring (semiring (semiring (semiring num)))))) := sorry --non-trivial
lemma new_lemma_59668 (h0 : ring (with_bot linarith.comp_source)) : rank_condition (with_bot linarith.comp_source) := sorry --non-trivial
lemma new_lemma_59669 (h0 : not (topological_space (has_ssubset char) -> false)) : @path_connected_space.{0} (has_ssubset.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_59670 (h0 : not (topological_space (semi_normed_ring (mul_one_class char)) -> false)) : @path_connected_space.{0} (semi_normed_ring.{0} (mul_one_class.{0} char)) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_ring.{0} (mul_one_class.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_59671 (h0 : finset Type -> finset Type -> Prop) : is_antisymm (finset Type) h0 := sorry --non-trivial
lemma new_lemma_59672 (h0 : cancel_comm_monoid_with_zero (has_neg_part (has_nndist (finset environment.implicit_infer_kind)))) : unique_factorization_monoid (has_neg_part (has_nndist (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_59673 (h1 : uniform_space (denumerable (has_inv to_additive.value_type))) : complete_space (denumerable (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_59674 (h0 : ring (group_with_zero (option num))) : rank_condition (group_with_zero (option num)) := sorry --non-trivial
lemma new_lemma_59675 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_59676 (h0 : function.extfun Type (functor.add_const (topological_space nnreal))) : loc_path_connected_space nnreal := sorry --non-trivial
lemma new_lemma_59677 (h0 : topological_space (has_bot (has_neg name))) : regular_space (has_bot (has_neg name)) := sorry --non-trivial
lemma new_lemma_59678 (h0 : has_mem.mem (metric_space (has_top unsigned)) has_emptyc.emptyc) : @rank_condition.{0} (metric_space.{0} (has_top.{0} unsigned)) (@finset.pi.empty.{1 0} Type ring.{0} (metric_space.{0} (has_top.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_59679 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_59680 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) Type) : @has_exists_mul_of_le.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) Type h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_59681 (h0 : not (complete_lattice name -> false)) : @complete_lattice.is_Sup_finite_compact.{0} name (@classical.by_contradiction'.{1} (complete_lattice.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_59682 (h0 : ring (semigroup (option ennreal))) : is_domain (semigroup (option ennreal)) := sorry --non-trivial
lemma new_lemma_59683 (h0 h1 : multiset (has_ssubset char)) : multiset.subset h0 h1 := sorry --non-trivial
lemma new_lemma_59684 (h0 : functor.add_const (group (has_nndist name)) environment.implicit_infer_kind) : @is_simple_group.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_59685 (h3 : group linarith.comp_source) : group.fg linarith.comp_source := sorry --non-trivial
lemma new_lemma_59686 (h0 : semiring (boolean_algebra (finset (finset (finset (finset (finset (has_nndist Type)))))))) : is_noetherian_ring (boolean_algebra (finset (finset (finset (finset (finset (has_nndist Type))))))) := sorry --non-trivial
lemma new_lemma_59687 (h0 : topological_space (finset (finset (finset pos)))) : topological_space.separable_space (finset (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_59688 (h0 : not (group (has_top linarith.comp_source) -> false)) : @normalizer_condition.{0} (has_top.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (has_top.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_59689 (h0 : metric_space unsigned -> metric_space unsigned -> Prop) : is_refl (metric_space unsigned) h0 := sorry --non-trivial
lemma new_lemma_59690 (h0 : not (topological_space (linear_ordered_comm_ring num) -> false)) : @totally_disconnected_space.{0} (linear_ordered_comm_ring.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_ring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_59691 (h1 : function.extfun Type ring) : @rank_condition.{0} (distrib_lattice.{0} string_imp) (@function.extfun_app.{2 1} Type ring.{0} h1 (distrib_lattice.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_59692 (h0 : eq (omega_complete_partial_order std_gen) real) (h1 : omega_complete_partial_order std_gen) : irrational (eq.mp h0 h1) := sorry --non-trivial
lemma new_lemma_59693 (h0 : functor.add_const (ring (normed_comm_ring Type)) Type) : @rank_condition.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (normed_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_59694 (h0 : topological_space (has_zero (ring (boolean_algebra name)))) : preirreducible_space (has_zero (ring (boolean_algebra name))) := sorry --non-trivial
lemma new_lemma_59695 (h0 : function.extfun (Type 1) group) : @is_simple_group.{1} (generalized_boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (generalized_boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_59696 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_59697 (h0 : topological_space (has_norm (has_top congr_arg_kind))) : totally_disconnected_space (has_norm (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_59698 (h0 : monoid (measurable_space.dynkin_system congr_arg_kind)) : monoid.fg (measurable_space.dynkin_system congr_arg_kind) := sorry --non-trivial
lemma new_lemma_59699 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (has_inv.{0} char) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_inv.{0} char))  := sorry --non-trivial
lemma new_lemma_59700 (h0 : function.extfun nat fin) : @discrete_topology.{0} (canonically_ordered_monoid.{0} (has_neg.{0} linarith.comp)) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} (has_neg.{0} linarith.comp))) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_59701 (h0 : functor.add_const (topological_space (normed_comm_ring ennreal)) num) : @locally_compact_space.{0} (normed_comm_ring.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_59702 (h0 : not (ring (mul_zero_class unsigned) -> false)) : @is_domain.{0} (mul_zero_class.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (mul_zero_class.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_59703 (h0 : topological_space (add_comm_monoid (comm_group Type))) : preirreducible_space (add_comm_monoid (comm_group Type)) := sorry --non-trivial
lemma new_lemma_59704 (h0 : add_monoid (generalized_boolean_algebra (ring linarith.comp))) : add_monoid.fg (generalized_boolean_algebra (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_59705 (h0 : prod (canonically_ordered_comm_semiring (finset name)) (canonically_ordered_comm_semiring (finset name))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_59706 (h0 : topological_space (measure_theory.measure_space (semiring (semiring (semiring num))))) : discrete_topology (measure_theory.measure_space (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_59707 (h0 : ring (div_inv_monoid (has_ssubset (has_ssubset string_imp)))) : rank_condition (div_inv_monoid (has_ssubset (has_ssubset string_imp))) := sorry --non-trivial
lemma new_lemma_59708 (h0 : function.extfun Type (functor.comp group mul_zero_class)) : @is_cyclic.{0} (mul_zero_class.{0} pos) (@functor.comp.run.{0 0 0} group.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} group.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} group.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} group.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} group.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} group.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} group.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} group.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} group.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} group.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} group.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} group.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} group.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} group.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} group.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} group.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} group.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} group.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} group.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} group.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} group.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} group.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} group.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} group.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} group.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} group.{0} mul_zero_class.{0} pos (@functor.comp.run.{0 0 0} group.{0} mul_zero_class.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} group.{0} mul_zero_class.{0}) h0 pos))))))))))))))))))))))))))))  := sorry --non-trivial
lemma new_lemma_59709 (h0 : function.extfun (finset Type) (has_mem.mem (with_bot num))) : @totally_disconnected_space.{0} (with_bot.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_59710 (h1 : complete_lattice (mul_one_class (mul_one_class enat))) : complete_lattice.is_Sup_finite_compact (mul_one_class (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_59711 (h0 : uniform_space (distrib (random_gen (random_gen (random_gen (random_gen (random_gen string_imp))))))) : complete_space (distrib (random_gen (random_gen (random_gen (random_gen (random_gen string_imp)))))) := sorry --non-trivial
lemma new_lemma_59712 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_59713 (h0 : measurable_space (add_comm_semigroup linarith.ineq)) (h2 : Prop) : measurable_set (id (fun (h1 : add_comm_semigroup linarith.ineq), h2)) := sorry --non-trivial
lemma new_lemma_59714 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{0} (sub_neg_monoid.{0} name) (@matrix.vec_empty.{0} (ring.{0} (sub_neg_monoid.{0} name)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_59715 (h0 : topological_space (with_bot (has_norm (random_gen (random_gen num))))) : totally_disconnected_space (with_bot (has_norm (random_gen (random_gen num)))) := sorry --non-trivial
lemma new_lemma_59716 (h0 : functor.add_const (add_monoid (ordered_comm_ring real)) (has_add real)) : @add_monoid.fg.{0} (ordered_comm_ring.{0} real) (@functor.add_const.run.{0 0} (add_monoid.{0} (ordered_comm_ring.{0} real)) (has_add.{0} real) h0)  := sorry --non-trivial
lemma new_lemma_59717 (h0 : topological_space (cancel_monoid (with_bot Type))) : t1_space (cancel_monoid (with_bot Type)) := sorry --non-trivial
lemma new_lemma_59718 (h0 : add_monoid (metric_space linarith.comp)) : add_monoid.fg (metric_space linarith.comp) := sorry --non-trivial
lemma new_lemma_59719 (h0 : topological_space (measurable_space.dynkin_system num)) : irreducible_space (measurable_space.dynkin_system num) := sorry --non-trivial
lemma new_lemma_59720 (h0 : ring (as_linear_order (option (option empty)))) : is_principal_ideal_ring (as_linear_order (option (option empty))) := sorry --non-trivial
lemma new_lemma_59721 (h0 : functor.add_const (semiring (has_to_string environment.implicit_infer_kind)) (has_neg Type)) : @is_noetherian_ring.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (semiring.{0} (has_to_string.{0} environment.implicit_infer_kind)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_59722 (h0 : ring (has_emptyc (has_norm num))) : rank_condition (has_emptyc (has_norm num)) := sorry --non-trivial
lemma new_lemma_59723 (h0 : topological_space (has_star (semiring num))) : irreducible_space (has_star (semiring num)) := sorry --non-trivial
lemma new_lemma_59724 (h0 : topological_space (linear_ordered_semiring (has_top fun_info))) : totally_separated_space (linear_ordered_semiring (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_59725 (h0 : topological_space (add_comm_monoid Type)) : path_connected_space (add_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_59726 (h0 : functor.add_const (functor.add_const (complete_lattice environment.implicit_infer_kind) linarith.comp) Type) : @is_compactly_generated.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (complete_lattice.{0} environment.implicit_infer_kind) linarith.comp (@functor.add_const.run.{0 1} (functor.add_const.{0 0} (complete_lattice.{0} environment.implicit_infer_kind) linarith.comp) Type h0))  := sorry --non-trivial
lemma new_lemma_59727 (h0 : group (finset (has_add (has_add name)))) : group.fg (finset (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_59728 (h0 : not (complete_lattice empty -> false)) : @is_compactly_generated.{0} empty (@classical.by_contradiction'.{1} (complete_lattice.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_59729 (h0 : not (finset (complete_linear_order congr_arg_kind) -> false)) : finset.nonempty (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_59730 (h0 : ring (has_pos_part (has_Inf (has_Inf real)))) : strong_rank_condition (has_pos_part (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_59731 (h0 : ring (distrib (mul_one_class linarith.ineq))) : is_domain (distrib (mul_one_class linarith.ineq)) := sorry --non-trivial
lemma new_lemma_59732 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_59733 (h0 : functor.add_const (filter (add_cancel_monoid name)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_59734 (h0 : finset (has_bot empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_59735 (h0 : finset (has_add (has_to_string Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_59736 (h0 : has_mem.mem (with_bot congr_arg_kind) has_emptyc.emptyc) : @is_add_cyclic.{0} (with_bot.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type add_group.{0} (with_bot.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_59737 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_noetherian_ring.{1} (plift.{1} unsigned) (@function.extfun_app.{3 2} (Type 1) semiring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 semiring.{1}) (plift.{1} unsigned))  := sorry --non-trivial
lemma new_lemma_59738 (h0 : add_monoid (ring (finset (finset (has_pos_part Type))))) : add_monoid.fg (ring (finset (finset (has_pos_part Type)))) := sorry --non-trivial
lemma new_lemma_59739 (h0 : ring (has_inter (option num))) : strong_rank_condition (has_inter (option num)) := sorry --non-trivial
lemma new_lemma_59740 (h0 : topological_space (denumerable (random_gen char))) : totally_disconnected_space (denumerable (random_gen char)) := sorry --non-trivial
lemma new_lemma_59741 (h0 : topological_space (has_neg (has_to_string (has_to_string (has_to_string congr_arg_kind))))) : preconnected_space (has_neg (has_to_string (has_to_string (has_to_string congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_59742 (h0 : functor.comp topological_space add_cancel_monoid unsigned) : @regular_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} add_cancel_monoid.{0} unsigned h0)  := sorry --non-trivial
lemma new_lemma_59743 (h0 : functor.add_const (topological_space (semigroup pos)) pos) : @totally_separated_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_59744 (h2 : ring (simple_graph linarith.ineq)) : rank_condition (simple_graph linarith.ineq) := sorry --non-trivial
lemma new_lemma_59745 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (add_left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_59746 (h0 : add_group (generalized_boolean_algebra linarith.comp)) : is_add_cyclic (generalized_boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_59747 (h2 : complete_lattice (id fun_info)) : complete_lattice.is_Sup_finite_compact (id fun_info) := sorry --non-trivial
lemma new_lemma_59748 (h2 : topological_space linarith.comp_source) : locally_compact_space linarith.comp_source := sorry --non-trivial
lemma new_lemma_59749 (h0 : topological_space (linear_ordered_semiring (has_norm (has_norm linarith.comp)))) : irreducible_space (linear_ordered_semiring (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_59750 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_add.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_add.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_59751 (h0 : filter linarith.comp_source) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_59752 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (add_left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (add_left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_59753 (h0 : functor.add_const (topological_space (complete_linear_order empty)) empty) : @path_connected_space.{0} (complete_linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_linear_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_59754 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_59755 (h0 : functor.add_const (ring environment.implicit_infer_kind) name) : @is_domain.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (ring.{0} environment.implicit_infer_kind) name h0)  := sorry --non-trivial
lemma new_lemma_59756 (h0 : ring (boolean_algebra (normed_comm_ring pos))) : is_domain (boolean_algebra (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_59757 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @t1_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_59758 (h0 : functor.add_const (topological_space (boolean_algebra Type)) (has_add unsigned)) : @locally_compact_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) (has_add.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_59759 (h0 : functor.comp topological_space comm_group Type) : @sequential_space.{1} (comm_group.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} comm_group.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_59760 (h0 : topological_space (option unsigned)) : discrete_topology (option unsigned) := sorry --non-trivial
lemma new_lemma_59761 (h0 : add_monoid (has_dist (option empty))) : add_monoid.fg (has_dist (option empty)) := sorry --non-trivial
lemma new_lemma_59762 (h0 : has_mem.mem (measurable_space to_additive.value_type) has_emptyc.emptyc) : @monoid.fg.{0} (measurable_space.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type monoid.{0} (measurable_space.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_59763 (h0 : group (semi_normed_comm_ring string_imp)) : is_cyclic (semi_normed_comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_59764 (h0 : functor.add_const (uniform_space (comm_group pos)) linarith.comp) : @complete_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (comm_group.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_59765 (h0 : add_group (canonically_ordered_monoid name)) : is_add_cyclic (canonically_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_59766 (h0 : function.extfun (finset Type) (has_mem.mem (with_one fun_info))) : @is_atomistic.{0} (with_one.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_59767 (h0 : semiring (non_assoc_semiring (option (option (option empty))))) : is_noetherian_ring (non_assoc_semiring (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_59768 (h0 : functor.add_const (topological_space (ring Type)) Type) : @normal_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_59769 (h0 : topological_space (mv_power_series empty congr_arg_kind)) : loc_path_connected_space (mv_power_series empty congr_arg_kind) := sorry --non-trivial
lemma new_lemma_59770 (h0 : functor.add_const (semiring (finset linarith.comp)) Type) : @is_noetherian_ring.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 1} (semiring.{0} (finset.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_59771 (h0 : functor.add_const (topological_space (free_add_monoid empty)) empty) : @irreducible_space.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_59772 (h0 : uniform_space (has_nndist congr_arg_kind)) : complete_space (has_nndist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_59773 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @discrete_topology.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_59774 (h0 : functor.add_const (ring (has_add name)) environment.implicit_infer_kind) : @is_domain.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (has_add.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_59775 (h0 : functor.add_const (function.extfun (Type 1) ring) Type) : @strong_rank_condition.{1} (add_cancel_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ring.{1}) Type h0) (add_cancel_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_59776 (h0 : functor.add_const (topological_space (free_add_monoid num)) (semiring num)) : @normal_space.{0} (free_add_monoid.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} num)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_59777 (h0 : topological_space (normed_lattice_add_comm_group Type)) : discrete_topology (normed_lattice_add_comm_group Type) := sorry --non-trivial
lemma new_lemma_59778 (h0 : functor.add_const (function.extfun Type uniform_space) pos) : @separated_space.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) pos h0) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_59779 (h0 : monoid (metric_space linarith.comp)) : monoid.fg (metric_space linarith.comp) := sorry --non-trivial
lemma new_lemma_59780 (h0 : functor.add_const Prop (mul_zero_class environment.implicit_infer_kind)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_59781 (h0 : not (ring (left_cancel_monoid num) -> false)) : @rank_condition.{0} (left_cancel_monoid.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (left_cancel_monoid.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_59782 (h0 : functor.add_const (ordered_add_comm_monoid (normed_comm_ring Type)) linarith.comp) : @archimedean.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (normed_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_59783 (h0 : topological_space (has_one (has_top unsigned))) : path_connected_space (has_one (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_59784 (h0 : monoid (option (semiring empty))) : monoid.fg (option (semiring empty)) := sorry --non-trivial
lemma new_lemma_59785 (h0 : complete_lattice (has_le (mul_one_class (mul_one_class reducibility_hints)))) : complete_lattice.is_Sup_finite_compact (has_le (mul_one_class (mul_one_class reducibility_hints))) := sorry --non-trivial
lemma new_lemma_59786 (h0 : ring (denumerable (comm_ring char))) : rank_condition (denumerable (comm_ring char)) := sorry --non-trivial
lemma new_lemma_59787 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_59788 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) linarith.comp) : @loc_path_connected_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_59789 (h0 : ring (finset (option (option unsigned)))) : rank_condition (finset (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_59790 (h0 : complete_lattice (has_zero num)) : is_atomistic (has_zero num) := sorry --non-trivial
lemma new_lemma_59791 (h1 : topological_space reducibility_hints) (h2 : add_group reducibility_hints) : topological_add_group reducibility_hints := sorry --non-trivial
lemma new_lemma_59792 (h1 : topological_space (random_gen (has_inv string_imp))) : path_connected_space (random_gen (has_inv string_imp)) := sorry --non-trivial
lemma new_lemma_59793 (h0 : functor.add_const (topological_space (has_add pos)) (ring linarith.comp)) : @totally_separated_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) (ring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_59794 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_59795 (h0 : function.extfun (Type 1) topological_space) : @t0_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_59796 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (add_left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_59797 (h0 : functor.add_const (list (finset linarith.comp)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_59798 (h0 : functor.add_const (topological_space (semigroup Type)) environment.implicit_infer_kind) : @totally_disconnected_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_59799 (h0 : ring (measurable_space.dynkin_system (semiring empty))) : is_domain (measurable_space.dynkin_system (semiring empty)) := sorry --non-trivial
lemma new_lemma_59800 (h0 : monoid (measurable_space string_imp)) : monoid.fg (measurable_space string_imp) := sorry --non-trivial
lemma new_lemma_59801 (h0 : topological_space (has_neg (has_add (has_nndist (has_add (has_add (ring Type))))))) : regular_space (has_neg (has_add (has_nndist (has_add (has_add (ring Type)))))) := sorry --non-trivial
lemma new_lemma_59802 (h0 : function.extfun Type ring) : @rank_condition.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h0 (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_59803 (h0 : complete_lattice (has_emptyc (has_top (has_inv linarith.ineq)))) : is_compactly_generated (has_emptyc (has_top (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_59804 (h0 : not (ring (has_append linarith.ineq) -> false)) : @is_domain.{0} (has_append.{0} linarith.ineq) (@classical.by_contradiction'.{1} (ring.{0} (has_append.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_59805 (h0 : functor.add_const (group (add_cancel_monoid Type)) name) : @is_simple_group.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (add_cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_59806 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : is_add_cyclic real := sorry --non-trivial
lemma new_lemma_59807 (h0 : functor.add_const (topological_space (complete_distrib_lattice linarith.comp)) pos) : @discrete_topology.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_59808 (h0 : function.extfun Type (functor.add_const (complete_lattice (add_comm_monoid unsigned)))) : @complete_lattice.is_Sup_finite_compact.{0} (add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_comm_monoid.{0} unsigned)) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (add_comm_monoid.{0} unsigned))) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_59809 (h0 : topological_space (generalized_boolean_algebra (has_pos_part pos))) : discrete_topology (generalized_boolean_algebra (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_59810 (h0 : prod (pseudo_metric_space ennreal) (pseudo_metric_space ennreal)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_59811 (h0 : not (add_monoid (complete_semilattice_Sup num) -> false)) : @add_monoid.fg.{0} (complete_semilattice_Sup.{0} num) (@classical.by_contradiction'.{1} (add_monoid.{0} (complete_semilattice_Sup.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_59812 (h0 : add_group (normed_comm_ring (finset Type))) : is_add_cyclic (normed_comm_ring (finset Type)) := sorry --non-trivial
lemma new_lemma_59813 (h0 : functor.add_const (add_monoid (finset name)) pos) : @add_monoid.fg.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (finset.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_59814 (h0 : complete_lattice (has_nndist (has_add (has_add environment.implicit_infer_kind)))) : is_compactly_generated (has_nndist (has_add (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_59815 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_59816 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_59817 (h0 : function.extfun (Type 1) ring) : @is_domain.{1} Type (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 Type)  := sorry --non-trivial
lemma new_lemma_59818 (h0 : complete_lattice (semigroup (has_neg linarith.comp))) : is_atomistic (semigroup (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_59819 (h0 : ring (has_pos_part (has_pos_part linarith.comp))) : is_principal_ideal_ring (has_pos_part (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_59820 (h0 : set (has_le enat)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_59821 (h1 : not (group (metric_space num) -> false)) : @group.fg.{0} (metric_space.{0} num) (@classical.by_contradiction'.{1} (group.{0} (metric_space.{0} num)) h1)  := sorry --non-trivial
lemma new_lemma_59822 (h0 : group (canonically_ordered_monoid (ordered_comm_monoid pos))) : normalizer_condition (canonically_ordered_monoid (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_59823 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (add_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_59824 (h0 : topological_space (normed_lattice_add_comm_group (sub_neg_monoid (has_pos_part real)))) : sequential_space (normed_lattice_add_comm_group (sub_neg_monoid (has_pos_part real))) := sorry --non-trivial
lemma new_lemma_59825 (h0 : ordered_comm_monoid (has_to_string (has_nndist (boolean_algebra environment.implicit_infer_kind)))) : has_exists_mul_of_le (has_to_string (has_nndist (boolean_algebra environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_59826 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (semigroup.{0} num) (@function.extfun_app.{2 1} Type monoid.{0} h0 (semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_59827 (h0 : not (topological_space (has_ssubset (has_nnnorm fun_info)) -> false)) : @totally_disconnected_space.{0} (has_ssubset.{0} (has_nnnorm.{0} fun_info)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} (has_nnnorm.{0} fun_info))) h0)  := sorry --non-trivial
lemma new_lemma_59828 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_59829 (h0 : group (with_bot (has_inv (random_gen (has_inv (random_gen (has_inv fun_info))))))) : group.fg (with_bot (has_inv (random_gen (has_inv (random_gen (has_inv fun_info)))))) := sorry --non-trivial
lemma new_lemma_59830 (h0 : add_monoid (comm_semigroup real)) : add_monoid.fg (comm_semigroup real) := sorry --non-trivial
lemma new_lemma_59831 (h0 : functor.add_const (list (simple_graph Type)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_59832 (h0 : functor.add_const (filter (has_pos_part pos)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_59833 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (finset.{0} (option.{0} (option.{0} ennreal))) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (finset.{0} (option.{0} (option.{0} ennreal))))  := sorry --non-trivial
lemma new_lemma_59834 (h0 : functor.add_const (ring (ring Type)) linarith.comp) : @is_domain.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_59835 (h0 : functor.add_const (complete_lattice ennreal) num) : is_compactly_generated ennreal := sorry --non-trivial
lemma new_lemma_59836 (h0 : monoid (normed_comm_ring (has_add (has_add pos)))) : monoid.fg (normed_comm_ring (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_59837 (h0 : measurable_space linarith.comp_source) (h1 : measure_theory.measure linarith.comp_source) : measure_theory.sigma_finite h1 := sorry --non-trivial
lemma new_lemma_59838 (h0 : topological_space (canonically_ordered_monoid name)) : t1_space (canonically_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_59839 (h0 : function.extfun Type group) : @group.fg.{0} (has_inv.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} linarith.comp_source)))) (@function.extfun_app.{2 1} Type group.{0} h0 (has_inv.{0} (has_nnnorm.{0} (has_nnnorm.{0} (has_nnnorm.{0} linarith.comp_source)))))  := sorry --non-trivial
lemma new_lemma_59840 (h0 : ring (canonically_ordered_monoid (has_add Type))) : is_principal_ideal_ring (canonically_ordered_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_59841 (h0 : functor.add_const (uniform_space (add_left_cancel_semigroup empty)) unsigned) : @complete_space.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_left_cancel_semigroup.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_59842 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (add_cancel_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_59843 (h0 : functor.add_const (complete_lattice (boolean_algebra name)) Type) : @is_compactly_generated.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (complete_lattice.{0} (boolean_algebra.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_59844 (h0 : functor.add_const (filter (has_neg environment.implicit_infer_kind)) (has_add Type)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_59845 (h0 : functor.add_const (function.extfun Type topological_space) (ordered_ring linarith.comp)) : @preconnected_space.{0} (has_pos_part.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (ordered_ring.{0} linarith.comp) h0) (has_pos_part.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_59846 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (complete_distrib_lattice pos)) := sorry --non-trivial
lemma new_lemma_59847 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (has_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_59848 (h0 : function.extfun (Type 1) topological_space) : @t1_space.{1} (plift.{1} (has_bot.{0} empty)) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (plift.{1} (has_bot.{0} empty)))  := sorry --non-trivial
lemma new_lemma_59849 (h0 : ring (has_lt (mul_one_class char))) : is_domain (has_lt (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_59850 (h0 : monoid (has_star (semiring empty))) : monoid.fg (has_star (semiring empty)) := sorry --non-trivial
lemma new_lemma_59851 (h0 : cancel_comm_monoid_with_zero (has_Inf pos)) : unique_factorization_monoid (has_Inf pos) := sorry --non-trivial
lemma new_lemma_59852 (h0 : topological_space (plift congr_arg_kind)) : normal_space (plift congr_arg_kind) := sorry --non-trivial
lemma new_lemma_59853 (h3 h4 : multiset (mul_one_class linarith.comp_source)) : multiset.subset h3 h4 := sorry --non-trivial
lemma new_lemma_59854 (h0 : functor.add_const (semiring (cancel_monoid pos)) pos) : @is_noetherian_ring.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (cancel_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_59855 (h0 : fin has_zero.zero) : @irreducible_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_59856 (h0 : add_group to_additive.value_type) : is_add_cyclic to_additive.value_type := sorry --non-trivial
lemma new_lemma_59857 (h1 : not (ring (add_monoid char) -> false)) : @is_domain.{0} (add_monoid.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (add_monoid.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_59858 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_59859 (h0 : topological_space (has_top (normed_group fun_info))) : discrete_topology (has_top (normed_group fun_info)) := sorry --non-trivial
lemma new_lemma_59860 (h0 : ring (id unsigned)) : is_domain (id unsigned) := sorry --non-trivial
lemma new_lemma_59861 (h0 : topological_space linarith.ineq) (h1 : preorder linarith.ineq) : order_closed_topology linarith.ineq := sorry --non-trivial
lemma new_lemma_59862 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_59863 (h0 : finset (ring unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_59864 (h0 : functor.add_const (ordered_comm_monoid (finset linarith.comp)) (has_Inf pos)) : @has_exists_mul_of_le.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (finset.{0} linarith.comp)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_59865 (h0 : ordered_comm_monoid (has_bot Type)) : has_exists_mul_of_le (has_bot Type) := sorry --non-trivial
lemma new_lemma_59866 (h0 : topological_space (monoid_with_zero ennreal)) : locally_compact_space (monoid_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_59867 (h0 : topological_space (boolean_algebra (finset environment.implicit_infer_kind))) : t0_space (boolean_algebra (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_59868 (h0 : topological_space (pseudo_metric_space congr_arg_kind)) : t0_space (pseudo_metric_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_59869 (h0 : complete_lattice (complete_distrib_lattice (finset pos))) : complete_lattice.is_Sup_finite_compact (complete_distrib_lattice (finset pos)) := sorry --non-trivial
lemma new_lemma_59870 (h2 : complete_lattice (has_lt (add_right_cancel_monoid char))) : is_compactly_generated (has_lt (add_right_cancel_monoid char)) := sorry --non-trivial
lemma new_lemma_59871 (h0 : ring (has_compl (has_lt (semi_normed_comm_ring to_additive.value_type)))) : strong_rank_condition (has_compl (has_lt (semi_normed_comm_ring to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_59872 (h0 : ring (boolean_algebra.core (complete_distrib_lattice unsigned))) : is_principal_ideal_ring (boolean_algebra.core (complete_distrib_lattice unsigned)) := sorry --non-trivial
lemma new_lemma_59873 (h0 : not (list (has_inv fun_info) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_59874 (h0 : not (complete_lattice (distrib fun_info) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (distrib.{0} fun_info) (@classical.by_contradiction'.{1} (complete_lattice.{0} (distrib.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_59875 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (ordered_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_59876 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_add.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_59877 (h0 : function.extfun Type ring) : @is_domain.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_59878 (h0 : functor.add_const (add_group (add_left_cancel_semigroup empty)) empty) : @is_add_cyclic.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (add_left_cancel_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_59879 (h0 : ring (left_cancel_semigroup num)) : is_domain (left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_59880 (h0 : cancel_comm_monoid_with_zero (semigroup (has_neg name))) : unique_factorization_monoid (semigroup (has_neg name)) := sorry --non-trivial
lemma new_lemma_59881 (h0 : topological_space (simple_graph (has_nndist linarith.comp))) : totally_separated_space (simple_graph (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_59882 (h0 : function.extfun Type group) : @group.fg.{0} (denumerable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (denumerable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_59883 (h0 : topological_space (finset (finset pos))) : t1_space (finset (finset pos)) := sorry --non-trivial
lemma new_lemma_59884 (h0 : ring (with_one (semiring empty))) : is_domain (with_one (semiring empty)) := sorry --non-trivial
lemma new_lemma_59885 (h0 : has_mem.mem uniform_space has_emptyc.emptyc) : @complete_space.{1} Type (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@finset.pi.empty.{2 2} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) uniform_space.{1} h0) Type)  := sorry --non-trivial
lemma new_lemma_59886 (h0 : add_monoid (with_bot (semiring (semiring empty)))) : add_monoid.fg (with_bot (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_59887 (h0 : topological_space (option (semiring empty))) : normal_space (option (semiring empty)) := sorry --non-trivial
lemma new_lemma_59888 (h0 : topological_space (measurable_space empty)) : t0_space (measurable_space empty) := sorry --non-trivial
lemma new_lemma_59889 (h0 : not (function.extfun Type topological_space -> false)) : @normal_space.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) num)  := sorry --non-trivial
lemma new_lemma_59890 (h1 : topological_space (complete_semilattice_Sup to_additive.value_type)) : totally_separated_space (complete_semilattice_Sup to_additive.value_type) := sorry --non-trivial
lemma new_lemma_59891 (h0 : set (semi_normed_comm_ring fun_info)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_59892 (h0 : functor.add_const (topological_space Type) name) : @preconnected_space.{1} Type (@functor.add_const.run.{1 0} (topological_space.{1} Type) name h0)  := sorry --non-trivial
lemma new_lemma_59893 (h0 : uniform_space (semiring (has_top linarith.comp))) : separated_space (semiring (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_59894 (h1 : not (has_mem.mem (has_top linarith.ineq) has_emptyc.emptyc -> false)) : @path_connected_space.{0} (has_top.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} linarith.ineq) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} linarith.ineq) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h1))  := sorry --non-trivial
lemma new_lemma_59895 (h0 : uniform_space (emetric_space (has_inv linarith.comp_source))) : complete_space (emetric_space (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_59896 (h0 : topological_space (complete_distrib_lattice (option name))) : preconnected_space (complete_distrib_lattice (option name)) := sorry --non-trivial
lemma new_lemma_59897 (h0 : ring (has_to_string (boolean_algebra name))) : is_principal_ideal_ring (has_to_string (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_59898 (h0 : ring (cancel_monoid unsigned)) : is_domain (cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_59899 (h0 : topological_space (has_nndist environment.implicit_infer_kind)) : t1_space (has_nndist environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_59900 (h0 : has_le (topological_space to_additive.value_type)) (h1 : not (topological_space to_additive.value_type -> false)) : is_bot (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_59901 (h0 : topological_space (has_add (has_to_string pos))) : discrete_topology (has_add (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_59902 (h1 : ring (semiring num)) : strong_rank_condition (semiring num) := sorry --non-trivial
lemma new_lemma_59903 (h0 : functor.add_const (semiring (boolean_algebra Type)) (has_add (normed_comm_ring linarith.comp))) : @is_noetherian_ring.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (semiring.{1} (boolean_algebra.{1} Type)) (has_add.{0} (normed_comm_ring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_59904 (h0 : functor.add_const (topological_space (semigroup Type)) linarith.comp) : @totally_disconnected_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_59905 (h0 : ring (linear_ordered_semiring (semiring (semiring congr_arg_kind)))) : is_domain (linear_ordered_semiring (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_59906 (h0 : ring (normed_group (random_gen to_additive.value_type))) : rank_condition (normed_group (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_59907 (h0 : functor.add_const (filter (add_cancel_monoid environment.implicit_infer_kind)) linarith.comp) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_59908 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (finset unsigned)) := sorry --non-trivial
lemma new_lemma_59909 (h0 : topological_space (semiring (semiring (semiring (semiring (semiring (semiring empty))))))) : totally_separated_space (semiring (semiring (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_59910 (h0 : ring (linear_ordered_comm_ring (semiring (semiring unsigned)))) : strong_rank_condition (linear_ordered_comm_ring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_59911 (h0 : ring (denumerable (has_ssubset char))) : strong_rank_condition (denumerable (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_59912 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (has_Sup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_59913 (h0 : list (has_emptyc (has_top (has_top fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_59914 (h0 : complete_lattice (random_gen (as_linear_order char))) : complete_lattice.is_Sup_finite_compact (random_gen (as_linear_order char)) := sorry --non-trivial
lemma new_lemma_59915 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_59916 (h0 : topological_space (has_top (linear_ordered_semiring (random_gen unsigned)))) : normal_space (has_top (linear_ordered_semiring (random_gen unsigned))) := sorry --non-trivial
lemma new_lemma_59917 (h0 : topological_space (canonically_ordered_comm_semiring (has_add pos))) : locally_compact_space (canonically_ordered_comm_semiring (has_add pos)) := sorry --non-trivial
lemma new_lemma_59918 (h0 : complete_lattice (has_zero (has_to_string name))) : is_compactly_generated (has_zero (has_to_string name)) := sorry --non-trivial
lemma new_lemma_59919 (h0 : add_monoid (with_bot (has_norm empty))) : add_monoid.fg (with_bot (has_norm empty)) := sorry --non-trivial
lemma new_lemma_59920 (h0 : functor.add_const (cancel_comm_monoid_with_zero (preorder congr_arg_kind)) congr_arg_kind) : @unique_factorization_monoid.{0} (preorder.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (preorder.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_59921 (h1 : has_neg (add_comm_semigroup enat)) (h2 : measurable_space (add_comm_semigroup enat)) : has_measurable_neg (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_59922 (h0 : has_vadd char char) : add_action.is_pretransitive char char := sorry --non-trivial
lemma new_lemma_59923 (h0 : topological_space (left_cancel_semigroup (semiring (semiring unsigned)))) : t1_space (left_cancel_semigroup (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_59924 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem add_group)) : @is_add_cyclic.{0} linarith.comp_source (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_59925 (h0 : functor.add_const (topological_space (preorder empty)) congr_arg_kind) : @preirreducible_space.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_59926 (h0 : not (ring (normed_field fun_info) -> false)) : @strong_rank_condition.{0} (normed_field.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (normed_field.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_59927 (h0 : group (with_zero linarith.comp_source)) : is_cyclic (with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_59928 (h0 : functor.add_const (ring (boolean_algebra.core Type)) Type) : @is_principal_ideal_ring.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (boolean_algebra.core.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_59929 (h0 : complete_lattice (has_compl (has_nnnorm (random_gen (has_ssubset (random_gen fun_info)))))) : is_compactly_generated (has_compl (has_nnnorm (random_gen (has_ssubset (random_gen fun_info))))) := sorry --non-trivial
lemma new_lemma_59930 (h0 : ring (has_neg_part (has_neg (semigroup (semigroup pos))))) : rank_condition (has_neg_part (has_neg (semigroup (semigroup pos)))) := sorry --non-trivial
lemma new_lemma_59931 (h0 : char) (h1 : false) : sym2.mem h0 (false.elim h1) := sorry --trivial
lemma new_lemma_59932 (h0 : not (topological_space (has_sub unsigned) -> false)) : @path_connected_space.{0} (has_sub.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (has_sub.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_59933 (h0 : topological_space (complete_distrib_lattice (ring pos))) : preirreducible_space (complete_distrib_lattice (ring pos)) := sorry --non-trivial
lemma new_lemma_59934 (h0 : list (id (has_inv fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_59935 (h0 : topological_space (generalized_boolean_algebra (has_nndist pos))) : t0_space (generalized_boolean_algebra (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_59936 (h0 : has_emptyc (has_top (has_top (has_top (has_top linarith.comp_source))))) (h1 : filter (has_emptyc (has_top (has_top (has_top (has_top linarith.comp_source)))))) : @totally_separated_space.{0} (has_emptyc.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.comp_source))))) (@nhds_adjoint.{0} (has_emptyc.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.comp_source))))) h0 h1)  := sorry --non-trivial
lemma new_lemma_59937 (h0 : functor.add_const (topological_space (cancel_monoid Type)) linarith.comp) : @preconnected_space.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_59938 (h0 : functor.add_const (topological_space (add_cancel_comm_monoid pos)) pos) : @t0_space.{0} (add_cancel_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_comm_monoid.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_59939 (h0 : complete_lattice (id (random_gen linarith.comp))) : is_atomistic (id (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_59940 (h0 : topological_space (finset (finset (finset linarith.comp)))) : t1_space (finset (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_59941 (h0 : functor.add_const (list (generalized_boolean_algebra name)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_59942 (h1 : function.extfun Type add_group) : @is_add_cyclic.{0} (measurable_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} h1 (measurable_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_59943 (h0 : topological_space (add_comm_monoid (has_neg (has_neg Type)))) : normal_space (add_comm_monoid (has_neg (has_neg Type))) := sorry --non-trivial
lemma new_lemma_59944 (h0 : functor.add_const (function.extfun Type semiring) (option pos)) : @is_noetherian_ring.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type semiring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type semiring.{0}) (option.{0} pos) h0) (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_59945 (h0 : not (complete_lattice (linear_ordered_add_comm_group linarith.ineq) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_add_comm_group.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (linear_ordered_add_comm_group.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_59946 (h0 : functor.add_const (list (boolean_algebra linarith.comp)) pos) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_59947 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) Type) : @discrete_topology.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_59948 (h0 : finset (ordered_ring (semiring (semiring (semiring (semiring (semiring num))))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_59949 (h0 : function.extfun nat fin) : @normalizer_condition.{0} (has_add.{0} real) (@matrix.vec_empty.{0} (group.{0} (has_add.{0} real)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) real (@matrix.vec_empty.{0} (functor.add_const.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) real) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))))  := sorry --non-trivial
lemma new_lemma_59950 (h0 : functor.add_const (uniform_space (canonically_ordered_comm_semiring name)) Type) : @complete_space.{0} (canonically_ordered_comm_semiring.{0} name) (@functor.add_const.run.{0 1} (uniform_space.{0} (canonically_ordered_comm_semiring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_59951 (h0 : complete_lattice (linear_ordered_semiring num)) : complete_lattice.is_Sup_finite_compact (linear_ordered_semiring num) := sorry --non-trivial
lemma new_lemma_59952 (h0 : uniform_space (add_group (semiring (has_top (semiring unsigned))))) : complete_space (add_group (semiring (has_top (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_59953 (h0 : functor.add_const (topological_space (has_add linarith.comp)) environment.implicit_infer_kind) : @preconnected_space.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_59954 (h0 : group (has_append (has_nnnorm string_imp))) : is_cyclic (has_append (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_59955 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_59956 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (pseudo_metric_space.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (pseudo_metric_space.{0} num))  := sorry --non-trivial
lemma new_lemma_59957 (h0 : topological_space (has_inter (option unsigned))) : discrete_topology (has_inter (option unsigned)) := sorry --non-trivial
lemma new_lemma_59958 (h0 : complete_lattice (finset congr_arg_kind)) : is_atomistic (finset congr_arg_kind) := sorry --non-trivial
lemma new_lemma_59959 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_59960 (h0 : ring (normed_field (comm_ring string_imp))) : rank_condition (normed_field (comm_ring string_imp)) := sorry --non-trivial
lemma new_lemma_59961 (h0 : topological_space (has_neg (has_to_string ennreal))) : preconnected_space (has_neg (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_59962 (h0 : functor.add_const (topological_space (has_add pos)) real) : @totally_disconnected_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) real h0)  := sorry --non-trivial
lemma new_lemma_59963 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) linarith.comp) : @archimedean.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) linarith.comp h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_59964 (h0 : function.extfun (Type 1) monoid) : @monoid.fg.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) monoid.{1} h0 (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_59965 (h0 : functor.add_const (add_group (has_add name)) (has_zero name)) : @is_add_cyclic.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (has_add.{0} name)) (has_zero.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_59966 (h0 : topological_space (add_cancel_monoid (ring Type))) : discrete_topology (add_cancel_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_59967 (h0 : complete_lattice (has_zero (finset (finset (finset pos))))) : is_compactly_generated (has_zero (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_59968 (h0 : functor.add_const (topological_space (has_Inf linarith.comp)) name) : @t0_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_59969 (h0 h1 : multiset std_gen) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_59970 (h0 : complete_lattice (normed_field (metric_space linarith.comp_source))) : is_compactly_generated (normed_field (metric_space linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_59971 (h0 : uniform_space (denumerable (linear_ordered_add_comm_group char))) : complete_space (denumerable (linear_ordered_add_comm_group char)) := sorry --non-trivial
lemma new_lemma_59972 (h0 : functor.add_const (function.extfun Type ring) (finset pos)) : @is_domain.{0} (linear_ordered_add_comm_monoid_with_top.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (finset.{0} pos) h0) (linear_ordered_add_comm_monoid_with_top.{0} pos))  := sorry --non-trivial
lemma new_lemma_59973 (h0 : functor.add_const (finset (option unsigned)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_59974 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (omega_complete_partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_59975 (h0 : complete_lattice (random_gen (mul_one_class to_additive.value_type))) : is_compactly_generated (random_gen (mul_one_class to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_59976 (h0 : has_mul (linear_ordered_comm_group empty)) (h1 : filter (con (linear_ordered_comm_group empty))) : countable_Inter_filter h1 := sorry --non-trivial
lemma new_lemma_59977 (h0 : functor.add_const (finset (has_nndist pos)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_59978 (h3 : has_coe (nondiscrete_normed_field (nondiscrete_normed_field char)) Prop) (h4 : nondiscrete_normed_field (nondiscrete_normed_field char)) : @coe_b.{1 1} (nondiscrete_normed_field.{0} (nondiscrete_normed_field.{0} char)) Prop h3 h4  := sorry --non-trivial
lemma new_lemma_59979 (h1 : topological_space (semi_normed_comm_ring linarith.comp_source)) : t0_space (semi_normed_comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_59980 (h0 : filter (normed_group (has_inv to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_59981 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_inter.{0} ennreal) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_inter.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_59982 (h1 : has_lt (nondiscrete_normed_field ereal)) : no_max_order (nondiscrete_normed_field ereal) := sorry --non-trivial
lemma new_lemma_59983 (h0 : topological_space (boolean_algebra (boolean_algebra environment.implicit_infer_kind))) : preconnected_space (boolean_algebra (boolean_algebra environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_59984 (h0 : ring (has_norm (semiring empty))) : rank_condition (has_norm (semiring empty)) := sorry --non-trivial
lemma new_lemma_59985 (h0 : add_monoid (option (semiring empty))) : add_monoid.fg (option (semiring empty)) := sorry --non-trivial
lemma new_lemma_59986 (h0 : function.extfun Type group) : @normalizer_condition.{0} real (@function.extfun_app.{2 1} Type group.{0} h0 real)  := sorry --non-trivial
lemma new_lemma_59987 (h0 : functor.add_const (filter (pseudo_metric_space ennreal)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_59988 (h0 : list (mul_zero_class (semigroup Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_59989 (h0 : has_le enat) (h2 : enat) : is_bot h2 := sorry --non-trivial
lemma new_lemma_59990 (h1 : has_mem.mem (complete_semilattice_Sup congr_arg_kind) has_emptyc.emptyc) : @path_connected_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_59991 (h0 : function.extfun (finset Type -> Prop) (function.extfun (finset Type))) : @path_connected_space.{0} (with_one.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} linarith.comp_source)) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) h0 (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} linarith.comp_source))) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_59992 (h0 : cancel_comm_monoid_with_zero (semigroup (has_add (has_neg pos)))) : unique_factorization_monoid (semigroup (has_add (has_neg pos))) := sorry --non-trivial
lemma new_lemma_59993 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (distrib_lattice.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (distrib_lattice.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_59994 (h0 : with_one (has_norm string_imp) -> with_one (has_norm string_imp) -> bool) : is_dec_refl h0 := sorry --non-trivial
lemma new_lemma_59995 (h0 : semiring enat) (h1 : enat) : even h1 := sorry --non-trivial
lemma new_lemma_59996 (h0 : topological_space (has_nndist (finset (finset pos)))) : path_connected_space (has_nndist (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_59997 (h0 : function.extfun (Type 1) topological_space) : @totally_separated_space.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_59998 (h0 : uniform_space (filter congr_arg_kind)) : separated_space (filter congr_arg_kind) := sorry --non-trivial
lemma new_lemma_59999 (h0 : topological_space (has_neg (boolean_algebra.core ennreal))) : regular_space (has_neg (boolean_algebra.core ennreal)) := sorry --non-trivial
lemma new_lemma_60000 (h0 : group (generalized_boolean_algebra (has_neg (has_neg (has_neg name))))) : is_cyclic (generalized_boolean_algebra (has_neg (has_neg (has_neg name)))) := sorry --non-trivial
lemma new_lemma_60001 (h0 : functor.add_const (ordered_add_comm_monoid (comm_group environment.implicit_infer_kind)) name) : @archimedean.{0} (comm_group.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (comm_group.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_60002 (h0 : functor.add_const (add_group (normed_linear_ordered_group num)) num) : @is_add_cyclic.{0} (normed_linear_ordered_group.{0} num) (@functor.add_const.run.{0 0} (add_group.{0} (normed_linear_ordered_group.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_60003 (h0 : functor.add_const (group (finset linarith.comp)) linarith.comp) : @is_cyclic.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_60004 (h0 : complete_lattice (has_nndist (option pos))) : complete_lattice.is_Sup_finite_compact (has_nndist (option pos)) := sorry --non-trivial
lemma new_lemma_60005 (h1 : ring (div_inv_monoid (has_nnnorm (random_gen char)))) : rank_condition (div_inv_monoid (has_nnnorm (random_gen char))) := sorry --non-trivial
lemma new_lemma_60006 (h0 : fin has_zero.zero) : @normal_space.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_60007 (h0 : list (linear_ordered_comm_group (comm_monoid (option unsigned)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_60008 (h1 : topological_space (add_left_cancel_monoid char)) : t0_space (add_left_cancel_monoid char) := sorry --non-trivial
lemma new_lemma_60009 (h0 : complete_lattice (add_cancel_monoid linarith.comp)) : is_compactly_generated (add_cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_60010 (h0 : group (canonically_ordered_monoid (sub_neg_monoid real))) : is_simple_group (canonically_ordered_monoid (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_60011 (h0 : topological_space (has_top (semiring linarith.comp))) : path_connected_space (has_top (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_60012 (h0 : topological_space (has_neg_part (has_nndist ennreal))) : totally_disconnected_space (has_neg_part (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_60013 (h0 : functor.add_const (topological_space (has_neg Type)) Type) : @loc_path_connected_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_neg.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_60014 (h0 : not (ring (complete_semilattice_Sup linarith.comp) -> false)) : @is_domain.{0} (complete_semilattice_Sup.{0} linarith.comp) (@classical.by_contradiction'.{1} (ring.{0} (complete_semilattice_Sup.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_60015 (h0 : group (ordered_cancel_add_comm_monoid (semigroup congr_arg_kind))) : group.fg (ordered_cancel_add_comm_monoid (semigroup congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_60016 (h0 : topological_space (random_gen (has_top fun_info))) : locally_compact_space (random_gen (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_60017 (h1 : function.extfun Type ring) : @is_domain.{0} (complete_semilattice_Sup.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} h1 (complete_semilattice_Sup.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_60018 (h0 : has_mem.mem (linear_ordered_semiring (semiring fun_info)) has_emptyc.emptyc) : @is_atomistic.{0} (linear_ordered_semiring.{0} (semiring.{0} fun_info)) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (linear_ordered_semiring.{0} (semiring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_60019 (h0 : topological_space (finset (ring Type))) : t0_space (finset (ring Type)) := sorry --non-trivial
lemma new_lemma_60020 (h0 : functor.add_const (topological_space (has_Inf pos)) (ring Type)) : @totally_separated_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} pos)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_60021 (h0 : topological_space (with_bot (measurable_space (random_gen (has_top empty))))) : totally_separated_space (with_bot (measurable_space (random_gen (has_top empty)))) := sorry --non-trivial
lemma new_lemma_60022 (h0 : group (normed_comm_ring (has_to_string (has_to_string name)))) : group.fg (normed_comm_ring (has_to_string (has_to_string name))) := sorry --non-trivial
lemma new_lemma_60023 (h0 : ulower (ulower Prop)) : @ulower.up.{0} Prop encodable.Prop (@ulower.up.{0} (@ulower.{0} Prop encodable.Prop) (@ulower.encodable.{0} Prop encodable.Prop) h0)  := sorry --non-trivial
lemma new_lemma_60024 (h0 : has_coe (add_comm_semigroup (partial_order (mul_one_class linarith.ineq))) Prop) (h1 : add_comm_semigroup (partial_order (mul_one_class linarith.ineq))) : @coe_b.{1 1} (add_comm_semigroup.{0} (partial_order.{0} (mul_one_class.{0} linarith.ineq))) Prop h0 h1  := sorry --non-trivial
lemma new_lemma_60025 (h1 : group empty) : normalizer_condition empty := sorry --non-trivial
lemma new_lemma_60026 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) pos) : @path_connected_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_60027 (h0 : functor.add_const (add_group (linear_order empty)) empty) : @is_add_cyclic.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (linear_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_60028 (h0 : topological_space (has_inner (option empty) unsigned)) : discrete_topology (has_inner (option empty) unsigned) := sorry --non-trivial
lemma new_lemma_60029 (h1 : has_mem.mem complete_lattice has_emptyc.emptyc) : @is_atomistic.{0} congr_arg_kind (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} h1) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_60030 (h0 : ring (has_zero (ring (ring (has_neg pos))))) : is_principal_ideal_ring (has_zero (ring (ring (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_60031 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (cancel_monoid.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_60032 (h0 : function.extfun Type group) : @is_cyclic.{0} (semiring.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} linarith.comp_source)))) (@function.extfun_app.{2 1} Type group.{0} h0 (semiring.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} linarith.comp_source)))))  := sorry --non-trivial
lemma new_lemma_60033 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_60034 (h0 : topological_space (has_norm (has_norm fun_info))) : locally_compact_space (has_norm (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_60035 (h0 : add_monoid (mul_zero_class (semiring unsigned))) : add_monoid.fg (mul_zero_class (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_60036 (h0 : complete_lattice (has_ssubset (random_gen (random_gen (random_gen linarith.ineq))))) : is_compactly_generated (has_ssubset (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_60037 (h0 : topological_space (has_compl (random_gen char))) : t0_space (has_compl (random_gen char)) := sorry --non-trivial
lemma new_lemma_60038 (h0 : set (has_ssubset fun_info)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_60039 (h0 : not (group (option unsigned) -> false)) : @normalizer_condition.{0} (option.{0} unsigned) (@classical.by_contradiction'.{1} (group.{0} (option.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_60040 (h0 : topological_space (has_nnnorm (with_zero fun_info))) : path_connected_space (has_nnnorm (with_zero fun_info)) := sorry --non-trivial
lemma new_lemma_60041 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_60042 (h0 : not (function.extfun Type complete_lattice -> false)) : @is_atomistic.{0} string_imp (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) string_imp)  := sorry --non-trivial
lemma new_lemma_60043 (h0 : topological_space ennreal) : totally_separated_space ennreal := sorry --non-trivial
lemma new_lemma_60044 (h0 : topological_space (add_cancel_monoid (finset (finset linarith.comp)))) : preconnected_space (add_cancel_monoid (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_60045 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_60046 (h0 : filter (semigroup (finset pos))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_60047 (h0 : not (ring (measurable_space.dynkin_system num) -> false)) : @is_principal_ideal_ring.{0} (measurable_space.dynkin_system.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.dynkin_system.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_60048 (h0 : topological_space (with_zero (has_inv (has_inv (has_inv (has_inv fun_info)))))) : t0_space (with_zero (has_inv (has_inv (has_inv (has_inv fun_info))))) := sorry --non-trivial
lemma new_lemma_60049 (h0 : ring (has_bot (sub_neg_monoid pos))) : is_principal_ideal_ring (has_bot (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_60050 (h0 : functor.add_const (group (ordered_comm_ring pos)) Type) : @is_cyclic.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (ordered_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_60051 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_60052 (h0 : complete_lattice (boolean_algebra (has_pos_part Type))) : is_compactly_generated (boolean_algebra (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_60053 (h0 : topological_space (has_one (has_norm unsigned))) : normal_space (has_one (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_60054 (h0 : add_group (complete_semilattice_Sup (has_norm linarith.ineq))) : is_add_cyclic (complete_semilattice_Sup (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_60055 (h2 : topological_space (topological_space to_additive.value_type)) : path_connected_space (topological_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_60056 (h0 : functor.add_const (function.extfun (Type 1) ring) pos) : @is_principal_ideal_ring.{1} Type (@function.extfun_app.{3 2} (Type 1) ring.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ring.{1}) pos h0) Type)  := sorry --non-trivial
lemma new_lemma_60057 (h0 : functor.add_const (ordered_comm_monoid (finset name)) environment.implicit_infer_kind) : @has_exists_mul_of_le.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (finset.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_60058 (h0 : ring (normed_comm_ring (semiring congr_arg_kind))) : rank_condition (normed_comm_ring (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_60059 (h0 : group (add_comm_monoid (comm_group (has_zero Type)))) : group.fg (add_comm_monoid (comm_group (has_zero Type))) := sorry --non-trivial
lemma new_lemma_60060 (h0 : group (normed_group (random_gen to_additive.value_type))) : normalizer_condition (normed_group (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_60061 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (non_assoc_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_60062 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_60063 (h0 : function.extfun (finset Type -> Prop) (function.extfun (finset Type))) : @monoid.fg.{0} (has_top.{0} unsigned) (@finset.pi.empty.{1 0} Type monoid.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} unsigned)) (@function.extfun_app.{2 0} (finset.{1} Type → Prop) (function.extfun.{2 0} (finset.{1} Type)) h0 (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} unsigned))) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_60064 (h0 : ordered_add_comm_monoid (has_Inf (has_pos_part pos))) : archimedean (has_Inf (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_60065 (h0 : topological_space (non_unital_non_assoc_semiring string_imp)) (h1 : preorder (non_unital_non_assoc_semiring string_imp)) : order_topology (non_unital_non_assoc_semiring string_imp) := sorry --non-trivial
lemma new_lemma_60066 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @normal_space.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_60067 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (add_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (add_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_60068 (h0 : has_coe enat Prop) (h1 : enat) : @coe_b.{1 1} enat Prop h0 h1  := sorry --non-trivial
lemma new_lemma_60069 (h0 : functor.add_const (uniform_space (bin_tree congr_arg_kind)) congr_arg_kind) : @separated_space.{0} (bin_tree.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (bin_tree.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_60070 (h0 : cancel_comm_monoid_with_zero (cancel_monoid environment.implicit_infer_kind)) : unique_factorization_monoid (cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_60071 (h0 : functor.add_const (function.extfun Type topological_space) environment.implicit_infer_kind) : @preconnected_space.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) environment.implicit_infer_kind h0) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_60072 (h0 : monoid (measurable_space (has_top empty))) : monoid.fg (measurable_space (has_top empty)) := sorry --non-trivial
lemma new_lemma_60073 (h0 : function.extfun Type ring) : @is_domain.{0} (as_linear_order.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (as_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_60074 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_to_string.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} num))  := sorry --non-trivial
lemma new_lemma_60075 (h2 : complete_lattice (fintype to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (fintype to_additive.value_type) := sorry --non-trivial
lemma new_lemma_60076 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @preirreducible_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_60077 (h0 : has_mem.mem (with_one empty) has_emptyc.emptyc) : @path_connected_space.{0} (with_one.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_60078 (h0 : topological_space (has_add Type)) : path_connected_space (has_add Type) := sorry --non-trivial
lemma new_lemma_60079 (h0 : fin has_zero.zero) : @regular_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_60080 (h1 : has_mem.mem (has_norm num) has_emptyc.emptyc) (h2 : function.extfun (finset Type) (has_mem.mem num)) : @odd.{0} (has_norm.{0} num) (@finset.pi.empty.{1 0} Type semiring.{0} (has_norm.{0} num) h1) (@finset.pi.empty.{1 0} Type has_norm.{0} num (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num) h2 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_60081 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) num) : @preirreducible_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) num h0)  := sorry --non-trivial
lemma new_lemma_60082 (h0 : complete_lattice (linear_ordered_comm_group_with_zero enat)) : complete_lattice.is_Sup_finite_compact (linear_ordered_comm_group_with_zero enat) := sorry --non-trivial
lemma new_lemma_60083 (h0 : functor.add_const (add_monoid (normed_comm_ring name)) environment.implicit_infer_kind) : @add_monoid.fg.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (normed_comm_ring.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_60084 (h0 : complete_lattice (option (semiring unsigned))) : is_compactly_generated (option (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_60085 (h0 : functor.add_const (ordered_comm_monoid (add_comm_monoid name)) Type) : @has_exists_mul_of_le.{0} (add_comm_monoid.{0} name) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (add_comm_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_60086 (h0 : uniform_space (complete_semilattice_Sup empty)) : complete_space (complete_semilattice_Sup empty) := sorry --non-trivial
lemma new_lemma_60087 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_60088 (h0 : topological_space (non_assoc_semiring unsigned)) : discrete_topology (non_assoc_semiring unsigned) := sorry --non-trivial
lemma new_lemma_60089 (h0 : not (fin has_zero.zero -> false)) : @is_add_cyclic.{0} (has_union.{0} unsigned) (@id.{1} (add_group.{0} (has_union.{0} unsigned)) (@matrix.vec_empty.{0} (add_group.{0} (has_union.{0} unsigned)) (@classical.by_contradiction'.{1} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_60090 (h0 : group (with_one (with_one congr_arg_kind))) : group.fg (with_one (with_one congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_60091 (h0 : topological_space (canonically_ordered_monoid (has_add Type))) : preconnected_space (canonically_ordered_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_60092 (h0 : group (mul_zero_class pos)) : group.fg (mul_zero_class pos) := sorry --non-trivial
lemma new_lemma_60093 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (left_cancel_semigroup.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (left_cancel_semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_60094 (h1 : topological_space (has_emptyc to_additive.value_type)) : path_connected_space (has_emptyc to_additive.value_type) := sorry --non-trivial
lemma new_lemma_60095 (h0 : topological_space (pseudo_metric_space (option empty))) : normal_space (pseudo_metric_space (option empty)) := sorry --non-trivial
lemma new_lemma_60096 (h2 : add_group (normed_field to_additive.value_type)) : is_add_cyclic (normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_60097 (h0 : ring (boolean_algebra (has_pos_part real))) : rank_condition (boolean_algebra (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_60098 (h0 : topological_space (ordered_comm_monoid (ring Type))) : normal_space (ordered_comm_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_60099 (h0 : function.extfun Type topological_space) : @t0_space.{0} (preorder.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} empty))  := sorry --non-trivial
lemma new_lemma_60100 (h0 : not (ring (linear_ordered_comm_ring num) -> false)) : @is_domain.{0} (linear_ordered_comm_ring.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (linear_ordered_comm_ring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_60101 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_inv.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_inv.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_60102 (h0 : ring (semi_normed_comm_ring (semi_normed_comm_ring (random_gen reducibility_hints)))) : rank_condition (semi_normed_comm_ring (semi_normed_comm_ring (random_gen reducibility_hints))) := sorry --non-trivial
lemma new_lemma_60103 (h0 : set string.iterator_imp) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_60104 (h0 : topological_space (has_neg (finset linarith.comp))) : loc_path_connected_space (has_neg (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_60105 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_60106 (h0 : simple_graph (topological_space (random_gen to_additive.value_type))) (h1 : topological_space (random_gen to_additive.value_type)) : simple_graph.support h0 h1 := sorry --non-trivial
lemma new_lemma_60107 (h0 : not (topological_space (ring linarith.ineq) -> false)) : @t0_space.{0} (ring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (ring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_60108 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_comm_monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_60109 (h1 : measurable_space (nondiscrete_normed_field enat)) (h2 : filter (nondiscrete_normed_field enat)) : filter.is_measurably_generated h2 := sorry --non-trivial
lemma new_lemma_60110 (h0 : topological_space (div_inv_monoid (random_gen (comm_ring linarith.ineq)))) : path_connected_space (div_inv_monoid (random_gen (comm_ring linarith.ineq))) := sorry --non-trivial
lemma new_lemma_60111 (h0 : has_mem.mem (measurable_space linarith.comp) has_emptyc.emptyc) : @is_domain.{0} (measurable_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type ring.{0} (measurable_space.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_60112 (h0 : semiring (preorder (option empty))) : is_noetherian_ring (preorder (option empty)) := sorry --non-trivial
lemma new_lemma_60113 (h0 : functor.add_const (topological_space (cancel_monoid environment.implicit_infer_kind)) linarith.comp) : @loc_path_connected_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_60114 (h0 : function.extfun Type (prod (add_group unsigned))) : id_rel (function.extfun_app h0 (add_group unsigned)) := sorry --non-trivial
lemma new_lemma_60115 (h0 : not (ring (semi_normed_ring (mul_one_class char)) -> false)) : @is_domain.{0} (semi_normed_ring.{0} (mul_one_class.{0} char)) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_ring.{0} (mul_one_class.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_60116 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_60117 (h0 : filter (with_one (semiring (has_norm (semiring num))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_60118 (h0 : complete_lattice (random_gen linarith.comp_source)) : is_compactly_generated (random_gen linarith.comp_source) := sorry --non-trivial
lemma new_lemma_60119 (h0 : topological_space (has_nndist (has_Inf (finset (finset (finset environment.implicit_infer_kind)))))) : discrete_topology (has_nndist (has_Inf (finset (finset (finset environment.implicit_infer_kind))))) := sorry --non-trivial
lemma new_lemma_60120 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen linarith.comp_source))) : @path_connected_space.{0} (random_gen.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_60121 (h0 : complete_lattice (linear_ordered_field (option (option ennreal)))) : is_compactly_generated (linear_ordered_field (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_60122 (h0 : topological_space (complete_semilattice_Sup (with_one to_additive.value_type))) : locally_compact_space (complete_semilattice_Sup (with_one to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_60123 (h1 : uniform_space (has_inv (random_gen string_imp))) : complete_space (has_inv (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_60124 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (canonically_ordered_comm_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_60125 (h0 : functor.add_const (ring (normed_comm_ring unsigned)) congr_arg_kind) : @is_domain.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_60126 (h0 : topological_space (has_ssubset (random_gen linarith.ineq))) : path_connected_space (has_ssubset (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_60127 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring ennreal)) (option name)) : @sequential_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} ennreal)) (option.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_60128 (h0 : list (finset (option congr_arg_kind))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_60129 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (monoid.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_60130 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (group_with_zero.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (group_with_zero.{0} empty))  := sorry --non-trivial
lemma new_lemma_60131 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (generalized_boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (generalized_boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_60132 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (semiring.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (semiring.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_60133 (h0 : filter (has_norm (random_gen to_additive.value_type))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_60134 (h0 : ring (complete_semilattice_Sup (has_top to_additive.value_type))) : is_domain (complete_semilattice_Sup (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_60135 (h0 : topological_space (add_cancel_monoid (option name))) : normal_space (add_cancel_monoid (option name)) := sorry --non-trivial
lemma new_lemma_60136 (h0 : monoid (with_bot (semiring (semiring (semiring (has_top unsigned)))))) : monoid.fg (with_bot (semiring (semiring (semiring (has_top unsigned))))) := sorry --non-trivial
lemma new_lemma_60137 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (has_sub.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (has_sub.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_60138 (h1 : uniform_space (with_one char)) : complete_space (with_one char) := sorry --non-trivial
lemma new_lemma_60139 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (ordered_comm_ring.{0} name) (@function.extfun_app.{2 1} Type add_group.{0} h0 (ordered_comm_ring.{0} name))  := sorry --non-trivial
lemma new_lemma_60140 (h0 : functor.add_const (ordered_add_comm_monoid (free_add_monoid empty)) num) : @archimedean.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (free_add_monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_60141 (h0 : complete_lattice (measurable_space congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_60142 (h0 : topological_space (has_le linarith.comp_source)) : path_connected_space (has_le linarith.comp_source) := sorry --non-trivial
lemma new_lemma_60143 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_60144 (h0 : not (prod (semiring congr_arg_kind) (semiring congr_arg_kind) -> false)) : id_rel (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_60145 (h0 : ring (has_union (has_union unsigned))) : strong_rank_condition (has_union (has_union unsigned)) := sorry --non-trivial
lemma new_lemma_60146 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (linear_ordered_semiring fun_info)) := sorry --non-trivial
lemma new_lemma_60147 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (canonically_ordered_comm_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (canonically_ordered_comm_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_60148 (h0 : topological_space (semigroup linarith.comp)) : totally_disconnected_space (semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_60149 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) (has_add (has_neg linarith.comp))) : @t0_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) (has_add.{0} (has_neg.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_60150 (h0 : topological_space (has_nnnorm (with_zero string_imp))) : totally_disconnected_space (has_nnnorm (with_zero string_imp)) := sorry --non-trivial
lemma new_lemma_60151 (h0 : add_monoid znum) : add_monoid.fg znum := sorry --non-trivial
lemma new_lemma_60152 (h0 : function.extfun Type topological_space) : @normal_space.{0} (metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_60153 (h1 : ring (has_ssubset linarith.comp_source)) : rank_condition (has_ssubset linarith.comp_source) := sorry --non-trivial
lemma new_lemma_60154 (h0 : topological_space (ordered_comm_ring (has_bot Type))) : totally_separated_space (ordered_comm_ring (has_bot Type)) := sorry --non-trivial
lemma new_lemma_60155 (h0 : monoid (has_union (semiring (semiring (semiring (semiring congr_arg_kind)))))) : monoid.fg (has_union (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_60156 (h0 : topological_space (linear_ordered_field congr_arg_kind)) : loc_path_connected_space (linear_ordered_field congr_arg_kind) := sorry --non-trivial
lemma new_lemma_60157 (h0 : ring (ordered_semiring (comm_monoid unsigned))) : rank_condition (ordered_semiring (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_60158 (h0 : functor.add_const (complete_lattice (canonically_ordered_comm_semiring unsigned)) pos) : @is_compactly_generated.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (canonically_ordered_comm_semiring.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_60159 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_60160 (h0 : not (topological_space (simple_graph (mul_one_class char)) -> false)) : @totally_disconnected_space.{0} (simple_graph.{0} (mul_one_class.{0} char)) (@classical.by_contradiction'.{1} (topological_space.{0} (simple_graph.{0} (mul_one_class.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_60161 (h0 h1 : multiset (add_comm_semigroup linarith.ineq)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_60162 (h2 : not (ring (has_append char) -> false)) : @rank_condition.{0} (has_append.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (has_append.{0} char)) h2)  := sorry --non-trivial
lemma new_lemma_60163 (h0 : group (distrib_lattice (has_nnnorm (random_gen linarith.ineq)))) : group.fg (distrib_lattice (has_nnnorm (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_60164 (h0 : ring (linear_ordered_semiring congr_arg_kind)) : is_principal_ideal_ring (linear_ordered_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_60165 (h2 : group (has_top to_additive.value_type)) : is_cyclic (has_top to_additive.value_type) := sorry --non-trivial
lemma new_lemma_60166 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (linear_ordered_comm_ring empty)) := sorry --non-trivial
lemma new_lemma_60167 (h1 : topological_space (random_gen linarith.ineq)) : path_connected_space (random_gen linarith.ineq) := sorry --non-trivial
lemma new_lemma_60168 (h0 : monoid (has_neg (option unsigned))) : monoid.fg (has_neg (option unsigned)) := sorry --non-trivial
lemma new_lemma_60169 (h0 : topological_space (has_top (random_gen linarith.comp_source))) : irreducible_space (has_top (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_60170 (h0 : topological_space (has_top (has_union (id (id linarith.comp))))) : totally_disconnected_space (has_top (has_union (id (id linarith.comp)))) := sorry --non-trivial
lemma new_lemma_60171 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_add_cyclic.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) add_group.{0}) (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_60172 (h0 : topological_space (complete_semilattice_Sup num)) : irreducible_space (complete_semilattice_Sup num) := sorry --non-trivial
lemma new_lemma_60173 (h1 : topological_space (boolean_algebra.core (random_gen char))) : t0_space (boolean_algebra.core (random_gen char)) := sorry --non-trivial
lemma new_lemma_60174 (h0 : group (has_zero (has_neg (has_neg (has_add Type))))) : group.fg (has_zero (has_neg (has_neg (has_add Type)))) := sorry --non-trivial
lemma new_lemma_60175 (h0 : uniform_space (has_Inf (has_add Type))) : separated_space (has_Inf (has_add Type)) := sorry --non-trivial
lemma new_lemma_60176 (h0 : filter unsigned -> filter unsigned -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_60177 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_disconnected_space.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_60178 (h0 : cancel_comm_monoid_with_zero (generalized_boolean_algebra (finset (has_add linarith.comp)))) : unique_factorization_monoid (generalized_boolean_algebra (finset (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_60179 (h0 : functor.add_const (ring (left_cancel_monoid num)) num) : @rank_condition.{0} (left_cancel_monoid.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_60180 (h0 : topological_space (has_add (has_to_string name))) : normal_space (has_add (has_to_string name)) := sorry --non-trivial
lemma new_lemma_60181 (h0 : topological_space (finset (has_to_string (has_to_string (finset pos))))) : regular_space (finset (has_to_string (has_to_string (finset pos)))) := sorry --non-trivial
lemma new_lemma_60182 (h0 : group (add_cancel_monoid num)) : is_simple_group (add_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_60183 (h0 : topological_space (finset (has_to_string name))) : regular_space (finset (has_to_string name)) := sorry --non-trivial
lemma new_lemma_60184 (h0 : topological_space (with_zero (has_inv fun_info))) : totally_disconnected_space (with_zero (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_60185 (h0 : functor.add_const (topological_space (omega_complete_partial_order empty)) empty) : @preirreducible_space.{0} (omega_complete_partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (omega_complete_partial_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_60186 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (normed_comm_ring.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} h0 (normed_comm_ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_60187 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (normed_group.{0} (random_gen.{0} to_additive.value_type)) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 uniform_space.{0}) (normed_group.{0} (random_gen.{0} to_additive.value_type)))  := sorry --non-trivial
lemma new_lemma_60188 (h0 : list Prop) (h1 : punit) : id (list.head (category_theory.hom_of_element h0 h1)) := sorry --non-trivial
lemma new_lemma_60189 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @totally_disconnected_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_60190 (h0 : functor.add_const (monoid (has_neg_part Type)) pos) : @monoid.fg.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (has_neg_part.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_60191 (h0 : add_group (canonically_linear_ordered_monoid linarith.comp)) : is_add_cyclic (canonically_linear_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_60192 (h0 : not (add_group (with_zero fun_info) -> false)) : @is_add_cyclic.{0} (with_zero.{0} fun_info) (@classical.by_contradiction'.{1} (add_group.{0} (with_zero.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_60193 (h0 : ring (monoid_with_zero environment.projection_info)) : is_domain (monoid_with_zero environment.projection_info) := sorry --non-trivial
lemma new_lemma_60194 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (option.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} num))  := sorry --non-trivial
lemma new_lemma_60195 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_60196 (h0 : topological_space (mul_zero_class (semiring unsigned))) : preirreducible_space (mul_zero_class (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_60197 (h0 : complete_lattice (encodable (random_gen fun_info))) : complete_lattice.is_Sup_finite_compact (encodable (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_60198 (h0 : functor.add_const (topological_space (linear_order unsigned)) empty) : @irreducible_space.{0} (linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_60199 (h0 : ordered_add_comm_monoid (has_nndist num)) : archimedean (has_nndist num) := sorry --non-trivial
lemma new_lemma_60200 (h0 : functor.add_const (topological_space (ring linarith.comp)) (mul_one_class Type)) : @irreducible_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} linarith.comp)) (mul_one_class.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_60201 (h0 : complete_lattice (has_one (semiring empty))) : is_atomistic (has_one (semiring empty)) := sorry --non-trivial
lemma new_lemma_60202 (h0 : group (ring (has_neg linarith.comp))) : is_cyclic (ring (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_60203 (h0 : ring (has_Sup (semiring congr_arg_kind))) : rank_condition (has_Sup (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_60204 (h0 : functor.add_const (add_group (finset environment.implicit_infer_kind)) pos) : @is_add_cyclic.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_group.{0} (finset.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_60205 (h0 : finset (add_comm_monoid (normed_comm_ring name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_60206 (h0 : functor.add_const (topological_space (has_nndist ennreal)) name) : @totally_separated_space.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_60207 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_60208 (h0 : group linarith.ineq) : group.fg linarith.ineq := sorry --non-trivial
lemma new_lemma_60209 (h0 : ring (metric_space (random_gen reducibility_hints))) : strong_rank_condition (metric_space (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_60210 (h0 : functor.add_const (uniform_space (boolean_algebra pos)) pos) : @separated_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_60211 (h0 : function.extfun Type pseudo_metric_space) (h1 : function.extfun Type add_monoid) : @has_lipschitz_add.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type pseudo_metric_space.{0} h0 (has_Inf.{0} pos)) (@function.extfun_app.{2 1} Type add_monoid.{0} h1 (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_60212 (h0 : add_monoid (normed_comm_ring (has_add name))) : add_monoid.fg (normed_comm_ring (has_add name)) := sorry --non-trivial
lemma new_lemma_60213 (h0 : group (with_one (has_inv to_additive.value_type))) : group.fg (with_one (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_60214 (h0 : filter (complete_semilattice_Sup linarith.ineq)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_60215 (h0 : monoid (with_bot (has_inv (has_inv (random_gen fun_info))))) : monoid.fg (with_bot (has_inv (has_inv (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_60216 (h0 : functor.add_const (topological_space (ring linarith.comp)) (has_neg environment.implicit_infer_kind)) : @topological_space.separable_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_60217 (h0 : list (finset (option (option (option (option (option empty))))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_60218 (h0 : topological_space (comm_semigroup (sub_neg_monoid (has_add (has_add (sub_neg_monoid real)))))) : normal_space (comm_semigroup (sub_neg_monoid (has_add (has_add (sub_neg_monoid real))))) := sorry --non-trivial
lemma new_lemma_60219 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (canonically_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} h0 (canonically_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_60220 (h0 : complete_lattice (distrib_lattice (has_nnnorm fun_info))) : is_compactly_generated (distrib_lattice (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_60221 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_60222 (h0 : ordered_comm_monoid (comm_semigroup (ordered_comm_monoid linarith.comp))) : has_exists_mul_of_le (comm_semigroup (ordered_comm_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_60223 (h0 : uniform_space (complete_distrib_lattice (has_pos_part linarith.comp))) : separated_space (complete_distrib_lattice (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_60224 (h0 : topological_space (ordered_ring (semiring num))) : topological_space.separable_space (ordered_ring (semiring num)) := sorry --non-trivial
lemma new_lemma_60225 (h0 : group (complete_linear_order (semiring (semiring (semiring congr_arg_kind))))) : group.fg (complete_linear_order (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_60226 (h0 : topological_space (encodable string_imp)) : locally_compact_space (encodable string_imp) := sorry --non-trivial
lemma new_lemma_60227 (h0 : filter (metric_space congr_arg_kind)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_60228 (h0 : function.extfun Type group) : @group.fg.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_60229 (h0 : functor.add_const (add_group (boolean_algebra linarith.comp)) environment.implicit_infer_kind) : @is_add_cyclic.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_group.{0} (boolean_algebra.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_60230 (h0 : has_mem.mem (measurable_space linarith.comp) has_emptyc.emptyc) : @separated_space.{0} (measurable_space.{0} linarith.comp) (@finset.pi.empty.{1 0} Type uniform_space.{0} (measurable_space.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_60231 (h0 : set (add_comm_semigroup (mul_one_class string.iterator_imp) -> char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_60232 (h0 : functor.add_const (uniform_space (has_to_string name)) (ring pos)) : @separated_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_to_string.{0} name)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_60233 (h0 : uniform_space (non_assoc_semiring (semiring empty))) : separated_space (non_assoc_semiring (semiring empty)) := sorry --non-trivial
lemma new_lemma_60234 (h1 : ring (normed_group linarith.ineq)) : is_domain (normed_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_60235 (h0 : add_monoid (has_zero (option name))) : add_monoid.fg (has_zero (option name)) := sorry --non-trivial
lemma new_lemma_60236 (h0 : topological_space (has_to_string (option pos))) : preirreducible_space (has_to_string (option pos)) := sorry --non-trivial
lemma new_lemma_60237 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_60238 (h0 : topological_space (complete_semilattice_Sup linarith.ineq)) : totally_disconnected_space (complete_semilattice_Sup linarith.ineq) := sorry --non-trivial
lemma new_lemma_60239 (h0 : has_mem.mem (measurable_space num) has_emptyc.emptyc) : @normalizer_condition.{0} (measurable_space.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (measurable_space.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_60240 (h0 : topological_space (ring (has_add pos))) : irreducible_space (ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_60241 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (generalized_boolean_algebra.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (generalized_boolean_algebra.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_60242 (h0 : finset (ordered_comm_monoid (has_Inf (has_add (has_Inf pos))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_60243 (h0 : functor.add_const (uniform_space (has_neg_part Type)) name) : @separated_space.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_neg_part.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_60244 (h0 : functor.add_const (uniform_space (add_group num)) (semiring empty)) : @complete_space.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_group.{0} num)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_60245 (h0 : function.extfun Type group) : @normalizer_condition.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_60246 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_60247 (h1 : group (encodable char)) : group.fg (encodable char) := sorry --non-trivial
lemma new_lemma_60248 (h0 : functor.add_const (topological_space (preorder num)) unsigned) : @irreducible_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_60249 (h0 : topological_space (semigroup (option ennreal))) : t1_space (semigroup (option ennreal)) := sorry --non-trivial
lemma new_lemma_60250 (h0 : topological_space (uniform_space (is_R_or_C (mul_one_class linarith.ineq)))) : t0_space (uniform_space (is_R_or_C (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_60251 (h0 : not (topological_space (has_top num) -> false)) : @path_connected_space.{0} (has_top.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_60252 (h1 : topological_space (has_ssubset environment.projection_info)) (h2 : add_group (has_ssubset environment.projection_info)) : topological_add_group (has_ssubset environment.projection_info) := sorry --non-trivial
lemma new_lemma_60253 (h0 : topological_space (has_union (linear_ordered_semiring num))) : irreducible_space (has_union (linear_ordered_semiring num)) := sorry --non-trivial
lemma new_lemma_60254 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (normed_group.{0} (has_inv.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (normed_group.{0} (has_inv.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_60255 (h0 : topological_space (has_to_string ennreal)) : totally_separated_space (has_to_string ennreal) := sorry --non-trivial
lemma new_lemma_60256 (h0 : topological_space (add_comm_monoid (has_Inf (has_Inf Type)))) : t1_space (add_comm_monoid (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_60257 (h0 : functor.add_const (topological_space znum) (option unsigned)) : @loc_path_connected_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_60258 (h1 : random_gen (add_cancel_comm_monoid char) -> random_gen (add_cancel_comm_monoid char) -> Prop) : is_extensional (random_gen (add_cancel_comm_monoid char)) h1 := sorry --non-trivial
lemma new_lemma_60259 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_60260 (h0 : uniform_space (measurable_space (measurable_space num))) : complete_space (measurable_space (measurable_space num)) := sorry --non-trivial
lemma new_lemma_60261 (h0 : uniform_space (simple_graph reducibility_hints)) : complete_space (simple_graph reducibility_hints) := sorry --non-trivial
lemma new_lemma_60262 (h0 : fin has_zero.zero) : @t0_space.{1} (add_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (add_comm_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_60263 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (add_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_60264 (h0 : topological_space (cancel_monoid (has_add Type))) : loc_path_connected_space (cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_60265 (h0 : finset (finset linarith.comp)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_60266 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (linear_ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_60267 (h0 : functor.add_const (function.extfun Type group) Type) : @group.fg.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) Type h0) (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_60268 (h0 : functor.add_const (function.extfun Type complete_lattice) Type) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type complete_lattice.{0}) Type h0) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_60269 (h0 : list (dlist (has_nnnorm linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_60270 (h0 : topological_space (has_le fun_info)) : totally_disconnected_space (has_le fun_info) := sorry --non-trivial
lemma new_lemma_60271 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (linear_ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_60272 (h0 : filter (metric_space linarith.comp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_60273 (h0 : function.extfun Type (prod (has_add unsigned))) : id_rel (function.extfun_app h0 (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_60274 (h0 : topological_space (linear_ordered_comm_ring (option num))) : t1_space (linear_ordered_comm_ring (option num)) := sorry --non-trivial
lemma new_lemma_60275 (h0 : function.extfun Type (functor.add_const (list (add_left_cancel_semigroup unsigned)))) : palindrome (functor.add_const.run (function.extfun_app h0 unsigned)) := sorry --non-trivial
lemma new_lemma_60276 (h0 : ring (has_top (has_top (semiring unsigned)))) : is_domain (has_top (has_top (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_60277 (h0 : cancel_comm_monoid_with_zero (has_union empty)) : unique_factorization_monoid (has_union empty) := sorry --non-trivial
lemma new_lemma_60278 (h0 : uniform_space (uniform_space (mul_one_class linarith.comp_source))) : complete_space (uniform_space (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_60279 (h0 : topological_space (add_cancel_monoid num)) : discrete_topology (add_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_60280 (h0 : complete_lattice (measurable_space (has_inv (has_top to_additive.value_type)))) : is_atomistic (measurable_space (has_inv (has_top to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_60281 (h0 : functor.add_const (filter (has_add linarith.comp)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_60282 (h0 : functor.add_const (uniform_space (has_add Type)) environment.implicit_infer_kind) : @complete_space.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (has_add.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_60283 (h0 : list (has_top linarith.comp_source)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_60284 (h1 : function.extfun Type topological_space) : @locally_compact_space.{0} (@id.{2} Type to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (@id.{2} Type to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_60285 (h0 : topological_space (has_norm linarith.comp)) : irreducible_space (has_norm linarith.comp) := sorry --non-trivial
lemma new_lemma_60286 (h0 : semiring (boolean_algebra.core (option unsigned))) : is_noetherian_ring (boolean_algebra.core (option unsigned)) := sorry --non-trivial
lemma new_lemma_60287 (h0 : topological_space (linear_ordered_comm_ring (semiring empty))) : normal_space (linear_ordered_comm_ring (semiring empty)) := sorry --non-trivial
lemma new_lemma_60288 (h0 : filter (has_neg (add_comm_monoid (has_add Type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_60289 (h0 : complete_lattice (comm_group environment.implicit_infer_kind)) : is_atomistic (comm_group environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_60290 (h0 : ring (boolean_algebra (has_neg (has_to_string Type)))) : is_domain (boolean_algebra (has_neg (has_to_string Type))) := sorry --non-trivial
lemma new_lemma_60291 (h0 : topological_space (comm_semigroup pos)) : normal_space (comm_semigroup pos) := sorry --non-trivial
lemma new_lemma_60292 (h0 : function.extfun (finset Type) (has_mem.mem (semiring unsigned))) : @t0_space.{0} (semiring.{0} unsigned) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} unsigned)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_60293 (h0 : ring (has_nndist (has_neg_part Type))) : is_domain (has_nndist (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_60294 (h0 : group (mul_zero_class (semiring num))) : normalizer_condition (mul_zero_class (semiring num)) := sorry --non-trivial
lemma new_lemma_60295 (h0 : ring (has_emptyc (random_gen (random_gen linarith.comp_source)))) : strong_rank_condition (has_emptyc (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_60296 (h0 : functor.add_const (add_monoid (mul_zero_class name)) name) : @add_monoid.fg.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (mul_zero_class.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_60297 (h0 : functor.add_const (complete_lattice (boolean_algebra.core unsigned)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_60298 (h0 : function.extfun Type (functor.add_const (topological_space (has_Sup unsigned)))) : @totally_disconnected_space.{0} (has_Sup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} unsigned)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (has_Sup.{0} unsigned))) h0 num))  := sorry --non-trivial
lemma new_lemma_60299 (h0 : filter (preorder (semiring empty))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_60300 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @has_exists_mul_of_le.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ordered_comm_monoid.{0}) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_60301 (h0 : topological_space (has_zero linarith.comp)) : totally_separated_space (has_zero linarith.comp) := sorry --non-trivial
lemma new_lemma_60302 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (pseudo_metric_space.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} name))  := sorry --non-trivial
lemma new_lemma_60303 (h0 : topological_space (ordered_comm_monoid (has_Inf (sub_neg_monoid pos)))) : t0_space (ordered_comm_monoid (has_Inf (sub_neg_monoid pos))) := sorry --non-trivial
lemma new_lemma_60304 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_separated_space.{0} (has_top.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_top.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_60305 (h0 : uniform_space (random_gen (semiring (semiring empty)))) : complete_space (random_gen (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_60306 (h0 : uniform_space (dlist linarith.ineq)) (h1 : set (dlist linarith.ineq)) : is_separated h1 := sorry --non-trivial
lemma new_lemma_60307 (h3 : has_neg (nondiscrete_normed_field char)) (h4 : measurable_space (nondiscrete_normed_field char)) : has_measurable_neg (nondiscrete_normed_field char) := sorry --non-trivial
lemma new_lemma_60308 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_edist unsigned)) := sorry --non-trivial
lemma new_lemma_60309 (h0 : topological_space (ordered_comm_ring (has_add pos))) : locally_compact_space (ordered_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_60310 (h0 : functor.add_const (topological_space (add_group num)) num) : @preirreducible_space.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_60311 (h0 : uniform_space (ordered_comm_monoid name)) : separated_space (ordered_comm_monoid name) := sorry --non-trivial
lemma new_lemma_60312 (h0 : list (semiring (with_one congr_arg_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_60313 (h0 : cancel_comm_monoid_with_zero (has_star congr_arg_kind)) : unique_factorization_monoid (has_star congr_arg_kind) := sorry --non-trivial
lemma new_lemma_60314 (h0 : functor.add_const (topological_space (has_neg_part ennreal)) (option (option name))) : @normal_space.{0} (has_neg_part.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} ennreal)) (option.{0} (option.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_60315 (h0 : ring (has_Inf unsigned)) : is_domain (has_Inf unsigned) := sorry --non-trivial
lemma new_lemma_60316 (h0 : topological_space (semigroup (option ennreal))) : topological_space.separable_space (semigroup (option ennreal)) := sorry --non-trivial
lemma new_lemma_60317 (h0 : ring (ring (has_neg Type))) : is_domain (ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_60318 (h0 : topological_space (encodable (random_gen fun_info))) : totally_disconnected_space (encodable (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_60319 (h0 : add_group (has_nnnorm (mul_one_class (mul_one_class string.iterator_imp)))) : is_add_cyclic (has_nnnorm (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_60320 (h0 : topological_space (finset (finset (finset pos)))) : path_connected_space (finset (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_60321 (h0 : functor.add_const (ring (boolean_algebra environment.implicit_infer_kind)) (ring Type)) : @strong_rank_condition.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ring.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_60322 (h1 : add_group (add_comm_semigroup (add_comm_semigroup linarith.ineq))) : is_add_cyclic (add_comm_semigroup (add_comm_semigroup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_60323 (h0 h1 : ulower pnat) : pnat.coprime (id (ulower.up (id h0))) (ulower.up h1) := sorry --non-trivial
lemma new_lemma_60324 (h0 : functor.add_const (topological_space (add_group unsigned)) num) : @totally_separated_space.{0} (add_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_60325 (h0 : fin has_zero.zero) : @is_noetherian_ring.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (semiring.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_60326 (h0 : ring (with_bot (semiring (semiring num)))) : is_domain (with_bot (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_60327 (h0 : functor.add_const (filter (has_neg Type)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_60328 (h0 : topological_space (ordered_comm_monoid (sub_neg_monoid (has_Inf (has_bot real))))) : loc_path_connected_space (ordered_comm_monoid (sub_neg_monoid (has_Inf (has_bot real)))) := sorry --non-trivial
lemma new_lemma_60329 (h0 : ring (option_t add_left_cancel_monoid to_additive.value_type)) : strong_rank_condition (option_t add_left_cancel_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_60330 (h0 : ring (fintype (fintype (distrib char)))) : rank_condition (fintype (fintype (distrib char))) := sorry --non-trivial
lemma new_lemma_60331 (h0 : complete_lattice (measurable_space.dynkin_system num)) : is_atomistic (measurable_space.dynkin_system num) := sorry --non-trivial
lemma new_lemma_60332 (h1 : filter (has_compl string_imp)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_60333 (h0 : group (measurable_space (random_gen to_additive.value_type))) : group.fg (measurable_space (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_60334 (h0 : not (topological_space (complete_semilattice_Sup unsigned) -> false)) : @topological_space.separable_space.{0} (complete_semilattice_Sup.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_60335 (h0 : finset (has_pos_part (has_Inf (has_pos_part (has_pos_part (has_Inf pos)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_60336 (h0 : functor.add_const (list (has_sub empty)) empty) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_60337 (h0 : topological_space (random_gen (has_norm to_additive.value_type))) : t0_space (random_gen (has_norm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_60338 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_60339 (h0 : nat) (h1 : fin (nat.succ (id (id h0))) -> filter Prop) (h2 : fin (id (id h0))) : @Lim.{0} Prop sierpinski_space (@nonempty_of_inhabited.{1} Prop sort.inhabited.{0}) (@matrix.vec_tail.{0} (filter.{0} Prop) (@id.{1} nat (@id.{1} nat h0)) h1 h2)  := sorry --non-trivial
lemma new_lemma_60340 (h0 : filter (cancel_monoid empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_60341 (h0 : finset (comm_group (ring (ring (finset environment.implicit_infer_kind))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_60342 (h0 : topological_space (has_norm linarith.comp)) : t0_space (has_norm linarith.comp) := sorry --non-trivial
lemma new_lemma_60343 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_60344 (h0 : add_monoid (normed_comm_ring (has_to_string (has_add name)))) : add_monoid.fg (normed_comm_ring (has_to_string (has_add name))) := sorry --non-trivial
lemma new_lemma_60345 (h0 : functor.add_const (cancel_comm_monoid_with_zero (left_cancel_monoid unsigned)) congr_arg_kind) : @unique_factorization_monoid.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (left_cancel_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_60346 (h0 : ring (ring (comm_group (boolean_algebra name)))) : is_domain (ring (comm_group (boolean_algebra name))) := sorry --non-trivial
lemma new_lemma_60347 (h0 : group (has_norm (has_top (has_top empty)))) : is_cyclic (has_norm (has_top (has_top empty))) := sorry --non-trivial
lemma new_lemma_60348 (h1 : has_mem.mem (with_one num) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_one.{0} num) h1)  := sorry --non-trivial
lemma new_lemma_60349 (h0 : fin has_zero.zero) : @monoid.fg.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (monoid.{0} (canonically_ordered_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_60350 (h0 : uniform_space (mul_one_class to_additive.value_type)) : complete_space (mul_one_class to_additive.value_type) := sorry --non-trivial
lemma new_lemma_60351 (h0 : finset (has_add (ring Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_60352 (h0 : topological_space (canonically_ordered_monoid (has_Inf (has_Inf (has_Inf linarith.comp))))) : normal_space (canonically_ordered_monoid (has_Inf (has_Inf (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_60353 (h0 : functor.add_const (topological_space (non_assoc_semiring unsigned)) empty) : @totally_separated_space.{0} (non_assoc_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (non_assoc_semiring.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_60354 (h0 : functor.add_const (group (ring Type)) environment.implicit_infer_kind) : @is_simple_group.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (ring.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_60355 (h0 : functor.add_const (ordered_add_comm_monoid (cancel_monoid name)) environment.implicit_infer_kind) : @archimedean.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (cancel_monoid.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_60356 (h0 : uniform_space (comm_group (has_to_string pos))) : separated_space (comm_group (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_60357 (h0 : functor.add_const (monoid (has_neg_part Type)) environment.implicit_infer_kind) : @monoid.fg.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (has_neg_part.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_60358 (h0 : topological_space (monoid_with_zero (complete_distrib_lattice (option ennreal)))) : loc_path_connected_space (monoid_with_zero (complete_distrib_lattice (option ennreal))) := sorry --non-trivial
lemma new_lemma_60359 (h0 : function.extfun Type (functor.add_const (topological_space auto.case_option))) : @totally_disconnected_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) unsigned (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} auto.case_option)) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_60360 (h0 : uniform_space (measurable_space (semiring (semiring congr_arg_kind)))) : complete_space (measurable_space (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_60361 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) linarith.comp) : @irreducible_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_60362 (h0 : set (add_comm_semigroup std_gen -> enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_60363 (h0 : topological_space (has_add (ring (has_neg linarith.comp)))) : t0_space (has_add (ring (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_60364 (h0 : function.extfun (Type 1) topological_space) : @normal_space.{1} (has_Inf.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_Inf.{1} Type))  := sorry --non-trivial
lemma new_lemma_60365 (h0 : add_group (denumerable (comm_ring linarith.comp_source))) : is_add_cyclic (denumerable (comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_60366 (h0 : monoid (linear_ordered_field ennreal)) : monoid.fg (linear_ordered_field ennreal) := sorry --non-trivial
lemma new_lemma_60367 (h0 : functor.add_const (list (add_cancel_monoid environment.implicit_infer_kind)) Type) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_60368 (h0 : not (uniform_space (random_gen fun_info) -> false)) : @separated_space.{0} (random_gen.{0} fun_info) (@classical.by_contradiction'.{1} (uniform_space.{0} (random_gen.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_60369 (h5 : set (string.iterator_imp -> enat)) : set.separates_points h5 := sorry --non-trivial
lemma new_lemma_60370 (h0 : measurable_space (normed_comm_ring linarith.comp)) (h1 : has_div (normed_comm_ring linarith.comp)) : has_measurable_div₂ (normed_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_60371 (h0 : ring (has_ssubset (metric_space (metric_space linarith.comp_source)))) : is_domain (has_ssubset (metric_space (metric_space linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_60372 (h0 : topological_space (random_gen (add_right_cancel_monoid (has_top linarith.comp)))) : totally_disconnected_space (random_gen (add_right_cancel_monoid (has_top linarith.comp))) := sorry --non-trivial
lemma new_lemma_60373 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_inv.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 ring.{0}) (has_inv.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_60374 (h0 : canonically_ordered_comm_semiring unsigned -> canonically_ordered_comm_semiring unsigned -> Prop) : total h0 := sorry --non-trivial
lemma new_lemma_60375 (h0 : not (uniform_space (has_compl string.iterator_imp) -> false)) : @complete_space.{0} (has_compl.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_compl.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_60376 (h0 : uniform_space (non_assoc_semiring empty)) : complete_space (non_assoc_semiring empty) := sorry --non-trivial
lemma new_lemma_60377 (h0 : list (semigroup (finset (semigroup Type)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_60378 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (add_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_60379 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_60380 (h0 : functor.add_const (monoid (finset Type)) pos) : @monoid.fg.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (monoid.{1} (finset.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_60381 (h0 : topological_space (ordered_comm_monoid (has_add (has_add name)))) : sequential_space (ordered_comm_monoid (has_add (has_add name))) := sorry --non-trivial
lemma new_lemma_60382 (h1 : complete_lattice (semiring to_additive.value_type)) : is_atomistic (semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_60383 (h0 : ring (has_norm (has_top (has_top (has_top to_additive.value_type))))) : strong_rank_condition (has_norm (has_top (has_top (has_top to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_60384 (h0 : ring (semi_normed_ring (has_ssubset linarith.ineq))) : strong_rank_condition (semi_normed_ring (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_60385 (h0 : topological_space (has_Inf (has_Inf name))) : irreducible_space (has_Inf (has_Inf name)) := sorry --non-trivial
lemma new_lemma_60386 (h0 : uniform_space (has_Inf (finset linarith.comp))) : complete_space (has_Inf (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_60387 (h0 : functor.add_const (ring (as_linear_order empty)) (option empty)) : @is_domain.{0} (as_linear_order.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (as_linear_order.{0} empty)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_60388 (h0 : functor.add_const (ordered_add_comm_monoid (simple_graph Type)) linarith.comp) : @archimedean.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (simple_graph.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_60389 (h0 : semiring (has_nndist (finset (finset environment.implicit_infer_kind)))) : is_noetherian_ring (has_nndist (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_60390 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_60391 (h0 : function.extfun Type group) : @group.fg.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_60392 (h0 : topological_space (has_neg congr_arg_kind)) (h1 : group (has_neg congr_arg_kind)) : topological_group (has_neg congr_arg_kind) := sorry --non-trivial
lemma new_lemma_60393 (h0 : functor.add_const (list (comm_group ennreal)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_60394 (h0 : functor.add_const (topological_space (normed_linear_ordered_group unsigned)) empty) : @discrete_topology.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_60395 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_60396 (h1 : complete_lattice (has_inv string_imp)) : is_compactly_generated (has_inv string_imp) := sorry --non-trivial
lemma new_lemma_60397 (h0 : functor.add_const (group (has_zero linarith.comp)) pos) : @is_simple_group.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_60398 (h0 : topological_space (ordered_comm_ring (sub_neg_monoid real))) : sequential_space (ordered_comm_ring (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_60399 (h0 : topological_space (has_nndist (has_to_string unsigned))) : regular_space (has_nndist (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_60400 (h0 : topological_space (has_nndist (has_to_string unsigned))) : normal_space (has_nndist (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_60401 (h0 : functor.add_const (topological_space (has_Inf Type)) pos) : @totally_disconnected_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_Inf.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_60402 (h0 : topological_space (canonically_ordered_comm_semiring name)) : totally_disconnected_space (canonically_ordered_comm_semiring name) := sorry --non-trivial
lemma new_lemma_60403 (h0 : function.extfun Type (functor.add_const (ring ennreal))) : @is_principal_ideal_ring.{0} ennreal (@functor.add_const.run.{0 0} (ring.{0} ennreal) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} ennreal)) h0 empty))  := sorry --non-trivial
lemma new_lemma_60404 (h0 : ring (distrib (has_nnnorm (has_ssubset (mul_one_class reducibility_hints))))) : is_domain (distrib (has_nnnorm (has_ssubset (mul_one_class reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_60405 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) name) : @complete_space.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) uniform_space.{1}) name h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_60406 (h0 : ring (simple_graph (mul_one_class string.iterator_imp))) : rank_condition (simple_graph (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_60407 (h0 : not (topological_space (has_ssubset char) -> false)) : @locally_compact_space.{0} (has_ssubset.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_60408 (h0 : not (has_mem.mem (function.extfun Type) has_emptyc.emptyc -> false)) : @is_add_cyclic.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{0} (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (finset.{2} ((Type → Type) → Type 1)) (@finset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type) (@has_emptyc.emptyc.{2} (finset.{2} ((Type → Type) → Type 1)) (@finset.has_emptyc.{2} ((Type → Type) → Type 1)))) h0)) add_group.{0}) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_60409 (h0 : topological_space (boolean_algebra Type)) : t0_space (boolean_algebra Type) := sorry --non-trivial
lemma new_lemma_60410 (h0 : functor.add_const (filter (add_cancel_monoid name)) (finset pos)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_60411 (h0 : list (dlist (has_ssubset (random_gen fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_60412 (h0 : topological_space real) : normal_space real := sorry --non-trivial
lemma new_lemma_60413 (h0 : topological_space (div_inv_monoid (random_gen linarith.ineq))) : t0_space (div_inv_monoid (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_60414 (h0 : functor.add_const (monoid auto.case_option) num) : @monoid.fg.{0} auto.case_option (@functor.add_const.run.{0 0} (monoid.{0} auto.case_option) num h0)  := sorry --non-trivial
lemma new_lemma_60415 (h0 : functor.add_const (topological_space (has_nndist environment.implicit_infer_kind)) environment.implicit_infer_kind) : @t0_space.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_60416 (h0 : group (complete_semilattice_Sup (has_inv fun_info))) : normalizer_condition (complete_semilattice_Sup (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_60417 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preconnected_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_60418 (h0 : topological_space (has_Sup congr_arg_kind)) : path_connected_space (has_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_60419 (h0 : fin has_zero.zero) : @t0_space.{1} (generalized_boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (generalized_boolean_algebra.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_60420 (h0 : topological_space (has_to_string ennreal)) : t1_space (has_to_string ennreal) := sorry --non-trivial
lemma new_lemma_60421 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_60422 (h0 : complete_lattice (normed_group linarith.ineq)) : is_atomistic (normed_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_60423 (h0 : topological_space (comm_group (has_neg_part ennreal))) : irreducible_space (comm_group (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_60424 (h0 : list (add_right_cancel_monoid (semiring congr_arg_kind))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_60425 (h0 : functor.add_const (ring (has_neg_part Type)) (boolean_algebra environment.implicit_infer_kind)) : @rank_condition.{1} (has_neg_part.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_neg_part.{1} Type)) (boolean_algebra.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_60426 (h1 : group (linear_ordered_semiring (has_top (has_top (has_top to_additive.value_type))))) : normalizer_condition (linear_ordered_semiring (has_top (has_top (has_top to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_60427 (h0 : functor.add_const (complete_lattice (has_neg linarith.comp)) pos) : @is_atomistic.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_60428 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (add_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_60429 (h0 : list (has_to_string (has_to_string (boolean_algebra linarith.comp)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_60430 (h0 : not (topological_space (measurable_space linarith.comp) -> false)) : @totally_separated_space.{0} (measurable_space.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_60431 (h0 : list (normed_comm_ring (semiring empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_60432 (h0 : functor.add_const (function.extfun (Type 1) ordered_add_comm_monoid) linarith.comp) : @archimedean.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) ordered_add_comm_monoid.{1}) linarith.comp h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_60433 (h0 : add_group (comm_ring char)) : is_add_cyclic (comm_ring char) := sorry --non-trivial
lemma new_lemma_60434 (h0 : functor.add_const (topological_space (has_Sup num)) empty) : @totally_separated_space.{0} (has_Sup.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Sup.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_60435 (h0 : with_bot (topological_space (partial_order (semiring (semiring (semiring (semiring (semiring num)))))))) (h1 : ne h0 has_bot.bot) : @totally_separated_space.{0} (partial_order.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} num)))))) (@with_bot.unbot.{0} (topological_space.{0} (partial_order.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} (semiring.{0} num))))))) h0 h1)  := sorry --non-trivial
lemma new_lemma_60436 (h0 : not (ring (has_top empty) -> false)) : @is_domain.{0} (has_top.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (has_top.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_60437 (h0 : ordered_comm_monoid (complete_distrib_lattice (ordered_comm_monoid Type))) : has_exists_mul_of_le (complete_distrib_lattice (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_60438 (h1 : not (topological_space (has_compl char) -> false)) : @totally_disconnected_space.{0} (has_compl.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (has_compl.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_60439 (h0 : complete_lattice (with_one (has_ssubset fun_info))) : is_compactly_generated (with_one (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_60440 (h0 : functor.comp topological_space cancel_monoid linarith.comp) : @locally_compact_space.{0} (cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} linarith.comp)) linarith.comp (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_60441 (h0 : functor.add_const (topological_space (comm_group linarith.comp)) environment.implicit_infer_kind) : @regular_space.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_60442 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_60443 (h0 : topological_space (has_bot (has_neg pos))) : irreducible_space (has_bot (has_neg pos)) := sorry --non-trivial
lemma new_lemma_60444 (h0 : functor.add_const (ring (generalized_boolean_algebra pos)) name) : @rank_condition.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (generalized_boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_60445 (h0 : functor.add_const (topological_space (add_cancel_comm_monoid empty)) empty) : @t1_space.{0} (add_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_60446 (h0 : topological_space (boolean_algebra.core (has_add (has_add Type)))) : preconnected_space (boolean_algebra.core (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_60447 (h0 : functor.add_const (function.extfun Type group) pos) : @is_simple_group.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_60448 (h0 : functor.add_const (add_group (normed_comm_ring unsigned)) linarith.comp) : @is_add_cyclic.{0} (normed_comm_ring.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (normed_comm_ring.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_60449 (h0 : list (denumerable (random_gen char))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_60450 (h0 : group (complete_semilattice_Sup linarith.comp_source)) : is_cyclic (complete_semilattice_Sup linarith.comp_source) := sorry --non-trivial
lemma new_lemma_60451 (h0 : functor.add_const (finset (measurable_space.dynkin_system empty)) (option empty)) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_60452 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_60453 (h0 : functor.add_const (uniform_space (has_neg_part pos)) (has_add environment.implicit_infer_kind)) : @complete_space.{0} (has_neg_part.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_neg_part.{0} pos)) (has_add.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_60454 (h0 : functor.add_const (filter (comm_group name)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_60455 (h0 : measurable_space (has_lt (random_gen char))) (h1 : has_mul (has_lt (random_gen char))) : has_measurable_mul₂ (has_lt (random_gen char)) := sorry --non-trivial
lemma new_lemma_60456 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @totally_disconnected_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_60457 (h0 : topological_space (has_ssubset linarith.comp_source)) : locally_compact_space (has_ssubset linarith.comp_source) := sorry --non-trivial
lemma new_lemma_60458 (h0 : function.extfun Type ring) : @rank_condition.{0} (monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_60459 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_60460 (h0 : functor.add_const (topological_space (fintype ennreal)) (option ennreal)) : @preirreducible_space.{0} (fintype.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (fintype.{0} ennreal)) (option.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_60461 (h0 : functor.comp group canonically_ordered_comm_semiring pos) : @is_simple_group.{0} (canonically_ordered_comm_semiring.{0} pos) (@functor.comp.run.{0 0 0} group.{0} canonically_ordered_comm_semiring.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_60462 (h0 : functor.add_const (fin has_zero.zero) real) : @totally_separated_space.{0} (has_bot.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} real)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) real h0))  := sorry --non-trivial
lemma new_lemma_60463 (h0 : add_group (add_cancel_comm_monoid (random_gen reducibility_hints))) : is_add_cyclic (add_cancel_comm_monoid (random_gen reducibility_hints)) := sorry --non-trivial
lemma new_lemma_60464 (h0 : not (function.extfun (finset Type) (has_mem.mem unsigned) -> false)) : @totally_disconnected_space.{0} unsigned (@finset.pi.empty.{1 0} Type topological_space.{0} unsigned (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) unsigned) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) unsigned)) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_60465 (h0 : has_le (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup enat)))) (h1 : add_comm_semigroup (add_comm_semigroup (add_comm_semigroup enat))) : is_bot h1 := sorry --non-trivial
lemma new_lemma_60466 (h0 : complete_lattice (with_one (has_ssubset to_additive.value_type))) : is_compactly_generated (with_one (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_60467 (h0 : functor.add_const (topological_space (boolean_algebra Type)) linarith.comp) : @normal_space.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_60468 (h0 : topological_space (has_compl (has_inv (random_gen (random_gen (has_inv fun_info)))))) : totally_disconnected_space (has_compl (has_inv (random_gen (random_gen (has_inv fun_info))))) := sorry --non-trivial
lemma new_lemma_60469 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (metric_space.{0} linarith.comp) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (metric_space.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_60470 (h0 : functor.add_const (add_monoid (partial_order empty)) num) : @add_monoid.fg.{0} (partial_order.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (partial_order.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_60471 (h0 : uniform_space (measurable_space.dynkin_system congr_arg_kind)) : separated_space (measurable_space.dynkin_system congr_arg_kind) := sorry --non-trivial
lemma new_lemma_60472 (h0 : not (function.extfun (Type 1) filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (plift empty)) := sorry --non-trivial
lemma new_lemma_60473 (h0 : cancel_comm_monoid_with_zero (has_neg_part (has_add Type))) : unique_factorization_monoid (has_neg_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_60474 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (mul_zero_class.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (mul_zero_class.{0} name))  := sorry --non-trivial
lemma new_lemma_60475 (h2 : filter (complete_semilattice_Sup congr_arg_kind)) : filter.ne_bot h2 := sorry --non-trivial
lemma new_lemma_60476 (h0 : functor.add_const (group (has_add pos)) name) : @normalizer_condition.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_add.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_60477 (h0 : ring (has_zero ennreal)) : strong_rank_condition (has_zero ennreal) := sorry --non-trivial
lemma new_lemma_60478 (h0 : functor.add_const (add_group (boolean_algebra.core name)) (has_add pos)) : @is_add_cyclic.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (boolean_algebra.core.{0} name)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_60479 (h0 : add_monoid (as_linear_order empty)) : add_monoid.fg (as_linear_order empty) := sorry --non-trivial
lemma new_lemma_60480 (h0 : uniform_space (measurable_space linarith.ineq)) : complete_space (measurable_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_60481 (h0 : complete_lattice (has_add (sub_neg_monoid real))) : complete_lattice.is_Sup_finite_compact (has_add (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_60482 (h0 : complete_lattice (has_sub (semiring unsigned))) : is_atomistic (has_sub (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_60483 (h0 : not (topological_space (option congr_arg_kind) -> false)) : @irreducible_space.{0} (option.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (option.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_60484 (h0 : functor.add_const (add_monoid (free_add_monoid empty)) congr_arg_kind) : add_monoid.fg (free_add_monoid empty) := sorry --non-trivial
lemma new_lemma_60485 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} to_additive.value_type (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) to_additive.value_type)  := sorry --non-trivial
lemma new_lemma_60486 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_60487 (h0 : topological_space (finset (has_neg_part name))) : path_connected_space (finset (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_60488 (h1 : complete_lattice (add_cancel_comm_monoid to_additive.value_type)) : is_compactly_generated (add_cancel_comm_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_60489 (h0 : semiring (has_add (normed_comm_ring linarith.comp))) : is_noetherian_ring (has_add (normed_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_60490 (h0 : semiring (semigroup (ring (finset Type)))) : is_noetherian_ring (semigroup (ring (finset Type))) := sorry --non-trivial
lemma new_lemma_60491 (h0 : topological_space (has_bot (has_Inf real))) : preconnected_space (has_bot (has_Inf real)) := sorry --non-trivial
lemma new_lemma_60492 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_60493 (h0 : list (with_bot (comm_ring linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_60494 (h0 : functor.add_const (topological_space (normed_comm_ring linarith.comp)) (has_zero (has_zero name))) : @topological_space.separable_space.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} linarith.comp)) (has_zero.{0} (has_zero.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_60495 (h0 : not (topological_space (complete_linear_order congr_arg_kind) -> false)) : @t0_space.{0} (complete_linear_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_linear_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_60496 (h0 : lattice (add_cancel_comm_monoid (random_gen string.iterator_imp))) : is_modular_lattice (add_cancel_comm_monoid (random_gen string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_60497 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_60498 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_to_string.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} name))  := sorry --non-trivial
lemma new_lemma_60499 (h0 : topological_space ennreal) : preirreducible_space ennreal := sorry --non-trivial
lemma new_lemma_60500 (h0 : not (has_mem.mem Type has_emptyc.emptyc -> false)) : @t0_space.{1} Type (@finset.pi.empty.{2 1} (Type 1) topological_space.{1} Type (@classical.by_contradiction'.{0} (@has_mem.mem.{2 2} (Type 1) (finset.{2} (Type 1)) (@finset.has_mem.{2} (Type 1)) Type (@has_emptyc.emptyc.{2} (finset.{2} (Type 1)) (@finset.has_emptyc.{2} (Type 1)))) h0))  := sorry --non-trivial
lemma new_lemma_60501 (h0 : list (encodable (random_gen (has_nnnorm fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_60502 (h0 : functor.add_const (group (omega_complete_partial_order unsigned)) empty) : @is_cyclic.{0} (omega_complete_partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (group.{0} (omega_complete_partial_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_60503 (h0 : add_monoid (canonically_ordered_monoid pos)) : add_monoid.fg (canonically_ordered_monoid pos) := sorry --non-trivial
lemma new_lemma_60504 (h0 : cancel_comm_monoid_with_zero (has_pos_part (has_neg (has_Inf Type)))) : unique_factorization_monoid (has_pos_part (has_neg (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_60505 (h0 : ring (metric_space (has_top linarith.comp))) : is_domain (metric_space (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_60506 (h0 : functor.add_const (ordered_comm_monoid (has_Inf linarith.comp)) name) : @has_exists_mul_of_le.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_Inf.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_60507 (h0 : linear_ordered_field unsigned -> linear_ordered_field unsigned -> Prop) : is_symm (linear_ordered_field unsigned) h0 := sorry --non-trivial
lemma new_lemma_60508 (h0 : group (complete_semilattice_Sup (has_top (has_top fun_info)))) : group.fg (complete_semilattice_Sup (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_60509 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (@id.{2} Type unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (@id.{2} Type unsigned))  := sorry --non-trivial
lemma new_lemma_60510 (h1 : topological_space (has_ssubset (mul_one_class environment.projection_info))) : regular_space (has_ssubset (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_60511 (h0 : functor.add_const (topological_space (has_to_string environment.implicit_infer_kind)) name) : @loc_path_connected_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_60512 (h0 : function.extfun Type topological_space) : @t1_space.{0} (left_cancel_semigroup.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_60513 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (has_star.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_star.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_60514 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (add_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (add_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_60515 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_one.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_one.{0} num))  := sorry --non-trivial
lemma new_lemma_60516 (h0 : prod (semigroup (semiring (semiring (semiring empty)))) (semigroup (semiring (semiring (semiring empty))))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_60517 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (has_scalar.{0 0} ennreal name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_scalar.{0 0} ennreal name))  := sorry --non-trivial
lemma new_lemma_60518 (h0 : functor.add_const (list (left_cancel_semigroup empty)) num) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_60519 (h0 : complete_lattice (has_norm fun_info)) : is_atomistic (has_norm fun_info) := sorry --non-trivial
lemma new_lemma_60520 (h0 : topological_space (plift (semiring num))) : t0_space (plift (semiring num)) := sorry --non-trivial
lemma new_lemma_60521 (h0 : uniform_space (linear_ordered_semiring (random_gen string_imp))) : complete_space (linear_ordered_semiring (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_60522 (h0 : uniform_space (measure_theory.measure_space (semiring (has_top (semiring congr_arg_kind))))) : separated_space (measure_theory.measure_space (semiring (has_top (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_60523 (h0 : functor.add_const (complete_lattice (has_zero unsigned)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_zero.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_60524 (h0 : functor.add_const Prop (boolean_algebra (comm_group Type))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_60525 (h0 : ring (with_bot linarith.comp)) : is_domain (with_bot linarith.comp) := sorry --non-trivial
lemma new_lemma_60526 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_60527 (h0 : group (boolean_algebra (comm_semigroup real))) : group.fg (boolean_algebra (comm_semigroup real)) := sorry --non-trivial
lemma new_lemma_60528 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_add_comm_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_60529 (h0 : functor.add_const (monoid (linear_ordered_field unsigned)) (option empty)) : @monoid.fg.{0} (linear_ordered_field.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (linear_ordered_field.{0} unsigned)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_60530 (h0 : ring (canonically_ordered_monoid (has_add (has_add real)))) : strong_rank_condition (canonically_ordered_monoid (has_add (has_add real))) := sorry --non-trivial
lemma new_lemma_60531 (h0 : cancel_comm_monoid_with_zero (has_bot (sub_neg_monoid (sub_neg_monoid real)))) : unique_factorization_monoid (has_bot (sub_neg_monoid (sub_neg_monoid real))) := sorry --non-trivial
lemma new_lemma_60532 (h1 : function.extfun Type group) : @normalizer_condition.{0} (with_bot.{0} (random_gen.{0} string_imp)) (@function.extfun_app.{2 1} Type group.{0} h1 (with_bot.{0} (random_gen.{0} string_imp)))  := sorry --non-trivial
lemma new_lemma_60533 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) (has_neg name)) : @loc_path_connected_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) (has_neg.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_60534 (h0 : pnat -> Prop) (h1 : pnat) : pnat.coprime (classical.epsilon h0) h1 := sorry --non-trivial
lemma new_lemma_60535 (h0 : functor.add_const (topological_space (ring pos)) linarith.comp) : @t0_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_60536 (h0 : functor.add_const (topological_space (has_pos_part real)) linarith.comp) : @topological_space.separable_space.{0} (has_pos_part.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} real)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_60537 (h0 : topological_space (sub_neg_monoid (has_Inf linarith.comp))) : preirreducible_space (sub_neg_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_60538 (h0 : uniform_space (comm_group (has_add pos))) : separated_space (comm_group (has_add pos)) := sorry --non-trivial
lemma new_lemma_60539 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (monoid empty)) := sorry --non-trivial
lemma new_lemma_60540 (h0 : group (add_comm_monoid (has_add name))) : group.fg (add_comm_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_60541 (h0 : functor.add_const (topological_space (plift congr_arg_kind)) congr_arg_kind) : @discrete_topology.{1} (plift.{1} congr_arg_kind) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_60542 (h0 : topological_space (measurable_space num)) : locally_compact_space (measurable_space num) := sorry --non-trivial
lemma new_lemma_60543 (h0 : group (metric_space (semiring (semiring unsigned)))) : is_cyclic (metric_space (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_60544 (h0 : uniform_space (generalized_boolean_algebra (has_neg (has_bot real)))) : separated_space (generalized_boolean_algebra (has_neg (has_bot real))) := sorry --non-trivial
lemma new_lemma_60545 (h0 : topological_space (has_nndist name)) : path_connected_space (has_nndist name) := sorry --non-trivial
lemma new_lemma_60546 (h0 : functor.add_const (ordered_add_comm_monoid (bin_tree empty)) empty) : @archimedean.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (bin_tree.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_60547 (h1 : topological_space (linear_ordered_add_comm_group (has_nnnorm char))) : totally_disconnected_space (linear_ordered_add_comm_group (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_60548 (h0 : ring (ordered_comm_monoid (finset Type))) : is_domain (ordered_comm_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_60549 (h0 : add_group (cancel_monoid num)) : is_add_cyclic (cancel_monoid num) := sorry --non-trivial
lemma new_lemma_60550 (h0 : add_group (canonically_ordered_comm_semiring (has_add name))) : is_add_cyclic (canonically_ordered_comm_semiring (has_add name)) := sorry --non-trivial
lemma new_lemma_60551 (h0 : filter (semigroup empty)) (h1 : semigroup empty -> topological_space (comm_monoid (semiring empty))) : @locally_compact_space.{0} (comm_monoid.{0} (semiring.{0} empty)) (@filter.limsup.{0 0} (topological_space.{0} (comm_monoid.{0} (semiring.{0} empty))) (semigroup.{0} empty) (@complete_lattice.to_conditionally_complete_lattice.{0} (topological_space.{0} (comm_monoid.{0} (semiring.{0} empty))) (@topological_space.complete_lattice.{0} (comm_monoid.{0} (semiring.{0} empty)))) h0 h1)  := sorry --non-trivial
lemma new_lemma_60552 (h0 : group (has_norm (has_norm (has_norm (has_norm fun_info))))) : is_cyclic (has_norm (has_norm (has_norm (has_norm fun_info)))) := sorry --non-trivial
lemma new_lemma_60553 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_60554 (h0 : group (boolean_algebra (has_bot linarith.comp))) : is_simple_group (boolean_algebra (has_bot linarith.comp)) := sorry --non-trivial
lemma new_lemma_60555 (h0 : topological_space (simple_graph (ring Type))) : regular_space (simple_graph (ring Type)) := sorry --non-trivial
lemma new_lemma_60556 (h1 : add_group linarith.comp_source) : is_add_cyclic linarith.comp_source := sorry --non-trivial
lemma new_lemma_60557 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_60558 (h0 : topological_space (has_Inf (has_add linarith.comp))) : preirreducible_space (has_Inf (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_60559 (h0 : group (simple_graph (option empty))) : group.fg (simple_graph (option empty)) := sorry --non-trivial
lemma new_lemma_60560 (h0 : functor.add_const (semiring (has_neg_part name)) name) : @is_noetherian_ring.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (semiring.{0} (has_neg_part.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_60561 (h0 : uniform_space (encodable (has_inv fun_info))) : complete_space (encodable (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_60562 (h0 : add_monoid (has_add (add_left_cancel_monoid pos))) : add_monoid.fg (has_add (add_left_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_60563 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (comm_semigroup.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_60564 (h1 : monoid (complete_semilattice_Sup congr_arg_kind)) : monoid.fg (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_60565 (h0 : topological_space (canonically_ordered_comm_semiring (option ennreal))) : topological_space.separable_space (canonically_ordered_comm_semiring (option ennreal)) := sorry --non-trivial
lemma new_lemma_60566 (h0 : topological_space (linear_ordered_field (option ennreal))) : t0_space (linear_ordered_field (option ennreal)) := sorry --non-trivial
lemma new_lemma_60567 (h0 : topological_space (has_add (has_nndist linarith.comp))) : preconnected_space (has_add (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_60568 (h0 : function.extfun Type (functor.add_const (topological_space (linear_order empty)))) : @discrete_topology.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_order.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (linear_order.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_60569 (h1 : complete_lattice (has_compl string_imp)) : is_compactly_generated (has_compl string_imp) := sorry --non-trivial
lemma new_lemma_60570 (h0 : topological_space (has_emptyc (semiring linarith.comp))) : t0_space (has_emptyc (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_60571 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (mul_zero_class.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (mul_zero_class.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_60572 (h0 : functor.add_const (ring (linear_ordered_comm_monoid_with_zero empty)) empty) : @is_domain.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_60573 (h0 : topological_space (comm_group (has_neg linarith.comp))) : t0_space (comm_group (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_60574 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (canonically_ordered_comm_semiring.{0} subsingleton_info) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (canonically_ordered_comm_semiring.{0} subsingleton_info))  := sorry --non-trivial
lemma new_lemma_60575 (h0 : functor.add_const (function.extfun (Type -> Type) (function.extfun Type)) empty) : @is_atomistic.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (bin_tree.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (bin_tree.{0} empty))) (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@functor.add_const.run.{1 0} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) empty h0) (functor.add_const.{0 0} (complete_lattice.{0} (bin_tree.{0} empty)))) empty))  := sorry --non-trivial
lemma new_lemma_60576 (h0 : not (add_group (normed_group linarith.comp_source) -> false)) : @is_add_cyclic.{0} (normed_group.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (add_group.{0} (normed_group.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_60577 (h0 : not (uniform_space (with_bot empty) -> false)) : @separated_space.{0} (with_bot.{0} empty) (@classical.by_contradiction'.{1} (uniform_space.{0} (with_bot.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_60578 (h0 : semiring (has_nndist ennreal)) : is_noetherian_ring (has_nndist ennreal) := sorry --non-trivial
lemma new_lemma_60579 (h0 : functor.add_const (topological_space environment.implicit_infer_kind) Type) : @irreducible_space.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 1} (topological_space.{0} environment.implicit_infer_kind) Type h0)  := sorry --non-trivial
lemma new_lemma_60580 (h0 : functor.add_const (complete_lattice (add_comm_monoid Type)) Type) : @complete_lattice.is_Sup_finite_compact.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (add_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_60581 (h0 : ring (add_monoid to_additive.value_type)) : is_domain (add_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_60582 (h0 : function.extfun Type topological_space) : @t0_space.{0} (topological_space.{0} (has_nnnorm.{0} (has_nnnorm.{0} (random_gen.{0} (has_nnnorm.{0} linarith.ineq))))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (topological_space.{0} (has_nnnorm.{0} (has_nnnorm.{0} (random_gen.{0} (has_nnnorm.{0} linarith.ineq))))))  := sorry --non-trivial
lemma new_lemma_60583 (h0 : add_group (plift (semiring (semiring congr_arg_kind)))) : is_add_cyclic (plift (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_60584 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (has_one.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} h0 (has_one.{0} empty))  := sorry --non-trivial
lemma new_lemma_60585 (h0 : functor.add_const (cancel_comm_monoid_with_zero (left_cancel_semigroup congr_arg_kind)) empty) : @unique_factorization_monoid.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (left_cancel_semigroup.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_60586 (h0 : not (function.extfun Type complete_lattice -> false)) : is_compactly_generated (topological_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_60587 (h0 : topological_space (has_norm empty)) : totally_disconnected_space (has_norm empty) := sorry --non-trivial
lemma new_lemma_60588 (h0 : topological_space (has_nndist (add_comm_monoid pos))) : irreducible_space (has_nndist (add_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_60589 (h0 : function.extfun Type group) : @group.fg.{0} (has_nndist.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (has_nndist.{0} num))  := sorry --non-trivial
lemma new_lemma_60590 (h1 : topological_space (measurable_space (random_gen linarith.ineq))) : totally_separated_space (measurable_space (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_60591 (h0 : function.extfun (Type 1) cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{1} (canonically_ordered_comm_semiring.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} h0 (canonically_ordered_comm_semiring.{1} Type))  := sorry --non-trivial
lemma new_lemma_60592 (h1 : add_group (comm_ring linarith.comp_source)) : is_add_cyclic (comm_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_60593 (h0 : topological_space (distrib_lattice (comm_ring to_additive.value_type))) : path_connected_space (distrib_lattice (comm_ring to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_60594 (h0 : filter (normed_group (has_norm (semiring (semiring (semiring (has_top linarith.comp))))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_60595 (h0 : function.extfun Type (functor.add_const (topological_space (ordered_comm_group empty)))) : @t1_space.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_group.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (ordered_comm_group.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_60596 (h0 : topological_space (linear_ordered_field (has_to_string pos))) : t1_space (linear_ordered_field (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_60597 (h0 : complete_lattice (has_zero (has_add unsigned))) : is_compactly_generated (has_zero (has_add unsigned)) := sorry --non-trivial
lemma new_lemma_60598 (h0 : functor.add_const (function.extfun Type group) name) : @group.fg.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) name h0) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_60599 (h0 : list (normed_group empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_60600 (h0 : filter (dlist (random_gen (has_inv to_additive.value_type)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_60601 (h0 : functor.add_const (ring (boolean_algebra.core name)) name) : @is_domain.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_60602 (h0 : functor.add_const (ring (add_cancel_monoid pos)) (finset Type)) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (add_cancel_monoid.{0} pos)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_60603 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_60604 (h0 : functor.add_const (topological_space (cancel_monoid pos)) Type) : @discrete_topology.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_60605 (h0 : functor.add_const (uniform_space (has_to_string name)) (finset environment.implicit_infer_kind)) : @complete_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_to_string.{0} name)) (finset.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_60606 (h1 : char -> nat) (h2 h4 : char) : measure h1 h2 h4 := sorry --non-trivial
lemma new_lemma_60607 (h0 : topological_space (has_nndist (normed_linear_ordered_group name))) : locally_compact_space (has_nndist (normed_linear_ordered_group name)) := sorry --non-trivial
lemma new_lemma_60608 (h0 : functor.add_const (ordered_add_comm_monoid (linear_order empty)) (option unsigned)) : @archimedean.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (linear_order.{0} empty)) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_60609 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_60610 (h0 : ordered_add_comm_monoid (has_pos_part (has_neg (has_nndist Type)))) : archimedean (has_pos_part (has_neg (has_nndist Type))) := sorry --non-trivial
lemma new_lemma_60611 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_60612 (h0 : list (has_top (has_inv (has_top fun_info)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_60613 (h0 : ring (has_ssubset (has_lt string_imp))) : rank_condition (has_ssubset (has_lt string_imp)) := sorry --non-trivial
lemma new_lemma_60614 (h0 : not (ring (distrib to_additive.value_type) -> false)) : @is_domain.{0} (distrib.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (distrib.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_60615 (h0 : list (has_Sup (semiring num))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_60616 (h0 : not (filter (complete_semilattice_Sup num) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_60617 (h0 : topological_space (complete_distrib_lattice (normed_comm_ring (has_add pos)))) : totally_disconnected_space (complete_distrib_lattice (normed_comm_ring (has_add pos))) := sorry --non-trivial
lemma new_lemma_60618 (h0 : functor.add_const (group (ordered_comm_monoid pos)) Type) : @normalizer_condition.{0} (ordered_comm_monoid.{0} pos) (@functor.add_const.run.{0 1} (group.{0} (ordered_comm_monoid.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_60619 (h0 : not (topological_space (complete_semilattice_Sup congr_arg_kind) -> false)) : @discrete_topology.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_60620 (h0 : ring (has_bot (has_Inf linarith.comp))) : rank_condition (has_bot (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_60621 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_top num)) := sorry --non-trivial
lemma new_lemma_60622 (h0 : not (topological_space (has_one linarith.comp) -> false)) : @irreducible_space.{0} (has_one.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_one.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_60623 (h0 : functor.add_const (list (pseudo_metric_space pos)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_60624 (h0 : topological_space (has_add (ring (ring pos)))) : t0_space (has_add (ring (ring pos))) := sorry --non-trivial
lemma new_lemma_60625 (h0 : function.extfun Type group) : @is_cyclic.{0} (ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_60626 (h0 : function.extfun Type ring) : @rank_condition.{0} (with_zero.{0} (has_nnnorm.{0} linarith.ineq)) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_zero.{0} (has_nnnorm.{0} linarith.ineq)))  := sorry --non-trivial
lemma new_lemma_60627 (h0 : functor.add_const (group (add_semigroup empty)) empty) : @normalizer_condition.{0} (add_semigroup.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (add_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_60628 (h0 : ring (metric_space (has_nndist (semiring (has_norm (has_norm unsigned)))))) : strong_rank_condition (metric_space (has_nndist (semiring (has_norm (has_norm unsigned))))) := sorry --non-trivial
lemma new_lemma_60629 (h0 : prod (has_top linarith.comp) (has_top linarith.comp)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_60630 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_60631 (h0 : add_group (has_append linarith.comp_source)) : is_add_cyclic (has_append linarith.comp_source) := sorry --non-trivial
lemma new_lemma_60632 (h0 : has_inter empty -> has_inter empty -> Prop) (h1 : function.extfun (Type -> Type) (function.extfun Type)) (h2 : has_inter empty) : relation.join h0 (function.extfun_app (function.extfun_app h1 has_inter) empty) h2 := sorry --non-trivial
lemma new_lemma_60633 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_norm.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (has_norm.{0} num))  := sorry --non-trivial
lemma new_lemma_60634 (h0 : functor.add_const (ring (add_cancel_monoid Type)) (has_Inf name)) : @strong_rank_condition.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (add_cancel_monoid.{1} Type)) (has_Inf.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_60635 (h0 : ring (linear_ordered_field (option (option (option (option pos)))))) : strong_rank_condition (linear_ordered_field (option (option (option (option pos))))) := sorry --non-trivial
lemma new_lemma_60636 (h0 : functor.add_const (topological_space (comm_group name)) pos) : @loc_path_connected_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_60637 (h0 : functor.add_const (topological_space (finset Type)) linarith.comp) : @sequential_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_60638 (h0 : topological_space (comm_group (canonically_ordered_comm_semiring (finset name)))) : totally_disconnected_space (comm_group (canonically_ordered_comm_semiring (finset name))) := sorry --non-trivial
lemma new_lemma_60639 (h0 : finset (simple_graph (has_pos_part linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_60640 (h0 : topological_space (ordered_ring num)) : t1_space (ordered_ring num) := sorry --non-trivial
lemma new_lemma_60641 (h0 : topological_space char) (h2 : preorder char) : order_closed_topology char := sorry --non-trivial
lemma new_lemma_60642 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_60643 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (normed_lattice_add_comm_group real)) := sorry --non-trivial
lemma new_lemma_60644 (h0 : uniform_space (has_dist num)) : separated_space (has_dist num) := sorry --non-trivial
lemma new_lemma_60645 (h0 : topological_space (has_top (has_norm (has_norm (has_norm num))))) : path_connected_space (has_top (has_norm (has_norm (has_norm num)))) := sorry --non-trivial
lemma new_lemma_60646 (h0 : topological_space (plift (normed_group unsigned))) : irreducible_space (plift (normed_group unsigned)) := sorry --non-trivial
lemma new_lemma_60647 (h0 : group (has_inter empty)) : group.fg (has_inter empty) := sorry --non-trivial
lemma new_lemma_60648 (h0 : topological_space (linear_ordered_semiring (semiring fun_info))) : t0_space (linear_ordered_semiring (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_60649 (h0 : group (random_gen (has_norm congr_arg_kind))) : is_cyclic (random_gen (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_60650 (h0 : uniform_space (linear_ordered_comm_group_with_zero enat)) : complete_space (linear_ordered_comm_group_with_zero enat) := sorry --non-trivial
lemma new_lemma_60651 (h0 : topological_space (normed_group (has_top linarith.ineq))) : t0_space (normed_group (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_60652 (h1 : not (function.extfun (finset Type) (has_mem.mem num) -> false)) : @discrete_topology.{0} num (@finset.pi.empty.{1 0} Type topological_space.{0} num (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num)) h1) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_60653 (h0 : functor.add_const (add_monoid (finset pos)) unsigned) : @add_monoid.fg.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (add_monoid.{0} (finset.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_60654 (h0 : complete_lattice (semiring (semiring (semiring linarith.comp)))) : is_atomistic (semiring (semiring (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_60655 (h0 : add_group (has_le enat)) : is_add_cyclic (has_le enat) := sorry --non-trivial
lemma new_lemma_60656 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_top.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_top.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_60657 (h0 : ordered_add_comm_monoid (normed_comm_ring (has_to_string Type))) : archimedean (normed_comm_ring (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_60658 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} num (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) num)  := sorry --non-trivial
lemma new_lemma_60659 (h0 : topological_space (random_gen unsigned)) : totally_separated_space (random_gen unsigned) := sorry --non-trivial
lemma new_lemma_60660 (h0 : monoid (with_bot linarith.ineq)) : monoid.fg (with_bot linarith.ineq) := sorry --non-trivial
lemma new_lemma_60661 (h0 : topological_space (has_zero (add_comm_monoid (add_comm_monoid Type)))) : locally_compact_space (has_zero (add_comm_monoid (add_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_60662 (h1 : ring (has_add to_additive.value_type)) : rank_condition (has_add to_additive.value_type) := sorry --non-trivial
lemma new_lemma_60663 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_60664 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @discrete_topology.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_60665 (h0 : ordered_comm_monoid (boolean_algebra.core (normed_comm_ring Type))) : has_exists_mul_of_le (boolean_algebra.core (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_60666 (h0 : set (left_cancel_semigroup enat)) (h1 : left_cancel_semigroup enat) : set.compl h0 h1 := sorry --non-trivial
lemma new_lemma_60667 (h0 : ordered_comm_monoid (generalized_boolean_algebra (ring pos))) : has_exists_mul_of_le (generalized_boolean_algebra (ring pos)) := sorry --non-trivial
lemma new_lemma_60668 (h0 : topological_space (has_edist (option (option unsigned)))) : preirreducible_space (has_edist (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_60669 (h0 : functor.comp group has_neg name) : @is_cyclic.{0} (has_neg.{0} name) (@functor.comp.run.{0 0 0} group.{0} has_neg.{0} name h0)  := sorry --non-trivial
lemma new_lemma_60670 (h0 : functor.add_const (complete_lattice (cancel_monoid pos)) environment.implicit_infer_kind) : @is_atomistic.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (cancel_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_60671 (h0 : topological_space (simple_graph (has_Inf (finset linarith.comp)))) : irreducible_space (simple_graph (has_Inf (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_60672 (h0 : function.extfun Type group) : @normalizer_condition.{0} (pseudo_metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (pseudo_metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_60673 (h0 : topological_space (complete_distrib_lattice pos)) : irreducible_space (complete_distrib_lattice pos) := sorry --non-trivial
lemma new_lemma_60674 (h0 : functor.add_const (topological_space (has_Inf pos)) Type) : @path_connected_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_60675 (h0 : has_mem.mem (with_one fun_info) has_emptyc.emptyc) : @locally_compact_space.{0} (with_one.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_one.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_60676 (h0 : topological_space (has_zero (option pos))) : totally_disconnected_space (has_zero (option pos)) := sorry --non-trivial
lemma new_lemma_60677 (h0 : std_gen -> char -> char) (h1 : char -> char -> Prop) : covariant std_gen char h0 h1 := sorry --non-trivial
lemma new_lemma_60678 (h10 : complete_lattice (denumerable char)) : is_compactly_generated (denumerable char) := sorry --non-trivial
lemma new_lemma_60679 (h0 : topological_space (normed_group (has_ssubset linarith.ineq))) : path_connected_space (normed_group (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_60680 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (mul_zero_class.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (mul_zero_class.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_60681 (h0 : functor.add_const (topological_space (has_edist empty)) empty) : @path_connected_space.{0} (has_edist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_edist.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_60682 (h0 : topological_space (has_to_string (has_add (has_to_string unsigned)))) : normal_space (has_to_string (has_add (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_60683 (h0 : group (boolean_algebra environment.implicit_infer_kind)) : group.fg (boolean_algebra environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_60684 (h0 : has_coe (add_comm_semigroup std_gen) Prop) (h2 : add_comm_semigroup std_gen) : @coe_b.{1 1} (add_comm_semigroup.{0} std_gen) Prop h0 h2  := sorry --non-trivial
lemma new_lemma_60685 (h1 : equiv.perm to_additive.value_type) (h2 : not (to_additive.value_type -> false)) (h3 : to_additive.value_type) : equiv.perm.same_cycle h1 (classical.by_contradiction' h2) h3 := sorry --non-trivial
lemma new_lemma_60686 (h0 : group (has_add (finset linarith.comp))) : is_cyclic (has_add (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_60687 (h0 : functor.add_const (cancel_comm_monoid_with_zero (is_R_or_C empty)) num) : @unique_factorization_monoid.{0} (is_R_or_C.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (is_R_or_C.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_60688 (h0 : topological_space (has_pos_part (ordered_comm_monoid Type))) : t1_space (has_pos_part (ordered_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_60689 (h0 : topological_space (multiplicative fun_info)) (h1 : preorder (multiplicative fun_info)) : order_topology (multiplicative fun_info) := sorry --non-trivial
lemma new_lemma_60690 (h0 : semiring (has_neg_part name)) : is_noetherian_ring (has_neg_part name) := sorry --non-trivial
lemma new_lemma_60691 (h3 : topological_space (nondiscrete_normed_field char)) : t0_space (nondiscrete_normed_field char) := sorry --non-trivial
lemma new_lemma_60692 (h0 h1 : multiset (uniform_space linarith.ineq)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_60693 (h0 : filter (dlist (dlist (comm_ring char)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_60694 (h0 : topological_space (has_neg (finset linarith.comp))) : locally_compact_space (has_neg (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_60695 (h0 : ordered_add_comm_monoid (pseudo_metric_space ennreal)) : archimedean (pseudo_metric_space ennreal) := sorry --non-trivial
lemma new_lemma_60696 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (measurable_space.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} congr_arg_kind)))))) (@function.extfun_app.{2 1} Type monoid.{0} h0 (measurable_space.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} congr_arg_kind)))))))  := sorry --non-trivial
lemma new_lemma_60697 (h0 : topological_space (plift (has_Sup empty))) : locally_compact_space (plift (has_Sup empty)) := sorry --non-trivial
lemma new_lemma_60698 (h0 : functor.add_const (topological_space (semigroup Type)) (has_neg pos)) : @locally_compact_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_60699 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring unsigned)) linarith.comp) : @preirreducible_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_60700 (h0 : not (topological_space (topological_space (semi_normed_ring reducibility_hints)) -> false)) : @t0_space.{0} (topological_space.{0} (semi_normed_ring.{0} reducibility_hints)) (@classical.by_contradiction'.{1} (topological_space.{0} (topological_space.{0} (semi_normed_ring.{0} reducibility_hints))) h0)  := sorry --non-trivial
lemma new_lemma_60701 (h0 : semiring environment.projection_info) (h1 : ideal environment.projection_info) : ideal.is_prime h1 := sorry --non-trivial
lemma new_lemma_60702 (h0 : topological_space (complete_semilattice_Sup fun_info)) : path_connected_space (complete_semilattice_Sup fun_info) := sorry --non-trivial
lemma new_lemma_60703 (h0 : not (ring (measurable_space num) -> false)) : @strong_rank_condition.{0} (measurable_space.{0} num) (@classical.by_contradiction'.{1} (ring.{0} (measurable_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_60704 (h0 : complete_lattice (add_cancel_monoid (has_nndist (finset (boolean_algebra.core name))))) : is_atomistic (add_cancel_monoid (has_nndist (finset (boolean_algebra.core name)))) := sorry --non-trivial
lemma new_lemma_60705 (h0 : functor.add_const Prop (boolean_algebra environment.implicit_infer_kind)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_60706 (h0 : complete_lattice (distrib_lattice (random_gen (has_inv linarith.comp_source)))) : complete_lattice.is_Sup_finite_compact (distrib_lattice (random_gen (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_60707 (h0 : ring (id (has_top (has_norm linarith.comp)))) : rank_condition (id (has_top (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_60708 (h0 : topological_space (linear_ordered_comm_group (option empty))) : loc_path_connected_space (linear_ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_60709 (h0 : cancel_comm_monoid_with_zero (complete_linear_order (semiring (semiring unsigned)))) : unique_factorization_monoid (complete_linear_order (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_60710 (h0 : not (has_mem.mem (with_bot linarith.comp_source) has_emptyc.emptyc -> false)) : @is_domain.{0} (with_bot.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type ring.{0} (with_bot.{0} linarith.comp_source) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_bot.{0} linarith.comp_source) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_60711 (h0 : topological_space (linear_ordered_add_comm_group (random_gen linarith.ineq))) : totally_separated_space (linear_ordered_add_comm_group (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_60712 (h0 : ring (with_bot (random_gen (has_inv fun_info)))) : rank_condition (with_bot (random_gen (has_inv fun_info))) := sorry --non-trivial
lemma new_lemma_60713 (h0 : function.extfun Type (functor.add_const (topological_space auto.case_option))) : @path_connected_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} auto.case_option)) h0 empty))  := sorry --non-trivial
lemma new_lemma_60714 (h2 : topological_space (denumerable char)) : t0_space (denumerable char) := sorry --non-trivial
lemma new_lemma_60715 (h0 h1 : multiset (add_comm_monoid to_additive.value_type)) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_60716 (h0 : ring (semiring (has_top fun_info))) : strong_rank_condition (semiring (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_60717 (h0 : not (uniform_space (simple_graph to_additive.value_type) -> false)) : @complete_space.{0} (simple_graph.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (uniform_space.{0} (simple_graph.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_60718 (h0 : filter (normed_comm_ring (finset Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_60719 (h0 : functor.add_const (functor.add_const (add_monoid linarith.comp) pos) Type) : @add_monoid.fg.{0} linarith.comp (@functor.add_const.run.{0 0} (add_monoid.{0} linarith.comp) pos (@functor.add_const.run.{0 1} (functor.add_const.{0 0} (add_monoid.{0} linarith.comp) pos) Type h0))  := sorry --non-trivial
lemma new_lemma_60720 (h0 : functor.add_const (group (simple_graph linarith.comp)) Type) : @is_cyclic.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (simple_graph.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_60721 (h0 : finset (has_inter (option (option (option ennreal))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_60722 (h0 : topological_space (add_comm_semigroup (mul_one_class (mul_one_class string.iterator_imp)))) : totally_separated_space (add_comm_semigroup (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_60723 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm fun_info))) : @is_add_cyclic.{0} (has_norm.{0} fun_info) (@finset.pi.empty.{1 0} Type add_group.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_60724 (h0 : uniform_space (measurable_space empty)) : separated_space (measurable_space empty) := sorry --non-trivial
lemma new_lemma_60725 (h0 : not (topological_space (distrib_lattice char) -> false)) : @totally_disconnected_space.{0} (distrib_lattice.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib_lattice.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_60726 (h0 : functor.add_const (topological_space (finset pos)) pos) : @normal_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_60727 (h0 : functor.add_const (list (has_zero linarith.comp)) environment.implicit_infer_kind) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_60728 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : palindrome (function.extfun_app (function.extfun_app h0 list) (semigroup Type)) := sorry --non-trivial
lemma new_lemma_60729 (h0 : not (complete_lattice (with_bot to_additive.value_type) -> false)) : @is_atomistic.{0} (with_bot.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_bot.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_60730 (h0 : topological_space (canonically_ordered_add_monoid congr_arg_kind)) : locally_compact_space (canonically_ordered_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_60731 (h0 : topological_space (linear_ordered_comm_group (option (option (option empty))))) : t0_space (linear_ordered_comm_group (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_60732 (h0 : topological_space (left_cancel_monoid (semiring empty))) : irreducible_space (left_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_60733 (h0 : topological_space (has_neg_part (has_add environment.implicit_infer_kind))) : regular_space (has_neg_part (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_60734 (h0 : group (has_zero (has_add (has_add (has_add (has_add Type)))))) : is_simple_group (has_zero (has_add (has_add (has_add (has_add Type))))) := sorry --non-trivial
lemma new_lemma_60735 (h1 : ring (semi_normed_comm_ring (denumerable to_additive.value_type))) : strong_rank_condition (semi_normed_comm_ring (denumerable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_60736 (h0 : uniform_space (add_cancel_monoid (has_add environment.implicit_infer_kind))) : separated_space (add_cancel_monoid (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_60737 (h0 : has_mem.mem (has_norm (has_inv (has_top (has_inv (has_top to_additive.value_type))))) has_zero.zero) : @monoid.fg.{0} (has_norm.{0} (has_inv.{0} (has_top.{0} (has_inv.{0} (has_top.{0} to_additive.value_type))))) (@multiset.pi.empty.{1 0} Type monoid.{0} (has_norm.{0} (has_inv.{0} (has_top.{0} (has_inv.{0} (has_top.{0} to_additive.value_type))))) h0)  := sorry --non-trivial
lemma new_lemma_60738 (h0 : topological_space (has_neg (semigroup environment.implicit_infer_kind))) : locally_compact_space (has_neg (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_60739 (h0 : topological_space (ring (has_nndist (has_add (cancel_monoid (cancel_monoid pos))))) -> Prop) : @normal_space.{0} (ring.{0} (has_nndist.{0} (has_add.{0} (cancel_monoid.{0} (cancel_monoid.{0} pos))))) (@classical.epsilon.{1} (topological_space.{0} (ring.{0} (has_nndist.{0} (has_add.{0} (cancel_monoid.{0} (cancel_monoid.{0} pos)))))) (@nonempty_of_inhabited.{1} (topological_space.{0} (ring.{0} (has_nndist.{0} (has_add.{0} (cancel_monoid.{0} (cancel_monoid.{0} pos)))))) (@inhabited_topological_space.{0} (ring.{0} (has_nndist.{0} (has_add.{0} (cancel_monoid.{0} (cancel_monoid.{0} pos))))))) h0)  := sorry --non-trivial
lemma new_lemma_60740 (h0 : list (has_neg (finset (finset (finset environment.implicit_infer_kind))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_60741 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc congr_arg_kind))) : @is_add_cyclic.{0} (has_emptyc.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type add_group.{0} (has_emptyc.{0} congr_arg_kind) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} congr_arg_kind)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_60742 (h0 : not (topological_space (normed_group linarith.comp) -> false)) : @totally_disconnected_space.{0} (normed_group.{0} linarith.comp) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_60743 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (ordered_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_60744 (h0 : preorder (ordered_ring linarith.comp_source)) (h1 : set (ordered_ring linarith.comp_source)) : bdd_below h1 := sorry --non-trivial
lemma new_lemma_60745 (h0 : filter (add_left_cancel_semigroup empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_60746 (h0 : fin has_zero.zero) : @is_principal_ideal_ring.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_60747 (h1 : has_mem.mem (ordered_semiring num) has_emptyc.emptyc) : @irreducible_space.{0} (ordered_semiring.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (ordered_semiring.{0} num) h1)  := sorry --non-trivial
lemma new_lemma_60748 (h0 : topological_space (has_add (option pos))) : preconnected_space (has_add (option pos)) := sorry --non-trivial
lemma new_lemma_60749 (h0 : functor.add_const (topological_space (plift empty)) (semiring empty)) : @preirreducible_space.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_60750 (h0 : nat) (h1 : fin (has_mul.mul has_zero.zero h0)) : nat.prime (matrix.vec_empty (fin.div_nat h1)) := sorry --non-trivial
lemma new_lemma_60751 (h0 : topological_space (linear_ordered_comm_ring (semiring unsigned))) : totally_disconnected_space (linear_ordered_comm_ring (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_60752 (h0 : uniform_space (normed_lattice_add_comm_group (has_add linarith.comp))) : complete_space (normed_lattice_add_comm_group (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_60753 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_60754 (h0 : ring (has_neg_part (finset Type))) : rank_condition (has_neg_part (finset Type)) := sorry --non-trivial
lemma new_lemma_60755 (h0 : topological_space (add_cancel_monoid num)) : normal_space (add_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_60756 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_60757 (h0 : uniform_space (measure_theory.measure_space (semiring (semiring (semiring empty))))) : separated_space (measure_theory.measure_space (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_60758 (h0 : functor.add_const (finset (has_star congr_arg_kind)) unsigned) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_60759 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_inter.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_inter.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_60760 (h0 : functor.add_const (complete_lattice (has_neg_part unsigned)) (option pos)) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg_part.{0} unsigned)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_60761 (h0 : group (linear_ordered_cancel_comm_monoid empty)) : is_cyclic (linear_ordered_cancel_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_60762 (h0 : prod (normed_linear_ordered_group (semiring empty)) (normed_linear_ordered_group (semiring empty))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_60763 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (non_assoc_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (non_assoc_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_60764 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_60765 (h0 : ring (has_Inf real)) : rank_condition (has_Inf real) := sorry --non-trivial
lemma new_lemma_60766 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_60767 (h0 : topological_space (add_cancel_monoid (has_neg_part linarith.comp))) : t1_space (add_cancel_monoid (has_neg_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_60768 (h0 : uniform_space (has_one (semiring (semiring empty)))) : separated_space (has_one (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_60769 (h0 : functor.comp complete_lattice normed_comm_ring environment.implicit_infer_kind) : @is_compactly_generated.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} complete_lattice.{0} normed_comm_ring.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_60770 (h0 : function.extfun Type group) : @group.fg.{0} (linear_ordered_add_comm_group.{0} (denumerable.{0} char)) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_add_comm_group.{0} (denumerable.{0} char)))  := sorry --non-trivial
lemma new_lemma_60771 (h0 : ring (finset (boolean_algebra linarith.comp))) : is_domain (finset (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_60772 (h0 : filter (has_neg_part (option unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_60773 (h1 : topological_space (has_div linarith.ineq)) : t0_space (has_div linarith.ineq) := sorry --non-trivial
lemma new_lemma_60774 (h0 : uniform_space (has_pos_part (has_add pos))) : separated_space (has_pos_part (has_add pos)) := sorry --non-trivial
lemma new_lemma_60775 (h0 : topological_space to_additive.value_type) (h1 : preorder to_additive.value_type) : order_topology to_additive.value_type := sorry --non-trivial
lemma new_lemma_60776 (h0 : topological_space (add_cancel_monoid (ring Type))) : totally_disconnected_space (add_cancel_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_60777 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @irreducible_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_60778 (h0 : topological_space (add_comm_monoid (has_bot real))) : regular_space (add_comm_monoid (has_bot real)) := sorry --non-trivial
lemma new_lemma_60779 (h0 : ring (has_one (semiring (semiring (semiring (semiring (semiring empty))))))) : is_domain (has_one (semiring (semiring (semiring (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_60780 (h0 : ring (has_nndist Type)) : strong_rank_condition (has_nndist Type) := sorry --non-trivial
lemma new_lemma_60781 (h0 : functor.add_const (topological_space (partial_order congr_arg_kind)) empty) : @normal_space.{0} (partial_order.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} congr_arg_kind)) empty h0)  := sorry --non-trivial
lemma new_lemma_60782 (h0 : semiring (ring (has_Inf (finset Type)))) : is_noetherian_ring (ring (has_Inf (finset Type))) := sorry --non-trivial
lemma new_lemma_60783 (h0 : topological_space (with_zero linarith.comp_source)) : t0_space (with_zero linarith.comp_source) := sorry --non-trivial
lemma new_lemma_60784 (h0 : ordered_comm_monoid (complete_distrib_lattice (finset (finset ennreal)))) : has_exists_mul_of_le (complete_distrib_lattice (finset (finset ennreal))) := sorry --non-trivial
lemma new_lemma_60785 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @group.fg.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) group.{0}) (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_60786 (h0 : topological_space (pseudo_metric_space empty)) : totally_separated_space (pseudo_metric_space empty) := sorry --non-trivial
lemma new_lemma_60787 (h0 : topological_space (has_top (random_gen string_imp))) : irreducible_space (has_top (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_60788 (h0 : filter (normed_group (random_gen (random_gen linarith.comp_source)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_60789 (h1 : has_mem.mem (complete_semilattice_Sup congr_arg_kind) has_emptyc.emptyc) : @t0_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_60790 (h0 : ring (finset (has_nndist linarith.comp))) : is_domain (finset (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_60791 (h0 : topological_space (has_zero (finset (has_to_string pos)))) : path_connected_space (has_zero (finset (has_to_string pos))) := sorry --non-trivial
lemma new_lemma_60792 (h0 : prod (plift (semiring congr_arg_kind)) (plift (semiring congr_arg_kind))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_60793 (h0 : topological_space (semiring linarith.comp_source)) : locally_compact_space (semiring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_60794 (h0 : add_group (mul_one_class to_additive.value_type)) : is_add_cyclic (mul_one_class to_additive.value_type) := sorry --non-trivial
lemma new_lemma_60795 (h0 : topological_space (has_pos_part (has_neg Type))) : loc_path_connected_space (has_pos_part (has_neg Type)) := sorry --non-trivial
lemma new_lemma_60796 (h0 : topological_space (add_cancel_monoid (has_neg linarith.comp))) : loc_path_connected_space (add_cancel_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_60797 (h0 : topological_space (generalized_boolean_algebra name)) : preconnected_space (generalized_boolean_algebra name) := sorry --non-trivial
lemma new_lemma_60798 (h0 : functor.add_const (uniform_space (ring name)) pos) : @complete_space.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (uniform_space.{0} (ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_60799 (h0 : ring (has_Inf (has_neg real))) : is_domain (has_Inf (has_neg real)) := sorry --non-trivial
lemma new_lemma_60800 (h0 : finset (has_nndist (boolean_algebra.core (finset name)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_60801 (h0 : functor.add_const (topological_space (comm_group name)) Type) : @preconnected_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (comm_group.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_60802 (h0 : ordered_add_comm_monoid (boolean_algebra.core (finset (has_to_string linarith.comp)))) : archimedean (boolean_algebra.core (finset (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_60803 (h0 : semiring (add_cancel_monoid unsigned)) : is_noetherian_ring (add_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_60804 (h0 : ring (semigroup ennreal)) : is_domain (semigroup ennreal) := sorry --non-trivial
lemma new_lemma_60805 (h1 : function.extfun (nat -> Type) (function.extfun nat)) : @path_connected_space.{0} (has_emptyc.{0} linarith.comp_source) (@matrix.vec_empty.{0} (topological_space.{0} (has_emptyc.{0} linarith.comp_source)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h1 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_60806 (h0 : ring (has_append (has_nnnorm linarith.comp_source))) : is_domain (has_append (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_60807 (h0 : topological_space (boolean_algebra (has_pos_part pos))) : locally_compact_space (boolean_algebra (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_60808 (h0 : complete_lattice (semi_normed_ring linarith.ineq)) : is_compactly_generated (semi_normed_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_60809 (h0 : topological_space (has_le to_additive.value_type)) : path_connected_space (has_le to_additive.value_type) := sorry --non-trivial
lemma new_lemma_60810 (h0 : ring (add_group (has_top (semiring fun_info)))) : is_domain (add_group (has_top (semiring fun_info))) := sorry --non-trivial
lemma new_lemma_60811 (h1 : functor.comp complete_lattice has_div linarith.ineq) : @is_compactly_generated.{0} (has_div.{0} linarith.ineq) (@functor.comp.run.{0 0 0} complete_lattice.{0} has_div.{0} linarith.ineq h1)  := sorry --non-trivial
lemma new_lemma_60812 (h0 : functor.add_const (ring (has_star congr_arg_kind)) (semiring num)) : @strong_rank_condition.{0} (has_star.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (has_star.{0} congr_arg_kind)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_60813 (h0 : complete_lattice (with_bot (has_inv (random_gen to_additive.value_type)))) : is_compactly_generated (with_bot (has_inv (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_60814 (h0 : topological_space (monoid ennreal)) : t1_space (monoid ennreal) := sorry --non-trivial
lemma new_lemma_60815 (h0 : topological_space (canonically_ordered_add_monoid congr_arg_kind)) : loc_path_connected_space (canonically_ordered_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_60816 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (has_nndist empty)) := sorry --non-trivial
lemma new_lemma_60817 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (finset.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} num))  := sorry --non-trivial
lemma new_lemma_60818 (h0 : function.extfun (Type 1) topological_space) : @preirreducible_space.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_60819 (h0 : set (enat -> std_gen)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_60820 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_60821 (h0 : topological_space (random_gen (mul_one_class linarith.comp_source))) : totally_disconnected_space (random_gen (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_60822 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (semigroup.{0} (option.{0} (option.{0} ennreal))) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (semigroup.{0} (option.{0} (option.{0} ennreal))))  := sorry --non-trivial
lemma new_lemma_60823 (h0 : functor.add_const (uniform_space (has_nndist ennreal)) (option (has_add name))) : @separated_space.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_nndist.{0} ennreal)) (option.{0} (has_add.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_60824 (h0 : not (filter (semi_normed_comm_ring linarith.ineq) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_60825 (h0 : functor.add_const (group (has_add name)) Type) : @group.fg.{0} (has_add.{0} name) (@functor.add_const.run.{0 1} (group.{0} (has_add.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_60826 (h0 : group (ordered_comm_ring (has_add linarith.comp))) : normalizer_condition (ordered_comm_ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_60827 (h0 : topological_space (has_pos_part (has_add Type))) : sequential_space (has_pos_part (has_add Type)) := sorry --non-trivial
lemma new_lemma_60828 (h0 : topological_space (add_comm_semigroup (add_comm_semigroup ereal))) (h1 : set (add_comm_semigroup (add_comm_semigroup ereal))) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_60829 (h0 : complete_lattice (div_inv_monoid (has_nnnorm linarith.comp_source))) : is_compactly_generated (div_inv_monoid (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_60830 (h0 : list (monoid_with_zero (option unsigned))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_60831 (h3 : ring (distrib linarith.comp_source)) : is_domain (distrib linarith.comp_source) := sorry --non-trivial
lemma new_lemma_60832 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (complete_distrib_lattice.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_60833 (h0 : ordered_comm_monoid (add_comm_monoid (has_neg_part (boolean_algebra (cancel_monoid Type))))) : has_exists_mul_of_le (add_comm_monoid (has_neg_part (boolean_algebra (cancel_monoid Type)))) := sorry --non-trivial
lemma new_lemma_60834 (h0 : topological_space (group_with_zero ennreal)) : topological_space.separable_space (group_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_60835 (h0 : ring (has_div to_additive.value_type)) : strong_rank_condition (has_div to_additive.value_type) := sorry --non-trivial
lemma new_lemma_60836 (h0 : eq (complete_lattice (semi_normed_comm_ring linarith.comp_source)) enat) (h1 : enat) : @complete_lattice.is_Sup_finite_compact.{0} (semi_normed_comm_ring.{0} linarith.comp_source) (@eq.mpr.{1} (complete_lattice.{0} (semi_normed_comm_ring.{0} linarith.comp_source)) enat h0 h1)  := sorry --non-trivial
lemma new_lemma_60837 (h0 : add_monoid (plift num)) : add_monoid.fg (plift num) := sorry --non-trivial
lemma new_lemma_60838 (h0 : functor.add_const Prop (complete_distrib_lattice (ring linarith.comp))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_60839 (h0 : group (linear_ordered_add_comm_group (random_gen (random_gen fun_info)))) : group.fg (linear_ordered_add_comm_group (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_60840 (h0 : group (linear_ordered_add_comm_group (has_top (random_gen linarith.ineq)))) : is_cyclic (linear_ordered_add_comm_group (has_top (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_60841 (h0 : add_monoid (add_cancel_monoid empty)) : add_monoid.fg (add_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_60842 (h0 : topological_space (id (option congr_arg_kind))) : locally_compact_space (id (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_60843 (h0 : topological_space (comm_group (finset environment.implicit_infer_kind))) : totally_separated_space (comm_group (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_60844 (h0 : complete_lattice (semi_normed_ring (mul_one_class string.iterator_imp))) : is_compactly_generated (semi_normed_ring (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_60845 (h0 : semiring (add_comm_semigroup std_gen)) (h1 : add_comm_semigroup std_gen) : even h1 := sorry --non-trivial
lemma new_lemma_60846 (h0 : add_group (has_add (has_nnnorm linarith.comp_source))) : is_add_cyclic (has_add (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_60847 (h0 : topological_space (add_comm_monoid (has_neg_part pos))) : normal_space (add_comm_monoid (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_60848 (h0 : ring (add_cancel_monoid (has_neg (has_Inf pos)))) : strong_rank_condition (add_cancel_monoid (has_neg (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_60849 (h0 : topological_space (has_pos_part (has_pos_part (ring (has_neg linarith.comp))))) : loc_path_connected_space (has_pos_part (has_pos_part (ring (has_neg linarith.comp)))) := sorry --non-trivial
lemma new_lemma_60850 (h0 : topological_space (normed_group (semiring (semiring congr_arg_kind)))) : preirreducible_space (normed_group (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_60851 (h3 : uniform_space (with_one num)) : complete_space (with_one num) := sorry --non-trivial
lemma new_lemma_60852 (h0 : topological_space (normed_field (has_nnnorm reducibility_hints))) : path_connected_space (normed_field (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_60853 (h0 : ring (normed_group (semiring empty))) : rank_condition (normed_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_60854 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_60855 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_60856 (h0 : functor.add_const (functor.add_const Prop name) name) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_60857 (h0 : ring (with_bot (random_gen linarith.comp))) : strong_rank_condition (with_bot (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_60858 (h4 : ring (distrib to_additive.value_type)) : strong_rank_condition (distrib to_additive.value_type) := sorry --non-trivial
lemma new_lemma_60859 (h0 : functor.add_const (group (complete_distrib_lattice linarith.comp)) pos) : @is_cyclic.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_60860 (h0 : topological_space (has_lt (semi_normed_ring linarith.comp_source))) : t0_space (has_lt (semi_normed_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_60861 (h1 : uniform_space (random_gen (random_gen string_imp))) : complete_space (random_gen (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_60862 (h0 : functor.add_const (topological_space (boolean_algebra real)) pos) : @topological_space.separable_space.{0} (boolean_algebra.{0} real) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} real)) pos h0)  := sorry --non-trivial
lemma new_lemma_60863 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_60864 (h0 : topological_space (boolean_algebra (boolean_algebra.core environment.implicit_infer_kind))) : irreducible_space (boolean_algebra (boolean_algebra.core environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_60865 (h0 : topological_space (left_cancel_semigroup num)) : path_connected_space (left_cancel_semigroup num) := sorry --non-trivial
lemma new_lemma_60866 (h0 : function.extfun Type (functor.add_const (complete_lattice auto.case_option))) : @is_compactly_generated.{0} auto.case_option (@functor.add_const.run.{0 0} (complete_lattice.{0} auto.case_option) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} auto.case_option)) h0 empty))  := sorry --non-trivial
lemma new_lemma_60867 (h0 : functor.add_const (complete_lattice (has_zero Type)) (finset (has_neg_part linarith.comp))) : @is_compactly_generated.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_zero.{1} Type)) (finset.{0} (has_neg_part.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_60868 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (monoid.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_60869 (h0 : finset (distrib_lattice (option (option (option (option (option empty))))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_60870 (h0 : set (linarith.ineq -> mul_one_class (add_comm_semigroup enat))) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_60871 (h0 : functor.add_const Prop (has_neg (finset environment.implicit_infer_kind))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_60872 (h0 : topological_space (ordered_comm_monoid (has_neg (has_neg pos)))) : regular_space (ordered_comm_monoid (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_60873 (h0 : ordered_comm_monoid (sub_neg_monoid (has_add (has_add (ring linarith.comp))))) : has_exists_mul_of_le (sub_neg_monoid (has_add (has_add (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_60874 (h0 : topological_space (complete_distrib_lattice empty)) : t0_space (complete_distrib_lattice empty) := sorry --non-trivial
lemma new_lemma_60875 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (comm_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_60876 (h0 : topological_space (has_top (has_top (random_gen linarith.comp_source)))) : totally_disconnected_space (has_top (has_top (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_60877 (h0 : not (has_mem.mem num has_emptyc.emptyc -> false)) : @is_atomistic.{0} num (@finset.pi.empty.{1 0} Type complete_lattice.{0} num (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_60878 (h0 : topological_space (sub_neg_monoid (finset pos))) : preirreducible_space (sub_neg_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_60879 (h0 : add_group (filter empty)) : is_add_cyclic (filter empty) := sorry --non-trivial
lemma new_lemma_60880 (h0 : cancel_comm_monoid_with_zero (boolean_algebra.core name)) : unique_factorization_monoid (boolean_algebra.core name) := sorry --non-trivial
lemma new_lemma_60881 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_60882 (h0 : functor.add_const (add_group (option num)) unsigned) : @is_add_cyclic.{0} (option.{0} num) (@functor.add_const.run.{0 0} (add_group.{0} (option.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_60883 (h0 : complete_lattice (has_pos_part (ordered_comm_monoid (ordered_comm_monoid (has_Inf pos))))) : is_atomistic (has_pos_part (ordered_comm_monoid (ordered_comm_monoid (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_60884 (h0 : cancel_comm_monoid_with_zero (has_to_string (normed_ring (ring (option unsigned))))) : unique_factorization_monoid (has_to_string (normed_ring (ring (option unsigned)))) := sorry --non-trivial
lemma new_lemma_60885 (h0 : functor.comp monoid has_to_string Type) : @monoid.fg.{1} (has_to_string.{1} Type) (@functor.comp.run.{1 1 1} monoid.{1} has_to_string.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_60886 (h0 : functor.add_const Prop (measurable_space.dynkin_system (semiring (has_top (has_one (has_union linarith.comp)))))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_60887 (h0 : group (comm_ring (random_gen to_additive.value_type))) : group.fg (comm_ring (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_60888 (h0 : functor.add_const (ring (has_pos_part linarith.comp)) real) : @rank_condition.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_pos_part.{0} linarith.comp)) real h0)  := sorry --non-trivial
lemma new_lemma_60889 (h0 : complete_lattice (linear_ordered_semiring (random_gen num))) : is_atomistic (linear_ordered_semiring (random_gen num)) := sorry --non-trivial
lemma new_lemma_60890 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (fintype.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (fintype.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_60891 (h0 : ordered_add_comm_monoid (has_add (ring pos))) : archimedean (has_add (ring pos)) := sorry --non-trivial
lemma new_lemma_60892 (h0 : topological_space (generalized_boolean_algebra (has_neg Type))) : path_connected_space (generalized_boolean_algebra (has_neg Type)) := sorry --non-trivial
lemma new_lemma_60893 (h0 : ring (mul_zero_class (comm_group (has_neg_part (has_neg_part Type))))) : is_domain (mul_zero_class (comm_group (has_neg_part (has_neg_part Type)))) := sorry --non-trivial
lemma new_lemma_60894 (h0 : function.extfun ((Type 1 -> Type 1) -> Type 2) (function.extfun (Type 1 -> Type 1))) : @irreducible_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) (@function.extfun_app.{4 3} ((Type 1 → Type 1) → Type 2) (function.extfun.{3 3} (Type 1 → Type 1)) h0 (function.extfun.{3 2} (Type 1))) topological_space.{1}) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_60895 (h0 : topological_space (boolean_algebra.core (comm_group name))) : normal_space (boolean_algebra.core (comm_group name)) := sorry --non-trivial
lemma new_lemma_60896 (h0 : ring (normed_field (semi_normed_ring reducibility_hints))) : is_domain (normed_field (semi_normed_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_60897 (h0 : ring (monoid unsigned)) : rank_condition (monoid unsigned) := sorry --non-trivial
lemma new_lemma_60898 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) linarith.comp) : @preconnected_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_60899 (h1 : group (with_bot fun_info)) : normalizer_condition (with_bot fun_info) := sorry --non-trivial
lemma new_lemma_60900 (h0 : add_group (has_top (has_inv linarith.comp_source))) : is_add_cyclic (has_top (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_60901 (h0 : functor.add_const (ordered_comm_monoid (boolean_algebra Type)) name) : @has_exists_mul_of_le.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (boolean_algebra.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_60902 (h0 : not (group (metric_space congr_arg_kind) -> false)) : @group.fg.{0} (metric_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (metric_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_60903 (h1 : ring (complete_semilattice_Sup (linear_ordered_semiring (has_norm fun_info)))) : rank_condition (complete_semilattice_Sup (linear_ordered_semiring (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_60904 (h0 : complete_lattice ordering) : is_compactly_generated ordering := sorry --non-trivial
lemma new_lemma_60905 (h0 : not (topological_space (add_right_cancel_monoid unsigned) -> false)) : @t0_space.{0} (add_right_cancel_monoid.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (add_right_cancel_monoid.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_60906 (h0 : has_lt (nondiscrete_normed_field (mul_one_class enat))) : no_max_order (nondiscrete_normed_field (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_60907 (h0 : measurable_space (has_norm (has_top (has_top linarith.ineq)))) (h1 : measure_theory.measure (has_norm (has_top (has_top linarith.ineq)))) : measure_theory.measure.is_complete h1 := sorry --non-trivial
lemma new_lemma_60908 (h0 : topological_space (free_add_monoid num)) : topological_space.separable_space (free_add_monoid num) := sorry --non-trivial
lemma new_lemma_60909 (h0 : topological_space (boolean_algebra (has_neg (has_Inf name)))) : locally_compact_space (boolean_algebra (has_neg (has_Inf name))) := sorry --non-trivial
lemma new_lemma_60910 (h0 : finset (normed_comm_ring name)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_60911 (h0 : group (cancel_monoid (boolean_algebra.core Type))) : normalizer_condition (cancel_monoid (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_60912 (h0 : ring (linear_ordered_semiring (has_norm linarith.ineq))) : strong_rank_condition (linear_ordered_semiring (has_norm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_60913 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (normed_lattice_add_comm_group.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_60914 (h0 : topological_space (add_comm_monoid (has_neg_part (semigroup Type)))) : loc_path_connected_space (add_comm_monoid (has_neg_part (semigroup Type))) := sorry --non-trivial
lemma new_lemma_60915 (h0 : functor.add_const (complete_lattice (finset pos)) linarith.comp) : @is_compactly_generated.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_60916 (h0 : topological_space (ordered_comm_ring (ring Type))) : locally_compact_space (ordered_comm_ring (ring Type)) := sorry --non-trivial
lemma new_lemma_60917 (h0 : functor.add_const (ring (complete_distrib_lattice unsigned)) linarith.comp) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (complete_distrib_lattice.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_60918 (h0 : monoid (normed_comm_ring (has_add (add_comm_monoid unsigned)))) : monoid.fg (normed_comm_ring (has_add (add_comm_monoid unsigned))) := sorry --non-trivial
lemma new_lemma_60919 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (normed_group string_imp)) := sorry --non-trivial
lemma new_lemma_60920 (h0 : functor.comp topological_space finset (has_add unsigned)) : @normal_space.{0} (finset.{0} (has_add.{0} unsigned)) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} (has_add.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_60921 (h0 : functor.add_const (group (preorder empty)) empty) : @is_cyclic.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (preorder.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_60922 (h0 : complete_lattice (measurable_space empty)) : is_atomistic (measurable_space empty) := sorry --non-trivial
lemma new_lemma_60923 (h1 : topological_space (has_emptyc congr_arg_kind)) : discrete_topology (has_emptyc congr_arg_kind) := sorry --non-trivial
lemma new_lemma_60924 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem add_group)) : @is_add_cyclic.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_60925 (h0 : function.extfun Type topological_space) : @t1_space.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_60926 (h0 : topological_space (boolean_algebra (has_pos_part linarith.comp))) : topological_space.separable_space (boolean_algebra (has_pos_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_60927 (h0 : topological_space (has_neg_part (ring (option (comm_group (comm_group unsigned)))))) : totally_disconnected_space (has_neg_part (ring (option (comm_group (comm_group unsigned))))) := sorry --non-trivial
lemma new_lemma_60928 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type monoid.{0} h0 (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_60929 (h0 : ring (plift num)) : is_domain (plift num) := sorry --non-trivial
lemma new_lemma_60930 (h0 : group (linear_ordered_add_comm_group (has_norm (has_norm (has_inv to_additive.value_type))))) : group.fg (linear_ordered_add_comm_group (has_norm (has_norm (has_inv to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_60931 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (add_comm_monoid.{0} (option.{0} empty)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} (option.{0} empty)))  := sorry --non-trivial
lemma new_lemma_60932 (h0 : functor.add_const (topological_space (add_comm_monoid pos)) (finset linarith.comp)) : @regular_space.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} pos)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_60933 (h0 : ring (has_to_string (has_pos_part (has_add pos)))) : is_domain (has_to_string (has_pos_part (has_add pos))) := sorry --non-trivial
lemma new_lemma_60934 (h0 : functor.add_const (filter (mul_zero_class congr_arg_kind)) unsigned) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_60935 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_60936 (h1 : uniform_space (normed_group char)) : complete_space (normed_group char) := sorry --non-trivial
lemma new_lemma_60937 (h0 : topological_space (has_le (add_comm_semigroup ereal))) : path_connected_space (has_le (add_comm_semigroup ereal)) := sorry --non-trivial
lemma new_lemma_60938 (h0 : uniform_space (cancel_monoid unsigned)) : separated_space (cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_60939 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_60940 (h0 : ring (has_Inf (has_add real))) : strong_rank_condition (has_Inf (has_add real)) := sorry --non-trivial
lemma new_lemma_60941 (h0 : ring (normed_comm_ring congr_arg_kind)) : rank_condition (normed_comm_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_60942 (h0 : filter (complete_distrib_lattice empty)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_60943 (h1 : topological_space (group (complete_semilattice_Sup (has_nnnorm linarith.comp_source)))) : totally_disconnected_space (group (complete_semilattice_Sup (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_60944 (h0 : functor.add_const (uniform_space (has_neg_part environment.implicit_infer_kind)) Type) : @separated_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (uniform_space.{0} (has_neg_part.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_60945 (h0 : uniform_space (has_pos_part (ring pos))) : separated_space (has_pos_part (ring pos)) := sorry --non-trivial
lemma new_lemma_60946 (h0 : topological_space (boolean_algebra.core (finset (finset ennreal)))) : sequential_space (boolean_algebra.core (finset (finset ennreal))) := sorry --non-trivial
lemma new_lemma_60947 (h0 h1 : multiset (add_comm_semigroup (add_comm_semigroup enat))) : multiset.le h0 h1 := sorry --non-trivial
lemma new_lemma_60948 (h0 : ordered_add_comm_monoid (option (mul_zero_class unsigned))) : archimedean (option (mul_zero_class unsigned)) := sorry --non-trivial
lemma new_lemma_60949 (h2 : ring (denumerable char)) : strong_rank_condition (denumerable char) := sorry --non-trivial
lemma new_lemma_60950 (h0 : topological_space (random_gen (semiring linarith.comp))) : totally_disconnected_space (random_gen (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_60951 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_to_string name)) linarith.comp) : @unique_factorization_monoid.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_to_string.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_60952 (h0 : fin has_zero.zero) : @archimedean.{0} (canonically_linear_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) (@function.extfun_app.{1 1} nat fin (@matrix.vec_empty.{0} (function.extfun.{1 1} nat fin) h0) (@has_zero.zero.{0} nat nat.has_zero))) (canonically_linear_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_60953 (h0 : functor.add_const (function.extfun Type ring) linarith.comp) : @strong_rank_condition.{0} (has_Inf.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) linarith.comp h0) (has_Inf.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_60954 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_60955 (h1 : topological_space (has_top string_imp)) : totally_disconnected_space (has_top string_imp) := sorry --non-trivial
lemma new_lemma_60956 (h0 : topological_space (mul_one_class string.iterator_imp)) : t0_space (mul_one_class string.iterator_imp) := sorry --non-trivial
lemma new_lemma_60957 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_norm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_60958 (h0 : monoid (add_right_cancel_monoid (has_norm empty))) : monoid.fg (add_right_cancel_monoid (has_norm empty)) := sorry --non-trivial
lemma new_lemma_60959 (h0 : functor.add_const (list (free_add_monoid empty)) (option (option (option empty)))) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_60960 (h0 : semiring (ordered_comm_ring Type)) : is_noetherian_ring (ordered_comm_ring Type) := sorry --non-trivial
lemma new_lemma_60961 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) (has_neg name)) : @has_exists_mul_of_le.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) (has_neg.{0} name) h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_60962 (h0 : list (has_star (semiring (semiring empty)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_60963 (h0 : not (complete_lattice (has_one congr_arg_kind) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_one.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_one.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_60964 (h0 : topological_space (comm_monoid empty)) : discrete_topology (comm_monoid empty) := sorry --non-trivial
lemma new_lemma_60965 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_60966 (h1 : ring (has_append fun_info)) : strong_rank_condition (has_append fun_info) := sorry --non-trivial
lemma new_lemma_60967 (h0 : topological_space (has_ssubset (has_nnnorm linarith.comp_source))) : totally_disconnected_space (has_ssubset (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_60968 (h3 : topological_space char) (h4 : set (set char)) : topological_space.is_topological_basis h4 := sorry --non-trivial
lemma new_lemma_60969 (h0 : function.extfun (Type 1) (prod (canonically_ordered_comm_semiring Type))) : id_rel (function.extfun_app h0 (canonically_ordered_comm_semiring Type)) := sorry --non-trivial
lemma new_lemma_60970 (h0 : group (boolean_algebra.core (has_Inf pos))) : is_simple_group (boolean_algebra.core (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_60971 (h0 : functor.add_const (ordered_add_comm_monoid (finset Type)) (has_neg pos)) : @archimedean.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (ordered_add_comm_monoid.{1} (finset.{1} Type)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_60972 (h0 : topological_space (has_zero (option num))) : preirreducible_space (has_zero (option num)) := sorry --non-trivial
lemma new_lemma_60973 (h1 : topological_space (has_emptyc linarith.comp_source)) : irreducible_space (has_emptyc linarith.comp_source) := sorry --non-trivial
lemma new_lemma_60974 (h0 : functor.add_const (topological_space (semigroup pos)) name) : @path_connected_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_60975 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) environment.implicit_infer_kind) : @totally_separated_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_60976 (h0 : topological_space (cancel_monoid pos)) : totally_separated_space (cancel_monoid pos) := sorry --non-trivial
lemma new_lemma_60977 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (normed_lattice_add_comm_group.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (normed_lattice_add_comm_group.{0} name))  := sorry --non-trivial
lemma new_lemma_60978 (h0 : ring (ordered_ring congr_arg_kind)) : is_domain (ordered_ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_60979 (h0 : not (ring (random_gen string.iterator_imp) -> false)) : @strong_rank_condition.{0} (random_gen.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_60980 (h0 : functor.add_const (topological_space (boolean_algebra real)) (has_Inf (has_add Type))) : @locally_compact_space.{0} (boolean_algebra.{0} real) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} real)) (has_Inf.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_60981 (h0 : functor.add_const (topological_space (boolean_algebra.core ennreal)) Type) : @regular_space.{0} (boolean_algebra.core.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_60982 (h0 : topological_space (boolean_algebra.core (has_add pos))) : topological_space.separable_space (boolean_algebra.core (has_add pos)) := sorry --non-trivial
lemma new_lemma_60983 (h0 : group (has_norm (has_inv to_additive.value_type))) : group.fg (has_norm (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_60984 (h0 : list (semigroup (ring (comm_group (has_to_string Type))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_60985 (h0 : functor.add_const (function.extfun Type list) pos) : palindrome (function.extfun_app (functor.add_const.run h0) (finset pos)) := sorry --non-trivial
lemma new_lemma_60986 (h0 : topological_space (encodable linarith.ineq) -> Prop) : @irreducible_space.{0} (encodable.{0} linarith.ineq) (@classical.epsilon.{1} (topological_space.{0} (encodable.{0} linarith.ineq)) (@nonempty_of_inhabited.{1} (topological_space.{0} (encodable.{0} linarith.ineq)) (@inhabited_topological_space.{0} (encodable.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_60987 (h0 : functor.add_const (topological_space (has_dist empty)) num) : @totally_disconnected_space.{0} (has_dist.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_dist.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_60988 (h0 : functor.add_const (add_monoid (normed_linear_ordered_group empty)) (semiring (semiring empty))) : @add_monoid.fg.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (add_monoid.{0} (normed_linear_ordered_group.{0} empty)) (semiring.{0} (semiring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_60989 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @is_atomistic.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_60990 (h0 : functor.add_const (ring (semiring empty)) empty) : @is_principal_ideal_ring.{0} (semiring.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (semiring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_60991 (h0 : not (add_group (simple_graph string.iterator_imp) -> false)) : @is_add_cyclic.{0} (simple_graph.{0} string.iterator_imp) (@classical.by_contradiction'.{1} (add_group.{0} (simple_graph.{0} string.iterator_imp)) h0)  := sorry --non-trivial
lemma new_lemma_60992 (h0 : topological_space (ordered_comm_ring (has_Inf pos))) : regular_space (ordered_comm_ring (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_60993 (h0 : group (semi_normed_comm_ring string_imp)) : group.fg (semi_normed_comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_60994 (h0 : complete_lattice (monoid_with_zero ennreal)) : is_atomistic (monoid_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_60995 (h0 : complete_lattice (semi_normed_comm_ring (random_gen to_additive.value_type))) : is_compactly_generated (semi_normed_comm_ring (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_60996 (h0 : ordered_add_comm_monoid (boolean_algebra (has_neg pos))) : archimedean (boolean_algebra (has_neg pos)) := sorry --non-trivial
lemma new_lemma_60997 (h0 : list (linear_ordered_add_comm_group (comm_ring fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_60998 (h0 : monoid (canonically_ordered_comm_semiring (has_add name))) : monoid.fg (canonically_ordered_comm_semiring (has_add name)) := sorry --non-trivial
lemma new_lemma_60999 (h0 : functor.add_const (filter (mul_zero_class environment.implicit_infer_kind)) pos) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_61000 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (preorder.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (preorder.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_61001 (h0 : topological_space (has_top (random_gen to_additive.value_type))) : path_connected_space (has_top (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_61002 (h0 : uniform_space (semiring (has_norm num))) : complete_space (semiring (has_norm num)) := sorry --non-trivial
lemma new_lemma_61003 (h0 : topological_space (distrib_lattice (random_gen to_additive.value_type))) : t0_space (distrib_lattice (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_61004 (h0 : add_monoid (add_semigroup (option unsigned))) : add_monoid.fg (add_semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_61005 (h0 : semiring (has_dist (option (option (option (option empty)))))) : is_noetherian_ring (has_dist (option (option (option (option empty))))) := sorry --non-trivial
lemma new_lemma_61006 (h0 : fin has_zero.zero) : @add_monoid.fg.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (add_monoid.{1} (ordered_comm_ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_61007 (h2 : complete_lattice (topological_space to_additive.value_type)) : is_compactly_generated (topological_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_61008 (h0 : add_group (comm_monoid (semiring unsigned))) : is_add_cyclic (comm_monoid (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_61009 (h0 : function.extfun nat fin) : @monoid.fg.{0} (canonically_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (monoid.{0} (canonically_ordered_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_61010 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_one.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_one.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_61011 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen linarith.comp))) : @complete_space.{0} (random_gen.{0} linarith.comp) (@finset.pi.empty.{1 0} Type uniform_space.{0} (random_gen.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_61012 (h0 : topological_space (linear_ordered_semiring (linear_ordered_semiring (semiring empty)))) : locally_compact_space (linear_ordered_semiring (linear_ordered_semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_61013 (h0 : functor.comp topological_space has_add pos) : @sequential_space.{0} (has_add.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_61014 (h0 : group (has_union (semiring linarith.comp))) : normalizer_condition (has_union (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_61015 (h0 : group (measurable_space (with_bot to_additive.value_type))) : group.fg (measurable_space (with_bot to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_61016 (h0 : complete_lattice (has_inv char)) : complete_lattice.is_Sup_finite_compact (has_inv char) := sorry --non-trivial
lemma new_lemma_61017 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) Type) : @loc_path_connected_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (add_cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_61018 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_61019 (h0 : functor.add_const (filter (semigroup pos)) unsigned) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_61020 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_bot.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_61021 (h0 : not (has_mem.mem Type has_emptyc.emptyc -> false)) : @separated_space.{1} Type (@finset.pi.empty.{2 1} (Type 1) uniform_space.{1} Type (@classical.by_contradiction'.{0} (@has_mem.mem.{2 2} (Type 1) (finset.{2} (Type 1)) (@finset.has_mem.{2} (Type 1)) Type (@has_emptyc.emptyc.{2} (finset.{2} (Type 1)) (@finset.has_emptyc.{2} (Type 1)))) h0))  := sorry --non-trivial
lemma new_lemma_61022 (h0 : topological_space (measurable_space (random_gen linarith.comp_source))) : locally_compact_space (measurable_space (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_61023 (h0 : ring (add_semigroup congr_arg_kind)) : strong_rank_condition (add_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_61024 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_61025 (h0 : fin has_zero.zero) : topological_space.separable_space real := sorry --non-trivial
lemma new_lemma_61026 (h0 : functor.add_const (topological_space pos) (option unsigned)) : @totally_disconnected_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) (option.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_61027 (h0 : not (add_group (distrib_lattice fun_info) -> false)) : @is_add_cyclic.{0} (distrib_lattice.{0} fun_info) (@classical.by_contradiction'.{1} (add_group.{0} (distrib_lattice.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_61028 (h0 : functor.add_const (group (boolean_algebra environment.implicit_infer_kind)) linarith.comp) : @is_simple_group.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_61029 (h0 : functor.add_const (ring (semigroup name)) environment.implicit_infer_kind) : @rank_condition.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_61030 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @archimedean.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (ordered_add_comm_monoid.{1} (has_pos_part.{1} Type)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_61031 (h0 : add_monoid (comm_semigroup linarith.comp)) : add_monoid.fg (comm_semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_61032 (h0 : fin has_zero.zero) : @complete_space.{0} (has_pos_part.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (has_pos_part.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_61033 (h0 : uniform_space (normed_field (mul_one_class string_imp))) : complete_space (normed_field (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_61034 (h0 : add_group (normed_group (semiring (semiring (semiring num))))) : is_add_cyclic (normed_group (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_61035 (h1 : uniform_space (dlist (has_ssubset string_imp))) : complete_space (dlist (has_ssubset string_imp)) := sorry --non-trivial
lemma new_lemma_61036 (h0 : topological_space (has_pos_part (ordered_comm_monoid real))) : totally_disconnected_space (has_pos_part (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_61037 (h0 : group (pseudo_metric_space (mul_zero_class name))) : is_simple_group (pseudo_metric_space (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_61038 (h0 : topological_space (comm_semigroup (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid real))))) : irreducible_space (comm_semigroup (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid real)))) := sorry --non-trivial
lemma new_lemma_61039 (h0 : fin has_zero.zero) : @is_simple_group.{0} (finset.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (finset.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_61040 (h0 : topological_space (as_linear_order (option empty))) : locally_compact_space (as_linear_order (option empty)) := sorry --non-trivial
lemma new_lemma_61041 (h0 : functor.add_const (topological_space (has_to_string pos)) Type) : @sequential_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_61042 (h0 : not (list (linear_ordered_comm_ring unsigned) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_61043 (h0 : functor.add_const (function.extfun Type topological_space) name) : @irreducible_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_61044 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_domain.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) ring.{0}) (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_61045 (h0 : topological_space (complete_distrib_lattice (option (bin_tree unsigned)))) : path_connected_space (complete_distrib_lattice (option (bin_tree unsigned))) := sorry --non-trivial
lemma new_lemma_61046 (h1 : uniform_space (measurable_space (has_top congr_arg_kind))) : complete_space (measurable_space (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_61047 (h0 : functor.add_const (ring (has_add linarith.comp)) Type) : @strong_rank_condition.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (has_add.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_61048 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (preorder.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (preorder.{0} num))  := sorry --non-trivial
lemma new_lemma_61049 (h4 : set (linarith.ineq -> std_gen)) : set.separates_points h4 := sorry --non-trivial
lemma new_lemma_61050 (h0 : list (has_top (has_norm fun_info))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_61051 (h0 : functor.comp topological_space cancel_monoid environment.implicit_infer_kind) : @normal_space.{0} (cancel_monoid.{0} environment.implicit_infer_kind) (@functor.comp.run.{0 0 0} topological_space.{0} cancel_monoid.{0} environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_61052 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_61053 (h0 : not (function.extfun Type complete_lattice -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_add.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type complete_lattice.{0}) h0) (has_add.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_61054 (h0 : function.extfun Type ring) : @is_domain.{0} (normed_group.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h0 (normed_group.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_61055 (h0 : function.extfun (finset Type) (has_mem.mem (semiring empty))) : @is_add_cyclic.{0} (semiring.{0} empty) (@finset.pi.empty.{1 0} Type add_group.{0} (semiring.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_61056 (h0 : add_group (has_inter empty)) : is_add_cyclic (has_inter empty) := sorry --non-trivial
lemma new_lemma_61057 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_61058 (h0 : ring (normed_lattice_add_comm_group (canonically_linear_ordered_monoid Type))) : is_domain (normed_lattice_add_comm_group (canonically_linear_ordered_monoid Type)) := sorry --non-trivial
lemma new_lemma_61059 (h1 : ring (id (random_gen to_additive.value_type))) : is_domain (id (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_61060 (h0 : group (semiring (has_top (has_union (semiring (semiring linarith.comp)))))) : is_cyclic (semiring (has_top (has_union (semiring (semiring linarith.comp))))) := sorry --non-trivial
lemma new_lemma_61061 (h0 : topological_space (sub_neg_monoid (finset (has_add linarith.comp)))) : regular_space (sub_neg_monoid (finset (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_61062 (h0 : semiring (normed_group congr_arg_kind)) : is_noetherian_ring (normed_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_61063 (h0 : linear_ordered_field (option empty)) (h1 : function.extfun (option empty -> option empty) (cau_seq (option empty))) : cau_seq.pos (function.extfun_app h1 has_abs.abs) := sorry --non-trivial
lemma new_lemma_61064 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_nndist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_nndist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_61065 (h2 : group num) : normalizer_condition num := sorry --non-trivial
lemma new_lemma_61066 (h0 : group (has_add (has_neg_part linarith.comp))) : is_simple_group (has_add (has_neg_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_61067 (h0 : char -> char -> Prop) (h1 : list char) : list.chain' h0 h1 := sorry --non-trivial
lemma new_lemma_61068 (h0 : functor.add_const (topological_space (has_nndist Type)) pos) : @t0_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_61069 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @preirreducible_space.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_61070 (h0 : function.extfun Type topological_space) : @t0_space.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_61071 (h0 : uniform_space (has_star (semiring (semiring num)))) : separated_space (has_star (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_61072 (h0 : functor.add_const (ordered_add_comm_monoid (has_nndist Type)) Type) : @archimedean.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 1} (ordered_add_comm_monoid.{1} (has_nndist.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_61073 (h0 : function.extfun Type group) : @normalizer_condition.{0} (add_left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (add_left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_61074 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_61075 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) pos) : @regular_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_61076 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (add_cancel_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_cancel_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_61077 (h0 : ring (ordered_comm_ring (has_neg Type))) : rank_condition (ordered_comm_ring (has_neg Type)) := sorry --non-trivial
lemma new_lemma_61078 (h0 : topological_space (mul_zero_class (finset Type))) : t0_space (mul_zero_class (finset Type)) := sorry --non-trivial
lemma new_lemma_61079 (h0 : functor.add_const (topological_space (has_to_string unsigned)) (comm_group Type)) : @topological_space.separable_space.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} unsigned)) (comm_group.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_61080 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (add_cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_61081 (h0 : topological_space (sub_neg_monoid (has_Inf (has_add (has_Inf (has_add pos)))))) : irreducible_space (sub_neg_monoid (has_Inf (has_add (has_Inf (has_add pos))))) := sorry --non-trivial
lemma new_lemma_61082 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (canonically_linear_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (canonically_linear_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_61083 (h0 : ordered_add_comm_monoid (semigroup (has_pos_part pos))) : archimedean (semigroup (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_61084 (h0 : group (with_one (semiring (semiring congr_arg_kind)))) : normalizer_condition (with_one (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_61085 (h0 : functor.add_const (topological_space (normed_comm_ring name)) pos) : @preirreducible_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_61086 (h0 : group (has_norm (has_inv (has_inv linarith.comp_source)))) : is_cyclic (has_norm (has_inv (has_inv linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_61087 (h0 : group (ordered_comm_monoid empty)) : is_cyclic (ordered_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_61088 (h0 : functor.add_const (complete_lattice (has_to_string pos)) pos) : @is_compactly_generated.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_61089 (h0 : topological_space (add_left_cancel_semigroup congr_arg_kind)) : normal_space (add_left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_61090 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (canonically_linear_ordered_monoid.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_linear_ordered_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_61091 (h0 : ring (semigroup (option (option pos)))) : strong_rank_condition (semigroup (option (option pos))) := sorry --non-trivial
lemma new_lemma_61092 (h0 : functor.add_const (function.extfun Type topological_space) name) : @path_connected_space.{0} (has_zero.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_zero.{0} name))  := sorry --non-trivial
lemma new_lemma_61093 (h0 : topological_space (has_inner pos (option pos))) : normal_space (has_inner pos (option pos)) := sorry --non-trivial
lemma new_lemma_61094 (h0 : topological_space (has_top congr_arg_kind)) : preirreducible_space (has_top congr_arg_kind) := sorry --non-trivial
lemma new_lemma_61095 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (add_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_61096 (h0 : topological_space linarith.comp) : discrete_topology linarith.comp := sorry --non-trivial
lemma new_lemma_61097 (h0 : functor.add_const (topological_space (linear_order empty)) empty) : @normal_space.{0} (linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_order.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_61098 (h0 : filter (has_norm (random_gen (random_gen fun_info)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_61099 (h1 : functor.comp topological_space part nat) : @totally_disconnected_space.{0} enat (@functor.comp.run.{0 0 0} topological_space.{0} part.{0} nat h1)  := sorry --non-trivial
lemma new_lemma_61100 (h0 : group (has_neg unsigned)) : group.fg (has_neg unsigned) := sorry --non-trivial
lemma new_lemma_61101 (h0 : functor.add_const (ring (left_cancel_monoid unsigned)) empty) : @rank_condition.{0} (left_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_61102 (h0 : cancel_comm_monoid_with_zero (has_one congr_arg_kind)) : unique_factorization_monoid (has_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_61103 (h0 : functor.add_const (group (plift num)) unsigned) : @normalizer_condition.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (group.{1} (plift.{1} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_61104 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_61105 (h0 : topological_space (has_inner (option empty) empty)) : t0_space (has_inner (option empty) empty) := sorry --non-trivial
lemma new_lemma_61106 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} znum (@function.extfun_app.{2 1} Type ring.{0} h0 znum)  := sorry --non-trivial
lemma new_lemma_61107 (h0 : functor.add_const (ring (preorder unsigned)) unsigned) : @is_domain.{0} (preorder.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (preorder.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_61108 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (encodable.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (encodable.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_61109 (h0 : add_group (ordered_cancel_add_comm_monoid (option unsigned))) : is_add_cyclic (ordered_cancel_add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_61110 (h0 : functor.add_const (topological_space (generalized_boolean_algebra name)) name) : @path_connected_space.{0} (generalized_boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_61111 (h0 : topological_space (complete_semilattice_Sup (has_top linarith.comp_source))) : totally_disconnected_space (complete_semilattice_Sup (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_61112 (h0 : functor.add_const (topological_space (add_group num)) (semiring empty)) : @preirreducible_space.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (add_group.{0} num)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_61113 (h0 : add_group (has_norm (has_norm (random_gen to_additive.value_type)))) : is_add_cyclic (has_norm (has_norm (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_61114 (h0 : topological_space (ordered_cancel_add_comm_monoid (option pos))) : topological_space.separable_space (ordered_cancel_add_comm_monoid (option pos)) := sorry --non-trivial
lemma new_lemma_61115 (h0 : functor.add_const (ordered_comm_monoid (has_pos_part Type)) Type) : @has_exists_mul_of_le.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 1} (ordered_comm_monoid.{1} (has_pos_part.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_61116 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (add_group.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (add_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_61117 (h0 : has_mem.mem (metric_space unsigned) has_emptyc.emptyc) : @is_domain.{0} (metric_space.{0} unsigned) (@finset.pi.empty.{1 0} Type ring.{0} (metric_space.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_61118 (h0 : not (function.extfun Type monoid -> false)) : @monoid.fg.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type monoid.{0}) h0) (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_61119 (h0 : functor.add_const (topological_space (canonically_linear_ordered_monoid ennreal)) (option (option ennreal))) : @preconnected_space.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} ennreal)) (option.{0} (option.{0} ennreal)) h0)  := sorry --non-trivial
lemma new_lemma_61120 (h0 : ring (normed_comm_ring (has_neg (ring (ring linarith.comp))))) : rank_condition (normed_comm_ring (has_neg (ring (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_61121 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_61122 (h0 : functor.comp topological_space boolean_algebra.core name) : @locally_compact_space.{0} (boolean_algebra.core.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.core.{0} name h0)  := sorry --non-trivial
lemma new_lemma_61123 (h0 : functor.add_const (ring (semigroup linarith.comp)) (ring Type)) : @strong_rank_condition.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (semigroup.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_61124 (h0 : has_mem.mem unsigned has_zero.zero) : @group.fg.{0} (has_add.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) unsigned (@multiset.pi.empty.{1 1} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type group.{0})) unsigned h0)) (has_add.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_61125 (h0 : not (topological_space (has_norm congr_arg_kind) -> false)) : @totally_separated_space.{0} (has_norm.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_61126 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_neg unsigned)) pos) : @unique_factorization_monoid.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_neg.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_61127 (h0 : not (topological_space (with_one linarith.comp_source) -> false)) : @locally_compact_space.{0} (with_one.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (with_one.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_61128 (h0 : group (linear_ordered_add_comm_group (random_gen (random_gen (random_gen char))))) : group.fg (linear_ordered_add_comm_group (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_61129 (h0 : topological_space (has_neg environment.implicit_infer_kind)) : preirreducible_space (has_neg environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_61130 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (complete_distrib_lattice.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_61131 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_61132 (h0 : group (finset (finset Type))) : is_simple_group (finset (finset Type)) := sorry --non-trivial
lemma new_lemma_61133 (h0 : topological_space (finset (mul_one_class Type))) : normal_space (finset (mul_one_class Type)) := sorry --non-trivial
lemma new_lemma_61134 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_61135 (h0 : fin has_zero.zero) : @rank_condition.{0} (ordered_comm_ring.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (ordered_comm_ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_61136 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (semigroup.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (semigroup.{0} name))  := sorry --non-trivial
lemma new_lemma_61137 (h0 : function.extfun Type complete_lattice) : complete_lattice.is_Sup_finite_compact (measurable_space unsigned) := sorry --non-trivial
lemma new_lemma_61138 (h0 : add_group (has_union (semiring linarith.comp))) : is_add_cyclic (has_union (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_61139 (h0 : functor.add_const (topological_space (as_linear_order unsigned)) num) : @totally_separated_space.{0} (as_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (as_linear_order.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_61140 (h0 : list (has_add Type)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_61141 (h0 : complete_lattice (boolean_algebra.core num)) : is_compactly_generated (boolean_algebra.core num) := sorry --non-trivial
lemma new_lemma_61142 (h0 : topological_space (normed_lattice_add_comm_group (ordered_comm_monoid pos))) : preirreducible_space (normed_lattice_add_comm_group (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_61143 (h0 : has_mem.mem (has_emptyc congr_arg_kind) has_emptyc.emptyc) : @normalizer_condition.{0} (has_emptyc.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type group.{0} (has_emptyc.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_61144 (h0 : group (dlist (denumerable to_additive.value_type))) : is_cyclic (dlist (denumerable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_61145 (h0 : ring (encodable (ordered_comm_monoid string_imp))) : rank_condition (encodable (ordered_comm_monoid string_imp)) := sorry --non-trivial
lemma new_lemma_61146 (h0 : topological_space (has_div enat)) : totally_disconnected_space (has_div enat) := sorry --non-trivial
lemma new_lemma_61147 (h0 : topological_space (measurable_space.dynkin_system (semiring num))) : normal_space (measurable_space.dynkin_system (semiring num)) := sorry --non-trivial
lemma new_lemma_61148 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_61149 (h0 : fin has_zero.zero) : @archimedean.{0} (has_bot.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) h0) (has_bot.{0} name))  := sorry --non-trivial
lemma new_lemma_61150 (h0 : ordered_comm_monoid (normed_comm_ring (option ennreal))) : has_exists_mul_of_le (normed_comm_ring (option ennreal)) := sorry --non-trivial
lemma new_lemma_61151 (h0 : uniform_space (canonically_ordered_comm_semiring (has_neg (has_neg (has_neg pos))))) : separated_space (canonically_ordered_comm_semiring (has_neg (has_neg (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_61152 (h0 : has_mem.mem (with_bot (random_gen linarith.ineq)) has_emptyc.emptyc) : @t0_space.{0} (with_bot.{0} (random_gen.{0} linarith.ineq)) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} (random_gen.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_61153 (h0 : function.extfun Type topological_space) : @normal_space.{0} (ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_61154 (h0 : ordered_add_comm_monoid (normed_comm_ring name)) : archimedean (normed_comm_ring name) := sorry --non-trivial
lemma new_lemma_61155 (h0 : topological_space (plift (semiring (semiring unsigned)))) : locally_compact_space (plift (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_61156 (h0 : topological_space (ordered_comm_monoid (has_add Type))) : path_connected_space (ordered_comm_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_61157 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (add_comm_monoid.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (add_comm_monoid.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_61158 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (is_R_or_C.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (is_R_or_C.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_61159 (h0 : functor.add_const (finset (finset environment.implicit_infer_kind)) linarith.comp) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_61160 (h0 : finset (add_cancel_monoid (has_add Type))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_61161 (h0 : functor.add_const (filter (boolean_algebra unsigned)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_61162 (h0 : topological_space (linear_ordered_comm_group congr_arg_kind)) : locally_compact_space (linear_ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_61163 (h0 : complete_lattice (cancel_monoid (boolean_algebra (has_add pos)))) : is_atomistic (cancel_monoid (boolean_algebra (has_add pos))) := sorry --non-trivial
lemma new_lemma_61164 (h0 : add_group (has_nnnorm (mul_one_class string_imp))) : is_add_cyclic (has_nnnorm (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_61165 (h2 : complete_lattice (with_one congr_arg_kind)) : is_compactly_generated (with_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_61166 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_61167 (h0 : finset (add_comm_monoid (has_neg (finset pos)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_61168 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (with_bot.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_61169 (h0 : functor.add_const (add_monoid (boolean_algebra.core name)) linarith.comp) : @add_monoid.fg.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (add_monoid.{0} (boolean_algebra.core.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_61170 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_to_string.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_to_string.{0} pos))  := sorry --non-trivial
lemma new_lemma_61171 (h0 : function.extfun Type topological_space) : @t0_space.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_61172 (h0 : not (complete_lattice (denumerable string_imp) -> false)) : @is_compactly_generated.{0} (denumerable.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (denumerable.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_61173 (h0 : ordered_comm_monoid (canonically_linear_ordered_monoid (has_add (sub_neg_monoid Type)))) : has_exists_mul_of_le (canonically_linear_ordered_monoid (has_add (sub_neg_monoid Type))) := sorry --non-trivial
lemma new_lemma_61174 (h0 : function.extfun Type topological_space) : @normal_space.{0} (linear_ordered_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_61175 (h0 : ring name) : strong_rank_condition name := sorry --non-trivial
lemma new_lemma_61176 (h0 : topological_space (normed_group (semiring (semiring (semiring (has_top unsigned)))))) : totally_disconnected_space (normed_group (semiring (semiring (semiring (has_top unsigned))))) := sorry --non-trivial
lemma new_lemma_61177 (h0 : topological_space (semi_normed_comm_ring (has_nnnorm to_additive.value_type))) : locally_compact_space (semi_normed_comm_ring (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_61178 (h0 : topological_space (semigroup (semiring num))) : discrete_topology (semigroup (semiring num)) := sorry --non-trivial
lemma new_lemma_61179 (h0 : functor.add_const (topological_space (has_add pos)) pos) : @normal_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_61180 (h0 : has_mem.mem (semiring fun_info) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (semiring.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_61181 (h0 : topological_space (comm_group linarith.comp)) : t1_space (comm_group linarith.comp) := sorry --non-trivial
lemma new_lemma_61182 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) name) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_61183 (h0 : topological_space (has_Inf (finset (has_pos_part Type)))) : discrete_topology (has_Inf (finset (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_61184 (h0 : not (function.extfun Type ring -> false)) : @is_principal_ideal_ring.{0} (measurable_space.dynkin_system.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (measurable_space.dynkin_system.{0} empty))  := sorry --non-trivial
lemma new_lemma_61185 (h2 : ring (mul_one_class ereal)) : strong_rank_condition (mul_one_class ereal) := sorry --non-trivial
lemma new_lemma_61186 (h0 : not (topological_space (normed_group linarith.comp_source) -> false)) : @discrete_topology.{0} (normed_group.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_61187 (h0 : complete_lattice (ordered_cancel_add_comm_monoid num)) : is_atomistic (ordered_cancel_add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_61188 (h0 : function.extfun Type ring) : @rank_condition.{0} (has_inter.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_inter.{0} num))  := sorry --non-trivial
lemma new_lemma_61189 (h0 : finset (has_to_string (ring (has_nndist linarith.comp)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_61190 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_add Type)) : @regular_space.{1} (ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_add.{1} Type) h0) (ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_61191 (h0 : add_group (denumerable (has_nnnorm (has_nnnorm linarith.ineq)))) : is_add_cyclic (denumerable (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_61192 (h0 : group (has_append (mul_one_class reducibility_hints))) : is_cyclic (has_append (mul_one_class reducibility_hints)) := sorry --non-trivial
lemma new_lemma_61193 (h0 : ring (has_pos_part (has_pos_part Type))) : rank_condition (has_pos_part (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_61194 (h0 : semiring (has_to_string environment.implicit_infer_kind)) : is_noetherian_ring (has_to_string environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_61195 (h0 : topological_space (has_to_string (has_add (ring Type)))) : sequential_space (has_to_string (has_add (ring Type))) := sorry --non-trivial
lemma new_lemma_61196 (h0 : ring (partial_order (semiring empty))) : is_principal_ideal_ring (partial_order (semiring empty)) := sorry --non-trivial
lemma new_lemma_61197 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_61198 (h0 : functor.add_const (group (complete_distrib_lattice name)) linarith.comp) : @group.fg.{0} (complete_distrib_lattice.{0} name) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_61199 (h0 : not (topological_space (add_right_cancel_monoid congr_arg_kind) -> false)) : @discrete_topology.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_61200 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_ordered_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_ordered_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_61201 (h0 : topological_space (linear_ordered_comm_group (option empty))) : path_connected_space (linear_ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_61202 (h0 : functor.add_const (cancel_comm_monoid_with_zero (normed_comm_ring linarith.comp)) pos) : @unique_factorization_monoid.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (normed_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_61203 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (bin_tree.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (bin_tree.{0} empty))  := sorry --non-trivial
lemma new_lemma_61204 (h0 : complete_lattice (has_ssubset (has_lt linarith.comp_source))) : is_compactly_generated (has_ssubset (has_lt linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_61205 (h0 : functor.add_const (function.extfun (Type 1) group) linarith.comp) : @is_cyclic.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) linarith.comp h0) (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_61206 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (boolean_algebra.core.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} empty))  := sorry --non-trivial
lemma new_lemma_61207 (h0 : filter (dlist (random_gen (random_gen fun_info)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_61208 (h0 : functor.add_const (ordered_add_comm_monoid (boolean_algebra pos)) Type) : @archimedean.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_61209 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @path_connected_space.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_61210 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (add_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_61211 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_61212 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_atomistic.{1} (plift.{1} (option.{0} unsigned)) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) (plift.{1} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_61213 (h0 : topological_space (ordered_comm_group congr_arg_kind)) : totally_disconnected_space (ordered_comm_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_61214 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (normed_linear_ordered_group.{0} (semiring.{0} unsigned)) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (normed_linear_ordered_group.{0} (semiring.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_61215 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) (boolean_algebra linarith.comp)) : @regular_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) (boolean_algebra.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_61216 (h0 : functor.add_const (group (normed_comm_ring linarith.comp)) Type) : @group.fg.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (normed_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_61217 (h0 : topological_space (has_neg (has_nndist name))) : t0_space (has_neg (has_nndist name)) := sorry --non-trivial
lemma new_lemma_61218 (h0 : topological_space (add_comm_monoid (sub_neg_monoid (has_pos_part Type)))) : t1_space (add_comm_monoid (sub_neg_monoid (has_pos_part Type))) := sorry --non-trivial
lemma new_lemma_61219 (h0 : group (complete_linear_order (semiring (semiring congr_arg_kind)))) : normalizer_condition (complete_linear_order (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_61220 (h0 : functor.add_const (add_group pos) (finset (finset Type))) : @is_add_cyclic.{0} pos (@functor.add_const.run.{0 1} (add_group.{0} pos) (finset.{1} (finset.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_61221 (h0 : group (with_one (has_nnnorm linarith.comp_source))) : is_cyclic (with_one (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_61222 (h0 : group (bin_tree (semiring num))) : is_cyclic (bin_tree (semiring num)) := sorry --non-trivial
lemma new_lemma_61223 (h0 : topological_space (finset name)) : preirreducible_space (finset name) := sorry --non-trivial
lemma new_lemma_61224 (h0 : complete_lattice (monoid (option (option (option pos))))) : complete_lattice.is_Sup_finite_compact (monoid (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_61225 (h0 : functor.add_const (topological_space (has_nndist pos)) pos) : @discrete_topology.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_61226 (h0 : functor.add_const (complete_lattice (option num)) empty) : @is_atomistic.{0} (option.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (option.{0} num)) empty h0)  := sorry --non-trivial
lemma new_lemma_61227 (h0 : functor.add_const (ordered_comm_monoid (comm_group linarith.comp)) name) : @has_exists_mul_of_le.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (comm_group.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_61228 (h1 : has_coe (nondiscrete_normed_field fun_info) Prop) (h2 : nondiscrete_normed_field fun_info) : @coe_b.{1 1} (nondiscrete_normed_field.{0} fun_info) Prop h1 h2  := sorry --non-trivial
lemma new_lemma_61229 (h0 : topological_space (complete_linear_order (semiring (semiring empty)))) : t0_space (complete_linear_order (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_61230 (h0 : cancel_comm_monoid_with_zero (cancel_monoid (finset (finset (finset pos))))) : unique_factorization_monoid (cancel_monoid (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_61231 (h0 : functor.add_const (complete_lattice (ordered_ring num)) num) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_ring.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_ring.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_61232 (h1 : function.extfun Type group) : @is_cyclic.{0} congr_arg_kind (@function.extfun_app.{2 1} Type group.{0} h1 congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_61233 (h0 : ordered_comm_monoid (has_neg_part (option (option pos)))) : has_exists_mul_of_le (has_neg_part (option (option pos))) := sorry --non-trivial
lemma new_lemma_61234 (h0 : function.extfun Type group) : @is_cyclic.{0} (finset.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (finset.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_61235 (h0 : function.extfun Type uniform_space) : @complete_space.{0} stieltjes_function (@function.extfun_app.{2 1} Type uniform_space.{0} h0 stieltjes_function)  := sorry --non-trivial
lemma new_lemma_61236 (h0 : function.extfun Type topological_space) : @normal_space.{0} (add_comm_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_61237 (h0 : functor.add_const (topological_space (has_neg Type)) Type) : @regular_space.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_neg.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_61238 (h0 : functor.add_const (topological_space (free_add_monoid unsigned)) congr_arg_kind) : @t1_space.{0} (free_add_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_61239 (h0 : group (boolean_algebra (has_to_string name))) : is_simple_group (boolean_algebra (has_to_string name)) := sorry --non-trivial
lemma new_lemma_61240 (h1 : topological_space (normed_field to_additive.value_type)) : path_connected_space (normed_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_61241 (h0 : not (topological_space (has_norm empty) -> false)) : @path_connected_space.{0} (has_norm.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_norm.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_61242 (h0 : functor.add_const (uniform_space (ring pos)) (ring (has_neg Type))) : @complete_space.{0} (ring.{0} pos) (@functor.add_const.run.{0 1} (uniform_space.{0} (ring.{0} pos)) (ring.{1} (has_neg.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_61243 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (div_inv_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (div_inv_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_61244 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @strong_rank_condition.{1} (plift.{1} num) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (plift.{1} num))  := sorry --non-trivial
lemma new_lemma_61245 (h0 : ordered_add_comm_monoid (has_to_string (has_nndist linarith.comp))) : archimedean (has_to_string (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_61246 (h0 : function.extfun Type group) : @is_cyclic.{0} (complete_semilattice_Sup.{0} (random_gen.{0} (random_gen.{0} (has_top.{0} (random_gen.{0} linarith.ineq))))) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_semilattice_Sup.{0} (random_gen.{0} (random_gen.{0} (has_top.{0} (random_gen.{0} linarith.ineq))))))  := sorry --non-trivial
lemma new_lemma_61247 (h0 : not (ring (semi_normed_comm_ring fun_info) -> false)) : @rank_condition.{0} (semi_normed_comm_ring.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_comm_ring.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_61248 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (ordered_ring.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type ring.{0} h0 (ordered_ring.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_61249 (h0 : fin has_zero.zero) : @complete_space.{0} (add_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (uniform_space.{0} (add_comm_monoid.{0} pos)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))))  := sorry --non-trivial
lemma new_lemma_61250 (h3 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (complete_semilattice_Sup.{0} linarith.ineq) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h3) (complete_semilattice_Sup.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_61251 (h0 : functor.add_const (group (normed_comm_ring Type)) linarith.comp) : @normalizer_condition.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (normed_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_61252 (h0 : topological_space (ordered_comm_group empty)) : normal_space (ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_61253 (h0 : functor.add_const (complete_lattice (has_to_string name)) pos) : @is_atomistic.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_61254 (h0 : topological_space (semigroup (normed_comm_ring (finset Type)))) : totally_disconnected_space (semigroup (normed_comm_ring (finset Type))) := sorry --non-trivial
lemma new_lemma_61255 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_zero.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_61256 (h0 : complete_lattice (metric_space string_imp)) : complete_lattice.is_Sup_finite_compact (metric_space string_imp) := sorry --non-trivial
lemma new_lemma_61257 (h0 : fin has_zero.zero) : @sequential_space.{0} (simple_graph.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (simple_graph.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_61258 (h0 : topological_space name) : loc_path_connected_space name := sorry --non-trivial
lemma new_lemma_61259 (h0 : function.extfun Type add_monoid) : add_monoid.fg nnreal := sorry --non-trivial
lemma new_lemma_61260 (h0 : topological_space (finset (has_add environment.implicit_infer_kind))) : sequential_space (finset (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_61261 (h0 : uniform_space (complete_semilattice_Sup (has_norm (has_norm empty)))) : separated_space (complete_semilattice_Sup (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_61262 (h0 : group (topological_space (has_nnnorm string_imp))) : is_cyclic (topological_space (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_61263 (h0 : group (fintype (has_top (has_nnnorm to_additive.value_type)))) : is_cyclic (fintype (has_top (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_61264 (h0 : topological_space (complete_semilattice_Sup (has_top fun_info))) : path_connected_space (complete_semilattice_Sup (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_61265 (h0 : has_mem.mem (with_bot empty) has_emptyc.emptyc) : @is_atomistic.{0} (with_bot.{0} empty) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_bot.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_61266 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_61267 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (linear_ordered_field.{0} name) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (linear_ordered_field.{0} name))  := sorry --non-trivial
lemma new_lemma_61268 (h0 : group (has_inv (random_gen char))) : group.fg (has_inv (random_gen char)) := sorry --non-trivial
lemma new_lemma_61269 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (add_cancel_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_cancel_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_61270 (h0 : ring (normed_group (random_gen (semiring num)))) : is_domain (normed_group (random_gen (semiring num))) := sorry --non-trivial
lemma new_lemma_61271 (h0 : functor.add_const (group (has_Inf pos)) linarith.comp) : @is_simple_group.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_Inf.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_61272 (h0 : add_group (normed_group linarith.ineq)) : is_add_cyclic (normed_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_61273 (h0 : ring (normed_group congr_arg_kind)) : rank_condition (normed_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_61274 (h0 : group (has_top (random_gen (random_gen linarith.comp_source)))) : group.fg (has_top (random_gen (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_61275 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_61276 (h0 : function.extfun (Type 1) group) : @group.fg.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_61277 (h0 : group (finset (has_add pos))) : is_simple_group (finset (has_add pos)) := sorry --non-trivial
lemma new_lemma_61278 (h0 : topological_space (mul_zero_class (has_nndist ennreal))) : preirreducible_space (mul_zero_class (has_nndist ennreal)) := sorry --non-trivial
lemma new_lemma_61279 (h0 : ordered_add_comm_monoid (option ennreal)) : archimedean (option ennreal) := sorry --non-trivial
lemma new_lemma_61280 (h0 : functor.add_const (complete_lattice (has_Inf linarith.comp)) Type) : @is_compactly_generated.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_Inf.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_61281 (h0 : function.extfun Type has_mul) (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @is_regular.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type has_mul.{0} h0 (ring.{0} ennreal)) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 ring.{0}) ennreal)  := sorry --non-trivial
lemma new_lemma_61282 (h0 : add_group (has_ssubset (random_gen fun_info))) : is_add_cyclic (has_ssubset (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_61283 (h0 : fin has_zero.zero) : @path_connected_space.{0} (simple_graph.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (simple_graph.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_61284 (h0 : topological_space (has_top (semiring num))) : path_connected_space (has_top (semiring num)) := sorry --non-trivial
lemma new_lemma_61285 (h0 : functor.comp ring add_comm_monoid name) : @is_principal_ideal_ring.{0} (add_comm_monoid.{0} name) (@functor.comp.run.{0 0 0} ring.{0} add_comm_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_61286 (h0 : ring (normed_linear_ordered_group empty)) : is_principal_ideal_ring (normed_linear_ordered_group empty) := sorry --non-trivial
lemma new_lemma_61287 (h0 : complete_lattice (div_inv_monoid fun_info)) : is_compactly_generated (div_inv_monoid fun_info) := sorry --non-trivial
lemma new_lemma_61288 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_61289 (h0 : functor.add_const (topological_space znum) empty) : @t1_space.{0} znum (@functor.add_const.run.{0 0} (topological_space.{0} znum) empty h0)  := sorry --non-trivial
lemma new_lemma_61290 (h0 : fin has_zero.zero) (h1 : list (fin has_zero.zero)) : id (matrix.vec_empty (list.ilast' h0 h1)) := sorry --non-trivial
lemma new_lemma_61291 (h0 : topological_space (add_comm_monoid (ring linarith.comp))) : regular_space (add_comm_monoid (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_61292 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_61293 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_61294 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (normed_linear_ordered_group.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} h0 (normed_linear_ordered_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_61295 (h0 : ring (add_comm_monoid (option ennreal))) : is_domain (add_comm_monoid (option ennreal)) := sorry --non-trivial
lemma new_lemma_61296 (h0 : functor.comp group has_zero ennreal) : @is_simple_group.{0} (has_zero.{0} ennreal) (@functor.comp.run.{0 0 0} group.{0} has_zero.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_61297 (h0 : function.extfun (((Type -> Type) -> Type 1) -> Type 1) (function.extfun ((Type -> Type) -> Type 1))) : @totally_separated_space.{0} (linear_ordered_comm_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (@function.extfun_app.{3 3} (((Type → Type) → Type 1) → Type 1) (function.extfun.{3 2} ((Type → Type) → Type 1)) h0 (function.extfun.{2 2} (Type → Type))) (function.extfun.{2 1} Type)) topological_space.{0}) (linear_ordered_comm_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_61298 (h0 : ring (boolean_algebra.core (add_comm_monoid (add_comm_monoid pos)))) : strong_rank_condition (boolean_algebra.core (add_comm_monoid (add_comm_monoid pos))) := sorry --non-trivial
lemma new_lemma_61299 (h0 : topological_space (plift congr_arg_kind)) : irreducible_space (plift congr_arg_kind) := sorry --non-trivial
lemma new_lemma_61300 (h0 : group (id (random_gen fun_info))) : is_cyclic (id (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_61301 (h0 : functor.add_const (list (ring Type)) Type) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_61302 (h0 : functor.add_const (add_monoid (normed_comm_ring linarith.comp)) pos) : @add_monoid.fg.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (normed_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_61303 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (option.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (option.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_61304 (h0 : ring (canonically_linear_ordered_monoid real)) : is_principal_ideal_ring (canonically_linear_ordered_monoid real) := sorry --non-trivial
lemma new_lemma_61305 (h0 : topological_space (free_add_monoid unsigned)) : topological_space.separable_space (free_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_61306 (h0 : filter (ordered_comm_monoid pos)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_61307 (h1 : topological_space (measurable_space (random_gen linarith.ineq))) : locally_compact_space (measurable_space (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_61308 (h0 : ring (pseudo_metric_space (option unsigned))) : rank_condition (pseudo_metric_space (option unsigned)) := sorry --non-trivial
lemma new_lemma_61309 (h0 : functor.add_const (topological_space (has_zero unsigned)) linarith.comp) : @t0_space.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_61310 (h0 : add_group (dlist string_imp)) : is_add_cyclic (dlist string_imp) := sorry --non-trivial
lemma new_lemma_61311 (h0 : ring (linear_ordered_field (has_to_string (has_to_string congr_arg_kind)))) : strong_rank_condition (linear_ordered_field (has_to_string (has_to_string congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_61312 (h0 : topological_space (add_cancel_monoid (option unsigned))) : discrete_topology (add_cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_61313 (h1 : topological_space (measurable_space (random_gen linarith.comp_source))) : path_connected_space (measurable_space (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_61314 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (complete_distrib_lattice.{0} empty) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (complete_distrib_lattice.{0} empty))  := sorry --non-trivial
lemma new_lemma_61315 (h0 : ring (complete_semilattice_Sup (has_norm (random_gen (random_gen linarith.ineq))))) : rank_condition (complete_semilattice_Sup (has_norm (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_61316 (h0 : group (linear_ordered_field unsigned) -> Prop) (h1 : Exists (fun (x : group (linear_ordered_field unsigned)), h0 x)) : @is_cyclic.{0} (linear_ordered_field.{0} unsigned) (@classical.some.{1} (group.{0} (linear_ordered_field.{0} unsigned)) h0 h1)  := sorry --non-trivial
lemma new_lemma_61317 (h0 : not (uniform_space (random_gen reducibility_hints) -> false)) : @complete_space.{0} (random_gen.{0} reducibility_hints) (@classical.by_contradiction'.{1} (uniform_space.{0} (random_gen.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_61318 (h0 : ring (generalized_boolean_algebra (has_Inf real))) : is_principal_ideal_ring (generalized_boolean_algebra (has_Inf real)) := sorry --non-trivial
lemma new_lemma_61319 (h0 : not (function.extfun (finset (Type -> Type)) (has_mem.mem uniform_space) -> false)) : @complete_space.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) uniform_space.{0}) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) uniform_space.{0})) h0) (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_61320 (h0 : uniform_space empty) : complete_space empty := sorry --non-trivial
lemma new_lemma_61321 (h0 : ordered_comm_monoid (complete_distrib_lattice (ordered_comm_monoid linarith.comp))) : has_exists_mul_of_le (complete_distrib_lattice (ordered_comm_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_61322 (h0 : topological_space (option (option (option (option ennreal))))) : normal_space (option (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_61323 (h0 : topological_space (measurable_space (has_norm (has_norm linarith.comp_source)))) : totally_separated_space (measurable_space (has_norm (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_61324 (h0 : complete_lattice (option (semiring (semiring empty)))) : is_compactly_generated (option (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_61325 (h0 : cancel_comm_monoid_with_zero (measure_theory.measure_space (semiring (semiring congr_arg_kind)))) : unique_factorization_monoid (measure_theory.measure_space (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_61326 (h2 : topological_space (normed_field (has_nnnorm (has_nnnorm char)))) : t0_space (normed_field (has_nnnorm (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_61327 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (group_with_zero ennreal)) := sorry --non-trivial
lemma new_lemma_61328 (h0 : group (has_nndist congr_arg_kind)) : group.fg (has_nndist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_61329 (h1 : function.extfun Type topological_space) : @locally_compact_space.{0} (distrib_lattice.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (distrib_lattice.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_61330 (h0 : functor.add_const (add_monoid (semigroup linarith.comp)) linarith.comp) : @add_monoid.fg.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (semigroup.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_61331 (h0 : ring (has_neg (option (option (option pos))))) : rank_condition (has_neg (option (option (option pos)))) := sorry --non-trivial
lemma new_lemma_61332 (h0 : ring (linear_ordered_comm_group_with_zero (metric_space reducibility_hints))) : strong_rank_condition (linear_ordered_comm_group_with_zero (metric_space reducibility_hints)) := sorry --non-trivial
lemma new_lemma_61333 (h1 h2 : multiset (add_comm_semigroup linarith.ineq)) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_61334 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (has_pos_part Type)) : @preirreducible_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) (has_pos_part.{1} Type) h0) (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_61335 (h0 : topological_space (has_inter (option unsigned))) : topological_space.separable_space (has_inter (option unsigned)) := sorry --non-trivial
lemma new_lemma_61336 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @discrete_topology.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_61337 (h0 : fin has_zero.zero) : @t0_space.{0} (add_comm_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (add_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_61338 (h0 : functor.add_const (function.extfun (Type 1) complete_lattice) pos) : @is_atomistic.{1} Type (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) complete_lattice.{1}) pos h0) Type)  := sorry --non-trivial
lemma new_lemma_61339 (h0 : group (linear_ordered_add_comm_group (has_norm linarith.comp_source))) : is_cyclic (linear_ordered_add_comm_group (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_61340 (h0 : complete_lattice (has_le fun_info)) : is_compactly_generated (has_le fun_info) := sorry --non-trivial
lemma new_lemma_61341 (h0 : uniform_space (add_semigroup (option (option empty)))) : separated_space (add_semigroup (option (option empty))) := sorry --non-trivial
lemma new_lemma_61342 (h0 : fin has_zero.zero) : @normal_space.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (boolean_algebra.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_61343 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_61344 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (complete_distrib_lattice.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (complete_distrib_lattice.{0} name))  := sorry --non-trivial
lemma new_lemma_61345 (h0 : functor.add_const (complete_lattice (has_to_string linarith.comp)) unsigned) : @is_atomistic.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} linarith.comp)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_61346 (h0 : topological_space (add_comm_monoid (has_bot real))) : preirreducible_space (add_comm_monoid (has_bot real)) := sorry --non-trivial
lemma new_lemma_61347 (h0 : list (with_bot (random_gen (has_inv linarith.comp_source)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_61348 (h0 : topological_space (add_cancel_monoid (has_Inf Type))) : path_connected_space (add_cancel_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_61349 (h0 : monoid (canonically_linear_ordered_monoid Type)) : monoid.fg (canonically_linear_ordered_monoid Type) := sorry --non-trivial
lemma new_lemma_61350 (h1 : ring (linear_ordered_add_comm_group string_imp)) : strong_rank_condition (linear_ordered_add_comm_group string_imp) := sorry --non-trivial
lemma new_lemma_61351 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (add_right_cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_right_cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_61352 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_61353 (h0 : functor.add_const (ordered_add_comm_monoid (has_nndist environment.implicit_infer_kind)) pos) : @archimedean.{0} (has_nndist.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_nndist.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_61354 (h0 : functor.add_const (topological_space (comm_group ennreal)) ennreal) : @sequential_space.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_61355 (h0 : list (semigroup (option pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_61356 (h0 : not (ring (ordered_cancel_comm_monoid to_additive.value_type) -> false)) : @strong_rank_condition.{0} (ordered_cancel_comm_monoid.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (ordered_cancel_comm_monoid.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_61357 (h0 : topological_space (has_zero (has_to_string (ring (has_to_string (has_to_string (has_to_string pos))))))) : t1_space (has_zero (has_to_string (ring (has_to_string (has_to_string (has_to_string pos)))))) := sorry --non-trivial
lemma new_lemma_61358 (h0 : uniform_space (has_Sup congr_arg_kind)) : separated_space (has_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_61359 (h0 : to_additive.value_type -> to_additive.value_type -> Prop) (h1 h2 : to_additive.value_type) : relation.refl_trans_gen h0 h1 h2 := sorry --non-trivial
lemma new_lemma_61360 (h0 : not (filter (linear_ordered_add_comm_group linarith.ineq) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_61361 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_61362 (h0 : topological_space (pseudo_metric_space (option empty))) : totally_disconnected_space (pseudo_metric_space (option empty)) := sorry --non-trivial
lemma new_lemma_61363 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_61364 (h0 : ring (has_ssubset (has_nndist reducibility_hints))) : rank_condition (has_ssubset (has_nndist reducibility_hints)) := sorry --non-trivial
lemma new_lemma_61365 (h1 : complete_lattice (metric_space (metric_space (comm_ring char)))) : complete_lattice.is_Sup_finite_compact (metric_space (metric_space (comm_ring char))) := sorry --non-trivial
lemma new_lemma_61366 (h0 : has_mem.mem (with_one congr_arg_kind) has_emptyc.emptyc) : @separated_space.{0} (with_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type uniform_space.{0} (with_one.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_61367 (h0 : group (complete_distrib_lattice (comm_group ennreal))) : is_simple_group (complete_distrib_lattice (comm_group ennreal)) := sorry --non-trivial
lemma new_lemma_61368 (h1 : topological_space (normed_field string_imp)) : path_connected_space (normed_field string_imp) := sorry --non-trivial
lemma new_lemma_61369 (h0 : group (has_pos_part (has_add linarith.comp))) : is_cyclic (has_pos_part (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_61370 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_61371 (h0 : topological_space (has_add (has_add name))) : regular_space (has_add (has_add name)) := sorry --non-trivial
lemma new_lemma_61372 (h0 : add_group (complete_distrib_lattice num)) : is_add_cyclic (complete_distrib_lattice num) := sorry --non-trivial
lemma new_lemma_61373 (h0 : functor.add_const (group (has_add Type)) environment.implicit_infer_kind) : @normalizer_condition.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_add.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_61374 (h0 : num -> Prop) : Exists h0 := sorry --non-trivial
lemma new_lemma_61375 (h0 : fin has_zero.zero) : @t1_space.{0} (canonically_ordered_comm_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp (@matrix.vec_empty.{1} (functor.add_const.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp) h0)) (canonically_ordered_comm_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_61376 (h0 : semiring (ring (has_neg_part Type))) : is_noetherian_ring (ring (has_neg_part Type)) := sorry --non-trivial
lemma new_lemma_61377 (h0 : uniform_space (has_to_string (has_neg (has_add (ring linarith.comp))))) : complete_space (has_to_string (has_neg (has_add (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_61378 (h0 : functor.add_const (ring (preorder empty)) empty) : @rank_condition.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (preorder.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_61379 (h0 : group (comm_group Type)) : group.fg (comm_group Type) := sorry --non-trivial
lemma new_lemma_61380 (h0 : list (encodable (has_inv (linear_ordered_add_comm_group to_additive.value_type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_61381 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) linarith.comp) : @locally_compact_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_61382 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (has_bot.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_bot.{0} empty))  := sorry --non-trivial
lemma new_lemma_61383 (h0 : topological_space (linear_ordered_comm_group empty)) : locally_compact_space (linear_ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_61384 (h0 : filter (div_inv_monoid string_imp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_61385 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_semigroup empty)) empty) : @unique_factorization_monoid.{0} (add_semigroup.{0} empty) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_semigroup.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_61386 (h1 : topological_space std_gen) (h2 : set std_gen) : is_path_connected h2 := sorry --non-trivial
lemma new_lemma_61387 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_61388 (h0 : functor.add_const (topological_space (has_nndist ennreal)) pos) : @normal_space.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} ennreal)) pos h0)  := sorry --non-trivial
lemma new_lemma_61389 (h0 : ring (has_inter unsigned)) : strong_rank_condition (has_inter unsigned) := sorry --non-trivial
lemma new_lemma_61390 (h0 : topological_space (generalized_boolean_algebra (has_add (has_add (has_add (has_Inf Type)))))) : preconnected_space (generalized_boolean_algebra (has_add (has_add (has_add (has_Inf Type))))) := sorry --non-trivial
lemma new_lemma_61391 (h0 : not (function.extfun (Type 1) ring -> false)) : @rank_condition.{1} (plift.{1} congr_arg_kind) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@classical.by_contradiction'.{3} (function.extfun.{3 2} (Type 1) ring.{1}) h0) (plift.{1} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_61392 (h0 : functor.add_const (topological_space (has_to_string ennreal)) Type) : @preirreducible_space.{0} (has_to_string.{0} ennreal) (@functor.add_const.run.{0 1} (topological_space.{0} (has_to_string.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_61393 (h2 : group (add_cancel_comm_monoid to_additive.value_type)) : is_cyclic (add_cancel_comm_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_61394 (h0 : functor.add_const (filter (add_cancel_monoid Type)) name) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_61395 (h0 : function.extfun Type ring) : @is_domain.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_61396 (h0 : topological_space (has_bot (has_add (has_Inf pos)))) : loc_path_connected_space (has_bot (has_add (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_61397 (h0 : functor.add_const (topological_space (ring linarith.comp)) Type) : @totally_separated_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_61398 (h0 : topological_space (normed_linear_ordered_group (add_group unsigned))) : totally_separated_space (normed_linear_ordered_group (add_group unsigned)) := sorry --non-trivial
lemma new_lemma_61399 (h3 : add_group (div_inv_monoid to_additive.value_type)) : is_add_cyclic (div_inv_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_61400 (h0 : group (measurable_space linarith.ineq)) : group.fg (measurable_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_61401 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (ordered_comm_ring.{0} (has_pos_part.{0} linarith.comp)) (@function.extfun_app.{2 1} Type monoid.{0} h0 (ordered_comm_ring.{0} (has_pos_part.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_61402 (h0 : function.extfun Type topological_space) : @t0_space.{0} (complete_distrib_lattice.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_61403 (h0 : functor.add_const (topological_space (has_to_string name)) name) : @totally_disconnected_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_61404 (h0 : topological_space (finset (finset Type))) : regular_space (finset (finset Type)) := sorry --non-trivial
lemma new_lemma_61405 (h0 : functor.add_const (topological_space (mul_zero_class unsigned)) Type) : @totally_separated_space.{0} (mul_zero_class.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (mul_zero_class.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_61406 (h1 : topological_space (normed_field (denumerable to_additive.value_type))) : totally_disconnected_space (normed_field (denumerable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_61407 (h1 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} h1 (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_61408 (h3 : list linarith.comp_source) : list.nodup h3 := sorry --non-trivial
lemma new_lemma_61409 (h0 : uniform_space (has_to_string (normed_comm_ring Type))) : separated_space (has_to_string (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_61410 (h0 : semiring (has_union (semiring (has_norm (semiring (semiring congr_arg_kind)))))) : is_noetherian_ring (has_union (semiring (has_norm (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_61411 (h0 : add_group (with_one string_imp)) : is_add_cyclic (with_one string_imp) := sorry --non-trivial
lemma new_lemma_61412 (h0 : ordered_comm_monoid (normed_comm_ring (has_to_string (finset environment.implicit_infer_kind)))) : has_exists_mul_of_le (normed_comm_ring (has_to_string (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_61413 (h0 : set (has_lt fun_info)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_61414 (h0 : functor.add_const (add_monoid pos) pos) : @add_monoid.fg.{0} pos (@functor.add_const.run.{0 0} (add_monoid.{0} pos) pos h0)  := sorry --non-trivial
lemma new_lemma_61415 (h0 : function.extfun Type (functor.comp uniform_space has_add)) : @separated_space.{0} (has_add.{0} name) (@functor.comp.run.{0 0 0} uniform_space.{0} has_add.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} uniform_space.{0} has_add.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_61416 (h0 : add_group (has_repr (has_neg linarith.comp))) : is_add_cyclic (has_repr (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_61417 (h0 : list (normed_comm_ring (semigroup (finset Type)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_61418 (h0 : topological_space (boolean_algebra (has_add (add_cancel_monoid Type)))) : totally_separated_space (boolean_algebra (has_add (add_cancel_monoid Type))) := sorry --non-trivial
lemma new_lemma_61419 (h0 : group (add_cancel_monoid (has_to_string name))) : is_simple_group (add_cancel_monoid (has_to_string name)) := sorry --non-trivial
lemma new_lemma_61420 (h0 : complete_lattice (random_gen congr_arg_kind)) : complete_lattice.is_Sup_finite_compact (random_gen congr_arg_kind) := sorry --non-trivial
lemma new_lemma_61421 (h0 : function.extfun (Type 1) (functor.comp topological_space finset)) : @totally_separated_space.{1} (finset.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} finset.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} finset.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_61422 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (complete_semilattice_Sup.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (complete_semilattice_Sup.{0} empty))  := sorry --non-trivial
lemma new_lemma_61423 (h0 : fin has_zero.zero) : @rank_condition.{0} (comm_semigroup.{0} pos) (@matrix.vec_empty.{0} (ring.{0} (comm_semigroup.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_61424 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @t1_space.{1} (mul_zero_class.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (mul_zero_class.{1} Type))  := sorry --non-trivial
lemma new_lemma_61425 (h0 : ring (normed_lattice_add_comm_group (has_Inf real))) : rank_condition (normed_lattice_add_comm_group (has_Inf real)) := sorry --non-trivial
lemma new_lemma_61426 (h0 : add_group (with_one (has_top to_additive.value_type))) : is_add_cyclic (with_one (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_61427 (h0 : functor.add_const (topological_space (has_nndist Type)) environment.implicit_infer_kind) : @loc_path_connected_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_61428 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_61429 (h0 : group (has_top (random_gen (random_gen congr_arg_kind)))) : normalizer_condition (has_top (random_gen (random_gen congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_61430 (h0 : complete_lattice (dlist linarith.ineq)) : complete_lattice.is_Sup_finite_compact (dlist linarith.ineq) := sorry --non-trivial
lemma new_lemma_61431 (h1 h2 : multiset (simple_graph char)) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_61432 (h0 : ordered_add_comm_monoid (has_zero (boolean_algebra Type))) : archimedean (has_zero (boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_61433 (h0 : functor.add_const (group (has_zero pos)) (finset (finset (ring (has_neg (ring (finset (ring pos)))))))) : @group.fg.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_zero.{0} pos)) (finset.{0} (finset.{0} (ring.{0} (has_neg.{0} (ring.{0} (finset.{0} (ring.{0} pos))))))) h0)  := sorry --non-trivial
lemma new_lemma_61434 (h0 : filter (comm_group (finset (has_add (add_comm_monoid environment.implicit_infer_kind))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_61435 (h0 : functor.add_const (topological_space (semigroup name)) Type) : @totally_disconnected_space.{0} (semigroup.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_61436 (h0 : group (has_bot (finset (has_add (finset linarith.comp))))) : is_cyclic (has_bot (finset (has_add (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_61437 (h0 : functor.add_const (function.extfun Type monoid) Type) : @monoid.fg.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type monoid.{0}) Type h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_61438 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (complete_semilattice_Sup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (complete_semilattice_Sup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_61439 (h0 : topological_space (ordered_comm_ring (sub_neg_monoid (has_add Type)))) : preconnected_space (ordered_comm_ring (sub_neg_monoid (has_add Type))) := sorry --non-trivial
lemma new_lemma_61440 (h0 : functor.add_const (finset (boolean_algebra Type)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_61441 (h0 : functor.add_const (uniform_space (option empty)) empty) : @complete_space.{0} (option.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (option.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_61442 (h0 : ordered_comm_monoid (add_cancel_monoid (has_neg (has_add Type)))) : has_exists_mul_of_le (add_cancel_monoid (has_neg (has_add Type))) := sorry --non-trivial
lemma new_lemma_61443 (h0 : add_group (non_unital_non_assoc_semiring fun_info)) : is_add_cyclic (non_unital_non_assoc_semiring fun_info) := sorry --non-trivial
lemma new_lemma_61444 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system unsigned)) unsigned) : @t1_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_61445 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @strong_rank_condition.{1} (has_neg_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ring.{1}) (has_neg_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_61446 (h0 : complete_lattice (semi_normed_ring (add_cancel_comm_monoid char))) : is_compactly_generated (semi_normed_ring (add_cancel_comm_monoid char)) := sorry --non-trivial
lemma new_lemma_61447 (h0 : ring (as_linear_order unsigned)) : is_domain (as_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_61448 (h1 : not (complete_lattice (simple_graph linarith.comp_source) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (simple_graph.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (simple_graph.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_61449 (h0 : topological_space (has_add unsigned)) : topological_space.separable_space (has_add unsigned) := sorry --non-trivial
lemma new_lemma_61450 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @normal_space.{0} (simple_graph.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (simple_graph.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_61451 (h0 : topological_space (normed_comm_ring (option (finset (ring pos))))) : t1_space (normed_comm_ring (option (finset (ring pos)))) := sorry --non-trivial
lemma new_lemma_61452 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (mul_zero_class.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (mul_zero_class.{0} empty))  := sorry --non-trivial
lemma new_lemma_61453 (h0 : list (has_add (has_to_string congr_arg_kind))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_61454 (h0 : not (uniform_space (distrib (has_nnnorm linarith.ineq)) -> false)) : @complete_space.{0} (distrib.{0} (has_nnnorm.{0} linarith.ineq)) (@classical.by_contradiction'.{1} (uniform_space.{0} (distrib.{0} (has_nnnorm.{0} linarith.ineq))) h0)  := sorry --non-trivial
lemma new_lemma_61455 (h0 : fin has_zero.zero) : @complete_lattice.is_Sup_finite_compact.{0} (has_Inf.{0} (has_neg.{0} (has_neg.{0} name))) (@matrix.vec_empty.{0} (complete_lattice.{0} (has_Inf.{0} (has_neg.{0} (has_neg.{0} name)))) h0)  := sorry --non-trivial
lemma new_lemma_61456 (h0 : complete_lattice (ordered_comm_monoid (ring (ring (ring name))))) : complete_lattice.is_Sup_finite_compact (ordered_comm_monoid (ring (ring (ring name)))) := sorry --non-trivial
lemma new_lemma_61457 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (boolean_algebra.core.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_61458 (h0 : uniform_space (boolean_algebra (has_nndist (finset (has_nndist linarith.comp))))) : separated_space (boolean_algebra (has_nndist (finset (has_nndist linarith.comp)))) := sorry --non-trivial
lemma new_lemma_61459 (h3 : ring (denumerable to_additive.value_type)) : rank_condition (denumerable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_61460 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg linarith.comp)) : @irreducible_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{0} linarith.comp) h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_61461 (h0 : function.extfun (Type 1) (functor.comp topological_space normed_comm_ring)) : @preirreducible_space.{1} (normed_comm_ring.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} normed_comm_ring.{1} Type (@function.extfun_app.{3 2} (Type 1) (functor.comp.{1 1 1} topological_space.{1} normed_comm_ring.{1}) h0 Type))  := sorry --non-trivial
lemma new_lemma_61462 (h0 : functor.add_const (topological_space (mul_zero_class ennreal)) environment.implicit_infer_kind) : @normal_space.{0} (mul_zero_class.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} ennreal)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_61463 (h0 : functor.add_const (list (option unsigned)) num) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_61464 (h0 : group (cancel_monoid name)) : is_simple_group (cancel_monoid name) := sorry --non-trivial
lemma new_lemma_61465 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (canonically_ordered_add_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_ordered_add_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_61466 (h0 : functor.add_const (list (option name)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_61467 (h0 : topological_space (has_add (option ennreal))) : normal_space (has_add (option ennreal)) := sorry --non-trivial
lemma new_lemma_61468 (h0 : topological_space (has_zero (add_cancel_monoid (has_add unsigned)))) : loc_path_connected_space (has_zero (add_cancel_monoid (has_add unsigned))) := sorry --non-trivial
lemma new_lemma_61469 (h0 : functor.add_const (group (comm_group name)) name) : @is_cyclic.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_61470 (h0 : functor.add_const (topological_space (ordered_comm_monoid Type)) Type) : @discrete_topology.{1} (ordered_comm_monoid.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (ordered_comm_monoid.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_61471 (h0 : functor.add_const Prop (normed_comm_ring pos)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_61472 (h0 : ordered_add_comm_monoid (complete_distrib_lattice name)) : archimedean (complete_distrib_lattice name) := sorry --non-trivial
lemma new_lemma_61473 (h0 : ring (add_cancel_comm_monoid (denumerable (metric_space linarith.comp_source)))) : strong_rank_condition (add_cancel_comm_monoid (denumerable (metric_space linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_61474 (h1 : not (has_mem.mem (has_top congr_arg_kind) has_emptyc.emptyc -> false)) : @is_domain.{0} (has_top.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type ring.{0} (has_top.{0} congr_arg_kind) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} congr_arg_kind) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h1))  := sorry --non-trivial
lemma new_lemma_61475 (h0 : complete_lattice (has_bot pos)) : complete_lattice.is_Sup_finite_compact (has_bot pos) := sorry --non-trivial
lemma new_lemma_61476 (h0 : list (boolean_algebra.core (comm_group ennreal))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_61477 (h0 : uniform_space (distrib_lattice (random_gen (random_gen string_imp)))) : complete_space (distrib_lattice (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_61478 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_norm.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_61479 (h0 : functor.comp topological_space normed_comm_ring Type) : @regular_space.{1} (normed_comm_ring.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} normed_comm_ring.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_61480 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (normed_comm_ring.{0} (random_gen.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (normed_comm_ring.{0} (random_gen.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_61481 (h0 : functor.add_const (ordered_comm_monoid (add_cancel_monoid Type)) unsigned) : @has_exists_mul_of_le.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (add_cancel_monoid.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_61482 (h0 : functor.add_const (ring (add_left_cancel_semigroup congr_arg_kind)) congr_arg_kind) : @rank_condition.{0} (add_left_cancel_semigroup.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (add_left_cancel_semigroup.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_61483 (h0 : fin has_zero.zero) : @complete_space.{0} (ordered_comm_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (uniform_space.{0} (ordered_comm_monoid.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_61484 (h0 : topological_space (linear_ordered_add_comm_group (has_inv linarith.ineq))) : locally_compact_space (linear_ordered_add_comm_group (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_61485 (h1 : topological_space (dlist (random_gen (random_gen linarith.ineq)))) : t0_space (dlist (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_61486 (h0 : topological_space (has_top (has_norm (has_norm (has_norm linarith.comp_source))))) : discrete_topology (has_top (has_norm (has_norm (has_norm linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_61487 (h0 : topological_space (comm_group (canonically_linear_ordered_monoid ennreal))) : preconnected_space (comm_group (canonically_linear_ordered_monoid ennreal)) := sorry --non-trivial
lemma new_lemma_61488 (h0 : ordered_comm_monoid (has_to_string (has_neg_part (has_neg_part Type)))) : has_exists_mul_of_le (has_to_string (has_neg_part (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_61489 (h1 : set (uniform_space std_gen)) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_61490 (h0 : not (prod (normed_group congr_arg_kind) (normed_group congr_arg_kind) -> false)) : id_rel (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_61491 (h0 : functor.add_const (topological_space (has_pos_part pos)) (has_Inf Type)) : @preconnected_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_pos_part.{0} pos)) (has_Inf.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_61492 (h0 : list (ordered_comm_ring linarith.comp)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_61493 (h0 : functor.add_const (topological_space (preorder num)) congr_arg_kind) : @locally_compact_space.{0} (preorder.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_61494 (h0 : topological_space (has_norm (has_top to_additive.value_type))) : discrete_topology (has_norm (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_61495 (h0 : topological_space (has_neg_part (has_to_string ennreal))) : sequential_space (has_neg_part (has_to_string ennreal)) := sorry --non-trivial
lemma new_lemma_61496 (h0 : fin has_zero.zero) : @t0_space.{0} (has_bot.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_bot.{0} real))  := sorry --non-trivial
lemma new_lemma_61497 (h0 : topological_space (comm_semigroup pos)) : path_connected_space (comm_semigroup pos) := sorry --non-trivial
lemma new_lemma_61498 (h0 : group (ring (has_neg name))) : normalizer_condition (ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_61499 (h0 : functor.add_const (group (has_neg pos)) name) : @is_cyclic.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_neg.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_61500 (h0 : complete_lattice (with_one (has_nnnorm linarith.ineq))) : complete_lattice.is_Sup_finite_compact (with_one (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_61501 (h0 : functor.add_const (complete_lattice (has_to_string Type)) pos) : @is_compactly_generated.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_to_string.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_61502 (h0 : topological_space (has_zero name)) : totally_separated_space (has_zero name) := sorry --non-trivial
lemma new_lemma_61503 (h0 : function.extfun (finset Type) (has_mem.mem num)) : @complete_space.{0} num (@finset.pi.empty.{1 0} Type uniform_space.{0} num (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) num) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_61504 (h0 : set (has_compl enat)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_61505 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 congr_arg_kind) := sorry --non-trivial
lemma new_lemma_61506 (h0 : uniform_space (measurable_space (has_norm fun_info))) : separated_space (measurable_space (has_norm fun_info)) := sorry --non-trivial
lemma new_lemma_61507 (h0 : list (has_inv (has_inv (distrib_lattice (random_gen char))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_61508 (h0 : function.extfun (Type 1) ordered_add_comm_monoid) : @archimedean.{1} (has_zero.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} h0 (has_zero.{1} Type))  := sorry --non-trivial
lemma new_lemma_61509 (h0 : topological_space (plift (semiring (semiring num)))) : t0_space (plift (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_61510 (h0 : uniform_space (has_top (id (semiring (id num))))) : complete_space (has_top (id (semiring (id num)))) := sorry --non-trivial
lemma new_lemma_61511 (h0 : cancel_comm_monoid_with_zero (ordered_comm_monoid (ring pos))) : unique_factorization_monoid (ordered_comm_monoid (ring pos)) := sorry --non-trivial
lemma new_lemma_61512 (h0 : topological_space (finset (finset (ring pos)))) : topological_space.separable_space (finset (finset (ring pos))) := sorry --non-trivial
lemma new_lemma_61513 (h0 : set.set_semiring nnreal) (h1 : nnreal) : set.set_semiring.down h0 h1 := sorry --non-trivial
lemma new_lemma_61514 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_emptyc.{0} num))  := sorry --non-trivial
lemma new_lemma_61515 (h0 : uniform_space (boolean_algebra (has_add (finset pos)))) : complete_space (boolean_algebra (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_61516 (h0 : has_mem.mem (normed_group fun_info) has_emptyc.emptyc) : @is_compactly_generated.{0} (normed_group.{0} fun_info) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (normed_group.{0} fun_info) h0)  := sorry --non-trivial
lemma new_lemma_61517 (h0 : group (ordered_comm_ring (finset (has_Inf (has_neg (finset linarith.comp)))))) : normalizer_condition (ordered_comm_ring (finset (has_Inf (has_neg (finset linarith.comp))))) := sorry --non-trivial
lemma new_lemma_61518 (h0 : not (topological_space (mul_zero_class empty) -> false)) : @totally_separated_space.{0} (mul_zero_class.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (mul_zero_class.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_61519 (h0 : functor.add_const (topological_space (add_comm_monoid linarith.comp)) pos) : @topological_space.separable_space.{0} (add_comm_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_comm_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_61520 (h0 : topological_space (has_nndist (has_neg_part environment.implicit_infer_kind))) : topological_space.separable_space (has_nndist (has_neg_part environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_61521 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_61522 (h0 : topological_space (random_gen empty)) : irreducible_space (random_gen empty) := sorry --non-trivial
lemma new_lemma_61523 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) name) : @sequential_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_61524 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (canonically_linear_ordered_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_linear_ordered_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_61525 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_neg.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_61526 (h0 : functor.add_const (topological_space (has_to_string name)) pos) : @totally_disconnected_space.{0} (has_to_string.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_61527 (h1 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h1) (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_61528 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_61529 (h0 : functor.add_const (uniform_space (has_Inf pos)) pos) : @separated_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_Inf.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_61530 (h0 : topological_space (generalized_boolean_algebra (sub_neg_monoid real))) : preconnected_space (generalized_boolean_algebra (sub_neg_monoid real)) := sorry --non-trivial
lemma new_lemma_61531 (h0 : uniform_space (has_zero (has_nndist pos))) : separated_space (has_zero (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_61532 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) Type) : @regular_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.core.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_61533 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type semiring.{0} h0 (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_61534 (h0 : group (encodable (random_gen linarith.ineq))) : group.fg (encodable (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_61535 (h0 : functor.add_const (uniform_space (semigroup unsigned)) name) : @complete_space.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (semigroup.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_61536 (h0 : topological_space (boolean_algebra.core (mul_zero_class ennreal))) : totally_disconnected_space (boolean_algebra.core (mul_zero_class ennreal)) := sorry --non-trivial
lemma new_lemma_61537 (h0 : fin has_zero.zero) : @topological_space.separable_space.{0} (normed_lattice_add_comm_group.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (normed_lattice_add_comm_group.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_61538 (h0 : topological_space (has_top (semiring congr_arg_kind))) : normal_space (has_top (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_61539 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (finset ennreal)) := sorry --non-trivial
lemma new_lemma_61540 (h0 : topological_space (has_ssubset (random_gen string_imp))) : t0_space (has_ssubset (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_61541 (h0 : topological_space (has_pos_part (ordered_comm_monoid real))) : preconnected_space (has_pos_part (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_61542 (h2 : preorder (mul_one_class (mul_one_class enat))) (h3 : set (mul_one_class (mul_one_class enat))) : set.is_pwo h3 := sorry --non-trivial
lemma new_lemma_61543 (h0 : group (with_bot (random_gen fun_info))) : group.fg (with_bot (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_61544 (h0 : function.extfun Type semiring) : is_noetherian_ring real := sorry --non-trivial
lemma new_lemma_61545 (h1 : add_group (mul_one_class std_gen)) : is_add_cyclic (mul_one_class std_gen) := sorry --non-trivial
lemma new_lemma_61546 (h0 : group (with_one (with_bot (with_bot (with_bot (with_bot string_imp)))))) : normalizer_condition (with_one (with_bot (with_bot (with_bot (with_bot string_imp))))) := sorry --non-trivial
lemma new_lemma_61547 (h0 : list (ordered_cancel_add_comm_monoid (option pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_61548 (h0 : monoid (has_neg_part (finset (finset Type)))) : monoid.fg (has_neg_part (finset (finset Type))) := sorry --non-trivial
lemma new_lemma_61549 (h0 : topological_space enat) : preirreducible_space enat := sorry --non-trivial
lemma new_lemma_61550 (h0 : cancel_comm_monoid_with_zero (add_group congr_arg_kind)) : unique_factorization_monoid (add_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_61551 (h2 : uniform_space (mul_one_class (mul_one_class string.iterator_imp))) : complete_space (mul_one_class (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_61552 (h1 : not (add_group (semi_normed_ring reducibility_hints) -> false)) : @is_add_cyclic.{0} (semi_normed_ring.{0} reducibility_hints) (@classical.by_contradiction'.{1} (add_group.{0} (semi_normed_ring.{0} reducibility_hints)) h1)  := sorry --non-trivial
lemma new_lemma_61553 (h0 : group (normed_field (comm_ring string.iterator_imp))) : is_cyclic (normed_field (comm_ring string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_61554 (h0 : not (ring (plift num) -> false)) : @rank_condition.{1} (plift.{1} num) (@classical.by_contradiction'.{2} (ring.{1} (plift.{1} num)) h0)  := sorry --non-trivial
lemma new_lemma_61555 (h0 : topological_space (simple_graph (mul_one_class fun_info))) : totally_disconnected_space (simple_graph (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_61556 (h0 : complete_lattice (add_comm_monoid name)) : is_compactly_generated (add_comm_monoid name) := sorry --non-trivial
lemma new_lemma_61557 (h0 : topological_space (complete_distrib_lattice (has_neg_part name))) : sequential_space (complete_distrib_lattice (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_61558 (h0 : add_group (has_bot (has_Inf (finset linarith.comp)))) : is_add_cyclic (has_bot (has_Inf (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_61559 (h0 : functor.add_const (add_monoid (finset environment.implicit_infer_kind)) linarith.comp) : @add_monoid.fg.{0} (finset.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (finset.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_61560 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (has_top.{0} (semiring.{0} linarith.comp)) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_top.{0} (semiring.{0} linarith.comp)))  := sorry --non-trivial
lemma new_lemma_61561 (h0 : function.extfun nat fin) : @is_noetherian_ring.{0} (has_bot.{0} name) (@matrix.vec_empty.{0} (semiring.{0} (has_bot.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_61562 (h0 : add_group (normed_group string_imp)) : is_add_cyclic (normed_group string_imp) := sorry --non-trivial
lemma new_lemma_61563 (h0 : topological_space (dlist (random_gen to_additive.value_type))) : totally_separated_space (dlist (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_61564 (h0 : topological_space (metric_space (has_one num))) : path_connected_space (metric_space (has_one num)) := sorry --non-trivial
lemma new_lemma_61565 (h0 : topological_space (linear_ordered_semiring to_additive.value_type)) : discrete_topology (linear_ordered_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_61566 (h0 : functor.add_const (functor.add_const (list Type) pos) Type) : palindrome (functor.add_const.run (functor.add_const.run h0)) := sorry --non-trivial
lemma new_lemma_61567 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (random_gen.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (random_gen.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_61568 (h0 : topological_space (sub_neg_monoid (has_neg real))) : path_connected_space (sub_neg_monoid (has_neg real)) := sorry --non-trivial
lemma new_lemma_61569 (h0 : complete_lattice (free_add_monoid empty)) : is_compactly_generated (free_add_monoid empty) := sorry --non-trivial
lemma new_lemma_61570 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_61571 (h0 : uniform_space (linear_ordered_comm_group_with_zero (mul_one_class fun_info))) : complete_space (linear_ordered_comm_group_with_zero (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_61572 (h0 : topological_space (ring unsigned)) : topological_space.separable_space (ring unsigned) := sorry --non-trivial
lemma new_lemma_61573 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) name) : @path_connected_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_61574 (h0 : monoid to_additive.value_type) (h1 : complete_lattice (star_monoid to_additive.value_type)) : is_compactly_generated (star_monoid to_additive.value_type) := sorry --non-trivial
lemma new_lemma_61575 (h0 : functor.add_const (group (ring Type)) environment.implicit_infer_kind) : @group.fg.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (ring.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_61576 (h0 : functor.add_const (function.extfun Type complete_lattice) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) linarith.comp h0) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_61577 (h0 : not (group (linear_order congr_arg_kind) -> false)) : @is_cyclic.{0} (linear_order.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (linear_order.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_61578 (h0 : canonically_linear_ordered_monoid Type -> canonically_linear_ordered_monoid Type -> Prop) : transitive h0 := sorry --non-trivial
lemma new_lemma_61579 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (monoid_with_zero.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (monoid_with_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_61580 (h0 : complete_lattice (metric_space (semiring linarith.comp))) : is_atomistic (metric_space (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_61581 (h1 : not (add_group (has_div string_imp) -> false)) : @is_add_cyclic.{0} (has_div.{0} string_imp) (@classical.by_contradiction'.{1} (add_group.{0} (has_div.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_61582 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (ring.{0} (option.{0} (option.{0} ennreal))) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} (option.{0} (option.{0} ennreal))))  := sorry --non-trivial
lemma new_lemma_61583 (h0 : functor.add_const (topological_space (metric_space name)) linarith.comp) : @preconnected_space.{0} (metric_space.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (metric_space.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_61584 (h0 : list (generalized_boolean_algebra linarith.comp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_61585 (h0 : topological_space (complete_distrib_lattice (semigroup (has_neg (has_add (has_add pos)))))) : normal_space (complete_distrib_lattice (semigroup (has_neg (has_add (has_add pos))))) := sorry --non-trivial
lemma new_lemma_61586 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_simple_group.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_61587 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (has_emptyc.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_emptyc.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_61588 (h0 : group (comm_group (has_add environment.implicit_infer_kind))) : group.fg (comm_group (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_61589 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_61590 (h0 : not (group (with_one congr_arg_kind) -> false)) : @is_cyclic.{0} (with_one.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (with_one.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_61591 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @loc_path_connected_space.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_61592 (h0 : monoid (add_comm_monoid (option (option empty)))) : monoid.fg (add_comm_monoid (option (option empty))) := sorry --non-trivial
lemma new_lemma_61593 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @path_connected_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_61594 (h0 : ring (add_comm_monoid (finset (has_neg name)))) : is_principal_ideal_ring (add_comm_monoid (finset (has_neg name))) := sorry --non-trivial
lemma new_lemma_61595 (h0 : functor.add_const (topological_space (free_add_monoid congr_arg_kind)) num) : @path_connected_space.{0} (free_add_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_61596 (h0 : topological_space (normed_lattice_add_comm_group (has_neg pos))) : discrete_topology (normed_lattice_add_comm_group (has_neg pos)) := sorry --non-trivial
lemma new_lemma_61597 (h0 : prod char char -> Prop) (h1 h2 : char) : function.curry h0 h1 h2 := sorry --non-trivial
lemma new_lemma_61598 (h0 : cancel_comm_monoid_with_zero (ring (finset Type))) : unique_factorization_monoid (ring (finset Type)) := sorry --non-trivial
lemma new_lemma_61599 (h0 : has_mem.mem linarith.comp has_emptyc.emptyc) : @rank_condition.{0} linarith.comp (@finset.pi.empty.{1 0} Type ring.{0} linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_61600 (h0 : not (topological_space (plift empty) -> false)) : @t0_space.{1} (plift.{1} empty) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} empty)) h0)  := sorry --non-trivial
lemma new_lemma_61601 (h0 : ring (semigroup (has_nndist (has_neg Type)))) : is_principal_ideal_ring (semigroup (has_nndist (has_neg Type))) := sorry --non-trivial
lemma new_lemma_61602 (h0 : function.extfun Type topological_space) : @normal_space.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_61603 (h0 : functor.add_const (ring (ordered_comm_ring pos)) Type) : @is_principal_ideal_ring.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (ordered_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_61604 (h0 : functor.add_const (ring (semigroup Type)) (has_neg pos)) : @rank_condition.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (semigroup.{1} Type)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_61605 (h0 : ring (has_to_string (has_pos_part (has_pos_part (has_pos_part linarith.comp))))) : strong_rank_condition (has_to_string (has_pos_part (has_pos_part (has_pos_part linarith.comp)))) := sorry --non-trivial
lemma new_lemma_61606 (h0 : topological_space (has_neg_part (has_neg_part linarith.comp))) : topological_space.separable_space (has_neg_part (has_neg_part linarith.comp)) := sorry --non-trivial
lemma new_lemma_61607 (h0 : functor.add_const (topological_space (pseudo_metric_space name)) name) : @normal_space.{0} (pseudo_metric_space.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (pseudo_metric_space.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_61608 (h0 : complete_lattice (has_inv (has_inv linarith.comp_source))) : is_atomistic (has_inv (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_61609 (h0 : not (uniform_space (bin_tree linarith.comp) -> false)) : @separated_space.{0} (bin_tree.{0} linarith.comp) (@classical.by_contradiction'.{1} (uniform_space.{0} (bin_tree.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_61610 (h0 : functor.add_const (topological_space (has_add pos)) environment.implicit_infer_kind) : @normal_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_61611 (h0 : topological_space (measurable_space (random_gen linarith.ineq))) : locally_compact_space (measurable_space (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_61612 (h0 : topological_space (boolean_algebra.core (option (option pos)))) : normal_space (boolean_algebra.core (option (option pos))) := sorry --non-trivial
lemma new_lemma_61613 (h0 : functor.add_const (finset (has_add pos)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_61614 (h0 : topological_space (has_bot (canonically_linear_ordered_monoid real))) : locally_compact_space (has_bot (canonically_linear_ordered_monoid real)) := sorry --non-trivial
lemma new_lemma_61615 (h0 : functor.add_const (complete_lattice (mul_zero_class empty)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (mul_zero_class.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_61616 (h0 : semiring (has_zero (has_to_string (ring (boolean_algebra (has_to_string (ring Type))))))) : is_noetherian_ring (has_zero (has_to_string (ring (boolean_algebra (has_to_string (ring Type)))))) := sorry --non-trivial
lemma new_lemma_61617 (h0 : functor.add_const (ring (has_nndist Type)) (has_to_string linarith.comp)) : @is_domain.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (has_nndist.{1} Type)) (has_to_string.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_61618 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} fun_info (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) fun_info)  := sorry --non-trivial
lemma new_lemma_61619 (h0 : ulower pnat) (h1 : fin has_zero.zero) : pnat.coprime (ulower.up h0) (matrix.vec_empty h1) := sorry --non-trivial
lemma new_lemma_61620 (h0 : functor.add_const (list (ring environment.implicit_infer_kind)) environment.implicit_infer_kind) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_61621 (h0 : topological_space (ordered_cancel_add_comm_monoid (option (option ennreal)))) : topological_space.separable_space (ordered_cancel_add_comm_monoid (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_61622 (h0 : semiring (has_Inf (has_pos_part pos))) : is_noetherian_ring (has_Inf (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_61623 (h0 : add_group (boolean_algebra.core (has_neg_part (finset pos)))) : is_add_cyclic (boolean_algebra.core (has_neg_part (finset pos))) := sorry --non-trivial
lemma new_lemma_61624 (h1 : complete_lattice (non_unital_non_assoc_semiring char)) : complete_lattice.is_Sup_finite_compact (non_unital_non_assoc_semiring char) := sorry --non-trivial
lemma new_lemma_61625 (h0 : topological_space (complete_linear_order (semiring (semiring (semiring num))))) : topological_space.separable_space (complete_linear_order (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_61626 (h0 : list (boolean_algebra (comm_group (comm_group name)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_61627 (h0 : not (topological_space (measurable_space.dynkin_system num) -> false)) : @totally_separated_space.{0} (measurable_space.dynkin_system.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (measurable_space.dynkin_system.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_61628 (h0 : option (option ennreal) -> option (option ennreal) -> Prop) : is_symm (option (option ennreal)) h0 := sorry --non-trivial
lemma new_lemma_61629 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_61630 (h0 : functor.add_const (topological_space (has_zero Type)) name) : @normal_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_61631 (h1 : group (distrib_lattice (random_gen string_imp))) : normalizer_condition (distrib_lattice (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_61632 (h0 : topological_space (add_left_cancel_monoid (has_nnnorm fun_info))) : path_connected_space (add_left_cancel_monoid (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_61633 (h0 : ring (has_top (semiring congr_arg_kind))) : is_domain (has_top (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_61634 (h0 : topological_space (normed_comm_ring (mul_one_class (has_Inf pos)))) : topological_space.separable_space (normed_comm_ring (mul_one_class (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_61635 (h1 : complete_lattice (has_top (has_nnnorm string_imp))) : complete_lattice.is_Sup_finite_compact (has_top (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_61636 (h0 : functor.add_const (add_group (add_cancel_monoid pos)) (has_pos_part linarith.comp)) : @is_add_cyclic.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (add_cancel_monoid.{0} pos)) (has_pos_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_61637 (h0 : prod (measurable_space.dynkin_system empty) (measurable_space.dynkin_system empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_61638 (h0 : topological_space (normed_field (has_nnnorm linarith.ineq))) : totally_disconnected_space (normed_field (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_61639 (h0 : topological_space (complete_semilattice_Sup (has_nnnorm (has_ssubset (has_inv fun_info))))) : locally_compact_space (complete_semilattice_Sup (has_nnnorm (has_ssubset (has_inv fun_info)))) := sorry --non-trivial
lemma new_lemma_61640 (h0 : pnat) (h1 : ulower (fin has_zero.zero)) : pnat.coprime h0 (id (matrix.vec_empty (ulower.up h1))) := sorry --non-trivial
lemma new_lemma_61641 (h0 : filter (random_gen string_imp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_61642 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_61643 (h0 : fin has_zero.zero) : @totally_disconnected_space.{1} (canonically_linear_ordered_monoid.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (canonically_linear_ordered_monoid.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_61644 (h0 : not (uniform_space (measure_theory.measure_space num) -> false)) : @complete_space.{0} (measure_theory.measure_space.{0} num) (@classical.by_contradiction'.{1} (uniform_space.{0} (measure_theory.measure_space.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_61645 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @t0_space.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_61646 (h1 : ring (mul_one_class enat)) : rank_condition (mul_one_class enat) := sorry --non-trivial
lemma new_lemma_61647 (h0 : filter (complete_distrib_lattice (has_to_string (finset ennreal)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_61648 (h0 : not (topological_space (plift congr_arg_kind) -> false)) : @totally_separated_space.{1} (plift.{1} congr_arg_kind) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_61649 (h0 : ring (ordered_comm_group (option (option num)))) : is_principal_ideal_ring (ordered_comm_group (option (option num))) := sorry --non-trivial
lemma new_lemma_61650 (h0 : complete_lattice (monoid_with_zero unsigned)) : complete_lattice.is_Sup_finite_compact (monoid_with_zero unsigned) := sorry --non-trivial
lemma new_lemma_61651 (h0 : not (function.extfun Type topological_space -> false)) : @irreducible_space.{0} (measurable_space.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_61652 (h0 : topological_space (add_semigroup empty)) : preirreducible_space (add_semigroup empty) := sorry --non-trivial
lemma new_lemma_61653 (h0 : functor.add_const (topological_space (has_bot empty)) empty) : @totally_disconnected_space.{0} (has_bot.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_bot.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_61654 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (has_add real)) := sorry --non-trivial
lemma new_lemma_61655 (h0 : uniform_space (measurable_space fun_info)) : complete_space (measurable_space fun_info) := sorry --non-trivial
lemma new_lemma_61656 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_61657 (h0 : group (add_group congr_arg_kind)) : normalizer_condition (add_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_61658 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_61659 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group linarith.comp))) : @group.fg.{0} (normed_group.{0} linarith.comp) (@finset.pi.empty.{1 0} Type group.{0} (normed_group.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_61660 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_61661 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (add_cancel_monoid.{0} (option.{0} congr_arg_kind)) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_monoid.{0} (option.{0} congr_arg_kind)))  := sorry --non-trivial
lemma new_lemma_61662 (h1 h2 : multiset (mul_one_class (mul_one_class (add_comm_semigroup (mul_one_class fun_info))))) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_61663 (h1 : uniform_space (with_one (has_nnnorm fun_info))) : complete_space (with_one (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_61664 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_61665 (h0 : functor.add_const (add_monoid (ring linarith.comp)) linarith.comp) : @add_monoid.fg.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_61666 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_add_cyclic.{0} (canonically_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (add_group.{0} (canonically_ordered_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_61667 (h0 : uniform_space (has_to_string (semigroup environment.implicit_infer_kind))) : complete_space (has_to_string (semigroup environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_61668 (h2 : uniform_space (uniform_space string_imp)) : complete_space (uniform_space string_imp) := sorry --non-trivial
lemma new_lemma_61669 (h0 : functor.add_const (ordered_comm_monoid (ring name)) (boolean_algebra (boolean_algebra name))) : @has_exists_mul_of_le.{0} (ring.{0} name) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (ring.{0} name)) (boolean_algebra.{0} (boolean_algebra.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_61670 (h0 : monoid (add_left_cancel_semigroup (complete_distrib_lattice unsigned))) : monoid.fg (add_left_cancel_semigroup (complete_distrib_lattice unsigned)) := sorry --non-trivial
lemma new_lemma_61671 (h0 : fin has_zero.zero) : @is_simple_group.{0} (has_add.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (has_add.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_61672 (h0 : functor.add_const (function.extfun (Type 1) ordered_comm_monoid) (has_neg Type)) : @has_exists_mul_of_le.{1} Type (@function.extfun_app.{3 2} (Type 1) ordered_comm_monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) ordered_comm_monoid.{1}) (has_neg.{1} Type) h0) Type)  := sorry --non-trivial
lemma new_lemma_61673 (h0 : function.extfun nat fin) : @is_add_cyclic.{1} (comm_semigroup.{1} Type) (@matrix.vec_empty.{1} (add_group.{1} (comm_semigroup.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_61674 (h1 : monoid (id congr_arg_kind)) : monoid.fg (id congr_arg_kind) := sorry --non-trivial
lemma new_lemma_61675 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_61676 (h0 : functor.comp list has_zero (comm_group unsigned)) : list.nodup (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_61677 (h0 : linear_ordered_field (add_comm_monoid pos) -> linear_ordered_field (add_comm_monoid pos) -> Prop) : is_symm (linear_ordered_field (add_comm_monoid pos)) h0 := sorry --non-trivial
lemma new_lemma_61678 (h0 : semiring (has_nndist num)) : is_noetherian_ring (has_nndist num) := sorry --non-trivial
lemma new_lemma_61679 (h0 : fin has_zero.zero) : @preirreducible_space.{0} (ordered_comm_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (ordered_comm_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_61680 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @strong_rank_condition.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (linear_ordered_semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_61681 (h0 : functor.add_const (list (ordered_ring empty)) empty) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_61682 (h0 : functor.add_const (ring (has_zero pos)) pos) : @is_principal_ideal_ring.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_61683 (h0 : topological_space std_gen) (h1 : set std_gen) : is_totally_separated h1 := sorry --non-trivial
lemma new_lemma_61684 (h2 : ring (has_emptyc (has_top fun_info))) : rank_condition (has_emptyc (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_61685 (h0 : ordered_comm_monoid (canonically_linear_ordered_monoid (has_neg real))) : has_exists_mul_of_le (canonically_linear_ordered_monoid (has_neg real)) := sorry --non-trivial
lemma new_lemma_61686 (h0 : functor.add_const (add_group (has_neg_part name)) pos) : @is_add_cyclic.{0} (has_neg_part.{0} name) (@functor.add_const.run.{0 0} (add_group.{0} (has_neg_part.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_61687 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (sub_neg_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_61688 (h0 : finset (has_zero num)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_61689 (h0 : functor.add_const (group environment.implicit_infer_kind) Type) : @is_cyclic.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 1} (group.{0} environment.implicit_infer_kind) Type h0)  := sorry --non-trivial
lemma new_lemma_61690 (h0 : group (with_one (has_top (has_top fun_info)))) : group.fg (with_one (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_61691 (h0 : functor.add_const (finset (left_cancel_monoid empty)) empty) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_61692 (h0 : fin has_zero.zero) : @separated_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type uniform_space.{0}) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_61693 (h0 : uniform_space (has_Inf (has_neg (has_add linarith.comp)))) : separated_space (has_Inf (has_neg (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_61694 (h0 : functor.add_const (topological_space (finset pos)) (has_neg pos)) : @path_connected_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} pos)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_61695 (h0 : filter (has_neg (finset (finset linarith.comp)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_61696 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_compactly_generated.{0} (comm_ring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (comm_ring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_61697 (h0 : filter (normed_linear_ordered_group unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_61698 (h0 : topological_space (add_cancel_monoid (comm_group (add_comm_monoid name)))) : loc_path_connected_space (add_cancel_monoid (comm_group (add_comm_monoid name))) := sorry --non-trivial
lemma new_lemma_61699 (h0 : ring (is_R_or_C (option unsigned))) : is_domain (is_R_or_C (option unsigned)) := sorry --non-trivial
lemma new_lemma_61700 (h0 : group (ordered_cancel_add_comm_monoid (option unsigned))) : is_cyclic (ordered_cancel_add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_61701 (h1 : topological_space (add_comm_semigroup (mul_one_class char))) (h2 : preorder (add_comm_semigroup (mul_one_class char))) : order_topology (add_comm_semigroup (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_61702 (h0 : add_monoid (boolean_algebra (ring Type))) : add_monoid.fg (boolean_algebra (ring Type)) := sorry --non-trivial
lemma new_lemma_61703 (h0 : filter (has_repr fun_info)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_61704 (h0 : functor.add_const (topological_space (mul_zero_class empty)) (semiring empty)) : @t1_space.{0} (mul_zero_class.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_61705 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) unsigned) : @regular_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_61706 (h0 : topological_space (random_gen (has_norm (has_norm fun_info)))) : totally_separated_space (random_gen (has_norm (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_61707 (h0 : topological_space (ring (has_neg (has_neg linarith.comp)))) : totally_separated_space (ring (has_neg (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_61708 (h0 : group (with_bot (semiring (semiring num)))) : group.fg (with_bot (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_61709 (h0 : functor.add_const (topological_space (ordered_comm_ring pos)) Type) : @topological_space.separable_space.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (ordered_comm_ring.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_61710 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_61711 (h0 : topological_space (ordered_comm_monoid (has_bot real))) : totally_separated_space (ordered_comm_monoid (has_bot real)) := sorry --non-trivial
lemma new_lemma_61712 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @discrete_topology.{0} linarith.comp (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_61713 (h0 : functor.add_const (topological_space (boolean_algebra linarith.comp)) Type) : @locally_compact_space.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_61714 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (random_gen.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (random_gen.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_61715 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (add_right_cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_right_cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_61716 (h0 : topological_space (linear_order num)) : t1_space (linear_order num) := sorry --non-trivial
lemma new_lemma_61717 (h0 : topological_space (has_nnnorm (has_lt (has_compl (random_gen linarith.ineq))))) : t0_space (has_nnnorm (has_lt (has_compl (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_61718 (h1 : topological_space (nondiscrete_normed_field (add_comm_semigroup char))) : t0_space (nondiscrete_normed_field (add_comm_semigroup char)) := sorry --non-trivial
lemma new_lemma_61719 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (canonically_ordered_comm_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_ordered_comm_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_61720 (h0 : functor.add_const (group (semiring num)) (option empty)) : @group.fg.{0} (semiring.{0} num) (@functor.add_const.run.{0 0} (group.{0} (semiring.{0} num)) (option.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_61721 (h0 : group (has_inv linarith.comp_source)) : normalizer_condition (has_inv linarith.comp_source) := sorry --non-trivial
lemma new_lemma_61722 (h0 : function.extfun Type (functor.add_const (uniform_space (add_cancel_monoid empty)))) : @complete_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (add_cancel_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_61723 (h3 : uniform_space environment.projection_info) : complete_space environment.projection_info := sorry --non-trivial
lemma new_lemma_61724 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (linear_ordered_comm_monoid_with_zero.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_61725 (h0 : functor.add_const (complete_lattice (normed_linear_ordered_group empty)) (semiring num)) : @is_compactly_generated.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_linear_ordered_group.{0} empty)) (semiring.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_61726 (h0 : complete_lattice (simple_graph (mul_one_class char)) -> Prop) (h1 : Exists (fun (x : complete_lattice (simple_graph (mul_one_class char))), h0 x)) : @is_compactly_generated.{0} (simple_graph.{0} (mul_one_class.{0} char)) (@classical.some.{1} (complete_lattice.{0} (simple_graph.{0} (mul_one_class.{0} char))) h0 h1)  := sorry --non-trivial
lemma new_lemma_61727 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type monoid.{0} h0 (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_61728 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (ordered_comm_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_61729 (h0 : list (add_cancel_monoid (has_neg_part (has_to_string name)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_61730 (h0 : function.extfun Type group) : @is_cyclic.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_61731 (h0 : not (topological_space (has_top to_additive.value_type) -> false)) : @irreducible_space.{0} (has_top.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_61732 (h0 : monoid (with_one (has_norm linarith.comp_source))) : monoid.fg (with_one (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_61733 (h0 : functor.add_const (topological_space (partial_order num)) num) : @totally_disconnected_space.{0} (partial_order.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_61734 (h11 : add_group (distrib fun_info)) : is_add_cyclic (distrib fun_info) := sorry --non-trivial
lemma new_lemma_61735 (h0 : filter (has_nndist (ring (option pos)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_61736 (h0 : ring (topological_space (denumerable to_additive.value_type))) : rank_condition (topological_space (denumerable to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_61737 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (normed_linear_ordered_group.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (normed_linear_ordered_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_61738 (h0 : complete_lattice (has_union (semiring unsigned))) : complete_lattice.is_Sup_finite_compact (has_union (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_61739 (h0 : unsigned -> empty -> Prop) : relator.bi_total h0 := sorry --non-trivial
lemma new_lemma_61740 (h0 : function.extfun (Type 1) ring) : @is_domain.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) ring.{1} h0 (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_61741 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (ordered_cancel_add_comm_monoid num)) := sorry --non-trivial
lemma new_lemma_61742 (h0 : filter (has_add (finset name))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_61743 (h0 : functor.add_const (group (comm_group pos)) ennreal) : @is_cyclic.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} pos)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_61744 (h0 : functor.add_const (add_monoid (ring Type)) (has_add (has_zero pos))) : @add_monoid.fg.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (ring.{1} Type)) (has_add.{0} (has_zero.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_61745 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @regular_space.{0} (has_to_string.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_to_string.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_61746 (h0 : topological_space (left_cancel_semigroup (semiring (semiring (semiring num))))) : totally_separated_space (left_cancel_semigroup (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_61747 (h0 : functor.add_const (functor.add_const (add_group (boolean_algebra pos)) (boolean_algebra.core Type)) Type) : @is_add_cyclic.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (add_group.{0} (boolean_algebra.{0} pos)) (boolean_algebra.core.{1} Type) (@functor.add_const.run.{0 1} (functor.add_const.{0 1} (add_group.{0} (boolean_algebra.{0} pos)) (boolean_algebra.core.{1} Type)) Type h0))  := sorry --non-trivial
lemma new_lemma_61748 (h0 : functor.add_const (function.extfun nat fin) Type) : @loc_path_connected_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin (@functor.add_const.run.{0 1} (function.extfun.{1 1} nat fin) Type h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_61749 (h0 : topological_space (has_ssubset fun_info)) (h1 : preorder (has_ssubset fun_info)) : order_topology (has_ssubset fun_info) := sorry --non-trivial
lemma new_lemma_61750 (h2 : topological_space (add_comm_semigroup linarith.ineq)) : totally_disconnected_space (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_61751 (h0 : has_mem.mem (has_norm linarith.ineq) has_emptyc.emptyc) : @discrete_topology.{0} (has_norm.{0} linarith.ineq) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} linarith.ineq) h0)  := sorry --non-trivial
lemma new_lemma_61752 (h0 : ring (option empty)) : strong_rank_condition (option empty) := sorry --non-trivial
lemma new_lemma_61753 (h0 : prod (normed_comm_ring (option (option unsigned))) (normed_comm_ring (option (option unsigned)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_61754 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} fun_info (@function.extfun_app.{2 1} Type add_group.{0} h0 fun_info)  := sorry --non-trivial
lemma new_lemma_61755 (h0 : group (canonically_linear_ordered_monoid num)) : is_simple_group (canonically_linear_ordered_monoid num) := sorry --non-trivial
lemma new_lemma_61756 (h0 : topological_space znum) : totally_disconnected_space znum := sorry --non-trivial
lemma new_lemma_61757 (h0 : has_mem.mem Type has_emptyc.emptyc) : @is_add_cyclic.{1} Type (@finset.pi.empty.{2 1} (Type 1) add_group.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_61758 (h0 : functor.add_const (ring (non_assoc_semiring empty)) empty) : @is_principal_ideal_ring.{0} (non_assoc_semiring.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (non_assoc_semiring.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_61759 (h2 : complete_lattice (topological_space char)) : is_compactly_generated (topological_space char) := sorry --non-trivial
lemma new_lemma_61760 (h0 : topological_space (boolean_algebra.core (mul_zero_class Type))) : topological_space.separable_space (boolean_algebra.core (mul_zero_class Type)) := sorry --non-trivial
lemma new_lemma_61761 (h0 : complete_lattice (has_dist congr_arg_kind)) : is_compactly_generated (has_dist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_61762 (h0 : ring (normed_comm_ring (option unsigned)) -> ring (normed_comm_ring (option unsigned)) -> Prop) : is_symm (ring (normed_comm_ring (option unsigned))) h0 := sorry --non-trivial
lemma new_lemma_61763 (h0 : topological_space (distrib_lattice string_imp)) : topological_space.separable_space (distrib_lattice string_imp) := sorry --non-trivial
lemma new_lemma_61764 (h0 : topological_space (add_cancel_monoid (has_Inf Type))) : irreducible_space (add_cancel_monoid (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_61765 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (has_pos_part.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (has_pos_part.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_61766 (h0 : functor.add_const (topological_space (normed_comm_ring Type)) Type) : @normal_space.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (normed_comm_ring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_61767 (h0 : complete_lattice (with_bot (has_top fun_info))) : is_compactly_generated (with_bot (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_61768 (h0 : topological_space (has_add (finset (has_Inf (finset pos))))) : normal_space (has_add (finset (has_Inf (finset pos)))) := sorry --non-trivial
lemma new_lemma_61769 (h0 : functor.add_const (function.extfun Type topological_space) name) : @sequential_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_61770 (h0 : topological_space (ordered_cancel_add_comm_monoid (option unsigned))) : t1_space (ordered_cancel_add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_61771 (h0 : complete_lattice (bin_tree (has_norm (has_top empty)))) : is_atomistic (bin_tree (has_norm (has_top empty))) := sorry --non-trivial
lemma new_lemma_61772 (h0 : topological_space (has_add (has_Inf pos))) : t0_space (has_add (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_61773 (h0 : topological_space (has_add (ring unsigned))) : t1_space (has_add (ring unsigned)) := sorry --non-trivial
lemma new_lemma_61774 (h0 : functor.add_const (function.extfun Type uniform_space) Type) : @complete_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type uniform_space.{0}) Type h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_61775 (h0 : comm_ring std_gen) : local_ring std_gen := sorry --non-trivial
lemma new_lemma_61776 (h0 : ring (option (has_neg_part name))) : strong_rank_condition (option (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_61777 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (has_dist.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_dist.{0} empty))  := sorry --non-trivial
lemma new_lemma_61778 (h2 : has_lt ereal) : no_max_order ereal := sorry --non-trivial
lemma new_lemma_61779 (h0 : functor.add_const (list (semigroup linarith.comp)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_61780 (h0 : not (complete_lattice (uniform_space reducibility_hints) -> false)) : complete_lattice.is_Sup_finite_compact (uniform_space reducibility_hints) := sorry --non-trivial
lemma new_lemma_61781 (h0 : function.extfun Type ring) : @is_domain.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_61782 (h0 : filter (boolean_algebra (has_add (has_nndist pos)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_61783 (h0 : functor.add_const (topological_space (ring linarith.comp)) name) : @normal_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_61784 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (add_cancel_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_cancel_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_61785 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_61786 (h0 : topological_space (add_left_cancel_monoid (has_nnnorm (has_nnnorm linarith.comp_source)))) : totally_disconnected_space (add_left_cancel_monoid (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_61787 (h0 : topological_space (has_top (random_gen (has_nnnorm fun_info)))) : t0_space (has_top (random_gen (has_nnnorm fun_info))) := sorry --non-trivial
lemma new_lemma_61788 (h0 : filter (has_div enat)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_61789 (h0 : function.extfun Type (functor.add_const Prop)) : functor.add_const.run (function.extfun_app h0 (option unsigned)) := sorry --non-trivial
lemma new_lemma_61790 (h0 : topological_space (ordered_cancel_add_comm_monoid (has_zero ennreal))) : preconnected_space (ordered_cancel_add_comm_monoid (has_zero ennreal)) := sorry --non-trivial
lemma new_lemma_61791 (h0 : topological_space (generalized_boolean_algebra linarith.comp)) : locally_compact_space (generalized_boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_61792 (h0 : topological_space (plift unsigned)) : totally_disconnected_space (plift unsigned) := sorry --non-trivial
lemma new_lemma_61793 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring linarith.comp_source))) : @locally_compact_space.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_61794 (h0 : functor.add_const (list (ordered_comm_monoid Type)) name) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_61795 (h0 : uniform_space (linear_ordered_comm_group_with_zero environment.projection_info)) : complete_space (linear_ordered_comm_group_with_zero environment.projection_info) := sorry --non-trivial
lemma new_lemma_61796 (h0 : functor.add_const (topological_space (comm_group Type)) pos) : @irreducible_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_61797 (h0 : function.extfun (Type 1) complete_lattice) : @complete_lattice.is_Sup_finite_compact.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} h0 (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_61798 (h0 : cancel_comm_monoid_with_zero (monoid (option congr_arg_kind))) : unique_factorization_monoid (monoid (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_61799 (h0 : topological_space (has_Inf (has_add (has_add pos)))) : sequential_space (has_Inf (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_61800 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (add_cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_61801 (h0 : topological_space (has_ssubset (random_gen char))) : path_connected_space (has_ssubset (random_gen char)) := sorry --non-trivial
lemma new_lemma_61802 (h0 : functor.add_const (filter (complete_distrib_lattice pos)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_61803 (h0 : measurable_space (measure_theory.measure_space ereal)) (h1 : measure_theory.measure (measure_theory.measure_space ereal)) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_61804 (h0 : function.extfun Type filter) : countable_Inter_filter (function.extfun_app h0 (complete_distrib_lattice pos)) := sorry --non-trivial
lemma new_lemma_61805 (h0 : topological_space (mul_zero_class (semiring num))) : locally_compact_space (mul_zero_class (semiring num)) := sorry --non-trivial
lemma new_lemma_61806 (h0 : functor.add_const (filter (boolean_algebra linarith.comp)) (has_neg Type)) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_61807 (h1 : set (ereal -> string.iterator_imp)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_61808 (h0 : ring (cancel_monoid (comm_monoid unsigned))) : rank_condition (cancel_monoid (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_61809 (h0 : semiring (add_right_cancel_monoid congr_arg_kind)) : is_noetherian_ring (add_right_cancel_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_61810 (h0 : function.extfun (finset Type) (has_mem.mem (complete_semilattice_Sup linarith.comp_source))) : @locally_compact_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@finset.pi.empty.{1 0} Type topological_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (complete_semilattice_Sup.{0} linarith.comp_source)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_61811 (h0 : functor.add_const (topological_space (ring Type)) (finset (has_to_string (finset (finset pos))))) : @preconnected_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) (finset.{0} (has_to_string.{0} (finset.{0} (finset.{0} pos)))) h0)  := sorry --non-trivial
lemma new_lemma_61812 (h0 : topological_space (has_pos_part (ring (finset (has_pos_part (has_pos_part Type)))))) : preirreducible_space (has_pos_part (ring (finset (has_pos_part (has_pos_part Type))))) := sorry --non-trivial
lemma new_lemma_61813 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_compl (has_ssubset to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_61814 (h0 : functor.add_const (ring (has_zero linarith.comp)) linarith.comp) : @is_domain.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 0} (ring.{0} (has_zero.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_61815 (h0 : finset (canonically_ordered_monoid (sub_neg_monoid name))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_61816 (h0 : topological_space (add_group_with_zero_nhd (semiring (semiring empty)))) : t1_space (add_group_with_zero_nhd (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_61817 (h0 : functor.add_const (finset (semigroup unsigned)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_61818 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) empty) : @archimedean.{0} (has_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) empty h0) (has_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_61819 (h0 : ring (uniform_space (comm_ring (topological_space char)))) : rank_condition (uniform_space (comm_ring (topological_space char))) := sorry --non-trivial
lemma new_lemma_61820 (h0 : add_monoid (plift (non_assoc_semiring (semiring num)))) : add_monoid.fg (plift (non_assoc_semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_61821 (h0 : functor.add_const (add_monoid (boolean_algebra linarith.comp)) (finset linarith.comp)) : @add_monoid.fg.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (boolean_algebra.{0} linarith.comp)) (finset.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_61822 (h0 : not (has_mem.mem (has_top num) has_emptyc.emptyc -> false)) : @irreducible_space.{0} (has_top.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_61823 (h2 : add_group congr_arg_kind) : is_add_cyclic congr_arg_kind := sorry --non-trivial
lemma new_lemma_61824 (h0 : complete_lattice (has_inv (has_ssubset linarith.ineq))) : is_compactly_generated (has_inv (has_ssubset linarith.ineq)) := sorry --non-trivial
lemma new_lemma_61825 (h0 : topological_space (has_norm linarith.ineq)) : irreducible_space (has_norm linarith.ineq) := sorry --non-trivial
lemma new_lemma_61826 (h0 : functor.add_const (topological_space (has_add pos)) (has_Inf pos)) : @normal_space.{0} (has_add.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} pos)) (has_Inf.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_61827 (h0 : topological_space (comm_group (has_to_string (has_to_string ennreal)))) : topological_space.separable_space (comm_group (has_to_string (has_to_string ennreal))) := sorry --non-trivial
lemma new_lemma_61828 (h0 : finset (semigroup (finset (finset (finset (finset linarith.comp)))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_61829 (h0 : topological_space (has_scalar ennreal unsigned)) : topological_space.separable_space (has_scalar ennreal unsigned) := sorry --non-trivial
lemma new_lemma_61830 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) Type) : @loc_path_connected_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_61831 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (option.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (option.{0} name))  := sorry --non-trivial
lemma new_lemma_61832 (h0 : topological_space (boolean_algebra.core num)) : t0_space (boolean_algebra.core num) := sorry --non-trivial
lemma new_lemma_61833 (h0 : list (simple_graph (ring (ring Type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_61834 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (has_nndist.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_nndist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_61835 (h0 : functor.add_const (topological_space (has_add ennreal)) ennreal) : @preconnected_space.{0} (has_add.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_61836 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_61837 (h0 : not (function.extfun (finset Type) (has_mem.mem linarith.comp) -> false)) : @separated_space.{0} linarith.comp (@finset.pi.empty.{1 0} Type uniform_space.{0} linarith.comp (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp) (@classical.by_contradiction'.{0} (function.extfun.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) linarith.comp)) h0) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_61838 (h0 : topological_space (sub_neg_monoid (has_Inf pos))) : topological_space.separable_space (sub_neg_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_61839 (h0 : functor.add_const (function.extfun Type list) linarith.comp) : palindrome (function.extfun_app (functor.add_const.run h0) (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_61840 (h0 : set (add_comm_semigroup (add_comm_semigroup (add_comm_semigroup string.iterator_imp)) -> char)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_61841 (h0 : function.extfun nat fin) : @strong_rank_condition.{1} (normed_lattice_add_comm_group.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (normed_lattice_add_comm_group.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_61842 (h0 : group (simple_graph unsigned)) : group.fg (simple_graph unsigned) := sorry --non-trivial
lemma new_lemma_61843 (h0 : ring (distrib_lattice string_imp)) : rank_condition (distrib_lattice string_imp) := sorry --non-trivial
lemma new_lemma_61844 (h0 : not (function.extfun (Type 1) filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) (plift unsigned)) := sorry --non-trivial
lemma new_lemma_61845 (h0 : uniform_space (normed_comm_ring pos)) : complete_space (normed_comm_ring pos) := sorry --non-trivial
lemma new_lemma_61846 (h0 : uniform_space (dlist char)) : complete_space (dlist char) := sorry --non-trivial
lemma new_lemma_61847 (h0 : functor.add_const (topological_space (finset unsigned)) linarith.comp) : @t0_space.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_61848 (h0 : finset (generalized_boolean_algebra (has_add (has_add (boolean_algebra name))))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_61849 (h0 : topological_space (normed_comm_ring (option (option num)))) : discrete_topology (normed_comm_ring (option (option num))) := sorry --non-trivial
lemma new_lemma_61850 (h0 : not (topological_space (with_zero to_additive.value_type) -> false)) : @path_connected_space.{0} (with_zero.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (with_zero.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_61851 (h0 : function.extfun Type group) : @group.fg.{0} (free_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (free_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_61852 (h0 : functor.add_const (topological_space (has_star empty)) congr_arg_kind) : @totally_disconnected_space.{0} (has_star.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_61853 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preconnected_space.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_61854 (h0 : functor.add_const (topological_space (has_neg unsigned)) pos) : @preconnected_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) pos h0)  := sorry --non-trivial
lemma new_lemma_61855 (h0 : functor.add_const (ring (preorder congr_arg_kind)) num) : @rank_condition.{0} (preorder.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (ring.{0} (preorder.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_61856 (h0 : ring (complete_semilattice_Sup linarith.ineq)) : rank_condition (complete_semilattice_Sup linarith.ineq) := sorry --non-trivial
lemma new_lemma_61857 (h0 : functor.add_const (topological_space (ordered_comm_ring linarith.comp)) linarith.comp) : @t0_space.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_ring.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_61858 (h0 : functor.comp topological_space complete_distrib_lattice name) : @normal_space.{0} (complete_distrib_lattice.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} complete_distrib_lattice.{0} name h0)  := sorry --non-trivial
lemma new_lemma_61859 (h0 : topological_space (has_Inf (ring name))) : t1_space (has_Inf (ring name)) := sorry --non-trivial
lemma new_lemma_61860 (h0 : add_group (has_pos_part (has_pos_part name))) : is_add_cyclic (has_pos_part (has_pos_part name)) := sorry --non-trivial
lemma new_lemma_61861 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem ring)) : @strong_rank_condition.{0} (has_top.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) ring.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) ring.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_top.{0} num))  := sorry --non-trivial
lemma new_lemma_61862 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} linarith.comp_source (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_61863 (h0 : cancel_comm_monoid_with_zero (add_cancel_monoid (finset (finset environment.implicit_infer_kind)))) : unique_factorization_monoid (add_cancel_monoid (finset (finset environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_61864 (h0 : topological_space (has_bot Type)) : preconnected_space (has_bot Type) := sorry --non-trivial
lemma new_lemma_61865 (h0 : ring (semigroup pos)) : is_principal_ideal_ring (semigroup pos) := sorry --non-trivial
lemma new_lemma_61866 (h0 : functor.add_const (function.extfun Type topological_space) (has_Inf linarith.comp)) : @path_connected_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_Inf.{0} linarith.comp) h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_61867 (h0 : not (cancel_comm_monoid_with_zero (add_group num) -> false)) : @unique_factorization_monoid.{0} (add_group.{0} num) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (add_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_61868 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) (has_neg pos)) : @regular_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_61869 (h0 : topological_space (add_comm_semigroup enat)) (h1 : add_group (add_comm_semigroup enat)) : topological_add_group (add_comm_semigroup enat) := sorry --non-trivial
lemma new_lemma_61870 (h0 : uniform_space (has_pos_part (has_Inf (ordered_comm_monoid Type)))) : complete_space (has_pos_part (has_Inf (ordered_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_61871 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (normed_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (normed_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_61872 (h0 : topological_space (ring (has_neg (has_neg name)))) : preconnected_space (ring (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_61873 (h0 : functor.add_const (semiring (group_with_zero num)) congr_arg_kind) : @is_noetherian_ring.{0} (group_with_zero.{0} num) (@functor.add_const.run.{0 0} (semiring.{0} (group_with_zero.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_61874 (h0 : function.extfun Type group) : @is_cyclic.{0} (ordered_cancel_add_comm_monoid.{0} empty) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_cancel_add_comm_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_61875 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (denumerable.{0} linarith.ineq) (@function.extfun_app.{2 1} Type monoid.{0} h0 (denumerable.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_61876 (h0 : functor.add_const (add_group (plift empty)) empty) : @is_add_cyclic.{1} (plift.{1} empty) (@functor.add_const.run.{1 0} (add_group.{1} (plift.{1} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_61877 (h0 : function.extfun Type (functor.comp topological_space canonically_ordered_comm_semiring)) : @irreducible_space.{0} (canonically_ordered_comm_semiring.{0} unsigned) (@functor.comp.run.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0} unsigned (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} canonically_ordered_comm_semiring.{0}) h0 unsigned))  := sorry --non-trivial
lemma new_lemma_61878 (h0 : functor.add_const (complete_lattice (comm_group pos)) (has_to_string Type)) : @is_compactly_generated.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (comm_group.{0} pos)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_61879 (h1 : not (topological_space (semiring num) -> false)) : @totally_separated_space.{0} (semiring.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} num)) h1)  := sorry --non-trivial
lemma new_lemma_61880 (h0 : functor.add_const (function.extfun Type group) pos) : @group.fg.{0} pos (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) pos h0) pos)  := sorry --non-trivial
lemma new_lemma_61881 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (boolean_algebra.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_61882 (h0 : functor.add_const (topological_space (semigroup environment.implicit_infer_kind)) pos) : @topological_space.separable_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_61883 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_61884 (h0 : functor.add_const (ring (semigroup pos)) pos) : @strong_rank_condition.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (semigroup.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_61885 (h0 : functor.add_const (functor.add_const (ring pos) Type) Type) : @is_domain.{0} pos (@functor.add_const.run.{0 1} (ring.{0} pos) Type (@functor.add_const.run.{0 1} (functor.add_const.{0 1} (ring.{0} pos) Type) Type h0))  := sorry --non-trivial
lemma new_lemma_61886 (h0 : semiring (finset (finset (finset pos)))) : is_noetherian_ring (finset (finset (finset pos))) := sorry --non-trivial
lemma new_lemma_61887 (h1 : ring (encodable string_imp)) : rank_condition (encodable string_imp) := sorry --non-trivial
lemma new_lemma_61888 (h0 : ordered_comm_monoid (has_to_string (has_pos_part (boolean_algebra.core linarith.comp)))) : has_exists_mul_of_le (has_to_string (has_pos_part (boolean_algebra.core linarith.comp))) := sorry --non-trivial
lemma new_lemma_61889 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (has_nndist.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_61890 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_bot.{0} unsigned) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_61891 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring Type)) name) : @is_principal_ideal_ring.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (canonically_ordered_comm_semiring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_61892 (h2 : ring (random_gen (distrib_lattice (random_gen fun_info)))) : is_domain (random_gen (distrib_lattice (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_61893 (h0 : ring (dlist (has_nnnorm fun_info))) : is_domain (dlist (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_61894 (h0 : group (boolean_algebra (comm_group ennreal))) : is_cyclic (boolean_algebra (comm_group ennreal)) := sorry --non-trivial
lemma new_lemma_61895 (h0 : has_add (add_comm_monoid (option pos)) -> has_add (add_comm_monoid (option pos)) -> Prop) : is_symm (has_add (add_comm_monoid (option pos))) h0 := sorry --non-trivial
lemma new_lemma_61896 (h0 : ring (measurable_space.dynkin_system (semiring empty))) : is_principal_ideal_ring (measurable_space.dynkin_system (semiring empty)) := sorry --non-trivial
lemma new_lemma_61897 (h0 : ring (linear_ordered_add_comm_group (semi_normed_ring string_imp))) : is_domain (linear_ordered_add_comm_group (semi_normed_ring string_imp)) := sorry --non-trivial
lemma new_lemma_61898 (h0 : group (has_nndist (option ennreal))) : is_simple_group (has_nndist (option ennreal)) := sorry --non-trivial
lemma new_lemma_61899 (h1 : not (complete_lattice (has_ssubset char) -> false)) : @is_compactly_generated.{0} (has_ssubset.{0} char) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_ssubset.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_61900 (h0 : topological_space (has_top (semiring linarith.comp))) : totally_separated_space (has_top (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_61901 (h0 : not (topological_space (linear_ordered_comm_ring empty) -> false)) : @t0_space.{0} (linear_ordered_comm_ring.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_ring.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_61902 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_cancel_monoid ennreal)) unsigned) : @unique_factorization_monoid.{0} (add_cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (add_cancel_monoid.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_61903 (h0 : function.extfun Type group) : @is_simple_group.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_61904 (h0 : topological_space (linear_ordered_semiring (random_gen fun_info))) : totally_disconnected_space (linear_ordered_semiring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_61905 (h0 : add_group (denumerable (comm_ring (metric_space char)))) : is_add_cyclic (denumerable (comm_ring (metric_space char))) := sorry --non-trivial
lemma new_lemma_61906 (h0 : group (normed_group (has_inv (has_inv (has_inv linarith.ineq))))) : is_cyclic (normed_group (has_inv (has_inv (has_inv linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_61907 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (complete_semilattice_Sup.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (complete_semilattice_Sup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_61908 (h0 : set (mul_one_class string.iterator_imp -> linarith.ineq)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_61909 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (pseudo_metric_space.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} empty))  := sorry --non-trivial
lemma new_lemma_61910 (h0 : topological_space (ordered_ring (semiring (semiring empty)))) : t1_space (ordered_ring (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_61911 (h0 : ring (linear_ordered_comm_group_with_zero (random_gen (random_gen (random_gen char))))) : is_domain (linear_ordered_comm_group_with_zero (random_gen (random_gen (random_gen char)))) := sorry --non-trivial
lemma new_lemma_61912 (h0 : functor.add_const (topological_space (has_Inf pos)) linarith.comp) : @irreducible_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_61913 (h0 : prod (has_ssubset congr_arg_kind) (has_ssubset congr_arg_kind)) : set.diagonal (has_ssubset congr_arg_kind) h0 := sorry --non-trivial
lemma new_lemma_61914 (h0 : function.extfun Type ring) : @rank_condition.{0} (comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_61915 (h0 : topological_space (monoid (option unsigned))) : t0_space (monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_61916 (h0 : functor.add_const (topological_space (has_Inf Type)) (has_neg pos)) : @sequential_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_Inf.{1} Type)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_61917 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_61918 (h0 : functor.add_const (topological_space (left_cancel_monoid congr_arg_kind)) num) : @locally_compact_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_61919 (h0 : add_monoid (bin_tree num)) : add_monoid.fg (bin_tree num) := sorry --non-trivial
lemma new_lemma_61920 (h0 : not (function.extfun Type filter -> false)) : filter.ne_bot (function.extfun_app (classical.by_contradiction' h0) real.angle) := sorry --non-trivial
lemma new_lemma_61921 (h0 : complete_lattice (finset (semigroup (semigroup unsigned)))) : is_compactly_generated (finset (semigroup (semigroup unsigned))) := sorry --non-trivial
lemma new_lemma_61922 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (mul_zero_class.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (mul_zero_class.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_61923 (h0 : ring (cancel_monoid name)) : rank_condition (cancel_monoid name) := sorry --non-trivial
lemma new_lemma_61924 (h0 : function.extfun Type group) : @is_simple_group.{0} (ordered_comm_monoid.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_comm_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_61925 (h0 : topological_space (has_bot (has_Inf (has_add (has_pos_part Type))))) : totally_disconnected_space (has_bot (has_Inf (has_add (has_pos_part Type)))) := sorry --non-trivial
lemma new_lemma_61926 (h0 : topological_space (normed_linear_ordered_group (option (option (option unsigned))))) : t1_space (normed_linear_ordered_group (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_61927 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @has_exists_mul_of_le.{1} (ordered_comm_monoid.{1} Type) (@matrix.vec_empty.{1} (ordered_comm_monoid.{1} (ordered_comm_monoid.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero))))  := sorry --non-trivial
lemma new_lemma_61928 (h0 : not (uniform_space (boolean_algebra unsigned) -> false)) : @separated_space.{0} (boolean_algebra.{0} unsigned) (@classical.by_contradiction'.{1} (uniform_space.{0} (boolean_algebra.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_61929 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (complete_linear_order.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (complete_linear_order.{0} num))  := sorry --non-trivial
lemma new_lemma_61930 (h0 : function.extfun Type (functor.add_const (topological_space (semigroup empty)))) : @irreducible_space.{0} (semigroup.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (semigroup.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_61931 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_61932 (h0 : finset (id pos)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_61933 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_61934 (h0 : topological_space to_additive.value_type) : locally_compact_space to_additive.value_type := sorry --non-trivial
lemma new_lemma_61935 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_61936 (h0 : function.extfun Type (functor.add_const (ring Type))) : @rank_condition.{1} Type (@functor.add_const.run.{1 0} (ring.{1} Type) name (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (ring.{1} Type)) h0 name))  := sorry --non-trivial
lemma new_lemma_61937 (h0 : topological_space (has_union (metric_space empty))) : locally_compact_space (has_union (metric_space empty)) := sorry --non-trivial
lemma new_lemma_61938 (h0 : uniform_space (topological_space linarith.comp_source)) : complete_space (topological_space linarith.comp_source) := sorry --non-trivial
lemma new_lemma_61939 (h0 : functor.add_const (ring (boolean_algebra.core environment.implicit_infer_kind)) environment.implicit_infer_kind) : @is_principal_ideal_ring.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (boolean_algebra.core.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_61940 (h0 : topological_space (has_nndist (option (option (option empty))))) : t1_space (has_nndist (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_61941 (h0 : group (has_norm (random_gen (with_bot (with_bot to_additive.value_type))))) : group.fg (has_norm (random_gen (with_bot (with_bot to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_61942 (h0 : function.extfun (Type 1) cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{1} (complete_distrib_lattice.{1} Type) (@function.extfun_app.{3 2} (Type 1) cancel_comm_monoid_with_zero.{1} h0 (complete_distrib_lattice.{1} Type))  := sorry --non-trivial
lemma new_lemma_61943 (h0 : group (option ennreal)) : normalizer_condition (option ennreal) := sorry --non-trivial
lemma new_lemma_61944 (h0 : ring (has_union (semiring congr_arg_kind))) : is_domain (has_union (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_61945 (h0 : functor.add_const (function.extfun Type cancel_comm_monoid_with_zero) Type) : @unique_factorization_monoid.{0} (finset.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type cancel_comm_monoid_with_zero.{0}) Type h0) (finset.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_61946 (h0 : function.extfun Type ring) : @rank_condition.{0} (with_bot.{0} (random_gen.{0} linarith.comp_source)) (@function.extfun_app.{2 1} Type ring.{0} h0 (with_bot.{0} (random_gen.{0} linarith.comp_source)))  := sorry --non-trivial
lemma new_lemma_61947 (h0 : topological_space (boolean_algebra (has_pos_part (has_Inf (has_pos_part Type))))) : totally_disconnected_space (boolean_algebra (has_pos_part (has_Inf (has_pos_part Type)))) := sorry --non-trivial
lemma new_lemma_61948 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_61949 (h0 : not (filter (with_zero linarith.comp_source) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_61950 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_61951 (h0 : functor.add_const (topological_space (mul_zero_class num)) congr_arg_kind) : @irreducible_space.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_61952 (h0 : group (semigroup (finset environment.implicit_infer_kind))) : is_cyclic (semigroup (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_61953 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @irreducible_space.{0} (comm_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_61954 (h0 : functor.add_const (list (boolean_algebra.core linarith.comp)) environment.implicit_infer_kind) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_61955 (h0 : function.extfun (finset Type) (has_mem.mem (has_emptyc num))) : @is_domain.{0} (has_emptyc.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (has_emptyc.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_emptyc.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_61956 (h1 : complete_lattice (has_nnnorm reducibility_hints)) : complete_lattice.is_Sup_finite_compact (has_nnnorm reducibility_hints) := sorry --non-trivial
lemma new_lemma_61957 (h0 : fin has_zero.zero) : @irreducible_space.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_pos_part.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_61958 (h0 : complete_lattice (monoid_with_zero (option (option ennreal)))) : is_atomistic (monoid_with_zero (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_61959 (h0 : fin has_zero.zero) : @topological_space.separable_space.{1} (has_add.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (has_add.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_61960 (h0 : group (measurable_space.dynkin_system unsigned)) : group.fg (measurable_space.dynkin_system unsigned) := sorry --non-trivial
lemma new_lemma_61961 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_61962 (h0 : ordered_add_comm_monoid (add_comm_monoid (has_to_string (has_neg (has_to_string Type))))) : archimedean (add_comm_monoid (has_to_string (has_neg (has_to_string Type)))) := sorry --non-trivial
lemma new_lemma_61963 (h0 : functor.add_const (monoid (ordered_cancel_add_comm_monoid unsigned)) unsigned) : @monoid.fg.{0} (ordered_cancel_add_comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (ordered_cancel_add_comm_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_61964 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_61965 (h1 h2 : multiset (add_comm_semigroup enat)) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_61966 (h0 : functor.add_const (topological_space (ring linarith.comp)) (ring Type)) : @regular_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} linarith.comp)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_61967 (h0 : function.extfun Type (functor.add_const (ordered_add_comm_monoid pos))) : @archimedean.{0} pos (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} pos) ennreal (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} pos)) h0 ennreal))  := sorry --non-trivial
lemma new_lemma_61968 (h0 : functor.add_const (topological_space (normed_linear_ordered_group unsigned)) congr_arg_kind) : @discrete_topology.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_61969 (h0 : topological_space (has_norm (has_emptyc (has_emptyc (has_top linarith.ineq))))) : locally_compact_space (has_norm (has_emptyc (has_emptyc (has_top linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_61970 (h0 : topological_space (add_cancel_monoid (option unsigned))) : normal_space (add_cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_61971 (h0 : functor.add_const (ring (ordered_comm_ring Type)) (has_neg pos)) : @is_principal_ideal_ring.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (ordered_comm_ring.{1} Type)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_61972 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (normed_lattice_add_comm_group.{0} real) (@function.extfun_app.{2 1} Type add_group.{0} h0 (normed_lattice_add_comm_group.{0} real))  := sorry --non-trivial
lemma new_lemma_61973 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_61974 (h0 : group (canonically_linear_ordered_monoid (option name))) : group.fg (canonically_linear_ordered_monoid (option name)) := sorry --non-trivial
lemma new_lemma_61975 (h0 : not (topological_space (uniform_space (has_nnnorm (mul_one_class linarith.ineq))) -> false)) : @path_connected_space.{0} (uniform_space.{0} (has_nnnorm.{0} (mul_one_class.{0} linarith.ineq))) (@classical.by_contradiction'.{1} (topological_space.{0} (uniform_space.{0} (has_nnnorm.{0} (mul_one_class.{0} linarith.ineq)))) h0)  := sorry --non-trivial
lemma new_lemma_61976 (h0 : complete_lattice (simple_graph linarith.comp_source)) : is_compactly_generated (simple_graph linarith.comp_source) := sorry --non-trivial
lemma new_lemma_61977 (h0 : char) (h1 : set char) : set.mem h0 h1 := sorry --non-trivial
lemma new_lemma_61978 (h0 : complete_lattice (comm_semigroup (has_pos_part real))) : is_atomistic (comm_semigroup (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_61979 (h0 : canonically_ordered_monoid (sub_neg_monoid real) -> canonically_ordered_monoid (sub_neg_monoid real) -> Prop) : well_founded h0 := sorry --non-trivial
lemma new_lemma_61980 (h0 : topological_space (random_gen (mul_one_class char))) : path_connected_space (random_gen (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_61981 (h1 : not (topological_space (has_nnnorm string_imp) -> false)) : @t0_space.{0} (has_nnnorm.{0} string_imp) (@classical.by_contradiction'.{1} (topological_space.{0} (has_nnnorm.{0} string_imp)) h1)  := sorry --non-trivial
lemma new_lemma_61982 (h0 : topological_space (complete_distrib_lattice (option ennreal))) : preirreducible_space (complete_distrib_lattice (option ennreal)) := sorry --non-trivial
lemma new_lemma_61983 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_61984 (h0 : function.extfun (Type 1) group) : @is_cyclic.{1} (sub_neg_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (sub_neg_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_61985 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (boolean_algebra.core pos)) := sorry --non-trivial
lemma new_lemma_61986 (h0 : group (random_gen (has_top linarith.ineq))) : is_cyclic (random_gen (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_61987 (h0 : ring (has_top (has_nnnorm (has_append (linear_ordered_add_comm_group fun_info))))) : strong_rank_condition (has_top (has_nnnorm (has_append (linear_ordered_add_comm_group fun_info)))) := sorry --non-trivial
lemma new_lemma_61988 (h0 : functor.add_const (topological_space (has_neg name)) linarith.comp) : @topological_space.separable_space.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_61989 (h0 : functor.add_const (group (has_Inf linarith.comp)) pos) : @normalizer_condition.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (has_Inf.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_61990 (h0 : uniform_space (normed_comm_ring (ring (finset (has_nndist linarith.comp))))) : complete_space (normed_comm_ring (ring (finset (has_nndist linarith.comp)))) := sorry --non-trivial
lemma new_lemma_61991 (h0 : topological_space (has_to_string (finset (has_nndist (finset name))))) : normal_space (has_to_string (finset (has_nndist (finset name)))) := sorry --non-trivial
lemma new_lemma_61992 (h0 : uniform_space (normed_group (has_norm (has_norm linarith.comp)))) : separated_space (normed_group (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_61993 (h2 : ring linarith.ineq) : is_domain linarith.ineq := sorry --non-trivial
lemma new_lemma_61994 (h0 : ring (has_top (id (random_gen linarith.comp_source)))) : rank_condition (has_top (id (random_gen linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_61995 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (linear_ordered_add_comm_group.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_ordered_add_comm_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_61996 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (group_with_zero.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_61997 (h0 : ordered_add_comm_monoid (has_bot (has_Inf (has_Inf Type)))) : archimedean (has_bot (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_61998 (h0 : functor.add_const (group (complete_distrib_lattice pos)) pos) : @is_simple_group.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_61999 (h0 : bin_tree (semiring congr_arg_kind) -> bin_tree (semiring congr_arg_kind) -> Prop) : is_strict_order (bin_tree (semiring congr_arg_kind)) h0 := sorry --non-trivial
lemma new_lemma_62000 (h0 : has_mem.mem (has_emptyc num) has_emptyc.emptyc) : @group.fg.{0} (has_emptyc.{0} num) (@finset.pi.empty.{1 0} Type group.{0} (has_emptyc.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_62001 (h0 : uniform_space (has_norm (random_gen congr_arg_kind))) : separated_space (has_norm (random_gen congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_62002 (h0 : group (has_Inf (has_neg Type))) : group.fg (has_Inf (has_neg Type)) := sorry --non-trivial
lemma new_lemma_62003 (h0 : add_monoid (monoid (option (option (option unsigned))))) : add_monoid.fg (monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_62004 (h0 : set (distrib string_imp)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_62005 (h0 : functor.add_const (ordered_add_comm_monoid (normed_comm_ring environment.implicit_infer_kind)) Type) : @archimedean.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ordered_add_comm_monoid.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_62006 (h0 : functor.add_const (topological_space (finset Type)) environment.implicit_infer_kind) : @path_connected_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_62007 (h0 : functor.add_const (function.extfun Type add_group) pos) : @is_add_cyclic.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_group.{0}) pos h0) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_62008 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} znum (@function.extfun_app.{2 1} Type topological_space.{0} h0 znum)  := sorry --non-trivial
lemma new_lemma_62009 (h0 : functor.add_const (add_group (has_neg linarith.comp)) (has_to_string Type)) : @is_add_cyclic.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_group.{0} (has_neg.{0} linarith.comp)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_62010 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_62011 (h0 : topological_space (normed_group (has_norm (measurable_space (has_top linarith.comp))))) : normal_space (normed_group (has_norm (measurable_space (has_top linarith.comp)))) := sorry --non-trivial
lemma new_lemma_62012 (h0 : functor.add_const (topological_space (finset Type)) Type) : @path_connected_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (finset.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_62013 (h1 : has_mem.mem (normed_group congr_arg_kind) has_emptyc.emptyc) : @t0_space.{0} (normed_group.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type topological_space.{0} (normed_group.{0} congr_arg_kind) h1)  := sorry --non-trivial
lemma new_lemma_62014 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_62015 (h0 : ordered_add_comm_monoid (has_nndist (has_add pos))) : archimedean (has_nndist (has_add pos)) := sorry --non-trivial
lemma new_lemma_62016 (h0 : group (with_zero fun_info)) : is_cyclic (with_zero fun_info) := sorry --non-trivial
lemma new_lemma_62017 (h0 : topological_space (measurable_space.dynkin_system (semiring (semiring num)))) : discrete_topology (measurable_space.dynkin_system (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_62018 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (linear_ordered_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_62019 (h0 : topological_space (pseudo_metric_space pos)) : loc_path_connected_space (pseudo_metric_space pos) := sorry --non-trivial
lemma new_lemma_62020 (h0 : ring (with_zero (has_inv linarith.ineq))) : is_domain (with_zero (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_62021 (h0 : topological_space (has_dist ennreal)) : path_connected_space (has_dist ennreal) := sorry --non-trivial
lemma new_lemma_62022 (h0 : not (filter (has_add linarith.comp_source) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_62023 (h0 : group (has_to_string name)) : is_simple_group (has_to_string name) := sorry --non-trivial
lemma new_lemma_62024 (h0 : ring (mul_one_class (add_comm_semigroup (add_comm_semigroup char)))) : strong_rank_condition (mul_one_class (add_comm_semigroup (add_comm_semigroup char))) := sorry --non-trivial
lemma new_lemma_62025 (h0 : has_mem.mem Type has_emptyc.emptyc) : @normalizer_condition.{1} Type (@finset.pi.empty.{2 1} (Type 1) group.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_62026 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_62027 (h0 : function.extfun Type topological_space) : @t0_space.{0} (normed_linear_ordered_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_linear_ordered_group.{0} num))  := sorry --non-trivial
lemma new_lemma_62028 (h0 : functor.add_const (list (finset linarith.comp)) (has_neg linarith.comp)) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_62029 (h0 : cancel_comm_monoid_with_zero (has_edist unsigned)) : unique_factorization_monoid (has_edist unsigned) := sorry --non-trivial
lemma new_lemma_62030 (h0 : topological_space (complete_semilattice_Sup (random_gen (measurable_space Type)))) : totally_disconnected_space (complete_semilattice_Sup (random_gen (measurable_space Type))) := sorry --non-trivial
lemma new_lemma_62031 (h0 : has_mem.mem (random_gen unsigned) has_emptyc.emptyc) : @normalizer_condition.{0} (random_gen.{0} unsigned) (@finset.pi.empty.{1 0} Type group.{0} (random_gen.{0} unsigned) h0)  := sorry --non-trivial
lemma new_lemma_62032 (h0 : functor.add_const (topological_space (has_add unsigned)) linarith.comp) : @topological_space.separable_space.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_62033 (h0 : measurable_space fun_info) (h1 : filter fun_info) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_62034 (h0 : functor.add_const (topological_space (linear_ordered_field pos)) name) : @totally_disconnected_space.{0} (linear_ordered_field.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_field.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_62035 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (canonically_ordered_add_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (canonically_ordered_add_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_62036 (h0 : filter (canonically_ordered_monoid real)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_62037 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (with_bot.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 group.{0}) (with_bot.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_62038 (h0 : set (uniform_space enat)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_62039 (h0 : function.extfun Type (functor.add_const (complete_lattice (add_right_cancel_monoid empty)))) : @complete_lattice.is_Sup_finite_compact.{0} (add_right_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_right_cancel_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (add_right_cancel_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_62040 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (comm_group.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (comm_group.{0} pos))  := sorry --non-trivial
lemma new_lemma_62041 (h0 : function.extfun (finset Type) (has_mem.mem (has_top empty))) : @path_connected_space.{0} (has_top.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_62042 (h0 : not (function.extfun Type semiring -> false)) : @is_noetherian_ring.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 1} Type semiring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type semiring.{0}) h0) (linear_ordered_semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_62043 (h0 : ring (has_nndist (has_pos_part (finset pos)))) : rank_condition (has_nndist (has_pos_part (finset pos))) := sorry --non-trivial
lemma new_lemma_62044 (h0 : functor.add_const (fin has_zero.zero) real) : @t1_space.{0} (canonically_ordered_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} real)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) real h0))  := sorry --non-trivial
lemma new_lemma_62045 (h0 : not (group (left_cancel_semigroup congr_arg_kind) -> false)) : @normalizer_condition.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (left_cancel_semigroup.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_62046 (h0 : semiring (is_R_or_C congr_arg_kind)) : is_noetherian_ring (is_R_or_C congr_arg_kind) := sorry --non-trivial
lemma new_lemma_62047 (h0 : topological_space (complete_distrib_lattice Type)) : t0_space (complete_distrib_lattice Type) := sorry --non-trivial
lemma new_lemma_62048 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @sequential_space.{0} (sub_neg_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (sub_neg_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_62049 (h0 : topological_space (has_add pos)) : totally_disconnected_space (has_add pos) := sorry --non-trivial
lemma new_lemma_62050 (h0 : measurable_space (uniform_space linarith.ineq)) (h1 : filter (uniform_space linarith.ineq)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_62051 (h0 : functor.add_const (monoid (has_zero name)) environment.implicit_infer_kind) : @monoid.fg.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (monoid.{0} (has_zero.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_62052 (h2 : group (with_zero (has_nnnorm to_additive.value_type))) : is_cyclic (with_zero (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_62053 (h0 : complete_lattice (has_add name)) : is_atomistic (has_add name) := sorry --non-trivial
lemma new_lemma_62054 (h0 : topological_space (ordered_ring (option unsigned))) : totally_separated_space (ordered_ring (option unsigned)) := sorry --non-trivial
lemma new_lemma_62055 (h0 : complete_lattice (add_cancel_monoid environment.implicit_infer_kind)) : is_atomistic (add_cancel_monoid environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_62056 (h0 : group (has_emptyc (random_gen (random_gen (random_gen linarith.comp_source))))) : normalizer_condition (has_emptyc (random_gen (random_gen (random_gen linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_62057 (h0 : topological_space (is_R_or_C (semiring (semiring empty)))) : t0_space (is_R_or_C (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_62058 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (normed_group.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (normed_group.{0} num))  := sorry --non-trivial
lemma new_lemma_62059 (h0 : ring (has_compl (has_ssubset (has_nnnorm reducibility_hints)))) : rank_condition (has_compl (has_ssubset (has_nnnorm reducibility_hints))) := sorry --non-trivial
lemma new_lemma_62060 (h0 : topological_space (has_nndist (comm_group Type))) : t0_space (has_nndist (comm_group Type)) := sorry --non-trivial
lemma new_lemma_62061 (h0 : prod (linear_ordered_cancel_comm_monoid (semiring empty)) (linear_ordered_cancel_comm_monoid (semiring empty))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_62062 (h1 : complete_lattice (comm_ring fun_info)) : complete_lattice.is_Sup_finite_compact (comm_ring fun_info) := sorry --non-trivial
lemma new_lemma_62063 (h0 : topological_space (with_one (random_gen (random_gen fun_info)))) : totally_disconnected_space (with_one (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_62064 (h0 : group (normed_comm_ring (has_add pos))) : is_cyclic (normed_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_62065 (h0 : functor.add_const (topological_space (has_Inf name)) pos) : @sequential_space.{0} (has_Inf.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_62066 (h0 : topological_space (finset (option (option empty)))) : totally_separated_space (finset (option (option empty))) := sorry --non-trivial
lemma new_lemma_62067 (h0 : functor.add_const (add_monoid (ring Type)) name) : @add_monoid.fg.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (add_monoid.{1} (ring.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_62068 (h0 : topological_space (has_bot (option empty))) : t1_space (has_bot (option empty)) := sorry --non-trivial
lemma new_lemma_62069 (h0 : topological_space (random_gen (random_gen (semiring congr_arg_kind)))) : irreducible_space (random_gen (random_gen (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_62070 (h0 : ring (semi_normed_ring (mul_one_class (mul_one_class linarith.comp_source)))) : is_domain (semi_normed_ring (mul_one_class (mul_one_class linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_62071 (h0 : ring (ordered_comm_monoid Type)) : is_principal_ideal_ring (ordered_comm_monoid Type) := sorry --non-trivial
lemma new_lemma_62072 (h0 : functor.add_const (function.extfun Type topological_space) (finset pos)) : @totally_disconnected_space.{0} (has_nndist.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (finset.{0} pos) h0) (has_nndist.{0} pos))  := sorry --non-trivial
lemma new_lemma_62073 (h0 : ring (sub_neg_monoid (has_add pos))) : is_domain (sub_neg_monoid (has_add pos)) := sorry --non-trivial
lemma new_lemma_62074 (h0 : function.extfun Type (functor.add_const (topological_space (bin_tree empty)))) : @locally_compact_space.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (bin_tree.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (bin_tree.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_62075 (h0 : functor.add_const (topological_space (has_nndist linarith.comp)) linarith.comp) : @irreducible_space.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_62076 (h0 : not (topological_space (linear_ordered_comm_ring unsigned) -> false)) : @normal_space.{0} (linear_ordered_comm_ring.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_comm_ring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_62077 (h0 : functor.add_const (group (add_cancel_monoid pos)) (has_Inf (has_Inf name))) : @is_simple_group.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} pos)) (has_Inf.{0} (has_Inf.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_62078 (h0 : topological_space (complete_distrib_lattice (option pos))) : sequential_space (complete_distrib_lattice (option pos)) := sorry --non-trivial
lemma new_lemma_62079 (h0 : topological_space (has_top (has_norm num))) : totally_disconnected_space (has_top (has_norm num)) := sorry --non-trivial
lemma new_lemma_62080 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preconnected_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_62081 (h0 : monoid (ordered_cancel_add_comm_monoid (option (option (option ennreal))))) : monoid.fg (ordered_cancel_add_comm_monoid (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_62082 (h0 : functor.add_const (group (complete_distrib_lattice pos)) (has_neg pos)) : @is_simple_group.{0} (complete_distrib_lattice.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (complete_distrib_lattice.{0} pos)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_62083 (h0 : function.extfun (finset Type) (has_mem.mem (random_gen num))) : @separated_space.{0} (random_gen.{0} num) (@finset.pi.empty.{1 0} Type uniform_space.{0} (random_gen.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (random_gen.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_62084 (h0 : add_monoid (normed_group (has_norm linarith.comp))) : add_monoid.fg (normed_group (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_62085 (h0 : uniform_space (add_comm_semigroup (mul_one_class environment.projection_info))) : complete_space (add_comm_semigroup (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_62086 (h0 : topological_space (with_bot (random_gen to_additive.value_type))) : irreducible_space (with_bot (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_62087 (h1 : topological_space (has_emptyc (has_top congr_arg_kind))) : path_connected_space (has_emptyc (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_62088 (h0 : pnat) (h1 : thunk (list pnat)) (h2 : nat) (h3 : vector pnat (has_add.add h2 has_one.one)) : pnat.coprime (@list.ilast'.{0} pnat h0 (@trace_call_stack.{0} (list.{0} pnat) h1)) (@vector.last.{0} h2 pnat h3)  := sorry --non-trivial
lemma new_lemma_62089 (h0 : topological_space (has_nndist (option (option (option (option ennreal)))))) : irreducible_space (has_nndist (option (option (option (option ennreal))))) := sorry --non-trivial
lemma new_lemma_62090 (h0 : group (has_nndist (has_nndist name))) : is_simple_group (has_nndist (has_nndist name)) := sorry --non-trivial
lemma new_lemma_62091 (h0 : function.extfun Type topological_space) : @regular_space.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_62092 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (semiring.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semiring.{0} num))  := sorry --non-trivial
lemma new_lemma_62093 (h0 : group (canonically_ordered_comm_semiring (option (has_add environment.implicit_infer_kind)))) : group.fg (canonically_ordered_comm_semiring (option (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_62094 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (has_neg.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} num))  := sorry --non-trivial
lemma new_lemma_62095 (h0 : topological_space (has_add real)) : preconnected_space (has_add real) := sorry --non-trivial
lemma new_lemma_62096 (h0 : list (monoid (option ennreal))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_62097 (h0 : semiring (add_group (semiring (has_top congr_arg_kind)))) : is_noetherian_ring (add_group (semiring (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_62098 (h0 : fin has_zero.zero) : @monoid.fg.{0} (ordered_comm_ring.{0} real) (@matrix.vec_empty.{0} (monoid.{0} (ordered_comm_ring.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_62099 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (canonically_linear_ordered_monoid.{0} num) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (canonically_linear_ordered_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_62100 (h0 : topological_space (mul_one_class string.iterator_imp)) (h1 : preorder (mul_one_class string.iterator_imp)) : order_topology (mul_one_class string.iterator_imp) := sorry --non-trivial
lemma new_lemma_62101 (h0 : functor.comp filter normed_linear_ordered_group name) : countable_Inter_filter (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_62102 (h0 : function.extfun Type topological_space) : @normal_space.{0} (has_nndist.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nndist.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_62103 (h0 : monoid (add_comm_monoid (boolean_algebra linarith.comp))) : monoid.fg (add_comm_monoid (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_62104 (h0 : topological_space (normed_lattice_add_comm_group real)) : irreducible_space (normed_lattice_add_comm_group real) := sorry --non-trivial
lemma new_lemma_62105 (h0 : add_group (has_div (mul_one_class (mul_one_class linarith.ineq)))) : is_add_cyclic (has_div (mul_one_class (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_62106 (h0 : not (group (topological_space (has_nnnorm (has_nnnorm (random_gen char)))) -> false)) : @is_cyclic.{0} (topological_space.{0} (has_nnnorm.{0} (has_nnnorm.{0} (random_gen.{0} char)))) (@classical.by_contradiction'.{1} (group.{0} (topological_space.{0} (has_nnnorm.{0} (has_nnnorm.{0} (random_gen.{0} char))))) h0)  := sorry --non-trivial
lemma new_lemma_62107 (h0 : topological_space (boolean_algebra.core (has_neg (has_neg (normed_comm_ring (has_neg (has_neg Type))))))) : t1_space (boolean_algebra.core (has_neg (has_neg (normed_comm_ring (has_neg (has_neg Type)))))) := sorry --non-trivial
lemma new_lemma_62108 (h0 : function.extfun Type (functor.add_const (complete_lattice (comm_monoid empty)))) : @is_atomistic.{0} (comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (complete_lattice.{0} (comm_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_62109 (h0 : functor.add_const (semiring (add_left_cancel_semigroup empty)) congr_arg_kind) : @is_noetherian_ring.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (semiring.{0} (add_left_cancel_semigroup.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_62110 (h0 : functor.add_const (topological_space (complete_distrib_lattice ennreal)) num) : @preconnected_space.{0} (complete_distrib_lattice.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_62111 (h0 : functor.add_const (topological_space (has_zero Type)) linarith.comp) : @preirreducible_space.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_zero.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_62112 (h0 : ring (normed_comm_ring (finset Type))) : is_principal_ideal_ring (normed_comm_ring (finset Type)) := sorry --non-trivial
lemma new_lemma_62113 (h0 : function.extfun Type (functor.add_const (function.extfun Type complete_lattice))) : @complete_lattice.is_Sup_finite_compact.{0} (add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) environment.implicit_infer_kind (@function.extfun_app.{2 2} Type (functor.add_const.{1 0} (function.extfun.{2 1} Type complete_lattice.{0})) h0 environment.implicit_infer_kind)) (add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_62114 (h0 : complete_lattice (has_dist ennreal)) : is_atomistic (has_dist ennreal) := sorry --non-trivial
lemma new_lemma_62115 (h0 : function.extfun Type ordered_comm_monoid) : @has_exists_mul_of_le.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} h0 (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_62116 (h0 : ring (semi_normed_ring (mul_one_class string_imp))) : rank_condition (semi_normed_ring (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_62117 (h0 : set (semi_normed_ring (mul_one_class linarith.ineq))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_62118 (h0 : ring (has_Sup fun_info)) : rank_condition (has_Sup fun_info) := sorry --non-trivial
lemma new_lemma_62119 (h0 : complete_lattice (has_nndist linarith.comp)) : is_compactly_generated (has_nndist linarith.comp) := sorry --non-trivial
lemma new_lemma_62120 (h0 : functor.add_const (topological_space (has_to_string linarith.comp)) environment.implicit_infer_kind) : @totally_disconnected_space.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_62121 (h1 : add_group (div_inv_monoid (has_inv linarith.ineq))) : is_add_cyclic (div_inv_monoid (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_62122 (h0 : topological_space (has_Inf (has_Inf (has_Inf Type)))) : regular_space (has_Inf (has_Inf (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_62123 (h0 : topological_space (has_compl (has_nnnorm (random_gen char)))) (h1 : preorder (has_compl (has_nnnorm (random_gen char)))) : order_topology (has_compl (has_nnnorm (random_gen char))) := sorry --non-trivial
lemma new_lemma_62124 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (canonically_ordered_comm_semiring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_ordered_comm_semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_62125 (h0 : not (function.extfun Type topological_space -> false)) : @path_connected_space.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (linear_ordered_semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_62126 (h0 : functor.add_const (list (semigroup name)) unsigned) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_62127 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (add_comm_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (add_comm_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_62128 (h0 : functor.add_const (group (ordered_comm_ring pos)) (has_neg pos)) : @normalizer_condition.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (ordered_comm_ring.{0} pos)) (has_neg.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_62129 (h1 : filter (with_zero linarith.ineq)) : filter.ne_bot h1 := sorry --non-trivial
lemma new_lemma_62130 (h0 : topological_space (has_bot (option (option (option empty))))) : normal_space (has_bot (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_62131 (h1 : topological_space environment.projection_info) (h2 : add_group environment.projection_info) : topological_add_group environment.projection_info := sorry --non-trivial
lemma new_lemma_62132 (h0 : functor.add_const (topological_space (has_neg ennreal)) name) : @path_connected_space.{0} (has_neg.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_62133 (h0 : ring (ordered_cancel_add_comm_monoid unsigned)) : is_domain (ordered_cancel_add_comm_monoid unsigned) := sorry --non-trivial
lemma new_lemma_62134 (h0 : add_group (canonically_linear_ordered_monoid (option (option (option unsigned))))) : is_add_cyclic (canonically_linear_ordered_monoid (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_62135 (h0 : group (add_cancel_monoid (has_neg (has_neg (has_neg (has_zero linarith.comp)))))) : normalizer_condition (add_cancel_monoid (has_neg (has_neg (has_neg (has_zero linarith.comp))))) := sorry --non-trivial
lemma new_lemma_62136 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (complete_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_62137 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (simple_graph.{0} empty) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (simple_graph.{0} empty))  := sorry --non-trivial
lemma new_lemma_62138 (h0 : add_group (semi_normed_comm_ring (has_top (has_top fun_info)))) : is_add_cyclic (semi_normed_comm_ring (has_top (has_top fun_info))) := sorry --non-trivial
lemma new_lemma_62139 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_62140 (h0 : complete_lattice (with_bot (has_norm (has_norm num)))) : is_atomistic (with_bot (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_62141 (h0 : topological_space (ordered_comm_monoid (has_Inf (has_Inf real)))) : irreducible_space (ordered_comm_monoid (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_62142 (h0 : topological_space (linear_ordered_field pos)) : irreducible_space (linear_ordered_field pos) := sorry --non-trivial
lemma new_lemma_62143 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @totally_separated_space.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) topological_space.{0}) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_62144 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (ring (ring pos))) : @sequential_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (ring.{0} (ring.{0} pos)) h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_62145 (h0 : functor.add_const (function.extfun Type topological_space) (has_neg pos)) : @topological_space.separable_space.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (has_neg.{0} pos) h0) (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_62146 (h0 : add_monoid (has_zero (finset environment.implicit_infer_kind))) : add_monoid.fg (has_zero (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_62147 (h1 : ring (parser (fintype linarith.ineq))) : is_domain (parser (fintype linarith.ineq)) := sorry --non-trivial
lemma new_lemma_62148 (h0 : topological_space (add_cancel_monoid (has_zero pos))) : totally_disconnected_space (add_cancel_monoid (has_zero pos)) := sorry --non-trivial
lemma new_lemma_62149 (h0 : topological_space (has_norm (has_norm (random_gen to_additive.value_type)))) : path_connected_space (has_norm (has_norm (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_62150 (h0 : group (complete_semilattice_Sup fun_info)) : group.fg (complete_semilattice_Sup fun_info) := sorry --non-trivial
lemma new_lemma_62151 (h0 : topological_space (topological_space (has_ssubset fun_info))) : path_connected_space (topological_space (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_62152 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_62153 (h0 : topological_space (add_comm_semigroup char) -> char) (h2 : coe_sort (set.range h0)) (h3 : has_sub (add_comm_semigroup char)) : @has_continuous_sub.{0} (add_comm_semigroup.{0} char) (@set.range_splitting.{0 0} (topological_space.{0} (add_comm_semigroup.{0} char)) char h0 h2) h3  := sorry --non-trivial
lemma new_lemma_62154 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_neg_part.{0} ennreal) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_neg_part.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_62155 (h0 : complete_lattice (has_nndist (mul_zero_class name))) : is_atomistic (has_nndist (mul_zero_class name)) := sorry --non-trivial
lemma new_lemma_62156 (h0 : functor.add_const (function.extfun Type ordered_add_comm_monoid) Type) : @archimedean.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ordered_add_comm_monoid.{0}) Type h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_62157 (h0 : topological_space (normed_comm_ring (has_to_string Type))) : t1_space (normed_comm_ring (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_62158 (h1 : uniform_space (has_well_founded (comm_ring (comm_ring reducibility_hints)))) : complete_space (has_well_founded (comm_ring (comm_ring reducibility_hints))) := sorry --non-trivial
lemma new_lemma_62159 (h0 : topological_space (finset (boolean_algebra (complete_distrib_lattice Type)))) : locally_compact_space (finset (boolean_algebra (complete_distrib_lattice Type))) := sorry --non-trivial
lemma new_lemma_62160 (h0 : semiring (has_add (option (option ennreal)))) : is_noetherian_ring (has_add (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_62161 (h0 : monoid (linear_ordered_field (boolean_algebra.core (has_add environment.implicit_infer_kind)))) : monoid.fg (linear_ordered_field (boolean_algebra.core (has_add environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_62162 (h0 : functor.add_const (topological_space (has_Inf pos)) Type) : @preirreducible_space.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_Inf.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_62163 (h0 : add_group (comm_ring (has_nnnorm char))) : is_add_cyclic (comm_ring (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_62164 (h0 : add_monoid (normed_group num)) : add_monoid.fg (normed_group num) := sorry --non-trivial
lemma new_lemma_62165 (h0 : topological_space (div_inv_monoid (random_gen to_additive.value_type))) : path_connected_space (div_inv_monoid (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_62166 (h0 : topological_space (has_nndist (option ennreal))) : locally_compact_space (has_nndist (option ennreal)) := sorry --non-trivial
lemma new_lemma_62167 (h0 : add_group (random_gen (has_top num))) : is_add_cyclic (random_gen (has_top num)) := sorry --non-trivial
lemma new_lemma_62168 (h0 : functor.add_const (group (linear_ordered_comm_monoid_with_zero empty)) unsigned) : @normalizer_condition.{0} (linear_ordered_comm_monoid_with_zero.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (linear_ordered_comm_monoid_with_zero.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_62169 (h0 : ring (has_sub num)) : strong_rank_condition (has_sub num) := sorry --non-trivial
lemma new_lemma_62170 (h1 : ring (has_compl (comm_ring string_imp))) : rank_condition (has_compl (comm_ring string_imp)) := sorry --non-trivial
lemma new_lemma_62171 (h1 : topological_space (add_comm_semigroup linarith.ineq)) (h2 : preorder (add_comm_semigroup linarith.ineq)) : order_topology (add_comm_semigroup linarith.ineq) := sorry --non-trivial
lemma new_lemma_62172 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_62173 (h0 : topological_space (has_zero (ring environment.implicit_infer_kind))) : normal_space (has_zero (ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_62174 (h1 h2 : lex fun_info) : function.is_fixed_pt (fun (h0 : lex fun_info), h1) h2 := sorry --non-trivial
lemma new_lemma_62175 (h1 : complete_lattice (random_gen (has_nnnorm fun_info))) : complete_lattice.is_Sup_finite_compact (random_gen (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_62176 (h0 : function.extfun Type ring) : @is_domain.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_62177 (h0 : topological_space (mul_one_class ereal)) (h1 : preorder (mul_one_class ereal)) : order_closed_topology (mul_one_class ereal) := sorry --non-trivial
lemma new_lemma_62178 (h0 : filter (has_zero (comm_group (comm_group Type)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_62179 (h1 : uniform_space (has_union (semiring linarith.comp))) : complete_space (has_union (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_62180 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (linear_ordered_add_comm_group.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} h0 (linear_ordered_add_comm_group.{0} num))  := sorry --non-trivial
lemma new_lemma_62181 (h0 : group (has_compl linarith.comp_source)) : is_cyclic (has_compl linarith.comp_source) := sorry --non-trivial
lemma new_lemma_62182 (h0 : ring (nondiscrete_normed_field string.iterator_imp)) : is_domain (nondiscrete_normed_field string.iterator_imp) := sorry --non-trivial
lemma new_lemma_62183 (h0 : topological_space (omega_complete_partial_order num)) : t0_space (omega_complete_partial_order num) := sorry --non-trivial
lemma new_lemma_62184 (h0 : list (partial_order empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_62185 (h0 : group (linear_ordered_add_comm_group (has_top (has_top linarith.ineq)))) : normalizer_condition (linear_ordered_add_comm_group (has_top (has_top linarith.ineq))) := sorry --non-trivial
lemma new_lemma_62186 (h0 : functor.add_const (topological_space (has_pos_part pos)) (finset pos)) : @path_connected_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_pos_part.{0} pos)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_62187 (h0 : function.extfun nat fin) : @is_principal_ideal_ring.{1} (sub_neg_monoid.{1} Type) (@matrix.vec_empty.{1} (ring.{1} (sub_neg_monoid.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_62188 (h0 : uniform_space (normed_group (has_top linarith.ineq))) : complete_space (normed_group (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_62189 (h0 : complete_lattice (fintype (random_gen (has_inv linarith.ineq)))) : is_compactly_generated (fintype (random_gen (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_62190 (h0 : filter (add_cancel_monoid (has_add (has_add (has_add (has_add Type)))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_62191 (h0 : not (function.extfun Type group -> false)) : @is_cyclic.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_62192 (h0 : functor.add_const (function.extfun (Type 1) topological_space) (finset (ring linarith.comp))) : @irreducible_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) (finset.{0} (ring.{0} linarith.comp)) h0) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_62193 (h0 : ring (has_inv to_additive.value_type)) : strong_rank_condition (has_inv to_additive.value_type) := sorry --non-trivial
lemma new_lemma_62194 (h0 : add_group (with_one (semiring (has_norm num)))) : is_add_cyclic (with_one (semiring (has_norm num))) := sorry --non-trivial
lemma new_lemma_62195 (h0 : functor.add_const (group (has_Inf pos)) name) : @group.fg.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_Inf.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_62196 (h0 : uniform_space (plift (has_top empty))) : complete_space (plift (has_top empty)) := sorry --non-trivial
lemma new_lemma_62197 (h1 : ring (topological_space string_imp)) : strong_rank_condition (topological_space string_imp) := sorry --non-trivial
lemma new_lemma_62198 (h0 : functor.add_const (topological_space (measurable_space.dynkin_system unsigned)) unsigned) : @locally_compact_space.{0} (measurable_space.dynkin_system.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (measurable_space.dynkin_system.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_62199 (h0 : topological_space (add_cancel_monoid (semigroup congr_arg_kind))) : path_connected_space (add_cancel_monoid (semigroup congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_62200 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (linear_ordered_field.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (linear_ordered_field.{0} pos))  := sorry --non-trivial
lemma new_lemma_62201 (h0 : functor.add_const (topological_space (complete_distrib_lattice environment.implicit_infer_kind)) unsigned) : @normal_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_62202 (h0 : topological_space (pseudo_metric_space empty)) : discrete_topology (pseudo_metric_space empty) := sorry --non-trivial
lemma new_lemma_62203 (h0 : add_group (measurable_space (semiring (semiring (semiring (semiring empty)))))) : is_add_cyclic (measurable_space (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_62204 (h0 : not (topological_space (mul_zero_class empty) -> false)) : @totally_disconnected_space.{0} (mul_zero_class.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (mul_zero_class.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_62205 (h0 : topological_space (has_top (has_top to_additive.value_type))) : discrete_topology (has_top (has_top to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_62206 (h0 : functor.add_const (ring (measure_theory.measure_space unsigned)) num) : @rank_condition.{0} (measure_theory.measure_space.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (measure_theory.measure_space.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_62207 (h0 : semiring (measurable_space.dynkin_system (has_norm (semiring (semiring unsigned))))) : is_noetherian_ring (measurable_space.dynkin_system (has_norm (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_62208 (h0 : not (add_group (has_sub num) -> false)) : @is_add_cyclic.{0} (has_sub.{0} num) (@classical.by_contradiction'.{1} (add_group.{0} (has_sub.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_62209 (h0 : not (ring (id empty) -> false)) : @strong_rank_condition.{0} (@id.{2} Type empty) (@classical.by_contradiction'.{1} (ring.{0} (@id.{2} Type empty)) h0)  := sorry --non-trivial
lemma new_lemma_62210 (h0 : complete_lattice (complete_distrib_lattice (has_Inf real))) : is_atomistic (complete_distrib_lattice (has_Inf real)) := sorry --non-trivial
lemma new_lemma_62211 (h0 : topological_space (random_gen (random_gen to_additive.value_type))) : locally_compact_space (random_gen (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_62212 (h0 : ring (measurable_space linarith.ineq)) : is_domain (measurable_space linarith.ineq) := sorry --non-trivial
lemma new_lemma_62213 (h0 : ring (option (semiring (semiring (semiring num))))) : is_principal_ideal_ring (option (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_62214 (h0 : finset (ring (has_add linarith.comp))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_62215 (h0 : topological_space (dlist (random_gen linarith.comp_source))) : path_connected_space (dlist (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_62216 (h0 : topological_space (complete_distrib_lattice (option ennreal))) : locally_compact_space (complete_distrib_lattice (option ennreal)) := sorry --non-trivial
lemma new_lemma_62217 (h0 : ring nat) : is_domain nat := sorry --non-trivial
lemma new_lemma_62218 (h1 : add_monoid (has_norm num)) : add_monoid.fg (has_norm num) := sorry --non-trivial
lemma new_lemma_62219 (h1 : has_lt (simple_graph linarith.comp_source)) : no_max_order (simple_graph linarith.comp_source) := sorry --non-trivial
lemma new_lemma_62220 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_neg ennreal)) := sorry --non-trivial
lemma new_lemma_62221 (h0 : topological_space (semiring num)) : discrete_topology (semiring num) := sorry --non-trivial
lemma new_lemma_62222 (h0 : topological_space (finset num)) : preconnected_space (finset num) := sorry --non-trivial
lemma new_lemma_62223 (h0 : complete_lattice (has_edist num)) : complete_lattice.is_Sup_finite_compact (has_edist num) := sorry --non-trivial
lemma new_lemma_62224 (h0 : not (group (distrib fun_info) -> false)) : @is_cyclic.{0} (distrib.{0} fun_info) (@classical.by_contradiction'.{1} (group.{0} (distrib.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_62225 (h1 : uniform_space (semi_normed_comm_ring (has_nnnorm (has_nnnorm to_additive.value_type)))) : complete_space (semi_normed_comm_ring (has_nnnorm (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_62226 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (boolean_algebra.core.{0} (has_add.{0} pos)) (@matrix.vec_empty.{0} (group.{0} (boolean_algebra.core.{0} (has_add.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_62227 (h1 : has_lt (has_lt linarith.comp_source)) : no_max_order (has_lt linarith.comp_source) := sorry --non-trivial
lemma new_lemma_62228 (h0 : function.extfun Type (functor.comp topological_space has_zero)) : @preirreducible_space.{0} (has_zero.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} has_zero.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} has_zero.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_62229 (h0 : monoid (measurable_space (random_gen (has_norm empty)))) : monoid.fg (measurable_space (random_gen (has_norm empty))) := sorry --non-trivial
lemma new_lemma_62230 (h0 : topological_space (has_nnnorm (mul_one_class fun_info))) (h1 : preorder (has_nnnorm (mul_one_class fun_info))) : order_closed_topology (has_nnnorm (mul_one_class fun_info)) := sorry --non-trivial
lemma new_lemma_62231 (h0 : uniform_space (metric_space num)) : separated_space (metric_space num) := sorry --non-trivial
lemma new_lemma_62232 (h1 : not (ring (has_ssubset char) -> false)) : @is_domain.{0} (has_ssubset.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_62233 (h0 : functor.add_const (complete_lattice (finset name)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (finset.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_62234 (h2 : complete_lattice (plift string_imp)) : is_compactly_generated (plift string_imp) := sorry --non-trivial
lemma new_lemma_62235 (h0 : functor.add_const (topological_space auto.case_option) unsigned) : @irreducible_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) unsigned h0)  := sorry --non-trivial
lemma new_lemma_62236 (h0 : add_monoid (add_comm_monoid (option (option (option (option unsigned)))))) : add_monoid.fg (add_comm_monoid (option (option (option (option unsigned))))) := sorry --non-trivial
lemma new_lemma_62237 (h0 : topological_space (has_Inf (has_neg pos))) : normal_space (has_Inf (has_neg pos)) := sorry --non-trivial
lemma new_lemma_62238 (h1 : complete_lattice (semiring (has_norm linarith.comp_source))) : is_atomistic (semiring (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_62239 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_union.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_union.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_62240 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (has_to_string.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_to_string.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_62241 (h2 : has_mem.mem (has_emptyc linarith.comp) has_emptyc.emptyc) : @is_cyclic.{0} (has_emptyc.{0} linarith.comp) (@finset.pi.empty.{1 0} Type group.{0} (has_emptyc.{0} linarith.comp) h2)  := sorry --non-trivial
lemma new_lemma_62242 (h0 : function.extfun Type group) : @is_cyclic.{0} (has_bot.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (has_bot.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_62243 (h0 : topological_space (ordered_comm_group (option empty))) : t1_space (ordered_comm_group (option empty)) := sorry --non-trivial
lemma new_lemma_62244 (h0 : semiring (sub_neg_monoid (has_pos_part pos))) : is_noetherian_ring (sub_neg_monoid (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_62245 (h0 : topological_space (has_union (semiring (has_norm linarith.comp)))) : t0_space (has_union (semiring (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_62246 (h0 : ring (has_add Type)) : is_domain (has_add Type) := sorry --non-trivial
lemma new_lemma_62247 (h0 : functor.add_const (topological_space (has_nndist unsigned)) num) : @locally_compact_space.{0} (has_nndist.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_62248 (h0 : functor.add_const (filter (boolean_algebra Type)) pos) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_62249 (h0 : group (canonically_ordered_comm_semiring (has_nndist Type))) : is_cyclic (canonically_ordered_comm_semiring (has_nndist Type)) := sorry --non-trivial
lemma new_lemma_62250 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @totally_separated_space.{0} (measurable_space.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (measurable_space.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_62251 (h0 : complete_lattice (with_bot empty)) : complete_lattice.is_Sup_finite_compact (with_bot empty) := sorry --non-trivial
lemma new_lemma_62252 (h0 : functor.add_const (topological_space (boolean_algebra pos)) Type) : @normal_space.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_62253 (h0 : topological_space (measurable_space.dynkin_system (semiring congr_arg_kind))) : discrete_topology (measurable_space.dynkin_system (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_62254 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @monoid.fg.{0} (add_group.{0} empty) (@function.extfun_app.{2 1} Type monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 monoid.{0}) (add_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_62255 (h0 : group (semiring string_imp)) : normalizer_condition (semiring string_imp) := sorry --non-trivial
lemma new_lemma_62256 (h0 : add_group (linear_ordered_semiring empty)) : is_add_cyclic (linear_ordered_semiring empty) := sorry --non-trivial
lemma new_lemma_62257 (h0 : uniform_space (ordered_comm_monoid (has_add (boolean_algebra.core name)))) : separated_space (ordered_comm_monoid (has_add (boolean_algebra.core name))) := sorry --non-trivial
lemma new_lemma_62258 (h0 : functor.add_const (function.extfun Type uniform_space) linarith.comp) : @separated_space.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) linarith.comp h0) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_62259 (h0 : ring (semiring (random_gen fun_info))) : is_domain (semiring (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_62260 (h0 : topological_space (semi_normed_comm_ring string_imp)) : locally_compact_space (semi_normed_comm_ring string_imp) := sorry --non-trivial
lemma new_lemma_62261 (h0 : topological_space (denumerable to_additive.value_type)) : locally_compact_space (denumerable to_additive.value_type) := sorry --non-trivial
lemma new_lemma_62262 (h0 : functor.add_const (semiring (simple_graph pos)) linarith.comp) : @is_noetherian_ring.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (semiring.{0} (simple_graph.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_62263 (h0 : topological_space (has_Inf pos)) : path_connected_space (has_Inf pos) := sorry --non-trivial
lemma new_lemma_62264 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_sub.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_sub.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_62265 (h0 : complete_lattice (finset (has_pos_part Type))) : is_compactly_generated (finset (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_62266 (h0 : functor.add_const (list (cancel_monoid Type)) linarith.comp) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_62267 (h0 : topological_space (has_add (ring Type))) : t1_space (has_add (ring Type)) := sorry --non-trivial
lemma new_lemma_62268 (h0 : functor.add_const (group (has_nndist ennreal)) Type) : @is_simple_group.{0} (has_nndist.{0} ennreal) (@functor.add_const.run.{0 1} (group.{0} (has_nndist.{0} ennreal)) Type h0)  := sorry --non-trivial
lemma new_lemma_62269 (h0 : option (add_cancel_monoid (option pos)) -> option (add_cancel_monoid (option pos)) -> Prop) : is_symm (option (add_cancel_monoid (option pos))) h0 := sorry --non-trivial
lemma new_lemma_62270 (h0 : group (id (semiring unsigned))) : group.fg (id (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_62271 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_62272 (h0 : semiring (has_neg (finset (finset linarith.comp)))) : is_noetherian_ring (has_neg (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_62273 (h0 : measurable_space (nondiscrete_normed_field string.iterator_imp)) (h2 : Prop) : measurable_set (id (fun (h1 : nondiscrete_normed_field string.iterator_imp), h2)) := sorry --non-trivial
lemma new_lemma_62274 (h0 : complete_lattice (has_one (has_top (semiring empty)))) : complete_lattice.is_Sup_finite_compact (has_one (has_top (semiring empty))) := sorry --non-trivial
lemma new_lemma_62275 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @t0_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_62276 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_62277 (h0 : topological_space (semigroup (has_add (has_add (has_Inf (has_add pos)))))) : sequential_space (semigroup (has_add (has_add (has_Inf (has_add pos))))) := sorry --non-trivial
lemma new_lemma_62278 (h0 : functor.add_const (topological_space (has_zero name)) linarith.comp) : @t0_space.{0} (has_zero.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_62279 (h0 : ring (has_compl (has_nnnorm linarith.ineq))) : rank_condition (has_compl (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_62280 (h0 : function.extfun (Type 1) group) : @normalizer_condition.{1} (with_one.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} h0 (with_one.{1} Type))  := sorry --non-trivial
lemma new_lemma_62281 (h0 : function.extfun (multiset ((Type -> Type) -> Type 1)) (has_mem.mem (function.extfun Type))) : @t0_space.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@multiset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@function.extfun_app.{3 0} (multiset.{2} ((Type → Type) → Type 1)) (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (multiset.{2} ((Type → Type) → Type 1)) (@multiset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type)) h0 (@has_zero.zero.{2} (multiset.{2} ((Type → Type) → Type 1)) (@multiset.has_zero.{2} ((Type → Type) → Type 1))))) topological_space.{0}) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_62282 (h0 : complete_lattice (has_to_string (has_add pos))) : is_compactly_generated (has_to_string (has_add pos)) := sorry --non-trivial
lemma new_lemma_62283 (h0 : semiring (canonically_ordered_monoid (ordered_comm_monoid pos))) : is_noetherian_ring (canonically_ordered_monoid (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_62284 (h0 : functor.add_const (group (add_comm_monoid pos)) linarith.comp) : @group.fg.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (add_comm_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_62285 (h0 : complete_lattice (normed_group fun_info)) : complete_lattice.is_Sup_finite_compact (normed_group fun_info) := sorry --non-trivial
lemma new_lemma_62286 (h0 : topological_space (left_cancel_monoid (free_add_monoid unsigned))) : normal_space (left_cancel_monoid (free_add_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_62287 (h0 : function.extfun Type topological_space) : @t1_space.{0} (generalized_boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (generalized_boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_62288 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_62289 (h0 : ring (dlist linarith.comp_source)) : is_domain (dlist linarith.comp_source) := sorry --non-trivial
lemma new_lemma_62290 (h0 : group (semi_normed_ring (has_nnnorm char))) : is_cyclic (semi_normed_ring (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_62291 (h0 : topological_space (has_to_string (has_add (finset pos)))) : topological_space.separable_space (has_to_string (has_add (finset pos))) := sorry --non-trivial
lemma new_lemma_62292 (h0 : uniform_space (add_cancel_monoid (cancel_monoid name))) : separated_space (add_cancel_monoid (cancel_monoid name)) := sorry --non-trivial
lemma new_lemma_62293 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (has_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (has_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_62294 (h0 : function.extfun (finset Type) (has_mem.mem (measurable_space fun_info))) : @discrete_topology.{0} (measurable_space.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (measurable_space.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_62295 (h0 : complete_lattice (random_gen to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_62296 (h0 : functor.add_const (list (semiring congr_arg_kind)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_62297 (h0 : semiring (simple_graph (finset (finset linarith.comp)))) : is_noetherian_ring (simple_graph (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_62298 (h0 : functor.add_const (functor.add_const Prop pos) Type) : functor.add_const.run (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_62299 (h0 : not (uniform_space (normed_field to_additive.value_type) -> false)) : @complete_space.{0} (normed_field.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (uniform_space.{0} (normed_field.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_62300 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_62301 (h0 : function.extfun Type group) : @is_cyclic.{0} (ordered_ring.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (ordered_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_62302 (h0 : complete_lattice (plift unsigned)) : is_compactly_generated (plift unsigned) := sorry --non-trivial
lemma new_lemma_62303 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @regular_space.{1} (semigroup.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (semigroup.{1} Type))  := sorry --non-trivial
lemma new_lemma_62304 (h1 : ring (normed_field (has_nnnorm (random_gen (random_gen (random_gen char)))))) : rank_condition (normed_field (has_nnnorm (random_gen (random_gen (random_gen char))))) := sorry --non-trivial
lemma new_lemma_62305 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (mul_zero_class.{0} unsigned) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (mul_zero_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_62306 (h0 : ring (free_add_monoid num)) : is_principal_ideal_ring (free_add_monoid num) := sorry --non-trivial
lemma new_lemma_62307 (h0 : add_group (distrib (mul_one_class (has_nnnorm (mul_one_class reducibility_hints))))) : is_add_cyclic (distrib (mul_one_class (has_nnnorm (mul_one_class reducibility_hints)))) := sorry --non-trivial
lemma new_lemma_62308 (h0 : function.extfun Type complete_lattice) : @is_atomistic.{0} (with_bot.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (with_bot.{0} num))  := sorry --non-trivial
lemma new_lemma_62309 (h0 : ring (semiring (option unsigned))) : is_domain (semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_62310 (h0 : topological_space (ordered_comm_monoid (ring Type))) : locally_compact_space (ordered_comm_monoid (ring Type)) := sorry --non-trivial
lemma new_lemma_62311 (h0 : is_empty (add_comm_semigroup fun_info)) (h1 : add_comm_semigroup fun_info) : is_empty.elim' h0 h1 := sorry --non-trivial
lemma new_lemma_62312 (h0 : functor.add_const (ring (normed_comm_ring Type)) linarith.comp) : @is_domain.{1} (normed_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (normed_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_62313 (h0 : list (comm_group ennreal)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_62314 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_62315 (h0 : functor.add_const (function.extfun (Type 1) list) linarith.comp) : list.nodup (function.extfun_app (functor.add_const.run h0) (generalized_boolean_algebra Type)) := sorry --non-trivial
lemma new_lemma_62316 (h0 : topological_space (has_neg (option (option (option empty))))) : t1_space (has_neg (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_62317 (h0 : topological_space (normed_group (has_inv (random_gen linarith.ineq)))) : totally_disconnected_space (normed_group (has_inv (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_62318 (h0 : functor.add_const (ring (boolean_algebra.core Type)) name) : @strong_rank_condition.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (boolean_algebra.core.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_62319 (h0 : topological_space (canonically_linear_ordered_monoid (comm_semigroup (has_neg Type)))) : sequential_space (canonically_linear_ordered_monoid (comm_semigroup (has_neg Type))) := sorry --non-trivial
lemma new_lemma_62320 (h0 : function.extfun Type topological_space) : @t0_space.{0} (has_nnnorm.{0} string_imp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_nnnorm.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_62321 (h0 : topological_space (finset (option unsigned)) -> Prop) (h1 : Exists (fun (x : topological_space (finset (option unsigned))), h0 x)) : @normal_space.{0} (finset.{0} (option.{0} unsigned)) (@classical.some.{1} (topological_space.{0} (finset.{0} (option.{0} unsigned))) h0 h1)  := sorry --non-trivial
lemma new_lemma_62322 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @preconnected_space.{0} (ordered_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (ordered_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_62323 (h0 : functor.add_const (function.extfun Type uniform_space) unsigned) : @separated_space.{0} (add_group.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) unsigned h0) (add_group.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_62324 (h0 : ordered_comm_monoid (boolean_algebra (has_to_string (has_to_string (has_to_string pos))))) : has_exists_mul_of_le (boolean_algebra (has_to_string (has_to_string (has_to_string pos)))) := sorry --non-trivial
lemma new_lemma_62325 (h0 : functor.add_const (function.extfun Type uniform_space) linarith.comp) : @complete_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) linarith.comp h0) (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_62326 (h0 : functor.add_const (cancel_comm_monoid_with_zero (free_add_monoid num)) num) : @unique_factorization_monoid.{0} (free_add_monoid.{0} num) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (free_add_monoid.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_62327 (h0 : topological_space (canonically_ordered_comm_semiring (has_add Type))) : regular_space (canonically_ordered_comm_semiring (has_add Type)) := sorry --non-trivial
lemma new_lemma_62328 (h0 : add_group (bin_tree (option (option unsigned)))) : is_add_cyclic (bin_tree (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_62329 (h0 : list (with_bot (with_bot to_additive.value_type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_62330 (h0 : functor.add_const (ring (has_Sup num)) congr_arg_kind) : @is_principal_ideal_ring.{0} (has_Sup.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (has_Sup.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_62331 (h0 : function.extfun (Type 1) uniform_space) : @separated_space.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} h0 (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_62332 (h0 : function.extfun Type topological_space) : @regular_space.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_62333 (h0 : topological_space (add_comm_monoid (has_to_string name))) : t0_space (add_comm_monoid (has_to_string name)) := sorry --non-trivial
lemma new_lemma_62334 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) Type) : @regular_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_62335 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : palindrome (function.extfun_app (function.extfun_app h0 list) (left_cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_62336 (h0 : ring (add_cancel_monoid (add_cancel_monoid linarith.comp))) : is_principal_ideal_ring (add_cancel_monoid (add_cancel_monoid linarith.comp)) := sorry --non-trivial
lemma new_lemma_62337 (h0 : functor.add_const (functor.add_const (group linarith.comp) pos) linarith.comp) : @normalizer_condition.{0} linarith.comp (@functor.add_const.run.{0 0} (group.{0} linarith.comp) pos (@functor.add_const.run.{0 0} (functor.add_const.{0 0} (group.{0} linarith.comp) pos) linarith.comp h0))  := sorry --non-trivial
lemma new_lemma_62338 (h0 : ordered_add_comm_monoid (has_Inf (has_add linarith.comp))) : archimedean (has_Inf (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_62339 (h0 : ring (distrib_lattice (topological_space (fintype char)))) : strong_rank_condition (distrib_lattice (topological_space (fintype char))) := sorry --non-trivial
lemma new_lemma_62340 (h0 : topological_space (simple_graph (option empty))) : path_connected_space (simple_graph (option empty)) := sorry --non-trivial
lemma new_lemma_62341 (h1 : char -> char -> Prop) (h2 : filter char) : filter.is_bounded h1 h2 := sorry --non-trivial
lemma new_lemma_62342 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (pseudo_metric_space.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (pseudo_metric_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_62343 (h0 : not (filter (linear_ordered_add_comm_group fun_info) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_62344 (h0 : not (list (plift num) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_62345 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (with_one.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (with_one.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_62346 (h0 : cancel_comm_monoid_with_zero (semigroup (option unsigned))) : unique_factorization_monoid (semigroup (option unsigned)) := sorry --non-trivial
lemma new_lemma_62347 (h0 : topological_space (has_norm (random_gen fun_info))) : t0_space (has_norm (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_62348 (h0 : list (comm_group (semigroup (semigroup (semigroup (comm_group name)))))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_62349 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) linarith.comp) : @t1_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_62350 (h0 : cancel_comm_monoid_with_zero (has_neg_part (has_add (has_add Type)))) : unique_factorization_monoid (has_neg_part (has_add (has_add Type))) := sorry --non-trivial
lemma new_lemma_62351 (h0 : functor.add_const (function.extfun Type complete_lattice) name) : @complete_lattice.is_Sup_finite_compact.{0} (cancel_monoid.{0} name) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) name h0) (cancel_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_62352 (h0 : set (mul_one_class environment.projection_info)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_62353 (h0 : ring (finset (has_Inf (ring (boolean_algebra (has_Inf (has_Inf Type))))))) : rank_condition (finset (has_Inf (ring (boolean_algebra (has_Inf (has_Inf Type)))))) := sorry --non-trivial
lemma new_lemma_62354 (h0 : ring (canonically_ordered_comm_semiring (has_add ennreal))) : is_principal_ideal_ring (canonically_ordered_comm_semiring (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_62355 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (boolean_algebra.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} name))  := sorry --non-trivial
lemma new_lemma_62356 (h4 : ring (has_ssubset (has_nnnorm char))) : rank_condition (has_ssubset (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_62357 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_62358 (h0 : measurable_space (ring Type)) (h1 : measure_theory.measure (ring Type)) : measure_theory.measure.is_complete h1 := sorry --non-trivial
lemma new_lemma_62359 (h0 : ring (denumerable string_imp)) : is_domain (denumerable string_imp) := sorry --non-trivial
lemma new_lemma_62360 (h0 : set (add_comm_semigroup string.iterator_imp -> add_comm_semigroup ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_62361 (h0 : functor.add_const (function.extfun Type finset) linarith.comp) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_62362 (h0 : topological_space (has_neg enat)) : totally_disconnected_space (has_neg enat) := sorry --non-trivial
lemma new_lemma_62363 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @irreducible_space.{0} (non_assoc_semiring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) topological_space.{0}) (non_assoc_semiring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_62364 (h0 : not (complete_lattice (has_union empty) -> false)) : @is_compactly_generated.{0} (has_union.{0} empty) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_union.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_62365 (h0 : ring unsigned -> Prop) : zzz_forall h0 := sorry --non-trivial
lemma new_lemma_62366 (h0 : topological_space (measurable_space (random_gen to_additive.value_type))) : discrete_topology (measurable_space (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_62367 (h0 : functor.add_const (topological_space (add_cancel_monoid linarith.comp)) (has_neg (has_neg (has_neg name)))) : @normal_space.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} linarith.comp)) (has_neg.{0} (has_neg.{0} (has_neg.{0} name))) h0)  := sorry --non-trivial
lemma new_lemma_62368 (h0 : list (with_one (random_gen linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_62369 (h0 : filter (finset (option (has_add (option name))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_62370 (h0 : set std_gen) : set.finite h0 := sorry --non-trivial
lemma new_lemma_62371 (h0 : add_monoid (normed_lattice_add_comm_group Type)) : add_monoid.fg (normed_lattice_add_comm_group Type) := sorry --non-trivial
lemma new_lemma_62372 (h0 : monoid (simple_graph (has_Inf pos))) : monoid.fg (simple_graph (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_62373 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_62374 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_Inf pos)) linarith.comp) : @unique_factorization_monoid.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (has_Inf.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_62375 (h0 : topological_space (mul_one_class linarith.ineq)) : totally_disconnected_space (mul_one_class linarith.ineq) := sorry --non-trivial
lemma new_lemma_62376 (h0 : functor.add_const (function.extfun (Type 1) uniform_space) linarith.comp) : @separated_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) uniform_space.{1}) linarith.comp h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_62377 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_62378 (h0 : functor.add_const (ring (add_comm_monoid pos)) linarith.comp) : @is_principal_ideal_ring.{0} (add_comm_monoid.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (add_comm_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_62379 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_neg.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_neg.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_62380 (h1 : ring (has_inv linarith.ineq)) : rank_condition (has_inv linarith.ineq) := sorry --non-trivial
lemma new_lemma_62381 (h0 : filter (has_to_string (has_neg linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_62382 (h0 : functor.add_const (topological_space auto.case_option) num) : @topological_space.separable_space.{0} auto.case_option (@functor.add_const.run.{0 0} (topological_space.{0} auto.case_option) num h0)  := sorry --non-trivial
lemma new_lemma_62383 (h0 : set (mul_one_class string.iterator_imp -> add_comm_semigroup enat)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_62384 (h0 : functor.add_const (complete_lattice (has_to_string pos)) unsigned) : @complete_lattice.is_Sup_finite_compact.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_62385 (h0 : not (ring (has_compl enat) -> false)) : @strong_rank_condition.{0} (has_compl.{0} enat) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} enat)) h0)  := sorry --non-trivial
lemma new_lemma_62386 (h0 : function.extfun Type (functor.add_const (topological_space (free_add_monoid empty)))) : @loc_path_connected_space.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (free_add_monoid.{0} empty)) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (free_add_monoid.{0} empty))) h0 num))  := sorry --non-trivial
lemma new_lemma_62387 (h0 : topological_space (ring (has_neg name))) : discrete_topology (ring (has_neg name)) := sorry --non-trivial
lemma new_lemma_62388 (h0 : filter (semigroup (ring environment.implicit_infer_kind))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_62389 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_62390 (h0 : topological_space (add_comm_semigroup (add_comm_semigroup ereal))) : t0_space (add_comm_semigroup (add_comm_semigroup ereal)) := sorry --non-trivial
lemma new_lemma_62391 (h0 : measurable_space (dlist (has_ssubset linarith.comp_source))) (h1 : filter (dlist (has_ssubset linarith.comp_source))) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_62392 (h0 : plift nnreal -> plift nnreal -> Prop) : is_trans (plift nnreal) h0 := sorry --non-trivial
lemma new_lemma_62393 (h0 : topological_space (canonically_ordered_comm_semiring (pseudo_metric_space name))) : sequential_space (canonically_ordered_comm_semiring (pseudo_metric_space name)) := sorry --non-trivial
lemma new_lemma_62394 (h0 : functor.add_const (group (complete_distrib_lattice Type)) Type) : @group.fg.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 1} (group.{1} (complete_distrib_lattice.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_62395 (h0 : not (list (has_ssubset linarith.comp_source) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_62396 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @path_connected_space.{0} (has_emptyc.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (has_emptyc.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_62397 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (complete_semilattice_Sup to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_62398 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_62399 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_62400 (h0 : ordered_add_comm_monoid (boolean_algebra.core (has_neg linarith.comp))) : archimedean (boolean_algebra.core (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_62401 (h0 : not (ring (comm_ring to_additive.value_type) -> false)) : @is_domain.{0} (comm_ring.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (comm_ring.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_62402 (h0 : function.extfun Type group) : @group.fg.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_62403 (h0 : filter (boolean_algebra (ordered_comm_monoid Type))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_62404 (h0 : add_group (has_compl linarith.comp_source)) : is_add_cyclic (has_compl linarith.comp_source) := sorry --non-trivial
lemma new_lemma_62405 (h0 : topological_space (add_cancel_monoid (boolean_algebra.core Type))) : loc_path_connected_space (add_cancel_monoid (boolean_algebra.core Type)) := sorry --non-trivial
lemma new_lemma_62406 (h0 : topological_space (has_neg (has_add (has_add (finset pos))))) : irreducible_space (has_neg (has_add (has_add (finset pos)))) := sorry --non-trivial
lemma new_lemma_62407 (h1 : set (mul_one_class char -> add_comm_semigroup linarith.ineq)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_62408 (h0 : complete_lattice (has_zero (boolean_algebra linarith.comp))) : is_atomistic (has_zero (boolean_algebra linarith.comp)) := sorry --non-trivial
lemma new_lemma_62409 (h0 : semiring (measurable_space.dynkin_system (semiring (semiring empty)))) : is_noetherian_ring (measurable_space.dynkin_system (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_62410 (h0 : topological_space (comm_semigroup (has_bot (has_Inf real)))) : irreducible_space (comm_semigroup (has_bot (has_Inf real))) := sorry --non-trivial
lemma new_lemma_62411 (h0 : topological_space (group_with_zero ennreal)) : loc_path_connected_space (group_with_zero ennreal) := sorry --non-trivial
lemma new_lemma_62412 (h0 : functor.comp topological_space comm_group Type) : @preirreducible_space.{1} (comm_group.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} comm_group.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_62413 (h1 : group (has_top string_imp)) : is_cyclic (has_top string_imp) := sorry --non-trivial
lemma new_lemma_62414 (h0 : group (has_neg (comm_group Type))) : normalizer_condition (has_neg (comm_group Type)) := sorry --non-trivial
lemma new_lemma_62415 (h1 : Prop) (h2 : unit) : set.separates_points (matrix.row (fun (h0 : add_comm_semigroup fun_info -> char), h1) h2) := sorry --non-trivial
lemma new_lemma_62416 (h0 : functor.add_const (topological_space (has_Inf Type)) linarith.comp) : @totally_disconnected_space.{1} (has_Inf.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_Inf.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_62417 (h0 : function.extfun (finset Type) (has_mem.mem (normed_group num))) : @complete_space.{0} (normed_group.{0} num) (@finset.pi.empty.{1 0} Type uniform_space.{0} (normed_group.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (normed_group.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_62418 (h0 : topological_space (mul_one_class (mul_one_class (add_comm_semigroup string.iterator_imp)))) : totally_disconnected_space (mul_one_class (mul_one_class (add_comm_semigroup string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_62419 (h0 : topological_space (finset (mul_zero_class (option (option name))))) : locally_compact_space (finset (mul_zero_class (option (option name)))) := sorry --non-trivial
lemma new_lemma_62420 (h0 : set (mul_one_class linarith.comp_source)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_62421 (h0 : complete_lattice (measurable_space.dynkin_system (semiring (semiring (semiring (semiring empty)))))) : is_atomistic (measurable_space.dynkin_system (semiring (semiring (semiring (semiring empty))))) := sorry --non-trivial
lemma new_lemma_62422 (h0 : ring (cancel_monoid (comm_group name))) : rank_condition (cancel_monoid (comm_group name)) := sorry --non-trivial
lemma new_lemma_62423 (h0 : ring (add_comm_semigroup (has_nnnorm (mul_one_class (mul_one_class enat))))) : strong_rank_condition (add_comm_semigroup (has_nnnorm (mul_one_class (mul_one_class enat)))) := sorry --non-trivial
lemma new_lemma_62424 (h0 : not (topological_space (has_top (random_gen linarith.comp_source)) -> false)) : @irreducible_space.{0} (has_top.{0} (random_gen.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} (random_gen.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_62425 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (comm_ring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_ring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_62426 (h0 : ring (linear_ordered_field (has_neg_part pos))) : strong_rank_condition (linear_ordered_field (has_neg_part pos)) := sorry --non-trivial
lemma new_lemma_62427 (h1 : ring (semi_normed_comm_ring char)) : rank_condition (semi_normed_comm_ring char) := sorry --non-trivial
lemma new_lemma_62428 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (ring unsigned)) := sorry --non-trivial
lemma new_lemma_62429 (h0 : not (functor.add_const Prop (with_zero empty) -> false)) : functor.add_const.run (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_62430 (h0 : topological_space (id (random_gen linarith.ineq))) : t0_space (id (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_62431 (h0 : complete_lattice (add_comm_monoid ennreal)) : complete_lattice.is_Sup_finite_compact (add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_62432 (h0 : topological_space (has_Inf (finset pos))) : topological_space.separable_space (has_Inf (finset pos)) := sorry --non-trivial
lemma new_lemma_62433 (h4 : not (uniform_space (topological_space char) -> false)) : @complete_space.{0} (topological_space.{0} char) (@classical.by_contradiction'.{1} (uniform_space.{0} (topological_space.{0} char)) h4)  := sorry --non-trivial
lemma new_lemma_62434 (h0 : functor.add_const (uniform_space (complete_distrib_lattice Type)) Type) : @separated_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 1} (uniform_space.{1} (complete_distrib_lattice.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_62435 (h0 : function.extfun Type group) : @group.fg.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_62436 (h0 : not (topological_space (normed_group num) -> false)) : @irreducible_space.{0} (normed_group.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_62437 (h0 : functor.add_const (monoid (boolean_algebra.core (has_nndist name))) Type) : @monoid.fg.{0} (boolean_algebra.core.{0} (has_nndist.{0} name)) (@functor.add_const.run.{0 1} (monoid.{0} (boolean_algebra.core.{0} (has_nndist.{0} name))) Type h0)  := sorry --non-trivial
lemma new_lemma_62438 (h0 : topological_space (has_top (random_gen linarith.comp_source))) : totally_separated_space (has_top (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_62439 (h2 : group (has_inv fun_info)) : normalizer_condition (has_inv fun_info) := sorry --non-trivial
lemma new_lemma_62440 (h0 : topological_space (finset (option congr_arg_kind))) : path_connected_space (finset (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_62441 (h0 : function.extfun Type (functor.add_const (filter (finset empty)))) : countable_Inter_filter (functor.add_const.run (function.extfun_app h0 unsigned)) := sorry --non-trivial
lemma new_lemma_62442 (h0 : not (topological_space (dlist to_additive.value_type) -> false)) : @path_connected_space.{0} (dlist.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (dlist.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_62443 (h0 : function.extfun Type topological_space) : totally_disconnected_space ennreal := sorry --non-trivial
lemma new_lemma_62444 (h1 : set (normed_field (mul_one_class linarith.ineq))) : set.subsingleton h1 := sorry --non-trivial
lemma new_lemma_62445 (h0 : add_group (id unsigned)) : is_add_cyclic (id unsigned) := sorry --non-trivial
lemma new_lemma_62446 (h0 : group (has_top (has_nnnorm to_additive.value_type))) : is_cyclic (has_top (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_62447 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_62448 (h0 : list (cancel_monoid (canonically_linear_ordered_monoid ennreal))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_62449 (h0 : topological_space (has_neg_part (add_comm_monoid (has_add (has_add Type))))) : t0_space (has_neg_part (add_comm_monoid (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_62450 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_62451 (h0 : functor.add_const (finset (boolean_algebra pos)) (finset (finset Type))) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_62452 (h0 : topological_space (has_neg (has_pos_part Type))) : preconnected_space (has_neg (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_62453 (h0 : topological_space (fintype (has_lt to_additive.value_type))) : t0_space (fintype (has_lt to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_62454 (h1 : topological_space (has_top to_additive.value_type) -> string_imp) (h2 : coe_sort (set.range h1)) : @irreducible_space.{0} (has_top.{0} to_additive.value_type) (@set.range_splitting.{0 0} (topological_space.{0} (has_top.{0} to_additive.value_type)) string_imp h1 h2)  := sorry --non-trivial
lemma new_lemma_62455 (h0 : topological_space (has_star (semiring empty))) : totally_separated_space (has_star (semiring empty)) := sorry --non-trivial
lemma new_lemma_62456 (h0 : ring (boolean_algebra (has_add (has_add pos)))) : is_principal_ideal_ring (boolean_algebra (has_add (has_add pos))) := sorry --non-trivial
lemma new_lemma_62457 (h0 : function.extfun (finset ((Type -> Type) -> Type 1)) (has_mem.mem (function.extfun Type))) : @strong_rank_condition.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@function.extfun_app.{3 0} (finset.{2} ((Type → Type) → Type 1)) (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (finset.{2} ((Type → Type) → Type 1)) (@finset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type)) h0 (@has_emptyc.emptyc.{2} (finset.{2} ((Type → Type) → Type 1)) (@finset.has_emptyc.{2} ((Type → Type) → Type 1))))) ring.{0}) (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_62458 (h0 : topological_space (ordered_cancel_add_comm_monoid empty)) : totally_disconnected_space (ordered_cancel_add_comm_monoid empty) := sorry --non-trivial
lemma new_lemma_62459 (h0 : functor.add_const (topological_space (boolean_algebra.core pos)) pos) : @discrete_topology.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_62460 (h0 : ring (has_ssubset (add_comm_semigroup string.iterator_imp))) : is_domain (has_ssubset (add_comm_semigroup string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_62461 (h0 : topological_space (has_norm (random_gen (random_gen (has_nnnorm fun_info))))) : locally_compact_space (has_norm (random_gen (random_gen (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_62462 (h0 : add_group (linear_ordered_field to_additive.value_type)) : is_add_cyclic (linear_ordered_field to_additive.value_type) := sorry --non-trivial
lemma new_lemma_62463 (h0 : complete_lattice (add_monoid (distrib fun_info))) : is_compactly_generated (add_monoid (distrib fun_info)) := sorry --non-trivial
lemma new_lemma_62464 (h0 : complete_lattice (has_one (has_top unsigned))) : is_atomistic (has_one (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_62465 (h0 : ring (linear_ordered_semiring (has_norm empty))) : rank_condition (linear_ordered_semiring (has_norm empty)) := sorry --non-trivial
lemma new_lemma_62466 (h0 : topological_space (cancel_monoid (has_add Type))) : discrete_topology (cancel_monoid (has_add Type)) := sorry --non-trivial
lemma new_lemma_62467 (h0 : group (has_nndist (has_add name))) : is_simple_group (has_nndist (has_add name)) := sorry --non-trivial
lemma new_lemma_62468 (h0 : ring (normed_linear_ordered_group (semiring empty))) : strong_rank_condition (normed_linear_ordered_group (semiring empty)) := sorry --non-trivial
lemma new_lemma_62469 (h0 : topological_space (filter (option empty))) : path_connected_space (filter (option empty)) := sorry --non-trivial
lemma new_lemma_62470 (h0 : functor.add_const (ring (normed_comm_ring empty)) (option (option empty))) : @is_domain.{0} (normed_comm_ring.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} empty)) (option.{0} (option.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_62471 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (semiring.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semiring.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_62472 (h0 : functor.add_const (add_group (canonically_ordered_add_monoid empty)) empty) : @is_add_cyclic.{0} (canonically_ordered_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (canonically_ordered_add_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_62473 (h0 : topological_space (has_zero (has_add (boolean_algebra (has_add (has_add pos)))))) : discrete_topology (has_zero (has_add (boolean_algebra (has_add (has_add pos))))) := sorry --non-trivial
lemma new_lemma_62474 (h0 : add_monoid (random_gen (has_top num))) : add_monoid.fg (random_gen (has_top num)) := sorry --non-trivial
lemma new_lemma_62475 (h0 : ring (has_append (has_nnnorm (has_ssubset (distrib_lattice (random_gen char)))))) : rank_condition (has_append (has_nnnorm (has_ssubset (distrib_lattice (random_gen char))))) := sorry --non-trivial
lemma new_lemma_62476 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_62477 (h0 : group (has_nndist (has_add name))) : is_cyclic (has_nndist (has_add name)) := sorry --non-trivial
lemma new_lemma_62478 (h0 : set (enat -> add_comm_semigroup string.iterator_imp)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_62479 (h0 : group (has_inv (has_nnnorm linarith.comp_source))) : is_cyclic (has_inv (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_62480 (h0 : complete_lattice (has_nnnorm (random_gen (random_gen string_imp)))) : is_compactly_generated (has_nnnorm (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_62481 (h0 : ring (complete_semilattice_Sup (random_gen linarith.comp_source))) : strong_rank_condition (complete_semilattice_Sup (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_62482 (h0 : prod (free_add_monoid num) (free_add_monoid num)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_62483 (h0 : functor.add_const (function.extfun (Type 1) group) (boolean_algebra.core pos)) : @is_simple_group.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) (boolean_algebra.core.{0} pos) h0) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_62484 (h0 : functor.add_const (topological_space (semigroup pos)) (comm_group name)) : @loc_path_connected_space.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} pos)) (comm_group.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_62485 (h0 : function.extfun Type (functor.add_const (topological_space nnreal))) : preirreducible_space nnreal := sorry --non-trivial
lemma new_lemma_62486 (h0 : functor.add_const (group (has_nndist pos)) environment.implicit_infer_kind) : @is_simple_group.{0} (has_nndist.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_nndist.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_62487 (h0 : functor.add_const (group (has_zero Type)) pos) : @is_cyclic.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_zero.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_62488 (h0 : functor.add_const (function.extfun Type ordered_comm_monoid) pos) : @has_exists_mul_of_le.{0} (has_add.{0} name) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ordered_comm_monoid.{0}) pos h0) (has_add.{0} name))  := sorry --non-trivial
lemma new_lemma_62489 (h0 : functor.add_const (list (semiring unsigned)) num) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_62490 (h0 : uniform_space (finset (option (option ennreal)))) : complete_space (finset (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_62491 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (monoid.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_62492 (h0 : ring (mul_zero_class (semiring congr_arg_kind))) : strong_rank_condition (mul_zero_class (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_62493 (h0 : topological_space (comm_group (complete_distrib_lattice (cancel_monoid (option pos))))) : totally_separated_space (comm_group (complete_distrib_lattice (cancel_monoid (option pos)))) := sorry --non-trivial
lemma new_lemma_62494 (h0 : functor.add_const (topological_space (semigroup linarith.comp)) (has_neg Type)) : @topological_space.separable_space.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (semigroup.{0} linarith.comp)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_62495 (h0 : topological_space (ring Type)) : preconnected_space (ring Type) := sorry --non-trivial
lemma new_lemma_62496 (h0 : functor.add_const (topological_space (ring linarith.comp)) (has_neg linarith.comp)) : @discrete_topology.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} linarith.comp)) (has_neg.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_62497 (h0 : functor.add_const (function.extfun (Type 1) group) name) : @is_cyclic.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) name h0) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_62498 (h0 : topological_space (has_pos_part (has_neg linarith.comp))) : normal_space (has_pos_part (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_62499 (h0 : functor.add_const (function.extfun Type uniform_space) pos) : @complete_space.{0} (ring.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) pos h0) (ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_62500 (h0 : uniform_space (normed_comm_ring (semigroup (has_neg_part pos)))) : separated_space (normed_comm_ring (semigroup (has_neg_part pos))) := sorry --non-trivial
lemma new_lemma_62501 (h0 : functor.comp topological_space has_add (complete_distrib_lattice environment.implicit_infer_kind)) : @totally_disconnected_space.{0} (has_add.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind)) (@functor.comp.run.{0 0 0} topological_space.{0} has_add.{0} (complete_distrib_lattice.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_62502 (h0 : filter (div_inv_monoid (option ennreal))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_62503 (h0 : function.extfun ((Type -> Type) -> Type 1) (function.extfun (Type -> Type))) : @is_compactly_generated.{0} (cancel_monoid.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) h0 (function.extfun.{2 1} Type)) complete_lattice.{0}) (cancel_monoid.{0} num))  := sorry --non-trivial
lemma new_lemma_62504 (h0 : functor.add_const (topological_space (preorder empty)) congr_arg_kind) : @locally_compact_space.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_62505 (h0 : not (topological_space (has_add to_additive.value_type) -> false)) : @path_connected_space.{0} (has_add.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (has_add.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_62506 (h0 : ring (has_inner empty unsigned)) : strong_rank_condition (has_inner empty unsigned) := sorry --non-trivial
lemma new_lemma_62507 (h0 : group (has_to_string congr_arg_kind)) : is_cyclic (has_to_string congr_arg_kind) := sorry --non-trivial
lemma new_lemma_62508 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) linarith.comp) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_62509 (h0 : ring (complete_distrib_lattice (has_Inf pos))) : is_domain (complete_distrib_lattice (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_62510 (h0 : topological_space (canonically_ordered_monoid linarith.comp)) : irreducible_space (canonically_ordered_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_62511 (h0 : add_monoid (has_zero (add_comm_monoid (add_comm_monoid name)))) : add_monoid.fg (has_zero (add_comm_monoid (add_comm_monoid name))) := sorry --non-trivial
lemma new_lemma_62512 (h0 : functor.add_const (filter (has_neg_part Type)) environment.implicit_infer_kind) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_62513 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (with_bot.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (with_bot.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_62514 (h0 : fin has_zero.zero) : id (matrix.vec_empty (id (id h0))) := sorry --non-trivial
lemma new_lemma_62515 (h0 : topological_space (normed_group (has_inv linarith.comp_source))) : path_connected_space (normed_group (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_62516 (h0 : add_group (simple_graph (nondiscrete_normed_field environment.projection_info))) : is_add_cyclic (simple_graph (nondiscrete_normed_field environment.projection_info)) := sorry --non-trivial
lemma new_lemma_62517 (h0 : functor.add_const (fin has_zero.zero) real) : @t1_space.{1} (complete_distrib_lattice.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (complete_distrib_lattice.{1} Type)) (@functor.add_const.run.{0 0} (fin (@has_zero.zero.{0} nat nat.has_zero)) real h0))  := sorry --non-trivial
lemma new_lemma_62518 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (omega_complete_partial_order.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (omega_complete_partial_order.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_62519 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (bin_tree.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (bin_tree.{0} num))  := sorry --non-trivial
lemma new_lemma_62520 (h0 : function.extfun Type group) : @group.fg.{0} (semiring.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.comp)))))) (@function.extfun_app.{2 1} Type group.{0} h0 (semiring.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} linarith.comp)))))))  := sorry --non-trivial
lemma new_lemma_62521 (h0 : functor.add_const (complete_lattice (has_neg_part environment.implicit_infer_kind)) (has_add pos)) : @complete_lattice.is_Sup_finite_compact.{0} (has_neg_part.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_neg_part.{0} environment.implicit_infer_kind)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_62522 (h0 : not (topological_space (has_emptyc congr_arg_kind) -> false)) : @totally_disconnected_space.{0} (has_emptyc.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (has_emptyc.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_62523 (h0 : topological_space (ordered_comm_monoid (has_neg linarith.comp))) : totally_separated_space (ordered_comm_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_62524 (h0 : not (ring (has_nnnorm rat) -> false)) : @rank_condition.{0} (has_nnnorm.{0} rat) (@classical.by_contradiction'.{1} (ring.{0} (has_nnnorm.{0} rat)) h0)  := sorry --non-trivial
lemma new_lemma_62525 (h0 : add_group (has_append (has_nnnorm linarith.ineq))) : is_add_cyclic (has_append (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_62526 (h1 : topological_space (measurable_space congr_arg_kind)) : t0_space (measurable_space congr_arg_kind) := sorry --non-trivial
lemma new_lemma_62527 (h0 : topological_space (cancel_monoid linarith.comp)) : discrete_topology (cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_62528 (h0 : ring (fintype (has_nnnorm (has_nnnorm (has_nnnorm fun_info))))) : strong_rank_condition (fintype (has_nnnorm (has_nnnorm (has_nnnorm fun_info)))) := sorry --non-trivial
lemma new_lemma_62529 (h0 : add_group (distrib (has_inv fun_info))) : is_add_cyclic (distrib (has_inv fun_info)) := sorry --non-trivial
lemma new_lemma_62530 (h0 : topological_space (has_neg_part (comm_group (comm_group Type)))) : t1_space (has_neg_part (comm_group (comm_group Type))) := sorry --non-trivial
lemma new_lemma_62531 (h0 : topological_space (comm_group (has_neg_part ennreal))) : sequential_space (comm_group (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_62532 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @path_connected_space.{0} (@id.{2} Type congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) (@id.{2} Type congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_62533 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (measure_theory.measure_space.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (measure_theory.measure_space.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_62534 (h0 : topological_space (comm_ring (has_ssubset (has_norm linarith.ineq)))) : path_connected_space (comm_ring (has_ssubset (has_norm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_62535 (h0 : pfun linarith.comp_source enat) (h1 : prod linarith.comp_source enat) : pfun.graph h0 h1 := sorry --non-trivial
lemma new_lemma_62536 (h0 : topological_space (add_cancel_monoid (has_pos_part Type))) : preconnected_space (add_cancel_monoid (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_62537 (h0 : functor.add_const (cancel_comm_monoid_with_zero (has_add pos)) Type) : @unique_factorization_monoid.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (has_add.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_62538 (h0 : group (boolean_algebra (has_add (has_add (has_add Type))))) : is_simple_group (boolean_algebra (has_add (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_62539 (h0 : not (function.extfun Type uniform_space -> false)) : @complete_space.{0} (semiring.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type uniform_space.{0}) h0) (semiring.{0} empty))  := sorry --non-trivial
lemma new_lemma_62540 (h0 : ring (add_cancel_monoid (comm_group unsigned))) : rank_condition (add_cancel_monoid (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_62541 (h0 : complete_lattice (normed_group (has_norm (has_norm empty)))) : is_atomistic (normed_group (has_norm (has_norm empty))) := sorry --non-trivial
lemma new_lemma_62542 (h0 : function.extfun Type topological_space) : @t1_space.{0} (bin_tree.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (bin_tree.{0} num))  := sorry --non-trivial
lemma new_lemma_62543 (h0 : ring (linear_ordered_add_comm_group (has_sdiff char))) : is_domain (linear_ordered_add_comm_group (has_sdiff char)) := sorry --non-trivial
lemma new_lemma_62544 (h0 : functor.add_const (topological_space (mul_zero_class num)) unsigned) : @locally_compact_space.{0} (mul_zero_class.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} num)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_62545 (h0 : add_group (has_top (has_top congr_arg_kind))) : is_add_cyclic (has_top (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_62546 (h0 : add_monoid (has_nndist (option (option (option unsigned))))) : add_monoid.fg (has_nndist (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_62547 (h0 : function.extfun Type group) : @group.fg.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_62548 (h0 : functor.add_const (function.extfun (Type 1) topological_space) pos) : @irreducible_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) pos h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_62549 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) name) : @t0_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_62550 (h0 : group (boolean_algebra.core (has_add Type))) : is_cyclic (boolean_algebra.core (has_add Type)) := sorry --non-trivial
lemma new_lemma_62551 (h1 : add_group (complete_semilattice_Sup congr_arg_kind)) : is_add_cyclic (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_62552 (h1 : ring (fintype char)) : rank_condition (fintype char) := sorry --non-trivial
lemma new_lemma_62553 (h0 : topological_space (has_Inf (has_Inf (has_Inf pos)))) : normal_space (has_Inf (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_62554 (h1 : ring (distrib_lattice (has_ssubset char))) : is_domain (distrib_lattice (has_ssubset char)) := sorry --non-trivial
lemma new_lemma_62555 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (canonically_ordered_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_62556 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (boolean_algebra.core unsigned)) := sorry --non-trivial
lemma new_lemma_62557 (h0 : ring (lattice fun_info)) : is_domain (lattice fun_info) := sorry --non-trivial
lemma new_lemma_62558 (h0 : topological_space (linear_ordered_add_comm_group linarith.comp_source)) : t0_space (linear_ordered_add_comm_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_62559 (h0 : function.extfun Type complete_lattice) : @complete_lattice.is_Sup_finite_compact.{0} (has_nnnorm.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (has_nnnorm.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_62560 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normal_space.{0} (normed_group.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_62561 (h0 : list (is_R_or_C unsigned)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_62562 (h0 : functor.add_const (function.extfun Type topological_space) name) : @totally_disconnected_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_62563 (h1 : topological_space (add_left_cancel_monoid fun_info)) : path_connected_space (add_left_cancel_monoid fun_info) := sorry --non-trivial
lemma new_lemma_62564 (h0 : list (has_neg_part pos)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_62565 (h0 : topological_space (semigroup (has_add Type))) : regular_space (semigroup (has_add Type)) := sorry --non-trivial
lemma new_lemma_62566 (h0 : complete_lattice (random_gen (with_bot (with_bot (with_bot string_imp))))) : is_compactly_generated (random_gen (with_bot (with_bot (with_bot string_imp)))) := sorry --non-trivial
lemma new_lemma_62567 (h0 : function.extfun Type (prod (ring empty))) : id_rel (function.extfun_app h0 (ring empty)) := sorry --non-trivial
lemma new_lemma_62568 (h0 : ordered_comm_monoid (has_neg_part (has_neg_part (finset (has_neg_part Type))))) : has_exists_mul_of_le (has_neg_part (has_neg_part (finset (has_neg_part Type)))) := sorry --non-trivial
lemma new_lemma_62569 (h0 : ring (generalized_boolean_algebra (has_Inf (has_Inf pos)))) : strong_rank_condition (generalized_boolean_algebra (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_62570 (h0 : uniform_space (add_group (has_top congr_arg_kind))) : separated_space (add_group (has_top congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_62571 (h0 : function.extfun (((Type -> Type) -> Type 1) -> Type 1) (function.extfun ((Type -> Type) -> Type 1))) : @is_domain.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@function.extfun_app.{3 2} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (@function.extfun_app.{3 3} (((Type → Type) → Type 1) → Type 1) (function.extfun.{3 2} ((Type → Type) → Type 1)) h0 (function.extfun.{2 2} (Type → Type))) (function.extfun.{2 1} Type)) ring.{0}) (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_62572 (h0 : uniform_space (id (linear_ordered_semiring linarith.comp))) : separated_space (id (linear_ordered_semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_62573 (h0 : fin has_zero.zero) : @is_noetherian_ring.{0} (linear_ordered_semiring.{0} (has_top.{0} congr_arg_kind)) (@matrix.vec_empty.{0} (semiring.{0} (linear_ordered_semiring.{0} (has_top.{0} congr_arg_kind))) h0)  := sorry --non-trivial
lemma new_lemma_62574 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (canonically_ordered_monoid.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_62575 (h0 : filter (semigroup (comm_group (comm_group name)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_62576 (h0 : not (functor.add_const Prop (complete_linear_order congr_arg_kind) -> false)) : functor.add_const.run (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_62577 (h0 : topological_space pos) : discrete_topology pos := sorry --non-trivial
lemma new_lemma_62578 (h0 : semiring (sub_neg_monoid (has_Inf (has_Inf (has_Inf linarith.comp))))) : is_noetherian_ring (sub_neg_monoid (has_Inf (has_Inf (has_Inf linarith.comp)))) := sorry --non-trivial
lemma new_lemma_62579 (h0 : topological_space (has_add (has_add Type))) : irreducible_space (has_add (has_add Type)) := sorry --non-trivial
lemma new_lemma_62580 (h0 : uniform_space (linear_ordered_semiring (has_norm empty))) : separated_space (linear_ordered_semiring (has_norm empty)) := sorry --non-trivial
lemma new_lemma_62581 (h0 : ring (semiring (random_gen linarith.comp))) : is_domain (semiring (random_gen linarith.comp)) := sorry --non-trivial
lemma new_lemma_62582 (h0 : function.extfun nat fin) : @totally_separated_space.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero))) (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_62583 (h0 : functor.add_const (topological_space (cancel_monoid pos)) name) : @locally_compact_space.{0} (cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (cancel_monoid.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_62584 (h0 : complete_lattice (uniform_space (mul_one_class enat))) : is_compactly_generated (uniform_space (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_62585 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (linear_ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_62586 (h0 : monoid (left_cancel_monoid num)) : monoid.fg (left_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_62587 (h0 : function.extfun Type (functor.add_const (uniform_space (simple_graph linarith.comp)))) : @complete_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (simple_graph.{0} linarith.comp)) pos (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (uniform_space.{0} (simple_graph.{0} linarith.comp))) h0 pos))  := sorry --non-trivial
lemma new_lemma_62588 (h0 : ring (has_zero (add_comm_monoid Type))) : is_domain (has_zero (add_comm_monoid Type)) := sorry --non-trivial
lemma new_lemma_62589 (h0 : functor.add_const (filter (simple_graph linarith.comp)) Type) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_62590 (h0 : add_monoid (option (add_right_cancel_monoid (option (option (ordered_ring (option num))))))) : add_monoid.fg (option (add_right_cancel_monoid (option (option (ordered_ring (option num)))))) := sorry --non-trivial
lemma new_lemma_62591 (h0 : not (add_group (measurable_space.dynkin_system congr_arg_kind) -> false)) : @is_add_cyclic.{0} (measurable_space.dynkin_system.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_group.{0} (measurable_space.dynkin_system.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_62592 (h0 : functor.add_const (complete_lattice (has_zero Type)) name) : @is_compactly_generated.{1} (has_zero.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (has_zero.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_62593 (h0 : ring (with_bot (semiring (semiring unsigned)))) : is_domain (with_bot (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_62594 (h0 : functor.add_const (cancel_comm_monoid_with_zero (add_cancel_monoid Type)) linarith.comp) : @unique_factorization_monoid.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (cancel_comm_monoid_with_zero.{1} (add_cancel_monoid.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_62595 (h0 : topological_space (has_inv string_imp)) : path_connected_space (has_inv string_imp) := sorry --non-trivial
lemma new_lemma_62596 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_compactly_generated.{1} Type (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 complete_lattice.{1}) Type)  := sorry --non-trivial
lemma new_lemma_62597 (h0 : group (has_dist ennreal)) : is_simple_group (has_dist ennreal) := sorry --non-trivial
lemma new_lemma_62598 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_62599 (h0 : topological_space (normed_lattice_add_comm_group (has_pos_part real))) : preconnected_space (normed_lattice_add_comm_group (has_pos_part real)) := sorry --non-trivial
lemma new_lemma_62600 (h0 : topological_space (semi_normed_comm_ring (has_nnnorm (has_nnnorm linarith.comp_source)))) : path_connected_space (semi_normed_comm_ring (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_62601 (h0 : topological_space (generalized_boolean_algebra (has_Inf pos))) : t0_space (generalized_boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_62602 (h0 h1 : linarith.comp_source) : is_distinct linarith.comp_source h0 h1 := sorry --non-trivial
lemma new_lemma_62603 (h0 : topological_space (ordered_comm_ring (has_add (has_add (has_Inf pos))))) : loc_path_connected_space (ordered_comm_ring (has_add (has_add (has_Inf pos)))) := sorry --non-trivial
lemma new_lemma_62604 (h1 : add_group (random_gen to_additive.value_type)) : is_add_cyclic (random_gen to_additive.value_type) := sorry --non-trivial
lemma new_lemma_62605 (h0 : functor.add_const (uniform_space (add_cancel_monoid Type)) pos) : @complete_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (uniform_space.{1} (add_cancel_monoid.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_62606 (h0 : not (topological_space (has_top fun_info) -> false)) : @path_connected_space.{0} (has_top.{0} fun_info) (@classical.by_contradiction'.{1} (topological_space.{0} (has_top.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_62607 (h0 : topological_space (has_inv (random_gen (random_gen linarith.ineq)))) : path_connected_space (has_inv (random_gen (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_62608 (h0 : uniform_space (complete_semilattice_Sup (semiring empty))) : complete_space (complete_semilattice_Sup (semiring empty)) := sorry --non-trivial
lemma new_lemma_62609 (h0 : topological_space (semiring (random_gen (random_gen (has_Sup linarith.ineq))))) : t0_space (semiring (random_gen (random_gen (has_Sup linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_62610 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (option pos)) := sorry --non-trivial
lemma new_lemma_62611 (h0 : topological_space (has_le linarith.ineq)) (h1 : preorder (has_le linarith.ineq)) : order_closed_topology (has_le linarith.ineq) := sorry --non-trivial
lemma new_lemma_62612 (h0 : functor.add_const (function.extfun Type group) name) : @group.fg.{0} (has_nndist.{0} name) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) name h0) (has_nndist.{0} name))  := sorry --non-trivial
lemma new_lemma_62613 (h0 : cancel_comm_monoid_with_zero (monoid (option unsigned))) : unique_factorization_monoid (monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_62614 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (normed_lattice_add_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (normed_lattice_add_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_62615 (h0 : functor.add_const (topological_space (has_to_string num)) num) : @preconnected_space.{0} (has_to_string.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_62616 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (with_one.{0} num) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (with_one.{0} num))  := sorry --non-trivial
lemma new_lemma_62617 (h0 : function.extfun (Type 1) topological_space) : @loc_path_connected_space.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_62618 (h0 : filter (add_right_cancel_monoid (semiring (semiring (semiring empty))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_62619 (h0 : functor.add_const (group (has_to_string pos)) name) : @is_simple_group.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (has_to_string.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_62620 (h0 : functor.add_const (monoid znum) unsigned) : @monoid.fg.{0} znum (@functor.add_const.run.{0 0} (monoid.{0} znum) unsigned h0)  := sorry --non-trivial
lemma new_lemma_62621 (h0 : ring (add_right_cancel_monoid num)) : strong_rank_condition (add_right_cancel_monoid num) := sorry --non-trivial
lemma new_lemma_62622 (h2 : measurable_space (has_ssubset string.iterator_imp)) (h3 : set (has_ssubset string.iterator_imp)) : measurable_set h3 := sorry --non-trivial
lemma new_lemma_62623 (h0 : functor.add_const (function.extfun (Type 1) topological_space) linarith.comp) : @t0_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) topological_space.{1}) linarith.comp h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_62624 (h0 : functor.add_const (topological_space (has_neg unsigned)) environment.implicit_infer_kind) : @t0_space.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_62625 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (finset.{0} stieltjes_function) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (finset.{0} stieltjes_function))  := sorry --non-trivial
lemma new_lemma_62626 (h0 : prod (complete_linear_order empty) (complete_linear_order empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_62627 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (left_cancel_semigroup num)) := sorry --non-trivial
lemma new_lemma_62628 (h0 : ring (with_one (has_top linarith.ineq))) : is_domain (with_one (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_62629 (h0 : filter (sub_neg_monoid (has_Inf (has_Inf (has_add Type))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_62630 (h0 : has_mem.mem uniform_space has_emptyc.emptyc) : @separated_space.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type uniform_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) uniform_space.{0} h0) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_62631 (h0 : has_le (dlist (random_gen (random_gen to_additive.value_type)))) (h1 : bounded_order (dlist (random_gen (random_gen to_additive.value_type)))) : is_simple_order (dlist (random_gen (random_gen to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_62632 (h0 : functor.add_const (ordered_add_comm_monoid (normed_linear_ordered_group unsigned)) empty) : @archimedean.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (normed_linear_ordered_group.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_62633 (h0 : cancel_comm_monoid_with_zero (boolean_algebra.core (option unsigned))) : unique_factorization_monoid (boolean_algebra.core (option unsigned)) := sorry --non-trivial
lemma new_lemma_62634 (h0 : topological_space (has_div char)) : totally_disconnected_space (has_div char) := sorry --non-trivial
lemma new_lemma_62635 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (linear_ordered_field.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_62636 (h1 : group (has_ssubset (random_gen (random_gen string_imp)))) : group.fg (has_ssubset (random_gen (random_gen string_imp))) := sorry --non-trivial
lemma new_lemma_62637 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (complete_linear_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (complete_linear_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_62638 (h0 : ordered_add_comm_monoid (has_add (has_Inf pos))) : archimedean (has_add (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_62639 (h0 : topological_space (with_bot (has_star (has_top congr_arg_kind)))) : preirreducible_space (with_bot (has_star (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_62640 (h0 : functor.add_const (topological_space (canonically_ordered_comm_semiring ennreal)) name) : @topological_space.separable_space.{0} (canonically_ordered_comm_semiring.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_ordered_comm_semiring.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_62641 (h0 : functor.comp topological_space normed_comm_ring name) : @t0_space.{0} (normed_comm_ring.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} normed_comm_ring.{0} name h0)  := sorry --non-trivial
lemma new_lemma_62642 (h0 : filter (has_neg linarith.comp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_62643 (h0 : not (function.extfun Type group -> false)) : @group.fg.{0} (distrib_lattice.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (distrib_lattice.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_62644 (h0 : complete_lattice (has_top congr_arg_kind)) : is_compactly_generated (has_top congr_arg_kind) := sorry --non-trivial
lemma new_lemma_62645 (h0 : functor.add_const (ring (canonically_ordered_comm_semiring Type)) Type) : @rank_condition.{1} (canonically_ordered_comm_semiring.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (canonically_ordered_comm_semiring.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_62646 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (normed_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type semiring.{0} h0 (normed_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_62647 (h0 : add_monoid (add_comm_monoid (option unsigned))) : add_monoid.fg (add_comm_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_62648 (h0 : ring (boolean_algebra (comm_group (has_add name)))) : is_domain (boolean_algebra (comm_group (has_add name))) := sorry --non-trivial
lemma new_lemma_62649 (h0 : topological_space (has_norm (semiring congr_arg_kind))) : discrete_topology (has_norm (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_62650 (h0 : functor.add_const (ring (semigroup environment.implicit_infer_kind)) Type) : @is_domain.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ring.{0} (semigroup.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_62651 (h0 : not (filter (partial_order unsigned) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_62652 (h0 : functor.add_const (function.extfun Type complete_lattice) (option pos)) : @is_atomistic.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) (option.{0} pos) h0) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_62653 (h0 : topological_space (comm_group (boolean_algebra (has_add (has_add Type))))) : loc_path_connected_space (comm_group (boolean_algebra (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_62654 (h0 : topological_space (ring (option empty))) : preirreducible_space (ring (option empty)) := sorry --non-trivial
lemma new_lemma_62655 (h0 : topological_space (comm_group (option unsigned))) : totally_disconnected_space (comm_group (option unsigned)) := sorry --non-trivial
lemma new_lemma_62656 (h0 : functor.add_const (complete_lattice (add_cancel_monoid ennreal)) (option (option name))) : @complete_lattice.is_Sup_finite_compact.{0} (add_cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_cancel_monoid.{0} ennreal)) (option.{0} (option.{0} name)) h0)  := sorry --non-trivial
lemma new_lemma_62657 (h1 : topological_space (distrib_lattice fun_info)) : path_connected_space (distrib_lattice fun_info) := sorry --non-trivial
lemma new_lemma_62658 (h0 : not (ring (has_compl fun_info) -> false)) : @strong_rank_condition.{0} (has_compl.{0} fun_info) (@classical.by_contradiction'.{1} (ring.{0} (has_compl.{0} fun_info)) h0)  := sorry --non-trivial
lemma new_lemma_62659 (h0 : topological_space (normed_lattice_add_comm_group (has_add linarith.comp))) : preconnected_space (normed_lattice_add_comm_group (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_62660 (h0 : list (comm_ring (has_ssubset linarith.ineq))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_62661 (h0 : list (boolean_algebra (finset (finset (finset (finset Type)))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_62662 (h0 : complete_lattice (distrib (has_nnnorm char))) : complete_lattice.is_Sup_finite_compact (distrib (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_62663 (h0 : topological_space (linear_ordered_cancel_comm_monoid congr_arg_kind)) : discrete_topology (linear_ordered_cancel_comm_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_62664 (h0 : topological_space (add_cancel_monoid (has_nndist (has_Inf name)))) : normal_space (add_cancel_monoid (has_nndist (has_Inf name))) := sorry --non-trivial
lemma new_lemma_62665 (h0 : functor.add_const (topological_space (has_add name)) pos) : @preconnected_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_62666 (h0 : functor.add_const (topological_space (simple_graph pos)) name) : @totally_separated_space.{0} (simple_graph.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (simple_graph.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_62667 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) Type) : @preirreducible_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_62668 (h0 : ring (add_comm_monoid (comm_monoid unsigned))) : is_principal_ideal_ring (add_comm_monoid (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_62669 (h0 : cancel_comm_monoid_with_zero (has_Inf (has_Inf Type))) : unique_factorization_monoid (has_Inf (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_62670 (h0 : topological_space (with_bot linarith.comp_source)) : totally_separated_space (with_bot linarith.comp_source) := sorry --non-trivial
lemma new_lemma_62671 (h0 : topological_space (metric_space (has_norm linarith.comp))) : normal_space (metric_space (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_62672 (h0 : topological_space (boolean_algebra (comm_group Type))) : totally_disconnected_space (boolean_algebra (comm_group Type)) := sorry --non-trivial
lemma new_lemma_62673 (h0 : not (topological_space (distrib linarith.ineq) -> false)) : @totally_disconnected_space.{0} (distrib.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (distrib.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_62674 (h1 : not (topological_space (has_ssubset linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (has_ssubset.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_ssubset.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_62675 (h0 : complete_lattice (ring (has_neg_part name))) : is_compactly_generated (ring (has_neg_part name)) := sorry --non-trivial
lemma new_lemma_62676 (h0 : add_monoid (normed_comm_ring (has_to_string (comm_group (has_to_string (comm_group unsigned)))))) : add_monoid.fg (normed_comm_ring (has_to_string (comm_group (has_to_string (comm_group unsigned))))) := sorry --non-trivial
lemma new_lemma_62677 (h0 : list (has_edist empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_62678 (h0 : ring (ordered_cancel_add_comm_monoid num)) : strong_rank_condition (ordered_cancel_add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_62679 (h0 : filter (ordered_comm_ring (has_bot (has_neg (add_comm_monoid Type))))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_62680 (h0 : ring (random_gen (mul_one_class linarith.comp_source))) : strong_rank_condition (random_gen (mul_one_class linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_62681 (h0 : not (group (linear_ordered_semiring linarith.comp_source) -> false)) : @normalizer_condition.{0} (linear_ordered_semiring.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (linear_ordered_semiring.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_62682 (h0 : not (topological_space (semi_normed_comm_ring reducibility_hints) -> false)) : @totally_disconnected_space.{0} (semi_normed_comm_ring.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (semi_normed_comm_ring.{0} reducibility_hints)) h0)  := sorry --non-trivial
lemma new_lemma_62683 (h0 : group (add_comm_monoid (comm_group pos))) : normalizer_condition (add_comm_monoid (comm_group pos)) := sorry --non-trivial
lemma new_lemma_62684 (h0 : topological_space (nondiscrete_normed_field ereal)) (h1 : set (nondiscrete_normed_field ereal)) : is_path_connected h1 := sorry --non-trivial
lemma new_lemma_62685 (h0 : list (free_add_monoid (option empty))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_62686 (h0 : not (add_group (has_lt char) -> false)) : @is_add_cyclic.{0} (has_lt.{0} char) (@classical.by_contradiction'.{1} (add_group.{0} (has_lt.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_62687 (h0 : group (add_comm_monoid (ring linarith.comp))) : is_cyclic (add_comm_monoid (ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_62688 (h0 : functor.add_const (function.extfun Type add_monoid) name) : @add_monoid.fg.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) name h0) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_62689 (h0 : group (ordered_comm_ring (ring Type))) : group.fg (ordered_comm_ring (ring Type)) := sorry --non-trivial
lemma new_lemma_62690 (h0 : group (comm_semigroup (sub_neg_monoid Type))) : is_cyclic (comm_semigroup (sub_neg_monoid Type)) := sorry --non-trivial
lemma new_lemma_62691 (h0 : not (semiring (has_one linarith.comp) -> false)) : @is_noetherian_ring.{0} (has_one.{0} linarith.comp) (@classical.by_contradiction'.{1} (semiring.{0} (has_one.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_62692 (h0 : functor.add_const (topological_space (has_to_string pos)) pos) : @normal_space.{0} (has_to_string.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_to_string.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_62693 (h0 : functor.add_const (topological_space (boolean_algebra unsigned)) environment.implicit_infer_kind) : @path_connected_space.{0} (boolean_algebra.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_62694 (h0 : semiring (ordered_comm_monoid (ordered_comm_ring linarith.comp))) : is_noetherian_ring (ordered_comm_monoid (ordered_comm_ring linarith.comp)) := sorry --non-trivial
lemma new_lemma_62695 (h0 : topological_space (has_pos_part (has_add (has_Inf real)))) : normal_space (has_pos_part (has_add (has_Inf real))) := sorry --non-trivial
lemma new_lemma_62696 (h0 : functor.add_const (ring (add_left_cancel_semigroup empty)) congr_arg_kind) : @rank_condition.{0} (add_left_cancel_semigroup.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (add_left_cancel_semigroup.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_62697 (h0 : topological_space (finset (has_to_string Type))) : sequential_space (finset (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_62698 (h0 : ordered_comm_monoid (canonically_ordered_comm_semiring (has_to_string pos))) : has_exists_mul_of_le (canonically_ordered_comm_semiring (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_62699 (h0 : ring (normed_lattice_add_comm_group (finset real))) : is_domain (normed_lattice_add_comm_group (finset real)) := sorry --non-trivial
lemma new_lemma_62700 (h0 : monoid (simple_graph (finset (finset (finset (ring Type)))))) : monoid.fg (simple_graph (finset (finset (finset (ring Type))))) := sorry --non-trivial
lemma new_lemma_62701 (h0 : function.extfun nat fin) : @is_compactly_generated.{0} (sub_neg_monoid.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (sub_neg_monoid.{0} real)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_62702 (h0 : random_gen (has_norm linarith.comp) -> random_gen (has_norm linarith.comp) -> Prop) (h1 : set (random_gen (has_norm linarith.comp))) : is_antichain h0 h1 := sorry --non-trivial
lemma new_lemma_62703 (h0 : not (complete_lattice (mul_one_class string_imp) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (mul_one_class.{0} string_imp) (@classical.by_contradiction'.{1} (complete_lattice.{0} (mul_one_class.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_62704 (h0 : cancel_comm_monoid_with_zero (bin_tree (semiring (semiring empty)))) : unique_factorization_monoid (bin_tree (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_62705 (h0 : complete_lattice (has_add (monoid_with_zero fun_info))) : complete_lattice.is_Sup_finite_compact (has_add (monoid_with_zero fun_info)) := sorry --non-trivial
lemma new_lemma_62706 (h0 : functor.add_const (topological_space (has_neg Type)) Type) : @discrete_topology.{1} (has_neg.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (has_neg.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_62707 (h0 : ordered_add_comm_monoid (has_bot (has_add (has_Inf Type)))) : archimedean (has_bot (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_62708 (h0 : topological_space (sub_neg_monoid (has_Inf real))) : totally_separated_space (sub_neg_monoid (has_Inf real)) := sorry --non-trivial
lemma new_lemma_62709 (h0 : functor.add_const (topological_space (ordered_comm_group empty)) empty) : @t1_space.{0} (ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (ordered_comm_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_62710 (h0 : functor.add_const (topological_space (semigroup (has_Inf pos))) (has_pos_part linarith.comp)) : @t1_space.{0} (semigroup.{0} (has_Inf.{0} pos)) (@functor.add_const.run.{0 0} (topological_space.{0} (semigroup.{0} (has_Inf.{0} pos))) (has_pos_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_62711 (h1 : add_group (topological_space char)) : is_add_cyclic (topological_space char) := sorry --non-trivial
lemma new_lemma_62712 (h2 : filter (distrib_lattice (has_nnnorm fun_info))) : filter.ne_bot h2 := sorry --non-trivial
lemma new_lemma_62713 (h0 : functor.add_const (add_monoid (has_star congr_arg_kind)) (semiring empty)) : @add_monoid.fg.{0} (has_star.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (add_monoid.{0} (has_star.{0} congr_arg_kind)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_62714 (h0 : function.extfun Type (functor.add_const (ring environment.implicit_infer_kind))) : @rank_condition.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (ring.{0} environment.implicit_infer_kind) (finset.{0} (has_Inf.{0} pos)) (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ring.{0} environment.implicit_infer_kind)) h0 (finset.{0} (has_Inf.{0} pos))))  := sorry --non-trivial
lemma new_lemma_62715 (h0 : group (denumerable (random_gen (has_top (has_inv fun_info))))) : is_cyclic (denumerable (random_gen (has_top (has_inv fun_info)))) := sorry --non-trivial
lemma new_lemma_62716 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (ordered_ring.{0} (option.{0} unsigned)) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_ring.{0} (option.{0} unsigned)))  := sorry --non-trivial
lemma new_lemma_62717 (h0 : finset (has_pos_part (ring (has_pos_part Type)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_62718 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_62719 (h0 : functor.add_const (topological_space (ordered_comm_ring Type)) pos) : @regular_space.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ordered_comm_ring.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_62720 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (cancel_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (cancel_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_62721 (h0 : group (has_Inf (finset (finset (finset Type))))) : group.fg (has_Inf (finset (finset (finset Type)))) := sorry --non-trivial
lemma new_lemma_62722 (h0 : function.extfun Type ring) : @is_domain.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_62723 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_add_cyclic.{0} (has_pos_part.{0} real) (@matrix.vec_empty.{0} (add_group.{0} (has_pos_part.{0} real)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_62724 (h0 : topological_space (measurable_space.dynkin_system (semiring (semiring congr_arg_kind)))) : t0_space (measurable_space.dynkin_system (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_62725 (h1 : monoid (has_emptyc (random_gen to_additive.value_type))) : monoid.fg (has_emptyc (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_62726 (h0 : topological_space (semiring (has_top (has_top linarith.comp_source)))) : totally_disconnected_space (semiring (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_62727 (h0 : uniform_space (has_neg Type)) : complete_space (has_neg Type) := sorry --non-trivial
lemma new_lemma_62728 (h0 : topological_space (canonically_ordered_comm_semiring (has_add pos))) : preirreducible_space (canonically_ordered_comm_semiring (has_add pos)) := sorry --non-trivial
lemma new_lemma_62729 (h0 : fun_info -> fun_info -> Prop) (h1 : set fun_info) : zorn.chain h0 h1 := sorry --non-trivial
lemma new_lemma_62730 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_62731 (h0 : function.extfun Type topological_space) : @discrete_topology.{0} (left_cancel_semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_62732 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (has_top.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_top.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_62733 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (random_gen.{0} linarith.ineq) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (random_gen.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_62734 (h0 : topological_space (generalized_boolean_algebra (has_neg name))) : totally_separated_space (generalized_boolean_algebra (has_neg name)) := sorry --non-trivial
lemma new_lemma_62735 (h0 : functor.add_const (topological_space (has_star unsigned)) num) : @totally_disconnected_space.{0} (has_star.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_62736 (h0 : function.extfun Type (functor.comp topological_space mul_zero_class)) : @t1_space.{0} (mul_zero_class.{0} pos) (@functor.comp.run.{0 0 0} topological_space.{0} mul_zero_class.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} mul_zero_class.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_62737 (h1 : not (group (has_nnnorm linarith.comp_source) -> false)) : @is_cyclic.{0} (has_nnnorm.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (group.{0} (has_nnnorm.{0} linarith.comp_source)) h1)  := sorry --non-trivial
lemma new_lemma_62738 (h0 : topological_space (generalized_boolean_algebra (ring name))) : locally_compact_space (generalized_boolean_algebra (ring name)) := sorry --non-trivial
lemma new_lemma_62739 (h0 : monoid (boolean_algebra.core (boolean_algebra name))) : monoid.fg (boolean_algebra.core (boolean_algebra name)) := sorry --non-trivial
lemma new_lemma_62740 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} linarith.comp (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) linarith.comp)  := sorry --non-trivial
lemma new_lemma_62741 (h0 : topological_space (linear_ordered_add_comm_monoid_with_top (has_nnnorm linarith.ineq))) : t0_space (linear_ordered_add_comm_monoid_with_top (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_62742 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (ordered_comm_monoid.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (ordered_comm_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_62743 (h0 : functor.add_const (complete_lattice (boolean_algebra.core Type)) Type) : @complete_lattice.is_Sup_finite_compact.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 1} (complete_lattice.{1} (boolean_algebra.core.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_62744 (h0 : complete_lattice (ordered_comm_semiring (has_nnnorm linarith.ineq))) : is_compactly_generated (ordered_comm_semiring (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_62745 (h0 : functor.add_const (ordered_comm_monoid (has_neg environment.implicit_infer_kind)) Type) : @has_exists_mul_of_le.{0} (has_neg.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (ordered_comm_monoid.{0} (has_neg.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_62746 (h0 : uniform_space (has_zero to_additive.value_type)) : complete_space (has_zero to_additive.value_type) := sorry --non-trivial
lemma new_lemma_62747 (h0 : group (boolean_algebra (finset environment.implicit_infer_kind))) : normalizer_condition (boolean_algebra (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_62748 (h1 : complete_lattice (comm_ring linarith.ineq)) : complete_lattice.is_Sup_finite_compact (comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_62749 (h0 : functor.add_const (topological_space (has_star congr_arg_kind)) unsigned) : @normal_space.{0} (has_star.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_star.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_62750 (h0 : cancel_comm_monoid_with_zero (complete_distrib_lattice (has_Inf Type))) : unique_factorization_monoid (complete_distrib_lattice (has_Inf Type)) := sorry --non-trivial
lemma new_lemma_62751 (h0 : topological_space (has_union (semiring (semiring unsigned)))) : path_connected_space (has_union (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_62752 (h0 : topological_space (has_norm linarith.comp)) : normal_space (has_norm linarith.comp) := sorry --non-trivial
lemma new_lemma_62753 (h3 h4 : Prop) : yyy_to h3 h4 := sorry --non-trivial
lemma new_lemma_62754 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_separated_space.{0} (bin_tree.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (bin_tree.{0} num))  := sorry --non-trivial
lemma new_lemma_62755 (h0 : uniform_space (sub_neg_monoid (has_neg linarith.comp))) : separated_space (sub_neg_monoid (has_neg linarith.comp)) := sorry --non-trivial
lemma new_lemma_62756 (h0 : complete_lattice fun_info) : is_atomistic fun_info := sorry --non-trivial
lemma new_lemma_62757 (h0 : functor.add_const (topological_space (comm_group pos)) unsigned) : @totally_disconnected_space.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_62758 (h1 : add_group (add_monoid (has_nnnorm char))) : is_add_cyclic (add_monoid (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_62759 (h0 : functor.add_const (complete_lattice (add_cancel_monoid Type)) (boolean_algebra linarith.comp)) : @is_compactly_generated.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (complete_lattice.{1} (add_cancel_monoid.{1} Type)) (boolean_algebra.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_62760 (h0 : ring (add_left_cancel_semigroup (semiring empty))) : is_domain (add_left_cancel_semigroup (semiring empty)) := sorry --non-trivial
lemma new_lemma_62761 (h0 : function.extfun nat fin) : @monoid.fg.{0} (has_bot.{0} name) (@matrix.vec_empty.{0} (monoid.{0} (has_bot.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_62762 (h0 : function.extfun Type topological_space) : preconnected_space real := sorry --non-trivial
lemma new_lemma_62763 (h0 : functor.add_const (function.extfun Type list) pos) : palindrome (function.extfun_app (functor.add_const.run h0) (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_62764 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (ring.{0} num) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ring.{0} num))  := sorry --non-trivial
lemma new_lemma_62765 (h0 : has_mem.mem (has_emptyc to_additive.value_type) has_emptyc.emptyc) : @t0_space.{0} (has_emptyc.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_emptyc.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_62766 (h0 : not (complete_lattice (with_one congr_arg_kind) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_one.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_one.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_62767 (h0 : group (random_gen (has_top fun_info))) : normalizer_condition (random_gen (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_62768 (h0 : ring (has_norm (semiring congr_arg_kind))) : is_domain (has_norm (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_62769 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) unsigned) : @irreducible_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_62770 (h0 : not (topological_space (semiring (random_gen num)) -> false)) : @path_connected_space.{0} (semiring.{0} (random_gen.{0} num)) (@classical.by_contradiction'.{1} (topological_space.{0} (semiring.{0} (random_gen.{0} num))) h0)  := sorry --non-trivial
lemma new_lemma_62771 (h0 : topological_space (has_add pos)) : totally_separated_space (has_add pos) := sorry --non-trivial
lemma new_lemma_62772 (h0 : group (has_neg (finset (has_add linarith.comp)))) : is_simple_group (has_neg (finset (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_62773 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (add_right_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (add_right_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_62774 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (sub_neg_monoid.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} real))  := sorry --non-trivial
lemma new_lemma_62775 (h0 : add_monoid (option congr_arg_kind)) : add_monoid.fg (option congr_arg_kind) := sorry --non-trivial
lemma new_lemma_62776 (h1 : ring (linear_ordered_add_comm_group to_additive.value_type)) : strong_rank_condition (linear_ordered_add_comm_group to_additive.value_type) := sorry --non-trivial
lemma new_lemma_62777 (h0 : function.extfun Type group) : @is_cyclic.{0} (complete_distrib_lattice.{0} real) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_distrib_lattice.{0} real))  := sorry --non-trivial
lemma new_lemma_62778 (h0 : group (complete_semilattice_Sup (has_inv (random_gen linarith.ineq)))) : is_cyclic (complete_semilattice_Sup (has_inv (random_gen linarith.ineq))) := sorry --non-trivial
lemma new_lemma_62779 (h0 : functor.add_const (topological_space (boolean_algebra name)) pos) : @t0_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_62780 (h0 : not (ring (random_gen string_imp) -> false)) : @strong_rank_condition.{0} (random_gen.{0} string_imp) (@classical.by_contradiction'.{1} (ring.{0} (random_gen.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_62781 (h0 : finset (ordered_comm_group empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_62782 (h0 : uniform_space (has_add (option (option (has_zero num))))) : complete_space (has_add (option (option (has_zero num)))) := sorry --non-trivial
lemma new_lemma_62783 (h0 : filter (plift (semiring (semiring num)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_62784 (h0 : filter (boolean_algebra name)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_62785 (h0 : topological_space (has_to_string (finset ennreal))) : totally_disconnected_space (has_to_string (finset ennreal)) := sorry --non-trivial
lemma new_lemma_62786 (h0 : functor.comp ring boolean_algebra.core Type) : @is_domain.{1} (boolean_algebra.core.{1} Type) (@functor.comp.run.{1 1 1} ring.{1} boolean_algebra.core.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_62787 (h0 : filter (has_add (option (option pos)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_62788 (h0 : set (nondiscrete_normed_field (mul_one_class string.iterator_imp))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_62789 (h0 : topological_space (has_to_string (has_Inf (has_Inf linarith.comp)))) : normal_space (has_to_string (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_62790 (h0 : group (ordered_comm_monoid (has_Inf pos))) : normalizer_condition (ordered_comm_monoid (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_62791 (h0 : ring (has_Inf (has_neg name))) : rank_condition (has_Inf (has_neg name)) := sorry --non-trivial
lemma new_lemma_62792 (h0 : functor.comp topological_space has_neg_part ennreal) : @discrete_topology.{0} (has_neg_part.{0} ennreal) (@functor.comp.run.{0 0 0} topological_space.{0} has_neg_part.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_62793 (h0 : functor.add_const (topological_space (mul_zero_class name)) name) : @totally_disconnected_space.{0} (mul_zero_class.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (mul_zero_class.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_62794 (h0 : topological_space (semigroup (filter (normed_comm_ring environment.implicit_infer_kind)))) : sequential_space (semigroup (filter (normed_comm_ring environment.implicit_infer_kind))) := sorry --non-trivial
lemma new_lemma_62795 (h0 : functor.add_const (complete_lattice (ordered_comm_monoid real)) (has_add pos)) : @complete_lattice.is_Sup_finite_compact.{0} (ordered_comm_monoid.{0} real) (@functor.add_const.run.{0 0} (complete_lattice.{0} (ordered_comm_monoid.{0} real)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_62796 (h0 : functor.add_const (finset (has_neg_part ennreal)) pos) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_62797 (h0 : ring (comm_ring (has_top fun_info))) : is_domain (comm_ring (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_62798 (h0 : complete_lattice (left_cancel_monoid (semiring (semiring (semiring congr_arg_kind))))) : is_atomistic (left_cancel_monoid (semiring (semiring (semiring congr_arg_kind)))) := sorry --non-trivial
lemma new_lemma_62799 (h0 : not (has_lt (linear_ordered_semiring num) -> false)) : @no_min_order.{0} (linear_ordered_semiring.{0} num) (@classical.by_contradiction'.{1} (has_lt.{0} (linear_ordered_semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_62800 (h0 : ring (topological_space (has_nnnorm char))) : is_domain (topological_space (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_62801 (h0 : fin has_zero.zero) : @is_cyclic.{0} (generalized_boolean_algebra.{0} linarith.comp) (@matrix.vec_empty.{0} (group.{0} (generalized_boolean_algebra.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_62802 (h0 : functor.add_const (topological_space (has_pos_part Type)) pos) : @sequential_space.{1} (has_pos_part.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_pos_part.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_62803 (h0 : functor.add_const (ring (metric_space num)) num) : @is_domain.{0} (metric_space.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (metric_space.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_62804 (h0 : set (linear_ordered_comm_group_with_zero linarith.comp_source)) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_62805 (h0 : functor.add_const (topological_space (comm_group Type)) name) : @regular_space.{1} (comm_group.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (comm_group.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_62806 (h0 : complete_lattice (complete_semilattice_Sup (random_gen to_additive.value_type))) : is_compactly_generated (complete_semilattice_Sup (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_62807 (h0 : function.extfun Type group) : @group.fg.{0} (linear_ordered_cancel_comm_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_cancel_comm_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_62808 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (complete_distrib_lattice.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (complete_distrib_lattice.{0} num))  := sorry --non-trivial
lemma new_lemma_62809 (h0 : topological_space (cancel_monoid (finset pos))) : irreducible_space (cancel_monoid (finset pos)) := sorry --non-trivial
lemma new_lemma_62810 (h0 : functor.add_const (uniform_space (preorder empty)) num) : @complete_space.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (preorder.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_62811 (h0 : not (function.extfun Type topological_space -> false)) : @t0_space.{0} (random_gen.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (random_gen.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_62812 (h0 : topological_space (normed_linear_ordered_group congr_arg_kind)) : discrete_topology (normed_linear_ordered_group congr_arg_kind) := sorry --non-trivial
lemma new_lemma_62813 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} num) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (random_gen.{0} num))  := sorry --non-trivial
lemma new_lemma_62814 (h0 : functor.add_const (topological_space (has_pos_part pos)) (has_neg Type)) : @regular_space.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 1} (topological_space.{0} (has_pos_part.{0} pos)) (has_neg.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_62815 (h0 : group (comm_ring (random_gen (has_nnnorm linarith.comp_source)))) : group.fg (comm_ring (random_gen (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_62816 (h0 : functor.add_const (function.extfun Type topological_space) name) : @normal_space.{0} (has_add.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) name h0) (has_add.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_62817 (h0 : add_group (has_nnnorm (has_le enat))) : is_add_cyclic (has_nnnorm (has_le enat)) := sorry --non-trivial
lemma new_lemma_62818 (h0 : uniform_space (add_group (has_norm (has_norm linarith.comp)))) : separated_space (add_group (has_norm (has_norm linarith.comp))) := sorry --non-trivial
lemma new_lemma_62819 (h0 : group (has_neg_part (option unsigned))) : group.fg (has_neg_part (option unsigned)) := sorry --non-trivial
lemma new_lemma_62820 (h0 : functor.add_const (uniform_space (option unsigned)) empty) : @complete_space.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (uniform_space.{0} (option.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_62821 (h1 : ring (nondiscrete_normed_field (mul_one_class char))) : strong_rank_condition (nondiscrete_normed_field (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_62822 (h0 : functor.add_const (topological_space (comm_group name)) name) : @topological_space.separable_space.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_62823 (h0 : functor.add_const (ring (boolean_algebra Type)) Type) : @is_domain.{1} (boolean_algebra.{1} Type) (@functor.add_const.run.{1 1} (ring.{1} (boolean_algebra.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_62824 (h0 : uniform_space (simple_graph char)) : complete_space (simple_graph char) := sorry --non-trivial
lemma new_lemma_62825 (h0 : functor.add_const (group (canonically_linear_ordered_monoid name)) pos) : @is_simple_group.{0} (canonically_linear_ordered_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (canonically_linear_ordered_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_62826 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (monoid.{0} ennreal) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_62827 (h0 : functor.add_const (ring (ring environment.implicit_infer_kind)) linarith.comp) : @is_principal_ideal_ring.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (ring.{0} (ring.{0} environment.implicit_infer_kind)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_62828 (h0 : ordered_comm_monoid (has_zero (finset linarith.comp))) : has_exists_mul_of_le (has_zero (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_62829 (h0 : functor.add_const (complete_lattice (complete_linear_order unsigned)) congr_arg_kind) : @complete_lattice.is_Sup_finite_compact.{0} (complete_linear_order.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (complete_linear_order.{0} unsigned)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_62830 (h0 : not (complete_lattice (has_lt linarith.ineq) -> false)) : @is_compactly_generated.{0} (has_lt.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_lt.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_62831 (h0 : functor.add_const (uniform_space (add_comm_monoid environment.implicit_infer_kind)) Type) : @complete_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (uniform_space.{0} (add_comm_monoid.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_62832 (h0 : empty -> empty -> Prop) : is_symm empty h0 := sorry --non-trivial
lemma new_lemma_62833 (h0 : complete_lattice empty) : complete_lattice.is_Sup_finite_compact empty := sorry --non-trivial
lemma new_lemma_62834 (h0 : uniform_space (has_add (mul_one_class (mul_one_class (mul_one_class Type))))) : separated_space (has_add (mul_one_class (mul_one_class (mul_one_class Type)))) := sorry --non-trivial
lemma new_lemma_62835 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_lattice.is_Sup_finite_compact.{0} (random_gen.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (random_gen.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_62836 (h0 : has_mem.mem (with_one empty) has_emptyc.emptyc) : @separated_space.{0} (with_one.{0} empty) (@finset.pi.empty.{1 0} Type uniform_space.{0} (with_one.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_62837 (h0 : complete_lattice (comm_group pos)) : complete_lattice.is_Sup_finite_compact (comm_group pos) := sorry --non-trivial
lemma new_lemma_62838 (h0 : ring (has_norm (has_union empty))) : is_domain (has_norm (has_union empty)) := sorry --non-trivial
lemma new_lemma_62839 (h0 : topological_space (has_ssubset (mul_one_class (mul_one_class char)))) : t0_space (has_ssubset (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_62840 (h0 : ring (id (has_top linarith.comp))) : is_domain (id (has_top linarith.comp)) := sorry --non-trivial
lemma new_lemma_62841 (h0 : functor.add_const (ring (left_cancel_semigroup num)) num) : @rank_condition.{0} (left_cancel_semigroup.{0} num) (@functor.add_const.run.{0 0} (ring.{0} (left_cancel_semigroup.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_62842 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_zero.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_62843 (h0 : functor.add_const (complete_lattice (add_group num)) num) : @is_atomistic.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (complete_lattice.{0} (add_group.{0} num)) num h0)  := sorry --non-trivial
lemma new_lemma_62844 (h0 : fin has_zero.zero) : @t0_space.{1} (has_add.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@matrix.vec_empty.{2} (function.extfun.{3 2} (Type 1) topological_space.{1}) h0) (has_add.{1} Type))  := sorry --non-trivial
lemma new_lemma_62845 (h0 : topological_space (semigroup (finset pos))) : totally_separated_space (semigroup (finset pos)) := sorry --non-trivial
lemma new_lemma_62846 (h0 : topological_space (has_add (has_add (has_add (has_add (has_to_string linarith.comp)))))) : sequential_space (has_add (has_add (has_add (has_add (has_to_string linarith.comp))))) := sorry --non-trivial
lemma new_lemma_62847 (h0 : fin has_zero.zero) : @normalizer_condition.{0} pos (@matrix.vec_empty.{0} (group.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_62848 (h0 : ordered_add_comm_monoid (simple_graph (ring Type))) : archimedean (simple_graph (ring Type)) := sorry --non-trivial
lemma new_lemma_62849 (h0 : uniform_space (uniform_space (option (option empty)))) : complete_space (uniform_space (option (option empty))) := sorry --non-trivial
lemma new_lemma_62850 (h0 : functor.add_const (ring (has_bot name)) (has_Inf Type)) : @strong_rank_condition.{0} (has_bot.{0} name) (@functor.add_const.run.{0 1} (ring.{0} (has_bot.{0} name)) (has_Inf.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_62851 (h0 : filter (cancel_monoid name)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_62852 (h0 : ordered_add_comm_monoid (has_bot (semiring empty))) : archimedean (has_bot (semiring empty)) := sorry --non-trivial
lemma new_lemma_62853 (h0 : group (has_to_string (has_nndist linarith.comp))) : normalizer_condition (has_to_string (has_nndist linarith.comp)) := sorry --non-trivial
lemma new_lemma_62854 (h0 : has_neg num -> has_neg num -> Prop) : well_founded h0 := sorry --non-trivial
lemma new_lemma_62855 (h0 : topological_space (has_neg (normed_comm_ring Type))) : totally_disconnected_space (has_neg (normed_comm_ring Type)) := sorry --non-trivial
lemma new_lemma_62856 (h0 : functor.add_const (topological_space (add_cancel_comm_monoid empty)) empty) : @totally_disconnected_space.{0} (add_cancel_comm_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_comm_monoid.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_62857 (h0 : topological_space (has_one fun_info)) : path_connected_space (has_one fun_info) := sorry --non-trivial
lemma new_lemma_62858 (h0 : topological_space (has_Inf (has_add (ring Type)))) : locally_compact_space (has_Inf (has_add (ring Type))) := sorry --non-trivial
lemma new_lemma_62859 (h0 : topological_space (has_one (semiring (semiring (random_gen linarith.comp))))) : discrete_topology (has_one (semiring (semiring (random_gen linarith.comp)))) := sorry --non-trivial
lemma new_lemma_62860 (h0 : function.extfun Type group) : @normalizer_condition.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_62861 (h0 : functor.add_const (add_group (partial_order unsigned)) empty) : @is_add_cyclic.{0} (partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (add_group.{0} (partial_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_62862 (h0 : topological_space (add_cancel_comm_monoid (semiring empty))) : loc_path_connected_space (add_cancel_comm_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_62863 (h0 : fin has_zero.zero) : @monoid.fg.{0} (boolean_algebra.{0} real) (@matrix.vec_empty.{0} (monoid.{0} (boolean_algebra.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))  := sorry --non-trivial
lemma new_lemma_62864 (h0 : functor.add_const (function.extfun Type list) (ring (finset linarith.comp))) : list.nodup (function.extfun_app (functor.add_const.run h0) (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_62865 (h0 : topological_space (add_comm_monoid (has_neg name))) : totally_disconnected_space (add_comm_monoid (has_neg name)) := sorry --non-trivial
lemma new_lemma_62866 (h0 : fin has_zero.zero) : @locally_compact_space.{0} (has_bot.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_62867 (h0 : group (has_add (option congr_arg_kind))) : is_cyclic (has_add (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_62868 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @is_atomistic.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (complete_lattice.{0} (comm_semigroup.{0} real)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_62869 (h0 : topological_space (has_union (has_norm num))) : normal_space (has_union (has_norm num)) := sorry --non-trivial
lemma new_lemma_62870 (h0 : functor.comp ring normed_comm_ring ennreal) : @is_principal_ideal_ring.{0} (normed_comm_ring.{0} ennreal) (@functor.comp.run.{0 0 0} ring.{0} normed_comm_ring.{0} ennreal h0)  := sorry --non-trivial
lemma new_lemma_62871 (h0 : functor.add_const (ring (preorder unsigned)) num) : @is_principal_ideal_ring.{0} (preorder.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (preorder.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_62872 (h0 : functor.add_const (topological_space (add_left_cancel_semigroup unsigned)) empty) : @locally_compact_space.{0} (add_left_cancel_semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_left_cancel_semigroup.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_62873 (h1 : topological_space (has_neg_part enat)) : t0_space (has_neg_part enat) := sorry --non-trivial
lemma new_lemma_62874 (h0 : semiring (has_sub congr_arg_kind)) : is_noetherian_ring (has_sub congr_arg_kind) := sorry --non-trivial
lemma new_lemma_62875 (h0 : functor.add_const (monoid (semigroup linarith.comp)) Type) : @monoid.fg.{0} (semigroup.{0} linarith.comp) (@functor.add_const.run.{0 1} (monoid.{0} (semigroup.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_62876 (h0 : monoid (option (semiring (semiring congr_arg_kind))) -> Prop) (h1 : function.extfun (monoid (option (semiring (semiring congr_arg_kind))) -> Prop) Exists) : @monoid.fg.{0} (option.{0} (semiring.{0} (semiring.{0} congr_arg_kind))) (@classical.some.{1} (monoid.{0} (option.{0} (semiring.{0} (semiring.{0} congr_arg_kind)))) h0 (@function.extfun_app.{1 0} (monoid.{0} (option.{0} (semiring.{0} (semiring.{0} congr_arg_kind))) → Prop) (@Exists.{1} (monoid.{0} (option.{0} (semiring.{0} (semiring.{0} congr_arg_kind))))) h1 (λ (x : monoid.{0} (option.{0} (semiring.{0} (semiring.{0} congr_arg_kind)))), h0 x)))  := sorry --non-trivial
lemma new_lemma_62877 (h0 : uniform_space (has_add ennreal)) : complete_space (has_add ennreal) := sorry --non-trivial
lemma new_lemma_62878 (h0 : functor.add_const (complete_lattice (boolean_algebra pos)) pos) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_62879 (h0 : topological_space (boolean_algebra.core (normed_comm_ring pos))) : preirreducible_space (boolean_algebra.core (normed_comm_ring pos)) := sorry --non-trivial
lemma new_lemma_62880 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @complete_space.{0} (complete_distrib_lattice.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (complete_distrib_lattice.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_62881 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_nndist.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_nndist.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_62882 (h0 : not (filter (with_zero linarith.ineq) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_62883 (h0 : topological_space (add_cancel_monoid unsigned)) : preconnected_space (add_cancel_monoid unsigned) := sorry --non-trivial
lemma new_lemma_62884 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @locally_compact_space.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_62885 (h0 : not (ring (lattice unsigned) -> false)) : @strong_rank_condition.{0} (lattice.{0} unsigned) (@classical.by_contradiction'.{1} (ring.{0} (lattice.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_62886 (h0 : topological_space (has_neg (finset (has_to_string (finset (finset (finset pos))))))) : locally_compact_space (has_neg (finset (has_to_string (finset (finset (finset pos)))))) := sorry --non-trivial
lemma new_lemma_62887 (h0 : functor.add_const (function.extfun (Type 1) monoid) Type) : @monoid.fg.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) monoid.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) monoid.{1}) Type h0) (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_62888 (h0 : functor.add_const (topological_space (add_cancel_monoid unsigned)) unsigned) : @locally_compact_space.{0} (add_cancel_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_62889 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @add_monoid.fg.{0} (linear_ordered_semiring.{0} linarith.comp) (@function.extfun_app.{2 1} Type add_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_monoid.{0}) (linear_ordered_semiring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_62890 (h0 : has_mem.mem (semiring linarith.comp) has_emptyc.emptyc) : @is_cyclic.{0} (semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type group.{0} (semiring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_62891 (h0 : functor.add_const (group (has_zero linarith.comp)) Type) : @normalizer_condition.{0} (has_zero.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (has_zero.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_62892 (h0 : group (has_top (has_nnnorm (has_nnnorm to_additive.value_type)))) : is_cyclic (has_top (has_nnnorm (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_62893 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (normed_linear_ordered_group.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_linear_ordered_group.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_62894 (h0 : functor.add_const (topological_space (boolean_algebra.core unsigned)) name) : @path_connected_space.{0} (boolean_algebra.core.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_62895 (h0 : functor.add_const (ring (ordered_comm_ring pos)) (ring (ring (ring pos)))) : @is_principal_ideal_ring.{0} (ordered_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (ring.{0} (ordered_comm_ring.{0} pos)) (ring.{0} (ring.{0} (ring.{0} pos))) h0)  := sorry --non-trivial
lemma new_lemma_62896 (h0 : add_group (pseudo_metric_space unsigned)) : is_add_cyclic (pseudo_metric_space unsigned) := sorry --non-trivial
lemma new_lemma_62897 (h0 : complete_lattice (mul_zero_class (canonically_ordered_comm_semiring name))) : is_atomistic (mul_zero_class (canonically_ordered_comm_semiring name)) := sorry --non-trivial
lemma new_lemma_62898 (h0 : topological_space (metric_space (has_norm congr_arg_kind))) : totally_separated_space (metric_space (has_norm congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_62899 (h0 : ring (add_monoid linarith.ineq)) : strong_rank_condition (add_monoid linarith.ineq) := sorry --non-trivial
lemma new_lemma_62900 (h0 : functor.add_const (topological_space (add_cancel_monoid pos)) linarith.comp) : @locally_compact_space.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_62901 (h0 : ring (distrib (uniform_space fun_info))) : rank_condition (distrib (uniform_space fun_info)) := sorry --non-trivial
lemma new_lemma_62902 (h0 : functor.add_const (filter (has_pos_part Type)) (ring Type)) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_62903 (h0 : filter (add_cancel_monoid (option (option (option unsigned))))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_62904 (h3 : uniform_space ereal) : complete_space ereal := sorry --non-trivial
lemma new_lemma_62905 (h0 : uniform_space (has_norm (has_top fun_info))) : separated_space (has_norm (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_62906 (h0 : topological_space (cancel_monoid linarith.comp)) : path_connected_space (cancel_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_62907 (h0 : functor.add_const (topological_space (boolean_algebra.core name)) name) : @t0_space.{0} (boolean_algebra.core.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.core.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_62908 (h2 : topological_space (has_compl ereal)) : path_connected_space (has_compl ereal) := sorry --non-trivial
lemma new_lemma_62909 (h0 : topological_space (has_top (has_top empty))) : totally_disconnected_space (has_top (has_top empty)) := sorry --non-trivial
lemma new_lemma_62910 (h0 : add_monoid (has_pos_part (has_neg (ordered_comm_monoid pos)))) : add_monoid.fg (has_pos_part (has_neg (ordered_comm_monoid pos))) := sorry --non-trivial
lemma new_lemma_62911 (h0 : functor.add_const (list (normed_comm_ring name)) unsigned) : palindrome (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_62912 (h0 : functor.comp add_monoid has_nndist name) : @add_monoid.fg.{0} (has_nndist.{0} name) (@functor.comp.run.{0 0 0} add_monoid.{0} has_nndist.{0} name (@functor.comp.run.{0 0 0} add_monoid.{0} has_nndist.{0} name h0))  := sorry --non-trivial
lemma new_lemma_62913 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (with_bot congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_62914 (h0 : functor.add_const (finset (ordered_comm_ring linarith.comp)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_62915 (h0 : ring (has_top (has_norm (random_gen (has_norm (random_gen to_additive.value_type)))))) : rank_condition (has_top (has_norm (random_gen (has_norm (random_gen to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_62916 (h0 : functor.add_const (group (cancel_monoid name)) pos) : @group.fg.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (group.{0} (cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_62917 (h0 : topological_space (has_top (has_norm linarith.comp_source))) : irreducible_space (has_top (has_norm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_62918 (h0 : ring (add_semigroup (option (option unsigned)))) : rank_condition (add_semigroup (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_62919 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @has_exists_mul_of_le.{0} (canonically_ordered_comm_semiring.{0} pos) (@function.extfun_app.{2 1} Type ordered_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_comm_monoid.{0}) (canonically_ordered_comm_semiring.{0} pos))  := sorry --non-trivial
lemma new_lemma_62920 (h0 : topological_space (normed_group (has_union num))) : normal_space (normed_group (has_union num)) := sorry --non-trivial
lemma new_lemma_62921 (h0 : topological_space (has_to_string (has_to_string Type))) : preirreducible_space (has_to_string (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_62922 (h0 : functor.add_const (monoid (semigroup environment.implicit_infer_kind)) Type) : @monoid.fg.{0} (semigroup.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (monoid.{0} (semigroup.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_62923 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (complete_linear_order.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (complete_linear_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_62924 (h0 : complete_lattice (linear_order (semiring (semiring empty)))) : is_compactly_generated (linear_order (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_62925 (h0 : functor.add_const (ordered_comm_monoid (has_to_string Type)) (has_neg_part (has_neg_part (has_neg_part Type)))) : @has_exists_mul_of_le.{1} (has_to_string.{1} Type) (@functor.add_const.run.{1 1} (ordered_comm_monoid.{1} (has_to_string.{1} Type)) (has_neg_part.{1} (has_neg_part.{1} (has_neg_part.{1} Type))) h0)  := sorry --non-trivial
lemma new_lemma_62926 (h0 : ordered_comm_monoid (monoid ennreal)) : has_exists_mul_of_le (monoid ennreal) := sorry --non-trivial
lemma new_lemma_62927 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (order_dual.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (order_dual.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_62928 (h0 : functor.add_const (topological_space (finset Type)) linarith.comp) : @preconnected_space.{1} (finset.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (finset.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_62929 (h0 : topological_space (generalized_boolean_algebra linarith.comp)) : path_connected_space (generalized_boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_62930 (h0 : topological_space Type -> Prop) : @locally_compact_space.{1} Type (@classical.epsilon.{2} (topological_space.{1} Type) (@nonempty_of_inhabited.{2} (topological_space.{1} Type) (@inhabited_topological_space.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_62931 (h0 : set (mul_one_class fun_info)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_62932 (h0 : uniform_space (group_with_zero empty)) : complete_space (group_with_zero empty) := sorry --non-trivial
lemma new_lemma_62933 (h0 : functor.comp group has_nndist pos) : @group.fg.{0} (has_nndist.{0} pos) (@functor.comp.run.{0 0 0} group.{0} has_nndist.{0} pos h0)  := sorry --non-trivial
lemma new_lemma_62934 (h0 : topological_space (cancel_monoid (has_nndist pos))) : t0_space (cancel_monoid (has_nndist pos)) := sorry --non-trivial
lemma new_lemma_62935 (h0 : topological_space unsigned) : normal_space unsigned := sorry --non-trivial
lemma new_lemma_62936 (h0 : not (ring (has_one empty) -> false)) : @strong_rank_condition.{0} (has_one.{0} empty) (@classical.by_contradiction'.{1} (ring.{0} (has_one.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_62937 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (measurable_space.dynkin_system.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (measurable_space.dynkin_system.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_62938 (h0 : has_lt (has_lt (mul_one_class (mul_one_class enat)))) : no_max_order (has_lt (mul_one_class (mul_one_class enat))) := sorry --non-trivial
lemma new_lemma_62939 (h0 : add_group (normed_lattice_add_comm_group (has_add linarith.comp))) : is_add_cyclic (normed_lattice_add_comm_group (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_62940 (h0 : topological_space (simple_graph (has_pos_part pos))) : loc_path_connected_space (simple_graph (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_62941 (h0 : functor.add_const (function.extfun Type uniform_space) pos) : @separated_space.{0} (semigroup.{0} linarith.comp) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) pos h0) (semigroup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_62942 (h1 : add_group (distrib reducibility_hints)) : is_add_cyclic (distrib reducibility_hints) := sorry --non-trivial
lemma new_lemma_62943 (h0 : not (cancel_comm_monoid_with_zero (linear_ordered_semiring unsigned) -> false)) : @unique_factorization_monoid.{0} (linear_ordered_semiring.{0} unsigned) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (linear_ordered_semiring.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_62944 (h0 : topological_space (group_with_zero (option ennreal))) : preirreducible_space (group_with_zero (option ennreal)) := sorry --non-trivial
lemma new_lemma_62945 (h0 : group (ring (non_unital_semiring Type))) : is_cyclic (ring (non_unital_semiring Type)) := sorry --non-trivial
lemma new_lemma_62946 (h0 : topological_space (id (has_top linarith.ineq))) : t0_space (id (has_top linarith.ineq)) := sorry --non-trivial
lemma new_lemma_62947 (h0 : ring (has_top (random_gen (random_gen (random_gen linarith.ineq))))) : is_domain (has_top (random_gen (random_gen (random_gen linarith.ineq)))) := sorry --non-trivial
lemma new_lemma_62948 (h0 : topological_space (ring name)) : normal_space (ring name) := sorry --non-trivial
lemma new_lemma_62949 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) name) : @normal_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_62950 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm fun_info))) : @discrete_topology.{0} (has_norm.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_62951 (h0 : topological_space (free_add_monoid (random_gen fun_info))) : totally_disconnected_space (free_add_monoid (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_62952 (h0 : functor.add_const (complete_lattice (normed_linear_ordered_group empty)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (normed_linear_ordered_group.{0} empty) (@functor.add_const.run.{0 0} (complete_lattice.{0} (normed_linear_ordered_group.{0} empty)) empty h0)  := sorry --non-trivial
lemma new_lemma_62953 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @path_connected_space.{0} (has_norm.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} num)))))) (@matrix.vec_empty.{0} (topological_space.{0} (has_norm.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} num))))))) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_62954 (h0 : topological_space (has_neg (comm_group Type))) : locally_compact_space (has_neg (comm_group Type)) := sorry --non-trivial
lemma new_lemma_62955 (h0 : ordered_add_comm_monoid (has_neg (normed_comm_ring (has_neg_part linarith.comp)))) : archimedean (has_neg (normed_comm_ring (has_neg_part linarith.comp))) := sorry --non-trivial
lemma new_lemma_62956 (h1 : not (ring (has_ssubset char) -> false)) : @strong_rank_condition.{0} (has_ssubset.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (has_ssubset.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_62957 (h0 : topological_space (add_monoid (has_inv linarith.comp_source))) : t0_space (add_monoid (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_62958 (h0 : group (add_monoid (has_nnnorm fun_info))) : is_cyclic (add_monoid (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_62959 (h0 : topological_space (canonically_linear_ordered_monoid (has_neg (has_neg pos)))) : totally_separated_space (canonically_linear_ordered_monoid (has_neg (has_neg pos))) := sorry --non-trivial
lemma new_lemma_62960 (h0 : not (group (has_union linarith.comp) -> false)) : @is_cyclic.{0} (has_union.{0} linarith.comp) (@classical.by_contradiction'.{1} (group.{0} (has_union.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_62961 (h1 : set (mul_one_class (mul_one_class (mul_one_class linarith.ineq)) -> linarith.ineq)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_62962 (h0 : uniform_space (ordered_ring unsigned)) : separated_space (ordered_ring unsigned) := sorry --non-trivial
lemma new_lemma_62963 (h0 : function.extfun Type group) : @normalizer_condition.{0} (linear_ordered_add_comm_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type group.{0} h0 (linear_ordered_add_comm_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_62964 (h0 : topological_space (comm_group (mul_zero_class pos))) : t0_space (comm_group (mul_zero_class pos)) := sorry --non-trivial
lemma new_lemma_62965 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (measurable_space.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_62966 (h0 : topological_space (add_cancel_monoid (complete_distrib_lattice name))) : preconnected_space (add_cancel_monoid (complete_distrib_lattice name)) := sorry --non-trivial
lemma new_lemma_62967 (h0 : functor.add_const (uniform_space (complete_linear_order empty)) (semiring empty)) : @separated_space.{0} (complete_linear_order.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (complete_linear_order.{0} empty)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_62968 (h0 : functor.add_const (function.extfun Type uniform_space) pos) : @complete_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type uniform_space.{0}) pos h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_62969 (h0 : functor.add_const (group (generalized_boolean_algebra linarith.comp)) linarith.comp) : @is_simple_group.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (generalized_boolean_algebra.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_62970 (h0 : function.extfun nat fin) : @is_add_cyclic.{0} (measure_theory.measure_space.{0} num) (@matrix.vec_empty.{0} (add_group.{0} (measure_theory.measure_space.{0} num)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_62971 (h0 : functor.add_const (topological_space (add_cancel_monoid ennreal)) num) : @preconnected_space.{0} (add_cancel_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} ennreal)) num h0)  := sorry --non-trivial
lemma new_lemma_62972 (h0 : functor.add_const (uniform_space (free_add_monoid empty)) unsigned) : @complete_space.{0} (free_add_monoid.{0} empty) (@functor.add_const.run.{0 0} (uniform_space.{0} (free_add_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_62973 (h0 : uniform_space (with_bot (semiring (semiring (has_top (semiring (semiring empty))))))) : complete_space (with_bot (semiring (semiring (has_top (semiring (semiring empty)))))) := sorry --non-trivial
lemma new_lemma_62974 (h0 : complete_lattice (with_one (linear_ordered_add_comm_group (has_norm empty)))) : complete_lattice.is_Sup_finite_compact (with_one (linear_ordered_add_comm_group (has_norm empty))) := sorry --non-trivial
lemma new_lemma_62975 (h0 : add_monoid (normed_lattice_add_comm_group (has_Inf pos))) : add_monoid.fg (normed_lattice_add_comm_group (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_62976 (h1 : ring (dlist (has_nnnorm to_additive.value_type))) : rank_condition (dlist (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_62977 (h0 : complete_lattice (linear_ordered_comm_monoid_with_zero (semiring empty))) : is_atomistic (linear_ordered_comm_monoid_with_zero (semiring empty)) := sorry --non-trivial
lemma new_lemma_62978 (h0 : add_monoid (has_nndist (has_zero name))) : add_monoid.fg (has_nndist (has_zero name)) := sorry --non-trivial
lemma new_lemma_62979 (h0 : function.extfun nat fin) : @locally_compact_space.{0} (canonically_ordered_monoid.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (canonically_ordered_monoid.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_62980 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_simple_group.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_62981 (h0 : cancel_comm_monoid_with_zero (add_comm_monoid (has_nndist (ring (ring (ring (ring Type))))))) : unique_factorization_monoid (add_comm_monoid (has_nndist (ring (ring (ring (ring Type)))))) := sorry --non-trivial
lemma new_lemma_62982 (h0 : fin has_zero.zero) : @group.fg.{1} (boolean_algebra.{1} Type) (@matrix.vec_empty.{1} (group.{1} (boolean_algebra.{1} Type)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0)))  := sorry --non-trivial
lemma new_lemma_62983 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_principal_ideal_ring.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_62984 (h0 : topological_space (has_star (semiring (semiring empty)))) : path_connected_space (has_star (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_62985 (h0 : functor.add_const (topological_space (cancel_monoid name)) Type) : @path_connected_space.{0} (cancel_monoid.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (cancel_monoid.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_62986 (h0 : topological_space (semigroup (has_add (boolean_algebra.core pos)))) : normal_space (semigroup (has_add (boolean_algebra.core pos))) := sorry --non-trivial
lemma new_lemma_62987 (h0 : group (has_add Type)) : normalizer_condition (has_add Type) := sorry --non-trivial
lemma new_lemma_62988 (h0 : functor.add_const (function.extfun Type list) (finset Type)) : palindrome (function.extfun_app (functor.add_const.run h0) (has_zero linarith.comp)) := sorry --non-trivial
lemma new_lemma_62989 (h0 : topological_space (has_nndist (finset name))) : discrete_topology (has_nndist (finset name)) := sorry --non-trivial
lemma new_lemma_62990 (h0 : ring (has_Inf (has_Inf (has_Inf pos)))) : strong_rank_condition (has_Inf (has_Inf (has_Inf pos))) := sorry --non-trivial
lemma new_lemma_62991 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 complete_lattice.{0}) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_62992 (h0 : complete_lattice (has_Sup (option (semiring empty)))) : complete_lattice.is_Sup_finite_compact (has_Sup (option (semiring empty))) := sorry --non-trivial
lemma new_lemma_62993 (h0 : topological_space (partial_order (semiring (semiring num)))) : normal_space (partial_order (semiring (semiring num))) := sorry --non-trivial
lemma new_lemma_62994 (h0 : functor.add_const (ordered_comm_monoid (has_Inf linarith.comp)) (has_Inf (has_neg (finset linarith.comp)))) : @has_exists_mul_of_le.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} (has_Inf.{0} linarith.comp)) (has_Inf.{0} (has_neg.{0} (finset.{0} linarith.comp))) h0)  := sorry --non-trivial
lemma new_lemma_62995 (h0 : topological_space (has_edist (linear_ordered_cancel_comm_monoid (option unsigned)))) : normal_space (has_edist (linear_ordered_cancel_comm_monoid (option unsigned))) := sorry --non-trivial
lemma new_lemma_62996 (h0 : functor.add_const Prop (has_Inf (has_pos_part linarith.comp))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_62997 (h0 : complete_lattice (sub_neg_monoid (has_bot real))) : complete_lattice.is_Sup_finite_compact (sub_neg_monoid (has_bot real)) := sorry --non-trivial
lemma new_lemma_62998 (h0 : topological_space (has_le (mul_one_class (mul_one_class linarith.ineq)))) : t0_space (has_le (mul_one_class (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_62999 (h0 : functor.add_const pnat (option (option unsigned))) : pnat.prime (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_63000 (h0 : group (normed_comm_ring (has_add name))) : is_cyclic (normed_comm_ring (has_add name)) := sorry --non-trivial
lemma new_lemma_63001 (h1 : complete_lattice to_additive.value_type) : is_atomistic to_additive.value_type := sorry --non-trivial
lemma new_lemma_63002 (h0 : ring (comm_ring reducibility_hints)) : strong_rank_condition (comm_ring reducibility_hints) := sorry --non-trivial
lemma new_lemma_63003 (h0 : list (canonically_ordered_monoid linarith.comp)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_63004 (h0 : complete_lattice (measurable_space (with_bot (with_bot (with_bot (with_bot congr_arg_kind)))))) : is_atomistic (measurable_space (with_bot (with_bot (with_bot (with_bot congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_63005 (h0 : topological_space (simple_graph to_additive.value_type)) : t0_space (simple_graph to_additive.value_type) := sorry --non-trivial
lemma new_lemma_63006 (h0 : uniform_space ereal) (h1 : set ereal) : is_complete h1 := sorry --non-trivial
lemma new_lemma_63007 (h0 : ring (has_neg (finset (finset linarith.comp)))) : strong_rank_condition (has_neg (finset (finset linarith.comp))) := sorry --non-trivial
lemma new_lemma_63008 (h0 : ring (canonically_linear_ordered_monoid (has_Inf (has_add real)))) : strong_rank_condition (canonically_linear_ordered_monoid (has_Inf (has_add real))) := sorry --non-trivial
lemma new_lemma_63009 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (add_group.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (add_group.{0} num))  := sorry --non-trivial
lemma new_lemma_63010 (h0 : ring (semi_normed_comm_ring (random_gen linarith.comp_source))) : is_domain (semi_normed_comm_ring (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_63011 (h0 : functor.add_const (topological_space (has_add name)) pos) : @locally_compact_space.{0} (has_add.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_63012 (h0 : functor.add_const (add_group (ring linarith.comp)) Type) : @is_add_cyclic.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_group.{0} (ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_63013 (h0 : uniform_space (has_neg (mul_zero_class ennreal))) : complete_space (has_neg (mul_zero_class ennreal)) := sorry --non-trivial
lemma new_lemma_63014 (h2 : not (topological_space (normed_field to_additive.value_type) -> false)) : @path_connected_space.{0} (normed_field.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_field.{0} to_additive.value_type)) h2)  := sorry --non-trivial
lemma new_lemma_63015 (h2 : ring (add_monoid (fintype to_additive.value_type))) : is_domain (add_monoid (fintype to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_63016 (h0 : topological_space (semiring (semiring (has_norm linarith.comp_source)))) : totally_disconnected_space (semiring (semiring (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_63017 (h0 : functor.add_const (cancel_comm_monoid_with_zero (ordered_comm_ring linarith.comp)) pos) : @unique_factorization_monoid.{0} (ordered_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 0} (cancel_comm_monoid_with_zero.{0} (ordered_comm_ring.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_63018 (h0 : topological_space (mul_zero_class (semiring (has_top congr_arg_kind)))) : normal_space (mul_zero_class (semiring (has_top congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_63019 (h0 : ring (add_cancel_comm_monoid (random_gen char))) : is_domain (add_cancel_comm_monoid (random_gen char)) := sorry --non-trivial
lemma new_lemma_63020 (h0 : ring (add_right_cancel_monoid (semiring (semiring congr_arg_kind)))) : is_domain (add_right_cancel_monoid (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_63021 (h0 : functor.add_const (function.extfun Type ring) empty) : @rank_condition.{0} (omega_complete_partial_order.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) empty h0) (omega_complete_partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_63022 (h0 : group (add_group (semiring num))) : is_cyclic (add_group (semiring num)) := sorry --non-trivial
lemma new_lemma_63023 (h0 : topological_space fun_info) (h2 : preorder fun_info) : order_closed_topology fun_info := sorry --non-trivial
lemma new_lemma_63024 (h0 : functor.add_const (uniform_space (normed_comm_ring environment.implicit_infer_kind)) name) : @separated_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (uniform_space.{0} (normed_comm_ring.{0} environment.implicit_infer_kind)) name h0)  := sorry --non-trivial
lemma new_lemma_63025 (h0 : functor.add_const Prop (has_neg_part name)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_63026 (h0 : functor.add_const (topological_space (preorder empty)) congr_arg_kind) : @t0_space.{0} (preorder.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (preorder.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_63027 (h0 : monoid_with_zero char) (h1 : nat.arithmetic_function char) : nat.arithmetic_function.is_multiplicative h1 := sorry --non-trivial
lemma new_lemma_63028 (h0 : functor.add_const (topological_space (has_add unsigned)) Type) : @path_connected_space.{0} (has_add.{0} unsigned) (@functor.add_const.run.{0 1} (topological_space.{0} (has_add.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_63029 (h0 : topological_space (simple_graph (mul_one_class string.iterator_imp))) (h1 : preorder (simple_graph (mul_one_class string.iterator_imp))) : order_closed_topology (simple_graph (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_63030 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (linear_ordered_semiring.{0} unsigned) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (linear_ordered_semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_63031 (h0 : functor.add_const (group (has_pos_part linarith.comp)) Type) : @is_cyclic.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 1} (group.{0} (has_pos_part.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_63032 (h0 : has_mem.mem (with_bot congr_arg_kind) has_emptyc.emptyc) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (with_bot.{0} congr_arg_kind) h0)  := sorry --non-trivial
lemma new_lemma_63033 (h0 : uniform_space (random_gen (semiring (semiring (semiring num))))) : complete_space (random_gen (semiring (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_63034 (h0 : functor.add_const (topological_space (left_cancel_monoid congr_arg_kind)) num) : @totally_separated_space.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_monoid.{0} congr_arg_kind)) num h0)  := sorry --non-trivial
lemma new_lemma_63035 (h1 : topological_space (mul_one_class char)) : t0_space (mul_one_class char) := sorry --non-trivial
lemma new_lemma_63036 (h0 : topological_space (has_nndist (has_neg Type))) : t1_space (has_nndist (has_neg Type)) := sorry --non-trivial
lemma new_lemma_63037 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (complete_semilattice_Sup num)) := sorry --non-trivial
lemma new_lemma_63038 (h0 : topological_space (has_zero (mul_one_class Type))) : preirreducible_space (has_zero (mul_one_class Type)) := sorry --non-trivial
lemma new_lemma_63039 (h0 : function.extfun Type topological_space) : @normal_space.{0} (ordered_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_63040 (h0 : functor.add_const (complete_lattice (boolean_algebra.core pos)) name) : @is_atomistic.{0} (boolean_algebra.core.{0} pos) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.core.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_63041 (h0 : functor.add_const (uniform_space (has_zero pos)) environment.implicit_infer_kind) : @separated_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_zero.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_63042 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 ring.{0}) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_63043 (h0 : list (normed_linear_ordered_group (semiring (semiring (semiring empty))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_63044 (h0 : functor.add_const (topological_space (boolean_algebra.core Type)) name) : @topological_space.separable_space.{1} (boolean_algebra.core.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (boolean_algebra.core.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_63045 (h0 : topological_space (complete_distrib_lattice pos)) : topological_space.separable_space (complete_distrib_lattice pos) := sorry --non-trivial
lemma new_lemma_63046 (h0 : group (measurable_space (has_inv (has_inv linarith.ineq)))) : is_cyclic (measurable_space (has_inv (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_63047 (h0 : set (mul_one_class enat -> string.iterator_imp)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_63048 (h0 : function.extfun Type group) : @is_cyclic.{0} (canonically_ordered_add_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} h0 (canonically_ordered_add_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_63049 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @normalizer_condition.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (canonically_linear_ordered_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_63050 (h0 : topological_space (comm_semigroup congr_arg_kind)) : loc_path_connected_space (comm_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_63051 (h0 : list (finset empty)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_63052 (h0 : topological_space (id (option (option (option unsigned))))) : totally_separated_space (id (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_63053 (h0 : complete_lattice (dlist to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (dlist to_additive.value_type) := sorry --non-trivial
lemma new_lemma_63054 (h0 : topological_space (simple_graph (has_pos_part (ring (has_add pos))))) : preconnected_space (simple_graph (has_pos_part (ring (has_add pos)))) := sorry --non-trivial
lemma new_lemma_63055 (h0 : ring (ordered_comm_ring real)) : is_principal_ideal_ring (ordered_comm_ring real) := sorry --non-trivial
lemma new_lemma_63056 (h0 : topological_space (is_R_or_C (option unsigned))) : topological_space.separable_space (is_R_or_C (option unsigned)) := sorry --non-trivial
lemma new_lemma_63057 (h0 : functor.add_const (add_group (measurable_space.dynkin_system empty)) unsigned) : @is_add_cyclic.{0} (measurable_space.dynkin_system.{0} empty) (@functor.add_const.run.{0 0} (add_group.{0} (measurable_space.dynkin_system.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_63058 (h0 : not (uniform_space (has_emptyc linarith.ineq) -> false)) : @complete_space.{0} (has_emptyc.{0} linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_emptyc.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_63059 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (boolean_algebra.core.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.core.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_63060 (h0 : topological_space (semigroup (comm_group Type))) : locally_compact_space (semigroup (comm_group Type)) := sorry --non-trivial
lemma new_lemma_63061 (h0 : functor.add_const (topological_space (add_cancel_monoid environment.implicit_infer_kind)) pos) : @path_connected_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_63062 (h0 : complete_lattice (ring linarith.comp)) : is_atomistic (ring linarith.comp) := sorry --non-trivial
lemma new_lemma_63063 (h0 : function.extfun Type (prod (linear_ordered_field ennreal))) : id_rel (function.extfun_app h0 (linear_ordered_field ennreal)) := sorry --non-trivial
lemma new_lemma_63064 (h0 : complete_lattice (finset empty)) : is_atomistic (finset empty) := sorry --non-trivial
lemma new_lemma_63065 (h0 : not (filter (linear_ordered_add_comm_group char) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_63066 (h0 : group (set.set_semiring to_additive.value_type)) : is_cyclic (set.set_semiring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_63067 (h0 : group (linear_ordered_add_comm_group linarith.ineq)) : group.fg (linear_ordered_add_comm_group linarith.ineq) := sorry --non-trivial
lemma new_lemma_63068 (h0 : add_monoid (comm_group (has_add name))) : add_monoid.fg (comm_group (has_add name)) := sorry --non-trivial
lemma new_lemma_63069 (h0 : topological_space (has_bot name)) : path_connected_space (has_bot name) := sorry --non-trivial
lemma new_lemma_63070 (h0 : not (complete_lattice (mul_one_class linarith.comp_source) -> false)) : @is_compactly_generated.{0} (mul_one_class.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (mul_one_class.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_63071 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_63072 (h0 : list (add_cancel_monoid empty)) : palindrome h0 := sorry --non-trivial
lemma new_lemma_63073 (h0 : ring (distrib (normed_field linarith.comp_source))) : is_domain (distrib (normed_field linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_63074 (h0 : list (boolean_algebra (has_neg pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_63075 (h0 : semiring (finset (has_add pos))) : is_noetherian_ring (finset (has_add pos)) := sorry --non-trivial
lemma new_lemma_63076 (h0 : add_monoid (has_neg (option ennreal))) : add_monoid.fg (has_neg (option ennreal)) := sorry --non-trivial
lemma new_lemma_63077 (h0 : not (ring (has_append char) -> false)) : @rank_condition.{0} (has_append.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (has_append.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_63078 (h0 : topological_space (normed_group (has_norm linarith.comp))) : normal_space (normed_group (has_norm linarith.comp)) := sorry --non-trivial
lemma new_lemma_63079 (h0 : not (function.extfun Type add_monoid -> false)) : @add_monoid.fg.{0} empty (@function.extfun_app.{2 1} Type add_monoid.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_monoid.{0}) h0) empty)  := sorry --non-trivial
lemma new_lemma_63080 (h0 : topological_space (normed_comm_ring (comm_monoid (comm_monoid unsigned)))) : path_connected_space (normed_comm_ring (comm_monoid (comm_monoid unsigned))) := sorry --non-trivial
lemma new_lemma_63081 (h0 : topological_space (random_gen (has_top empty))) : normal_space (random_gen (has_top empty)) := sorry --non-trivial
lemma new_lemma_63082 (h0 : functor.add_const (function.extfun Type ring) (finset linarith.comp)) : @rank_condition.{0} (normed_comm_ring.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type ring.{0}) (finset.{0} linarith.comp) h0) (normed_comm_ring.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_63083 (h0 : ring (has_top (has_inv linarith.comp_source))) : rank_condition (has_top (has_inv linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_63084 (h0 : functor.add_const (monoid (semigroup pos)) (comm_group (comm_group Type))) : @monoid.fg.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (monoid.{0} (semigroup.{0} pos)) (comm_group.{1} (comm_group.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_63085 (h0 : functor.add_const (ring (ordered_comm_ring Type)) linarith.comp) : @is_domain.{1} (ordered_comm_ring.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (ordered_comm_ring.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_63086 (h0 : topological_space (has_union (has_norm unsigned))) : totally_separated_space (has_union (has_norm unsigned)) := sorry --non-trivial
lemma new_lemma_63087 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (add_left_cancel_semigroup.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (add_left_cancel_semigroup.{0} empty))  := sorry --non-trivial
lemma new_lemma_63088 (h0 : topological_space (finset (finset name))) : preirreducible_space (finset (finset name)) := sorry --non-trivial
lemma new_lemma_63089 (h0 : topological_space (distrib_lattice (random_gen (has_nnnorm to_additive.value_type)))) : totally_disconnected_space (distrib_lattice (random_gen (has_nnnorm to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_63090 (h0 : functor.add_const (topological_space (normed_comm_ring pos)) name) : @loc_path_connected_space.{0} (normed_comm_ring.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_comm_ring.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_63091 (h0 : topological_space (bin_tree (semiring (semiring (semiring (semiring unsigned)))))) : t1_space (bin_tree (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_63092 (h0 : topological_space (has_top (has_ssubset fun_info))) : locally_compact_space (has_top (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_63093 (h0 : has_top (has_top empty) -> has_top (has_top empty) -> Prop) : is_strict_order (has_top (has_top empty)) h0 := sorry --non-trivial
lemma new_lemma_63094 (h0 : topological_space (boolean_algebra (has_add (has_Inf Type)))) : loc_path_connected_space (boolean_algebra (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_63095 (h0 : topological_space (has_nndist environment.implicit_infer_kind)) : discrete_topology (has_nndist environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_63096 (h0 : filter (has_norm linarith.comp)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_63097 (h0 : group (complete_distrib_lattice environment.implicit_infer_kind)) : is_cyclic (complete_distrib_lattice environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_63098 (h0 : complete_lattice (semiring (metric_space linarith.comp))) : complete_lattice.is_Sup_finite_compact (semiring (metric_space linarith.comp)) := sorry --non-trivial
lemma new_lemma_63099 (h0 : functor.add_const (ordered_add_comm_monoid (has_neg name)) name) : @archimedean.{0} (has_neg.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_neg.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_63100 (h0 : add_group (has_star (mul_zero_class unsigned))) : is_add_cyclic (has_star (mul_zero_class unsigned)) := sorry --non-trivial
lemma new_lemma_63101 (h0 : topological_space (finset (boolean_algebra (finset (has_Inf (finset (finset (finset Type)))))))) : t1_space (finset (boolean_algebra (finset (has_Inf (finset (finset (finset Type))))))) := sorry --non-trivial
lemma new_lemma_63102 (h0 : fin has_zero.zero) : @totally_separated_space.{0} (has_bot.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_bot.{0} pos))  := sorry --non-trivial
lemma new_lemma_63103 (h0 : functor.add_const (function.extfun Type topological_space) (finset pos)) : @loc_path_connected_space.{0} (boolean_algebra.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) (finset.{0} pos) h0) (boolean_algebra.{0} pos))  := sorry --non-trivial
lemma new_lemma_63104 (h0 : prod (canonically_linear_ordered_monoid name) (canonically_linear_ordered_monoid name)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_63105 (h0 : ring (normed_group (semiring congr_arg_kind))) : is_domain (normed_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_63106 (h0 : functor.comp topological_space cancel_monoid Type) : @preconnected_space.{1} (cancel_monoid.{1} Type) (@functor.comp.run.{1 1 1} topological_space.{1} cancel_monoid.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_63107 (h0 : ring (random_gen (has_nnnorm char))) : is_domain (random_gen (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_63108 (h0 : uniform_space (ordered_comm_monoid (has_Inf (has_pos_part (has_Inf real))))) : complete_space (ordered_comm_monoid (has_Inf (has_pos_part (has_Inf real)))) := sorry --non-trivial
lemma new_lemma_63109 (h0 : function.extfun nat fin) : @totally_disconnected_space.{0} (random_gen.{0} (has_norm.{0} (random_gen.{0} linarith.comp))) (@matrix.vec_empty.{0} (topological_space.{0} (random_gen.{0} (has_norm.{0} (random_gen.{0} linarith.comp)))) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_63110 (h0 : topological_space (has_nndist (finset (ring (finset (ring linarith.comp)))))) : preirreducible_space (has_nndist (finset (ring (finset (ring linarith.comp))))) := sorry --non-trivial
lemma new_lemma_63111 (h0 : finset (canonically_ordered_comm_semiring (option (option unsigned)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_63112 (h0 : not (add_group (with_one unsigned) -> false)) : @is_add_cyclic.{0} (with_one.{0} unsigned) (@classical.by_contradiction'.{1} (add_group.{0} (with_one.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_63113 (h0 : uniform_space (free_add_monoid congr_arg_kind)) : separated_space (free_add_monoid congr_arg_kind) := sorry --non-trivial
lemma new_lemma_63114 (h0 : function.extfun Type topological_space) : @topological_space.separable_space.{0} (linear_ordered_cancel_comm_monoid.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_cancel_comm_monoid.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_63115 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (linear_ordered_add_comm_group.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_add_comm_group.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_63116 (h0 : topological_space (semi_normed_ring linarith.comp_source)) (h1 : add_group (semi_normed_ring linarith.comp_source)) : topological_add_group (semi_normed_ring linarith.comp_source) := sorry --non-trivial
lemma new_lemma_63117 (h0 : functor.add_const (topological_space (canonically_linear_ordered_monoid ennreal)) unsigned) : @preirreducible_space.{0} (canonically_linear_ordered_monoid.{0} ennreal) (@functor.add_const.run.{0 0} (topological_space.{0} (canonically_linear_ordered_monoid.{0} ennreal)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_63118 (h0 : not (topological_space (plift unsigned) -> false)) : @discrete_topology.{1} (plift.{1} unsigned) (@classical.by_contradiction'.{2} (topological_space.{1} (plift.{1} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_63119 (h0 : functor.add_const (topological_space (has_neg_part unsigned)) linarith.comp) : @sequential_space.{0} (has_neg_part.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg_part.{0} unsigned)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_63120 (h0 : not (uniform_space (id empty) -> false)) : @separated_space.{0} (@id.{2} Type empty) (@classical.by_contradiction'.{1} (uniform_space.{0} (@id.{2} Type empty)) h0)  := sorry --non-trivial
lemma new_lemma_63121 (h0 : topological_space (boolean_algebra (semigroup name))) : t0_space (boolean_algebra (semigroup name)) := sorry --non-trivial
lemma new_lemma_63122 (h0 : set (encodable linarith.ineq)) : set.infinite h0 := sorry --non-trivial
lemma new_lemma_63123 (h0 : functor.add_const (ring (comm_group ennreal)) name) : @is_domain.{0} (comm_group.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (comm_group.{0} ennreal)) name h0)  := sorry --non-trivial
lemma new_lemma_63124 (h0 : topological_space bool) : totally_separated_space bool := sorry --non-trivial
lemma new_lemma_63125 (h0 : list (semigroup (boolean_algebra pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_63126 (h0 : ring (add_comm_monoid (has_to_string (has_to_string unsigned)))) : is_domain (add_comm_monoid (has_to_string (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_63127 (h0 : complete_lattice (distrib (distrib to_additive.value_type))) : is_compactly_generated (distrib (distrib to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_63128 (h1 : function.extfun Type topological_space) : @t0_space.{0} (metric_space.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h1 (metric_space.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_63129 (h0 : not (complete_lattice (measurable_space num) -> false)) : is_compactly_generated (measurable_space num) := sorry --non-trivial
lemma new_lemma_63130 (h0 : topological_space (has_nndist (option (has_nndist name)))) : regular_space (has_nndist (option (has_nndist name))) := sorry --non-trivial
lemma new_lemma_63131 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_63132 (h0 : topological_space (generalized_boolean_algebra (has_neg (has_neg name)))) : locally_compact_space (generalized_boolean_algebra (has_neg (has_neg name))) := sorry --non-trivial
lemma new_lemma_63133 (h0 : complete_lattice (generalized_boolean_algebra (has_bot name))) : is_atomistic (generalized_boolean_algebra (has_bot name)) := sorry --non-trivial
lemma new_lemma_63134 (h0 : functor.add_const (add_monoid (normed_comm_ring linarith.comp)) Type) : @add_monoid.fg.{0} (normed_comm_ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_monoid.{0} (normed_comm_ring.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_63135 (h0 : ring (has_add (has_add (ring Type)))) : strong_rank_condition (has_add (has_add (ring Type))) := sorry --non-trivial
lemma new_lemma_63136 (h0 : add_group (random_gen (has_nnnorm (has_nnnorm (random_gen fun_info))))) : is_add_cyclic (random_gen (has_nnnorm (has_nnnorm (random_gen fun_info)))) := sorry --non-trivial
lemma new_lemma_63137 (h0 : functor.add_const (group (has_repr Type)) pos) : @group.fg.{1} (has_repr.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_repr.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_63138 (h0 : topological_space (id (random_gen (random_gen (random_gen (random_gen linarith.ineq)))))) : t0_space (id (random_gen (random_gen (random_gen (random_gen linarith.ineq))))) := sorry --non-trivial
lemma new_lemma_63139 (h0 : group (complete_linear_order (has_top empty))) : group.fg (complete_linear_order (has_top empty)) := sorry --non-trivial
lemma new_lemma_63140 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (canonically_linear_ordered_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (canonically_linear_ordered_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_63141 (h0 : ring (complete_distrib_lattice linarith.comp)) : is_domain (complete_distrib_lattice linarith.comp) := sorry --non-trivial
lemma new_lemma_63142 (h2 : ring ordering) : strong_rank_condition ordering := sorry --non-trivial
lemma new_lemma_63143 (h0 : ordered_comm_monoid (ordered_comm_ring (has_add Type))) : has_exists_mul_of_le (ordered_comm_ring (has_add Type)) := sorry --non-trivial
lemma new_lemma_63144 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @path_connected_space.{0} (bin_tree.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (bin_tree.{0} empty))  := sorry --non-trivial
lemma new_lemma_63145 (h0 : functor.add_const (group (ring pos)) linarith.comp) : @is_cyclic.{0} (ring.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (ring.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_63146 (h0 : group (monoid pos)) : is_cyclic (monoid pos) := sorry --non-trivial
lemma new_lemma_63147 (h0 : group (filter unsigned)) : group.fg (filter unsigned) := sorry --non-trivial
lemma new_lemma_63148 (h0 : function.extfun Type topological_space) : @t0_space.{0} (complete_semilattice_Sup.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_semilattice_Sup.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_63149 (h0 : topological_space (has_neg_part (cancel_monoid (option (has_add name))))) : preconnected_space (has_neg_part (cancel_monoid (option (has_add name)))) := sorry --non-trivial
lemma new_lemma_63150 (h0 : add_group (has_nndist (has_neg_part (finset pos)))) : is_add_cyclic (has_nndist (has_neg_part (finset pos))) := sorry --non-trivial
lemma new_lemma_63151 (h1 : topological_space (complete_semilattice_Sup congr_arg_kind)) : locally_compact_space (complete_semilattice_Sup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_63152 (h0 : add_group (with_one (semiring congr_arg_kind))) : is_add_cyclic (with_one (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_63153 (h0 : functor.comp group partial_order empty) : @normalizer_condition.{0} (partial_order.{0} empty) (@functor.comp.run.{0 0 0} group.{0} partial_order.{0} empty h0)  := sorry --non-trivial
lemma new_lemma_63154 (h0 : not (filter (add_left_cancel_monoid linarith.comp_source) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_63155 (h0 : topological_space (has_neg (has_neg (has_neg linarith.comp)))) : discrete_topology (has_neg (has_neg (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_63156 (h0 : function.extfun (Type 1) topological_space) : @totally_disconnected_space.{1} Type (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 Type)  := sorry --non-trivial
lemma new_lemma_63157 (h0 : function.extfun (nat -> Type) (function.extfun nat)) : @totally_disconnected_space.{0} (has_norm.{0} linarith.ineq) (@matrix.vec_empty.{0} (topological_space.{0} (has_norm.{0} linarith.ineq)) (@function.extfun_app.{1 1} nat fin (@function.extfun_app.{2 1} (nat → Type) (function.extfun.{1 1} nat) h0 fin) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_63158 (h0 : topological_space (canonically_ordered_monoid name)) : normal_space (canonically_ordered_monoid name) := sorry --non-trivial
lemma new_lemma_63159 (h0 : function.extfun Type (functor.add_const (topological_space pos))) : @preirreducible_space.{0} pos (@functor.add_const.run.{0 0} (topological_space.{0} pos) name (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} pos)) h0 name))  := sorry --non-trivial
lemma new_lemma_63160 (h0 : ring (complete_distrib_lattice (ordered_ring name))) : is_domain (complete_distrib_lattice (ordered_ring name)) := sorry --non-trivial
lemma new_lemma_63161 (h0 : group (has_top (has_nnnorm char))) : is_cyclic (has_top (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_63162 (h0 : topological_space (boolean_algebra linarith.comp)) : discrete_topology (boolean_algebra linarith.comp) := sorry --non-trivial
lemma new_lemma_63163 (h1 : topological_space (has_nnnorm std_gen)) : path_connected_space (has_nnnorm std_gen) := sorry --non-trivial
lemma new_lemma_63164 (h0 : function.extfun Type complete_lattice) : is_compactly_generated (measurable_space (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_63165 (h0 : ring (boolean_algebra (has_Inf pos))) : strong_rank_condition (boolean_algebra (has_Inf pos)) := sorry --non-trivial
lemma new_lemma_63166 (h0 : topological_space (complete_distrib_lattice (has_add name))) : preirreducible_space (complete_distrib_lattice (has_add name)) := sorry --non-trivial
lemma new_lemma_63167 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm linarith.comp))) : @is_atomistic.{0} (has_norm.{0} linarith.comp) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} linarith.comp)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_63168 (h0 : function.extfun (finset (Type -> Type) -> Prop) (function.extfun (finset (Type -> Type)))) : @path_connected_space.{0} (has_norm.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) (@function.extfun_app.{2 0} (finset.{1} (Type → Type) → Prop) (function.extfun.{2 0} (finset.{1} (Type → Type))) h0 (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0})) (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (has_norm.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_63169 (h0 : topological_space (ring (option (option (option unsigned))))) : discrete_topology (ring (option (option (option unsigned)))) := sorry --non-trivial
lemma new_lemma_63170 (h0 : not (cancel_comm_monoid_with_zero (linear_ordered_comm_ring num) -> false)) : @unique_factorization_monoid.{0} (linear_ordered_comm_ring.{0} num) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (linear_ordered_comm_ring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_63171 (h0 : functor.add_const (complete_lattice (has_to_string unsigned)) unsigned) : @is_atomistic.{0} (has_to_string.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (has_to_string.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_63172 (h0 : set (simple_graph (mul_one_class string.iterator_imp))) : set.subsingleton h0 := sorry --non-trivial
lemma new_lemma_63173 (h1 h2 : multiset (non_unital_non_assoc_semiring (has_div linarith.comp_source))) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_63174 (h0 : functor.add_const (topological_space (complete_distrib_lattice linarith.comp)) pos) : @t0_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_63175 (h1 : add_group (semiring linarith.comp)) : is_add_cyclic (semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_63176 (h0 : functor.add_const (topological_space (linear_ordered_comm_group empty)) ennreal) : @path_connected_space.{0} (linear_ordered_comm_group.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_group.{0} empty)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_63177 (h0 : topological_space (has_zero (finset (has_to_string linarith.comp)))) : t1_space (has_zero (finset (has_to_string linarith.comp))) := sorry --non-trivial
lemma new_lemma_63178 (h0 : topological_space (ordered_cancel_add_comm_monoid num)) : topological_space.separable_space (ordered_cancel_add_comm_monoid num) := sorry --non-trivial
lemma new_lemma_63179 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_63180 (h0 : complete_lattice (semiring (has_top linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (semiring (has_top linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_63181 (h0 : fin has_zero.zero) : @regular_space.{0} (sub_neg_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_63182 (h0 : filter (random_gen string_imp)) (h1 : random_gen string_imp -> filter (linear_ordered_add_comm_group (dlist linarith.ineq))) : filter.ne_bot (filter.limsup h0 h1) := sorry --non-trivial
lemma new_lemma_63183 (h0 : ring (has_norm (has_top (has_top num)))) : strong_rank_condition (has_norm (has_top (has_top num))) := sorry --non-trivial
lemma new_lemma_63184 (h0 : functor.add_const (ring (finset unsigned)) environment.implicit_infer_kind) : @strong_rank_condition.{0} (finset.{0} unsigned) (@functor.add_const.run.{0 0} (ring.{0} (finset.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_63185 (h1 : topological_space (add_comm_semigroup ereal)) (h2 : preorder (add_comm_semigroup ereal)) : order_closed_topology (add_comm_semigroup ereal) := sorry --non-trivial
lemma new_lemma_63186 (h0 : uniform_space (semi_normed_comm_ring (has_inv linarith.ineq))) : complete_space (semi_normed_comm_ring (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_63187 (h0 : ring (has_nndist (option name))) : rank_condition (has_nndist (option name)) := sorry --non-trivial
lemma new_lemma_63188 (h0 : complete_lattice (random_gen (mul_one_class (mul_one_class char)))) : is_compactly_generated (random_gen (mul_one_class (mul_one_class char))) := sorry --non-trivial
lemma new_lemma_63189 (h0 : group (complete_distrib_lattice (has_neg (has_neg linarith.comp)))) : is_simple_group (complete_distrib_lattice (has_neg (has_neg linarith.comp))) := sorry --non-trivial
lemma new_lemma_63190 (h0 : ring (has_norm (random_gen (random_gen fun_info)))) : rank_condition (has_norm (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_63191 (h0 : topological_space (has_emptyc (random_gen to_additive.value_type))) : totally_separated_space (has_emptyc (random_gen to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_63192 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_63193 (h0 : topological_space (has_add (has_to_string congr_arg_kind))) : preconnected_space (has_add (has_to_string congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_63194 (h0 : semiring (has_nndist (finset (ring (ring linarith.comp))))) : is_noetherian_ring (has_nndist (finset (ring (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_63195 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (denumerable.{0} fun_info) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (denumerable.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_63196 (h0 : topological_space (has_Sup (comm_monoid unsigned))) : path_connected_space (has_Sup (comm_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_63197 (h1 : add_group (denumerable fun_info)) : is_add_cyclic (denumerable fun_info) := sorry --non-trivial
lemma new_lemma_63198 (h0 : ring (canonically_ordered_comm_semiring (finset ennreal))) : strong_rank_condition (canonically_ordered_comm_semiring (finset ennreal)) := sorry --non-trivial
lemma new_lemma_63199 (h0 : semiring (add_comm_semigroup fun_info)) (h1 : add_comm_semigroup fun_info) : even h1 := sorry --non-trivial
lemma new_lemma_63200 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_63201 (h0 : topological_space (topological_space string.iterator_imp)) : t0_space (topological_space string.iterator_imp) := sorry --non-trivial
lemma new_lemma_63202 (h0 : list (complete_distrib_lattice (has_Inf Type))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_63203 (h0 : not (topological_space (denumerable linarith.ineq) -> false)) : @path_connected_space.{0} (denumerable.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (denumerable.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_63204 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (with_one linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_63205 (h0 : ring (linear_ordered_add_comm_group (has_nnnorm fun_info))) : strong_rank_condition (linear_ordered_add_comm_group (has_nnnorm fun_info)) := sorry --non-trivial
lemma new_lemma_63206 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_noetherian_ring.{0} (simple_graph.{0} name) (@function.extfun_app.{2 1} Type semiring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 semiring.{0}) (simple_graph.{0} name))  := sorry --non-trivial
lemma new_lemma_63207 (h0 : function.extfun Type (functor.add_const (topological_space (omega_complete_partial_order empty)))) : @topological_space.separable_space.{0} (omega_complete_partial_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (omega_complete_partial_order.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (topological_space.{0} (omega_complete_partial_order.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_63208 (h0 : functor.add_const (filter (normed_comm_ring pos)) name) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_63209 (h0 : topological_space (has_top (has_norm (has_top (has_top (has_top empty)))))) : irreducible_space (has_top (has_norm (has_top (has_top (has_top empty))))) := sorry --non-trivial
lemma new_lemma_63210 (h0 : topological_space (has_nndist (has_neg_part ennreal))) : locally_compact_space (has_nndist (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_63211 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (@id.{2} Type num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type num))  := sorry --non-trivial
lemma new_lemma_63212 (h0 : ring (complete_semilattice_Sup (has_top empty))) : is_principal_ideal_ring (complete_semilattice_Sup (has_top empty)) := sorry --non-trivial
lemma new_lemma_63213 (h0 : ordered_comm_monoid (normed_lattice_add_comm_group (has_neg (has_neg (has_neg pos))))) : has_exists_mul_of_le (normed_lattice_add_comm_group (has_neg (has_neg (has_neg pos)))) := sorry --non-trivial
lemma new_lemma_63214 (h0 : topological_space (non_assoc_semiring (semiring (semiring unsigned)))) : discrete_topology (non_assoc_semiring (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_63215 (h0 : group (complete_distrib_lattice unsigned)) : is_cyclic (complete_distrib_lattice unsigned) := sorry --non-trivial
lemma new_lemma_63216 (h0 : topological_space (random_gen (random_gen char))) : totally_disconnected_space (random_gen (random_gen char)) := sorry --non-trivial
lemma new_lemma_63217 (h0 : functor.add_const (topological_space (normed_comm_ring name)) Type) : @t1_space.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (normed_comm_ring.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_63218 (h0 : filter (complete_distrib_lattice ennreal)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_63219 (h0 : topological_space (random_gen (has_top (has_top (has_top fun_info))))) : locally_compact_space (random_gen (has_top (has_top (has_top fun_info)))) := sorry --non-trivial
lemma new_lemma_63220 (h0 : topological_space (with_bot (has_inv (has_inv (has_inv fun_info))))) : locally_compact_space (with_bot (has_inv (has_inv (has_inv fun_info)))) := sorry --non-trivial
lemma new_lemma_63221 (h0 : functor.comp add_monoid mul_zero_class (has_add ennreal)) : @add_monoid.fg.{0} (mul_zero_class.{0} (has_add.{0} ennreal)) (@functor.comp.run.{0 0 0} add_monoid.{0} mul_zero_class.{0} (has_add.{0} ennreal) h0)  := sorry --non-trivial
lemma new_lemma_63222 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (left_cancel_semigroup.{0} num) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (left_cancel_semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_63223 (h0 : functor.add_const (monoid (left_cancel_semigroup num)) (semiring (semiring num))) : @monoid.fg.{0} (left_cancel_semigroup.{0} num) (@functor.add_const.run.{0 0} (monoid.{0} (left_cancel_semigroup.{0} num)) (semiring.{0} (semiring.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_63224 (h0 : filter (ring ennreal)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_63225 (h0 : filter (has_neg (has_to_string congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_63226 (h0 : function.extfun (finset Type) (has_mem.mem (has_norm to_additive.value_type))) : @is_cyclic.{0} (has_norm.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type group.{0} (has_norm.{0} to_additive.value_type) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_norm.{0} to_additive.value_type)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_63227 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @totally_disconnected_space.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_63228 (h0 : measurable_space (normed_field string.iterator_imp)) (h1 : filter (normed_field string.iterator_imp)) : filter.is_measurably_generated h1 := sorry --non-trivial
lemma new_lemma_63229 (h0 : uniform_space (random_gen congr_arg_kind)) : complete_space (random_gen congr_arg_kind) := sorry --non-trivial
lemma new_lemma_63230 (h0 : topological_space (id (semiring empty))) : preirreducible_space (id (semiring empty)) := sorry --non-trivial
lemma new_lemma_63231 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (has_to_string.{0} (option.{0} (option.{0} (has_neg_part.{0} (option.{0} (option.{0} pos)))))) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} (option.{0} (option.{0} (has_neg_part.{0} (option.{0} (option.{0} pos)))))))  := sorry --non-trivial
lemma new_lemma_63232 (h0 : functor.add_const (topological_space (has_add environment.implicit_infer_kind)) environment.implicit_infer_kind) : @preirreducible_space.{0} (has_add.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (has_add.{0} environment.implicit_infer_kind)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_63233 (h0 : ulower pnat) (h1 : fin has_zero.zero) : pnat.coprime (id (ulower.up h0)) (id (matrix.vec_empty h1)) := sorry --non-trivial
lemma new_lemma_63234 (h0 : functor.add_const (ordered_comm_monoid pos) ennreal) : @has_exists_mul_of_le.{0} pos (@functor.add_const.run.{0 0} (ordered_comm_monoid.{0} pos) ennreal h0)  := sorry --non-trivial
lemma new_lemma_63235 (h0 : monoid (has_zero (ring Type))) : monoid.fg (has_zero (ring Type)) := sorry --non-trivial
lemma new_lemma_63236 (h0 : functor.add_const (group (left_cancel_monoid congr_arg_kind)) unsigned) : @group.fg.{0} (left_cancel_monoid.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (group.{0} (left_cancel_monoid.{0} congr_arg_kind)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_63237 (h0 : functor.add_const (topological_space (ring environment.implicit_infer_kind)) pos) : @preconnected_space.{0} (ring.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (ring.{0} environment.implicit_infer_kind)) pos h0)  := sorry --non-trivial
lemma new_lemma_63238 (h0 : topological_space (has_add (has_pos_part Type))) : preirreducible_space (has_add (has_pos_part Type)) := sorry --non-trivial
lemma new_lemma_63239 (h0 : complete_lattice (fintype fun_info)) : is_compactly_generated (fintype fun_info) := sorry --non-trivial
lemma new_lemma_63240 (h2 : complete_lattice (div_inv_monoid (has_nnnorm to_additive.value_type))) : is_compactly_generated (div_inv_monoid (has_nnnorm to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_63241 (h0 : topological_space (has_dist num)) : t0_space (has_dist num) := sorry --non-trivial
lemma new_lemma_63242 (h0 : function.extfun Type topological_space) : @normal_space.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_63243 (h0 : ordered_add_comm_monoid (generalized_boolean_algebra (has_Inf real))) : archimedean (generalized_boolean_algebra (has_Inf real)) := sorry --non-trivial
lemma new_lemma_63244 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_63245 (h0 : complete_lattice (finset (has_add (has_add real)))) : is_atomistic (finset (has_add (has_add real))) := sorry --non-trivial
lemma new_lemma_63246 (h0 : topological_space (ordered_comm_group empty)) : preirreducible_space (ordered_comm_group empty) := sorry --non-trivial
lemma new_lemma_63247 (h0 : not (uniform_space (normed_field linarith.ineq) -> false)) : @complete_space.{0} (normed_field.{0} linarith.ineq) (@classical.by_contradiction'.{1} (uniform_space.{0} (normed_field.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_63248 (h0 : not (list (has_inv (has_nnnorm fun_info)) -> false)) : list.nodup (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_63249 (h0 : topological_space (has_ssubset (mul_one_class (mul_one_class string.iterator_imp)))) : path_connected_space (has_ssubset (mul_one_class (mul_one_class string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_63250 (h0 : topological_space (id (has_inv (has_top (has_inv (has_inv (has_inv fun_info))))))) : locally_compact_space (id (has_inv (has_top (has_inv (has_inv (has_inv fun_info)))))) := sorry --non-trivial
lemma new_lemma_63251 (h0 : has_lt (add_comm_semigroup (normed_field reducibility_hints))) : no_max_order (add_comm_semigroup (normed_field reducibility_hints)) := sorry --non-trivial
lemma new_lemma_63252 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (ordered_ring.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} h0 (ordered_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_63253 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (canonically_ordered_comm_semiring.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_ordered_comm_semiring.{0} name))  := sorry --non-trivial
lemma new_lemma_63254 (h0 : topological_space (ordered_comm_ring (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid real))))) : t1_space (ordered_comm_ring (sub_neg_monoid (sub_neg_monoid (sub_neg_monoid real)))) := sorry --non-trivial
lemma new_lemma_63255 (h0 : functor.add_const (group (add_comm_monoid Type)) unsigned) : @group.fg.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (add_comm_monoid.{1} Type)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_63256 (h1 : ring (metric_space char)) : strong_rank_condition (metric_space char) := sorry --non-trivial
lemma new_lemma_63257 (h0 : functor.add_const (topological_space (ring (finset linarith.comp))) (has_to_string Type)) : @discrete_topology.{0} (ring.{0} (finset.{0} linarith.comp)) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} (finset.{0} linarith.comp))) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_63258 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (has_add.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_add.{0} real))  := sorry --non-trivial
lemma new_lemma_63259 (h1 : complete_lattice (denumerable (has_nnnorm char))) : is_compactly_generated (denumerable (has_nnnorm char)) := sorry --non-trivial
lemma new_lemma_63260 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_63261 (h0 : functor.comp topological_space boolean_algebra name) : @regular_space.{0} (boolean_algebra.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.{0} name h0)  := sorry --non-trivial
lemma new_lemma_63262 (h0 : functor.add_const (topological_space (has_nndist name)) Type) : @topological_space.separable_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_nndist.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_63263 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @archimedean.{0} (linear_ordered_comm_group.{0} unsigned) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ordered_add_comm_monoid.{0}) (linear_ordered_comm_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_63264 (h0 : not (add_group (simple_graph string_imp) -> false)) : @is_add_cyclic.{0} (simple_graph.{0} string_imp) (@classical.by_contradiction'.{1} (add_group.{0} (simple_graph.{0} string_imp)) h0)  := sorry --non-trivial
lemma new_lemma_63265 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_63266 (h0 : function.extfun Type group) : @group.fg.{0} (measurable_space.{0} num) (@function.extfun_app.{2 1} Type group.{0} h0 (measurable_space.{0} num))  := sorry --non-trivial
lemma new_lemma_63267 (h0 : functor.add_const (filter (add_cancel_monoid unsigned)) linarith.comp) : countable_Inter_filter (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_63268 (h0 : topological_space (has_nndist (metric_space (mul_one_class (finset Type))))) : loc_path_connected_space (has_nndist (metric_space (mul_one_class (finset Type)))) := sorry --non-trivial
lemma new_lemma_63269 (h0 : function.extfun Type ring) : @rank_condition.{0} (add_cancel_monoid.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (add_cancel_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_63270 (h0 : topological_space (has_neg_part environment.implicit_infer_kind)) : discrete_topology (has_neg_part environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_63271 (h0 : functor.add_const (function.extfun nat fin) linarith.comp) : @preconnected_space.{0} (has_bot.{0} pos) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} pos)) (@function.extfun_app.{1 1} nat fin (@functor.add_const.run.{0 0} (function.extfun.{1 1} nat fin) linarith.comp h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_63272 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (comm_group.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (comm_group.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_63273 (h0 : functor.add_const (topological_space (boolean_algebra name)) Type) : @t0_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_63274 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) complete_lattice.{0}) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_63275 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_edist.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_edist.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_63276 (h0 : fin has_zero.zero) : @normalizer_condition.{0} (sub_neg_monoid.{0} pos) (@matrix.vec_empty.{0} (group.{0} (sub_neg_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_63277 (h0 : measurable_space enat) (h1 : set enat) : measurable_set h1 := sorry --non-trivial
lemma new_lemma_63278 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_63279 (h0 : topological_space (uniform_space (mul_one_class char))) : path_connected_space (uniform_space (mul_one_class char)) := sorry --non-trivial
lemma new_lemma_63280 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @archimedean.{1} (has_neg.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 ordered_add_comm_monoid.{1}) (has_neg.{1} Type))  := sorry --non-trivial
lemma new_lemma_63281 (h0 : function.extfun (finset Type) (has_mem.mem (has_top num))) : @path_connected_space.{0} (has_top.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_top.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_top.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_63282 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (@id.{2} Type linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (@id.{2} Type linarith.comp))  := sorry --non-trivial
lemma new_lemma_63283 (h0 : topological_space (plift (semiring (semiring unsigned)))) : irreducible_space (plift (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_63284 (h0 : monoid (id (random_gen (semiring (semiring num))))) : monoid.fg (id (random_gen (semiring (semiring num)))) := sorry --non-trivial
lemma new_lemma_63285 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (semiring.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} fun_info)))))) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (semiring.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} (has_top.{0} fun_info)))))))  := sorry --non-trivial
lemma new_lemma_63286 (h0 : complete_lattice (plift (free_add_monoid congr_arg_kind))) : complete_lattice.is_Sup_finite_compact (plift (free_add_monoid congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_63287 (h0 : group (has_zero (has_add (ring Type)))) : normalizer_condition (has_zero (has_add (ring Type))) := sorry --non-trivial
lemma new_lemma_63288 (h0 : not (has_mem.mem (with_one num) has_emptyc.emptyc -> false)) : @rank_condition.{0} (with_one.{0} num) (@finset.pi.empty.{1 0} Type ring.{0} (with_one.{0} num) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} num) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_63289 (h0 : functor.add_const (filter (has_bot empty)) empty) : filter.ne_bot (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_63290 (h0 : topological_space (has_pos_part (has_to_string pos))) : totally_separated_space (has_pos_part (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_63291 (h0 : topological_space (has_top (has_one (id linarith.comp)))) : preirreducible_space (has_top (has_one (id linarith.comp))) := sorry --non-trivial
lemma new_lemma_63292 (h0 : topological_space (complete_distrib_lattice (has_add (boolean_algebra pos)))) : totally_separated_space (complete_distrib_lattice (has_add (boolean_algebra pos))) := sorry --non-trivial
lemma new_lemma_63293 (h0 : topological_space (finset (normed_comm_ring environment.implicit_infer_kind))) : irreducible_space (finset (normed_comm_ring environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_63294 (h0 : topological_space (finset (has_neg Type))) : totally_disconnected_space (finset (has_neg Type)) := sorry --non-trivial
lemma new_lemma_63295 (h0 : topological_space (generalized_boolean_algebra (sub_neg_monoid pos))) : totally_separated_space (generalized_boolean_algebra (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_63296 (h0 : ring (has_add real)) : rank_condition (has_add real) := sorry --non-trivial
lemma new_lemma_63297 (h0 : uniform_space (pseudo_metric_space (option empty))) : separated_space (pseudo_metric_space (option empty)) := sorry --non-trivial
lemma new_lemma_63298 (h0 : has_lt (has_ssubset (add_comm_semigroup linarith.ineq))) : no_max_order (has_ssubset (add_comm_semigroup linarith.ineq)) := sorry --non-trivial
lemma new_lemma_63299 (h0 : uniform_space (has_union congr_arg_kind)) : separated_space (has_union congr_arg_kind) := sorry --non-trivial
lemma new_lemma_63300 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (with_one.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (with_one.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_63301 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @sequential_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_63302 (h0 : group (measure_theory.measure_space (has_top (semiring (has_top empty))))) : is_cyclic (measure_theory.measure_space (has_top (semiring (has_top empty)))) := sorry --non-trivial
lemma new_lemma_63303 (h3 : topological_space (semi_normed_comm_ring char)) : totally_disconnected_space (semi_normed_comm_ring char) := sorry --non-trivial
lemma new_lemma_63304 (h0 : fin has_zero.zero) : @normal_space.{0} (normed_lattice_add_comm_group.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@matrix.vec_empty.{1} (function.extfun.{2 1} Type topological_space.{0}) h0) (normed_lattice_add_comm_group.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_63305 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @topological_space.separable_space.{0} (semigroup.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (semigroup.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_63306 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (has_edist.{0} empty) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (has_edist.{0} empty))  := sorry --non-trivial
lemma new_lemma_63307 (h1 : not (topological_space (normed_group congr_arg_kind) -> false)) : @totally_separated_space.{0} (normed_group.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} congr_arg_kind)) h1)  := sorry --non-trivial
lemma new_lemma_63308 (h0 : function.extfun Type ring) : @is_domain.{0} (semiring.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (semiring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_63309 (h0 : not (topological_space (linear_ordered_semiring linarith.ineq) -> false)) : @totally_separated_space.{0} (linear_ordered_semiring.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (linear_ordered_semiring.{0} linarith.ineq)) h0)  := sorry --non-trivial
lemma new_lemma_63310 (h0 : ring (linear_ordered_field (option num))) : strong_rank_condition (linear_ordered_field (option num)) := sorry --non-trivial
lemma new_lemma_63311 (h1 : group (with_bot string_imp)) : group.fg (with_bot string_imp) := sorry --non-trivial
lemma new_lemma_63312 (h0 : group (linear_ordered_semiring (has_top (has_norm linarith.comp_source)))) : normalizer_condition (linear_ordered_semiring (has_top (has_norm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_63313 (h0 : add_group (normed_field (mul_one_class environment.projection_info))) : is_add_cyclic (normed_field (mul_one_class environment.projection_info)) := sorry --non-trivial
lemma new_lemma_63314 (h0 : ring (has_zero (has_add (has_add linarith.comp)))) : is_principal_ideal_ring (has_zero (has_add (has_add linarith.comp))) := sorry --non-trivial
lemma new_lemma_63315 (h0 : group (has_emptyc num)) : group.fg (has_emptyc num) := sorry --non-trivial
lemma new_lemma_63316 (h0 : topological_space (boolean_algebra.core (has_add linarith.comp))) : totally_separated_space (boolean_algebra.core (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_63317 (h0 : topological_space (complete_distrib_lattice linarith.comp)) : loc_path_connected_space (complete_distrib_lattice linarith.comp) := sorry --non-trivial
lemma new_lemma_63318 (h1 : has_lt (has_nnnorm (normed_field string_imp))) : no_max_order (has_nnnorm (normed_field string_imp)) := sorry --non-trivial
lemma new_lemma_63319 (h0 : filter (finset (has_zero linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_63320 (h0 : not (group (random_gen to_additive.value_type) -> false)) : @is_cyclic.{0} (random_gen.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (group.{0} (random_gen.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_63321 (h0 : topological_space (ring (ring name))) : t1_space (ring (ring name)) := sorry --non-trivial
lemma new_lemma_63322 (h0 : functor.add_const (function.extfun Type topological_space) Type) : @regular_space.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type topological_space.{0}) Type h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_63323 (h0 : functor.add_const (ring (plift num)) num) : @is_principal_ideal_ring.{1} (plift.{1} num) (@functor.add_const.run.{1 0} (ring.{1} (plift.{1} num)) num h0)  := sorry --non-trivial
lemma new_lemma_63324 (h0 : option (group (comm_ring to_additive.value_type))) (h1 : coe_sort (option.is_some h0)) : @group.fg.{0} (comm_ring.{0} to_additive.value_type) (@option.get.{0} (group.{0} (comm_ring.{0} to_additive.value_type)) h0 h1)  := sorry --non-trivial
lemma new_lemma_63325 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (has_pos_part.{0} real) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_pos_part.{0} real))  := sorry --non-trivial
lemma new_lemma_63326 (h0 : functor.add_const (topological_space (has_Inf pos)) pos) : @discrete_topology.{0} (has_Inf.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_Inf.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_63327 (h0 : fin has_zero.zero) : countable_Inter_filter (function.extfun_app (matrix.vec_empty h0) (has_add real)) := sorry --non-trivial
lemma new_lemma_63328 (h0 : topological_space (ring (normed_comm_ring name))) : totally_disconnected_space (ring (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_63329 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_63330 (h0 : comm_monoid_with_zero reducibility_hints) (h1 : not (reducibility_hints -> false)) : prime (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_63331 (h0 : semiring (has_sub (semiring num))) : is_noetherian_ring (has_sub (semiring num)) := sorry --non-trivial
lemma new_lemma_63332 (h0 : ring (has_neg (has_to_string (finset (has_neg Type))))) : rank_condition (has_neg (has_to_string (finset (has_neg Type)))) := sorry --non-trivial
lemma new_lemma_63333 (h0 : complete_lattice (with_bot (semiring num))) : complete_lattice.is_Sup_finite_compact (with_bot (semiring num)) := sorry --non-trivial
lemma new_lemma_63334 (h0 : function.extfun Type (functor.add_const (list (has_nndist linarith.comp)))) : list.nodup (functor.add_const.run (function.extfun_app h0 linarith.comp)) := sorry --non-trivial
lemma new_lemma_63335 (h0 : not (has_mem.mem (with_one congr_arg_kind) has_emptyc.emptyc -> false)) : @monoid.fg.{0} (with_one.{0} congr_arg_kind) (@finset.pi.empty.{1 0} Type monoid.{0} (with_one.{0} congr_arg_kind) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (with_one.{0} congr_arg_kind) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_63336 (h0 : function.extfun Type group) : @is_simple_group.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_63337 (h0 : group (bin_tree (semiring congr_arg_kind))) : group.fg (bin_tree (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_63338 (h0 : uniform_space (has_top (has_norm (semiring congr_arg_kind)))) : complete_space (has_top (has_norm (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_63339 (h0 : function.extfun Type ring) : @is_domain.{0} (linear_ordered_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type ring.{0} h0 (linear_ordered_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_63340 (h0 : functor.add_const (uniform_space (has_neg linarith.comp)) environment.implicit_infer_kind) : @separated_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_neg.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_63341 (h0 : ring (normed_comm_ring (finset (has_add (has_add Type))))) : is_principal_ideal_ring (normed_comm_ring (finset (has_add (has_add Type)))) := sorry --non-trivial
lemma new_lemma_63342 (h1 : not (topological_space (has_append reducibility_hints) -> false)) : @t0_space.{0} (has_append.{0} reducibility_hints) (@classical.by_contradiction'.{1} (topological_space.{0} (has_append.{0} reducibility_hints)) h1)  := sorry --non-trivial
lemma new_lemma_63343 (h0 : has_mem.mem (with_bot to_additive.value_type) has_emptyc.emptyc) : @discrete_topology.{0} (with_bot.{0} to_additive.value_type) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} to_additive.value_type) h0)  := sorry --non-trivial
lemma new_lemma_63344 (h0 : filter (has_neg_part unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_63345 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (has_one empty)) := sorry --non-trivial
lemma new_lemma_63346 (h0 : uniform_space (normed_group linarith.comp_source)) : complete_space (normed_group linarith.comp_source) := sorry --non-trivial
lemma new_lemma_63347 (h0 : list (has_neg_part name)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_63348 (h0 : topological_space (has_inner to_additive.value_type (has_ssubset to_additive.value_type))) : t0_space (has_inner to_additive.value_type (has_ssubset to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_63349 (h0 : function.extfun Type topological_space) : @normal_space.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_63350 (h0 : not (function.extfun Type topological_space -> false)) : @preirreducible_space.{0} (measurable_space.dynkin_system.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (measurable_space.dynkin_system.{0} num))  := sorry --non-trivial
lemma new_lemma_63351 (h0 : functor.add_const (ring (pseudo_metric_space ennreal)) ennreal) : @is_principal_ideal_ring.{0} (pseudo_metric_space.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (pseudo_metric_space.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_63352 (h0 : functor.add_const Prop (has_neg (option pos))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_63353 (h0 : topological_space (cancel_monoid char)) : t0_space (cancel_monoid char) := sorry --non-trivial
lemma new_lemma_63354 (h0 : semiring (has_nndist (has_to_string pos))) : is_noetherian_ring (has_nndist (has_to_string pos)) := sorry --non-trivial
lemma new_lemma_63355 (h0 : topological_space (plift (semiring (semiring (semiring (semiring unsigned)))))) : irreducible_space (plift (semiring (semiring (semiring (semiring unsigned))))) := sorry --non-trivial
lemma new_lemma_63356 (h0 : functor.add_const (topological_space name) unsigned) : @totally_disconnected_space.{0} name (@functor.add_const.run.{0 0} (topological_space.{0} name) unsigned h0)  := sorry --non-trivial
lemma new_lemma_63357 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (canonically_ordered_monoid.{0} name) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (canonically_ordered_monoid.{0} name))  := sorry --non-trivial
lemma new_lemma_63358 (h0 : functor.add_const (monoid (finset pos)) name) : @monoid.fg.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (monoid.{0} (finset.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_63359 (h1 : function.extfun Type ring) : @strong_rank_condition.{0} (has_top.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h1 (has_top.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_63360 (h0 : functor.add_const (ordered_add_comm_monoid (has_pos_part pos)) linarith.comp) : @archimedean.{0} (has_pos_part.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_pos_part.{0} pos)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_63361 (h0 : not (cancel_comm_monoid_with_zero (measure_theory.measure_space congr_arg_kind) -> false)) : @unique_factorization_monoid.{0} (measure_theory.measure_space.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (cancel_comm_monoid_with_zero.{0} (measure_theory.measure_space.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_63362 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (normed_comm_ring.{0} linarith.comp) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (normed_comm_ring.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_63363 (h0 : functor.comp monoid has_zero Type) : @monoid.fg.{1} (has_zero.{1} Type) (@functor.comp.run.{1 1 1} monoid.{1} has_zero.{1} Type h0)  := sorry --non-trivial
lemma new_lemma_63364 (h0 : function.extfun Type ring) : @rank_condition.{0} (measure_theory.measure_space.{0} num) (@function.extfun_app.{2 1} Type ring.{0} h0 (measure_theory.measure_space.{0} num))  := sorry --non-trivial
lemma new_lemma_63365 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_63366 (h0 : function.extfun Type monoid) : @monoid.fg.{0} (option.{0} (option.{0} ennreal)) (@function.extfun_app.{2 1} Type monoid.{0} h0 (option.{0} (option.{0} ennreal)))  := sorry --non-trivial
lemma new_lemma_63367 (h0 : cancel_comm_monoid_with_zero (has_neg_part ennreal)) : unique_factorization_monoid (has_neg_part ennreal) := sorry --non-trivial
lemma new_lemma_63368 (h0 : topological_space (semigroup (finset pos))) : preconnected_space (semigroup (finset pos)) := sorry --non-trivial
lemma new_lemma_63369 (h0 : complete_lattice (add_right_cancel_monoid empty)) : is_compactly_generated (add_right_cancel_monoid empty) := sorry --non-trivial
lemma new_lemma_63370 (h0 : ring (has_edist congr_arg_kind)) : is_principal_ideal_ring (has_edist congr_arg_kind) := sorry --non-trivial
lemma new_lemma_63371 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_63372 (h0 : ring (canonically_ordered_comm_semiring (option (option empty)))) : is_principal_ideal_ring (canonically_ordered_comm_semiring (option (option empty))) := sorry --non-trivial
lemma new_lemma_63373 (h0 : functor.add_const (topological_space (finset linarith.comp)) (finset pos)) : @totally_disconnected_space.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} linarith.comp)) (finset.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_63374 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (mul_zero_class.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (mul_zero_class.{0} pos))  := sorry --non-trivial
lemma new_lemma_63375 (h0 : add_group (add_comm_monoid (finset environment.implicit_infer_kind))) : is_add_cyclic (add_comm_monoid (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_63376 (h0 : filter (add_semigroup unsigned)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_63377 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (simple_graph.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (simple_graph.{0} pos))  := sorry --non-trivial
lemma new_lemma_63378 (h0 : topological_space (canonically_ordered_comm_semiring congr_arg_kind)) : t0_space (canonically_ordered_comm_semiring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_63379 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @strong_rank_condition.{0} (has_inter.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_inter.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_63380 (h0 : topological_space (normed_group fun_info)) : totally_disconnected_space (normed_group fun_info) := sorry --non-trivial
lemma new_lemma_63381 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_63382 (h0 : ordered_add_comm_monoid (ordered_ring empty)) : archimedean (ordered_ring empty) := sorry --non-trivial
lemma new_lemma_63383 (h0 : topological_space (measurable_space.dynkin_system (measurable_space.dynkin_system unsigned))) : locally_compact_space (measurable_space.dynkin_system (measurable_space.dynkin_system unsigned)) := sorry --non-trivial
lemma new_lemma_63384 (h1 : topological_space (nondiscrete_normed_field (add_comm_semigroup enat))) : totally_disconnected_space (nondiscrete_normed_field (add_comm_semigroup enat)) := sorry --non-trivial
lemma new_lemma_63385 (h0 : topological_space (has_add num)) : discrete_topology (has_add num) := sorry --non-trivial
lemma new_lemma_63386 (h0 : complete_lattice (has_add (ordered_comm_monoid real))) : is_atomistic (has_add (ordered_comm_monoid real)) := sorry --non-trivial
lemma new_lemma_63387 (h0 : cancel_comm_monoid_with_zero nnreal) : unique_factorization_monoid nnreal := sorry --non-trivial
lemma new_lemma_63388 (h0 : uniform_space (bin_tree (semiring (semiring (semiring empty))))) : separated_space (bin_tree (semiring (semiring (semiring empty)))) := sorry --non-trivial
lemma new_lemma_63389 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} (complete_semilattice_Sup.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (complete_semilattice_Sup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_63390 (h0 : functor.add_const (ordered_add_comm_monoid (has_neg pos)) pos) : @archimedean.{0} (has_neg.{0} pos) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (has_neg.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_63391 (h0 : ring (has_one unsigned)) : is_domain (has_one unsigned) := sorry --non-trivial
lemma new_lemma_63392 (h0 : uniform_space (cancel_monoid (option unsigned))) : complete_space (cancel_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_63393 (h0 : semiring (has_union (semiring (semiring (semiring (semiring congr_arg_kind)))))) : is_noetherian_ring (has_union (semiring (semiring (semiring (semiring congr_arg_kind))))) := sorry --non-trivial
lemma new_lemma_63394 (h0 : list (dlist (has_ssubset (has_ssubset (random_gen linarith.ineq))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_63395 (h0 : set (prod linarith.comp linarith.comp)) (h1 : prod linarith.comp linarith.comp) : symmetrize_rel h0 h1 := sorry --non-trivial
lemma new_lemma_63396 (h2 : not (topological_space (topological_space char) -> false)) : @t0_space.{0} (topological_space.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (topological_space.{0} char)) h2)  := sorry --non-trivial
lemma new_lemma_63397 (h0 : functor.comp topological_space has_to_string name) : @totally_separated_space.{0} (has_to_string.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} has_to_string.{0} name h0)  := sorry --non-trivial
lemma new_lemma_63398 (h0 : function.extfun nat fin) : @has_exists_mul_of_le.{0} (has_bot.{0} (has_neg.{0} name)) (@matrix.vec_empty.{0} (ordered_comm_monoid.{0} (has_bot.{0} (has_neg.{0} name))) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_63399 (h0 : topological_space (ordered_comm_group (semiring num))) : totally_disconnected_space (ordered_comm_group (semiring num)) := sorry --non-trivial
lemma new_lemma_63400 (h0 : function.extfun Type topological_space) : @preconnected_space.{0} (ring.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ring.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_63401 (h0 : functor.add_const (add_monoid (comm_group linarith.comp)) linarith.comp) : @add_monoid.fg.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 0} (add_monoid.{0} (comm_group.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_63402 (h0 : topological_space (distrib (semi_normed_comm_ring linarith.comp_source))) : path_connected_space (distrib (semi_normed_comm_ring linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_63403 (h0 : functor.add_const (semiring (has_nndist linarith.comp)) linarith.comp) : @is_noetherian_ring.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (has_nndist.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_63404 (h0 : topological_space (has_zero (has_add environment.implicit_infer_kind))) : t1_space (has_zero (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_63405 (h0 : group (distrib linarith.comp_source)) : is_cyclic (distrib linarith.comp_source) := sorry --non-trivial
lemma new_lemma_63406 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (has_Inf.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_Inf.{0} name))  := sorry --non-trivial
lemma new_lemma_63407 (h0 : prod (mul_zero_class congr_arg_kind) (mul_zero_class congr_arg_kind)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_63408 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (linear_ordered_semiring.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_semiring.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_63409 (h0 : topological_space (linear_ordered_comm_group ennreal)) : t1_space (linear_ordered_comm_group ennreal) := sorry --non-trivial
lemma new_lemma_63410 (h0 : topological_space (ordered_comm_ring (has_Inf (sub_neg_monoid (has_add real))))) : totally_separated_space (ordered_comm_ring (has_Inf (sub_neg_monoid (has_add real)))) := sorry --non-trivial
lemma new_lemma_63411 (h1 h2 : multiset (semi_normed_comm_ring linarith.comp_source)) : multiset.subset h1 h2 := sorry --non-trivial
lemma new_lemma_63412 (h0 : function.extfun Type cancel_comm_monoid_with_zero) : @unique_factorization_monoid.{0} (generalized_boolean_algebra.{0} real) (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} h0 (generalized_boolean_algebra.{0} real))  := sorry --non-trivial
lemma new_lemma_63413 (h0 : topological_space (has_inter (option (option (option empty))))) : normal_space (has_inter (option (option (option empty)))) := sorry --non-trivial
lemma new_lemma_63414 (h0 : not (function.extfun Type topological_space -> false)) : @totally_disconnected_space.{0} (partial_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_63415 (h0 : list (has_add (option pos))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_63416 (h0 : ring (add_cancel_monoid (has_neg Type))) : is_principal_ideal_ring (add_cancel_monoid (has_neg Type)) := sorry --non-trivial
lemma new_lemma_63417 (h0 : filter (ordered_comm_ring linarith.comp)) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_63418 (h0 : list (has_zero environment.implicit_infer_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_63419 (h0 : topological_space (random_gen (comm_ring (comm_ring char)))) : totally_disconnected_space (random_gen (comm_ring (comm_ring char))) := sorry --non-trivial
lemma new_lemma_63420 (h1 : set (nondiscrete_normed_field ereal -> linarith.ineq)) : set.separates_points h1 := sorry --non-trivial
lemma new_lemma_63421 (h0 : function.extfun (finset Type) (has_mem.mem (semiring empty))) : @rank_condition.{0} (semiring.{0} empty) (@finset.pi.empty.{1 0} Type ring.{0} (semiring.{0} empty) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} empty)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_63422 (h0 : functor.add_const (ring (cancel_monoid Type)) name) : @rank_condition.{1} (cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_63423 (h0 : not (uniform_space (has_emptyc congr_arg_kind) -> false)) : @complete_space.{0} (has_emptyc.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (uniform_space.{0} (has_emptyc.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_63424 (h0 : functor.add_const (topological_space (simple_graph linarith.comp)) (ring (ring Type))) : @t0_space.{0} (simple_graph.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (simple_graph.{0} linarith.comp)) (ring.{1} (ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_63425 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (canonically_ordered_monoid.{0} empty) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (canonically_ordered_monoid.{0} empty))  := sorry --non-trivial
lemma new_lemma_63426 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @separated_space.{0} (linear_ordered_field.{0} empty) (@function.extfun_app.{2 1} Type uniform_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 uniform_space.{0}) (linear_ordered_field.{0} empty))  := sorry --non-trivial
lemma new_lemma_63427 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (has_to_string linarith.comp)) := sorry --non-trivial
lemma new_lemma_63428 (h0 : functor.add_const (complete_lattice environment.implicit_infer_kind) (has_pos_part linarith.comp)) : @is_compactly_generated.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 0} (complete_lattice.{0} environment.implicit_infer_kind) (has_pos_part.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_63429 (h0 : list (complete_distrib_lattice (boolean_algebra pos))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_63430 (h0 : topological_space (boolean_algebra.core (ring (has_nndist ennreal)))) : totally_disconnected_space (boolean_algebra.core (ring (has_nndist ennreal))) := sorry --non-trivial
lemma new_lemma_63431 (h0 : functor.add_const (topological_space (semiring unsigned)) (semiring (semiring (semiring congr_arg_kind)))) : @irreducible_space.{0} (semiring.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (semiring.{0} unsigned)) (semiring.{0} (semiring.{0} (semiring.{0} congr_arg_kind))) h0)  := sorry --non-trivial
lemma new_lemma_63432 (h0 : topological_space (normed_group (has_top unsigned))) : path_connected_space (normed_group (has_top unsigned)) := sorry --non-trivial
lemma new_lemma_63433 (h0 : Prop) (h1 : part Prop) (h2 : decidable (part.dom h1)) : part.get_or_else h1 h0 := sorry --non-trivial
lemma new_lemma_63434 (h0 : monoid (linear_ordered_add_comm_group (comm_ring (has_inv linarith.ineq)))) : monoid.fg (linear_ordered_add_comm_group (comm_ring (has_inv linarith.ineq))) := sorry --non-trivial
lemma new_lemma_63435 (h0 : functor.add_const (topological_space (plift unsigned)) unsigned) : @normal_space.{1} (plift.{1} unsigned) (@functor.add_const.run.{1 0} (topological_space.{1} (plift.{1} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_63436 (h0 : ring (complete_distrib_lattice (option unsigned))) : strong_rank_condition (complete_distrib_lattice (option unsigned)) := sorry --non-trivial
lemma new_lemma_63437 (h0 : not (complete_lattice (has_top num) -> false)) : @complete_lattice.is_Sup_finite_compact.{0} (has_top.{0} num) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_top.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_63438 (h0 : set (linear_ordered_comm_group_with_zero (mul_one_class (mul_one_class (mul_one_class linarith.comp_source))))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_63439 (h0 : not (function.extfun Type topological_space -> false)) : @locally_compact_space.{0} (has_norm.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (has_norm.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_63440 (h0 : functor.add_const (topological_space (ring Type)) environment.implicit_infer_kind) : @locally_compact_space.{1} (ring.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (ring.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_63441 (h1 : complete_lattice (semi_normed_ring (random_gen (mul_one_class (mul_one_class string_imp))))) : is_compactly_generated (semi_normed_ring (random_gen (mul_one_class (mul_one_class string_imp)))) := sorry --non-trivial
lemma new_lemma_63442 (h1 : ring (random_gen (has_nnnorm string_imp))) : is_domain (random_gen (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_63443 (h0 : has_neg (has_nnnorm linarith.comp_source)) (h1 : measurable_space (has_nnnorm linarith.comp_source)) : has_measurable_neg (has_nnnorm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_63444 (h0 : add_monoid (ring (option empty))) : add_monoid.fg (ring (option empty)) := sorry --non-trivial
lemma new_lemma_63445 (h1 : complete_lattice (random_gen (distrib char))) : is_compactly_generated (random_gen (distrib char)) := sorry --non-trivial
lemma new_lemma_63446 (h1 : topological_space (random_gen (has_top fun_info))) : irreducible_space (random_gen (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_63447 (h0 : not (topological_space (with_zero char) -> false)) : @t0_space.{0} (with_zero.{0} char) (@classical.by_contradiction'.{1} (topological_space.{0} (with_zero.{0} char)) h0)  := sorry --non-trivial
lemma new_lemma_63448 (h0 : add_monoid (finset (ring pos))) : add_monoid.fg (finset (ring pos)) := sorry --non-trivial
lemma new_lemma_63449 (h0 : group (has_neg (has_neg (finset pos)))) : group.fg (has_neg (has_neg (finset pos))) := sorry --non-trivial
lemma new_lemma_63450 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (@id.{2} Type empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (@id.{2} Type empty))  := sorry --non-trivial
lemma new_lemma_63451 (h3 : topological_space (with_one to_additive.value_type)) : path_connected_space (with_one to_additive.value_type) := sorry --non-trivial
lemma new_lemma_63452 (h0 : function.extfun Type (functor.comp list mul_zero_class)) : palindrome (functor.comp.run (function.extfun_app h0 (option name))) := sorry --non-trivial
lemma new_lemma_63453 (h0 : function.extfun Type group) : @normalizer_condition.{0} (has_top.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type group.{0} h0 (has_top.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_63454 (h0 : add_group (has_div enat)) : is_add_cyclic (has_div enat) := sorry --non-trivial
lemma new_lemma_63455 (h0 : semiring (ordered_comm_monoid (has_Inf (has_Inf linarith.comp)))) : is_noetherian_ring (ordered_comm_monoid (has_Inf (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_63456 (h0 : group (has_emptyc (has_inv (has_inv (has_inv linarith.comp_source))))) : normalizer_condition (has_emptyc (has_inv (has_inv (has_inv linarith.comp_source)))) := sorry --non-trivial
lemma new_lemma_63457 (h0 : function.extfun (Type 1) topological_space) : @path_connected_space.{1} (plift.{1} num) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (plift.{1} num))  := sorry --non-trivial
lemma new_lemma_63458 (h0 : functor.comp list has_to_string linarith.comp) : palindrome (functor.comp.run h0) := sorry --non-trivial
lemma new_lemma_63459 (h0 : finset (comm_group (option (option unsigned)))) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_63460 (h0 : functor.add_const (group (monoid empty)) num) : @is_cyclic.{0} (monoid.{0} empty) (@functor.add_const.run.{0 0} (group.{0} (monoid.{0} empty)) num h0)  := sorry --non-trivial
lemma new_lemma_63461 (h0 : prod (metric_space (semiring (semiring empty))) (metric_space (semiring (semiring empty)))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_63462 (h1 : measurable_space reducibility_hints) (h2 : measure_theory.measure reducibility_hints) : measure_theory.is_finite_measure h2 := sorry --non-trivial
lemma new_lemma_63463 (h0 : complete_lattice (ordered_comm_monoid linarith.comp)) : is_compactly_generated (ordered_comm_monoid linarith.comp) := sorry --non-trivial
lemma new_lemma_63464 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_zero.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_zero.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_63465 (h0 : set (mul_one_class (mul_one_class (mul_one_class environment.projection_info)) -> fun_info)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_63466 (h0 : functor.add_const (complete_lattice (comm_group pos)) (ring Type)) : @complete_lattice.is_Sup_finite_compact.{0} (comm_group.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (comm_group.{0} pos)) (ring.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_63467 (h0 : topological_space (finset (has_add linarith.comp))) : totally_disconnected_space (finset (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_63468 (h0 : topological_space (monoid (option unsigned))) : path_connected_space (monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_63469 (h0 : complete_lattice (ordered_cancel_add_comm_monoid ennreal)) : is_compactly_generated (ordered_cancel_add_comm_monoid ennreal) := sorry --non-trivial
lemma new_lemma_63470 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (normed_group.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_63471 (h0 : function.extfun Type topological_space) : @preirreducible_space.{0} (ordered_cancel_add_comm_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_63472 (h0 : functor.add_const (function.extfun Type group) linarith.comp) : @group.fg.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type group.{0}) linarith.comp h0) (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_63473 (h0 : functor.add_const (group (has_add Type)) (has_neg (ring pos))) : @is_cyclic.{1} (has_add.{1} Type) (@functor.add_const.run.{1 0} (group.{1} (has_add.{1} Type)) (has_neg.{0} (ring.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_63474 (h0 : topological_space (has_bot pos)) : preirreducible_space (has_bot pos) := sorry --non-trivial
lemma new_lemma_63475 (h1 : add_group (normed_field char)) : is_add_cyclic (normed_field char) := sorry --non-trivial
lemma new_lemma_63476 (h0 : functor.add_const (function.extfun Type add_monoid) pos) : @add_monoid.fg.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type add_monoid.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type add_monoid.{0}) pos h0) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_63477 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (boolean_algebra.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_63478 (h0 : complete_lattice (has_Inf real)) : is_compactly_generated (has_Inf real) := sorry --non-trivial
lemma new_lemma_63479 (h0 : cancel_comm_monoid_with_zero (complete_linear_order unsigned)) : unique_factorization_monoid (complete_linear_order unsigned) := sorry --non-trivial
lemma new_lemma_63480 (h0 : topological_space (ordered_comm_ring (has_add pos))) : regular_space (ordered_comm_ring (has_add pos)) := sorry --non-trivial
lemma new_lemma_63481 (h0 : ring (topological_space (has_nnnorm (denumerable to_additive.value_type)))) : rank_condition (topological_space (has_nnnorm (denumerable to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_63482 (h0 : ring (comm_monoid (option empty))) : strong_rank_condition (comm_monoid (option empty)) := sorry --non-trivial
lemma new_lemma_63483 (h0 : topological_space (add_comm_monoid (has_bot (has_Inf (sub_neg_monoid (has_bot (sub_neg_monoid real))))))) : normal_space (add_comm_monoid (has_bot (has_Inf (sub_neg_monoid (has_bot (sub_neg_monoid real)))))) := sorry --non-trivial
lemma new_lemma_63484 (h0 : ring (semi_normed_comm_ring (distrib linarith.comp_source))) : rank_condition (semi_normed_comm_ring (distrib linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_63485 (h0 : functor.add_const (group (add_cancel_monoid linarith.comp)) pos) : @is_cyclic.{0} (add_cancel_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_63486 (h0 : ring (add_monoid string_imp)) : strong_rank_condition (add_monoid string_imp) := sorry --non-trivial
lemma new_lemma_63487 (h0 : functor.add_const (function.extfun Type ring) Type) : @is_principal_ideal_ring.{0} (boolean_algebra.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (boolean_algebra.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_63488 (h0 : function.extfun Type group) : @group.fg.{0} (with_one.{0} char) (@function.extfun_app.{2 1} Type group.{0} h0 (with_one.{0} char))  := sorry --non-trivial
lemma new_lemma_63489 (h0 : topological_space (has_neg_part (finset pos))) : regular_space (has_neg_part (finset pos)) := sorry --non-trivial
lemma new_lemma_63490 (h0 : functor.add_const (topological_space (has_pos_part linarith.comp)) Type) : @totally_separated_space.{0} (has_pos_part.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (has_pos_part.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_63491 (h0 : functor.add_const (semiring (semigroup pos)) Type) : @is_noetherian_ring.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (semiring.{0} (semigroup.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_63492 (h0 : functor.add_const (semiring (has_add linarith.comp)) unsigned) : @is_noetherian_ring.{0} (has_add.{0} linarith.comp) (@functor.add_const.run.{0 0} (semiring.{0} (has_add.{0} linarith.comp)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_63493 (h0 : functor.add_const (topological_space (option pos)) pos) : @preirreducible_space.{0} (option.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_63494 (h0 : ring (distrib (has_nnnorm linarith.comp_source))) : strong_rank_condition (distrib (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_63495 (h0 : topological_space (measurable_space.dynkin_system num)) : path_connected_space (measurable_space.dynkin_system num) := sorry --non-trivial
lemma new_lemma_63496 (h0 : functor.add_const (complete_lattice (sub_neg_monoid linarith.comp)) (has_Inf linarith.comp)) : @is_compactly_generated.{0} (sub_neg_monoid.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (sub_neg_monoid.{0} linarith.comp)) (has_Inf.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_63497 (h0 : list (has_nndist (has_add Type))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_63498 (h0 : ring (has_top (has_inv to_additive.value_type))) : is_domain (has_top (has_inv to_additive.value_type)) := sorry --non-trivial
lemma new_lemma_63499 (h0 : functor.add_const (function.extfun Type topological_space) pos) : @totally_separated_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) pos h0) (complete_distrib_lattice.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_63500 (h0 : set (mul_one_class (add_comm_semigroup ereal))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_63501 (h0 : topological_space (semigroup (ring pos))) : normal_space (semigroup (ring pos)) := sorry --non-trivial
lemma new_lemma_63502 (h0 : functor.add_const (topological_space (has_nndist Type)) linarith.comp) : @loc_path_connected_space.{1} (has_nndist.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (has_nndist.{1} Type)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_63503 (h2 : complete_lattice (comm_ring to_additive.value_type)) : complete_lattice.is_Sup_finite_compact (comm_ring to_additive.value_type) := sorry --non-trivial
lemma new_lemma_63504 (h1 : ring (has_inv (random_gen (has_nnnorm string_imp)))) : is_domain (has_inv (random_gen (has_nnnorm string_imp))) := sorry --non-trivial
lemma new_lemma_63505 (h0 : function.extfun (Type 1) group) : @is_simple_group.{1} Type (@function.extfun_app.{3 2} (Type 1) group.{1} h0 Type)  := sorry --non-trivial
lemma new_lemma_63506 (h0 : not (function.extfun Type group -> false)) : @normalizer_condition.{0} (add_right_cancel_monoid.{0} unsigned) (@function.extfun_app.{2 1} Type group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type group.{0}) h0) (add_right_cancel_monoid.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_63507 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : finset.nonempty (function.extfun_app (function.extfun_app h0 finset) (plift congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_63508 (h1 : has_lt (nondiscrete_normed_field enat)) : no_max_order (nondiscrete_normed_field enat) := sorry --non-trivial
lemma new_lemma_63509 (h0 : complete_lattice (add_right_cancel_monoid (semiring (semiring empty)))) : complete_lattice.is_Sup_finite_compact (add_right_cancel_monoid (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_63510 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (ordered_cancel_add_comm_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (ordered_cancel_add_comm_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_63511 (h0 h1 : nat) (h2 : thunk Prop) : scope_trace h2 := sorry --non-trivial
lemma new_lemma_63512 (h0 : topological_space (boolean_algebra.core (boolean_algebra.core linarith.comp))) : loc_path_connected_space (boolean_algebra.core (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_63513 (h0 : group (has_nndist linarith.comp)) : is_simple_group (has_nndist linarith.comp) := sorry --non-trivial
lemma new_lemma_63514 (h0 : uniform_space (add_cancel_monoid (has_pos_part (ring (ring linarith.comp))))) : separated_space (add_cancel_monoid (has_pos_part (ring (ring linarith.comp)))) := sorry --non-trivial
lemma new_lemma_63515 (h0 : functor.add_const Prop (ordered_comm_ring linarith.comp)) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_63516 (h0 : topological_space (has_top (has_nndist (has_nnnorm string_imp)))) : totally_disconnected_space (has_top (has_nndist (has_nnnorm string_imp))) := sorry --non-trivial
lemma new_lemma_63517 (h0 : complete_lattice (has_edist (semiring (semiring empty)))) : complete_lattice.is_Sup_finite_compact (has_edist (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_63518 (h0 : not (topological_space (fintype linarith.comp_source) -> false)) : @t0_space.{0} (fintype.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (fintype.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_63519 (h1 : function.extfun Type ring) : @is_domain.{0} (has_emptyc.{0} linarith.ineq) (@function.extfun_app.{2 1} Type ring.{0} h1 (has_emptyc.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_63520 (h0 : topological_space (has_nndist (option (mul_zero_class name)))) : locally_compact_space (has_nndist (option (mul_zero_class name))) := sorry --non-trivial
lemma new_lemma_63521 (h0 : complete_lattice (has_top (has_norm (has_norm num)))) : is_compactly_generated (has_top (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_63522 (h0 : functor.add_const (complete_lattice (boolean_algebra linarith.comp)) environment.implicit_infer_kind) : @complete_lattice.is_Sup_finite_compact.{0} (boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (complete_lattice.{0} (boolean_algebra.{0} linarith.comp)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_63523 (h0 : topological_space (with_bot (non_assoc_semiring (semiring congr_arg_kind)))) : irreducible_space (with_bot (non_assoc_semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_63524 (h0 : function.extfun Type topological_space) : @path_connected_space.{0} (has_sub.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_sub.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_63525 (h0 : uniform_space (normed_field environment.projection_info)) : complete_space (normed_field environment.projection_info) := sorry --non-trivial
lemma new_lemma_63526 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @regular_space.{0} (has_add.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_add.{0} pos))  := sorry --non-trivial
lemma new_lemma_63527 (h0 : functor.add_const (topological_space (partial_order unsigned)) empty) : @path_connected_space.{0} (partial_order.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (partial_order.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_63528 (h0 : list (with_bot string_imp)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_63529 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (ring.{0} name) (@function.extfun_app.{2 1} Type ring.{0} h0 (ring.{0} name))  := sorry --non-trivial
lemma new_lemma_63530 (h0 : topological_space (denumerable (random_gen linarith.ineq))) : t0_space (denumerable (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_63531 (h0 : prod (option empty) (option empty)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_63532 (h0 : complete_lattice (add_cancel_monoid (option (option (option ennreal))))) : is_compactly_generated (add_cancel_monoid (option (option (option ennreal)))) := sorry --non-trivial
lemma new_lemma_63533 (h0 : list (normed_comm_ring congr_arg_kind)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_63534 (h3 : monoid (add_group fun_info)) : monoid.fg (add_group fun_info) := sorry --non-trivial
lemma new_lemma_63535 (h0 : topological_space (normed_comm_ring linarith.comp)) : regular_space (normed_comm_ring linarith.comp) := sorry --non-trivial
lemma new_lemma_63536 (h0 : add_monoid (add_group (semiring congr_arg_kind))) : add_monoid.fg (add_group (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_63537 (h0 : cancel_comm_monoid_with_zero (has_to_string (has_neg pos))) : unique_factorization_monoid (has_to_string (has_neg pos)) := sorry --non-trivial
lemma new_lemma_63538 (h0 : functor.add_const (topological_space (semigroup Type)) pos) : @locally_compact_space.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (semigroup.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_63539 (h2 : function.extfun Type topological_space) : @locally_compact_space.{0} (with_bot.{0} linarith.ineq) (@function.extfun_app.{2 1} Type topological_space.{0} h2 (with_bot.{0} linarith.ineq))  := sorry --non-trivial
lemma new_lemma_63540 (h0 : complete_lattice (boolean_algebra (finset environment.implicit_infer_kind))) : complete_lattice.is_Sup_finite_compact (boolean_algebra (finset environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_63541 (h0 : ring (random_gen (random_gen (has_lt linarith.comp_source)))) : rank_condition (random_gen (random_gen (has_lt linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_63542 (h0 : group (has_top (has_nnnorm (has_nnnorm (random_gen (has_nnnorm to_additive.value_type)))))) : group.fg (has_top (has_nnnorm (has_nnnorm (random_gen (has_nnnorm to_additive.value_type))))) := sorry --non-trivial
lemma new_lemma_63543 (h0 : uniform_space (complete_distrib_lattice name)) : complete_space (complete_distrib_lattice name) := sorry --non-trivial
lemma new_lemma_63544 (h0 : group (has_to_string (has_neg_part (has_neg_part Type)))) : is_simple_group (has_to_string (has_neg_part (has_neg_part Type))) := sorry --non-trivial
lemma new_lemma_63545 (h0 : not (topological_space (normed_group num) -> false)) : @discrete_topology.{0} (normed_group.{0} num) (@classical.by_contradiction'.{1} (topological_space.{0} (normed_group.{0} num)) h0)  := sorry --non-trivial
lemma new_lemma_63546 (h0 : function.extfun (Type 1) add_monoid) : @add_monoid.fg.{1} (has_pos_part.{1} Type) (@function.extfun_app.{3 2} (Type 1) add_monoid.{1} h0 (has_pos_part.{1} Type))  := sorry --non-trivial
lemma new_lemma_63547 (h0 : functor.add_const (complete_lattice (option unsigned)) num) : @is_atomistic.{0} (option.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (option.{0} unsigned)) num h0)  := sorry --non-trivial
lemma new_lemma_63548 (h0 : set (set linarith.comp_source)) : is_countably_spanning h0 := sorry --non-trivial
lemma new_lemma_63549 (h0 : function.extfun (finset Type) (has_mem.mem (has_inter fun_info))) : @totally_disconnected_space.{0} (has_inter.{0} fun_info) (@finset.pi.empty.{1 0} Type topological_space.{0} (has_inter.{0} fun_info) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (has_inter.{0} fun_info)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_63550 (h0 : uniform_space (complete_semilattice_Sup (semiring (semiring unsigned)))) : separated_space (complete_semilattice_Sup (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_63551 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @discrete_topology.{0} congr_arg_kind (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_63552 (h0 : functor.add_const (topological_space (complete_distrib_lattice Type)) Type) : @t1_space.{1} (complete_distrib_lattice.{1} Type) (@functor.add_const.run.{1 1} (topological_space.{1} (complete_distrib_lattice.{1} Type)) Type h0)  := sorry --non-trivial
lemma new_lemma_63553 (h0 : cancel_comm_monoid_with_zero (canonically_ordered_comm_semiring linarith.comp)) : unique_factorization_monoid (canonically_ordered_comm_semiring linarith.comp) := sorry --non-trivial
lemma new_lemma_63554 (h0 : function.extfun nat fin) : @group.fg.{0} (finset.{0} name) (@matrix.vec_empty.{0} (group.{0} (finset.{0} name)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_63555 (h0 : with_bot pnat) (h1 : ne h0 has_bot.bot) (h2 : fin has_zero.zero) : pnat.coprime (with_bot.unbot h0 h1) (matrix.vec_empty (id (id (id (id h2))))) := sorry --non-trivial
lemma new_lemma_63556 (h0 : topological_space (semigroup (has_neg_part ennreal))) : totally_separated_space (semigroup (has_neg_part ennreal)) := sorry --non-trivial
lemma new_lemma_63557 (h0 : add_monoid (comm_group (option (option unsigned)))) : add_monoid.fg (comm_group (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_63558 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @totally_disconnected_space.{0} (linear_ordered_comm_ring.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_ring.{0} empty))  := sorry --non-trivial
lemma new_lemma_63559 (h0 : group (denumerable (has_ssubset fun_info))) : group.fg (denumerable (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_63560 (h0 : set (mul_one_class (mul_one_class environment.projection_info))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_63561 (h0 : complete_lattice (has_Inf pos)) : complete_lattice.is_Sup_finite_compact (has_Inf pos) := sorry --non-trivial
lemma new_lemma_63562 (h0 : topological_space (has_add (linear_ordered_comm_ring (normed_comm_ring name)))) : discrete_topology (has_add (linear_ordered_comm_ring (normed_comm_ring name))) := sorry --non-trivial
lemma new_lemma_63563 (h0 : topological_space (canonically_linear_ordered_monoid (option unsigned))) : topological_space.separable_space (canonically_linear_ordered_monoid (option unsigned)) := sorry --non-trivial
lemma new_lemma_63564 (h0 : topological_space (with_zero linarith.ineq)) : path_connected_space (with_zero linarith.ineq) := sorry --non-trivial
lemma new_lemma_63565 (h0 : measurable_space (add_comm_semigroup enat)) (h1 : measure_theory.measure (add_comm_semigroup enat)) : measure_theory.is_finite_measure h1 := sorry --non-trivial
lemma new_lemma_63566 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_add_cyclic.{0} (has_neg_part.{0} ennreal) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 add_group.{0}) (has_neg_part.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_63567 (h0 : add_group (comm_ring (has_nnnorm reducibility_hints))) : is_add_cyclic (comm_ring (has_nnnorm reducibility_hints)) := sorry --non-trivial
lemma new_lemma_63568 (h1 : complete_lattice (has_lt ereal)) : is_compactly_generated (has_lt ereal) := sorry --non-trivial
lemma new_lemma_63569 (h0 : uniform_space (semi_normed_comm_ring linarith.ineq)) : complete_space (semi_normed_comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_63570 (h0 : not (topological_space (mul_one_class (mul_one_class char)) -> false)) : @path_connected_space.{0} (mul_one_class.{0} (mul_one_class.{0} char)) (@classical.by_contradiction'.{1} (topological_space.{0} (mul_one_class.{0} (mul_one_class.{0} char))) h0)  := sorry --non-trivial
lemma new_lemma_63571 (h0 : topological_space (finset (option (option congr_arg_kind)))) : locally_compact_space (finset (option (option congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_63572 (h0 : has_le (has_compl reducibility_hints)) (h1 : bounded_order (has_compl reducibility_hints)) : is_simple_order (has_compl reducibility_hints) := sorry --non-trivial
lemma new_lemma_63573 (h0 : not (has_mem.mem (semiring empty) has_emptyc.emptyc -> false)) : @locally_compact_space.{0} (semiring.{0} empty) (@finset.pi.empty.{1 0} Type topological_space.{0} (semiring.{0} empty) (@classical.by_contradiction'.{0} (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (semiring.{0} empty) (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))) h0))  := sorry --non-trivial
lemma new_lemma_63574 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (has_add.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (has_add.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_63575 (h0 : ordered_add_comm_monoid (has_add (has_neg unsigned))) : archimedean (has_add (has_neg unsigned)) := sorry --non-trivial
lemma new_lemma_63576 (h0 : functor.add_const (topological_space (add_comm_monoid Type)) (boolean_algebra pos)) : @totally_disconnected_space.{1} (add_comm_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_comm_monoid.{1} Type)) (boolean_algebra.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_63577 (h0 : topological_space (denumerable (random_gen fun_info))) : t0_space (denumerable (random_gen fun_info)) := sorry --non-trivial
lemma new_lemma_63578 (h0 : complete_lattice (free_add_monoid unsigned)) : complete_lattice.is_Sup_finite_compact (free_add_monoid unsigned) := sorry --non-trivial
lemma new_lemma_63579 (h0 : functor.add_const (topological_space (complete_distrib_lattice unsigned)) empty) : @locally_compact_space.{0} (complete_distrib_lattice.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (complete_distrib_lattice.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_63580 (h0 : add_group (preorder num)) : is_add_cyclic (preorder num) := sorry --non-trivial
lemma new_lemma_63581 (h0 : function.extfun Type (functor.comp add_monoid mul_zero_class)) : @add_monoid.fg.{0} (mul_zero_class.{0} pos) (@functor.comp.run.{0 0 0} add_monoid.{0} mul_zero_class.{0} pos (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} add_monoid.{0} mul_zero_class.{0}) h0 pos))  := sorry --non-trivial
lemma new_lemma_63582 (h0 : complete_lattice (simple_graph fun_info)) : is_compactly_generated (simple_graph fun_info) := sorry --non-trivial
lemma new_lemma_63583 (h0 : semiring (ordered_ring (semiring num))) : is_noetherian_ring (ordered_ring (semiring num)) := sorry --non-trivial
lemma new_lemma_63584 (h0 : functor.add_const (topological_space (finset name)) linarith.comp) : @normal_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_63585 (h0 : group (preorder (semiring (semiring congr_arg_kind)))) : normalizer_condition (preorder (semiring (semiring congr_arg_kind))) := sorry --non-trivial
lemma new_lemma_63586 (h0 : functor.add_const (function.extfun (Type 1) group) name) : @group.fg.{1} (add_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@functor.add_const.run.{2 0} (function.extfun.{3 2} (Type 1) group.{1}) name h0) (add_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_63587 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (ordered_comm_ring.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (ordered_comm_ring.{0} pos))  := sorry --non-trivial
lemma new_lemma_63588 (h0 : function.extfun Type uniform_space) : @separated_space.{0} (sub_neg_monoid.{0} (has_neg.{0} name)) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (sub_neg_monoid.{0} (has_neg.{0} name)))  := sorry --non-trivial
lemma new_lemma_63589 (h0 : not (complete_lattice (with_bot (has_norm (has_norm (semiring (has_norm (has_norm linarith.comp)))))) -> false)) : @is_atomistic.{0} (with_bot.{0} (has_norm.{0} (has_norm.{0} (semiring.{0} (has_norm.{0} (has_norm.{0} linarith.comp)))))) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_bot.{0} (has_norm.{0} (has_norm.{0} (semiring.{0} (has_norm.{0} (has_norm.{0} linarith.comp))))))) h0)  := sorry --non-trivial
lemma new_lemma_63590 (h0 : prod (finset pos) (finset pos)) : id_rel h0 := sorry --non-trivial
lemma new_lemma_63591 (h3 : add_group (semi_normed_ring string_imp)) : is_add_cyclic (semi_normed_ring string_imp) := sorry --non-trivial
lemma new_lemma_63592 (h0 : topological_space (has_top (comm_ring linarith.ineq))) : totally_disconnected_space (has_top (comm_ring linarith.ineq)) := sorry --non-trivial
lemma new_lemma_63593 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @separated_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 uniform_space.{1}) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_63594 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (comm_semigroup.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (comm_semigroup.{0} real)) h0)  := sorry --non-trivial
lemma new_lemma_63595 (h0 : complete_lattice (measurable_space to_additive.value_type)) : is_compactly_generated (measurable_space to_additive.value_type) := sorry --non-trivial
lemma new_lemma_63596 (h0 : topological_space (ordered_comm_ring (has_add linarith.comp))) : path_connected_space (ordered_comm_ring (has_add linarith.comp)) := sorry --non-trivial
lemma new_lemma_63597 (h0 : not (topological_space nnreal -> false)) : t1_space nnreal := sorry --non-trivial
lemma new_lemma_63598 (h0 : ring (complete_semilattice_Sup (random_gen string_imp))) : strong_rank_condition (complete_semilattice_Sup (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_63599 (h0 : functor.add_const (ordered_comm_monoid (semigroup Type)) (has_neg environment.implicit_infer_kind)) : @has_exists_mul_of_le.{1} (semigroup.{1} Type) (@functor.add_const.run.{1 0} (ordered_comm_monoid.{1} (semigroup.{1} Type)) (has_neg.{0} environment.implicit_infer_kind) h0)  := sorry --non-trivial
lemma new_lemma_63600 (h1 : group (has_ssubset char)) : is_cyclic (has_ssubset char) := sorry --non-trivial
lemma new_lemma_63601 (h1 : add_group (complete_semilattice_Sup linarith.ineq)) : is_add_cyclic (complete_semilattice_Sup linarith.ineq) := sorry --non-trivial
lemma new_lemma_63602 (h0 : functor.add_const (topological_space (option pos)) (option pos)) : @t1_space.{0} (option.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} pos)) (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_63603 (h0 : group (normed_group (has_one num))) : normalizer_condition (normed_group (has_one num)) := sorry --non-trivial
lemma new_lemma_63604 (h0 : functor.add_const (uniform_space (has_Inf linarith.comp)) pos) : @separated_space.{0} (has_Inf.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_Inf.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_63605 (h0 : function.extfun Type topological_space) : @t0_space.{0} (pseudo_metric_space.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (pseudo_metric_space.{0} pos))  := sorry --non-trivial
lemma new_lemma_63606 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_zero.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_zero.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_63607 (h0 : topological_space (has_one congr_arg_kind)) : discrete_topology (has_one congr_arg_kind) := sorry --non-trivial
lemma new_lemma_63608 (h0 : topological_space (generalized_boolean_algebra (ring (ring (has_add (has_add linarith.comp)))))) : t1_space (generalized_boolean_algebra (ring (ring (has_add (has_add linarith.comp))))) := sorry --non-trivial
lemma new_lemma_63609 (h0 : uniform_space (complete_semilattice_Sup char)) : complete_space (complete_semilattice_Sup char) := sorry --non-trivial
lemma new_lemma_63610 (h0 : ordered_comm_monoid (normed_comm_ring (option (option (option (option pos)))))) : has_exists_mul_of_le (normed_comm_ring (option (option (option (option pos))))) := sorry --non-trivial
lemma new_lemma_63611 (h0 : functor.add_const (functor.add_const (topological_space nnreal) num) num) : irreducible_space nnreal := sorry --non-trivial
lemma new_lemma_63612 (h0 : topological_space (has_ssubset (has_nnnorm linarith.comp_source))) : path_connected_space (has_ssubset (has_nnnorm linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_63613 (h0 : function.extfun Type group) : @normalizer_condition.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type group.{0} h0 (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_63614 (h1 : ring (has_emptyc (has_norm (has_norm fun_info)))) : strong_rank_condition (has_emptyc (has_norm (has_norm fun_info))) := sorry --non-trivial
lemma new_lemma_63615 (h0 : has_mem.mem topological_space has_emptyc.emptyc) : @irreducible_space.{0} linarith.comp_source (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} h0) linarith.comp_source)  := sorry --non-trivial
lemma new_lemma_63616 (h0 : has_mem.mem (normed_group (semiring linarith.comp)) has_emptyc.emptyc) : @is_atomistic.{0} (normed_group.{0} (semiring.{0} linarith.comp)) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (normed_group.{0} (semiring.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_63617 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @locally_compact_space.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_63618 (h1 : ring (mul_one_class std_gen)) : is_field (mul_one_class std_gen) := sorry --non-trivial
lemma new_lemma_63619 (h0 : list (has_add (has_neg_part (has_neg Type)))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_63620 (h0 : complete_lattice (comm_ring (random_gen (random_gen string.iterator_imp)))) : is_compactly_generated (comm_ring (random_gen (random_gen string.iterator_imp))) := sorry --non-trivial
lemma new_lemma_63621 (h0 : not (function.extfun Type ring -> false)) : @strong_rank_condition.{0} (left_cancel_semigroup.{0} num) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (left_cancel_semigroup.{0} num))  := sorry --non-trivial
lemma new_lemma_63622 (h0 : topological_space (non_assoc_semiring (semiring (semiring (semiring unsigned))))) : path_connected_space (non_assoc_semiring (semiring (semiring (semiring unsigned)))) := sorry --non-trivial
lemma new_lemma_63623 (h0 : semiring (sub_neg_monoid name)) : is_noetherian_ring (sub_neg_monoid name) := sorry --non-trivial
lemma new_lemma_63624 (h0 : ring (add_group (semiring (semiring unsigned)))) : is_domain (add_group (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_63625 (h0 : ring (has_nndist (comm_group unsigned))) : rank_condition (has_nndist (comm_group unsigned)) := sorry --non-trivial
lemma new_lemma_63626 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (normed_group.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (normed_group.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_63627 (h2 : group (with_one linarith.comp_source)) : normalizer_condition (with_one linarith.comp_source) := sorry --non-trivial
lemma new_lemma_63628 (h0 : function.extfun Type ring) : @rank_condition.{0} (mul_zero_class.{0} unsigned) (@function.extfun_app.{2 1} Type ring.{0} h0 (mul_zero_class.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_63629 (h0 : add_group (has_le (has_ssubset (normed_field linarith.ineq)))) : is_add_cyclic (has_le (has_ssubset (normed_field linarith.ineq))) := sorry --non-trivial
lemma new_lemma_63630 (h0 : function.extfun (Type 1) (functor.add_const (complete_lattice environment.implicit_infer_kind))) : @complete_lattice.is_Sup_finite_compact.{0} environment.implicit_infer_kind (@functor.add_const.run.{0 1} (complete_lattice.{0} environment.implicit_infer_kind) Type (@function.extfun_app.{3 1} (Type 1) (functor.add_const.{0 1} (complete_lattice.{0} environment.implicit_infer_kind)) h0 Type))  := sorry --non-trivial
lemma new_lemma_63631 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : filter.ne_bot (function.extfun_app (function.extfun_app h0 filter) (add_cancel_monoid unsigned)) := sorry --non-trivial
lemma new_lemma_63632 (h0 : monoid (canonically_ordered_monoid (finset Type))) : monoid.fg (canonically_ordered_monoid (finset Type)) := sorry --non-trivial
lemma new_lemma_63633 (h0 : function.extfun Type (functor.comp filter has_nndist)) : countable_Inter_filter (functor.comp.run (function.extfun_app h0 name)) := sorry --non-trivial
lemma new_lemma_63634 (h0 : add_group (fintype reducibility_hints)) : is_add_cyclic (fintype reducibility_hints) := sorry --non-trivial
lemma new_lemma_63635 (h1 : topological_space (normed_field (mul_one_class string.iterator_imp))) : path_connected_space (normed_field (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_63636 (h0 : topological_space (nondiscrete_normed_field (add_comm_semigroup (normed_field char)))) (h1 : add_group (nondiscrete_normed_field (add_comm_semigroup (normed_field char)))) : topological_add_group (nondiscrete_normed_field (add_comm_semigroup (normed_field char))) := sorry --non-trivial
lemma new_lemma_63637 (h0 : ring (has_union (has_norm (semiring linarith.comp)))) : rank_condition (has_union (has_norm (semiring linarith.comp))) := sorry --non-trivial
lemma new_lemma_63638 (h0 : fin has_zero.zero) : @group.fg.{0} (canonically_linear_ordered_monoid.{0} pos) (@matrix.vec_empty.{0} (group.{0} (canonically_linear_ordered_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_63639 (h0 : group (comm_ring (has_nnnorm (has_nnnorm linarith.comp_source)))) : is_cyclic (comm_ring (has_nnnorm (has_nnnorm linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_63640 (h0 : filter (finset (has_neg (finset linarith.comp)))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_63641 (h0 : topological_space (semigroup (has_add (has_add (finset linarith.comp))))) : loc_path_connected_space (semigroup (has_add (has_add (finset linarith.comp)))) := sorry --non-trivial
lemma new_lemma_63642 (h0 : functor.add_const (ordered_add_comm_monoid (add_cancel_monoid name)) pos) : @archimedean.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} (add_cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_63643 (h0 : function.extfun (Type 1) filter) : countable_Inter_filter (function.extfun_app h0 (cancel_monoid Type)) := sorry --non-trivial
lemma new_lemma_63644 (h0 : filter (ordered_cancel_add_comm_monoid num)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_63645 (h0 : functor.add_const (complete_lattice (has_to_string environment.implicit_infer_kind)) Type) : @complete_lattice.is_Sup_finite_compact.{0} (has_to_string.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 1} (complete_lattice.{0} (has_to_string.{0} environment.implicit_infer_kind)) Type h0)  := sorry --non-trivial
lemma new_lemma_63646 (h0 : complete_lattice (has_norm unsigned)) : complete_lattice.is_Sup_finite_compact (has_norm unsigned) := sorry --non-trivial
lemma new_lemma_63647 (h0 : complete_lattice (simple_graph (mul_one_class (has_nnnorm char)))) : is_compactly_generated (simple_graph (mul_one_class (has_nnnorm char))) := sorry --non-trivial
lemma new_lemma_63648 (h1 : ring (multiplicative string_imp)) : is_domain (multiplicative string_imp) := sorry --non-trivial
lemma new_lemma_63649 (h0 : topological_space (add_cancel_monoid (has_Inf (ring name)))) : t1_space (add_cancel_monoid (has_Inf (ring name))) := sorry --non-trivial
lemma new_lemma_63650 (h0 : not (topological_space (has_compl linarith.comp_source) -> false)) : @totally_disconnected_space.{0} (has_compl.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (topological_space.{0} (has_compl.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_63651 (h0 : topological_space (canonically_linear_ordered_monoid (sub_neg_monoid (has_add Type)))) : regular_space (canonically_linear_ordered_monoid (sub_neg_monoid (has_add Type))) := sorry --non-trivial
lemma new_lemma_63652 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_63653 (h0 : functor.add_const (complete_lattice (sub_neg_monoid real)) (has_bot (sub_neg_monoid pos))) : @complete_lattice.is_Sup_finite_compact.{0} (sub_neg_monoid.{0} real) (@functor.add_const.run.{0 0} (complete_lattice.{0} (sub_neg_monoid.{0} real)) (has_bot.{0} (sub_neg_monoid.{0} pos)) h0)  := sorry --non-trivial
lemma new_lemma_63654 (h0 : functor.add_const (ring (mul_zero_class ennreal)) ennreal) : @is_principal_ideal_ring.{0} (mul_zero_class.{0} ennreal) (@functor.add_const.run.{0 0} (ring.{0} (mul_zero_class.{0} ennreal)) ennreal h0)  := sorry --non-trivial
lemma new_lemma_63655 (h0 : topological_space (ring (semigroup (mul_one_class linarith.comp)))) : sequential_space (ring (semigroup (mul_one_class linarith.comp))) := sorry --non-trivial
lemma new_lemma_63656 (h0 : uniform_space (semi_normed_comm_ring (mul_one_class string.iterator_imp))) : complete_space (semi_normed_comm_ring (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_63657 (h0 : group (ordered_comm_monoid (has_bot (has_Inf real)))) : group.fg (ordered_comm_monoid (has_bot (has_Inf real))) := sorry --non-trivial
lemma new_lemma_63658 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t1_space.{0} (linear_ordered_comm_ring.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (linear_ordered_comm_ring.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_63659 (h0 : topological_space (cancel_monoid (has_add name))) : totally_disconnected_space (cancel_monoid (has_add name)) := sorry --non-trivial
lemma new_lemma_63660 (h0 : complete_lattice (left_cancel_monoid (option (option unsigned)))) : is_atomistic (left_cancel_monoid (option (option unsigned))) := sorry --non-trivial
lemma new_lemma_63661 (h0 : functor.add_const (function.extfun Type topological_space) linarith.comp) : @preirreducible_space.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type topological_space.{0}) linarith.comp h0) (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_63662 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @rank_condition.{0} (with_one.{0} fun_info) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (with_one.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_63663 (h0 : functor.add_const (ring (bin_tree empty)) congr_arg_kind) : @strong_rank_condition.{0} (bin_tree.{0} empty) (@functor.add_const.run.{0 0} (ring.{0} (bin_tree.{0} empty)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_63664 (h0 : topological_space (distrib (mul_one_class string.iterator_imp))) : path_connected_space (distrib (mul_one_class string.iterator_imp)) := sorry --non-trivial
lemma new_lemma_63665 (h0 : complete_lattice (measurable_space (has_top (has_top linarith.comp_source)))) : complete_lattice.is_Sup_finite_compact (measurable_space (has_top (has_top linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_63666 (h0 : complete_lattice name) : is_compactly_generated name := sorry --non-trivial
lemma new_lemma_63667 (h0 : filter (random_gen (has_norm congr_arg_kind))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_63668 (h0 : functor.add_const (topological_space (has_zero pos)) pos) : @preirreducible_space.{0} (has_zero.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (has_zero.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_63669 (h0 : topological_space (nondiscrete_normed_field (mul_one_class ereal))) : t0_space (nondiscrete_normed_field (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_63670 (h1 h2 : fintype (fintype string_imp) -> fintype (fintype string_imp)) : function.commute h1 h2 := sorry --non-trivial
lemma new_lemma_63671 (h0 : function.extfun nat fin) : @monoid.fg.{1} (has_pos_part.{1} Type) (@matrix.vec_empty.{1} (monoid.{1} (has_pos_part.{1} Type)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_63672 (h0 : list (linear_ordered_field name)) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_63673 (h0 : semilattice_inf (semiring empty)) (h1 : multiset (semilattice_inf (semiring empty))) : multiset.mem h0 h1 := sorry --non-trivial
lemma new_lemma_63674 (h0 : filter (normed_group linarith.comp_source)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_63675 (h1 : not (ring (dlist char) -> false)) : @is_domain.{0} (dlist.{0} char) (@classical.by_contradiction'.{1} (ring.{0} (dlist.{0} char)) h1)  := sorry --non-trivial
lemma new_lemma_63676 (h0 : topological_space (linear_ordered_semiring (semiring fun_info))) : irreducible_space (linear_ordered_semiring (semiring fun_info)) := sorry --non-trivial
lemma new_lemma_63677 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @is_simple_group.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) group.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 group.{1}) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_63678 (h0 : functor.add_const (finset (simple_graph pos)) Type) : finset.nonempty (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_63679 (h0 : monoid (ordered_comm_monoid (has_Inf linarith.comp))) : monoid.fg (ordered_comm_monoid (has_Inf linarith.comp)) := sorry --non-trivial
lemma new_lemma_63680 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 char) := sorry --non-trivial
lemma new_lemma_63681 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @path_connected_space.{1} (normed_comm_ring.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (normed_comm_ring.{1} Type))  := sorry --non-trivial
lemma new_lemma_63682 (h0 : complete_lattice (boolean_algebra (has_zero name))) : is_atomistic (boolean_algebra (has_zero name)) := sorry --non-trivial
lemma new_lemma_63683 (h0 : set (has_lt to_additive.value_type)) : set.finite h0 := sorry --non-trivial
lemma new_lemma_63684 (h0 : functor.add_const (ring (normed_comm_ring name)) (ring pos)) : @is_domain.{0} (normed_comm_ring.{0} name) (@functor.add_const.run.{0 0} (ring.{0} (normed_comm_ring.{0} name)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_63685 (h0 : functor.add_const (ring Type) (semigroup linarith.comp)) : @is_domain.{1} Type (@functor.add_const.run.{1 0} (ring.{1} Type) (semigroup.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_63686 (h1 h2 : multiset (nondiscrete_normed_field enat)) : multiset.disjoint h1 h2 := sorry --non-trivial
lemma new_lemma_63687 (h2 : set (ereal -> mul_one_class std_gen)) : set.separates_points h2 := sorry --non-trivial
lemma new_lemma_63688 (h0 : group (normed_comm_ring (comm_group Type))) : is_cyclic (normed_comm_ring (comm_group Type)) := sorry --non-trivial
lemma new_lemma_63689 (h0 : topological_space (has_pos_part linarith.comp)) : topological_space.separable_space (has_pos_part linarith.comp) := sorry --non-trivial
lemma new_lemma_63690 (h0 : pseudo_metric_space (simple_graph (option congr_arg_kind))) (h1 : monoid (simple_graph (option congr_arg_kind))) : has_lipschitz_mul (simple_graph (option congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_63691 (h1 : function.extfun Type ring) : @rank_condition.{0} (complete_semilattice_Sup.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} h1 (complete_semilattice_Sup.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_63692 (h5 : add_group ereal) : is_add_cyclic ereal := sorry --non-trivial
lemma new_lemma_63693 (h0 : topological_space (finset num)) : locally_compact_space (finset num) := sorry --non-trivial
lemma new_lemma_63694 (h0 : not (function.extfun Type topological_space -> false)) : @totally_separated_space.{0} (option.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (option.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_63695 (h0 : finset (complete_linear_order empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_63696 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : countable_Inter_filter (function.extfun_app (function.extfun_app h0 filter) (monoid pos)) := sorry --non-trivial
lemma new_lemma_63697 (h0 : functor.add_const Prop (has_top (semiring empty))) : functor.add_const.run h0 := sorry --non-trivial
lemma new_lemma_63698 (h0 : functor.add_const (semiring (add_group num)) congr_arg_kind) : @is_noetherian_ring.{0} (add_group.{0} num) (@functor.add_const.run.{0 0} (semiring.{0} (add_group.{0} num)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_63699 (h0 : complete_lattice (generalized_boolean_algebra (finset (has_Inf name)))) : is_compactly_generated (generalized_boolean_algebra (finset (has_Inf name))) := sorry --non-trivial
lemma new_lemma_63700 (h0 : uniform_space (has_to_string (has_pos_part pos))) : complete_space (has_to_string (has_pos_part pos)) := sorry --non-trivial
lemma new_lemma_63701 (h0 : functor.comp topological_space add_comm_monoid name) : @discrete_topology.{0} (add_comm_monoid.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} add_comm_monoid.{0} name h0)  := sorry --non-trivial
lemma new_lemma_63702 (h0 : list (comm_group (option (option pos)))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_63703 (h1 : topological_space string.iterator_imp) : totally_disconnected_space string.iterator_imp := sorry --non-trivial
lemma new_lemma_63704 (h0 : finset (add_right_cancel_monoid unsigned)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_63705 (h0 : not (ring (mul_one_class linarith.comp_source) -> false)) : @is_domain.{0} (mul_one_class.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (ring.{0} (mul_one_class.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_63706 (h0 : complete_lattice (has_inv (random_gen (has_nnnorm linarith.ineq)))) : complete_lattice.is_Sup_finite_compact (has_inv (random_gen (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_63707 (h1 : uniform_space (linear_ordered_add_comm_group string_imp)) : complete_space (linear_ordered_add_comm_group string_imp) := sorry --non-trivial
lemma new_lemma_63708 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_atomistic.{0} (has_zero.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 complete_lattice.{0}) (has_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_63709 (h0 : functor.add_const (add_monoid (has_nndist linarith.comp)) Type) : @add_monoid.fg.{0} (has_nndist.{0} linarith.comp) (@functor.add_const.run.{0 1} (add_monoid.{0} (has_nndist.{0} linarith.comp)) Type h0)  := sorry --non-trivial
lemma new_lemma_63710 (h0 : functor.add_const (topological_space (add_cancel_monoid Type)) environment.implicit_infer_kind) : @t1_space.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (topological_space.{1} (add_cancel_monoid.{1} Type)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_63711 (h0 : function.extfun (Type 1) ordered_add_comm_monoid) : @archimedean.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) ordered_add_comm_monoid.{1} h0 (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_63712 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem add_group)) : @is_add_cyclic.{0} (complete_semilattice_Sup.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) add_group.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) add_group.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (complete_semilattice_Sup.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_63713 (h0 : add_group (comm_ring (has_nnnorm (has_nnnorm (has_nnnorm char))))) : is_add_cyclic (comm_ring (has_nnnorm (has_nnnorm (has_nnnorm char)))) := sorry --non-trivial
lemma new_lemma_63714 (h0 : topological_space (ring congr_arg_kind)) : t0_space (ring congr_arg_kind) := sorry --non-trivial
lemma new_lemma_63715 (h0 : ring (has_nndist (has_to_string (has_to_string unsigned)))) : is_principal_ideal_ring (has_nndist (has_to_string (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_63716 (h0 : set (mul_one_class linarith.ineq -> ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_63717 (h0 : std_gen -> fun_info -> Prop) : relator.bi_unique h0 := sorry --non-trivial
lemma new_lemma_63718 (h0 : topological_space (linear_ordered_semiring (random_gen (random_gen fun_info)))) : path_connected_space (linear_ordered_semiring (random_gen (random_gen fun_info))) := sorry --non-trivial
lemma new_lemma_63719 (h0 : topological_space (canonically_ordered_comm_semiring (option unsigned))) : preconnected_space (canonically_ordered_comm_semiring (option unsigned)) := sorry --non-trivial
lemma new_lemma_63720 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @irreducible_space.{1} (ordered_comm_monoid.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (ordered_comm_monoid.{1} Type))  := sorry --non-trivial
lemma new_lemma_63721 (h0 : functor.add_const (cancel_comm_monoid_with_zero (boolean_algebra name)) Type) : @unique_factorization_monoid.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 1} (cancel_comm_monoid_with_zero.{0} (boolean_algebra.{0} name)) Type h0)  := sorry --non-trivial
lemma new_lemma_63722 (h0 : semiring (left_cancel_semigroup empty)) : is_noetherian_ring (left_cancel_semigroup empty) := sorry --non-trivial
lemma new_lemma_63723 (h0 : filter (distrib_lattice (has_nnnorm string_imp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_63724 (h0 : function.extfun Type topological_space) : @totally_separated_space.{0} (group_with_zero.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (group_with_zero.{0} num))  := sorry --non-trivial
lemma new_lemma_63725 (h0 : filter (fintype to_additive.value_type)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_63726 (h0 : functor.add_const (topological_space (linear_ordered_comm_monoid_with_zero unsigned)) (semiring empty)) : @t1_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (linear_ordered_comm_monoid_with_zero.{0} unsigned)) (semiring.{0} empty) h0)  := sorry --non-trivial
lemma new_lemma_63727 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (complete_distrib_lattice unsigned)) := sorry --non-trivial
lemma new_lemma_63728 (h0 : ring (with_zero (has_mul linarith.ineq))) : rank_condition (with_zero (has_mul linarith.ineq)) := sorry --non-trivial
lemma new_lemma_63729 (h0 : filter (linear_order empty)) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_63730 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (finset.{0} name) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (finset.{0} name))  := sorry --non-trivial
lemma new_lemma_63731 (h0 : topological_space (has_nnnorm (mul_one_class (normed_field string_imp)))) : path_connected_space (has_nnnorm (mul_one_class (normed_field string_imp))) := sorry --non-trivial
lemma new_lemma_63732 (h0 : function.extfun Type group) : @normalizer_condition.{0} (finset.{0} pos) (@function.extfun_app.{2 1} Type group.{0} h0 (finset.{0} pos))  := sorry --non-trivial
lemma new_lemma_63733 (h1 : set (linear_ordered_comm_group_with_zero environment.projection_info)) : set.finite h1 := sorry --non-trivial
lemma new_lemma_63734 (h0 : functor.add_const (uniform_space (generalized_boolean_algebra linarith.comp)) (has_add pos)) : @complete_space.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) (has_add.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_63735 (h0 : functor.comp topological_space boolean_algebra name) : @discrete_topology.{0} (boolean_algebra.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} boolean_algebra.{0} name h0)  := sorry --non-trivial
lemma new_lemma_63736 (h0 : function.extfun Type semiring) : @is_noetherian_ring.{0} (cancel_monoid.{0} ennreal) (@function.extfun_app.{2 1} Type semiring.{0} h0 (cancel_monoid.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_63737 (h0 : topological_space (simple_graph (mul_one_class ereal))) : path_connected_space (simple_graph (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_63738 (h0 : functor.add_const (topological_space (as_linear_order empty)) unsigned) : @t1_space.{0} (as_linear_order.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (as_linear_order.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_63739 (h0 : topological_space (boolean_algebra (has_pos_part (has_neg (finset (has_neg linarith.comp)))))) : t0_space (boolean_algebra (has_pos_part (has_neg (finset (has_neg linarith.comp))))) := sorry --non-trivial
lemma new_lemma_63740 (h0 : multiset (random_gen linarith.comp_source)) (h1 : not (multiset (random_gen linarith.comp_source) -> false)) : multiset.disjoint h0 (classical.by_contradiction' h1) := sorry --non-trivial
lemma new_lemma_63741 (h0 : monoid (canonically_ordered_comm_semiring (has_add Type))) : monoid.fg (canonically_ordered_comm_semiring (has_add Type)) := sorry --non-trivial
lemma new_lemma_63742 (h0 : topological_space (has_add (has_Inf (has_Inf real)))) : preirreducible_space (has_add (has_Inf (has_Inf real))) := sorry --non-trivial
lemma new_lemma_63743 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (linear_ordered_field.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_63744 (h0 : filter (linear_ordered_field (option ennreal))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_63745 (h0 : functor.add_const (topological_space (add_cancel_monoid name)) pos) : @topological_space.separable_space.{0} (add_cancel_monoid.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} name)) pos h0)  := sorry --non-trivial
lemma new_lemma_63746 (h0 : functor.add_const (function.extfun Type complete_lattice) linarith.comp) : @complete_lattice.is_Sup_finite_compact.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@functor.add_const.run.{1 0} (function.extfun.{2 1} Type complete_lattice.{0}) linarith.comp h0) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_63747 (h0 : topological_space (add_right_cancel_monoid (semiring empty))) : totally_disconnected_space (add_right_cancel_monoid (semiring empty)) := sorry --non-trivial
lemma new_lemma_63748 (h0 : not (add_group (linear_ordered_comm_ring congr_arg_kind) -> false)) : @is_add_cyclic.{0} (linear_ordered_comm_ring.{0} congr_arg_kind) (@classical.by_contradiction'.{1} (add_group.{0} (linear_ordered_comm_ring.{0} congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_63749 (h0 : add_group (topological_space (denumerable char))) : is_add_cyclic (topological_space (denumerable char)) := sorry --non-trivial
lemma new_lemma_63750 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (left_cancel_semigroup.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (left_cancel_semigroup.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_63751 (h0 : function.extfun Type (functor.comp topological_space finset)) : @t1_space.{0} (finset.{0} name) (@functor.comp.run.{0 0 0} topological_space.{0} finset.{0} name (@function.extfun_app.{2 1} Type (functor.comp.{0 0 0} topological_space.{0} finset.{0}) h0 name))  := sorry --non-trivial
lemma new_lemma_63752 (h0 : functor.add_const (topological_space (boolean_algebra name)) environment.implicit_infer_kind) : @preconnected_space.{0} (boolean_algebra.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (boolean_algebra.{0} name)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_63753 (h0 : functor.add_const (topological_space (generalized_boolean_algebra linarith.comp)) name) : @discrete_topology.{0} (generalized_boolean_algebra.{0} linarith.comp) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} linarith.comp)) name h0)  := sorry --non-trivial
lemma new_lemma_63754 (h0 : functor.add_const (group (comm_group name)) linarith.comp) : @group.fg.{0} (comm_group.{0} name) (@functor.add_const.run.{0 0} (group.{0} (comm_group.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_63755 (h0 : topological_space (has_nndist (has_to_string Type))) : loc_path_connected_space (has_nndist (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_63756 (h0 : functor.add_const (topological_space (boolean_algebra (has_add name))) Type) : @totally_disconnected_space.{0} (boolean_algebra.{0} (has_add.{0} name)) (@functor.add_const.run.{0 1} (topological_space.{0} (boolean_algebra.{0} (has_add.{0} name))) Type h0)  := sorry --non-trivial
lemma new_lemma_63757 (h0 : uniform_space (monoid_with_zero (option (option ennreal)))) : complete_space (monoid_with_zero (option (option ennreal))) := sorry --non-trivial
lemma new_lemma_63758 (h0 : uniform_space (normed_lattice_add_comm_group (has_neg Type))) : separated_space (normed_lattice_add_comm_group (has_neg Type)) := sorry --non-trivial
lemma new_lemma_63759 (h0 : group (has_nndist (has_to_string unsigned))) : group.fg (has_nndist (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_63760 (h0 : functor.add_const (ring (comm_group linarith.comp)) (has_to_string Type)) : @strong_rank_condition.{0} (comm_group.{0} linarith.comp) (@functor.add_const.run.{0 1} (ring.{0} (comm_group.{0} linarith.comp)) (has_to_string.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_63761 (h0 : function.extfun nat fin) : @is_cyclic.{0} (add_comm_monoid.{0} pos) (@matrix.vec_empty.{0} (group.{0} (add_comm_monoid.{0} pos)) (@function.extfun_app.{1 1} nat fin h0 (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_63762 (h0 : cancel_comm_monoid_with_zero unsigned) : unique_factorization_monoid unsigned := sorry --non-trivial
lemma new_lemma_63763 (h2 : Prop) : set.separates_points (id (fun (h1 : environment.projection_info -> char), h2)) := sorry --non-trivial
lemma new_lemma_63764 (h0 : ordered_add_comm_monoid (has_to_string (ring (ring (ring (ring environment.implicit_infer_kind)))))) : archimedean (has_to_string (ring (ring (ring (ring environment.implicit_infer_kind))))) := sorry --non-trivial
lemma new_lemma_63765 (h0 : functor.add_const (list (has_to_string Type)) linarith.comp) : list.nodup (functor.add_const.run h0) := sorry --non-trivial
lemma new_lemma_63766 (h0 : group (finset (has_to_string (ring Type)))) : group.fg (finset (has_to_string (ring Type))) := sorry --non-trivial
lemma new_lemma_63767 (h0 : topological_space (mul_zero_class congr_arg_kind)) : topological_space.separable_space (mul_zero_class congr_arg_kind) := sorry --non-trivial
lemma new_lemma_63768 (h0 : list (normed_comm_ring (comm_monoid unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_63769 (h1 : monoid (measurable_space (random_gen linarith.ineq))) : monoid.fg (measurable_space (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_63770 (h0 : topological_space (boolean_algebra.core (has_neg name))) : discrete_topology (boolean_algebra.core (has_neg name)) := sorry --non-trivial
lemma new_lemma_63771 (h0 : not (topological_space (complete_semilattice_Sup unsigned) -> false)) : @locally_compact_space.{0} (complete_semilattice_Sup.{0} unsigned) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_63772 (h0 : function.extfun Type add_monoid) : @add_monoid.fg.{0} (partial_order.{0} num) (@function.extfun_app.{2 1} Type add_monoid.{0} h0 (partial_order.{0} num))  := sorry --non-trivial
lemma new_lemma_63773 (h0 : add_group (semi_normed_comm_ring linarith.ineq)) : is_add_cyclic (semi_normed_comm_ring linarith.ineq) := sorry --non-trivial
lemma new_lemma_63774 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @unique_factorization_monoid.{0} auto.case_option (@function.extfun_app.{2 1} Type cancel_comm_monoid_with_zero.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 cancel_comm_monoid_with_zero.{0}) auto.case_option)  := sorry --non-trivial
lemma new_lemma_63775 (h1 : ring (semi_normed_ring (linear_ordered_cancel_add_comm_monoid reducibility_hints))) : rank_condition (semi_normed_ring (linear_ordered_cancel_add_comm_monoid reducibility_hints)) := sorry --non-trivial
lemma new_lemma_63776 (h1 : prod (add_comm_semigroup linarith.ineq) (add_comm_semigroup linarith.ineq)) : set.diagonal (add_comm_semigroup linarith.ineq) h1 := sorry --non-trivial
lemma new_lemma_63777 (h0 : functor.add_const (function.extfun Type ring) Type) : @rank_condition.{0} (semigroup.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type ring.{0}) Type h0) (semigroup.{0} pos))  := sorry --non-trivial
lemma new_lemma_63778 (h0 : ring (div_inv_monoid (random_gen string_imp))) : rank_condition (div_inv_monoid (random_gen string_imp)) := sorry --non-trivial
lemma new_lemma_63779 (h0 : functor.add_const (complete_lattice (semigroup pos)) (finset Type)) : @is_compactly_generated.{0} (semigroup.{0} pos) (@functor.add_const.run.{0 1} (complete_lattice.{0} (semigroup.{0} pos)) (finset.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_63780 (h0 : complete_lattice (comm_semigroup linarith.comp)) : complete_lattice.is_Sup_finite_compact (comm_semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_63781 (h0 : not (filter (add_left_cancel_monoid (nondiscrete_normed_field linarith.ineq)) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_63782 (h0 : group (boolean_algebra.core (has_add Type))) : group.fg (boolean_algebra.core (has_add Type)) := sorry --non-trivial
lemma new_lemma_63783 (h0 : functor.add_const (topological_space (has_neg unsigned)) name) : @discrete_topology.{0} (has_neg.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (has_neg.{0} unsigned)) name h0)  := sorry --non-trivial
lemma new_lemma_63784 (h0 : topological_space (with_one (semiring (semiring empty)))) : irreducible_space (with_one (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_63785 (h0 : topological_space (has_append (random_gen linarith.ineq))) : path_connected_space (has_append (random_gen linarith.ineq)) := sorry --non-trivial
lemma new_lemma_63786 (h0 : functor.add_const (topological_space (finset name)) (ring pos)) : @t0_space.{0} (finset.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (finset.{0} name)) (ring.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_63787 (h1 : complete_lattice (simple_graph reducibility_hints)) : complete_lattice.is_Sup_finite_compact (simple_graph reducibility_hints) := sorry --non-trivial
lemma new_lemma_63788 (h0 : not (function.extfun (Type -> Type) (function.extfun Type) -> false)) : @is_add_cyclic.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type add_group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@classical.by_contradiction'.{2} (function.extfun.{2 2} (Type → Type) (function.extfun.{2 1} Type)) h0) add_group.{0}) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_63789 (h0 : complete_lattice (distrib (comm_ring fun_info))) : complete_lattice.is_Sup_finite_compact (distrib (comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_63790 (h0 : function.extfun Type filter) : filter.ne_bot (function.extfun_app h0 (option unsigned)) := sorry --non-trivial
lemma new_lemma_63791 (h0 : not (add_monoid (semi_normed_ring (mul_one_class enat)) -> false)) : @add_monoid.fg.{0} (semi_normed_ring.{0} (mul_one_class.{0} enat)) (@classical.by_contradiction'.{1} (add_monoid.{0} (semi_normed_ring.{0} (mul_one_class.{0} enat))) h0)  := sorry --non-trivial
lemma new_lemma_63792 (h0 : function.extfun Type topological_space) : @totally_disconnected_space.{0} (complete_distrib_lattice.{0} num) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (complete_distrib_lattice.{0} num))  := sorry --non-trivial
lemma new_lemma_63793 (h0 : function.extfun Type topological_space) : @t0_space.{0} (denumerable.{0} to_additive.value_type) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (denumerable.{0} to_additive.value_type))  := sorry --non-trivial
lemma new_lemma_63794 (h0 : uniform_space (denumerable (has_nnnorm (has_nnnorm linarith.ineq)))) : complete_space (denumerable (has_nnnorm (has_nnnorm linarith.ineq))) := sorry --non-trivial
lemma new_lemma_63795 (h0 : topological_space (uniform_space (random_gen linarith.comp_source))) : t0_space (uniform_space (random_gen linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_63796 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @preirreducible_space.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_63797 (h0 : ring (ordered_comm_monoid (has_add (has_Inf Type)))) : is_principal_ideal_ring (ordered_comm_monoid (has_add (has_Inf Type))) := sorry --non-trivial
lemma new_lemma_63798 (h0 : uniform_space (semi_normed_comm_ring (has_nnnorm linarith.ineq))) : complete_space (semi_normed_comm_ring (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_63799 (h0 h1 : multiset (uniform_space (mul_one_class char))) : multiset.disjoint h0 h1 := sorry --non-trivial
lemma new_lemma_63800 (h0 : function.extfun Type topological_space) : @sequential_space.{0} (semigroup.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (semigroup.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_63801 (h0 : ring (generalized_boolean_algebra (has_add (has_Inf linarith.comp)))) : rank_condition (generalized_boolean_algebra (has_add (has_Inf linarith.comp))) := sorry --non-trivial
lemma new_lemma_63802 (h0 : add_monoid (semiring (semiring linarith.comp))) : add_monoid.fg (semiring (semiring linarith.comp)) := sorry --non-trivial
lemma new_lemma_63803 (h0 : ring (has_div (mul_one_class ereal))) : rank_condition (has_div (mul_one_class ereal)) := sorry --non-trivial
lemma new_lemma_63804 (h0 : uniform_space (measurable_space (has_inv linarith.ineq))) : complete_space (measurable_space (has_inv linarith.ineq)) := sorry --non-trivial
lemma new_lemma_63805 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (add_cancel_monoid.{0} pos) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (add_cancel_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_63806 (h0 : complete_lattice (add_comm_monoid (has_to_string Type))) : is_compactly_generated (add_comm_monoid (has_to_string Type)) := sorry --non-trivial
lemma new_lemma_63807 (h0 : function.extfun Type complete_lattice) : @is_compactly_generated.{0} (random_gen.{0} (has_top.{0} fun_info)) (@function.extfun_app.{2 1} Type complete_lattice.{0} h0 (random_gen.{0} (has_top.{0} fun_info)))  := sorry --non-trivial
lemma new_lemma_63808 (h0 : functor.add_const (ordered_add_comm_monoid ennreal) (option (option num))) : archimedean ennreal := sorry --non-trivial
lemma new_lemma_63809 (h0 : topological_space (complete_semilattice_Sup (random_gen unsigned))) : t0_space (complete_semilattice_Sup (random_gen unsigned)) := sorry --non-trivial
lemma new_lemma_63810 (h0 : ring (ordered_comm_ring (finset (ring (ring pos))))) : is_domain (ordered_comm_ring (finset (ring (ring pos)))) := sorry --non-trivial
lemma new_lemma_63811 (h0 : functor.add_const (topological_space (has_nndist name)) linarith.comp) : @path_connected_space.{0} (has_nndist.{0} name) (@functor.add_const.run.{0 0} (topological_space.{0} (has_nndist.{0} name)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_63812 (h0 : add_group (semigroup linarith.comp)) : is_add_cyclic (semigroup linarith.comp) := sorry --non-trivial
lemma new_lemma_63813 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (is_R_or_C.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (is_R_or_C.{0} empty))  := sorry --non-trivial
lemma new_lemma_63814 (h0 : functor.add_const (complete_lattice (comm_monoid unsigned)) empty) : @complete_lattice.is_Sup_finite_compact.{0} (comm_monoid.{0} unsigned) (@functor.add_const.run.{0 0} (complete_lattice.{0} (comm_monoid.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_63815 (h0 : filter (add_right_cancel_monoid (semiring (semiring congr_arg_kind)))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_63816 (h0 : ring (omega_complete_partial_order (has_sdiff congr_arg_kind))) : rank_condition (omega_complete_partial_order (has_sdiff congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_63817 (h0 : functor.add_const (function.extfun Type finset) pos) : finset.nonempty (function.extfun_app (functor.add_const.run h0) (add_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_63818 (h1 : function.extfun (Type -> Type) (function.extfun Type)) : @discrete_topology.{0} (has_top.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h1 topological_space.{0}) (has_top.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_63819 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_Inf.{0} pos) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_Inf.{0} pos))  := sorry --non-trivial
lemma new_lemma_63820 (h4 : uniform_space (non_unital_non_assoc_semiring string_imp)) : complete_space (non_unital_non_assoc_semiring string_imp) := sorry --non-trivial
lemma new_lemma_63821 (h0 : list (linear_ordered_field (linear_ordered_field unsigned))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_63822 (h0 : ordered_add_comm_monoid (add_cancel_monoid (boolean_algebra.core linarith.comp))) : archimedean (add_cancel_monoid (boolean_algebra.core linarith.comp)) := sorry --non-trivial
lemma new_lemma_63823 (h0 : topological_space (add_left_cancel_semigroup congr_arg_kind)) : t0_space (add_left_cancel_semigroup congr_arg_kind) := sorry --non-trivial
lemma new_lemma_63824 (h0 : add_group (semi_normed_ring (mul_one_class string_imp))) : is_add_cyclic (semi_normed_ring (mul_one_class string_imp)) := sorry --non-trivial
lemma new_lemma_63825 (h0 : group (complete_distrib_lattice (has_neg pos))) : group.fg (complete_distrib_lattice (has_neg pos)) := sorry --non-trivial
lemma new_lemma_63826 (h0 : functor.comp add_group comm_group (option pos)) : @is_add_cyclic.{0} (comm_group.{0} (option.{0} pos)) (@functor.comp.run.{0 0 0} add_group.{0} comm_group.{0} (option.{0} pos) h0)  := sorry --non-trivial
lemma new_lemma_63827 (h0 : function.extfun ((Type 1 -> Type 1) -> Type 2) (function.extfun (Type 1 -> Type 1))) : @is_atomistic.{1} (plift.{1} congr_arg_kind) (@function.extfun_app.{3 2} (Type 1) complete_lattice.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) (@function.extfun_app.{4 3} ((Type 1 → Type 1) → Type 2) (function.extfun.{3 3} (Type 1 → Type 1)) h0 (function.extfun.{3 2} (Type 1))) complete_lattice.{1}) (plift.{1} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_63828 (h0 : functor.add_const (topological_space (generalized_boolean_algebra pos)) name) : @sequential_space.{0} (generalized_boolean_algebra.{0} pos) (@functor.add_const.run.{0 0} (topological_space.{0} (generalized_boolean_algebra.{0} pos)) name h0)  := sorry --non-trivial
lemma new_lemma_63829 (h0 : topological_space (boolean_algebra (has_add (has_add (has_add name))))) : preirreducible_space (boolean_algebra (has_add (has_add (has_add name)))) := sorry --non-trivial
lemma new_lemma_63830 (h0 : fin has_zero.zero) : @loc_path_connected_space.{1} (ordered_comm_ring.{1} Type) (@matrix.vec_empty.{1} (topological_space.{1} (ordered_comm_ring.{1} Type)) h0)  := sorry --non-trivial
lemma new_lemma_63831 (h0 : function.extfun Type (functor.add_const (ordered_add_comm_monoid znum))) : @archimedean.{0} znum (@functor.add_const.run.{0 0} (ordered_add_comm_monoid.{0} znum) num (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (ordered_add_comm_monoid.{0} znum)) h0 num))  := sorry --non-trivial
lemma new_lemma_63832 (h0 : topological_space (has_neg_part (option (has_to_string ennreal)))) : locally_compact_space (has_neg_part (option (has_to_string ennreal))) := sorry --non-trivial
lemma new_lemma_63833 (h0 : not (function.extfun Type ring -> false)) : @rank_condition.{0} (with_one.{0} linarith.comp) (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) (with_one.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_63834 (h0 : fin has_zero.zero) : @discrete_topology.{0} (has_bot.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (has_bot.{0} linarith.comp)) h0)  := sorry --non-trivial
lemma new_lemma_63835 (h0 : complete_distrib_lattice unsigned -> complete_distrib_lattice unsigned -> Prop) : total h0 := sorry --non-trivial
lemma new_lemma_63836 (h0 : add_group (has_pos_part Type)) : is_add_cyclic (has_pos_part Type) := sorry --non-trivial
lemma new_lemma_63837 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : list.nodup (function.extfun_app (function.extfun_app h0 list) (distrib_lattice fun_info)) := sorry --non-trivial
lemma new_lemma_63838 (h0 : complete_lattice (mul_one_class string.iterator_imp)) : complete_lattice.is_Sup_finite_compact (mul_one_class string.iterator_imp) := sorry --non-trivial
lemma new_lemma_63839 (h0 : uniform_space (measurable_space (random_gen num))) : separated_space (measurable_space (random_gen num)) := sorry --non-trivial
lemma new_lemma_63840 (h0 : function.extfun Type topological_space) : @t0_space.{0} (partial_order.{0} empty) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (partial_order.{0} empty))  := sorry --non-trivial
lemma new_lemma_63841 (h0 : complete_lattice (option (has_add ennreal))) : is_compactly_generated (option (has_add ennreal)) := sorry --non-trivial
lemma new_lemma_63842 (h0 : group (has_add (has_add name))) : is_simple_group (has_add (has_add name)) := sorry --non-trivial
lemma new_lemma_63843 (h0 : complete_lattice (omega_complete_partial_order (semiring unsigned))) : complete_lattice.is_Sup_finite_compact (omega_complete_partial_order (semiring unsigned)) := sorry --non-trivial
lemma new_lemma_63844 (h0 : topological_space (option unsigned)) : preirreducible_space (option unsigned) := sorry --non-trivial
lemma new_lemma_63845 (h0 : ring unsigned) : strong_rank_condition unsigned := sorry --non-trivial
lemma new_lemma_63846 (h0 : group (comm_group (option (option pos)))) : is_cyclic (comm_group (option (option pos))) := sorry --non-trivial
lemma new_lemma_63847 (h0 : not (ring (add_monoid to_additive.value_type) -> false)) : @rank_condition.{0} (add_monoid.{0} to_additive.value_type) (@classical.by_contradiction'.{1} (ring.{0} (add_monoid.{0} to_additive.value_type)) h0)  := sorry --non-trivial
lemma new_lemma_63848 (h0 : function.extfun Type topological_space) : @loc_path_connected_space.{0} (sub_neg_monoid.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (sub_neg_monoid.{0} pos))  := sorry --non-trivial
lemma new_lemma_63849 (h0 : ring (semi_normed_ring (random_gen (linear_ordered_add_comm_group char)))) : is_domain (semi_normed_ring (random_gen (linear_ordered_add_comm_group char))) := sorry --non-trivial
lemma new_lemma_63850 (h0 : topological_space (has_to_string (has_add environment.implicit_infer_kind))) : path_connected_space (has_to_string (has_add environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_63851 (h0 : add_monoid (has_neg environment.implicit_infer_kind)) : add_monoid.fg (has_neg environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_63852 (h0 : topological_space (has_to_string (has_to_string unsigned))) : irreducible_space (has_to_string (has_to_string unsigned)) := sorry --non-trivial
lemma new_lemma_63853 (h0 : function.extfun (Type 1) topological_space) : @discrete_topology.{1} (boolean_algebra.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} h0 (boolean_algebra.{1} Type))  := sorry --non-trivial
lemma new_lemma_63854 (h0 : functor.add_const (function.extfun (Type 1) topological_space) Type) : @irreducible_space.{1} (has_to_string.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@functor.add_const.run.{2 1} (function.extfun.{3 2} (Type 1) topological_space.{1}) Type h0) (has_to_string.{1} Type))  := sorry --non-trivial
lemma new_lemma_63855 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @group.fg.{0} (encodable.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (encodable.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_63856 (h0 : function.extfun Type (functor.add_const (monoid (left_cancel_monoid empty)))) : @monoid.fg.{0} (left_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (monoid.{0} (left_cancel_monoid.{0} empty)) empty (@function.extfun_app.{2 1} Type (functor.add_const.{0 0} (monoid.{0} (left_cancel_monoid.{0} empty))) h0 empty))  := sorry --non-trivial
lemma new_lemma_63857 (h0 : complete_lattice (complete_distrib_lattice (finset (finset (finset pos))))) : is_compactly_generated (complete_distrib_lattice (finset (finset (finset pos)))) := sorry --non-trivial
lemma new_lemma_63858 (h0 : uniform_space (ordered_comm_ring (finset linarith.comp))) : complete_space (ordered_comm_ring (finset linarith.comp)) := sorry --non-trivial
lemma new_lemma_63859 (h0 : functor.add_const (topological_space (option congr_arg_kind)) congr_arg_kind) : @normal_space.{0} (option.{0} congr_arg_kind) (@functor.add_const.run.{0 0} (topological_space.{0} (option.{0} congr_arg_kind)) congr_arg_kind h0)  := sorry --non-trivial
lemma new_lemma_63860 (h0 : functor.add_const (function.extfun Type group) (has_neg Type)) : @group.fg.{0} (has_neg.{0} pos) (@function.extfun_app.{2 1} Type group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type group.{0}) (has_neg.{1} Type) h0) (has_neg.{0} pos))  := sorry --non-trivial
lemma new_lemma_63861 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (has_pos_part.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (has_pos_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_63862 (h0 : ring (non_unital_non_assoc_semiring (mul_one_class enat))) : strong_rank_condition (non_unital_non_assoc_semiring (mul_one_class enat)) := sorry --non-trivial
lemma new_lemma_63863 (h0 : functor.add_const (topological_space (add_cancel_monoid empty)) unsigned) : @totally_disconnected_space.{0} (add_cancel_monoid.{0} empty) (@functor.add_const.run.{0 0} (topological_space.{0} (add_cancel_monoid.{0} empty)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_63864 (h0 : not (ring (semi_normed_ring enat) -> false)) : @strong_rank_condition.{0} (semi_normed_ring.{0} enat) (@classical.by_contradiction'.{1} (ring.{0} (semi_normed_ring.{0} enat)) h0)  := sorry --non-trivial
lemma new_lemma_63865 (h0 : function.extfun (finset Type) (has_mem.mem (linear_ordered_semiring num))) : @t0_space.{0} (linear_ordered_semiring.{0} num) (@finset.pi.empty.{1 0} Type topological_space.{0} (linear_ordered_semiring.{0} num) (@function.extfun_app.{2 0} (finset.{1} Type) (@has_mem.mem.{1 1} Type (finset.{1} Type) (@finset.has_mem.{1} Type) (linear_ordered_semiring.{0} num)) h0 (@has_emptyc.emptyc.{1} (finset.{1} Type) (@finset.has_emptyc.{1} Type))))  := sorry --non-trivial
lemma new_lemma_63866 (h0 : uniform_space (has_neg (finset (has_neg (boolean_algebra linarith.comp))))) : complete_space (has_neg (finset (has_neg (boolean_algebra linarith.comp)))) := sorry --non-trivial
lemma new_lemma_63867 (h0 : functor.add_const (add_group (finset pos)) unsigned) : @is_add_cyclic.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (add_group.{0} (finset.{0} pos)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_63868 (h0 : function.extfun Type ring) : @is_principal_ideal_ring.{0} (has_to_string.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_to_string.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_63869 (h1 : add_group (semi_normed_comm_ring (has_nnnorm string_imp))) : is_add_cyclic (semi_normed_comm_ring (has_nnnorm string_imp)) := sorry --non-trivial
lemma new_lemma_63870 (h0 : not (function.extfun Type ring -> false)) : @is_domain.{0} name (@function.extfun_app.{2 1} Type ring.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type ring.{0}) h0) name)  := sorry --non-trivial
lemma new_lemma_63871 (h0 : function.extfun Type topological_space) : @irreducible_space.{0} (linear_ordered_field.{0} unsigned) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (linear_ordered_field.{0} unsigned))  := sorry --non-trivial
lemma new_lemma_63872 (h0 : has_mem.mem (with_bot linarith.comp) has_emptyc.emptyc) : @locally_compact_space.{0} (with_bot.{0} linarith.comp) (@finset.pi.empty.{1 0} Type topological_space.{0} (with_bot.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_63873 (h0 : group (id linarith.comp_source)) : normalizer_condition (id linarith.comp_source) := sorry --non-trivial
lemma new_lemma_63874 (h0 : group (ordered_comm_group (semiring (semiring empty)))) : group.fg (ordered_comm_group (semiring (semiring empty))) := sorry --non-trivial
lemma new_lemma_63875 (h0 : cancel_comm_monoid_with_zero (has_star (semiring (semiring unsigned)))) : unique_factorization_monoid (has_star (semiring (semiring unsigned))) := sorry --non-trivial
lemma new_lemma_63876 (h0 : ring (has_inv (div_inv_monoid linarith.comp_source))) : rank_condition (has_inv (div_inv_monoid linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_63877 (h0 : functor.add_const (uniform_space (finset pos)) pos) : @separated_space.{0} (finset.{0} pos) (@functor.add_const.run.{0 0} (uniform_space.{0} (finset.{0} pos)) pos h0)  := sorry --non-trivial
lemma new_lemma_63878 (h0 : topological_space (complete_linear_order empty)) : preirreducible_space (complete_linear_order empty) := sorry --non-trivial
lemma new_lemma_63879 (h0 : measurable_space (uniform_space (mul_one_class (mul_one_class linarith.ineq)))) (h1 : not (has_inf (uniform_space (mul_one_class (mul_one_class linarith.ineq))) -> false)) : has_measurable_inf₂ (uniform_space (mul_one_class (mul_one_class linarith.ineq))) := sorry --non-trivial
lemma new_lemma_63880 (h1 : Prop) : classical.epsilon (fun (h0 : Prop), h1) := sorry --non-trivial
lemma new_lemma_63881 (h0 : topological_space (semigroup ennreal)) : loc_path_connected_space (semigroup ennreal) := sorry --non-trivial
lemma new_lemma_63882 (h0 : filter (simple_graph (has_Inf linarith.comp))) : countable_Inter_filter h0 := sorry --non-trivial
lemma new_lemma_63883 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_domain.{0} (ring.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 ring.{0}) (ring.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_63884 (h0 : add_monoid (monoid (option empty))) : add_monoid.fg (monoid (option empty)) := sorry --non-trivial
lemma new_lemma_63885 (h0 : functor.add_const (complete_lattice (semigroup name)) name) : @is_atomistic.{0} (semigroup.{0} name) (@functor.add_const.run.{0 0} (complete_lattice.{0} (semigroup.{0} name)) name h0)  := sorry --non-trivial
lemma new_lemma_63886 (h0 : function.extfun Type ordered_add_comm_monoid) : @archimedean.{0} (omega_complete_partial_order.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ordered_add_comm_monoid.{0} h0 (omega_complete_partial_order.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_63887 (h1 : topological_space (has_le to_additive.value_type)) : t0_space (has_le to_additive.value_type) := sorry --non-trivial
lemma new_lemma_63888 (h0 : not (topological_space (complete_semilattice_Sup (has_top linarith.comp_source)) -> false)) : @totally_separated_space.{0} (complete_semilattice_Sup.{0} (has_top.{0} linarith.comp_source)) (@classical.by_contradiction'.{1} (topological_space.{0} (complete_semilattice_Sup.{0} (has_top.{0} linarith.comp_source))) h0)  := sorry --non-trivial
lemma new_lemma_63889 (h0 : function.extfun Type ring) : @rank_condition.{0} (is_R_or_C.{0} congr_arg_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (is_R_or_C.{0} congr_arg_kind))  := sorry --non-trivial
lemma new_lemma_63890 (h0 : ring (ordered_comm_monoid name)) : rank_condition (ordered_comm_monoid name) := sorry --non-trivial
lemma new_lemma_63891 (h0 : complete_lattice (has_ssubset to_additive.value_type)) : is_compactly_generated (has_ssubset to_additive.value_type) := sorry --non-trivial
lemma new_lemma_63892 (h0 : function.extfun Type uniform_space) : @complete_space.{0} (has_neg_part.{0} pos) (@function.extfun_app.{2 1} Type uniform_space.{0} h0 (has_neg_part.{0} pos))  := sorry --non-trivial
lemma new_lemma_63893 (h0 : functor.add_const (ring (add_cancel_monoid Type)) name) : @rank_condition.{1} (add_cancel_monoid.{1} Type) (@functor.add_const.run.{1 0} (ring.{1} (add_cancel_monoid.{1} Type)) name h0)  := sorry --non-trivial
lemma new_lemma_63894 (h0 : functor.add_const (uniform_space (has_neg linarith.comp)) linarith.comp) : @separated_space.{0} (has_neg.{0} linarith.comp) (@functor.add_const.run.{0 0} (uniform_space.{0} (has_neg.{0} linarith.comp)) linarith.comp h0)  := sorry --non-trivial
lemma new_lemma_63895 (h0 : has_mem.mem (metric_space num) has_emptyc.emptyc) : @is_atomistic.{0} (metric_space.{0} num) (@finset.pi.empty.{1 0} Type complete_lattice.{0} (metric_space.{0} num) h0)  := sorry --non-trivial
lemma new_lemma_63896 (h1 : group (has_nnnorm linarith.comp_source)) : is_cyclic (has_nnnorm linarith.comp_source) := sorry --non-trivial
lemma new_lemma_63897 (h0 : ring (linear_ordered_add_comm_monoid_with_top ennreal)) : is_domain (linear_ordered_add_comm_monoid_with_top ennreal) := sorry --non-trivial
lemma new_lemma_63898 (h0 : not (function.extfun Type list -> false)) : list.nodup (function.extfun_app (classical.by_contradiction' h0) (semi_normed_comm_ring fun_info)) := sorry --non-trivial
lemma new_lemma_63899 (h0 : add_group (dlist (has_nnnorm linarith.ineq))) : is_add_cyclic (dlist (has_nnnorm linarith.ineq)) := sorry --non-trivial
lemma new_lemma_63900 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (normed_linear_ordered_group num)) := sorry --non-trivial
lemma new_lemma_63901 (h0 : not (complete_lattice (has_norm linarith.comp_source) -> false)) : @is_atomistic.{0} (has_norm.{0} linarith.comp_source) (@classical.by_contradiction'.{1} (complete_lattice.{0} (has_norm.{0} linarith.comp_source)) h0)  := sorry --non-trivial
lemma new_lemma_63902 (h0 : functor.add_const (topological_space (has_bot name)) (has_Inf Type)) : @path_connected_space.{0} (has_bot.{0} name) (@functor.add_const.run.{0 1} (topological_space.{0} (has_bot.{0} name)) (has_Inf.{1} Type) h0)  := sorry --non-trivial
lemma new_lemma_63903 (h0 : complete_lattice (has_norm (with_bot linarith.comp_source))) : complete_lattice.is_Sup_finite_compact (has_norm (with_bot linarith.comp_source)) := sorry --non-trivial
lemma new_lemma_63904 (h0 : topological_space (has_zero Type)) : loc_path_connected_space (has_zero Type) := sorry --non-trivial
lemma new_lemma_63905 (h0 : functor.add_const (function.extfun Type monoid) Type) : @monoid.fg.{0} (has_to_string.{0} linarith.comp) (@function.extfun_app.{2 1} Type monoid.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type monoid.{0}) Type h0) (has_to_string.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_63906 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @t0_space.{0} (monoid_with_zero.{0} pos) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (monoid_with_zero.{0} pos))  := sorry --non-trivial
lemma new_lemma_63907 (h0 : functor.add_const (group (boolean_algebra environment.implicit_infer_kind)) (has_add name)) : @group.fg.{0} (boolean_algebra.{0} environment.implicit_infer_kind) (@functor.add_const.run.{0 0} (group.{0} (boolean_algebra.{0} environment.implicit_infer_kind)) (has_add.{0} name) h0)  := sorry --non-trivial
lemma new_lemma_63908 (h0 : function.extfun (finset ((Type -> Type) -> Type 1)) (has_mem.mem (function.extfun Type))) : @complete_lattice.is_Sup_finite_compact.{0} congr_arg_kind (@function.extfun_app.{2 1} Type complete_lattice.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) (@finset.pi.empty.{2 1} ((Type → Type) → Type 1) (function.extfun.{2 2} (Type → Type)) (function.extfun.{2 1} Type) (@function.extfun_app.{3 0} (finset.{2} ((Type → Type) → Type 1)) (@has_mem.mem.{2 2} ((Type → Type) → Type 1) (finset.{2} ((Type → Type) → Type 1)) (@finset.has_mem.{2} ((Type → Type) → Type 1)) (function.extfun.{2 1} Type)) h0 (@has_emptyc.emptyc.{2} (finset.{2} ((Type → Type) → Type 1)) (@finset.has_emptyc.{2} ((Type → Type) → Type 1))))) complete_lattice.{0}) congr_arg_kind)  := sorry --non-trivial
lemma new_lemma_63909 (h0 : topological_space (canonically_ordered_monoid (ordered_comm_monoid pos))) : path_connected_space (canonically_ordered_monoid (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_63910 (h0 : functor.add_const (group (finset linarith.comp)) pos) : @group.fg.{0} (finset.{0} linarith.comp) (@functor.add_const.run.{0 0} (group.{0} (finset.{0} linarith.comp)) pos h0)  := sorry --non-trivial
lemma new_lemma_63911 (h0 : list (has_neg (option (option (option unsigned))))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_63912 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem topological_space)) : @t0_space.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type topological_space.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) topological_space.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) topological_space.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_63913 (h0 : ring (has_top (linear_ordered_semiring empty))) : is_domain (has_top (linear_ordered_semiring empty)) := sorry --non-trivial
lemma new_lemma_63914 (h0 : ordered_comm_monoid subsingleton_info) : has_exists_mul_of_le subsingleton_info := sorry --non-trivial
lemma new_lemma_63915 (h0 : topological_space (finset num)) : preirreducible_space (finset num) := sorry --non-trivial
lemma new_lemma_63916 (h0 : ordered_comm_monoid (comm_semigroup (sub_neg_monoid pos))) : has_exists_mul_of_le (comm_semigroup (sub_neg_monoid pos)) := sorry --non-trivial
lemma new_lemma_63917 (h0 : functor.add_const (semiring (has_zero unsigned)) Type) : @is_noetherian_ring.{0} (has_zero.{0} unsigned) (@functor.add_const.run.{0 1} (semiring.{0} (has_zero.{0} unsigned)) Type h0)  := sorry --non-trivial
lemma new_lemma_63918 (h0 : prod (mul_zero_class (semiring empty)) (mul_zero_class (semiring empty))) : id_rel h0 := sorry --non-trivial
lemma new_lemma_63919 (h0 : finset (cancel_monoid empty)) : finset.nonempty h0 := sorry --non-trivial
lemma new_lemma_63920 (h0 : topological_space (random_gen (has_ssubset fun_info))) : t0_space (random_gen (has_ssubset fun_info)) := sorry --non-trivial
lemma new_lemma_63921 (h1 : add_group (denumerable (comm_ring reducibility_hints))) : is_add_cyclic (denumerable (comm_ring reducibility_hints)) := sorry --non-trivial
lemma new_lemma_63922 (h0 : not (topological_space (has_star empty) -> false)) : @path_connected_space.{0} (has_star.{0} empty) (@classical.by_contradiction'.{1} (topological_space.{0} (has_star.{0} empty)) h0)  := sorry --non-trivial
lemma new_lemma_63923 (h0 : group (encodable (has_top char))) : is_cyclic (encodable (has_top char)) := sorry --non-trivial
lemma new_lemma_63924 (h0 : function.extfun Type list) : list.nodup (function.extfun_app h0 (measurable_space fun_info)) := sorry --non-trivial
lemma new_lemma_63925 (h0 : functor.add_const (functor.add_const (topological_space (ring linarith.comp)) Type) (has_zero (finset Type))) : @totally_separated_space.{0} (ring.{0} linarith.comp) (@functor.add_const.run.{0 1} (topological_space.{0} (ring.{0} linarith.comp)) Type (@functor.add_const.run.{0 1} (functor.add_const.{0 1} (topological_space.{0} (ring.{0} linarith.comp)) Type) (has_zero.{1} (finset.{1} Type)) h0))  := sorry --non-trivial
lemma new_lemma_63926 (h0 : functor.add_const (topological_space (comm_group unsigned)) environment.implicit_infer_kind) : @regular_space.{0} (comm_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (comm_group.{0} unsigned)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_63927 (h0 : ring (normed_group (random_gen (has_ssubset to_additive.value_type)))) : strong_rank_condition (normed_group (random_gen (has_ssubset to_additive.value_type))) := sorry --non-trivial
lemma new_lemma_63928 (h0 : functor.add_const (add_group (simple_graph Type)) pos) : @is_add_cyclic.{1} (simple_graph.{1} Type) (@functor.add_const.run.{1 0} (add_group.{1} (simple_graph.{1} Type)) pos h0)  := sorry --non-trivial
lemma new_lemma_63929 (h0 : functor.add_const (function.extfun Type add_group) Type) : @is_add_cyclic.{0} (complete_distrib_lattice.{0} pos) (@function.extfun_app.{2 1} Type add_group.{0} (@functor.add_const.run.{1 1} (function.extfun.{2 1} Type add_group.{0}) Type h0) (complete_distrib_lattice.{0} pos))  := sorry --non-trivial
lemma new_lemma_63930 (h0 : list (has_inv (random_gen linarith.comp_source))) : list.nodup h0 := sorry --non-trivial
lemma new_lemma_63931 (h0 : set (mul_one_class string.iterator_imp -> mul_one_class ereal)) : set.separates_points h0 := sorry --non-trivial
lemma new_lemma_63932 (h0 : topological_space (complete_distrib_lattice (option unsigned))) : t0_space (complete_distrib_lattice (option unsigned)) := sorry --non-trivial
lemma new_lemma_63933 (h0 : has_mem.mem (linear_ordered_semiring linarith.comp) has_emptyc.emptyc) : @separated_space.{0} (linear_ordered_semiring.{0} linarith.comp) (@finset.pi.empty.{1 0} Type uniform_space.{0} (linear_ordered_semiring.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_63934 : subsingleton (omega_complete_partial_order std_gen) := sorry --non-trivial
lemma new_lemma_63935 (h0 : function.extfun Type topological_space) : @t1_space.{0} (has_neg_part.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_neg_part.{0} name))  := sorry --non-trivial
lemma new_lemma_63936 (h0 : has_top linarith.comp_source -> Prop) : @infi.{0 1} Prop (@conditionally_complete_lattice.to_has_Inf.{0} Prop (@complete_lattice.to_conditionally_complete_lattice.{0} Prop Prop.complete_lattice)) (has_top.{0} linarith.comp_source) h0  := sorry --non-trivial
lemma new_lemma_63937 (h0 : ordered_add_comm_monoid (canonically_ordered_comm_semiring (has_nndist name))) : archimedean (canonically_ordered_comm_semiring (has_nndist name)) := sorry --non-trivial
lemma new_lemma_63938 (h0 : functor.add_const (monoid (has_to_string linarith.comp)) (boolean_algebra linarith.comp)) : @monoid.fg.{0} (has_to_string.{0} linarith.comp) (@functor.add_const.run.{0 0} (monoid.{0} (has_to_string.{0} linarith.comp)) (boolean_algebra.{0} linarith.comp) h0)  := sorry --non-trivial
lemma new_lemma_63939 (h0 : not (topological_space znum -> false)) : @path_connected_space.{0} znum (@classical.by_contradiction'.{1} (topological_space.{0} znum) h0)  := sorry --non-trivial
lemma new_lemma_63940 (h0 : complete_lattice (has_add (normed_comm_ring name))) : complete_lattice.is_Sup_finite_compact (has_add (normed_comm_ring name)) := sorry --non-trivial
lemma new_lemma_63941 (h0 : group (has_pos_part Type)) : group.fg (has_pos_part Type) := sorry --non-trivial
lemma new_lemma_63942 (h0 : complete_lattice (normed_comm_ring unsigned)) : complete_lattice.is_Sup_finite_compact (normed_comm_ring unsigned) := sorry --non-trivial
lemma new_lemma_63943 (h0 : topological_space (normed_lattice_add_comm_group (ordered_comm_monoid pos))) : irreducible_space (normed_lattice_add_comm_group (ordered_comm_monoid pos)) := sorry --non-trivial
lemma new_lemma_63944 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @is_cyclic.{0} (ordered_comm_group.{0} empty) (@function.extfun_app.{2 1} Type group.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 group.{0}) (ordered_comm_group.{0} empty))  := sorry --non-trivial
lemma new_lemma_63945 (h0 : complete_lattice (ring environment.implicit_infer_kind)) : is_compactly_generated (ring environment.implicit_infer_kind) := sorry --non-trivial
lemma new_lemma_63946 (h0 : topological_space (generalized_boolean_algebra (finset (ring Type)))) : regular_space (generalized_boolean_algebra (finset (ring Type))) := sorry --non-trivial
lemma new_lemma_63947 (h0 : functor.add_const (topological_space (normed_linear_ordered_group unsigned)) empty) : @topological_space.separable_space.{0} (normed_linear_ordered_group.{0} unsigned) (@functor.add_const.run.{0 0} (topological_space.{0} (normed_linear_ordered_group.{0} unsigned)) empty h0)  := sorry --non-trivial
lemma new_lemma_63948 (h0 : function.extfun Type (prod (comm_group name))) : id_rel (function.extfun_app h0 (comm_group name)) := sorry --non-trivial
lemma new_lemma_63949 (h0 : function.extfun Type (prod (add_cancel_monoid pos))) : id_rel (function.extfun_app h0 (add_cancel_monoid pos)) := sorry --non-trivial
lemma new_lemma_63950 (h0 : ring (add_cancel_monoid (comm_group (comm_group name)))) : is_domain (add_cancel_monoid (comm_group (comm_group name))) := sorry --non-trivial
lemma new_lemma_63951 (h0 : list (has_nndist (mul_zero_class name))) : palindrome h0 := sorry --non-trivial
lemma new_lemma_63952 (h0 : has_lt (semi_normed_ring char)) : no_max_order (semi_normed_ring char) := sorry --non-trivial
lemma new_lemma_63953 (h0 : function.extfun (finset (Type -> Type)) (has_mem.mem complete_lattice)) : @complete_lattice.is_Sup_finite_compact.{0} (semiring.{0} linarith.comp_source) (@function.extfun_app.{2 1} Type complete_lattice.{0} (@finset.pi.empty.{1 1} (Type → Type) (function.extfun.{2 1} Type) complete_lattice.{0} (@function.extfun_app.{2 0} (finset.{1} (Type → Type)) (@has_mem.mem.{1 1} (Type → Type) (finset.{1} (Type → Type)) (@finset.has_mem.{1} (Type → Type)) complete_lattice.{0}) h0 (@has_emptyc.emptyc.{1} (finset.{1} (Type → Type)) (@finset.has_emptyc.{1} (Type → Type))))) (semiring.{0} linarith.comp_source))  := sorry --non-trivial
lemma new_lemma_63954 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @complete_space.{1} (plift.{1} empty) (@function.extfun_app.{3 2} (Type 1) uniform_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 uniform_space.{1}) (plift.{1} empty))  := sorry --non-trivial
lemma new_lemma_63955 (h0 : functor.add_const (ring (has_add pos)) Type) : @is_principal_ideal_ring.{0} (has_add.{0} pos) (@functor.add_const.run.{0 1} (ring.{0} (has_add.{0} pos)) Type h0)  := sorry --non-trivial
lemma new_lemma_63956 (h0 : function.extfun Type add_group) : @is_add_cyclic.{0} (normed_group.{0} fun_info) (@function.extfun_app.{2 1} Type add_group.{0} h0 (normed_group.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_63957 (h0 : not (group (id congr_arg_kind) -> false)) : @group.fg.{0} (@id.{2} Type congr_arg_kind) (@classical.by_contradiction'.{1} (group.{0} (@id.{2} Type congr_arg_kind)) h0)  := sorry --non-trivial
lemma new_lemma_63958 (h1 : monoid (has_norm num)) : monoid.fg (has_norm num) := sorry --non-trivial
lemma new_lemma_63959 (h0 : filter (finset (finset linarith.comp))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_63960 (h0 : function.extfun Type list) : palindrome (function.extfun_app h0 (has_nndist environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_63961 (h0 : fin has_zero.zero) : @loc_path_connected_space.{0} (sub_neg_monoid.{0} real) (@matrix.vec_empty.{0} (topological_space.{0} (sub_neg_monoid.{0} real)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) (@matrix.vec_empty.{0} (fin (@has_zero.zero.{0} nat nat.has_zero)) h0))))  := sorry --non-trivial
lemma new_lemma_63962 (h0 : topological_space (has_top unsigned)) : path_connected_space (has_top unsigned) := sorry --non-trivial
lemma new_lemma_63963 (h3 : not (complete_lattice (with_one linarith.ineq) -> false)) : @is_compactly_generated.{0} (with_one.{0} linarith.ineq) (@classical.by_contradiction'.{1} (complete_lattice.{0} (with_one.{0} linarith.ineq)) h3)  := sorry --non-trivial
lemma new_lemma_63964 (h1 : not (topological_space (with_bot linarith.ineq) -> false)) : @t0_space.{0} (with_bot.{0} linarith.ineq) (@classical.by_contradiction'.{1} (topological_space.{0} (with_bot.{0} linarith.ineq)) h1)  := sorry --non-trivial
lemma new_lemma_63965 (h0 : topological_space (has_to_string (has_add Type))) : normal_space (has_to_string (has_add Type)) := sorry --non-trivial
lemma new_lemma_63966 (h0 : topological_space (ordered_comm_monoid (boolean_algebra.core (ring (has_add linarith.comp))))) : loc_path_connected_space (ordered_comm_monoid (boolean_algebra.core (ring (has_add linarith.comp)))) := sorry --non-trivial
lemma new_lemma_63967 (h0 : topological_space (ordered_comm_ring (has_bot pos))) : t1_space (ordered_comm_ring (has_bot pos)) := sorry --non-trivial
lemma new_lemma_63968 (h0 : group (has_norm (has_inv (random_gen (random_gen to_additive.value_type))))) : is_cyclic (has_norm (has_inv (random_gen (random_gen to_additive.value_type)))) := sorry --non-trivial
lemma new_lemma_63969 (h0 : set (distrib (mul_one_class linarith.ineq))) : set.finite h0 := sorry --non-trivial
lemma new_lemma_63970 (h0 : not (add_group (has_star unsigned) -> false)) : @is_add_cyclic.{0} (has_star.{0} unsigned) (@classical.by_contradiction'.{1} (add_group.{0} (has_star.{0} unsigned)) h0)  := sorry --non-trivial
lemma new_lemma_63971 (h0 : not (filter (fintype to_additive.value_type) -> false)) : filter.ne_bot (classical.by_contradiction' h0) := sorry --non-trivial
lemma new_lemma_63972 (h0 : functor.add_const (topological_space (left_cancel_semigroup num)) (semiring (semiring (semiring num)))) : @sequential_space.{0} (left_cancel_semigroup.{0} num) (@functor.add_const.run.{0 0} (topological_space.{0} (left_cancel_semigroup.{0} num)) (semiring.{0} (semiring.{0} (semiring.{0} num))) h0)  := sorry --non-trivial
lemma new_lemma_63973 (h0 : monoid (linear_ordered_add_comm_group (random_gen (has_norm string_imp)))) : monoid.fg (linear_ordered_add_comm_group (random_gen (has_norm string_imp))) := sorry --non-trivial
lemma new_lemma_63974 (h0 : not (function.extfun Type topological_space -> false)) : @discrete_topology.{0} (with_bot.{0} fun_info) (@function.extfun_app.{2 1} Type topological_space.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type topological_space.{0}) h0) (with_bot.{0} fun_info))  := sorry --non-trivial
lemma new_lemma_63975 (h0 : complete_lattice (normed_group (has_inv (comm_ring linarith.comp_source)))) : complete_lattice.is_Sup_finite_compact (normed_group (has_inv (comm_ring linarith.comp_source))) := sorry --non-trivial
lemma new_lemma_63976 (h0 : topological_space (with_bot (semiring empty))) : irreducible_space (with_bot (semiring empty)) := sorry --non-trivial
lemma new_lemma_63977 (h0 : topological_space (normed_group (has_norm (has_norm num)))) : path_connected_space (normed_group (has_norm (has_norm num))) := sorry --non-trivial
lemma new_lemma_63978 (h0 : functor.add_const (function.extfun nat fin) pos) : @regular_space.{0} (complete_distrib_lattice.{0} linarith.comp) (@matrix.vec_empty.{0} (topological_space.{0} (complete_distrib_lattice.{0} linarith.comp)) (@function.extfun_app.{1 1} nat fin (@functor.add_const.run.{0 0} (function.extfun.{1 1} nat fin) pos h0) (@has_zero.zero.{0} nat nat.has_zero)))  := sorry --non-trivial
lemma new_lemma_63979 (h0 : topological_space (normed_comm_ring (semigroup name))) : discrete_topology (normed_comm_ring (semigroup name)) := sorry --non-trivial
lemma new_lemma_63980 (h0 : function.extfun Type ring) : @is_domain.{0} (pseudo_metric_space.{0} ennreal) (@function.extfun_app.{2 1} Type ring.{0} h0 (pseudo_metric_space.{0} ennreal))  := sorry --non-trivial
lemma new_lemma_63981 (h0 : topological_space (has_pos_part (ordered_comm_monoid (ordered_comm_monoid Type)))) : normal_space (has_pos_part (ordered_comm_monoid (ordered_comm_monoid Type))) := sorry --non-trivial
lemma new_lemma_63982 (h0 : not (function.extfun Type add_group -> false)) : @is_add_cyclic.{0} (has_norm.{0} empty) (@function.extfun_app.{2 1} Type add_group.{0} (@classical.by_contradiction'.{2} (function.extfun.{2 1} Type add_group.{0}) h0) (has_norm.{0} empty))  := sorry --non-trivial
lemma new_lemma_63983 (h0 : function.extfun Type finset) : finset.nonempty (function.extfun_app h0 (has_zero environment.implicit_infer_kind)) := sorry --non-trivial
lemma new_lemma_63984 (h0 : functor.add_const (monoid (semigroup unsigned)) unsigned) : @monoid.fg.{0} (semigroup.{0} unsigned) (@functor.add_const.run.{0 0} (monoid.{0} (semigroup.{0} unsigned)) unsigned h0)  := sorry --non-trivial
lemma new_lemma_63985 (h0 : function.extfun (Type -> Type) (function.extfun Type)) : @loc_path_connected_space.{0} (boolean_algebra.core.{0} name) (@function.extfun_app.{2 1} Type topological_space.{0} (@function.extfun_app.{2 2} (Type → Type) (function.extfun.{2 1} Type) h0 topological_space.{0}) (boolean_algebra.core.{0} name))  := sorry --non-trivial
lemma new_lemma_63986 (h0 : fintype std_gen -> fintype std_gen -> fintype std_gen) : is_commutative (fintype std_gen) h0 := sorry --non-trivial
lemma new_lemma_63987 (h0 : function.extfun Type ring) : @rank_condition.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} num)))))) (@function.extfun_app.{2 1} Type ring.{0} h0 (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} (random_gen.{0} num)))))))  := sorry --non-trivial
lemma new_lemma_63988 (h0 : functor.add_const (group (add_cancel_monoid pos)) environment.implicit_infer_kind) : @is_cyclic.{0} (add_cancel_monoid.{0} pos) (@functor.add_const.run.{0 0} (group.{0} (add_cancel_monoid.{0} pos)) environment.implicit_infer_kind h0)  := sorry --non-trivial
lemma new_lemma_63989 (h1 : function.extfun Type group) : @is_cyclic.{0} (with_bot.{0} string_imp) (@function.extfun_app.{2 1} Type group.{0} h1 (with_bot.{0} string_imp))  := sorry --non-trivial
lemma new_lemma_63990 (h0 : ring (has_zero (comm_group (has_to_string unsigned)))) : strong_rank_condition (has_zero (comm_group (has_to_string unsigned))) := sorry --non-trivial
lemma new_lemma_63991 (h0 : complete_lattice (id (has_top fun_info))) : is_atomistic (id (has_top fun_info)) := sorry --non-trivial
lemma new_lemma_63992 (h0 : function.extfun (Type 1 -> Type 1) (function.extfun (Type 1))) : @t1_space.{1} (finset.{1} Type) (@function.extfun_app.{3 2} (Type 1) topological_space.{1} (@function.extfun_app.{3 3} (Type 1 → Type 1) (function.extfun.{3 2} (Type 1)) h0 topological_space.{1}) (finset.{1} Type))  := sorry --non-trivial
lemma new_lemma_63993 (h0 : topological_space (mul_zero_class (semiring congr_arg_kind))) : discrete_topology (mul_zero_class (semiring congr_arg_kind)) := sorry --non-trivial
lemma new_lemma_63994 (h0 : function.extfun Type ring) : @strong_rank_condition.{0} (has_nndist.{0} environment.implicit_infer_kind) (@function.extfun_app.{2 1} Type ring.{0} h0 (has_nndist.{0} environment.implicit_infer_kind))  := sorry --non-trivial
lemma new_lemma_63995 (h0 : ordered_comm_monoid (has_to_string (semigroup Type))) : has_exists_mul_of_le (has_to_string (semigroup Type)) := sorry --non-trivial
lemma new_lemma_63996 (h0 : function.extfun Type topological_space) : @locally_compact_space.{0} (has_norm.{0} linarith.comp) (@function.extfun_app.{2 1} Type topological_space.{0} h0 (has_norm.{0} linarith.comp))  := sorry --non-trivial
lemma new_lemma_63997 (h0 : filter (cancel_monoid (option unsigned))) : filter.ne_bot h0 := sorry --non-trivial
lemma new_lemma_63998 (h0 : complete_lattice (finset Type)) : is_atomistic (finset Type) := sorry --non-trivial
lemma new_lemma_63999 (h3 : topological_space (distrib to_additive.value_type)) : path_connected_space (distrib to_additive.value_type) := sorry --non-trivial
